KERNEL32._hread(
 HFILE hFile, ; handle to file
 LPVOID lpBuffer, ; read data buffer
 long lBytes ; length of read data buffer
)
KERNEL32._hwrite(
 HFILE hFile, ; handle to file
 LPCSTR lpBuffer, ; write data buffer
 long lBytes ; number of bytes to write
)
KERNEL32._lclose(
 HFILE hFile ; handle to file
)
KERNEL32._lcreat(
 LPCSTR lpPathName, ; pointer to name of file to open
 int iAttribute ; file attribute
)
KERNEL32._llseek(
 HFILE hFile, ; handle to file
 LONG lOffset, ; number of bytes to move
 int iOrigin ; starting position
)
KERNEL32._lopen(
 LPCSTR lpPathName, ; pointer to name of file to open
 int iReadWrite ; file access mode
)
KERNEL32._lread(
 HFILE hFile, ; handle to file
 LPVOID lpBuffer, ; pointer to buffer for read data
 UINT uBytes ; length, in bytes, of data buffer
)
KERNEL32._lwrite(
 HFILE hFile, ; handle to file
 LPCSTR lpBuffer, ; write data buffer
 UINT uBytes ; number of bytes to write
)
xxxx._TrackMouseEvent
)
AbnormalTermination(VOID)
)
GDI32.AbortDoc(
 HDC hdc ; handle to DC
)
GDI32.AbortPath(
 HDC hdc ; handle to DC
)
WINSPOOL.AbortPrinter(
 HANDLE hPrinter ; handle to printer object
)
USER-DEFINED.AbortProc(
 HDC hdc, ; handle to DC
 int iError ; error value
)
ADVAPI32.AbortSystemShutdown(
 LPTSTR lpMachineName ; computer name
)
USER-DEFINED.ABProviderInit(
 HINSTANCE hInstance,
 LPMALLOC lpMalloc,
 LPALLOCATEBUFFER lpAllocateBuffer,
 LPALLOCATEMORE lpAllocateMore,
 LPFREEBUFFER lpFreeBuffer,
 ULONG ulFlags,
 ULONG ulMAPIVer,
 ULONG FAR * lpulProviderVer,
 LPABPROVIDER FAR * lppABProvider
)
MAPI32.ACCELERATEABSDI(
 ULONG ulUIParam,
 LPVOID lpvmsg
)
KERNEL32.AddAtomA(
 LPCTSTR lpString ; string to add
)
GDI32.AddFontMemResourceEx(
 PVOID pbFont, ; font resource
 DWORD cbFont, ; number of bytes in font resource
 PVOID pdv, ; Reserved. Must be 0.
 DWORD *pcFonts ; number of fonts installed
)
GDI32.AddFontResourceA(
 LPCTSTR lpszFilename ; font file name
)
GDI32.AddFontResourceExA(
 LPCTSTR lpszFilename, ; font file name
 DWORD fl, ; font characteristics
 PVOID pdv ; reserved
)
WINSPOOL.AddFormA(
 HANDLE hPrinter, ; handle to printer object
 DWORD Level, ; data-structure level
 LPBYTE pForm ; form information buffer
)
USER-DEFINED.AddInterface(
 LPWSTR InterfaceName, ; name of the interface
 ULONG InterfaceIndex, ; index for the interface
 NET_INTERFACE_TYPE InterfaceType, ; type of the interface
 DWORD MediaType,
 WORD AccessType,
 WORD ConnectionType,
 PVOID InterfaceInfo, ; interface information block
 ULONG StructureVersion,
 ULONG StructureSize,
 ULONG StructureCount
)
WINSPOOL.AddJobA(
 HANDLE hPrinter, ; handle to printer
 DWORD Level, ; print job information version
 LPBYTE pData, ; job information buffer
 DWORD cbBuf, ; size of job information buffer
 LPDWORD pcbNeeded ; bytes received or required
)
WINSPOOL.AddMonitorA(
 LPTSTR pName, ; server name
 DWORD Level, ; monitor information level
 LPBYTE pMonitors ; monitor information buffer
)
WINSPOOL.AddPortA(
 LPTSTR pName, ; server name
 HWND hWnd, ; handle to parent window
 LPTSTR pMonitorName ; monitor name
)
WINSPOOL.AddPrinterA(
 LPTSTR pName, ; server name
 DWORD Level, ; printer information level
 LPBYTE pPrinter ; printer information buffer
)
WINSPOOL.AddPrinterConnectionA(
 LPTSTR pName ; printer name
)
WINSPOOL.AddPrinterDriverA(
 LPTSTR pName, ; server name
 DWORD Level, ; driver information level
 LPBYTE pDriverInfo ; driver information buffer
)
WINSPOOL.AddPrinterDriverExA(
 LPTSTR pName, ; server name
 DWORD Level, ; driver information level
 LPBYTE pDriverInfo, ; driver information buffer
 DWORD dwFileCopyFlags ; copy options
)
WINSPOOL.AddPrintProcessorA(
 LPTSTR pName, ; server name
 LPTSTR pEnvironment, ; environment name
 LPTSTR pPathName, ; path
 LPTSTR pPrintProcessorName ; print-processor name
)
WINSPOOL.AddPrintProvidorA(
 LPTSTR pName, ; reserved, must be NULL
 DWORD Level, ; provider information level
 LPBYTE pProviderInfo ; provider information buffer
)
USER-DEFINED.AddPropSheetPageProc(
 HPROPSHEETPAGE hpage,
 LPARAM lParam
)
xxxx.AddUsersToEncryptedFile(
 LPCWSTR lpFileName, ; file name
 PENCRYPTION_CERTIFICATE_LIST pUsers ; user keys
)
xxxx.AddVectoredExceptionHandler(
 ULONG FirstHandler,
 PVECTORED_EXCEPTION_HANDLER VectoredHandler
)
USER32.AdjustWindowRect(
 LPRECT lpRect, ; client-rectangle structure
 DWORD dwStyle, ; window styles
 BOOL bMenu ; menu-present option
)
USER32.AdjustWindowRectEx(
 LPRECT lpRect, ; client-rectangle structure
 DWORD dwStyle, ; window styles
 BOOL bMenu, ; menu-present option
 DWORD dwExStyle ; extended window style
)
xxxx.ADsPropCheckIfWritable(
 const PWSTR pwzAttr,
 const PADS_ATTR_INFO pWritableAttrs
)
xxxx.ADsPropCreateNotifyObj(
 LPDATAOBJECT pAppThdDataObj,
 PWSTR pwzADsObjName,
 HWND *phNotifyObj
)
xxxx.ADsPropGetInitInfo(
 HWND hNotifyObject,
 PADSPROPINITPARAMS pInitParams
)
xxxx.ADsPropSetHwnd(
 HWND hNotifyObject,
 HWND hPage,
 PTSTR ptzTitle
)
WINSPOOL.AdvancedDocumentPropertiesA(
 HWND hWnd, ; handle to parent window
 HANDLE hPrinter, ; handle to printer object
 LPTSTR pDeviceName, ; driver name
 PDEVMODE pDevModeOutput, ; modified device mode data
 PDEVMODE pDevModeInput ; original device mode data
)
xxxx.AllocateUserPhysicalPages(
 HANDLE hProcess, ; handle to process
 PULONG_PTR NumberOfPages, ; number of pages
 PULONG_PTR UserPfnArray ; address of storage
)
KERNEL32.AllocConsole(VOID)
AllowSetForegroundWindow(
 DWORD dwProcessId ; process identifier
)
MSIMG32.AlphaBlend(
 HDC hdcDest, ; handle to destination DC
 int nXOriginDest, ; x-coord of upper-left corner
 int nYOriginDest, ; y-coord of upper-left corner
 int nWidthDest, ; destination width
 int nHeightDest, ; destination height
 HDC hdcSrc, ; handle to source DC
 int nXOriginSrc, ; x-coord of upper-left corner
 int nYOriginSrc, ; y-coord of upper-left corner
 int nWidthSrc, ; source width
 int nHeightSrc, ; source height
 BLENDFUNCTION blendFunction ; alpha-blending function
)
GDI32.AngleArc(
 HDC hdc, ; handle to device context
 int X, ; x-coordinate of circle's center
 int Y, ; y-coordinate of circle's center
 DWORD dwRadius, ; circle's radius
 FLOAT eStartAngle, ; arc's start angle
 FLOAT eSweepAngle ; arc's sweep angle
)
GDI32.AnimatePalette(
 HPALETTE hpal, ; handle to logical palette
 UINT iStartIndex, ; first entry in logical palette
 UINT cEntries, ; number of entries
 CONST PALETTEENTRY *ppe ; first replacement
)
USER32.AnimateWindow(
 HWND hwnd, ; handle to window
 DWORD dwTime, ; duration of animation
 DWORD dwFlags ; animation type
)
xxxx.AnsiLower(OBSOLETE - Use CharLower)
)
AnsiLowerBuff(OBSOLETE - Use CharLowerBuff)
)
AnsiNext(OBSOLETE - Use CharNext)
)
AnsiPrev(OBSOLETE - Use CharPrev)
)
AnsiToOem(OBSOLETE - Use CharToOem)
)
AnsiToOemBuff(OBSOLETE - Use CharToOemBuff)
)
AnsiUpper(OBSOLETE - Use CharUpper)
)
AnsiUpperBuff(OBSOLETE - Use CharUpperBuff)
)
USER32.AnyPopup(VOID)
)
APCProc(
 ULONG_PTR dwParam
)
USER32.AppendMenuA(
 HMENU hMenu, ; handle to menu
 UINT uFlags, ; menu-item options
 UINT_PTR uIDNewItem, ; identifier, menu, or submenu
 LPCTSTR lpNewItem ; menu-item content
)
GDI32.Arc(
 HDC hdc, ; handle to device context
 int nLeftRect, ; x-coord of rectangle's upper-left corner
 int nTopRect, ; y-coord of rectangle's upper-left corner
 int nRightRect, ; x-coord of rectangle's lower-right corner
 int nBottomRect, ; y-coord of rectangle's lower-right corner
 int nXStartArc, ; x-coord of first radial ending point
 int nYStartArc, ; y-coord of first radial ending point
 int nXEndArc, ; x-coord of second radial ending point
 int nYEndArc ; y-coord of second radial ending point
)
GDI32.ArcTo(
 HDC hdc, ; handle to device context
 int nLeftRect, ; x-coord of rectangle's upper-left corner
 int nTopRect, ; y-coord of rectangle's upper-left corner
 int nRightRect, ; x-coord of rectangle's lower-right corner
 int nBottomRect, ; y-coord of rectangle's lower-right corner
 int nXRadial1, ; x-coord of first radial ending point
 int nYRadial1, ; y-coord of first radial ending point
 int nXRadial2, ; x-coord of second radial ending point
 int nYRadial2 ; y-coord of second radial ending point
)
KERNEL32.AreFileApisANSI(VOID)
ArrangeIconicWindows(
 HWND hWnd ; handle to parent window
)
KERNEL32.AssignProcessToJobObject(
 HANDLE hJob, ; handle to job
 HANDLE hProcess ; handle to process
)
xxxx.AssocCreate(
 CLSID clsid,
 REFIID riid,
 LPVOID *pqa
)
xxxx.AssocQueryKey(
 ASSOCF flags,
 ASSOCKEY key,
 LPCTSTR pszAssoc,
 LPCTSTR pszExtra,
 HKEY *phkeyOut
)
xxxx.AssocQueryString(
 ASSOCF flags,
 ASSOCSTR str,
 LPCTSTR pszAssoc,
 LPCTSTR pszExtra,
 LPTSTR pszOut,
 DWORD *pcchOut
)
xxxx.AssocQueryStringByKey(
 ASSOCF flags,
 ASSOCSTR str,
 HKEY hkAssoc,
 LPCTSTR pszExtra,
 LPTSTR pszOut,
 DWORD *pcchOut
)
USER32.AttachThreadInput(
 DWORD idAttach, ; thread to attach
 DWORD idAttachTo, ; thread to attach to
 BOOL fAttach ; attach or detach
)
ADVAPI32.BackupEventLogA(
 HANDLE hEventLog, ; handle to event log
 LPCTSTR lpBackupFileName ; name of backup file
)
KERNEL32.BackupRead(
 HANDLE hFile, ; handle to file or directory
 LPBYTE lpBuffer, ; read buffer
 DWORD nNumberOfBytesToRead, ; number of bytes to read
 LPDWORD lpNumberOfBytesRead, ; number of bytes read
 BOOL bAbort, ; termination type
 BOOL bProcessSecurity, ; process security options
 LPVOID *lpContext ; context information
)
KERNEL32.BackupSeek(
 HANDLE hFile, ; handle to file
 DWORD dwLowBytesToSeek, ; low-order DWORD of number of bytes
 DWORD dwHighBytesToSeek, ; high-order DWORD of number of bytes
 LPDWORD lpdwLowByteSeeked, ; number of bytes to forward
 LPDWORD lpdwHighByteSeeked, ; number of bytes forwarded
 LPVOID *lpContext ; context information
)
KERNEL32.BackupWrite(
 HANDLE hFile, ; handle to file or directory
 LPBYTE lpBuffer, ; write buffer
 DWORD nNumberOfBytesToWrite, ; number of bytes to write
 LPDWORD lpNumberOfBytesWritten, ; number of bytes written
 BOOL bAbort, ; termination type
 BOOL bProcessSecurity, ; process security
 LPVOID *lpContext ; context information
)
KERNEL32.Beep(
 DWORD dwFreq, ; sound frequency
 DWORD dwDuration ; sound duration
)
USER32.BeginDeferWindowPos(
 int nNumWindows ; number of windows
)
USER32.BeginPaint(
 HWND hwnd, ; handle to window
 LPPAINTSTRUCT lpPaint ; paint information
)
GDI32.BeginPath(
 HDC hdc ; handle to DC
)
KERNEL32.BeginUpdateResourceA(
 LPCTSTR pFileName, ; executable file name
 BOOL bDeleteExistingResources ; deletion option
)
xxxx.ber_alloc_t(
 INT iOptions
)
xxxx.ber_bvdup(
 BERVAL *pBerVal
)
xxxx.ber_bvecfree(
 PBERVAL *pBerVal
)
xxxx.ber_bvfree(
 BERVAL *pBerVal
)
xxxx.ber_first_element(
 BerElement *pBerElement,
 ULONG *pLen,
 CHAR **ppOpaque
)
xxxx.ber_flatten(
 BerElement *pBerElement,
 PBERVAL *pBerVal
)
xxxx.ber_free(
 BerElement *pBerElement,
 INT fbuf
)
xxxx.ber_init(
 BERVAL *pBerVal
)
xxxx.ber_next_element(
 BerElement *pBerElement,
 ULONG *pLen,
 CHAR *pOpaque
)
xxxx.ber_peek_tag(
 BerElement *pBerElement,
 ULONG *pLen
)
xxxx.ber_printf(
 BerElement *pBerElement,
 PCHAR fmt,
 ...
)
xxxx.ber_scanf(
 BerElement *pBerElement,
 PCHAR fmt,
 ...
)
xxxx.ber_skip_tag(
 BerElement *pBerElement,
 ULONG *pLen
)
xxxx.BFFCallBack(
 HWND hwnd,
 UINT umsg,
 LPARAM lParam,
 LPARAM lpData
)
xxxx.BindIoCompletionCallback(
 HANDLE FileHandle, ; handle to file
 LPOVERLAPPED_COMPLETION_ROUTINE Function, ; callback
 ULONG Flags ; reserved
)
GDI32.BitBlt(
 HDC hdcDest, ; handle to destination DC
 int nXDest, ; x-coord of destination upper-left corner
 int nYDest, ; y-coord of destination upper-left corner
 int nWidth, ; width of destination rectangle
 int nHeight, ; height of destination rectangle
 HDC hdcSrc, ; handle to source DC
 int nXSrc, ; x-coordinate of source upper-left corner
 int nYSrc, ; y-coordinate of source upper-left corner
 DWORD dwRop ; raster operation code
)
USER-DEFINED.BlockConvertServicesToStatic(
 ULONG InterfaceIndex
)
USER-DEFINED.BlockDeleteStaticServices(
 ULONG InterfaceIndex
)
USER32.BringWindowToTop(
 HWND hWnd ; handle to window
)
USER32.BroadcastSystemMessageA(
 DWORD dwFlags, ; broadcast option
 LPDWORD lpdwRecipients, ; recipients
 UINT uiMessage, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
USER32.BroadcastSystemMessageEx(
 DWORD dwFlags, ; broadcast option
 LPDWORD lpdwRecipients, ; recipients
 UINT uiMessage, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam, ; second message parameter
 PBSMINFO pBSMInfo ; additional information
)
USER-DEFINED.BrowseCallbackProc(
 HWND hwnd,
 UINT uMsg,
 LPARAM lParam,
 LPARAM lpData
)
KERNEL32.BuildCommDCB(
 LPCTSTR lpDef, ; device-control string
 LPDCB lpDCB ; device-control block
)
KERNEL32.BuildCommDCBAndTimeoutsA(
 LPCTSTR lpDef, ; device-control string
 LPDCB lpDCB, ; device-control block
 LPCOMMTIMEOUTS lpCommTimeouts ; device time-out values
)
MAPI32.BuildDisplayTable(
 LPALLOCATEBUFFER lpAllocateBuffer,
 LPALLOCATEMORE lpAllocateMore,
 LPFREEBUFFER lpFreeBuffer,
 LPMALLOC lpMalloc,
 HINSTANCE hInstance,
 UINT cPages,
 LPDTPAGE lpPage,
 ULONG ulFlags,
 LPMAPITABLE * lppTable,
 LPTABLEDATA * lppTblData
)
xxxx.CalcMenuBar(
 HWND hwnd, ; window handle
 int iLeftOffset, ; offset from left edge
 int iRightOffset, ; offset from right edge
 int iTopOffset ; offset from top edge
)
USER-DEFINED.CALLERRELEASE(
 ULONG ulCallerData,
 LPTABLEDATA lpTblData,
 LPMAPITABLE lpVue
)
USER-DEFINED.CCHookProc(
 HWND hdlg, ; handle to dialog box
 UINT uiMsg, ; message identifier
 WPARAM wParam, ; message parameter
 LPARAM lParam ; message parameter
)
USER-DEFINED.CFHookProc(
 HWND hdlg, ; handle to dialog box
 UINT uiMsg, ; message identifier
 WPARAM wParam, ; message parameter
 LPARAM lParam ; message parameter
)
USER32.CallMsgFilter(
 LPMSG lpMsg, ; message data
 int nCode ; hook code
)
KERNEL32.CallNamedPipe(
 LPCTSTR lpNamedPipeName, ; pipe name
 LPVOID lpInBuffer, ; write buffer
 DWORD nInBufferSize, ; size of write buffer
 LPVOID lpOutBuffer, ; read buffer
 DWORD nOutBufferSize, ; size of read buffer
 LPDWORD lpBytesRead, ; number of bytes read
 DWORD nTimeOut ; time-out value
)
USER32.CallNextHookEx(
 HHOOK hhk, ; handle to current hook
 int nCode, ; hook code passed to hook procedure
 WPARAM wParam, ; value passed to hook procedure
 LPARAM lParam ; value passed to hook procedure
)
USER32.CallWindowProc(
 WNDPROC lpPrevWndFunc, ; pointer to previous procedure
 HWND hWnd, ; handle to window
 UINT Msg, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
USER-DEFINED.CallWndProc(
 int nCode, ; hook code
 WPARAM wParam, ; current-process flag
 LPARAM lParam ; message data
)
USER-DEFINED.CallWndRetProc(
 int nCode, ; hook code
 WPARAM wParam, ; current-process flag
 LPARAM lParam ; message data
)
GDI32.CancelDC(
 HDC hdc ; handle to DC
)
KERNEL32.CancelIo(
 HANDLE hFile ; handle to file
)
KERNEL32.CancelWaitableTimer(
 HANDLE hTimer ; handle to timer
)
USER32.CascadeWindows(
 HWND hwndParent, ; handle to parent window
 UINT wHow, ; types of windows not to arrange
 CONST RECT *lpRect, ; rectangle to arrange windows in
 UINT cKids, ; number of windows to arrange
 const HWND *lpKids ; array of window handles
)
USER-DEFINED.CBTProc(
 int nCode, ; hook code
 WPARAM wParam, ; depends on hook code
 LPARAM lParam ; depends on hook code
)
USER32.ChangeClipboardChain(
 HWND hWndRemove, ; handle to window to remove
 HWND hWndNewNext ; handle to next window
)
USER32.ChangeDisplaySettings(
 LPDEVMODE lpDevMode, ; graphics mode
 DWORD dwflags ; graphics mode options
)
USER32.ChangeDisplaySettingsEx(
 LPCTSTR lpszDeviceName, ; name of display device
 LPDEVMODE lpDevMode, ; graphics mode
 HWND hwnd, ; not used; must be NULL
 DWORD dwflags, ; graphics mode options
 LPVOID lParam ; video parameters (or NULL)
)
MAPI32.ChangeIdleRoutine(
 FTG ftg,
 PFNIDLE pfnIdle,
 LPVOID pvIdleParam,
 short priIdle,
 ULONG csecIdle,
 USHORT iroIdle,
 USHORT ircIdle
)
ADVAPI32.ChangeServiceConfig2A(
 SC_HANDLE hService, ; handle to service
 DWORD dwInfoLevel, ; information level
 LPVOID lpInfo ; new data
)
ADVAPI32.ChangeServiceConfigA(
 SC_HANDLE hService, ; handle to service
 DWORD dwServiceType, ; type of service
 DWORD dwStartType, ; when to start service
 DWORD dwErrorControl, ; severity of start failure
 LPCTSTR lpBinaryPathName, ; service binary file name
 LPCTSTR lpLoadOrderGroup, ; load ordering group name
 LPDWORD lpdwTagId, ; tag identifier
 LPCTSTR lpDependencies, ; array of dependency names
 LPCTSTR lpServiceStartName, ; account name
 LPCTSTR lpPassword, ; account password
 LPCTSTR lpDisplayName ; display name
)
xxxx.ChangeTimerQueueTimer(
 HANDLE TimerQueue, ; handle to timer queue
 HANDLE Timer, ; handle to timer
 ULONG DueTime, ; timer due time
 ULONG Period ; timer period
)
USER32.CharLowerA(
 LPTSTR lpsz ; single character or string
)
USER32.CharLowerBuffA(
 LPTSTR lpsz, ; characters
 DWORD cchLength ; number of characters to process
)
USER32.CharNextA(
 LPCTSTR lpsz ; current character
)
USER32.CharNextExA(
 WORD CodePage, ; code page identifier
 LPCSTR lpCurrentChar, ; current character
 DWORD dwFlags ; reserved; must be zero
)
USER32.CharPrevA(
 LPCTSTR lpszStart, ; first character
 LPCTSTR lpszCurrent ; current character
)
USER32.CharPrevExA(
 WORD CodePage, ; identifier of code page
 LPCSTR lpStart, ; first character
 LPCSTR lpCurrentChar, ; current character
 DWORD dwFlags ; reserved; must be zero
)
USER32.CharToOemA(
 LPCTSTR lpszSrc, ; string to translate
 LPSTR lpszDst ; translated string
)
USER32.CharToOemBuffA(
 LPCTSTR lpszSrc, ; string to translate
 LPSTR lpszDst, ; translated string
 DWORD cchDstLength ; length of string to translate
)
USER32.CharUpperA(
 LPTSTR lpsz ; single character or string
)
USER32.CharUpperBuffA(
 LPTSTR lpsz, ; characters
 DWORD cchLength ; number of characters to process
)
USER32.CheckDlgButton(
 HWND hDlg, ; handle to dialog box
 int nIDButton, ; button identifier
 UINT uCheck ; check state
)
USER32.CheckMenuItem(
 HMENU hmenu, ; handle to menu
 UINT uIDCheckItem, ; menu item to check or uncheck
 UINT uCheck ; menu item options
)
USER32.CheckMenuRadioItem(
 HMENU hmenu, ; handle to menu
 UINT idFirst, ; identifier or position of first item
 UINT idLast, ; identifier or position of last item
 UINT idCheck, ; identifier or position of menu item
 UINT uFlags ; function options
)
MAPI32.CheckParameters(
 METHODS eMethod,
 LPVOID First
)
MAPI32.CheckParms(
 METHODS eMethod,
 LPVOID First
)
USER32.CheckRadioButton(
 HWND hDlg, ; handle to dialog box
 int nIDFirstButton, ; identifier of first button in group
 int nIDLastButton, ; identifier of last button in group
 int nIDCheckButton ; identifier of button to select
)
USER32.ChildWindowFromPoint(
 HWND hWndParent, ; handle to parent window
 POINT Point ; structure with point coordinates
)
USER32.ChildWindowFromPointEx(
 HWND hwndParent, ; handle to parent window
 POINT pt, ; structure with point coordinates
 UINT uFlags ; skip options
)
COMDLG32.ChooseColorA(
 LPCHOOSECOLOR lpcc ; initialization data
)
COMDLG32.ChooseFontA(
 LPCHOOSEFONT lpcf ; initialization data
)
GDI32.Chord(
 HDC hdc, ; handle to DC
 int nLeftRect, ; x-coord of upper-left corner of rectangle
 int nTopRect, ; y-coord of upper-left corner of rectangle
 int nRightRect, ; x-coord of lower-right corner of rectangle
 int nBottomRect, ; y-coord of lower-right corner of rectangle
 int nXRadial1, ; x-coord of first radial's endpoint
 int nYRadial1, ; y-coord of first radial's endpoint
 int nXRadial2, ; x-coord of second radial's endpoint
 int nYRadial2 ; y-coord of second radial's endpoint
)
xxxx.ChrCmpIA(
 WORD w1,
 WORD w2
)
xxxx.ChrCmpIW(
 WCHAR w1,
 WCHAR w2
)
xxxx.cldap_open(
 PCHAR HostName,
 ULONG PortNumber
)
KERNEL32.ClearCommBreak(
 HANDLE hFile ; handle to communications device
)
KERNEL32.ClearCommError(
 HANDLE hFile, ; handle to communications device
 LPDWORD lpErrors, ; error codes
 LPCOMSTAT lpStat ; communications status
)
ADVAPI32.ClearEventLogA(
 HANDLE hEventLog, ; handle to event log
 LPCTSTR lpBackupFileName ; name of backup file
)
USER32.ClientToScreen(
 HWND hWnd, ; handle to window
 LPPOINT lpPoint ; screen coordinates
)
USER32.ClipCursor(
 CONST RECT *lpRect ; screen coordinates
)
USER32.CloseClipboard(VOID)
)
USER32.CloseDesktop(
 HDESK hDesktop ; handle to desktop
)
GDI32.CloseEnhMetaFile(
 HDC hdc ; handle to enhanced-metafile DC
)
ADVAPI32.CloseEventLog(
 HANDLE hEventLog ; handle to event log
)
GDI32.CloseFigure(
 HDC hdc ; handle to DC
)
KERNEL32.CloseHandle(
 HANDLE hObject ; handle to object
)
MAPI32.CloseIMsgSession(
 LPMSGSESS lpMsgSess
)
GDI32.CloseMetaFile(
 HDC hdc ; handle to Windows-metafile DC
)
WINSPOOL.ClosePrinter(
 HANDLE hPrinter ; handle to printer object
)
USER-DEFINED.CloseServiceEnumerationHandle(
 HANDLE EnumerationHandle
)
ADVAPI32.CloseServiceHandle(
 SC_HANDLE hSCObject ; handle to service or SCM object
)
USER32.CloseWindow(
 HWND hWnd ; handle to window to minimize
)
USER32.CloseWindowStation(
 HWINSTA hWinSta ; handle to window station
)
xxxx.cmc_act_on(
 CMC_session_id session,
 CMC_message_reference * message_reference,
 CMC_enum operation,
 CMC_flags act_on_flags,
 CMC_ui_id ui_id,
 CMC_extension FAR * act_on_extensions
)
xxxx.cmc_free(
 CMC_buffer memory
)
xxxx.cmc_list(
 CMC_session_id session,
 CMC_string message_type,
 CMC_flags list_flags,
 CMC_message_reference * seed,
 CMC_uint32 FAR * count,
 CMC_ui_id ui_id,
 CMC_message_summary FAR * FAR * result,
 CMC_extension FAR * list_extensions
)
xxxx.cmc_logoff(
 CMC_session_id session,
 CMC_ui_id ui_id,
 CMC_flags logoff_flags,
 CMC_extension FAR * logoff_extensions
)
xxxx.cmc_logon(
 CMC_string service,
 CMC_string user,
 CMC_string password,
 CMC_object_identifier character_set,
 CMC_ui_id ui_id,
 CMC_uint16 caller_CMC_version,
 CMC_flags logon_flags,
 CMC_session_id FAR * session,
 CMC_extension FAR * logon_extensions
)
xxxx.cmc_look_up(
 CMC_session_id session,
 CMC_recipient FAR * recipient_in,
 CMC_flags look_up_flags,
 CMC_ui_id ui_id,
 CMC_uint32 FAR * count,
 CMC_recipient FAR * FAR * recipient_out,
 CMC_extension FAR * look_up_extensions
)
xxxx.cmc_query_configuration(
 CMC_session_id session,
 CMC_enum item,
 CMC_buffer reference,
 CMC_extension FAR * config_extensions
)
xxxx.cmc_read(
 CMC_session_id session,
 CMC_message_reference * message_reference,
 CMC_flags read_flags,
 CMC_message FAR * FAR * message,
 CMC_ui_id ui_id,
 CMC_extension FAR * read_extensions
)
xxxx.cmc_send(
 CMC_session_id session,
 CMC_message FAR * message,
 CMC_flags send_flags,
 CMC_ui_id ui_id,
 CMC_extension FAR s* send_extensions
)
xxxx.cmc_send_documents(
 CMC_string recipient_addresses,
 CMC_string subject,
 CMC_string text_note,
 CMC_flags send_doc_flags,
 CMC_string file_paths,
 CMC_string file_names,
 CMC_string delimiter,
 CMC_ui_id ui_id
)
xxxx.ColorAdjustLuma(
 COLORREF clrRGB,
 int n,
 BOOL fScale
)
xxxx.ColorHLSToRGB(
 WORD wHue,
 WORD wLuminance,
 WORD wSaturation
)
xxxx.ColorRGBToHLS(
 COLORREF clrRGB,
 WORD *pwHue,
 WORD *pwLuminance,
 WORD *pwSaturation
)
GDI32.CombineRgn(
 HRGN hrgnDest, ; handle to destination region
 HRGN hrgnSrc1, ; handle to source region
 HRGN hrgnSrc2, ; handle to source region
 int fnCombineMode ; region combining mode
)
GDI32.CombineTransform(
 LPXFORM lpxformResult, ; combined transformation
 CONST XFORM *lpxform1, ; first transformation
 CONST XFORM *lpxform2 ; second transformation
)
SHELL32.CommandLineToArgvW(
 LPCWSTR lpCmdLine, ; pointer to a command-line string
 int *pNumArgs ; receives the argument count
)
KERNEL32.CommConfigDialogA(
 LPCTSTR lpszName, ; device name string
 HWND hWnd, ; handle to window
 LPCOMMCONFIG lpCC ; configuration information
)
COMDLG32.CommDlgExtendedError(VOID)
CompareFileTime(
 CONST FILETIME *lpFileTime1, ; first file time
 CONST FILETIME *lpFileTime2 ; second file time
)
KERNEL32.CompareStringA(
 LCID Locale, ; locale identifier
 DWORD dwCmpFlags, ; comparison-style options
 LPCTSTR lpString1, ; first string
 int cchCount1, ; size of first string
 LPCTSTR lpString2, ; second string
 int cchCount2 ; size of second string
)
WINSPOOL.ConfigurePortA(
 LPTSTR pName, ; server name
 HWND hWnd, ; handle to parent window
 LPTSTR pPortName ; port name
)
xxxx.ConnectClient(
 ULONG InterfaceIndex,
 PVOID ClientAddress
)
KERNEL32.ConnectNamedPipe(
 HANDLE hNamedPipe, ; handle to named pipe
 LPOVERLAPPED lpOverlapped ; overlapped structure
)
WINSPOOL.ConnectToPrinterDlg(
 HWND hwnd, ; handle to parent window
 DWORD Flags ; reserved; must be zero
)
KERNEL32.ContinueDebugEvent(
 DWORD dwProcessId, ; process to continue
 DWORD dwThreadId, ; thread to continue
 DWORD dwContinueStatus ; continuation status
)
ADVAPI32.ControlService(
 SC_HANDLE hService, ; handle to service
 DWORD dwControl, ; control code
 LPSERVICE_STATUS lpServiceStatus ; status information
)
KERNEL32.ConvertDefaultLocale(
 LCID Locale ; default locale
)
KERNEL32.ConvertThreadToFiber(
 LPVOID lpParameter ; fiber data for new fiber
)
USER32.CopyAcceleratorTableA(
 HACCEL hAccelSrc, ; handle to accelerator table
 LPACCEL lpAccelDst, ; information buffer
 int cAccelEntries ; number of entries in buffer
)
USER32.CopyCursor(
 HCURSOR pcur ; handle to cursor
)
GDI32.CopyEnhMetaFileA(
 HENHMETAFILE hemfSrc, ; handle to enhanced metafile
 LPCTSTR lpszFile ; file name
)
KERNEL32.CopyFileA(
 LPCTSTR lpExistingFileName, ; name of an existing file
 LPCTSTR lpNewFileName, ; name of new file
 BOOL bFailIfExists ; operation if file exists
)
KERNEL32.CopyFileExA(
 LPCTSTR lpExistingFileName, ; name of existing file
 LPCTSTR lpNewFileName, ; name of new file
 LPPROGRESS_ROUTINE lpProgressRoutine, ; callback function
 LPVOID lpData, ; callback parameter
 LPBOOL pbCancel, ; cancel status
 DWORD dwCopyFlags ; copy options
)
USER32.CopyIcon(
 HICON hIcon ; handle to icon
)
USER32.CopyImage(
 HANDLE hImage, ; handle to the image
 UINT uType, ; type of image to copy
 int cxDesired, ; desired width of new image
 int cyDesired, ; desired height of new image
 UINT fuFlags ; copy options
)
xxxx.CopyLZFile(OBSOLETE - Use LZCopy)
CopyMemory(
 PVOID Destination, ; copy destination
 CONST VOID *Source, ; memory block
 SIZE_T Length ; size of memory block
)
GDI32.CopyMetaFileA(
 HMETAFILE hmfSrc, ; handle to Windows-format metafile
 LPCTSTR lpszFile ; file name
)
USER-DEFINED.CopyProgressRoutine(
 LARGE_INTEGER TotalFileSize, ; file size
 LARGE_INTEGER TotalBytesTransferred, ; bytes transferred
 LARGE_INTEGER StreamSize, ; bytes in stream
 LARGE_INTEGER StreamBytesTransferred, ; bytes transferred for stream
 DWORD dwStreamNumber, ; current stream
 DWORD dwCallbackReason, ; callback reason
 HANDLE hSourceFile, ; handle to source file
 HANDLE hDestinationFile, ; handle to destination file
 LPVOID lpData ; from CopyFileEx
)
USER32.CopyRect(
 LPRECT lprcDst, ; destination rectangle
 CONST RECT *lprcSrc ; source rectangle
)
USER32.CountClipboardFormats(VOID)
CPlApplet(
 HWND hwndCPl,
 UINT uMsg,
 LPARAM lParam1,
 LPARAM lParam2
)
USER32.CreateAcceleratorTableA(
 LPACCEL lpaccl, ; accelerator data array
 int cEntries ; number of entries in array
)
USER32.CreateCaret(
 HWND hWnd, ; handle to owner window
 HBITMAP hBitmap, ; handle to bitmap for caret shape
 int nWidth, ; caret width
 int nHeight ; caret height
)
GDI32.CreateCompatibleDC(
 HDC hdc ; handle to DC
)
KERNEL32.CreateConsoleScreenBuffer(
 DWORD dwDesiredAccess, ; access
 DWORD dwShareMode, ; buffer share mode
 CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes, ; SD
 DWORD dwFlags, ; buffer type
 LPVOID lpScreenBufferData ; reserved
)
USER32.CreateCursor(
 HINSTANCE hInst, ; handle to application instance
 int xHotSpot, ; x coordinate of hot spot
 int yHotSpot, ; y coordinate of hot spot
 int nWidth, ; cursor width
 int nHeight, ; cursor height
 CONST VOID *pvANDPlane, ; AND mask array
 CONST VOID *pvXORPlane ; XOR mask array
)
GDI32.CreateDCA(
 LPCTSTR lpszDriver, ; driver name
 LPCTSTR lpszDevice, ; device name
 LPCTSTR lpszOutput, ; not used; should be NULL
 CONST DEVMODE *lpInitData ; optional printer data
)
USER32.CreateDesktopA(
 LPCTSTR lpszDesktop, ; name of new desktop
 LPCTSTR lpszDevice, ; reserved; must be NULL
 LPDEVMODE pDevmode, ; reserved; must be NULL
 DWORD dwFlags, ; desktop interaction
 ACCESS_MASK dwDesiredAccess, ; access of returned handle
 LPSECURITY_ATTRIBUTES lpsa ; security attributes
)
USER32.CreateDialog(
 HINSTANCE hInstance, ; handle to module
 LPCTSTR lpTemplate, ; dialog box template name
 HWND hWndParent, ; handle to owner window
 DLGPROC lpDialogFunc ; dialog box procedure
)
USER32.CreateDialogIndirect(
 HINSTANCE hInstance, ; handle to module
 LPCDLGTEMPLATE lpTemplate, ; dialog box template
 HWND hWndParent, ; handle to owner window
 DLGPROC lpDialogFunc ; dialog box procedure
)
USER32.CreateDialogIndirectParamA(
 HINSTANCE hInstance, ; handle to module
 LPCDLGTEMPLATE lpTemplate, ; dialog box template
 HWND hWndParent, ; handle to owner window
 DLGPROC lpDialogFunc, ; dialog box procedure
 LPARAM lParamInit ; initialization value
)
USER32.CreateDialogParamA(
 HINSTANCE hInstance, ; handle to module
 LPCTSTR lpTemplateName, ; dialog box template
 HWND hWndParent, ; handle to owner window
 DLGPROC lpDialogFunc, ; dialog box procedure
 LPARAM dwInitParam ; initialization value
)
GDI32.CreateDIBitmap(
 HDC hdc, ; handle to DC
 CONST BITMAPINFOHEADER *lpbmih, ; bitmap data
 DWORD fdwInit, ; initialization option
 CONST VOID *lpbInit, ; initialization data
 CONST BITMAPINFO *lpbmi, ; color-format data
 UINT fuUsage ; color-data usage
)
GDI32.CreateDIBPatternBrush(
 HGLOBAL hglbDIBPacked, ; handle to DIB
 UINT fuColorSpec ; color table data
)
GDI32.CreateDIBPatternBrushPt(
 CONST VOID *lpPackedDIB, ; bitmap bits
 UINT iUsage ; usage
)
GDI32.CreateDIBSection(
 HDC hdc, ; handle to DC
 CONST BITMAPINFO *pbmi, ; bitmap data
 UINT iUsage, ; data type indicator
 VOID **ppvBits, ; bit values
 HANDLE hSection, ; handle to file mapping object
 DWORD dwOffset ; offset to bitmap bit values
)
KERNEL32.CreateDirectoryA(
 LPCTSTR lpPathName, ; directory name
 LPSECURITY_ATTRIBUTES lpSecurityAttributes ; SD
)
KERNEL32.CreateDirectoryExA(
 LPCTSTR lpTemplateDirectory, ; template directory
 LPCTSTR lpNewDirectory, ; directory name
 LPSECURITY_ATTRIBUTES lpSecurityAttributes ; SD
)
GDI32.CreateDiscardableBitmap(
 HDC hdc, ; handle to DC
 int nWidth, ; bitmap width
 int nHeight ; bitmap height
)
GDI32.CreateEllipticRgn(
 int nLeftRect, ; x-coord of upper-left corner of rectangle
 int nTopRect, ; y-coord of upper-left corner of rectangle
 int nRightRect, ; x-coord of lower-right corner of rectangle
 int nBottomRect ; y-coord of lower-right corner of rectangle
)
GDI32.CreateEllipticRgnIndirect(
 CONST RECT *lprc ; bounding rectangle
)
GDI32.CreateEnhMetaFileA(
 HDC hdcRef, ; handle to reference DC
 LPCTSTR lpFilename, ; file name
 CONST RECT *lpRect, ; bounding rectangle
 LPCTSTR lpDescription ; description string
)
xxxx.CreateEnvironmentBlock(
 LPVOID *lpEnvironment, ; environment block
 HANDLE hToken, ; user token
 BOOL bInherit ; inheritance
)
KERNEL32.CreateEventA(
 LPSECURITY_ATTRIBUTES lpEventAttributes, ; SD
 BOOL bManualReset, ; reset type
 BOOL bInitialState, ; initial state
 LPCTSTR lpName ; object name
)
KERNEL32.CreateFiber(
 DWORD dwStackSize, ; initial stack size
 LPFIBER_START_ROUTINE lpStartAddress, ; fiber function
 LPVOID lpParameter ; fiber argument
)
KERNEL32.CreateFileA(
 LPCTSTR lpFileName, ; file name
 DWORD dwDesiredAccess, ; access mode
 DWORD dwShareMode, ; share mode
 LPSECURITY_ATTRIBUTES lpSecurityAttributes, ; SD
 DWORD dwCreationDisposition, ; how to create
 DWORD dwFlagsAndAttributes, ; file attributes
 HANDLE hTemplateFile ; handle to template file
)
KERNEL32.CreateFileMappingA(
 HANDLE hFile, ; handle to file
 LPSECURITY_ATTRIBUTES lpAttributes, ; security
 DWORD flProtect, ; protection
 DWORD dwMaximumSizeHigh, ; high-order DWORD of size
 DWORD dwMaximumSizeLow, ; low-order DWORD of size
 LPCTSTR lpName ; object name
)
GDI32.CreateFontA(
 int nHeight, ; height of font
 int nWidth, ; average character width
 int nEscapement, ; angle of escapement
 int nOrientation, ; base-line orientation angle
 int fnWeight, ; font weight
 DWORD fdwItalic, ; italic attribute option
 DWORD fdwUnderline, ; underline attribute option
 DWORD fdwStrikeOut, ; strikeout attribute option
 DWORD fdwCharSet, ; character set identifier
 DWORD fdwOutputPrecision, ; output precision
 DWORD fdwClipPrecision, ; clipping precision
 DWORD fdwQuality, ; output quality
 DWORD fdwPitchAndFamily, ; pitch and family
 LPCTSTR lpszFace ; typeface name
)
GDI32.CreateFontIndirectA(
 CONST LOGFONT *lplf ; characteristics
)
GDI32.CreateFontIndirectExA(
 CONST ENUMLOGFONTEXDV *penumlfex ; characteristiccs
)
GDI32.CreateHalftonePalette(
 HDC hdc ; handle to DC
)
KERNEL32.CreateHardLinkA(
 LPCTSTR lpFileName, ; new file name
 LPCTSTR lpExistingFileName, ; extant file name
 LPSECURITY_ATTRIBUTES lpSecurityAttributes ; SD
)
GDI32.CreateHatchBrush(
 int fnStyle, ; hatch style
 COLORREF clrref ; foreground color
)
GDI32.CreateICA(
 LPCTSTR lpszDriver, ; driver name
 LPCTSTR lpszDevice, ; device name
 LPCTSTR lpszOutput, ; port or file name
 CONST DEVMODE *lpdvmInit ; optional initialization data
)
USER32.CreateIcon(
 HINSTANCE hInstance, ; handle to application instance
 int nWidth, ; icon width
 int nHeight, ; icon height
 BYTE cPlanes, ; number of planes in XOR bitmask
 BYTE cBitsPixel, ; number of BPP in XOR bitmask
 CONST BYTE *lpbANDbits, ; AND bitmask
 CONST BYTE *lpbXORbits ; XOR bitmask
)
USER32.CreateIconFromResource(
 PBYTE presbits, ; icon or cursor bits
 DWORD dwResSize, ; number of bytes in bit buffer
 BOOL fIcon, ; icon or cursor
 DWORD dwVer ; format version
)
USER32.CreateIconFromResourceEx(
 PBYTE pbIconBits, ; icon or cursor bits
 DWORD cbIconBits, ; number of bytes in bit buffer
 BOOL fIcon, ; icon or cursor
 DWORD dwVersion, ; format version
 int cxDesired, ; desired width of icon or cursor
 int cyDesired, ; desired height of icon or cursor
 UINT uFlags ; load resource options
)
USER32.CreateIconIndirect(
 PICONINFO piconinfo ; icon information
)
KERNEL32.CreateIoCompletionPort(
 HANDLE FileHandle, ; handle to file
 HANDLE ExistingCompletionPort, ; handle to I/O completion port
 ULONG_PTR CompletionKey, ; completion key
 DWORD NumberOfConcurrentThreads ; number of threads to execute concurrently
)
MAPI32.CreateIProp(
 LPCIID lpInterface,
 ALLOCATEBUFFER FAR * lpAllocateBuffer,
 ALLOCATEMORE FAR * lpAllocateMore,
 FREEBUFFER FAR * lpFreeBuffer,
 LPVOID lpvReserved,
 LPPROPDATA FAR * lppPropData
)
KERNEL32.CreateJobObjectA(
 LPSECURITY_ATTRIBUTES lpJobAttributes, ; SD
 LPCTSTR lpName ; job name
)
KERNEL32.CreateMailslotA(
 LPCTSTR lpName, ; mailslot name
 DWORD nMaxMessageSize, ; maximum message size
 DWORD lReadTimeout, ; read time-out interval
 LPSECURITY_ATTRIBUTES lpSecurityAttributes ; inheritance option
)
COMCTL32.CreateMappedBitmap(
 HINSTANCE hInstance,
 int idBitmap,
 UINT wFlags,
 LPCOLORMAP lpColorMap,
 int iNumMaps
)
USER32.CreateMDIWindowA(
 LPCTSTR lpClassName, ; registered child class name
 LPCTSTR lpWindowName, ; window name
 DWORD dwStyle, ; window style
 int X, ; horizontal position of window
 int Y, ; vertical position of window
 int nWidth, ; window width
 int nHeight, ; window height
 HWND hWndParent, ; handle to parent window
 HINSTANCE hInstance, ; handle to application instance
 LPARAM lParam ; application-defined value
)
USER32.CreateMenu(VOID)
CreateMetaFile(
 LPCTSTR lpszFile ; file name
)
KERNEL32.CreateMutexA(
 LPSECURITY_ATTRIBUTES lpMutexAttributes, ; SD
 BOOL bInitialOwner, ; initial owner
 LPCTSTR lpName ; object name
)
KERNEL32.CreateNamedPipeA(
 LPCTSTR lpName, ; pipe name
 DWORD dwOpenMode, ; pipe open mode
 DWORD dwPipeMode, ; pipe-specific modes
 DWORD nMaxInstances, ; maximum number of instances
 DWORD nOutBufferSize, ; output buffer size
 DWORD nInBufferSize, ; input buffer size
 DWORD nDefaultTimeOut, ; time-out interval
 LPSECURITY_ATTRIBUTES lpSecurityAttributes ; SD
)
GDI32.CreatePalette(
 CONST LOGPALETTE *lplgpl ; logical palette
)
GDI32.CreatePatternBrush(
 HBITMAP hbmp ; handle to bitmap
)
GDI32.CreatePen(
 int fnPenStyle, ; pen style
 int nWidth, ; pen width
 COLORREF crColor ; pen color
)
GDI32.CreatePenIndirect(
 CONST LOGPEN *lplgpn ; style, width, and color
)
KERNEL32.CreatePipe(
 PHANDLE hReadPipe, ; read handle
 PHANDLE hWritePipe, ; write handle
 LPSECURITY_ATTRIBUTES lpPipeAttributes, ; security attributes
 DWORD nSize ; pipe size
)
GDI32.CreatePolygonRgn(
 CONST POINT *lppt, ; array of points
 int cPoints, ; number of points in array
 int fnPolyFillMode ; polygon-filling mode
)
GDI32.CreatePolyPolygonRgn(
 CONST POINT *lppt, ; pointer to array of points
 CONST INT *lpPolyCounts, ; pointer to count of vertices
 int nCount, ; number of integers in array
 int fnPolyFillMode ; polygon fill mode
)
USER32.CreatePopupMenu(VOID)
KERNEL32.CreateProcessA(
 LPCTSTR lpApplicationName, ; name of executable module
 LPTSTR lpCommandLine, ; command line string
 LPSECURITY_ATTRIBUTES lpProcessAttributes, ; SD
 LPSECURITY_ATTRIBUTES lpThreadAttributes, ; SD
 BOOL bInheritHandles, ; handle inheritance option
 DWORD dwCreationFlags, ; creation flags
 LPVOID lpEnvironment, ; new environment block
 LPCTSTR lpCurrentDirectory, ; current directory name
 LPSTARTUPINFO lpStartupInfo, ; startup information
 LPPROCESS_INFORMATION lpProcessInformation ; process information
)
ADVAPI32.CreateProcessAsUserA(
 HANDLE hToken, ; handle to user token
 LPCTSTR lpApplicationName, ; name of executable module
 LPTSTR lpCommandLine, ; command-line string
 LPSECURITY_ATTRIBUTES lpProcessAttributes, ; SD
 LPSECURITY_ATTRIBUTES lpThreadAttributes, ; SD
 BOOL bInheritHandles, ; inheritance option
 DWORD dwCreationFlags, ; creation flags
 LPVOID lpEnvironment, ; new environment block
 LPCTSTR lpCurrentDirectory, ; current directory name
 LPSTARTUPINFO lpStartupInfo, ; startup information
 LPPROCESS_INFORMATION lpProcessInformation ; process information
)
xxxx.CreateProcessWithLogonW(
 LPCWSTR lpUsername, ; user's name
 LPCWSTR lpDomain, ; user's domain
 LPCWSTR lpPassword, ; user's password
 DWORD dwLogonFlags, ; logon option
 LPCWSTR lpApplicationName, ; executable module name
 LPWSTR lpCommandLine, ; command-line string
 DWORD dwCreationFlags, ; creation flags
 LPVOID lpEnvironment, ; new environment block
 LPCWSTR lpCurrentDirectory, ; current directory name
 LPSTARTUPINFOW lpStartupInfo, ; startup information
 LPPROCESS_INFORMATION lpProcessInfo ; process information
)
COMCTL32.CreatePropertySheetPageA(
 LPCPROPSHEETPAGE lppsp
)
GDI32.CreateRectRgn(
 int nLeftRect, ; x-coordinate of upper-left corner
 int nTopRect, ; y-coordinate of upper-left corner
 int nRightRect, ; x-coordinate of lower-right corner
 int nBottomRect ; y-coordinate of lower-right corner
)
GDI32.CreateRectRgnIndirect(
 CONST RECT *lprc ; rectangle
)
KERNEL32.CreateRemoteThread(
 HANDLE hProcess, ; handle to process
 LPSECURITY_ATTRIBUTES lpThreadAttributes, ; SD
 DWORD dwStackSize, ; initial stack size
 LPTHREAD_START_ROUTINE lpStartAddress, ; thread function
 LPVOID lpParameter, ; thread argument
 DWORD dwCreationFlags, ; creation option
 LPDWORD lpThreadId ; thread identifier
)
GDI32.CreateRoundRectRgn(
 int nLeftRect, ; x-coordinate of upper-left corner
 int nTopRect, ; y-coordinate of upper-left corner
 int nRightRect, ; x-coordinate of lower-right corner
 int nBottomRect, ; y-coordinate of lower-right corner
 int nWidthEllipse, ; height of ellipse
 int nHeightEllipse ; width of ellipse
)
GDI32.CreateScalableFontResourceA(
 DWORD fdwHidden, ; read-only option
 LPCTSTR lpszFontRes, ; font file name
 LPCTSTR lpszFontFile, ; scalable font file name
 LPCTSTR lpszCurrentPath ; scalable font file path
)
KERNEL32.CreateSemaphoreA(
 LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, ; SD
 LONG lInitialCount, ; initial count
 LONG lMaximumCount, ; maximum count
 LPCTSTR lpName ; object name
)
ADVAPI32.CreateServiceA(
 SC_HANDLE hSCManager, ; handle to SCM database
 LPCTSTR lpServiceName, ; name of service to start
 LPCTSTR lpDisplayName, ; display name
 DWORD dwDesiredAccess, ; type of access to service
 DWORD dwServiceType, ; type of service
 DWORD dwStartType, ; when to start service
 DWORD dwErrorControl, ; severity of service failure
 LPCTSTR lpBinaryPathName, ; name of binary file
 LPCTSTR lpLoadOrderGroup, ; name of load ordering group
 LPDWORD lpdwTagId, ; tag identifier
 LPCTSTR lpDependencies, ; array of dependency names
 LPCTSTR lpServiceStartName, ; account name
 LPCTSTR lpPassword ; account password
)
USER-DEFINED.CreateServiceEnumerationHandle(
 DWORD ExclusionFlags,
 PIPX_SERVICE CriteriaService
)
GDI32.CreateSolidBrush(
 COLORREF crColor ; brush color value
)
USER-DEFINED.CreateStaticService(
 ULONG InterfaceIndex,
 PIPX_STATIC_SERVICE_INFO ServiceEntry
)
COMCTL32.CreateStatusWindowA(
 LONG style,
 LPCTSTR lpszText,
 HWND hwndParent,
 UINT wID
)
MAPI32.CreateTable(
 LPCIID lpInterface,
 ALLOCATEBUFFER FAR * lpAllocateBuffer,
 ALLOCATEMORE FAR * lpAllocateMore,
 FREEBUFFER FAR * lpFreeBuffer,
 LPVOID lpvReserved,
 ULONG ulTableType,
 ULONG ulPropTagIndexColumn,
 LPSPropTagArray lpSPropTagArrayColumns,
 LPTABLEDATA FAR * lppTableData
)
KERNEL32.CreateTapePartition(
 HANDLE hDevice, ; handle to device
 DWORD dwPartitionMethod, ; new partition type
 DWORD dwCount, ; number of new partitions
 DWORD dwSize ; size of new partition
)
xxxx.CreateTextServices(
 IUnknown *punkOuter, ; controlling IUnknown
 ITextHost *pITextHost, ; ITextHost implementation
 IUnknown **ppUnk ; private IUnknown
)
KERNEL32.CreateThread(
 LPSECURITY_ATTRIBUTES lpThreadAttributes, ; SD
 DWORD dwStackSize, ; initial stack size
 LPTHREAD_START_ROUTINE lpStartAddress, ; thread function
 LPVOID lpParameter, ; thread argument
 DWORD dwCreationFlags, ; creation option
 LPDWORD lpThreadId ; thread identifier
)
xxxx.CreateTimerQueue(VOID)
CreateTimerQueueTimer(
 PHANDLE phNewTimer, ; handle to timer
 HANDLE TimerQueue, ; handle to timer queue
 WAITORTIMERCALLBACK Callback, ; timer callback function
 PVOID Parameter, ; callback parameter
 DWORD DueTime, ; timer due time
 DWORD Period, ; timer period
 ULONG Flags ; options
)
COMCTL32.CreateToolbarEx(
 HWND hwnd,
 DWORD ws,
 UINT wID,
 int nBitmaps,
 HINSTANCE hBMInst,
 UINT wBMID,
 LPCTBBUTTON lpButtons,
 int iNumButtons,
 int dxButton,
 int dyButton,
 int dxBitmap,
 int dyBitmap,
 UINT uStructSize
)
KERNEL32.CreateToolhelp32Snapshot(
 DWORD dwFlags,
 DWORD th32ProcessID
)
COMCTL32.CreateUpDownControl(
 DWORD dwStyle,
 int x,
 int y,
 int cx,
 int cy,
 HWND hParent,
 int nID,
 HINSTANCE hInst,
 HWND hBuddy,
 int nUpper,
 int nLower,
 int nPos
)
KERNEL32.CreateWaitableTimerA(
 LPSECURITY_ATTRIBUTES lpTimerAttributes, ; SD
 BOOL bManualReset, ; reset type
 LPCTSTR lpTimerName ; object name
)
USER32.CreateWindow(
 LPCTSTR lpClassName, ; registered class name
 LPCTSTR lpWindowName, ; window name
 DWORD dwStyle, ; window style
 int x, ; horizontal position of window
 int y, ; vertical position of window
 int nWidth, ; window width
 int nHeight, ; window height
 HWND hWndParent, ; handle to parent or owner window
 HMENU hMenu, ; menu handle or child identifier
 HINSTANCE hInstance, ; handle to application instance
 LPVOID lpParam ; window-creation data
)
USER32.CreateWindowExA(
 DWORD dwExStyle, ; extended window style
 LPCTSTR lpClassName, ; registered class name
 LPCTSTR lpWindowName, ; window name
 DWORD dwStyle, ; window style
 int x, ; horizontal position of window
 int y, ; vertical position of window
 int nWidth, ; window width
 int nHeight, ; window height
 HWND hWndParent, ; handle to parent or owner window
 HMENU hMenu, ; menu handle or child identifier
 HINSTANCE hInstance, ; handle to application instance
 LPVOID lpParam ; window-creation data
)
USER32.CreateWindowStationA(
 LPTSTR lpwinsta, ; new window station name
 DWORD dwReserved, ; reserved; must be zero
 ACCESS_MASK dwDesiredAccess, ; requested access
 LPSECURITY_ATTRIBUTES lpsa ; security attributes
)
USER32.DdeAbandonTransaction(
 DWORD idInst, ; instance identifier
 HCONV hConv, ; handle to conversation
 DWORD idTransaction ; transaction identifier
)
USER32.DdeAccessData(
 HDDEDATA hData, ; handle to DDE object
 LPDWORD pcbDataSize ; receives data length
)
USER32.DdeAddData(
 HDDEDATA hData, ; handle to DDE data object
 LPBYTE pSrc, ; pointer to source buffer
 DWORD cb, ; length of data
 DWORD cbOff ; offset within DDE data object
)
USER-DEFINED.DdeCallback(
 UINT uType, ; transaction type
 UINT uFmt, ; clipboard data format
 HCONV hconv, ; handle to the conversation
 HSZ hsz1, ; handle to a string
 HSZ hsz2, ; handle to a string
 HDDEDATA hdata, ; handle to a global memory object
 ULONG_PTR dwData1, ; transaction-specific data
 ULONG_PTR dwData2 ; transaction-specific data
)
USER32.DdeClientTransaction(
 LPBYTE pData, ; pointer to data to pass to server
 DWORD cbData, ; length of data
 HCONV hConv, ; handle to conversation
 HSZ hszItem, ; handle to item name string
 UINT wFmt, ; clipboard data format
 UINT wType, ; transaction type
 DWORD dwTimeout, ; time-out duration
 LPDWORD pdwResult ; pointer to transaction result
)
USER32.DdeCmpStringHandles(
 HSZ hsz1, ; handle to first string
 HSZ hsz2 ; handle to second string
)
USER32.DdeConnect(
 DWORD idInst, ; instance identifier
 HSZ hszService, ; handle to service name string
 HSZ hszTopic, ; handle to topic name string
 PCONVCONTEXT pCC ; context data
)
USER32.DdeConnectList(
 DWORD idInst, ; instance identifier
 HSZ hszService, ; handle to service name string
 HSZ hszTopic, ; handle to topic name string
 HCONVLIST hConvList, ; handle to conversation list
 PCONVCONTEXT pCC ; context data
)
USER32.DdeCreateDataHandle(
 DWORD idInst, ; instance identifier
 LPBYTE pSrc, ; pointer to source buffer
 DWORD cb, ; length of DDE object
 DWORD cbOff, ; offset from beginning of source buffer
 HSZ hszItem, ; handle to item name string
 UINT wFmt, ; clipboard data format
 UINT afCmd ; creation flags
)
USER32.DdeCreateStringHandleA(
 DWORD idInst, ; instance identifier
 LPTSTR psz, ; pointer to null-terminated string
 int iCodePage ; code page identifier
)
USER32.DdeDisconnect(
 HCONV hConv ; handle to conversation
)
USER32.DdeDisconnectList(
 HCONVLIST hConvList ; handle to conversation list
)
USER32.DdeEnableCallback(
 DWORD idInst, ; instance identifier
 HCONV hConv, ; handle to conversation
 UINT wCmd ; enable or disable function code
)
USER32.DdeFreeDataHandle(
 HDDEDATA hData ; handle to DDE object
)
USER32.DdeFreeStringHandle(
 DWORD idInst, ; instance identifier
 HSZ hsz ; handle to string
)
USER32.DdeGetData(
 HDDEDATA hData, ; handle to DDE object
 LPBYTE pDst, ; pointer to destination buffer
 DWORD cbMax, ; amount of data to copy
 DWORD cbOff ; offset to beginning of data
)
USER32.DdeGetLastError(
 DWORD idInst ; instance identifier
)
USER32.DdeImpersonateClient(
 HCONV hConv ; handle to DDE conversation
)
USER32.DdeInitializeA(
 LPDWORD pidInst, ; instance identifier
 PFNCALLBACK pfnCallback, ; callback function
 DWORD afCmd, ; command and filter flags
 DWORD ulRes ; reserved
)
USER32.DdeKeepStringHandle(
 DWORD idInst, ; instance identifier
 HSZ hsz ; handle to string
)
USER32.DdeNameService(
 DWORD idInst, ; instance identifier
 HSZ hsz1, ; handle to service name string
 HSZ hsz2, ; reserved
 UINT afCmd ; service name flags
)
USER32.DdePostAdvise(
 DWORD idInst, ; instance identifier
 HSZ hszTopic, ; handle to topic name string
 HSZ hszItem ; handle to item name string
)
USER32.DdeQueryConvInfo(
 HCONV hConv, ; handle to conversation
 DWORD idTransaction, ; transaction identifier
 PCONVINFO pConvInfo ; conversation data
)
USER32.DdeQueryNextServer(
 HCONVLIST hConvList, ; handle to conversation list
 HCONV hConvPrev ; previous conversation handle
)
USER32.DdeQueryStringA(
 DWORD idInst, ; instance identifier
 HSZ hsz, ; handle to string
 LPTSTR psz, ; pointer to destination buffer
 DWORD cchMax, ; length of buffer
 int iCodePage ; code page identifier
)
USER32.DdeReconnect(
 HCONV hConv ; handle to conversation to reestablish
)
USER32.DdeSetQualityOfService(
 HWND hwndClient, ; handle to window
 CONST SECURITY_QUALITY_OF_SERVICE *pqosNew, ; QOS
 PSECURITY_QUALITY_OF_SERVICE pqosPrev ; prior QOS
)
USER32.DdeSetUserHandle(
 HCONV hConv, ; handle to conversation
 DWORD id, ; transaction identifier
 DWORD_PTR hUser ; application-defined value
)
USER32.DdeUnaccessData(
 HDDEDATA hData ; handle to DDE object
)
USER32.DdeUninitialize(
 DWORD idInst ; instance identifier
)
KERNEL32.DebugActiveProcess(
 DWORD dwProcessId ; process to be debugged
)
KERNEL32.DebugBreak(VOID)
DebugProc(
 int nCode, ; hook code
 WPARAM wParam, ; hook type
 LPARAM lParam ; debugging information
)
KERNEL32.DecryptFileA(
 LPCTSTR lpFileName, ; file name
 DWORD dwReserved ; reserved; must be zero
)
USER32.DefDlgProcA(
 HWND hDlg, ; handle to dialog box
 UINT Msg, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
USER32.DeferWindowPos(
 HDWP hWinPosInfo, ; handle to internal structure
 HWND hWnd, ; handle to window to position
 HWND hWndInsertAfter, ; placement-order handle
 int x, ; horizontal position
 int y, ; vertical position
 int cx, ; width
 int cy, ; height
 UINT uFlags ; window-positioning options
)
USER32.DefFrameProcA(
 HWND hWnd, ; handle to MDI frame window
 HWND hWndMDIClient, ; handle to MDI client window
 UINT uMsg, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
xxxx.DefHookProc(OBSOLETE - Use CallNextHookEx)
DefineDosDevice(
 DWORD dwFlags, ; options
 LPCTSTR lpDeviceName, ; device name
 LPCTSTR lpTargetPath ; path string
)
xxxx.DefineHandleTable(OBSOLETE)
DefMDIChildProc(
 HWND hWnd, ; handle to MDI child window
 UINT uMsg, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
SCRNSAVE.DefScreenSaverProc(
 HWND hWnd,
 UINT msg,
 WPARAM wParam,
 LPARAM lParam
)
xxxx.DefSubclassProc(
 HWND hWnd,
 UINT uMsg,
 WPARAM WPARAM,
 LPARAM LPARAM
)
USER32.DefWindowProcA(
 HWND hWnd, ; handle to window
 UINT Msg, ; message identifier
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
MAPI32.DeinitMapiUtil(VOID)
)
KERNEL32.DeleteAtom(
 ATOM nAtom ; atom to delete
)
KERNEL32.DeleteCriticalSection(
 LPCRITICAL_SECTION lpCriticalSection ; critical section
)
GDI32.DeleteDC(
 HDC hdc ; handle to DC
)
GDI32.DeleteEnhMetaFile(
 HENHMETAFILE hemf ; handle to an enhanced metafile
)
KERNEL32.DeleteFiber(
 LPVOID lpFiber ; pointer to the fiber to delete
)
KERNEL32.DeleteFileA(
 LPCTSTR lpFileName ; file name
)
WINSPOOL.DeleteFormA(
 HANDLE hPrinter, ; handle to printer object
 LPTSTR pFormName ; form name
)
USER-DEFINED.DeleteInterface(
 ULONG InterfaceIndex ; index of the interface
)
USER32.DeleteMenu(
 HMENU hMenu, ; handle to menu
 UINT uPosition, ; menu item identifier or position
 UINT uFlags ; option
)
GDI32.DeleteMetaFile(
 HMETAFILE hmf ; handle to Windows-format metafile
)
WINSPOOL.DeleteMonitorA(
 LPTSTR pName, ; server name
 LPTSTR pEnvironment, ; environment name
 LPTSTR pMonitorName ; monitor name
)
GDI32.DeleteObject(
 HGDIOBJ hObject ; handle to graphic object
)
WINSPOOL.DeletePortA(
 LPTSTR pName, ; server name
 HWND hWnd, ; handle to parent window
 LPTSTR pPortName ; port name
)
WINSPOOL.DeletePrinter(
 HANDLE hPrinter ; handle to printer object
)
WINSPOOL.DeletePrinterConnectionA(
 LPTSTR pName ; printer name
)
WINSPOOL.DeletePrinterDataA(
 HANDLE hPrinter, ; handle to printer
 LPTSTR pValueName ; value name
)
WINSPOOL.DeletePrinterDataExA(
 HANDLE hPrinter, ; handle to printer object
 LPCTSTR pKeyName, ; registry key
 LPCTSTR pValueName ; value name
)
WINSPOOL.DeletePrinterDriverA(
 LPTSTR pName, ; server name
 LPTSTR pEnvironment, ; environment name
 LPTSTR pDriverName ; driver name
)
WINSPOOL.DeletePrinterDriverExA(
 LPTSTR pName, ; server name
 LPTSTR pEnvironment, ; environment name
 LPTSTR pDriverName, ; driver name
 DWORD dwDeleteFlag, ; deletion options
 DWORD dwVersionFlag ; version number
)
WINSPOOL.DeletePrinterKeyA(
 HANDLE hPrinter, ; handle to printer object
 LPCTSTR pKeyName ; registry key name
)
WINSPOOL.DeletePrintProcessorA(
 LPTSTR pName, ; server name
 LPTSTR pEnvironment, ; environment name
 LPTSTR pPrintProcessorName ; processor name
)
WINSPOOL.DeletePrintProvidorA(
 LPTSTR pName, ; reserved, must be NULL
 LPTSTR pEnvironment, ; environment name
 LPTSTR pPrintProviderName ; provider name
)
xxxx.DeleteProfile(
 LPCTSTR lpSidString, ; user SID
 LPCTSTR lpProfilePath, ; profile path
 LPCTSTR lpComputerName ; computer name
)
ADVAPI32.DeleteService(
 SC_HANDLE hService ; handle to service
)
USER-DEFINED.DeleteStaticService(
 ULONG InterfaceIndex,
 PIPX_STATIC_SERVICE_INFO ServiceEntry
)
xxxx.DeleteTimerQueue(
 HANDLE TimerQueue ; handle to timer queue
)
xxxx.DeleteTimerQueueEx(
 HANDLE TimerQueue, ; handle to timer queue
 HANDLE CompletionEvent ; handle to completion event
)
xxxx.DeleteTimerQueueTimer(
 HANDLE TimerQueue, ; handle to timer queue
 HANDLE Timer, ; handle to timer
 HANDLE CompletionEvent ; handle to completion event
)
xxxx.DeleteVolumeMountPoint(
 LPCTSTR lpszVolumeMountPoint ; volume mount point path
)
ADVAPI32.DeregisterEventSource(
 HANDLE hEventLog ; handle to event log
)
MAPI32.DeregisterIdleRoutine(
 FTG ftg
)
USER32.DestroyAcceleratorTable(
 HACCEL hAccel ; handle to accelerator table
)
USER32.DestroyCaret(VOID)
DestroyCursor(
 HCURSOR hCursor ; handle to cursor to destroy
)
xxxx.DestroyEnvironmentBlock(
 LPVOID lpEnvironment ; environment block
)
USER32.DestroyIcon(
 HICON hIcon ; handle to icon
)
USER32.DestroyMenu(
 HMENU hMenu ; handle to menu
)
COMCTL32.DestroyPropertySheetPage(
 HPROPSHEETPAGE hPSPage
)
USER32.DestroyWindow(
 HWND hWnd ; handle to window to destroy
)
WINSPOOL.DeviceCapabilitiesA(
 LPCTSTR pDevice, ; printer name
 LPCTSTR pPort, ; port name
 WORD fwCapability, ; device capability
 LPTSTR pOutput, ; output buffer
 CONST DEVMODE *pDevMode ; device data buffer
)
KERNEL32.DeviceIoControl(
 HANDLE hDevice, ; handle to device
 DWORD dwIoControlCode, ; operation
 LPVOID lpInBuffer, ; input data buffer
 DWORD nInBufferSize, ; size of input data buffer
 LPVOID lpOutBuffer, ; output data buffer
 DWORD nOutBufferSize, ; size of output data buffer
 LPDWORD lpBytesReturned, ; byte count
 LPOVERLAPPED lpOverlapped ; overlapped information
)
USER32.DialogBox(
 HINSTANCE hInstance, ; handle to module
 LPCTSTR lpTemplate, ; dialog box template
 HWND hWndParent, ; handle to owner window
 DLGPROC lpDialogFunc ; dialog box procedure
)
USER32.DialogBoxIndirect(
 HINSTANCE hInstance, ; handle to module
 LPCDLGTEMPLATE lpTemplate, ; dialog box template
 HWND hWndParent, ; handle to owner window
 DLGPROC lpDialogFunc ; dialog box procedure
)
USER32.DialogBoxIndirectParamA(
 HINSTANCE hInstance, ; handle to module
 LPCDLGTEMPLATE hDialogTemplate, ; dialog box template
 HWND hWndParent, ; handle to owner window
 DLGPROC lpDialogFunc, ; dialog box procedure
 LPARAM dwInitParam ; initialization value
)
USER32.DialogBoxParamA(
 HINSTANCE hInstance, ; handle to module
 LPCTSTR lpTemplateName, ; dialog box template
 HWND hWndParent, ; handle to owner window
 DLGPROC lpDialogFunc, ; dialog box procedure
 LPARAM dwInitParam ; initialization value
)
USER-DEFINED.DialogProc(
 HWND hwndDlg, ; handle to dialog box
 UINT uMsg, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
KERNEL32.DisableThreadLibraryCalls(
 HMODULE hModule ; handle to DLL module
)
xxxx.DisconnectClient(
 ULONG InterfaceIndex,
 PVOID ClientAddress
)
KERNEL32.DisconnectNamedPipe(
 HANDLE hNamedPipe ; handle to named pipe
)
USER-DEFINED.DISMISSMODELESS(
 ULONG ulUIParam,
 LPVOID lpvContext
)
USER32.DispatchMessageA(
 CONST MSG *lpmsg ; message information
)
USER32.DlgDirListA(
 HWND hDlg, ; handle to dialog box with list box
 LPTSTR lpPathSpec, ; path or file name buffer
 int nIDListBox, ; list box identifier
 int nIDStaticPath, ; static control identifier
 UINT uFileType ; file attributes to display
)
USER32.DlgDirListComboBoxA(
 HWND hDlg, ; handle to dialog box with combo box
 LPTSTR lpPathSpec, ; path or file name
 int nIDComboBox, ; combo box identifier
 int nIDStaticPath, ; static control identifier
 UINT uFiletype ; file attributes to display
)
USER32.DlgDirSelectComboBoxExA(
 HWND hDlg, ; handle to a dialog box
 LPTSTR lpString, ; pointer to buffer for path string
 int nCount, ; number of characters in path string
 int nIDComboBox ; combo box identifier
)
USER32.DlgDirSelectExA(
 HWND hDlg, ; handle to dialog box with list box
 LPTSTR lpString, ; path buffer
 int nCount, ; number of characters in path buffer
 int nIDListBox ; list box identifier
)
xxxx.DllGetVersion(
 DLLVERSIONINFO *pdvi
)
xxxx.DLLGETVERSIONPROC()
DllInstall(
 BOOL bInstall,
 LPCWSTR pszCmdLine
)
xxxx.DllMain(
 HINSTANCE hinstDLL, ; handle to the DLL module
 DWORD fdwReason, ; reason for calling function
 LPVOID lpvReserved ; reserved
)
xxxx.DnsHostnameToComputerName(
 LPCTSTR Hostname, ; DNS name
 LPTSTR ComputerName, ; name buffer
 LPDWORD nSize ; size of name buffer
)
WINSPOOL.DocumentPropertiesA(
 HWND hWnd, ; handle to parent window
 HANDLE hPrinter, ; handle to printer object
 LPTSTR pDeviceName, ; device name
 PDEVMODE pDevModeOutput, ; modified device mode
 PDEVMODE pDevModeInput, ; original device mode
 DWORD fMode ; mode options
)
xxxx.DoEnvironmentSubst(
 LPCTSTR pszString,
 UINT cbSize
)
KERNEL32.DosDateTimeToFileTime(
 WORD wFatDate, ; 16-bit MS-DOS date
 WORD wFatTime, ; 16-bit MS-DOS time
 LPFILETIME lpFileTime ; 64-bit file time
)
USER-DEFINED.DoUpdateRoutes(
 ULONG InterfaceIndex ; index of the interface
)
USER-DEFINED.DoUpdateServices(
 ULONG InterfaceIndex ; index of the interface
)
GDI32.DPtoLP(
 HDC hdc, ; handle to device context
 LPPOINT lpPoints, ; array of points
 int nCount ; count of points in array
)
SHELL32.DragAcceptFiles(
 HWND hWnd,
 BOOL fAccept
)
USER32.DragDetect(
 HWND hwnd, ; handle to window
 POINT pt ; initial position
)
SHELL32.DragFinish(
 HDROP hDrop
)
SHELL32.DragQueryFileA(
 HDROP hDrop,
 UINT iFile,
 LPTSTR lpszFile,
 UINT cch
)
SHELL32.DragQueryPoint(
 HDROP hDrop,
 LPPOINT lppt
)
USER32.DrawAnimatedRects(
 HWND hwnd, ; handle to clipping window
 int idAni, ; type of animation
 CONST RECT *lprcFrom, ; rectangle coordinates (minimized)
 CONST RECT *lprcTo ; rectangle coordinates (restored)
)
USER32.DrawCaption(
 HWND hwnd, ; handle to window
 HDC hdc, ; handle to device context
 LPCRECT lprc, ; rectangle to draw into
 UINT uFlags ; drawing options
)
USER32.DrawEdge(
 HDC hdc, ; handle to device context
 LPRECT qrc, ; rectangle coordinates
 UINT edge, ; type of edge
 UINT grfFlags ; type of border
)
GDI32.DrawEscape(
 HDC hdc, ; handle to DC
 int nEscape, ; escape function
 int cbInput, ; size of structure for input
 LPCSTR lpszInData ; structure for input
)
USER32.DrawFocusRect(
 HDC hDC, ; handle to device context
 CONST RECT *lprc ; logical coordinates
)
USER32.DrawFrameControl(
 HDC hdc, ; handle to device context
 LPRECT lprc, ; bounding rectangle
 UINT uType, ; frame-control type
 UINT uState ; frame-control state
)
USER32.DrawIcon(
 HDC hDC, ; handle to DC
 int X, ; x-coordinate of upper-left corner
 int Y, ; y-coordinate of upper-left corner
 HICON hIcon ; handle to icon
)
USER32.DrawIconEx(
 HDC hdc, ; handle to device context
 int xLeft, ; x-coord of upper left corner
 int yTop, ; y-coord of upper left corner
 HICON hIcon, ; handle to icon
 int cxWidth, ; icon width
 int cyWidth, ; icon height
 UINT istepIfAniCur, ; frame index, animated cursor
 HBRUSH hbrFlickerFreeDraw, ; handle to background brush
 UINT diFlags ; icon-drawing flags
)
COMCTL32.DrawInsert(
 HWND handParent,
 HWND hLB,
 int nItem
)
USER32.DrawMenuBar(
 HWND hWnd ; handle to window
)
USER32.DrawState(
 HDC hdc, ; handle to device context
 HBRUSH hbr, ; handle to brush
 DRAWSTATEPROC lpOutputFunc, ; callback function
 LPARAM lData, ; image information
 WPARAM wData, ; more image information
 int x, ; horizontal location
 int y, ; vertical location
 int cx, ; image width
 int cy, ; image height
 UINT fuFlags ; image type and state
)
USER-DEFINED.DrawStateProc(
 HDC hdc, ; handle to device context
 LPARAM lData, ; image information
 WPARAM wData, ; more image information
 int cx, ; image width
 int cy ; image height
)
COMCTL32.DrawStatusTextA(
 HDC hdc,
 LPRECT lprc,
 LPCTSTR pszText,
 UINT uFlags
)
USER32.DrawTextA(
 HDC hDC, ; handle to DC
 LPCTSTR lpString, ; text to draw
 int nCount, ; text length
 LPRECT lpRect, ; formatting dimensions
 UINT uFormat ; text-drawing options
)
USER32.DrawTextExA(
 HDC hdc, ; handle to DC
 LPTSTR lpchText, ; text to draw
 int cchText, ; length of text to draw
 LPRECT lprc, ; rectangle coordinates
 UINT dwDTFormat, ; formatting options
 LPDRAWTEXTPARAMS lpDTParams ; more formatting options
)
NETAPI32.DsAddressToSiteNames(
 LPCSTR ComputerName,
 DWORD EntryCount,
 PSOCKET_ADDRESS SocketAddresses,
 LPSTR **SiteNames
)
NETAPI32.DsAddSidHistory(
 HANDLE hDS,
 DWORD Flags,
 LPCTSTR SrcDomain,
 LPCTSTR SrcPrincipal,
 LPCTSTR SrcDomainController,
 RPC_AUTH_IDENTITY_HANDLE SrcDomainCreds,
 LPCTSTR DstDomain,
 LPCTSTR DstPrincipal
)
NETAPI32.DsBackupClose(
 HBC hbc
)
NETAPI32.DsBackupEnd(
 HBC hbc
)
NETAPI32.DsBackupFree(
 PVOID pvBuffer
)
NETAPI32.DsBackupGetBackupLogs(
 HBC hbc,
 LPWSTR *pszBackupLogFiles,
 LPDWORD pcbSize
)
NETAPI32.DsBackupGetDatabaseNames(
 HBC hbc,
 LPWSTR *pszAttachmentInfo,
 LPDWORD pcbSize
)
NETAPI32.DsBackupOpenFile(
 HBC hbc,
 LPCWSTR szAttachmentName,
 DWORD cbReadHintSize,
 LARGE_INTEGER *pliFileSize
)
NETAPI32.DsBackupPrepare(
 LPCWSTR szBackupServer,
 ULONG grbit,
 ULONG btFlag,
 PVOID *ppvExpiryToken,
 LPDWORD pcbExpiryTokenSize,
 HBC *phbc
)
NETAPI32.DsBackupRead(
 HBC hbc,
 PVOID pvBuffer,
 DWORD cbBuffer,
 PDWORD pcbRead
)
NETAPI32.DsBackupTruncateLogs(
 HBC hbc
)
NETAPI32.DsBind(
 TCHAR *DomainController,
 TCHAR *DnsDomainName,
 HANDLE *phDS
)
NETAPI32.DsBindWithCred(
 TCHAR *DomainController,
 TCHAR *DnsDomainName,
 RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
 HANDLE *phDS
)
NETAPI32.DsBindWithSpn(
 LPCSTR DomainControllerName,
 LPCSTR DnsDomainName,
 RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
 LPCSTR ServicePrincipalName,
 HANDLE *phDS
)
NETAPI32.DsBrowseForContainer(
 PDSBROWSEINFO pInfo
)
NETAPI32.DsClientMakeSpnForTargetServer(
 LPCSTR ServiceClass,
 LPCSTR ServiceName,
 DWORD *pcSpnLength,
 LPSTR pszSpn
)
NETAPI32.DsCrackNames(
 HANDLE hDS,
 DS_NAME_FLAGS flags,
 DS_NAME_FORMAT formatOffered,
 DS_NAME_FORMAT formatDesired,
 DWORD cNames,
 LPTSTR *rpNames,
 PDS_NAME_RESULT *ppResult
)
NETAPI32.DsCrackSpn(
 LPCTSTR pszSPN,
 DWORD *pcServiceClass,
 LPTSTR ServiceClass,
 DWORD *pcServiceName,
 LPTSTR ServiceName,
 DWORD *pcInstanceName,
 LPTSTR InstanceName,
 USHORT *pInstancePort
)
NETAPI32.DsDeregisterDnsHostRecords(
 LPSTR ServerName,
 LPSTR DnsDomainName,
 GUID *DomainGuid,
 GUID *DsaGuid,
 LPSTR **DnsHostName
)
NETAPI32.DsEnumerateDomainTrusts(
 LPWSTR ServerName,
 ULONG Flags,
 PDS_DOMAIN_TRUSTS *Domains,
 PULONG DomainCount
)
NETAPI32.DsFreeDomainControllerInfo(
 DWORD InfoLevel,
 DWORD cInfo,
 VOID *pInfo
)
NETAPI32.DsFreeNameResult(
 DS_NAME_RESULTW *pResult
)
NETAPI32.DsFreePasswordCredentials(
 RPC_AUTH_IDENTITY_HANDLE AuthIdentity
)
NETAPI32.DsFreeSchemaGuidMap(
 PDS_SCHEMA_GUID_MAP pGuidMap
)
NETAPI32.DsFreeSpnArray(
 DWORD cSpn,
 LPTSTR *rpszSpn
)
NETAPI32.DsGetDcNameA(
 LPCTSTR ComputerName,
 LPCTSTR DomainName,
 GUID *DomainGuid,
 LPCTSTR SiteName,
 ULONG Flags,
 PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
)
NETAPI32.DsGetDcSiteCoverage(
 LPCSTR ServerName,
 PULONG EntryCount,
 LPSTR **SiteNames
)
NETAPI32.DsGetDomainControllerInfo(
 HANDLE hDs,
 LPTSTR DomainName,
 DWORD InfoLevel,
 DWORD *pcOut,
 VOID **ppInfo
)
NETAPI32.DsGetSiteNameA(
 LPCTSTR ComputerName,
 LPTSTR *SiteName
)
NETAPI32.DsGetSpn(
 DS_SPN_NAME_TYPE ServiceType,
 LPCTSTR ServiceClass,
 LPCTSTR ServiceName,
 USHORT InstancePort,
 USHORT cInstanceNames,
 LPCTSTR *pInstanceNames,
 const USHORT *pInstancePorts,
 DWORD *pcSpn,
 LPTSTR **prpszSpn
)
NETAPI32.DsInheritSecurityIdentity(
 HANDLE hDS,
 DWORD Flags,
 LPCTSTR SrcPrincipal,
 LPCTSTR DstPrincipal
)
NETAPI32.DsIsNTDSOnline(
 LPTCWSTR szServerName,
 BOOL *pfNTDSOnline
)
NETAPI32.DsListDomainsInSite(
 HANDLE hDs,
 LPTSTR site,
 PDS_NAME_RESULTW *ppDomains
)
NETAPI32.DsListInfoForServer(
 HANDLE hDs,
 LPTSTR server,
 PDS_NAME_RESULTW *ppInfo
)
NETAPI32.DsListRoles(
 HANDLE hDs,
 PDS_NAME_RESULTW *ppRoles
)
NETAPI32.DsListServersForDomainInSite(
 HANDLE hDs,
 LPTSTR domain,
 LPTSTR site,
 PDS_NAME_RESULTW *ppServers
)
NETAPI32.DsListServersInSite(
 HANDLE hDs,
 LPTSTR site,
 PDS_NAME_RESULT *ppServers
)
NETAPI32.DsListSites(
 HANDLE hDs,
 PDS_NAME_RESULTW *ppSites
)
NETAPI32.DsMakePasswordCredentials(
 LPTSTR User,
 LPTSTR Domain,
 LPTSTR Password,
 RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
)
NETAPI32.DsMakeSpn(
 LPCTSTR ServiceClass,
 LPCTSTR ServiceName,
 LPCTSTR InstanceName,
 USHORT InstancePort,
 LPCTSTR Referrer,
 DWORD *pcSpnLength,
 LPTSTR pszSpn
)
NETAPI32.DsMapSchemaGuids(
 HANDLE hDs,
 DWORD cGuids,
 GUID *rGuids,
 DS_SCHEMA_GUID_MAP **ppGuidMap
)
NETAPI32.DsQuoteRdnValue(
 DWORD cUnquotedRdnValueLength,
 LPCTCH psUnquotedRdnValue,
 DWORD *pcQuotedRdnValueLength,
 LPTCH psQuotedRdnValue
)
NETAPI32.DsRemoveDsDomain(
 HANDLE hDs,
 LPTSTR DomainDN
)
NETAPI32.DsRemoveDsServer(
 HANDLE hDs,
 LPTSTR ServerDN,
 LPTSTR DomainDN,
 BOOL *fLastDcInDomain,
 BOOL fCommit
)
NETAPI32.DsReplicaAdd(
 HANDLE hDS,
 LPCTSTR NameContext,
 LPCTSTR SourceDsaDn,
 LPCTSTR TransportDn,
 LPCTSTR SourceDsaAddress,
 const PSCHEDULE pSchedule,
 DWORD Options
)
NETAPI32.DsReplicaConsistencyCheck(
 HANDLE hDS,
 DS_KCC_TASKID TaskID,
 DWORD dwFlags
)
NETAPI32.DsReplicaDel(
 HANDLE hDS,
 LPCTSTR NameContext,
 LPCTSTR DsaSrc,
 ULONG Options
)
NETAPI32.DsReplicaGetInfo(
 HANDLE hDS,
 DS_REPL_INFO_TYPE InfoType,
 LPCWSTR pszObject,
 UUID *puuidForSourceDsaObjGuid,
 VOID **ppInfo
)
NETAPI32.DsReplicaModify(
 HANDLE hDS,
 LPCTSTR NameContext,
 const UUID *pUuidSourceDsa,
 LPCTSTR TransportDn,
 LPCTSTR SourceDsaAddress,
 const PSCHEDULE pSchedule,
 DWORD ReplicaFlags,
 DWORD ModifyFields,
 DWORD Options
)
NETAPI32.DsReplicaSync(
 HANDLE hDS,
 LPCTSTR NameContext,
 const UUID *pUuidDsaSrc,
 ULONG Options
)
NETAPI32.DsReplicaSyncAll(
 HANDLE hDS,
 LPTSTR pszNameContext,
 ULONG ulFlags,
 BOOL (__stdcall *pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATE),
 LPVOID pCallbackData,
 PDS_REPSYNCALL_ERRINFO **pErrors
)
NETAPI32.DsReplicaUpdateRefs(
 HANDLE hDS,
 LPCTSTR NameContext,
 LPCTSTR DsaDest,
 const UUID *pUuidDsaDest,
 ULONG Options
)
NETAPI32.DsRestoreEnd(
 HBC hbc
)
NETAPI32.DsRestoreGetDatabaseLocations(
 HBC hbc,
 LPWSTR *pszDatabaseLocationList,
 LPDWORD pcbSize
)
NETAPI32.DsRestorePrepare(
 LPCWSTR szServerName,
 ULONG rtFlag,
 PVOID pvExpiryToken,
 DWORD cbExpiryTokenSize,
 HBC *phbc
)
NETAPI32.DsRestoreRegister(
 HBC hbc,
 LPCWSTR szCheckPointFilePath,
 LPCWSTR szLogPath,
 EDB_RSTMAP rgrstmap[],
 LONG crstmap,
 LPCWSTR szBackupLogPath,
 ULONG genLow,
 ULONG genHigh
)
NETAPI32.DsRestoreRegisterComplete(
 HBC hbc,
 HRESULT hrRestoreState
)
NETAPI32.DsRoleFreeMemory(
 PVOID Buffer
)
NETAPI32.DsRoleGetPrimaryDomainInformation(
 LPCWSTR lpServer,
 DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
 PBYTE *Buffer
)
NETAPI32.DsServerRegisterSpn(
 DS_SPN_WRITE_OP Operation,
 LPCTSTR ServiceClass,
 LPCTSTR UserObjectDN
)
NETAPI32.DsSetAuthIdentity(
 LPCWSTR szUserName,
 LPCWSTR szDomainName,
 LPCWSTR szPassword
)
NETAPI32.DsSetCurrentBackupLog(
 LPCWSTR szServerName,
 DWORD dwCurrentLog
)
NETAPI32.DsUnBind(
 HANDLE *phDS
)
NETAPI32.DsUnquoteRdnValue(
 DWORD cQuotedRdnValueLength,
 LPCTCH psQuotedRdnValue,
 DWORD *pcUnquotedRdnValueLength,
 LPTCH psUnquotedRdnValue
)
NETAPI32.DsValidateSubnetNameA(
 LPCTSTR SubnetName
)
NETAPI32.DsWriteAccountSpn(
 HANDLE hDS,
 DS_SPN_WRITE_OP Operation,
 LPCTSTR pszAccount,
 DWORD cSpn,
 LPCTSTR *rpszSpn
)
KERNEL32.DuplicateHandle(
 HANDLE hSourceProcessHandle, ; handle to source process
 HANDLE hSourceHandle, ; handle to duplicate
 HANDLE hTargetProcessHandle, ; handle to target process
 LPHANDLE lpTargetHandle, ; duplicate handle
 DWORD dwDesiredAccess, ; requested access
 BOOL bInheritHandle, ; handle inheritance option
 DWORD dwOptions ; optional actions
)
SHELL32.DuplicateIcon(
 HINSTANCE hInst, ; not used
 HICON hIcon ; handle to icon
)
USER-DEFINED.EditStreamCallback(
 DWORD_PTR dwCookie, ; application-defined value
 LPBYTE pbBuff, ; data buffer
 LONG cb, ; number of bytes to read or write
 LONG *pcb ; number of bytes transferred
)
USER-DEFINED.EditWordBreakProc(
 LPTSTR lpch, ; text string
 int ichCurrent, ; index of starting point
 int cch, ; length of text string
 int code ; action to take
)
USER-DEFINED.EditWordBreakProcEx(
 char *pchText, ; text buffer
 LONG cchText, ; number of characters in buffer
 BYTE bCharSet, ; character set
 INT code ; word break action
)
GDI32.Ellipse(
 HDC hdc, ; handle to DC
 int nLeftRect, ; x-coord of upper-left corner of rectangle
 int nTopRect, ; y-coord of upper-left corner of rectangle
 int nRightRect, ; x-coord of lower-right corner of rectangle
 int nBottomRect ; y-coord of lower-right corner of rectangle
)
USER32.EmptyClipboard(VOID)
EnableIdleRoutine(
 FTG ftg,
 BOOL fEnable
)
USER32.EnableMenuItem(
 HMENU hMenu, ; handle to menu
 UINT uIDEnableItem, ; menu item to update
 UINT uEnable ; options
)
USER32.EnableScrollBar(
 HWND hWnd, ; handle to window or scroll bar
 UINT wSBflags, ; scroll bar type
 UINT wArrows ; scroll bar arrow options
)
USER32.EnableWindow(
 HWND hWnd, ; handle to window
 BOOL bEnable ; enable or disable input
)
KERNEL32.EncryptFileA(
 LPCTSTR lpFileName ; file name
)
xxxx.EncryptionDisable(
 LPCWSTR DirPath, ; directory name
 BOOL Disable ; encryption option
)
USER32.EndDeferWindowPos(
 HDWP hWinPosInfo ; handle to internal structure
)
USER32.EndDialog(
 HWND hDlg, ; handle to dialog box
 INT_PTR nResult ; value to return
)
GDI32.EndDoc(
 HDC hdc ; handle to DC
)
WINSPOOL.EndDocPrinter(
 HANDLE hPrinter ; handle to printer object
)
xxxx.EndMenu(VOID)
)
GDI32.EndPage(
 HDC hdc ; handle to DC
)
WINSPOOL.EndPagePrinter(
 HANDLE hPrinter ; handle to printer object
)
USER32.EndPaint(
 HWND hWnd, ; handle to window
 CONST PAINTSTRUCT *lpPaint ; paint data
)
GDI32.EndPath(
 HDC hdc ; handle to DC
)
KERNEL32.EndUpdateResourceA(
 HANDLE hUpdate, ; update-file handle
 BOOL fDiscard ; write option
)
USER-DEFINED.EnhMetaFileProc(
 HDC hDC, ; handle to DC
 HANDLETABLE *lpHTable, ; metafile handle table
 CONST ENHMETARECORD *lpEMFR, ; metafile record
 int nObj, ; count of objects
 LPARAM lpData ; optional data
)
KERNEL32.EnterCriticalSection(
 LPCRITICAL_SECTION lpCriticalSection ; critical section
)
KERNEL32.EnumCalendarInfoA(
 CALINFO_ENUMPROC pCalInfoEnumProc, ; callback function
 LCID Locale, ; locale
 CALID Calendar, ; calendar
 CALTYPE CalType ; calendar information type
)
KERNEL32.EnumCalendarInfoExA(
 CALINFO_ENUMPROCEX pCalInfoEnumProcEx, ; callback function
 LCID Locale, ; locale
 CALID Calendar, ; calendar
 CALTYPE CalType ; information type
)
USER-DEFINED.EnumCalendarInfoProc(
 LPTSTR lpCalendarInfoString ; calendar information string
)
xxxx.EnumCalendarInfoProcEx(
 LPTSTR lpCalendarInfoString, ; calendar information string
 CALID Calendar ; calendar identifier
)
USER-DEFINED.EnumChildProc(
 HWND hwnd, ; handle to child window
 LPARAM lParam ; application-defined value
)
USER32.EnumChildWindows(
 HWND hWndParent, ; handle to parent window
 WNDENUMPROC lpEnumFunc, ; callback function
 LPARAM lParam ; application-defined value
)
USER32.EnumClipboardFormats(
 UINT format ; available clipboard format
)
USER-DEFINED.EnumCodePagesProc(
 LPTSTR lpCodePageString ; code page identifier string
)
KERNEL32.EnumDateFormatsA(
 DATEFMT_ENUMPROC lpDateFmtEnumProc, ; callback function
 LCID Locale, ; locale
 DWORD dwFlags ; date formats
)
xxxx.EnumDateFormatsExA(
 DATEFMT_ENUMPROCEX lpDateFmtEnumProcEx, ; callback function
 LCID Locale, ; locale
 DWORD dwFlags ; date formats
)
USER-DEFINED.EnumDateFormatsProc(
 LPTSTR lpDateFormatString ; date format string
)
xxxx.EnumDateFormatsProcEx(
 LPTSTR lpDateFormatString, ; date format string
 CALID CalendarID ; calendar identifier
)
ADVAPI32.EnumDependentServicesA(
 SC_HANDLE hService, ; handle to service
 DWORD dwServiceState, ; service state
 LPENUM_SERVICE_STATUS lpServices, ; status buffer
 DWORD cbBufSize, ; size of status buffer
 LPDWORD pcbBytesNeeded, ; buffer size needed
 LPDWORD lpServicesReturned ; number of entries returned
)
USER-DEFINED.EnumDesktopProc(
 LPTSTR lpszDesktop, ; desktop name
 LPARAM lParam ; user-defined value
)
USER32.EnumDesktopsA(
 HWINSTA hwinsta, ; handle to window station
 DESKTOPENUMPROC lpEnumFunc, ; callback function
 LPARAM lParam ; value for callback function
)
USER32.EnumDesktopWindows(
 HDESK hDesktop, ; handle to desktop to enumerate
 WNDENUMPROC lpfn, ; callback function
 LPARAM lParam ; value to pass to callback function
)
xxxx.EnumDisplayDevices(
 LPCTSTR lpDevice, ; device name
 DWORD iDevNum, ; display device
 PDISPLAY_DEVICE lpDisplayDevice, ; device information
 DWORD dwFlags ; reserved
)
USER32.EnumDisplayMonitors(
 HDC hdc, ; handle to display DC
 LPCRECT lprcClip, ; clipping rectangle
 MONITORENUMPROC lpfnEnum, ; callback function
 LPARAM dwData ; data for callback function
)
USER32.EnumDisplaySettingsA(
 LPCTSTR lpszDeviceName, ; display device
 DWORD iModeNum, ; graphics mode
 LPDEVMODE lpDevMode ; graphics mode settings
)
xxxx.EnumDisplaySettingsExA(
 LPCTSTR lpszDeviceName, ; display device
 DWORD iModeNum, ; graphics mode
 LPDEVMODE lpDevMode, ; graphics mode settings
 DWORD dwFlags ; options
)
GDI32.EnumEnhMetaFile(
 HDC hdc, ; handle to DC
 HENHMETAFILE hemf, ; handle to enhanced metafile
 ENHMFENUMPROC lpEnhMetaFunc, ; callback function
 LPVOID lpData, ; callback-function data
 CONST RECT *lpRect ; bounding rectangle
)
USER-DEFINED.EnumerateGetNextService(
 HANDLE EnumerationHandle,
 PIPX_SERVICE Service
)
USER-DEFINED.EnumFontFamExProc(
 ENUMLOGFONTEX *lpelfe, ; logical-font data
 NEWTEXTMETRICEX *lpntme, ; physical-font data
 DWORD FontType, ; type of font
 LPARAM lParam ; application-defined data
)
GDI32.EnumFontFamiliesA(
 HDC hdc, ; handle to DC
 LPCTSTR lpszFamily, ; font family
 FONTENUMPROC lpEnumFontFamProc, ; callback function
 LPARAM lParam ; additional data
)
GDI32.EnumFontFamiliesExA(
 HDC hdc, ; handle to DC
 LPLOGFONT lpLogfont, ; font information
 FONTENUMPROC lpEnumFontFamExProc, ; callback function
 LPARAM lParam, ; additional data
 DWORD dwFlags ; not used; must be 0
)
GDI32.EnumFontFamProc(
 ENUMLOGFONT *lpelf, ; logical-font data
 NEWTEXTMETRIC *lpntm, ; physical-font data
 DWORD FontType, ; type of font
 LPARAM lParam ; application-defined data
)
GDI32.EnumFontsA(
 HDC hdc, ; handle to DC
 LPCTSTR lpFaceName, ; font typeface name
 FONTENUMPROC lpFontFunc, ; callback function
 LPARAM lParam ; application-supplied data
)
xxxx.EnumFontsProc(
 CONST LOGFONT *lplf, ; logical-font data
 CONST TEXTMETRIC *lptm, ; physical-font data
 DWORD dwType, ; font type
 LPARAM lpData ; application-defined data
)
WINSPOOL.EnumFormsA(
 HANDLE hPrinter, ; handle to printer object
 DWORD Level, ; data level
 LPBYTE pForm, ; form information buffer
 DWORD cbBuf, ; size of form information buffer
 LPDWORD pcbNeeded, ; bytes received or required
 LPDWORD pcReturned ; number of forms received
)
xxxx.EnumGeoInfoProc(
 GEOID GeoId ; location identifier
)
xxxx.EnumInputContext(
 HIMC hIMC,
 LPARAM lParam
)
WINSPOOL.EnumJobsA(
 HANDLE hPrinter, ; handle to printer object
 DWORD FirstJob, ; index of first job
 DWORD NoJobs, ; number of jobs to enumerate
 DWORD Level, ; information level
 LPBYTE pJob, ; job information buffer
 DWORD cbBuf, ; size of job information buffer
 LPDWORD pcbNeeded, ; bytes received or required
 LPDWORD pcReturned ; number of jobs received
)
xxxx.EnumLanguageGroupLocales(
 LANGGROUPLOCALE_ENUMPROC pLangGroupLocaleEnumProc, ; callback function
 LGRPID LanguageGroup, ; language-group identifier
 DWORD dwFlags, ; reserved
 LONG_PTR lParam ; callback parameter
)
xxxx.EnumLanguageGroupLocalesProc(
 LGRPID LanguageGroup, ; language-group identifier
 LCID Locale, ; locale identifier
 LPTSTR lpLocaleString, ; locale identifier string
 LONG_PTR lParam ; callback parameter
)
xxxx.EnumLanguageGroupsProc(
 LGRPID LanguageGroup, ; language-group identifier
 LPTSTR lpLanguageGroupString, ; language-group identifier string
 LPTSTR lpLanguageGroupNameString, ; language-group name string
 DWORD dwFlags, ; options
 LONG_PTR lParam ; callback parameter
)
USER-DEFINED.EnumLocalesProc(
 LPTSTR lpLocaleString ; locale identifier string
)
xxxx.EnumMetaFile(
 HDC hdc, ; handle to DC
 HMETAFILE hmf, ; handle to Windows-format metafile
 MFENUMPROC lpMetaFunc, ; callback function
 LPARAM lParam ; optional data
)
xxxx.EnumMetaFileProc(
 HDC hDC, ; handle to DC
 HANDLETABLE *lpHTable, ; metafile handle table
 METARECORD *lpMFR, ; metafile record
 int nObj, ; count of objects
 LPARAM lpClientData ; optional data
)
WINSPOOL.EnumMonitorsA(
 LPTSTR pName, ; server name
 DWORD Level, ; information level
 LPBYTE pMonitors, ; monitor information buffer
 DWORD cbBuf, ; size of monitor information buffer
 LPDWORD pcbNeeded, ; bytes received or required
 LPDWORD pcReturned ; number of monitors received
)
GDI32.EnumObjects(
 HDC hdc, ; handle to DC
 int nObjectType, ; object-type identifier
 GOBJENUMPROC lpObjectFunc, ; callback function
 LPARAM lParam ; application-supplied data
)
USER-DEFINED.EnumObjectsProc(
 LPVOID lpLogObject, ; object attributes
 LPARAM lpData ; application-defined data
)
WINSPOOL.EnumPortsA(
 LPTSTR pName, ; server name
 DWORD Level, ; information level
 LPBYTE pPorts, ; port information buffer
 DWORD cbBuf, ; size of port information buffer
 LPDWORD pcbNeeded, ; bytes received or required
 LPDWORD pcReturned ; number of ports received
)
WINSPOOL.EnumPrinterDataA(
 HANDLE hPrinter, ; handle to printer
 DWORD dwIndex, ; index of value to retrieve
 LPTSTR pValueName, ; value name buffer
 DWORD cbValueName, ; size of value name buffer
 LPDWORD pcbValueName, ; bytes received
 LPDWORD pType, ; value type code
 LPBYTE pData, ; value data buffer
 DWORD cbData, ; size of value data buffer
 LPDWORD pcbData ; bytes received
)
WINSPOOL.EnumPrinterDataExA(
 HANDLE hPrinter, ; handle to printer object
 LPCTSTR pKeyName, ; registry key name
 LPBYTE pEnumValues, ; array of values
 DWORD cbEnumValues, ; size of values array
 LPDWORD pcbEnumValues, ; bytes in the values array
 LPDWORD pnEnumValues ; number of values enumerated
)
WINSPOOL.EnumPrinterDriversA(
 LPTSTR pName, ; printer server name
 LPTSTR pEnvironment, ; environment name
 DWORD Level, ; information level
 LPBYTE pDriverInfo, ; driver information buffer
 DWORD cbBuf, ; size of driver information buffer
 LPDWORD pcbNeeded, ; bytes received or required
 LPDWORD pcReturned ; number of drivers received
)
WINSPOOL.EnumPrinterKeyA(
 HANDLE hPrinter, ; handle to printer object
 LPCTSTR pKeyName, ; registry key name
 LPTSTR pSubkey, ; array of subkey names
 DWORD cbSubkey, ; size subkey array
 LPDWORD pcbSubkey ; bytes received in subkey array
)
WINSPOOL.EnumPrintersA(
 DWORD Flags, ; printer object types
 LPTSTR Name, ; name of printer object
 DWORD Level, ; information level
 LPBYTE pPrinterEnum, ; printer information buffer
 DWORD cbBuf, ; size of printer information buffer
 LPDWORD pcbNeeded, ; bytes received or required
 LPDWORD pcReturned ; number of printers enumerated
)
WINSPOOL.EnumPrintProcessorDatatypesA(
 LPTSTR pName, ; printer server name
 LPTSTR pPrintProcessorName, ; print processor name
 DWORD Level, ; information level
 LPBYTE pDatatypes, ; processor data buffer
 DWORD cbBuf, ; size of data buffer
 LPDWORD pcbNeeded, ; bytes received or required
 LPDWORD pcReturned ; number of processors
)
WINSPOOL.EnumPrintProcessorsA(
 LPTSTR pName, ; print server name
 LPTSTR pEnvironment, ; environment name
 DWORD Level, ; information level
 LPBYTE pPrintProcessorInfo, ; processor data buffer
 DWORD cbBuf, ; size of data buffer
 LPDWORD pcbNeeded, ; bytes received or required
 LPDWORD pcReturned ; number of processors
)
USER32.EnumPropsA(
 HWND hWnd, ; handle to window
 PROPENUMPROC lpEnumFunc ; callback function
)
USER32.EnumPropsExA(
 HWND hWnd, ; handle to window
 PROPENUMPROCEX lpEnumFunc, ; callback function
 LPARAM lParam ; application-defined data
)
USER-DEFINED.EnumRegisterWordProc(
 LPCTSTR lpszReading,
 DWORD dwStyle,
 LPCTSTR lpszString,
 LPVOID lpData
)
USER-DEFINED.EnumResLangProc(
 HANDLE hModule, ; module handle
 LPCTSTR lpszType, ; resource type
 LPCTSTR lpszName, ; resource name
 WORD wIDLanguage, ; language identifier
 LONG_PTR lParam ; application-defined parameter
)
USER-DEFINED.EnumResNameProc(
 HMODULE hModule, ; module handle
 LPCTSTR lpszType, ; resource type
 LPTSTR lpszName, ; resource name
 LONG_PTR lParam ; application-defined parameter
)
KERNEL32.EnumResourceLanguagesA(
 HMODULE hModule, ; module handle
 LPCTSTR lpType, ; resource type
 LPCTSTR lpName, ; resource name
 ENUMRESLANGPROC lpEnumFunc, ; callback function
 LONG_PTR lParam ; application-defined parameter
)
KERNEL32.EnumResourceNamesA(
 HMODULE hModule, ; module handle
 LPCTSTR lpszType, ; resource type
 ENUMRESNAMEPROC lpEnumFunc, ; callback function
 LONG_PTR lParam ; application-defined parameter
)
KERNEL32.EnumResourceTypesA(
 HMODULE hModule, ; module handle
 ENUMRESTYPEPROC lpEnumFunc, ; callback function
 LONG_PTR lParam ; application-defined parameter
)
USER-DEFINED.EnumResTypeProc(
 HMODULE hModule, ; module handle
 LPTSTR lpszType, ; resource type
 LONG_PTR lParam ; application-defined parameter
)
ADVAPI32.EnumServicesStatusA(
 SC_HANDLE hSCManager, ; handle to SCM database
 DWORD dwServiceType, ; service type
 DWORD dwServiceState, ; service state
 LPENUM_SERVICE_STATUS lpServices, ; status buffer
 DWORD cbBufSize, ; size of status buffer
 LPDWORD pcbBytesNeeded, ; buffer size needed
 LPDWORD lpServicesReturned, ; number of entries returned
 LPDWORD lpResumeHandle ; next entry
)
xxxx.EnumServicesStatusEx(
 SC_HANDLE hSCManager, ; handle to SCM database
 SC_ENUM_TYPE InfoLevel, ; information level
 DWORD dwServiceType, ; service type
 DWORD dwServiceState, ; service state
 LPBYTE lpServices, ; status buffer
 DWORD cbBufSize, ; size of status buffer
 LPDWORD pcbBytesNeeded, ; buffer size needed
 LPDWORD lpServicesReturned, ; number of entries returned
 LPDWORD lpResumeHandle, ; next entry
 LPCTSTR pszGroupName ; load-order group name
)
KERNEL32.EnumSystemCodePagesA(
 CODEPAGE_ENUMPROC lpCodePageEnumProc, ; callback function
 DWORD dwFlags ; code pages
)
xxxx.EnumSystemGeoID(
 GEOCLASS GeoClass, ; geographical type to enumerate
 GEOID ParentGeoId, ; parent GeoID
 GEO_ENUMPROC lpGeoEnumProc ; callback function
)
xxxx.EnumSystemLanguageGroups(
 LANGUAGEGROUP_ENUMPROC pLangGroupEnumProc, ; callback function
 DWORD dwFlags, ; language groups
 LONG_PTR lParam ; callback parameter
)
KERNEL32.EnumSystemLocalesA(
 LOCALE_ENUMPROC lpLocaleEnumProc, ; callback function
 DWORD dwFlags ; locales
)
xxxx.EnumTaskWindows(OBSOLETE - Use EnumThreadWindows)
EnumThreadWindows(
 DWORD dwThreadId, ; thread identifier
 WNDENUMPROC lpfn, ; callback function
 LPARAM lParam ; application-defined value
)
USER-DEFINED.EnumThreadWndProc(
 HWND hwnd, ; handle to window
 LPARAM lParam ; application-defined value
)
KERNEL32.EnumTimeFormatsA(
 TIMEFMT_ENUMPROC lpTimeFmtEnumProc, ; callback function
 LCID Locale, ; locale
 DWORD dwFlags ; unused
)
USER-DEFINED.EnumTimeFormatsProc(
 LPTSTR lpTimeFormatString ; time format string
)
xxxx.EnumUILanguages(
 UILANGUAGE_ENUMPROC pUILangEnumProc, ; callback function
 DWORD dwFlags, ; reserved
 LONG_PTR lParam ; callback parameter
)
xxxx.EnumUILanguagesProc(
 LPTSTR lpUILanguageString, ; language string
 LONG_PTR lParam ; callback parameter
)
USER32.EnumWindows(
 WNDENUMPROC lpEnumFunc, ; callback function
 LPARAM lParam ; application-defined value
)
USER-DEFINED.EnumWindowsProc(
 HWND hwnd, ; handle to parent window
 LPARAM lParam ; application-defined value
)
USER-DEFINED.EnumWindowStationProc(
 LPTSTR lpszWindowStation, ; window station name
 LPARAM lParam ; user-defined value
)
USER32.EnumWindowStationsA(
 WINSTAENUMPROC lpEnumFunc, ; callback function
 LPARAM lParam ; value for callback function
)
USER32.EqualRect(
 CONST RECT *lprc1, ; first rectangle
 CONST RECT *lprc2 ; second rectangle
)
GDI32.EqualRgn(
 HRGN hSrcRgn1, ; handle to first region
 HRGN hSrcRgn2 ; handle to second region
)
KERNEL32.EraseTape(
 HANDLE hDevice, ; handle to device
 DWORD dwEraseType, ; type of erasure to perform
 BOOL bImmediate ; return after erase operation begins
)
GDI32.Escape(
 HDC hdc, ; handle to DC
 int nEscape, ; escape function
 int cbInput, ; size of input structure
 LPCSTR lpvInData, ; input structure
 LPVOID lpvOutData ; output structure
)
KERNEL32.EscapeCommFunction(
 HANDLE hFile, ; handle to communications device
 DWORD dwFunc ; extended function to perform
)
GDI32.ExcludeClipRect(
 HDC hdc, ; handle to DC
 int nLeftRect, ; x-coord of upper-left corner
 int nTopRect, ; y-coord of upper-left corner
 int nRightRect, ; x-coord of lower-right corner
 int nBottomRect ; y-coord of lower-right corner
)
USER32.ExcludeUpdateRgn(
 HDC hDC, ; handle to device context
 HWND hWnd ; handle to window
)
KERNEL32.ExitProcess(
 UINT uExitCode ; exit code for all threads
)
KERNEL32.ExitThread(
 DWORD dwExitCode ; exit code for this thread
)
USER32.ExitWindows(
 DWORD dwReserved, ; reserved; must be zero
 UINT uReserved ; reserved; must be zero
)
USER32.ExitWindowsEx(
 UINT uFlags, ; shutdown operation
 DWORD dwReserved ; reserved
)
KERNEL32.ExpandEnvironmentStringsA(
 LPCTSTR lpSrc, ; string with environment variables
 LPTSTR lpDst, ; string with expanded strings
 DWORD nSize ; maximum characters in expanded string
)
KERNEL32.ExpandEnvironmentStringsForUser(
 HANDLE hToken, ; user token
 LPCTSTR lpSrc, ; source string
 LPTSTR lpDest, ; destination buffer
 DWORD dwSize ; size of destination buffer
)
GDI32.ExtCreatePen(
 DWORD dwPenStyle, ; pen style
 DWORD dwWidth, ; pen width
 CONST LOGBRUSH *lplb, ; brush attributes
 DWORD dwStyleCount, ; length of custom style array
 CONST DWORD *lpStyle ; custom style array
)
GDI32.ExtCreateRegion(
 CONST XFORM *lpXform, ; transformation data
 DWORD nCount, ; size of region data
 CONST RGNDATA *lpRgnData ; region data buffer
)
GDI32.ExtEscape(
 HDC hdc, ; handle to DC
 int nEscape, ; escape function
 int cbInput, ; size of input structure
 LPCSTR lpszInData, ; input structure
 int cbOutput, ; size of output structure
 LPSTR lpszOutData ; output structure
)
GDI32.ExtFloodFill(
 HDC hdc, ; handle to DC
 int nXStart, ; starting x-coordinate
 int nYStart, ; starting y-coordinate
 COLORREF crColor, ; fill color
 UINT fuFillType ; fill type
)
SHELL32.ExtractAssociatedIconA(
 HINSTANCE hInst, ; application instance handle
 LPTSTR lpIconPath, ; file name
 LPWORD lpiIcon ; icon index
)
SHELL32.ExtractIconA(
 HINSTANCE hInst, ; instance handle
 LPCTSTR lpszExeFileName, ; file name
 UINT nIconIndex ; icon index
)
SHELL32.ExtractIconExA(
 LPCTSTR lpszFile, ; file name
 int nIconIndex, ; icon index
 HICON *phiconLarge, ; large icon array
 HICON *phiconSmall, ; small icon array
 UINT nIcons ; number of icons to extract
)
GDI32.ExtSelectClipRgn(
 HDC hdc, ; handle to DC
 HRGN hrgn, ; handle to region
 int fnMode ; region-selection mode
)
GDI32.ExtTextOut(
 HDC hdc, ; handle to DC
 int X, ; x-coordinate of reference point
 int Y, ; y-coordinate of reference point
 UINT fuOptions, ; text-output options
 CONST RECT *lprc, ; optional dimensions
 LPCTSTR lpString, ; string
 UINT cbCount, ; number of characters in string
 CONST INT *lpDx ; array of spacing values
)
KERNEL32.FatalAppExitA(
 UINT uAction, ; reserved
 LPCTSTR lpMessageText ; display string
)
KERNEL32.FatalExit(
 int ExitCode ; error code
)
xxxx.FAX_RECIPIENT_CALLBACK(
 HANDLE FaxHandle, ; handle to the fax server
 DWORD RecipientNumber, ; index indicating current fax recipient
 LPVOID Context, ; pointer to context information
 PFAX_JOB_PARAM JobParams, ; pointer to job information structure
 PFAX_COVERPAGE_INFO CoverpageInfo OPTIONAL ; pointer to local cover page structure
)
xxxx.FAX_ROUTING_INSTALLATION_CALLBACK(
 HANDLE FaxHandle, ; handle to the fax server
 LPVOID Context, ; pointer to context information
 LPWSTR MethodName, ; pointer to fax routing method internal name
 LPWSTR FriendlyName, ; pointer to fax routing method user-friendly name
 LPWSTR FunctionName, ; pointer to fax routing method function name
 LPWSTR Guid ; pointer to GUID that identifies the fax routing method
)
xxxx.FaxAbort(
 HANDLE FaxHandle, ; handle to the fax server
 DWORD JobId ; identifier of fax job to terminate
)
xxxx.FaxAccessCheck(
 HANDLE FaxHandle, ; handle to the fax server
 DWORD AccessMask ; set of access level bit flags
)
xxxx.FaxClose(
 HANDLE FaxHandle ; fax handle to close
)
xxxx.FaxCompleteJobParams(
 PFAX_JOB_PARAM *JobParams, ; pointer to job information structure
 PFAX_COVERPAGE_INFO *CoverpageInfo ; pointer to cover page structure
)
xxxx.FaxConnectFaxServer(
 LPCTSTR MachineName OPTIONAL, ; fax server name
 LPHANDLE FaxHandle ; handle to the fax server
)
xxxx.FaxEnableRoutingMethod(
 HANDLE FaxPortHandle, ; fax port handle
 LPCTSTR RoutingGuid, ; GUID that identifies the fax routing method
 BOOL Enabled ; fax routing method enable/disable flag
)
xxxx.FaxEnumGlobalRoutingInfo(
 HANDLE FaxHandle, ;handle to the fax server
 PFAX_GLOBAL_ROUTING_INFO *RoutingInfo, ;buffer to receive global routing structures
 LPDWORD MethodsReturned ;number of global routing structures returned
)
xxxx.FaxEnumJobs(
 HANDLE FaxHandle, ; handle to the fax server
 PFAX_JOB_ENTRY *JobEntry, ; buffer to receive array of job data
 LPDWORD JobsReturned ; number of fax job structures returned
)
xxxx.FaxEnumPorts(
 HANDLE FaxHandle, ; handle to the fax server
 PFAX_PORT_INFO *PortInfo, ; buffer to receive array of port data
 LPDWORD PortsReturned ; number of fax port structures returned
)
xxxx.FaxEnumRoutingMethods(
 HANDLE FaxPortHandle, ; fax port handle
 PFAX_ROUTING_METHOD *RoutingMethod, ; buffer to receive routing method data
 LPDWORD MethodsReturned ; number of routing method structures returned
)
xxxx.FaxFreeBuffer(
 LPVOID Buffer ; pointer to buffer to free
)
xxxx.FaxGetConfiguration(
 HANDLE FaxHandle, ; handle to the fax server
 PFAX_CONFIGURATION *FaxConfig ; structure to receive configuration data
)
xxxx.FaxGetDeviceStatus(
 HANDLE FaxPortHandle, ; fax port handle
 PFAX_DEVICE_STATUS *DeviceStatus ; structure to receive fax device data
)
xxxx.FaxGetJob(
 HANDLE FaxHandle, ; handle to the fax server
 DWORD JobId, ; fax job identifier
 PFAX_JOB_ENTRY *JobEntry ; pointer to job data structure
)
xxxx.FaxGetLoggingCategories(
 HANDLE FaxHandle, ; handle to the fax server
 PFAX_LOG_CATEGORY *Categories, ; buffer to receive category data
 LPDWORD NumberCategories ; number of logging categories returned
)
xxxx.FaxGetPageData(
 HANDLE FaxHandle, ; handle to the fax server
 DWORD JobId, ; fax job identifier
 LPBYTE *Buffer, ; buffer to receive first page of data
 LPDWORD BufferSize, ; size of buffer, in bytes
 LPDWORD ImageWidth, ; page image width, in pixels
 LPDWORD ImageHeight ; page image height, in pixels
)
xxxx.FaxGetPort(
 HANDLE FaxPortHandle, ; fax port handle
 PFAX_PORT_INFO *PortInfo ; structure to receive port data
)
xxxx.FaxGetRoutingInfo(
 HANDLE FaxPortHandle, ; fax port handle
 LPCTSTR RoutingGuid, ; GUID that identifies fax routing method
 LPBYTE *RoutingInfoBuffer, ; buffer to receive routing method data
 LPDWORD RoutingInfoBufferSize ; size of buffer, in bytes
)
xxxx.FaxInitializeEventQueue(
 HANDLE FaxHandle, ; handle to the fax server
 HANDLE CompletionPort, ; handle to an I/O completion port
 ULONG_PTR CompletionKey, ; completion key value
 HWND hWnd, ; handle to the notification window
 UINT MessageStart ; window message base event number
)
xxxx.FaxOpenPort(
 HANDLE FaxHandle, ; handle to the fax server
 DWORD DeviceId, ; receiving device identifier
 DWORD Flags, ; set of port access level bit flags
 LPHANDLE FaxPortHandle ; fax port handle
)
xxxx.FaxPrintCoverPage(
 CONST FAX_CONTEXT_INFO *FaxContextInfo, ; pointer to device context structure
 CONST FAX_COVERPAGE_INFO *CoverPageInfo ; pointer to local cover page structure
)
xxxx.FaxRegisterRoutingExtension(
 HANDLE FaxHandle, ; handle to the fax server
 LPCWSTR ExtensionName, ; fax routing extension DLL name
 LPCWSTR FriendlyName, ; fax routing extension user-friendly name
 LPCWSTR ImageName, ; path to fax routing extension DLL
 PFAX_ROUTING_INSTALLATION_CALLBACK CallBack, ; pointer to fax routing installation callback function
 LPVOID Context ; pointer to context information
)
xxxx.FaxRegisterServiceProvider(
 LPCWSTR DeviceProvider, ; fax service provider DLL name
 LPCWSTR FriendlyName, ; fax service provider user-friendly name
 LPCWSTR ImageName, ; path to fax service provider DLL
 LPCWSTR TspName ; telephony service provider name
)
xxxx.FaxSendDocument(
 HANDLE FaxHandle, ; handle to the fax server
 LPCTSTR FileName, ; file with data to transmit
 PFAX_JOB_PARAM JobParams, ; pointer to job information structure
 CONST FAX_COVERPAGE_INFO *CoverpageInfo OPTIONAL, ; pointer to local cover page structure
 LPDWORD FaxJobId ; fax job identifier
)
xxxx.FaxSendDocumentForBroadcast(
 HANDLE FaxHandle, ; handle to the fax server
 LPCTSTR FileName, ; fax document file name
 LPDWORD FaxJobId, ; fax job identifier
 PFAX_RECIPIENT_CALLBACK FaxRecipientCallback, ; pointer to fax recipient callback function
 LPVOID Context ; pointer to context information
)
xxxx.FaxSetConfiguration(
 HANDLE FaxHandle, ; handle to the fax server
 CONST FAX_CONFIGURATION *FaxConfig ; new configuration data
)
xxxx.FaxSetGlobalRoutingInfo(
 HANDLE FaxHandle, ; handle to the fax server
 CONST FAX_GLOBAL_ROUTING_INFO *RoutingInfo ; pointer to global routing information structure
)
xxxx.FaxSetJob(
 HANDLE FaxHandle, ; handle to the fax server
 DWORD JobId, ; fax job identifier
 DWORD Command, ; job command value
 CONST FAX_JOB_ENTRY *JobEntry ; pointer to job information structure
)
xxxx.FaxSetLoggingCategories(
 HANDLE FaxHandle, ; handle to the fax server
 CONST FAX_LOG_CATEGORY *Categories, ; new logging categories data
 DWORD NumberCategories ; number of category structures
)
xxxx.FaxSetPort(
 HANDLE FaxPortHandle, ; fax port handle
 CONST FAX_PORT_INFO *PortInfo ; new port configuration data
)
xxxx.FaxSetRoutingInfo(
 HANDLE FaxPortHandle, ; fax port handle
 LPCTSTR RoutingGuid, ; GUID that identifies fax routing method
 CONST BYTE *RoutingInfoBuffer, ; buffer with routing method data
 DWORD RoutingInfoBufferSize ; size of buffer, in bytes
)
xxxx.FaxStartPrintJob(
 LPCTSTR PrinterName, ; printer for fax job
 CONST FAX_PRINT_INFO *PrintInfo, ; print job information structure
 LPDWORD FaxJobId, ; fax job identifier
 PFAX_CONTEXT_INFO FaxContextInfo ; pointer to device context structure
)
MAPI32.FBadColumnSet(
 LPSPropTagArray lpptaCols
)
MAPI32.FBadEntryList(
 LPENTRYLIST lpEntryList
)
MAPI32.FBadProp(
 LPSPropValue lpprop
)
MAPI32.FBadPropTag(
 ULONG ulPropTag
)
MAPI32.FBadRestriction(
 LPSRestriction lpres
)
MAPI32.FBadRglpNameID(
 LPMAPINAMEID FAR * lppNameId,
 ULONG cNames
)
MAPI32.FBadRglpszW(
 LPWSTR FAR * lppszW,
 ULONG cStrings
)
MAPI32.FBadRow(
 LPSRow lprow
)
MAPI32.FBadRowSet(
 LPSRowSet lpRowSet
)
MAPI32.FBadSortOrderSet(
 LPSSortOrderSet lpsos
)
MAPI32.FBinFromHex(
 LPTSTR sz,
 LPBYTE pb
)
MAPI32.FEqualNames(
 LPMAPINAMEID lpName1,
 LPMAPINAMEID lpName2
)
USER-DEFINED.FiberProc(
 PVOID lpParameter ; fiber data
)
xxxx.FileEncryptionStatus(
 LPCTSTR lpFileName, ; file name
 LPDWORD lpStatus ; encryption status
)
USER-DEFINED.FileIOCompletionRoutine(
 DWORD dwErrorCode, ; completion code
 DWORD dwNumberOfBytesTransfered, ; number of bytes transferred
 LPOVERLAPPED lpOverlapped ; I/O information buffer
)
KERNEL32.FileTimeToDosDateTime(
 CONST FILETIME *lpFileTime, ; 64-bit file time
 LPWORD lpFatDate, ; MS-DOS date
 LPWORD lpFatTime ; MS-DOS time
)
KERNEL32.FileTimeToLocalFileTime(
 CONST FILETIME *lpFileTime, ; UTC file time to convert
 LPFILETIME lpLocalFileTime ; converted file time
)
KERNEL32.FileTimeToSystemTime(
 CONST FILETIME *lpFileTime, ; file time to convert
 LPSYSTEMTIME lpSystemTime ; receives system time
)
KERNEL32.FillConsoleOutputAttribute(
 HANDLE hConsoleOutput, ; handle to screen buffer
 WORD wAttribute, ; color attribute
 DWORD nLength, ; number of cells
 COORD dwWriteCoord, ; first coordinates
 LPDWORD lpNumberOfAttrsWritten ; number of cells written
)
KERNEL32.FillConsoleOutputCharacterA(
 HANDLE hConsoleOutput, ; handle to screen buffer
 TCHAR cCharacter, ; character
 DWORD nLength, ; number of cells
 COORD dwWriteCoord, ; first coordinates
 LPDWORD lpNumberOfCharsWritten ; number of cells written
)
xxxx.FillMemory(
 PVOID Destination, ; memory block
 SIZE_T Length, ; size of memory block
 BYTE Fill ; fill value
)
GDI32.FillPath(
 HDC hdc ; handle to DC
)
USER32.FillRect(
 HDC hDC, ; handle to DC
 CONST RECT *lprc, ; rectangle
 HBRUSH hbr ; handle to brush
)
GDI32.FillRgn(
 HDC hdc, ; handle to device context
 HRGN hrgn, ; handle to region to be filled
 HBRUSH hbr ; handle to brush used to fill the region
)
KERNEL32.FindAtom(
 LPCTSTR lpString ; string to find
)
KERNEL32.FindClose(
 HANDLE hFindFile ; file search handle
)
KERNEL32.FindCloseChangeNotification(
 HANDLE hChangeHandle ; handle to change notification
)
WINSPOOL.FindClosePrinterChangeNotification(
 HANDLE hChange ; handle to change notification object
)
xxxx.FindEnvironmentString(
 LPCTSTR pszEnvVar
)
SHELL32.FindExecutableA(
 LPCTSTR lpFile,
 LPCTSTR lpDirectory,
 LPTSTR lpResult
)
KERNEL32.FindFirstChangeNotificationA(
 LPCTSTR lpPathName, ; directory name
 BOOL bWatchSubtree, ; monitoring option
 DWORD dwNotifyFilter ; filter conditions
)
KERNEL32.FindFirstFileA(
 LPCTSTR lpFileName, ; file name
 LPWIN32_FIND_DATA lpFindFileData ; data buffer
)
KERNEL32.FindFirstFileExA(
 LPCTSTR lpFileName, ; file name
 FINDEX_INFO_LEVELS fInfoLevelId, ; information level
 LPVOID lpFindFileData, ; information buffer
 FINDEX_SEARCH_OPS fSearchOp, ; filtering type
 LPVOID lpSearchFilter, ; search criteria
 DWORD dwAdditionalFlags ; additional search control
)
WINSPOOL.FindFirstPrinterChangeNotification(
 HANDLE hPrinter, ; handle to printer
 DWORD fdwFlags, ; conditions to monitor
 DWORD fdwOptions, ; reserved, must be zero
 LPVOID pPrinterNotifyOptions ; fields to monitor
)
xxxx.FindFirstVolume(
 LPTSTR lpszVolumeName, ; output buffer
 DWORD cchBufferLength ; size of output buffer
)
xxxx.FindFirstVolumeMountPoint(
 LPTSTR lpszRootPathName, ; volume name
 LPTSTR lpszVolumeMountPoint, ; output buffer
 DWORD cchBufferLength ; size of output buffer
)
KERNEL32.FindNextChangeNotification(
 HANDLE hChangeHandle ; handle to change notification
)
KERNEL32.FindNextFileA(
 HANDLE hFindFile, ; search handle
 LPWIN32_FIND_DATA lpFindFileData ; data buffer
)
WINSPOOL.FindNextPrinterChangeNotification(
 HANDLE hChange, ; change notification
 PDWORD pdwChange, ; condition that changed
 LPVOID pPrinterNotifyOptions, ; refresh option
 LPVOID *ppPrinterNotifyInfo ; printer information
)
xxxx.FindNextVolume(
 HANDLE hFindVolume, ; volume search handle
 LPTSTR lpszVolumeName, ; output buffer
 DWORD cchBufferLength ; size of output buffer
)
xxxx.FindNextVolumeMountPoint(
 HANDLE hFindVolumeMountPoint, ; search handle
 LPTSTR lpszVolumeMountPoint, ; output buffer
 DWORD cchBufferLength ; size of output buffer
)
KERNEL32.FindResourceA(
 HMODULE hModule, ; module handle
 LPCTSTR lpName, ; resource name
 LPCTSTR lpType ; resource type
)
KERNEL32.FindResourceExA(
 HMODULE hModule, ; module handle
 LPCTSTR lpType, ; resource type
 LPCTSTR lpName, ; resource name
 WORD wLanguage ; resource language
)
COMDLG32.FindTextA(
 LPFINDREPLACE lpfr ; initialization data
)
xxxx.FindVolumeClose(
 HANDLE hFindVolume ; search handle
)
xxxx.FindVolumeMountPointClose(
 HANDLE hFindVolumeMountPoint ; search handle
)
USER32.FindWindowA(
 LPCTSTR lpClassName, ; class name
 LPCTSTR lpWindowName ; window name
)
USER32.FindWindowExA(
 HWND hwndParent, ; handle to parent window
 HWND hwndChildAfter, ; handle to child window
 LPCTSTR lpszClass, ; class name
 LPCTSTR lpszWindow ; window name
)
xxxx.FixBrushOrgExA(Win32s Compatibility)
)
USER32.FlashWindow(
 HWND hWnd, ; handle to window
 BOOL bInvert ; flash status
)
USER32.FlashWindowEx(
 PFLASHWINFO pfwi ; flash status information
)
COMCTL32.FlatSB_EnableScrollBar(
 HWND hwnd,
 int wSBflags,
 UINT wArrows
)
COMCTL32.FlatSB_GetScrollInfo(
 HWND hwnd,
 int fnBar,
 LPSCROLLINFO lpsi
)
COMCTL32.FlatSB_GetScrollPos(
 HWND hwnd,
 int code
)
COMCTL32.FlatSB_GetScrollProp(
 HWND hwnd,
 UINT index,
 LPINT pValue
)
COMCTL32.FlatSB_GetScrollRange(
 HWND hwnd,
 int code,
 LPINT lpMinPos,
 LPINT lpMaxPos
)
COMCTL32.FlatSB_SetScrollInfo(
 HWND hwnd,
 int fnBar,
 LPSCROLLINFO lpsi,
 BOOL fRedraw
)
COMCTL32.FlatSB_SetScrollPos(
 HWND hwnd,
 int code,
 int nPos,
 BOOL fRedraw
)
COMCTL32.FlatSB_SetScrollProp(
 HWND hwnd,
 UINT index,
 int newValue,
 BOOL fRedraw
)
COMCTL32.FlatSB_SetScrollRange(
 HWND hwnd,
 int code,
 int nMinPos,
 int nMaxPos,
 BOOL fRedraw
)
COMCTL32.FlatSB_ShowScrollBar(
 HWND hwnd,
 int code,
 BOOL fShow
)
GDI32.FlattenPath(
 HDC hdc ; handle to DC
)
GDI32.FloodFill(
 HDC hdc, ; handle to DC
 int nXStart, ; starting x-coordinate
 int nYStart, ; starting y-coordinate
 COLORREF crFill ; fill color
)
KERNEL32.FlushConsoleInputBuffer(
 HANDLE hConsoleInput ; handle to console input buffer
)
KERNEL32.FlushFileBuffers(
 HANDLE hFile ; handle to file
)
KERNEL32.FlushInstructionCache(
 HANDLE hProcess, ; handle to process
 LPCVOID lpBaseAddress, ; base of region to flush
 DWORD dwSize ; length of region to flush
)
xxxx.FlushPrinter(
 HANDLE hPrinter, ; handle to printer object
 LPVOID pBuf, ; printer data buffer
 DWORD cbBuf, ; size of data buffer
 LPDWORD pcWritten, ; bytes received
 DWORD cSleep ; idle period
)
KERNEL32.FlushViewOfFile(
 LPCVOID lpBaseAddress, ; starting address
 SIZE_T dwNumberOfBytesToFlush ; number of bytes in range
)
USER-DEFINED.FMExtensionProc(
 HWND hwnd,
 WORD wMsg,
 LONG lParam
)
USER-DEFINED.FNIDLE(
 LPVOID lpvContext
)
KERNEL32.FoldStringA(
 DWORD dwMapFlags, ; mapping transformation options
 LPCTSTR lpSrcStr, ; source string
 int cchSrc, ; size of source string
 LPTSTR lpDestStr, ; destination buffer
 int cchDest ; size of destination buffer
)
USER-DEFINED.ForegroundIdleProc(
 int code, ; hook code
 DWORD wParam, ; not used
 LONG lParam ; not used
)
KERNEL32.FormatMessageA(
 DWORD dwFlags, ; source and processing options
 LPCVOID lpSource, ; message source
 DWORD dwMessageId, ; message identifier
 DWORD dwLanguageId, ; language identifier
 LPTSTR lpBuffer, ; message buffer
 DWORD nSize, ; maximum size of message buffer
 va_list *Arguments ; array of message inserts
)
MAPI32.FPropCompareProp(
 LPSPropValue lpSPropValue1,
 ULONG ulRelOp,
 LPSPropValue lpSPropValue2
)
MAPI32.FPropContainsProp(
 LPSPropValue lpSPropValueDst,
 LPSPropValue lpSPropValueSrc,
 ULONG ulFuzzyLevel
)
MAPI32.FPropExists(
 LPMAPIPROP pobj,
 ULONG ulPropTag
)
USER32.FrameRect(
 HDC hDC, ; handle to DC
 CONST RECT *lprc, ; rectangle
 HBRUSH hbr ; handle to brush
)
GDI32.FrameRgn(
 HDC hdc, ; handle to device context
 HRGN hrgn, ; handle to region to be framed
 HBRUSH hbr, ; handle to brush used to draw border
 int nWidth, ; width of region frame
 int nHeight ; height of region frame
)
KERNEL32.FreeConsole(VOID)
)
USER32FreeDDElParam(
 UINT msg, ; posted DDE message
 LPARAM lParam ; lParam of message
)
xxxx.FreeEncryptionCertificateHashList(
 PENCRYPTION_CERTIFICATE_HASH_LIST pHashes ; hash list
)
KERNEL32.FreeEnvironmentStringsA(
 LPTSTR lpszEnvironmentBlock ; environment strings
)
KERNEL32.FreeLibrary(
 HMODULE hModule ; handle to DLL module
)
KERNEL32.FreeLibraryAndExitThread(
 HMODULE hModule, ; handle to the DLL module
 DWORD dwExitCode ; exit code for thread
)
xxxx.FreeModule(OBSOLETE - Use FreeLibrary)
FreePadrlist(
 LPADRLIST padrlist
)
WINSPOOL.FreePrinterNotifyInfo(
 PPRINTER_NOTIFY_INFO pPrinterNotifyInfo ; buffer
)
xxxx.FreeProcInstance(OBSOLETE)
FreeProws(
 LPSRowSet prows
)
xxxx.FreeResource(OBSOLETE)
)
xxxx.FreeUserPhysicalPages(
 HANDLE hProcess, ; handle to process
 PULONG_PTR NumberOfPages, ; pages to free
 PULONG_PTR UserPfnArray ; virtual address
)
USER-DEFINED.FRHookProc(
 HWND hdlg, ; handle to dialog box
 UINT uiMsg, ; message identifier
 WPARAM wParam, ; message parameter
 LPARAM lParam ; message parameter
)
MAPI32.FtAddFt(
 FILETIME Addend1,
 FILETIME Addend2
)
MAPI32.FtgRegisterIdleRoutine(
 PFNIDLE pfnIdle,
 LPVOID pvIdleParam,
 short priIdle,
 ULONG csecIdle,
 USHORT iroIdle
)
MAPI32.FtMulDw(
 DWORD Multiplier,
 FILETIME Multiplicand
)
MAPI32.FtMulDwDw(
 DWORD Multiplicand,
 DWORD Multiplier
)
MAPI32.FtNegFt(
 FILETIME ft
)
MAPI32.FtSubFt(
 FILETIME Minuend,
 FILETIME Subtrahend
)
GDI32.GdiComment(
 HDC hdc, ; handle to a device context
 UINT cbSize, ; size of text buffer
 CONST BYTE *lpData ; text buffer
)
GDI32.GdiFlush(VOID)
GdiGetBatchLimit(VOID)
GdiSetBatchLimit(
 DWORD dwLimit ; batch limit
)
KERNEL32.GenerateConsoleCtrlEvent(
 DWORD dwCtrlEvent, ; signal to generate
 DWORD dwProcessGroupId ; process group to get signal
)
KERNEL32.GetACP(VOID)
)
USER32.GetActiveWindow(VOID)
)
GetAllUsersProfileDirectory(
 LPTSTR lpProfileDir, ; profile path buffer
 LPDWORD lpcchSize ; size of profile path buffer
)
xxxx.GetAltTabInfoA(
 HWND hwnd, ; handle to window
 int iItem, ; icon index
 PALTTABINFO pati, ; status information
 LPTSTR pszItemText, ; item name buffer
 UINT cchItemText ; size of item name buffer
)
xxxx.GetAncestor(
 HWND hwnd, ; handle to window
 UINT gaFlags ; ancestor
)
GDI32.GetArcDirection(
 HDC hdc ; handle to device context
)
GDI32.GetAspectRatioFilterEx(
 HDC hdc, ; handle to DC
 LPSIZE lpAspectRatio ; aspect-ratio filter
)
USER32.GetAsyncKeyState(
 int vKey ; virtual-key code
)
KERNEL32.GetAtomNameA(
 ATOM nAtom, ; atom identifying character string
 LPTSTR lpBuffer, ; buffer for atom string
 int nSize ; size of buffer
)
MAPI32.GetAttribIMsgOnIStg(
 LPVOID lpObject,
 LPSPropTagArray lpPropTagArray,
 LPSPropAttrArray FAR * lppPropAttrArray
)
KERNEL32.GetBinaryTypeA(
 LPCTSTR lpApplicationName, ; full file path
 LPDWORD lpBinaryType ; binary type information
)
GDI32.GetBitmapBits(
 HBITMAP hbmp, ; handle to bitmap
 LONG cbBuffer, ; number of bytes to copy
 LPVOID lpvBits ; buffer to receive bits
)
GDI32.GetBitmapDimensionEx(
 HBITMAP hBitmap, ; handle to bitmap
 LPSIZE lpDimension ; dimensions
)
GDI32.GetBkColor(
 HDC hdc ; handle to device context
)
GDI32.GetBkMode(
 HDC hdc ; handle to device context
)
GDI32.GetBoundsRect(
 HDC hdc, ; handle to device context
 LPRECT lprcBounds, ; bounding rectangle
 UINT flags ; function options
)
GDI32.GetBrushOrgEx(
 HDC hdc, ; handle to DC
 LPPOINT lppt ; coordinates of origin
)
xxxx.GetCalendarInfo(
 LCID Locale, ; locale
 CALID Calendar, ; calendar identifier
 CALTYPE CalType, ; calendar type
 LPTSTR lpCalData, ; information buffer
 int cchData, ; information buffer size
 LPDWORD lpValue ; data
)
USER32.GetCapture(VOID)
)
USER32.GetCaretBlinkTime(VOID)
)
USER32.GetCaretPos(
 LPPOINT lpPoint ; client coordinates
)
GDI32.GetCharABCWidthsA(
 HDC hdc, ; handle to DC
 UINT uFirstChar, ; first character in range
 UINT uLastChar, ; last character in range
 LPABC lpabc ; array of character widths
)
GDI32.GetCharABCWidthsFloatA(
 HDC hdc, ; handle to DC
 UINT iFirstChar, ; first character in range
 UINT iLastChar, ; last character in range
 LPABCFLOAT lpABCF ; array of character widths
)
GDI32.GetCharABCWidthsI(
 HDC hdc, ; handle to DC
 UINT giFirst, ; first glyph index in range
 UINT cgi, ; count of glyph indices in range
 LPWORD pgi, ; array of glyph indices
 LPABC lpabc ; array of character widths
)
GDI32.GetCharacterPlacementA(
 HDC hdc, ; handle to DC
 LPCTSTR lpString, ; character string
 int nCount, ; number of characters
 int nMaxExtent, ; maximum extent for string
 LPGCP_RESULTS lpResults, ; placement result
 DWORD dwFlags ; placement options
)
GDI32.GetCharWidth(
 HDC hdc, ; handle to DC
 UINT iFirstChar, ; first character in range
 UINT iLastChar, ; last character in range
 LPINT lpBuffer ; buffer for widths
)
GDI32.GetCharWidth32A(
 HDC hdc, ; handle to DC
 UINT iFirstChar, ; first character in range
 UINT iLastChar, ; last character in range
 LPINT lpBuffer ; buffer for widths
)
GDI32.GetCharWidthFloatA(
 HDC hdc, ; handle to DC
 UINT iFirstChar, ; first-character code point
 UINT iLastChar, ; last-character code point
 PFLOAT pxBuffer ; buffer for widths
)
GDI32.GetCharWidthI(
 HDC hdc, ; handle to DC
 UINT giFirst, ; first glyph index in range
 UINT cgi, ; number of glyph indicies in range
 LPWORD pgi, ; array of glyph indices
 LPINT lpBuffer ; buffer for widths
)
USER32.GetClassInfoA(
 HINSTANCE hInstance, ; handle to application instance
 LPCTSTR lpClassName, ; class name
 LPWNDCLASS lpWndClass ; class data
)
USER32.GetClassInfoExA(
 HINSTANCE hinst, ; handle to application instance
 LPCTSTR lpszClass, ; class name
 LPWNDCLASSEX lpwcx ; class data
)
USER32.GetClassLongA(
 HWND hWnd, ; handle to window
 int nIndex ; offset of value to retrieve
)
USER32.GetClassLongPtr(
 HWND hWnd, ; handle to window
 int nIndex ; offset of value to retrieve
)
USER32.GetClassNameA(
 HWND hWnd, ; handle to window
 LPTSTR lpClassName, ; class name
 int nMaxCount ; size of class name buffer
)
USER32.GetClassWord(
 HWND hWnd, ; handle to window
 int nIndex ; offset of value to retrieve
)
USER32.GetClientRect(
 HWND hWnd, ; handle to window
 LPRECT lpRect ; client coordinates
)
USER32.GetClipboardData(
 UINT uFormat ; clipboard format
)
USER32.GetClipboardFormatNameA(
 UINT format, ; clipboard format to retrieve
 LPTSTR lpszFormatName, ; format name
 int cchMaxCount ; length of format name buffer
)
USER32.GetClipboardOwner(VOID)
)
USER32.GetClipboardSequenceNumber(VOID)
)
xxxx.GetClipboardViewer(VOID)
)
GDI32.GetClipBox(
 HDC hdc, ; handle to DC
 LPRECT lprc ; rectangle
)
USER32.GetClipCursor(
 LPRECT lpRect ; screen coordinates
)
GDI32.GetClipRgn(
 HDC hdc, ; handle to DC
 HRGN hrgn ; handle to region
)
GDI32.GetColorAdjustment(
 HDC hdc, ; handle to DC
 LPCOLORADJUSTMENT lpca ; color adjustment values
)
xxxx.GetComboBoxInfo(
 HWND hwndCombo, ; handle to combo box
 PCOMBOBOXINFO pcbi ; combo box information
)
KERNEL32.GetCommandLineA(VOID)
)
KERNEL32GetCommConfig(
 HANDLE hCommDev, ; handle to communications service
 LPCOMMCONFIG lpCC, ; configuration information
 LPDWORD lpdwSize ; size of buffer
)
KERNEL32.GetCommMask(
 HANDLE hFile, ; handle to communications device
 LPDWORD lpEvtMask ; event mask
)
KERNEL32.GetCommModemStatus(
 HANDLE hFile, ; handle to communications device
 LPDWORD lpModemStat ; control-register values
)
KERNEL32.GetCommProperties(
 HANDLE hFile, ; handle to comm device
 LPCOMMPROP lpCommProp ; communications properties
)
KERNEL32.GetCommState(
 HANDLE hFile, ; handle to communications device
 LPDCB lpDCB ; device-control block
)
KERNEL32.GetCommTimeouts(
 HANDLE hFile, ; handle to comm device
 LPCOMMTIMEOUTS lpCommTimeouts ; time-out values
)
KERNEL32.GetCompressedFileSizeA(
 LPCTSTR lpFileName, ; file name
 LPDWORD lpFileSizeHigh ; high-order DWORD of file size
)
KERNEL32.GetComputerNameA(
 LPTSTR lpBuffer, ; computer name
 LPDWORD lpnSize ; size of name buffer
)
KERNEL32.GetComputerNameEx(
 COMPUTER_NAME_FORMAT NameType, ; name type
 LPTSTR lpBuffer, ; name buffer
 LPDWORD lpnSize ; size of name buffer
)
KERNEL32.GetComputerObjectName(
 EXTENDED_NAME_FORMAT NameFormat, ; name format
 LPTSTR lpNameBuffer, ; name buffer
 PULONG nSize ; size of name buffer
)
KERNEL32.GetConsoleCP(VOID)
)
KERNEL32.GetConsoleCursorInfo(
 HANDLE hConsoleOutput, ; handle to screen buffer
 PCONSOLE_CURSOR_INFO lpConsoleCursorInfo ; cursor information
)
KERNEL32.GetConsoleMode(
 HANDLE hConsoleHandle, ; handle to console input or screen buffer
 LPDWORD lpMode ; current mode flags
)
KERNEL32.GetConsoleOutputCP(VOID)
)
KERNEL32.GetConsoleScreenBufferInfo(
 HANDLE hConsoleOutput, ; handle to screen buffer
 PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo ; screen buffer information
)
KERNEL32.GetConsoleTitleA(
 LPTSTR lpConsoleTitle, ; console title
 DWORD nSize ; size of title buffer
)
xxxx.GetConsoleWindow(VOID)
)
KERNEL32.GetCPInfo(
 UINT CodePage, ; code page identifier
 LPCPINFO lpCPInfo ; information buffer
)
KERNEL32..GetCPInfoExA(
 UINT CodePage, ; code-page identifier
 DWORD dwFlags, ; flags (must be zero)
 LPCPINFOEX lpCPInfoEx ; structure for information
)
KERNEL32.GetCurrencyFormatA(
 LCID Locale, ; locale
 DWORD dwFlags, ; operation option
 LPCTSTR lpValue, ; input number string
 CONST CURRENCYFMT *lpFormat, ; formatting information
 LPTSTR lpCurrencyStr, ; output buffer
 int cchCurrency ; size of output buffer
)
KERNEL32.GetCurrentDirectoryA(
 DWORD nBufferLength, ; size of directory buffer
 LPTSTR lpBuffer ; directory buffer
)
ADVAPI32.GetCurrentHwProfileA(
 LPHW_PROFILE_INFO lpHwProfileInfo ; profile information
)
GDI32.GetCurrentObject(
 HDC hdc, ; handle to DC
 UINT uObjectType ; object type
)
GDI32.GetCurrentPositionEx(
 HDC hdc, ; handle to device context
 LPPOINT lpPoint ; current position
)
KERNEL32.GetCurrentProcess(VOID)
)
KERNEL32.GetCurrentProcessId(VOID)
)
KERNEL32GetCurrentThread(VOID)
)
KERNEL32GetCurrentThreadId(VOID)
)
xxxx.GetCurrentTime(OBSOLETE - Use GetTickCount)
)
USER32.GetCursor(VOID)
)
USER32.GetCursorInfo(
 PCURSORINFO pci ; cursor information
)
USER32.GetCursorPos(
 LPPOINT lpPoint ; cursor position
)
KERNEL32.GetDateFormatA(
 LCID Locale, ; locale
 DWORD dwFlags, ; options
 CONST SYSTEMTIME *lpDate, ; date
 LPCTSTR lpFormat, ; date format
 LPTSTR lpDateStr, ; formatted string buffer
 int cchDate ; size of buffer
)
USER32.GetDC(
 HWND hWnd ; handle to window
)
MSIMG32.GetDCBrushColor(
 HDC hdc ; handle to DC
)
USER32.GetDCEx(
 HWND hWnd, ; handle to window
 HRGN hrgnClip, ; handle to clipping region
 DWORD flags ; creation options
)
GDI32.GetDCOrgEx(
 HDC hdc, ; handle to a DC
 LPPOINT lpPoint ; translation origin
)
MSIMG32.GetDCPenColor(
 HDC hdc ; handle to DC
)
KERNEL32.GetDefaultCommConfigA(
 LPCTSTR lpszName, ; device name string
 LPCOMMCONFIG lpCC, ; configuration information
 LPDWORD lpdwSize ; size of buffer
)
xxxx.GetDefaultPrinterA(
 LPTSTR pszBuffer, ; printer name buffer
 LPDWORD pcchBuffer ; size of name buffer
)
xxxx.GetDefaultUserProfileDirectory(
 LPTSTR lpProfileDir, ; profile path buffer
 LPDWORD lpcchSize ; size of profile path buffer
)
USER32.GetDesktopWindow(VOID)
GetDeviceCaps(
 HDC hdc, ; handle to DC
 int nIndex ; index of capability
)
KERNEL32.GetDevicePowerState(
 HANDLE hDevice, ; device-context handle
 BOOL *pfOn ; receives power state
)
USER32.GetDialogBaseUnits(VOID)
)
GDI32.GetDIBColorTable(
 HDC hdc, ; handle to DC
 UINT uStartIndex, ; color table index of first entry
 UINT cEntries, ; number of entries to retrieve
 RGBQUAD *pColors ; array of color table entries
)
GDI32.GetDIBits(
 HDC hdc, ; handle to DC
 HBITMAP hbmp, ; handle to bitmap
 UINT uStartScan, ; first scan line to set
 UINT cScanLines, ; number of scan lines to copy
 LPVOID lpvBits, ; array for bitmap bits
 LPBITMAPINFO lpbi, ; bitmap data buffer
 UINT uUsage ; RGB or palette index
)
KERNEL32.GetDiskFreeSpaceA(
 LPCTSTR lpRootPathName, ; root path
 LPDWORD lpSectorsPerCluster, ; sectors per cluster
 LPDWORD lpBytesPerSector, ; bytes per sector
 LPDWORD lpNumberOfFreeClusters, ; free clusters
 LPDWORD lpTotalNumberOfClusters ; total clusters
)
KERNEL32.GetDiskFreeSpaceExA(
 LPCTSTR lpDirectoryName, ; directory name
 PULARGE_INTEGER lpFreeBytesAvailable, ; bytes available to caller
 PULARGE_INTEGER lpTotalNumberOfBytes, ; bytes on disk
 PULARGE_INTEGER lpTotalNumberOfFreeBytes ; free bytes on disk
)
USER32.GetDlgCtrlID(
 HWND hwndCtl ; handle to control
)
USER32.GetDlgItem(
 HWND hDlg, ; handle to dialog box
 int nIDDlgItem ; control identifier
)
USER32.GetDlgItemInt(
 HWND hDlg, ; handle to dialog box
 int nIDDlgItem, ; control identifier
 BOOL *lpTranslated, ; success state
 BOOL bSigned ; signed or unsigned value
)
USER32.GetDlgItemTextA(
 HWND hDlg, ; handle to dialog box
 int nIDDlgItem, ; control identifier
 LPTSTR lpString, ; pointer to buffer for text
 int nMaxCount ; maximum size of string
)
USER32.GetDoubleClickTime(VOID)
)
KERNEL32.GetDriveTypeA(
 LPCTSTR lpRootPathName ; root directory
)
COMCTL32.GetEffectiveClientRect(
 HWND hWnd,
 LPRECT lprc,
 LPINT lpInfo
)
GDI32.GetEnhMetaFileA(
 LPCTSTR lpszMetaFile ; file name
)
GDI32.GetEnhMetaFileBits(
 HENHMETAFILE hemf, ; handle to metafile
 UINT cbBuffer, ; size of data buffer
 LPBYTE lpbBuffer ; data buffer
)
GDI32.GetEnhMetaFileDescriptionA(
 HENHMETAFILE hemf, ; handle to enhanced metafile
 UINT cchBuffer, ; size of text buffer
 LPTSTR lpszDescription ; text buffer
)
GDI32.GetEnhMetaFileHeader(
 HENHMETAFILE hemf, ; handle to enhanced metafile
 UINT cbBuffer, ; size of buffer
 LPENHMETAHEADER lpemh ; data buffer
)
GDI32.GetEnhMetaFilePaletteEntries(
 HENHMETAFILE hemf, ; handle to enhanced metafile
 UINT cEntries, ; count of palette entries
 LPPALETTEENTRY lppe ; array of palette entries
)
KERNEL32.GetEnvironmentStringsA(VOID)
)
KERNEL32.GetEnvironmentVariableA(
 LPCTSTR lpName, ; environment variable name
 LPTSTR lpBuffer, ; buffer for variable value
 DWORD nSize ; size of buffer
)
xxxx.GetEventLogInformation(
 HANDLE hEventLog, ; handle to event log
 DWORD dwInfoLevel, ; information to retrieve
 LPVOID lpBuffer, ; buffer for read data
 DWORD cbBufSize, ; size of buffer in bytes
 LPDWORD pcbBytesNeeded ; number of bytes needed
)
USER-DEFINED.GetEventMessage(
 ROUTING_PROTOCOL_EVENTS *Event, ; address of message queue entry
 MESSAGE *Result ; event dependent message
)
xxxx.GetExceptionCode(VOID)
)
xxxx.GetExceptionInformation(VOID)
)
GetExitCodeProcess(
 HANDLE hProcess, ; handle to the process
 LPDWORD lpExitCode ; termination status
)
KERNEL32.GetExitCodeThread(
 HANDLE hThread, ; handle to the thread
 LPDWORD lpExitCode ; termination status
)
LZ32.GetExpandedNameA(
 LPTSTR lpszSource, ; name of compressed file
 LPTSTR lpszBuffer ; original file name
)
KERNEL32.GetFileAttributesA(
 LPCTSTR lpFileName ; name of file or directory
)
KERNEL32.GetFileAttributesEx A(
 LPCTSTR lpFileName, ; file or directory name
 GET_FILEEX_INFO_LEVELS fInfoLevelId, ; attribute
 LPVOID lpFileInformation ; attribute information
)
KERNEL32.GetFileInformationByHandle(
 HANDLE hFile, ; handle to file
 LPBY_HANDLE_FILE_INFORMATION lpFileInformation ; buffer
)
KERNEL32.GetFileSize(
 HANDLE hFile, ; handle to file
 LPDWORD lpFileSizeHigh ; high-order word of file size
)
KERNEL32.GetFileSizeEx(
 HANDLE hFile, ; handle to file
 PLARGE_INTEGER lpFileSize ; file size
)
KERNEL32.GetFileTime(
 HANDLE hFile, ; handle to file
 LPFILETIME lpCreationTime, ; creation time
 LPFILETIME lpLastAccessTime, ; last access time
 LPFILETIME lpLastWriteTime ; last write time
)
COMDLG32.GetFileTitleA(
 LPCTSTR lpszFile, ; path and file name
 LPTSTR lpszTitle, ; file name buffer
 WORD cbBuf ; length of buffer
)
KERNEL32.GetFileType(
 HANDLE hFile ; handle to file
)
VERSION.GetFileVersionInfoA(
 LPTSTR lptstrFilename, ; file name
 DWORD dwHandle, ; ignored
 DWORD dwLen, ; size of buffer
 LPVOID lpData ; version information buffer
)
VERSION.GetFileVersionInfoSize A(
 LPTSTR lptstrFilename, ; file name
 LPDWORD lpdwHandle ; set to zero
)
USER-DEFINED.GetFirstOrderedService(
 DWORD OrderingMethod,
 DWORD ExclusionFlags,
 OUT PIPX_SERVICE Service
)
USER32.GetFocus(VOID)
)
GDI32GetFontData(
 HDC hdc, ; handle to DC
 DWORD dwTable, ; metric table name
 DWORD dwOffset, ; offset into table
 LPVOID lpvBuffer, ; buffer for returned data
 DWORD cbData ; length of data
)
GDI32.GetFontLanguageInfo(
 HDC hdc ; handle to DC
)
GDI32.GetFontUnicodeRanges(
 HDC hdc, ; handle to DC
 LPGLYPHSET lpgs ; glyph set
)
USER32.GetForegroundWindow(VOID)
)
WINSPOOL.GetFormA(
 HANDLE hPrinter, ; handle to printer
 LPTSTR pFormName, ; form name
 DWORD Level, ; information level
 LPBYTE pForm, ; array of forms
 DWORD cbBuf, ; bytes in array
 LPDWORD pcbNeeded ; bytes received or required
)
xxxx.GetFreeSpace(OBSOLETE - Use GlobalMemoryStatus)
)
KERNEL32.GetFullPathNameA(
 LPCTSTR lpFileName, ; file name
 DWORD nBufferLength, ; size of path buffer
 LPTSTR lpBuffer, ; path buffer
 LPTSTR *lpFilePart ; address of file name in path
)
xxxx.GetGeoInfo(
 GEOID GeoId, ; location identifier
 GEOTYPE GeoType, ; type of information requested
 LPTSTR lpGeoData, ; buffer for results
 int cchData, ; size of buffer
 LANGID language ; language id
)
USER-DEFINED.GetGlobalInfo(
 PVOID GlobalInfo ; address of configuration information
 PULONG GlobalInfoSize ; size of configuration information
)
GDI32.GetGlyphIndicesA(
 HDC hdc, ; handle to DC
 LPCTSTR lpstr, ; string to convert
 int c, ; number of characters in string
 LPWORD pgi, ; array of glyph indices
 DWORD fl ; glyph options
)
GDI32.GetGlyphOutlineA(
 HDC hdc, ; handle to DC
 UINT uChar, ; character to query
 UINT uFormat, ; data format
 LPGLYPHMETRICS lpgm, ; glyph metrics
 DWORD cbBuffer, ; size of data buffer
 LPVOID lpvBuffer, ; data buffer
 CONST MAT2 *lpmat2 ; transformation matrix
)
GDI32.GetGraphicsMode(
 HDC hdc ; handle to device context
)
USER32.GetGuiResources(
 HANDLE hProcess, ; handle to process
 DWORD uiFlags ; GUI object type
)
xxxx.GetGUIThreadInfo(
 DWORD idThread, ; thread identifier
 LPGUITHREADINFO lpgui ; thread information
)
KERNEL32.GetHandleInformation(
 HANDLE hObject, ; handle to object
 LPDWORD lpdwFlags ; handle properties
)
USER32.GetIconInfo(
 HICON hIcon, ; icon handle
 PICONINFO piconinfo ; icon structure
)
USER32.GetInputState(VOID)
)
xxxx.GetInstance(
 LPSPropValue pvalMv,
 LPSPropValue pvalSv,
 ULONG uliInst
)
xxxx.GetInterfaceInfo(
 ULONG InterfaceIndex, ; the index of the interface
 PVOID InterfaceInfo, ; buffer for interface information
 PULONG BufferSize, ; size of the buffer for interface information
 ULONG StructureVersion,
 ULONG StructureSize,
 ULONG StructureCount
)
WINSPOOL.GetJobA(
 HANDLE hPrinter, ; handle to printer
 DWORD JobId, ; job identifier
 DWORD Level, ; information level
 LPBYTE pJob, ; array of jobs
 DWORD cbBuf, ; bytes in array
 LPDWORD pcbNeeded ; bytes received or required
)
USER32.GetKBCodePage(VOID)
)
GDI32.GetKerningPairsA(
 HDC hdc, ; handle to DC
 DWORD nNumPairs, ; number of kerning pairs
 LPKERNINGPAIR lpkrnpair ; array of kerning pairs
)
USER32.GetKeyboardLayout(
 DWORD idThread ; thread identifier
)
USER32.GetKeyboardLayoutList(
 int nBuff, ; size of array
 HKL FAR *lpList ; array of input locale identifiers
)
USER32.GetKeyboardLayoutNameA(
 LPTSTR pwszKLID ; input locale identifier name
)
USER32.GetKeyboardState(
 PBYTE lpKeyState ; array of status data
)
USER32.GetKeyboardType(
 int nTypeFlag ; information type
)
USER32.GetKeyNameTextA(
 LONG lParam, ; second parameter of keyboard message
 LPTSTR lpString, ; buffer for key name
 int nSize ; maximum length of key name
)
USER32.GetKeyState(
 int nVirtKey ; virtual-key code
)
KERNEL32.GetLargestConsoleWindowSize(
 HANDLE hConsoleOutput ; handle to screen buffer
)
USER32.GetLastActivePopup(
 HWND hWnd ; handle to owner window
)
KERNEL32.GetLastError(VOID)
)
XXXX.GetLastInputInfo(
 PLASTINPUTINFO plii ; last input event
)
xxxx.GetLayeredWindowAttributes(
 HWND hwnd, ; handle to the layered window
 COLORREF *pcrKey, ; color key
 BYTE *pbAlpha, ; Alpha value
 DWORD *pdwFlags ; layering flags
)
xxxx.GetLayout(
 HDC hdc ; handle to DC
)
xxxx.GetListBoxInfo(
 HWND hwnd ; handle to list box
)
KERNEL32.GetLocaleInfoA(
 LCID Locale, ; locale identifier
 LCTYPE LCType, ; information type
 LPTSTR lpLCData, ; information buffer
 int cchData ; size of buffer
)
KERNEL32.GetLocalTime(
 LPSYSTEMTIME lpSystemTime ; system time
)
KERNEL32.GetLogicalDrives(VOID)
)
KERNEL32.GetLogicalDriveStringsA(
 DWORD nBufferLength, ; size of buffer
 LPTSTR lpBuffer ; drive strings buffer
)
KERNEL32.GetLongPathNameA(
 LPCTSTR lpszShortPath, ; file name
 LPTSTR lpszLongPath, ; path buffer
 DWORD cchBuffer ; size of path buffer
)
KERNEL32.GetMailslotInfo(
 HANDLE hMailslot, ; mailslot handle
 LPDWORD lpMaxMessageSize, ; maximum message size
 LPDWORD lpNextSize, ; size of next message
 LPDWORD lpMessageCount, ; number of messages
 LPDWORD lpReadTimeout ; read time-out interval
)
GDI32.GetMapMode(
 HDC hdc ; handle to device context
)
USER32.GetMenu(
 HWND hWnd ; handle to window
)
xxxx.GetMenuBarInfo(
 HWND hwnd, ; handle to window
 LONG idObject, ; menu object
 LONG idItem, ; item identifier
 PMENUBARINFO pmbi ; information
)
xxxx.GetMenuCheckMarkDimensions(VOID)
)
USER32.GetMenuContextHelpId(
 HMENU hmenu
)
USER32.GetMenuDefaultItem(
 HMENU hMenu, ; handle to menu
 UINT fByPos, ; retrieval option
 UINT gmdiFlags ; function search option
)
USER32.GetMenuInfo(
 HMENU hmenu, ; handle to menu
 LPCMENUINFO lpcmi ; menu information
)
USER32.GetMenuItemCount(
 HMENU hMenu ; handle to menu
)
USER32.GetMenuItemID(
 HMENU hMenu, ; handle to menu
 int nPos ; position of menu item
)
USER32.GetMenuItemInfoA(
 HMENU hMenu, ; handle to menu
 UINT uItem, ; menu item
 BOOL fByPosition, ; meaning of uItem
 LPMENUITEMINFO lpmii ; menu item information
)
USER32.GetMenuItemRect(
 HWND hWnd, ; handle to window
 HMENU hMenu, ; handle to menu
 UINT uItem, ; menu item position
 LPRECT lprcItem ; bounding rectangle
)
USER32.GetMenuState(
 HMENU hMenu, ; handle to menu
 UINT uId, ; menu item to query
 UINT uFlags ; options
)
USER32.GetMenuStringA(
 HMENU hMenu, ; handle to the menu
 UINT uIDItem, ; menu item identifier
 LPTSTR lpString, ; buffer for the string
 int nMaxCount, ; maximum length of string
 UINT uFlag ; options
)
USER32.GetMessageA(
 LPMSG lpMsg, ; message information
 HWND hWnd, ; handle to window
 UINT wMsgFilterMin, ; first message
 UINT wMsgFilterMax ; last message
)
USER32.GetMessageExtraInfo(VOID)
)
USER32.GetMessagePos(VOID)
)
USER32.GetMessageTime(VOID)
)
GDI32.GetMetaFileA(OBSOLETE- Use GetEnhMetaFile)
)
GDI32.GetMetaFileBitsEx(
 HMETAFILE hmf, ; handle to metafile
 UINT nSize, ; size of metafile
 LPVOID lpvData ; metafile data
)
GDI32.GetMetaRgn(
 HDC hdc, ; handle to DC
 HRGN hrgn ; handle to region
)
xxxx.GetMfeStatus(
 DWORD InterfaceIndex,
 DWORD GroupAddress,
 DWORD SourceAddress,
 PBYTE StatusCode
)
GDI32.GetMiterLimit(
 HDC hdc, ; handle to DC
 PFLOAT peLimit ; miter limit
)
KERNEL32.GetModuleFileNameA(
 HMODULE hModule, ; handle to module
 LPTSTR lpFilename, ; file name of module
 DWORD nSize ; size of buffer
)
KERNEL32.GetModuleHandleA(
 LPCTSTR lpModuleName ; module name
)
USER32.GetMonitorInfoA(
 HMONITOR hMonitor, ; handle to display monitor
 LPMONITORINFO lpmi ; display monitor information
)
xxxx.GetMouseMovePointsEx(
 UINT cbSize, ; size of mouse move point
 LPMOUSEMOVEPOINT lppt, ; current mouse move point
 LPMOUSEMOVEPOINT lpptBuf, ; buffer to store points
 int nBufPoints, ; points the buffer can store
 DWORD resolution ; resolution of the points
)
USER-DEFINED.GetMsgProc(
 int code, ; hook code
 WPARAM wParam, ; removal option
 LPARAM lParam ; message
)
xxxx.GetMUILanguage(VOID)
)
KERNEL32.GetNamedPipeHandleStateA(
 HANDLE hNamedPipe, ; handle to named pipe
 LPDWORD lpState, ; pipe state
 LPDWORD lpCurInstances, ; number of pipe instances
 LPDWORD lpMaxCollectionCount, ; maximum collection count
 LPDWORD lpCollectDataTimeout, ; time before transmission
 LPTSTR lpUserName, ; client user name
 DWORD nMaxUserNameSize ; size of user name buffer
)
KERNEL32.GetNamedPipeInfo(
 HANDLE hNamedPipe, ; handle to named pipe
 LPDWORD lpFlags, ; pipe type
 LPDWORD lpOutBufferSize, ; size of output buffer
 LPDWORD lpInBufferSize, ; size of input buffer
 LPDWORD lpMaxInstances ; maximum number of pipe instances
)
GDI32.GetNearestColor(
 HDC hdc, ; handle to DC
 COLORREF crColor ; color to be matched
)
GDI32.GetNearestPaletteIndex(
 HPALETTE hpal, ; handle to logical palette
 COLORREF crColor ; color to be matched
)
xxxx.GetNeighbors(
 DWORD InterfaceIndex,
 PDWORD NeighborList,
 PDWORD NeighborListSize,
 PBYTE InterfaceFlags
)
USER32.GetNextDlgGroupItem(
 HWND hDlg, ; handle to dialog box
 HWND hCtl, ; handle to control
 BOOL bPrevious ; direction flag
)
USER32.GetNextDlgTabItem(
 HWND hDlg, ; handle to dialog box
 HWND hCtl, ; handle to known control
 BOOL bPrevious ; direction flag
)
USER-DEFINED.GetNextOrderedService(
 DWORD OrderingMethod,
 DWORD ExclusionFlags,
 PIPX_SERVICE Service
)
USER32.GetNextWindow(
 HWND hWnd, ; handle to current window
 UINT wCmd ; direction
)
KERNEL32.GetNumberFormatA(
 LCID Locale, ; locale
 DWORD dwFlags, ; options
 LPCTSTR lpValue, ; input number string
 CONST NUMBERFMT *lpFormat, ; formatting information
 LPTSTR lpNumberStr, ; output buffer
 int cchNumber ; size of output buffer
)
KERNEL32.GetNumberOfConsoleInputEvents(
 HANDLE hConsoleInput, ; handle to console input buffer
 LPDWORD lpcNumberOfEvents ; number of events
)
KERNEL32.GetNumberOfConsoleMouseButtons(
 LPDWORD lpNumberOfMouseButtons ; number of buttons
)
ADVAPI32.GetNumberOfEventLogRecords(
 HANDLE hEventLog, ; handle to event log
 PDWORD NumberOfRecords ; buffer for number of records
)
GDI32.GetObjectA(
 HGDIOBJ hgdiobj, ; handle to graphics object
 int cbBuffer, ; size of buffer for object information
 LPVOID lpvObject ; buffer for object information
)
GDI32.GetObjectType(
 HGDIOBJ h ; handle to graphics object
)
KERNEL32.GetOEMCP(void)
)
ADVAPI32.GetOldestEventLogRecord(
 HANDLE hEventLog, ; handle to event log
 PDWORD OldestRecord ; buffer for number of records
)
USER32.GetOpenClipboardWindow(VOID)
)
COMDLG32.GetOpenFileNameA(
 LPOPENFILENAME lpofn ; initialization data
)
GDI32.GetOutlineTextMetricsA(
 HDC hdc, ; handle to DC
 UINT cbData, ; size of metric data array
 LPOUTLINETEXTMETRIC lpOTM ; metric data array
)
KERNEL32.GetOverlappedResult(
 HANDLE hFile, ; handle to file, pipe, or device
 LPOVERLAPPED lpOverlapped, ; overlapped structure
 LPDWORD lpNumberOfBytesTransferred, ; bytes transferred
 BOOL bWait ; wait option
)
GDI32.GetPaletteEntries(
 HPALETTE hpal, ; handle to logical palette
 UINT iStartIndex, ; first entry to retrieve
 UINT nEntries, ; number of entries to retrieve
 LPPALETTEENTRY lppe ; array that receives entries
)
USER32.GetParent(
 HWND hWnd ; handle to child window
)
GDI32.GetPath(
 HDC hdc, ; handle to DC
 LPPOINT lpPoints, ; path vertices
 LPBYTE lpTypes, ; array of path vertex types
 int nSize ; count of points defining path
)
GDI32.GetPixel(
 HDC hdc, ; handle to DC
 int nXPos, ; x-coordinate of pixel
 int nYPos ; y-coordinate of pixel
)
GDI32.GetPolyFillMode(
 HDC hdc ; handle to device context
)
WINSPOOL.GetPrinterA(
 HANDLE hPrinter, ; handle to printer
 DWORD Level, ; information level
 LPBYTE pPrinter, ; printer information buffer
 DWORD cbBuf, ; size of buffer
 LPDWORD pcbNeeded ; bytes received or required
)
WINSPOOL.GetPrinterDataA(
 HANDLE hPrinter, ; handle to printer or print server
 LPTSTR pValueName, ; value name
 LPDWORD pType, ; data type
 LPBYTE pData, ; configuration data buffer
 DWORD nSize, ; size of configuration data buffer
 LPDWORD pcbNeeded ; bytes received or required
)
WINSPOOL.GetPrinterDataExA(
 HANDLE hPrinter, ; handle to printer or print server
 LPCTSTR pKeyName, ; registry key name
 LPCTSTR pValueName, ; registry value name
 LPDWORD pType, ; data type
 LPBYTE pData, ; configuration data buffer
 DWORD nSize, ; size of data buffer
 LPDWORD pcbNeeded ; bytes received or required
)
WINSPOOL.GetPrinterDriverA(
 HANDLE hPrinter, ; printer object
 LPTSTR pEnvironment, ; environment name
 DWORD Level, ; information level
 LPBYTE pDriverInfo, ; driver data buffer
 DWORD cbBuf, ; size of buffer
 LPDWORD pcbNeeded ; bytes received or required
)
WINSPOOL.GetPrinterDriverDirectoryA(
 LPTSTR pName, ; server name
 LPTSTR pEnvironment, ; environment name
 DWORD Level, ; information level
 LPBYTE pDriverDirectory, ; path buffer
 DWORD cbBuf, ; size of path buffer
 LPDWORD pcbNeeded ; bytes received or required
)
WINSPOOL.GetPrintProcessorDirectoryA(
 LPTSTR pName, ; server name
 LPTSTR pEnvironment, ; environment name
 DWORD Level, ; information level
 LPBYTE pPrintProcessorInfo, ; path buffer
 DWORD cbBuf, ; size of path buffer
 LPDWORD pcbNeeded ; bytes received or required
)
KERNEL32.GetPriorityClass(
 HANDLE hProcess ; handle to process
)
USER32.GetPriorityClipboardFormat(
 UINT *paFormatPriorityList, ; array of clipboard formats
 int cFormats ; number of entries in array
)
KERNEL32.GetPrivateProfileIntA(
 LPCTSTR lpAppName, ; section name
 LPCTSTR lpKeyName, ; key name
 INT nDefault, ; return value if key name not found
 LPCTSTR lpFileName ; initialization file name
)
KERNEL32.GetPrivateProfileSectionA(
 LPCTSTR lpAppName, ; section name
 LPTSTR lpReturnedString, ; return buffer
 DWORD nSize, ; size of return buffer
 LPCTSTR lpFileName ; initialization file name
)
KERNEL32.GetPrivateProfileSectionNamesA(
 LPTSTR lpszReturnBuffer, ; return buffer
 DWORD nSize, ; size of return buffer
 LPCTSTR lpFileName ; initialization file name
)
KERNEL32.GetPrivateProfileStringA(
 LPCTSTR lpAppName, ; section name
 LPCTSTR lpKeyName, ; key name
 LPCTSTR lpDefault, ; default string
 LPTSTR lpReturnedString, ; destination buffer
 DWORD nSize, ; size of destination buffer
 LPCTSTR lpFileName ; initialization file name
)
KERNEL32.GetPrivateProfileStructA(
 LPCTSTR lpszSection, ; section name
 LPCTSTR lpszKey, ; key name
 LPVOID lpStruct, ; return buffer
 UINT uSizeStruct, ; size of return buffer
 LPCTSTR szFile ; initialization file name
)
KERNEL32.GetProcAddress(
 HMODULE hModule, ; handle to DLL module
 LPCSTR lpProcName ; function name
)
KERNEL32.GetProcessAffinityMask(
 HANDLE hProcess, ; handle to process
 PDWORD_PTR lpProcessAffinityMask, ; process affinity mask
 PDWORD_PTR lpSystemAffinityMask ; system affinity mask
)
xxxx.GetProcessDefaultLayout(
 DWORD *pdwDefaultLayout ; default process layout
)
KERNEL32.GetProcessHeap(VOID)
)
KERNEL32.GetProcessHeaps(
 DWORD NumberOfHeaps, ; maximum number of heap handles
 PHANDLE ProcessHeaps ; buffer for heap handles
)
KERNEL32.GetProcessIoCounters(
 HANDLE hProcess, ; handle to process
 PIO_COUNTERS lpIoCounters ; I/O accouting information
)
KERNEL32.GetProcessPriorityBoost(
 HANDLE hProcess, ; handle to process
 PBOOL pDisablePriorityBoost ; priority boost state
)
KERNEL32.GetProcessShutdownParameters(
 LPDWORD lpdwLevel, ; shutdown priority
 LPDWORD lpdwFlags ; shutdown flag
)
KERNEL32.GetProcessTimes(
 HANDLE hProcess, ; handle to process
 LPFILETIME lpCreationTime, ; process creation time
 LPFILETIME lpExitTime, ; process exit time
 LPFILETIME lpKernelTime, ; process kernel-mode time
 LPFILETIME lpUserTime ; process user-mode time
)
KERNEL32.GetProcessVersion(
 DWORD ProcessId ; process identifier
)
USER32.GetProcessWindowStation(VOID)
)
KERNEL32.GetProcessWorkingSetSize(
 HANDLE hProcess, ; handle to the process
 PSIZE_T lpMinimumWorkingSetSize, ; minimum working set size
 PSIZE_T lpMaximumWorkingSetSize ; maximum working set size
)
KERNEL32.GetProfileIntA(
 LPCTSTR lpAppName, ; section name
 LPCTSTR lpKeyName, ; key name
 INT nDefault ; default value if key name not found
)
KERNEL32.GetProfilesDirectory(
 LPTSTR lpProfilesDir, ; profile path buffer
 LPDWORD lpcchSize ; size of profile path buffer
)
KERNEL32.GetProfileSectionA(
 LPCTSTR lpAppName, ; section name
 LPTSTR lpReturnedString, ; return buffer
 DWORD nSize ; size of return buffer
)
KERNEL32.GetProfileStringA(
 LPCTSTR lpAppName, ; section name
 LPCTSTR lpKeyName, ; key name
 LPCTSTR lpDefault, ; default string
 LPTSTR lpReturnedString, ; destination buffer
 DWORD nSize ; size of destination buffer
)
KERNEL32.GetProfileType(
 DWORD *dwFlags ; profile type
)
USER32.GetPropA(
 HWND hWnd, ; handle to window
 LPCTSTR lpString ; atom or string
)
KERNEL32.GetQueuedCompletionStatus(
 HANDLE CompletionPort, ; handle to completion port
 LPDWORD lpNumberOfBytes, ; bytes transferred
 PULONG_PTR lpCompletionKey, ; file completion key
 LPOVERLAPPED *lpOverlapped, ; buffer
 DWORD dwMilliseconds ; optional timeout value
)
USER32.GetQueueStatus(
 UINT flags ; message types
)
xxxx.GetRandomRgn(
 HDC hdc, ; handle to DC
 HRGN hrgn, ; handle to region
 INT iNum ; must be SYSRGN
)
GDI32.GetRasterizerCaps(
 LPRASTERIZER_STATUS lprs, ; rasterizer information
 UINT cb ; rasterizer information size
)
GDI32.GetRegionData(
 HRGN hRgn, ; handle to region
 DWORD dwCount, ; size of region data buffer
 LPRGNDATA lpRgnData ; region data buffer
)
GDI32.GetRgnBox(
 HRGN hrgn, ; handle to a region
 LPRECT lprc ; bounding rectangle
)
GDI32.GetROP2(
 HDC hdc ; handle to device context
)
COMDLG32.GetSaveFileNameA(
 LPOPENFILENAME lpofn ; initialization data
)
xxxx.GetScrollBarInfo(
 HWND hwnd, ; handle to window
 LONG idObject, ; scroll bar object
 PSCROLLBARINFO psbi ; scroll bar information
)
USER32.GetScrollInfo(
 HWND hwnd, ; handle to window
 int fnBar, ; scroll bar type
 LPSCROLLINFO lpsi ; scroll bar parameters
)
USER32.GetScrollPos(
 HWND hWnd, ; handle to window
 int nBar ; scroll bar options
)
USER32.GetScrollRange(
 HWND hWnd, ; handle to window
 int nBar, ; scroll bar options
 LPINT lpMinPos, ; receives minimum position
 LPINT lpMaxPos ; receives maximum position
)
USER-DEFINED.GetServiceCount(VOID)
)
ADVAPI32.GetServiceDisplayNameA(
 SC_HANDLE hSCManager, ; handle to SCM database
 LPCTSTR lpServiceName, ; service name
 LPTSTR lpDisplayName, ; display name
 LPDWORD lpcchBuffer ; size of display name buffer
)
ADVAPI32.GetServiceKeyNameA(
 SC_HANDLE hSCManager, ; handle to SCM database
 LPCTSTR lpDisplayName, ; display name
 LPTSTR lpServiceName, ; service name
 LPDWORD lpcchBuffer ; size of service name buffer
)
KERNEL32.GetShortPathNameA(
 LPCTSTR lpszLongPath, ; null-terminated path string
 LPTSTR lpszShortPath, ; short form buffer
 DWORD cchBuffer ; size of short form buffer
)
KERNEL32.GetStartupInfoA(
 LPSTARTUPINFO lpStartupInfo ; startup information
)
KERNEL32.GetStdHandle(
 DWORD nStdHandle ; input, output, or error device
)
GDI32.GetStockObject(
 int fnObject ; stock object type
)
GDI32.GetStretchBltMode(
 HDC hdc ; handle to DC
)
KERNEL32.GetStringTypeA(
 LCID Locale, ; locale identifer
 DWORD dwInfoType, ; information-type options
 LPCSTR lpSrcStr, ; source string
 int cchSrc, ; size of source string
 LPWORD lpCharType ; output buffer
)
KERNEL32.GetStringTypeExA(
 LCID Locale, ; locale identifer
 DWORD dwInfoType, ; information-type options
 LPCTSTR lpSrcStr, ; source string
 int cchSrc, ; size of source string
 LPWORD lpCharType ; output buffer
)
KERNEL32.GetStringTypeW(
 DWORD dwInfoType, ; information-type options
 LPCWSTR lpSrcStr, ; source string
 int cchSrc, ; number of characters in string
 LPWORD lpCharType ; output buffer
)
USER32.GetSubMenu(
 HMENU hMenu, ; handle to menu
 int nPos ; menu item position
)
USER32.GetSysColor(
 int nIndex ; display element
)
USER32.GetSysColorBrush(
 int nIndex ; system color index
)
xxxx.GetSysModalWindow(OBSOLETE)
)
KERNE32.GetSystemDefaultLangID(VOID)
)
KERNEL32.GetSystemDefaultLCID(VOID)
)
KERNEL32.GetSystemDefaultUILanguage(VOID)
)
KERNEL32GetSystemDirectoryA(
 LPTSTR lpBuffer, ; buffer for system directory
 UINT uSize ; size of directory buffer
)
KERNEL32.GetSystemInfo(
 LPSYSTEM_INFO lpSystemInfo ; system information
)
USER32.GetSystemMenu(
 HWND hWnd, ; handle to window
 BOOL bRevert ; reset option
)
USER32.GetSystemMetrics(
 int nIndex ; system metric or configuration setting
)
GDI32.GetSystemPaletteEntries(
 HDC hdc, ; handle to DC
 UINT iStartIndex, ; first entry to be retrieved
 UINT nEntries, ; number of entries to be retrieved
 LPPALETTEENTRY lppe ; array that receives entries
)
GDI32.GetSystemPaletteUse(
 HDC hdc ; handle to DC
)
KERNEL32.GetSystemPowerStatus(
 LPSYSTEM_POWER_STATUS lpSystemPowerStatus ; status
)
KERNEL32.GetSystemTime(
 LPSYSTEMTIME lpSystemTime ; system time
)
KERNEL32.GetSystemTimeAdjustment(
 PDWORD lpTimeAdjustment, ; size of time adjustment
 PDWORD lpTimeIncrement, ; time between adjustments
 PBOOL lpTimeAdjustmentDisabled ; disable option
)
KERNEL32.GetSystemTimeAsFileTime(
 LPFILETIME lpSystemTimeAsFileTime ; file time
)
xxxx.GetSystemWindowsDirectory(
 LPTSTR lpBuffer, ; buffer to receive directory name
 UINT uSize ; size of name buffer
)
xxxx.GetSystemWow64Directory(
 LPTSTR lpBuffer, ; buffer for system directory
 UINT uSize ; size of directory buffer
)
USER32.GetTabbedTextExtentA(
 HDC hDC, ; handle to DC
 LPCTSTR lpString, ; character string
 int nCount, ; number of characters
 int nTabPositions, ; number of tab positions
 CONST LPINT lpnTabStopPositions ; array of tab positions
)
KERNEL32.GetTapeParameters(
 HANDLE hDevice, ; handle to device
 DWORD dwOperation, ; information type
 LPDWORD lpdwSize, ; information
 LPVOID lpTapeInformation ; tape media or drive information
)
KERNEL32.GetTapePosition(
 HANDLE hDevice, ; handle to device
 DWORD dwPositionType, ; address type
 LPDWORD lpdwPartition, ; current tape partition
 LPDWORD lpdwOffsetLow, ; low-order bits of position
 LPDWORD lpdwOffsetHigh ; high-order bits of position
)
KERNEL32.GetTapeStatus(
 HANDLE hDevice ; handle to device
)
KERNEL32.GetTempFileNameA(
 LPCTSTR lpPathName, ; directory name
 LPCTSTR lpPrefixString, ; file name prefix
 UINT uUnique, ; integer
 LPTSTR lpTempFileName ; file name buffer
)
KERNEL32.GetTempPathA(
 DWORD nBufferLength, ; size of buffer
 LPTSTR lpBuffer ; path buffer
)
GDI32.GetTextAlign(
 HDC hdc ; handle to DC
)
GDI32.GetTextCharacterExtra(
 HDC hdc ; handle to DC
)
GDI32.GetTextCharset(
 HDC hdc ; handle to DC
)
GDI32.GetTextCharsetInfo(
 HDC hdc, ; handle to DC
 LPFONTSIGNATURE lpSig, ; data buffer
 DWORD dwFlags ; reserved; must be zero
)
GDI32.GetTextColor(
 HDC hdc ; handle to DC
)
GDI32.GetTextExtentExPointA(
 HDC hdc, ; handle to DC
 LPCTSTR lpszStr, ; character string
 int cchString, ; number of characters
 int nMaxExtent, ; maximum width of formatted string
 LPINT lpnFit, ; maximum number of characters
 LPINT alpDx, ; array of partial string widths
 LPSIZE lpSize ; string dimensions
)
GDI32.GetTextExtentExPointI(
 HDC hdc, ; handle to DC
 LPWORD pgiIn, ; array of glyph indices
 int cgi, ; number of glyphs in array
 int nMaxExtent, ; maximum width of formatted string
 LPINT lpnFit, ; maximum number of characters
 LPINT alpDx, ; array of partial string widths
 LPSIZE lpSize ; string dimensions
)
GDI32.GetTextExtentPoint32A(
 HDC hdc, ; handle to DC
 LPCTSTR lpString, ; text string
 int cbString, ; characters in string
 LPSIZE lpSize ; string size
)
GDI32.GetTextExtentPointA(
 HDC hdc, ; handle to DC
 LPCTSTR lpString, ; text string
 int cbString, ; number of characters in string
 LPSIZE lpSize ; string size
)
GDI32.GetTextExtentPointI(
 HDC hdc, ; handle to DC
 LPWORD pgiIn, ; glyph indices
 int cgi, ; number of indices in array
 LPSIZE lpSize ; string size
)
GDI32.GetTextFaceA(
 HDC hdc, ; handle to DC
 int nCount, ; length of typeface name buffer
 LPTSTR lpFaceName ; typeface name buffer
)
GDI32.GetTextMetricsA(
 HDC hdc, ; handle to DC
 LPTEXTMETRIC lptm ; text metrics
)
KERNEL32.GetThreadContext(
 HANDLE hThread, ; handle to thread with context
 LPCONTEXT lpContext ; context structure
)
USER32.GetThreadDesktop(
 DWORD dwThreadId ; thread identifier
)
KERNEL32.GetThreadLocale(VOID)
)
KERNEL32.GetThreadPriority(
 HANDLE hThread ; handle to thread
)
KERNEL32.GetThreadPriorityBoost(
 HANDLE hThread, ; handle to thread
 PBOOL pDisablePriorityBoost ; priority boost state
)
KERNEL32.GetThreadSelectorEntry(
 HANDLE hThread, ; handle to thread
 DWORD dwSelector, ; number of selector value
 LPLDT_ENTRY lpSelectorEntry ; descriptor table entry
)
KERNEL32.GetThreadTimes(
 HANDLE hThread, ; handle to thread
 LPFILETIME lpCreationTime, ; thread creation time
 LPFILETIME lpExitTime, ; thread exit time
 LPFILETIME lpKernelTime, ; thread kernel-mode time
 LPFILETIME lpUserTime ; thread user-mode time
)
KERNEL32.GetTickCount(VOID)
)
KERNEL32.GetTimeFormatA(
 LCID Locale, ; locale
 DWORD dwFlags, ; options
 CONST SYSTEMTIME *lpTime, ; time
 LPCTSTR lpFormat, ; time format string
 LPTSTR lpTimeStr, ; formatted string buffer
 int cchTime ; size of string buffer
)
KERNEL32.GetTimeZoneInformation(
 LPTIME_ZONE_INFORMATION lpTimeZoneInformation ; time zone
)
xxxx.GetTitleBarInfo(
 HWND hwnd, ; handle to title bar
 PTITLEBARINFO pti ; title bar information
)
USER32.GetTopWindow(
 HWND hWnd ; handle to parent window
)
USER32.GetUpdateRect(
 HWND hWnd, ; handle to window
 LPRECT lpRect, ; update rectangle coordinates
 BOOL bErase ; erase state
)
USER32.GetUpdateRgn(
 HWND hWnd, ; handle to window
 HRGN hRgn, ; handle to region
 BOOL bErase ; erase state
)
KERNEL32.GetUserDefaultLangID(VOID)
)
KERNEL32.GetUserDefaultLCID(VOID)
)
KERNEL32.GetUserDefaultUILanguage(VOID)
)
KERNEL32.GetUserGeoID(
 GEOCLASS GeoClass ; location class
)
ADVAPI32.GetUserNameA(
 LPTSTR lpBuffer, ; name buffer
 LPDWORD nSize ; size of name buffer
)
ADVAPI32.GetUserNameEx(
 EXTENDED_NAME_FORMAT NameFormat, ; name format
 LPTSTR lpNameBuffer, ; name buffer
 PULONG nSize ; size of name buffer
)
USER32.GetUserObjectInformationA(
 HANDLE hObj, ; handle to object
 int nIndex, ; type of information to retrieve
 PVOID pvInfo, ; information buffer
 DWORD nLength, ; size of the buffer
 LPDWORD lpnLengthNeeded ; receives required buffer size
)
xxxx.GetUserProfileDirectory(
 HANDLE hToken, ; user token
 LPTSTR lpProfileDir, ; profile path buffer
 LPDWORD lpcchSize ; size of profile path buffer
)
KERNEL32.GetVersion(VOID)
)
KERNEL32.GetVersionExA(
 LPOSVERSIONINFO lpVersionInfo ; version information
)
GDI32.GetViewportExtEx(
 HDC hdc, ; handle to device context
 LPSIZE lpSize ; viewport dimensions
)
GDI32.GetViewportOrgEx(
 HDC hdc, ; handle to device context
 LPPOINT lpPoint ; viewport origin
)
KERNEL32.GetVolumeInformation(
 LPCTSTR lpRootPathName, ; root directory
 LPTSTR lpVolumeNameBuffer, ; volume name buffer
 DWORD nVolumeNameSize, ; length of name buffer
 LPDWORD lpVolumeSerialNumber, ; volume serial number
 LPDWORD lpMaximumComponentLength, ; maximum file name length
 LPDWORD lpFileSystemFlags, ; file system options
 LPTSTR lpFileSystemNameBuffer, ; file system name buffer
 DWORD nFileSystemNameSize ; length of file system name buffer
)
KERNEL32.GetVolumeNameForVolumeMountPoint(
 LPCTSTR lpszVolumeMountPoint, ; volume mount point or directory
 LPTSTR lpszVolumeName, ; volume name buffer
 DWORD cchBufferLength ; size of volume name buffer
)
KERNEL32.GetVolumePathName(
 LPCTSTR lpszFileName, ; file path
 LPTSTR lpszVolumePathName, ; volume mount point
 DWORD cchBufferLength ; size of buffer
)
USER32.GetWindow(
 HWND hWnd, ; handle to original window
 UINT uCmd ; relationship
)
USER32.GetWindowContextHelpId(
 HWND hwnd
)
USER32.GetWindowDC(
 HWND hWnd ; handle to window
)
GDI32.GetWindowExtEx(
 HDC hdc, ; handle to device context
 LPSIZE lpSize ; window extents
)
xxxx.GetWindowInfo(
 HWND hwnd, ; handle to window
 PWINDOWINFO pwi ; window information
)
USER32.GetWindowLongA(
 HWND hWnd, ; handle to window
 int nIndex ; offset of value to retrieve
)
xxxx.GetWindowLongPtr(
 HWND hWnd, ; handle to window
 int nIndex ; offset of value to retrieve
)
xxxx.GetWindowModuleFileNameA(
 HWND hwnd, ; handle to window
 LPTSTR lpszFileName, ; file name buffer
 UINT cchFileNameMax ; max size of file name buffer
)
GDI32.GetWindowOrgEx(
 HDC hdc, ; handle to device context
 LPPOINT lpPoint ; window origin
)
USER32.GetWindowPlacement(
 HWND hWnd, ; handle to window
 WINDOWPLACEMENT *lpwndpl ; position data
)
USER32.GetWindowRect(
 HWND hWnd, ; handle to window
 LPRECT lpRect ; window coordinates
)
USER32.GetWindowRgn(
 HWND hWnd, ; handle to window
 HRGN hRgn ; handle to window region
)
KERNEL32.GetWindowsDirectoryA(
 LPTSTR lpBuffer, ; buffer for Windows directory
 UINT uSize ; size of directory buffer
)
xxxx.GetWindowSubclass(
 HWND hWnd,
 SUBCLASSPROC pfnSubclass,
 UINT_PTR uIdSubclass,
 DWORD_PTR *pdwRefData
)
xxxx.GetWindowTask(OBSOLETE - Use GetWindowThreadProcessId)
)
USER32.GetWindowTextA(
 HWND hWnd, ; handle to window or control
 LPTSTR lpString, ; text buffer
 int nMaxCount ; maximum number of characters to copy
)
USER32.GetWindowTextLengthA(
 HWND hWnd ; handle to window or control
)
USER32.GetWindowThreadProcessId(
 HWND hWnd, ; handle to window
 LPDWORD lpdwProcessId ; process identifier
)
USER32.GetWindowWord(OBSOLETE - Use GetWindowLong)
)
GDI32.GetWinMetaFileBits(
 HENHMETAFILE hemf, ; handle to the enhanced metafile
 UINT cbBuffer, ; buffer size
 LPBYTE lpbBuffer, ; records buffer
 INT fnMapMode, ; mapping mode
 HDC hdcRef ; handle to reference DC
)
GDI32.GetWorldTransform(
 HDC hdc, ; handle to device context
 LPXFORM lpXform ; transformation
)
xxxx.GetWriteWatch(
 DWORD dwFlags, ; write-tracking state
 PVOID lpBaseAddress, ; base address of region
 SIZE_T dwRegionSize, ; size of region
 PVOID *lpAddresses, ; array of page addresses
 PULONG_PTR lpdwCount, ; number of addresses returned
 PULONG lpdwGranularity ; page size
)
KERNEL32.GlobalAddAtomA(
 LPCTSTR lpString ; string to add
)
KERNEL32.GlobalAlloc(
 UINT uFlags, ; allocation attributes
 SIZE_T dwBytes ; number of bytes to allocate
)
KERNEL32.GlobalCompact(OBSOLETE)
)
KERNEL32.GlobalDeleteAtom(
 ATOM nAtom ; atom to delete
)
xxxx.GlobalDiscard(
 HGLOBAL hglbMem ; handle to global memory object
)
KERNEL32.GlobalFindAtomA(
 LPCTSTR lpString ; string to find
)
xxxx.GlobalFix(OBSOLETE)
)
KERNEL32.GlobalFlags(
 HGLOBAL hMem ; handle to global memory object
)
KERNEL32.GlobalFree(
 HGLOBAL hMem ; handle to global memory object
)
KERNEL32.GlobalGetAtomNameA(
 ATOM nAtom, ; atom identifier
 LPTSTR lpBuffer, ; buffer for atom string
 int nSize ; size of buffer
)
KERNEL32.GlobalHandle(
 LPCVOID pMem ; first byte of global memory block
)
KERNEL32.GlobalLock(
 HGLOBAL hMem ; handle to global memory object
)
xxxx.GlobalLRUNewest(OBSOLETE)
)
GlobalLRUOldest(OBSOLETE)
)
KERNEL32.GlobalMemoryStatus(
 LPMEMORYSTATUS lpBuffer ; memory status structure
)
KERNEL32.GlobalMemoryStatusEx(
 LPMEMORYSTATUSEX lpBuffer ; memory status structure
)
KERNEL32.GlobalReAlloc(
 HGLOBAL hMem, ; handle to global memory object
 SIZE_T dwBytes, ; new block size
 UINT uFlags ; how to reallocate object
)
KERNEL32.GlobalSize(
 HGLOBAL hMem ; handle to global memory object
)
xxxx.GlobalUnfix(OBSOLETE)
)
KERNEL32.GlobalUnlock(
 HGLOBAL hMem ; handle to global memory object
)
xxxx.GlobalUnWire(OBSOLETE)
)
xxxx.GlobalWire(OBSOLETE)
)
xxxx.GradientFill(
 HDC hdc, ; handle to DC
 PTRIVERTEX pVertex, ; array of vertices
 ULONG dwNumVertex, ; number of vertices
 PVOID pMesh, ; array of gradients
 ULONG dwNumMesh, ; size of gradient array
 ULONG dwMode ; gradient fill mode
)
USER32.GrayStringA(
 HDC hDC, ; handle to DC
 HBRUSH hBrush, ; handle to the brush
 GRAYSTRINGPROC lpOutputFunc, ; callback function
 LPARAM lpData, ; application-defined data
 int nCount, ; number of characters
 int X, ; horizontal position
 int Y, ; vertical position
 int nWidth, ; width
 int nHeight ; height
)
USER-DEFINED.Handler(
 DWORD fdwControl ; requested control code
)
xxxx.HandlerEx(
 DWORD dwControl, ; requested control code
 DWORD dwEventType, ; event type
 LPVOID lpEventData, ; event data
 LPVOID lpContext ; user-defined context data
)
USER-DEFINED.HandlerRoutine(
 DWORD dwCtrlType ; control signal type
)
xxxx.HashData(
 LPBYTE pbData,
 DWORD cbData,
 LPBYTE pbHash,
 DWORD cbHash
)
KERNEL32.Heap32First(
 LPHEAPENTRY32 lphe,
 DWORD th32ProcessID,
 ULONG_PTR th32HeapID
)
KERNEL32.Heap32ListFirst(
 HANDLE hSnapshot,
 LPHEAPLIST32 lphl
)
KERNEL32.Heap32ListNext(
 HANDLE hSnapshot,
 LPHEAPLIST32 lphl
)
KERNEL32.Heap32Next(
 LPHEAPENTRY32 lphe
)
KERNEL32.HeapAlloc(
 HANDLE hHeap, ; handle to private heap block
 DWORD dwFlags, ; heap allocation control
 SIZE_T dwBytes ; number of bytes to allocate
)
KERNEL32.HeapCompact(
 HANDLE hHeap, ; handle to heap
 DWORD dwFlags ; heap access options
)
KERNEL32.HeapCreate(
 DWORD flOptions, ; heap allocation attributes
 SIZE_T dwInitialSize, ; initial heap size
 SIZE_T dwMaximumSize ; maximum heap size
)
KERNEL32.HeapDestroy(
 HANDLE hHeap ; handle to heap
)
KERNEL32.HeapFree(
 HANDLE hHeap, ; handle to heap
 DWORD dwFlags, ; heap free options
 LPVOID lpMem ; pointer to memory
)
KERNEL32.HeapLock(
 HANDLE hHeap ; handle to heap
)
KERNEL32.HeapReAlloc(
 HANDLE hHeap, ; handle to heap block
 DWORD dwFlags, ; heap reallocation options
 LPVOID lpMem, ; pointer to memory to reallocate
 SIZE_T dwBytes ; number of bytes to reallocate
)
KERNEL32.HeapSize(
 HANDLE hHeap, ; handle to heap
 DWORD dwFlags, ; heap size options
 LPCVOID lpMem ; pointer to memory
)
KERNEL32.HeapUnlock(
 HANDLE hHeap ; handle to heap
)
KERNEL32.HeapValidate(
 HANDLE hHeap, ; handle to heap
 DWORD dwFlags, ; heap access options
 LPCVOID lpMem ; optional pointer to memory block
)
KERNEL32.HeapWalk(
 HANDLE hHeap, ; heap to enumerate
 LPPROCESS_HEAP_ENTRY lpEntry ; state information
)
MAPI32.HexFromBin(
 LPBYTE pb,
 int cb,
 LPTSTR sz
)
USER32.HideCaret(
 HWND hWnd ; handle to window with caret
)
USER32.HiliteMenuItem(
 HWND hwnd, ; handle to window
 HMENU hmenu, ; handle to menu
 UINT uItemHilite, ; menu item
 UINT uHilite ; highlight options
)
xxxx.HImageList_QueryInterface(
 HIMAGELIST himl,
 REFIID riid,
 void **ppv
)
USER-DEFINED.HPProviderInit(
 LPMAPISESSION lpSession,
 HINSTANCE hInstance,
 LPALLOCATEBUFFER lpAllocateBuffer,
 LPALLOCATEMORE lpAllocateMore,
 LPFREEBUFFER lpFreeBuffer,
 LPMAPIUID lpSectionUID,
 ULONG ulFlags,
 LPSPOOLERHOOK FAR * lppSpoolerHook
)
MAPI32.HrAddColumnsEx(
 LPMAPITABLE lptbl,
 LPSPropTagArray lpproptagColumnsNew,
 LPALLOCATEBUFFER lpAllocateBuffer,
 LPFREEBUFFER lpFreeBuffer,
 void (FAR * lpfnFilterColumns) (LPSPropTagArray ptaga)
)
MAPI32.HrAllocAdviseSink(
 LPNOTIFCALLBACK lpfnCallback,
 LPVOID lpvContext,
 LPMAPIADVISESINK FAR * lppAdviseSink
)
MAPI32.HrComposeEID(
 LPMAPISESSION psession,
 ULONG cbStoreRecordKey,
 LPBYTE pStoreRecordKey,
 ULONG cbMsgEID,
 LPENTRYID pMsgEID,
 ULONG FAR * pcbEID,
 LPENTRYID FAR * ppEID
)
MAPI32.HrComposeMsgID(
 LPMAPISESSION psession,
 ULONG cbStoreRecordKey,
 LPBYTE pStoreRecordKey,
 ULONG cbMsgEID,
 LPENTRYID pMsgEID,
 LPTSTR FAR * pszMsgID
)
MAPI32.HrDecomposeEID(
 LPMAPISESSION psession,
 ULONG cbEID,
 LPENTRYID pEID,
 ULONG FAR * pcbStoreEID,
 LPENTRYID FAR * ppStoreEID ,
 ULONG FAR * pcbMsgEID,
 LPENTRYID FAR * ppMsgEID
)
MAPI32.HrDecomposeMsgID(
 LPMAPISESSION psession,
 LPTSTR szMsgID,
 ULONG FAR * pcbStoreEID,
 LPENTRYID FAR * ppStoreEID ,
 ULONG FAR * pcbMsgEID,
 LPENTRYID FAR * ppMsgEID
)
MAPI32.HrDispatchNotifications(
 ULONG ulFlags
)
MAPI32.HrEntryIDFromSz(
 LPTSTR sz,
 ULONG FAR * pcb,
 LPENTRYID FAR * ppentry
)
MAPI32.HrGetOneProp(
 LPMAPIPROP pmp,
 ULONG ulPropTag,
 LPSPropValue FAR * ppprop
)
MAPI32.HrIStorageFromStream(
 LPUNKNOWN lpUnkIn,
 PIID lpInterface,
 ULONG ulFlags,
 LPSTORAGE FAR * lppStorageOut
)
MAPI32.HrQueryAllRows(
 LPMAPITABLE ptable,
 LPSPropTagArray ptaga,
 LPSRestriction pres,
 LPSSortOrderSet psos,
 LONG crowsMax,
 LPSRowSet FAR * pprows
)
MAPI32.HrSetOneProp(
 LPMAPIPROP pmp,
 LPSPropValue pprop
)
MAPI32.HrSzFromEntryID(
 ULONG cb,
 LPENTRYID pentry,
 LPTSTR FAR * psz
)
MAPI32.HrThisThreadAdviseSink(
 LPMAPIADVISESINK lpAdviseSink,
 LPMAPIADVISESINK FAR * lppAdviseSink
)
MAPI32.HrValidateIPMSubtree(
 LPMDB lpMDB,
 ULONG ulFlags,
 ULONG FAR * lpcValues,
 LPSPropValue FAR * lppProps,
 LPMAPIERROR FAR * lppMapiError
)
COMCTL32.ImageList_Add(
 HIMAGELIST himl,
 HBITMAP hbmImage,
 HBITMAP hbmMask
)
COMCTL32.ImageList_AddMasked(
 HIMAGELIST himl,
 HBITMAP hbmImage,
 COLORREF crMask
)
COMCTL32.ImageList_BeginDrag(
 HIMAGELIST himlTrack,
 int iTrack,
 int dxHotspot,
 int dyHotspot
)
COMCTL32.ImageList_Copy(
 HIMAGELIST himlDst,
 int iDst,
 HIMAGELIST himlSrc,
 int iSrc,
 UINT uFlags
)
COMCTL32.ImageList_Create(
 int cx,
 int cy,
 UINT flags,
 int cInitial,
 int cGrow
)
COMCTL32.ImageList_Destroy(
 HIMAGELIST himl
)
COMCTL32.ImageList_DragEnter(
 HWND hwndLock,
 int x,
 int y
)
COMCTL32.ImageList_DragLeave(
 HWND hwndLock
)
COMCTL32.ImageList_DragMove(
 int x,
 int y
)
COMCTL32.ImageList_DragShowNolock(
 BOOL fShow
)
COMCTL32.ImageList_Draw(
 HIMAGELIST himl,
 int i,
 HDC hdcDst,
 int x,
 int y,
 UINT fStyle
)
COMCTL32.ImageList_DrawEx(
 HIMAGELIST himl,
 int i,
 HDC hdcDst,
 int x,
 int y,
 int dx,
 int dy,
 COLORREF rgbBk,
 COLORREF rgbFg,
 UINT fStyle
)
COMCTL32.ImageList_DrawIndirect(
 IMAGELISTDRAWPARAMS *pimldp
)
COMCTL32.ImageList_Duplicate(
 HIMAGELIST himl
)
COMCTL32.ImageList_EndDrag(VOID)
)
COMCTL32.ImageList_GetBkColor(
 HIMAGELIST himl
)
COMCTL32.ImageList_GetDragImage(
 POINT FAR *ppt,
 POINT FAR *pptHotspot
)
COMCTL32.ImageList_GetIcon(
 HIMAGELIST himl,
 int i,
 UINT flags
)
COMCTL32.ImageList_GetIconSize(
 HIMAGELIST himl,
 int FAR *cx,
 int FAR *cy
)
COMCTL32.ImageList_GetImageCount(
 HIMAGELIST himl
)
COMCTL32.ImageList_GetImageInfo(
 HIMAGELIST himl,
 int i,
 IMAGEINFO FAR *pImageInfo
)
COMCTL32.ImageList_LoadImageA(
 HINSTANCE hi,
 LPCTSTR lpbmp,
 int cx,
 int cGrow,
 COLORREF crMask,
 UINT uType,
 UINT uFlags
)
COMCTL32.ImageList_Merge(
 HIMAGELIST himl1,
 int i1,
 HIMAGELIST himl2,
 int i2,
 int dx,
 int dy
)
COMCTL32.ImageList_Read(
 LPSTREAM pstm
)
COMCTL32.ImageList_Remove(
 HIMAGELIST himl,
 int i
)
COMCTL32.ImageList_Replace(
 HIMAGELIST himl,
 int i,
 HBITMAP hbmImage,
 HBITMAP hbmMask
)
COMCTL32.ImageList_ReplaceIcon(
 HIMAGELIST himl,
 int i,
 HICON hicon
)
COMCTL32.ImageList_SetBkColor(
 HIMAGELIST himl,
 COLORREF clrBk
)
COMCTL32.ImageList_SetDragCursorImage(
 HIMAGELIST himlDrag,
 int iDrag,
 int dxHotspot,
 int dyHotspot
)
COMCTL32.ImageList_SetIconSize(
 HIMAGELIST himl,
 int cx,
 int cy
)
COMCTL32.ImageList_SetImageCount(
 HIMAGELIST himl,
 UINT uNewCount
)
COMCTL32.ImageList_SetOverlayImage(
 HIMAGELIST himl,
 int iImage,
 int iOverlay
)
COMCTL32.ImageList_Write(
 HIMAGELIST himl,
 LPSTREAM pstm
)
IMM32.ImmAssociateContext(
 HWND hWnd,
 HIMC hIMC
)
IMM32.ImmAssociateContextEx(
 HWND hWnd,
 HINC hIMC,
 DWORD dwFlags
)
IMM32.ImmConfigureIMEA(
 HKL hKL,
 HWND hWnd,
 DWORD dwMode,
 LPVOID lpData
)
IMM32.ImmCreateContext(VOID)
)
IMM32.ImmDestroyContext(
 HIMC hIMC
)
IMM32.ImmDisableIME(
 DWORD idThread
)
IMM32.ImmEnumInputContext(
 DWORD idThread,
 IMCENUMPROC lpfn,
 LPARAM lParam
)
IMM32.ImmEnumRegisterWordA(
 HKL hKL,
 REGISTERWORDENUMPROC lpfnEnumProc,
 LPCTSTR lpszReading,
 DWORD dwStyle,
 LPCTSTR lpszRegister,
 LPVOID lpData
)
IMM32.ImmEscapeA(
 HKL hKL,
 HIMC hIMC,
 UINT uEscape,
 LPVOID lpData
)
IMM32.ImmGetCandidateListA(
 HIMC hIMC,
 DWORD dwIndex,
 LPCANDIDATELIST lpCandList,
 DWORD dwBufLen
)
IMM32.ImmGetCandidateListCountA(
 HIMC hIMC,
 LPDWORD lpdwListCount
)
IMM32.ImmGetCandidateWindow(
 HIMC hIMC,
 DWORD dwIndex,
 LPCANDIDATEFORM lpCandidate
)
IMM32.ImmGetCompositionFontA(
 HIMC hIMC,
 LPLOGFONT lplf
)
IMM32.ImmGetCompositionStringA(
 HIMC hIMC,
 DWORD dwIndex,
 LPVOID lpBuf,
 DWORD dwBufLen
)
IMM32.ImmGetCompositionWindow(
 HIMC hIMC,
 LPCOMPOSITIONFORM lpCompForm
)
IMM32.ImmGetContext(
 HWND hWnd
)
IMM32.ImmGetConversionListA(
 HKL hKL,
 HIMC hIMC,
 LPCTSTR lpSrc,
 LPCANDIDATELIST lpDst,
 DWORD dwBufLen,
 UINT uFlag
)
IMM32.ImmGetConversionStatus(
 HIMC hIMC,
 LPDWORD lpfdwConversion,
 LPDWORD lpfdwSentence
)
IMM32.ImmGetDefaultIMEWnd(
 HWND hWnd
)
IMM32.ImmGetDescriptionA(
 HKL hKL,
 LPTSTR lpszDescription,
 UINT uBufLen
)
IMM32.ImmGetGuideLineA(
 HIMC hIMC,
 DWORD dwIndex,
 LPTSTR lpBuf,
 DWORD dwBufLen
)
IMM32.ImmGetIMEFileNameA(
 HKL hKL,
 LPTSTR lpszFileName,
 UINT uBufLen
)
IMM32.ImmGetImeMenuItemsA(
 HIMC hIMC,
 DWORD dwFlags,
 DWORD dwType,
 LPIMEMENUITEMINFO lpImeParentMenu,
 LPIMEMENUITEMINFO lpImeMenu,
 DWORD dwSize
)
IMM32.ImmGetOpenStatus(
 HIMC hIMC
)
IMM32.ImmGetProperty(
 HKL hKL,
 DWORD fdwIndex
)
IMM32.ImmGetRegisterWordStyleA(
 HKL hKL,
 UINT nItem,
 LPSTYLEBUF lpStyleBuf
)
IMM32.ImmGetStatusWindowPos(
 HIMC hIMC,
 LPPOINT lpptPos
)
IMM32.ImmGetVirtualKey(
 HWND hWnd
)
IMM32.ImmInstallIMEA(
 LPCTSTR lpszIMEFileName,
 LPCTSTR lpszLayoutText
)
IMM32.ImmIsIME(
 HKL hKL
)
IMM32.ImmIsUIMessageA(
 HWND hWndIME,
 UINT msg,
 WPARAM wParam,
 LPARAM lParam
)
IMM32.ImmNotifyIME(
 HIMC hIMC,
 DWORD dwAction,
 DWORD dwIndex,
 DWORD dwValue
)
IMM32.ImmRegisterWordA(
 HKL hKL,
 LPCTSTR lpszReading,
 DWORD dwStyle,
 LPCTSTR lpszRegister
)
IMM32.ImmReleaseContext(
 HWND hWnd,
 HIMC hIMC
)
IMM32.ImmSetCandidateWindow(
 HIMC hIMC,
 LPCANDIDATEFORM lpCandidate
)
IMM32.ImmSetCompositionFontA(
 HIMC hIMC,
 LPLOGFONT lplf
)
IMM32.ImmSetCompositionStringA(
 HIMC hIMC,
 DWORD dwIndex,
 LPVOID lpComp,
 DWORD dwCompLen,
 LPVOID lpRead,
 DWORD dwReadLen
)
IMM32.ImmSetCompositionWindow(
 HIMC hIMC,
 LPCOMPOSITIONFORM lpCompForm
)
IMM32.ImmSetConversionStatus(
 HIMC hIMC,
 DWORD fdwConversion,
 DWORD fdwSentence
)
IMM32.ImmSetOpenStatus(
 HIMC hIMC,
 BOOL fOpen
)
IMM32.ImmSetStatusWindowPos(
 HIMC hIMC,
 LPPOINT lpptPos
)
IMM32.ImmSimulateHotKey(
 HWND hWnd,
 DWORD dwHotKeyID
)
IMM32.ImmUnregisterWordA(
 HKL hKL,
 LPCTSTR lpszReading,
 DWORD dwStyle,
 LPCTSTR lpszUnregister
)
USER32.ImpersonateDdeClientWindow(
 HWND hWndClient, ; handle to DDE client window
 HWND hWndServer ; handle to DDE server window
)
xxxx.InetIsOffline(
 DWORD dwFlags
)
USER32.InflateRect(
 LPRECT lprc, ; rectangle
 int dx, ; amount to adjust width
 int dy ; amount to adjust height
)
KERNEL32.InitAtomTable(
 DWORD nSize ; size of atom table
)
COMCTL32.InitCommonControls(VOID)
)
COMCTL32.InitCommonControlsEx(
 LPINITCOMMONCONTROLSEX lpInitCtrls
)
KERNEL32.InitializeCriticalSection(
 LPCRITICAL_SECTION lpCriticalSection ; critical section
)
KERNEL32.InitializeCriticalSectionAndSpinCount(
 LPCRITICAL_SECTION lpCriticalSection, ; critical section
 DWORD dwSpinCount ; spin count
)
COMCTL32.InitializeFlatSB(
 HWND hwnd
)
ADVAPI32.InitiateSystemShutdownA(
 LPTSTR lpMachineName, ; computer name
 LPTSTR lpMessage, ; message to display
 DWORD dwTimeout, ; length of time to display
 BOOL bForceAppsClosed, ; force closed option
 BOOL bRebootAfterShutdown ; reboot option
)
ADVAPI32.InitiateSystemShutdownEx(
 LPTSTR lpMachineName, ; computer name
 LPTSTR lpMessage, ; message to display
 DWORD dwTimeout, ; length of time to display
 BOOL bForceAppsClosed, ; force closed option
 BOOL bRebootAfterShutdown, ; reboot option
 DWORD dwReason ; shutdown reason
)
xxxx.InitMUILanguage(
 LANGID uiLang
)
USER32.InSendMessage(VOID)
)
USER32.InSendMessageEx(
 LPVOID lpReserved ; not used; must be NULL
)
USER32.InsertMenuA(
 HMENU hMenu, ; handle to menu
 UINT uPosition, ; item that new item precedes
 UINT uFlags, ; options
 UINT_PTR uIDNewItem, ; identifier, menu, or submenu
 LPCTSTR lpNewItem ; menu item content
)
USER32.InsertMenuItemA(
 HMENU hMenu, ; handle to menu
 UINT uItem, ; identifier or position
 BOOL fByPosition, ; meaning of uItem
 LPCMENUITEMINFO lpmii ; menu item information
)
xxxx.InterfaceStatus(
 ULONG InterfaceIndex,
 BOOL InterfaceActive,
 DWORD StatusType,
 PVOID StatusInfo
)
KERNEL32.InterlockedCompareExchange(
 LPLONG Destination, ; destination address
 LONG Exchange, ; exchange value
 LONG Comperand ; value to compare
)
KERNEL32.InterlockedCompareExchangePointer(
 PVOID *Destination, ; destination address
 PVOID Exchange, ; exchange value
 PVOID Comperand ; value to compare
)
KERNEL32.InterlockedDecrement(
 LPLONG lpAddend ; variable address
)
KERNEL32.InterlockedExchange(
 LPLONG Target, ; value to exchange
 LONG Value ; new value
)
KERNEL32.InterlockedExchangeAdd(
 LPLONG Addend, ; addend
 LONG Increment ; increment value
)
KERNEL32.InterlockedExchangePointer(
 PVOID *Target, ; value to exchange
 PVOID Value ; new value
)
KERNEL32.InterlockedIncrement(
 LPLONG lpAddend ; variable to increment
)
GDI32.IntersectClipRect(
 HDC hdc, ; handle to DC
 int nLeftRect, ; x-coord of upper-left corner
 int nTopRect, ; y-coord of upper-left corner
 int nRightRect, ; x-coord of lower-right corner
 int nBottomRect ; y-coord of lower-right corner
)
USER32.IntersectRect(
 LPRECT lprcDst, ; intersection buffer
 CONST RECT *lprcSrc1, ; first rectangle
 CONST RECT *lprcSrc2 ; second rectangle
)
xxxx.IntlStrEqN(
 LPCTSTR pszStr1,
 LPCTSTR pszStr2,
 int nChar
)
xxxx.IntlStrEqNI(
 LPCTSTR pszStr1,
 LPCTSTR pszStr2,
 int nChar
)
xxxx.IntlStrEqWorkerA(
 BOOL fCaseSens,
 LPCTSTR pszStr1,
 LPCTSTR pszStr2,
 int nChar
)
USER32.InvalidateRect(
 HWND hWnd, ; handle to window
 CONST RECT *lpRect, ; rectangle coordinates
 BOOL bErase ; erase state
)
USER32.InvalidateRgn(
 HWND hWnd, ; handle to window
 HRGN hRgn, ; handle to region
 BOOL bErase ; erase state
)
USER32.InvertRect(
 HDC hDC, ; handle to DC
 CONST RECT *lprc ; rectangle
)
GDI32.InvertRgn(
 HDC hdc, ; handle to device context
 HRGN hrgn ; handle to region to be inverted
)
KERNEL32.IsBadCodePtr(
 FARPROC lpfn ; memory address
)
xxxx.IsBadHugeReadPtr(OBSOLETE - Use IsBadReadPtr)
)
xxxx.IsBadHugeWritePtr(OBSOLETE - Use IsBadWritePtr)
)
xxxx.IsBadReadPtr(
 CONST VOID *lp, ; memory address
 UINT_PTR ucb ; size of block
)
KERNEL32.IsBadStringPtrA(
 LPCTSTR lpsz, ; string
 UINT_PTR ucchMax ; maximum size of string
)
KERNEL32.IsBadWritePtr(
 LPVOID lp, ; memory address
 UINT_PTR ucb ; size of memory block
)
USER32.IsCharAlphaA(
 TCHAR ch ; character to test
)
USER32.IsCharAlphaNumericA(
 TCHAR ch ; character to test
)
USER32.IsCharLowerA(
 TCHAR ch ; character to test
)
USER32.IsCharUpperA(
 TCHAR ch ; character to test
)
USER32.IsChild(
 HWND hWndParent, ; handle to parent window
 HWND hWnd ; handle to window to test
)
USER32.IsClipboardFormatAvailable(
 UINT format ; clipboard format
)
KERNEL32.IsDBCSLeadByte(
 BYTE TestChar ; character to test
)
KERNEL32.IsDBCSLeadByteEx(
 UINT CodePage, ; identifier of code page
 BYTE TestChar ; byte to test
)
KERNEL32.IsDebuggerPresent(VOID)
)
USER32.IsDialogMessageA(
 HWND hDlg, ; handle to dialog box
 LPMSG lpMsg ; message to be checked
)
USER32.IsDlgButtonChecked(
 HWND hDlg, ; handle to dialog box
 int nIDButton ; button identifier
)
USER32.IsIconic(
 HWND hWnd ; handle to window
)
USER32.IsMenu(
 HMENU hMenu ; handle to test
)
KERNEL32.IsProcessorFeaturePresent(
 DWORD ProcessorFeature ; processor feature
)
USER32.IsRectEmpty(
 CONST RECT *lprc ; rectangle
)
USER-DEFINED.IsService(
 USHORT Type,
 PUCHAR Name,
 PIPX_SERVICE Service ; OPTIONAL
)
KERNEL32.IsSystemResumeAutomatic(VOID)
)
ADVAPI32.IsTextUnicode(
 CONST VOID *lpBuffer, ; input buffer to be examined
 int cb, ; size of input buffer
 LPINT lpi ; options
)
KERNEL32.IsValidCodePage(
 UINT CodePage ; code page
)
KERNEL32.IsValidLanguageGroup(
 LGRPID LanguageGroup, ; language-group identifier
 DWORD dwFlags ; validity test
)
KERNEL32.IsValidLocale(
 LCID Locale, ; locale identifier
 DWORD dwFlags ; validity test
)
USER32.IsWindow(
 HWND hWnd ; handle to window
)
USER32.IsWindowEnabled(
 HWND hWnd ; handle to window
)
USER32.IsWindowUnicode(
 HWND hWnd ; handle to window
)
USER32.IsWindowVisible(
 HWND hWnd ; handle to window
)
USER32.IsZoomed(
 HWND hWnd ; handle to window
)
USER-DEFINED.JournalPlaybackProc(
 int code, ; hook code
 WPARAM wParam, ; not used
 LPARAM lParam ; message being processed
)
USER-DEFINED.JournalRecordProc(
 int code, ; hook code
 WPARAM wParam, ; not used
 LPARAM lParam ; message being processed
)
USER32.keybd_event(
 BYTE bVk, ; virtual-key code
 BYTE bScan, ; hardware scan code
 DWORD dwFlags, ; function options
 ULONG_PTR dwExtraInfo ; additional keystroke data
)
USER-DEFINED.KeyboardProc(
 int code, ; hook code
 WPARAM wParam, ; virtual-key code
 LPARAM lParam ; keystroke-message information
)
USER32.KillTimer(
 HWND hWnd, ; handle to window
 UINT_PTR uIDEvent ; timer identifier
)
MAPI32.LAUNCHWIZARDENTRY(
 HWND hParentWnd,
 ULONG ulFlags,
 LPCTSTR FAR * lppszServiceNameToAdd,
 ULONG cbBufferMax,
 LPTSTR lpszNewProfileName
)
COMCTL32.LBItemFromPt(
 HWND hLB,
 POINT pt,
 BOOL bAutoScroll
)
KERNEL32.LCMapStringA(
 LCID Locale, ; locale identifier
 DWORD dwMapFlags, ; mapping transformation type
 LPCTSTR lpSrcStr, ; source string
 int cchSrc, ; number of characters in source string
 LPTSTR lpDestStr, ; destination buffer
 int cchDest ; size of destination buffer
)
xxxx.ldap_abandon(
 LDAP *ld,
 ULONG msgid
)
xxxx.ldap_add_ext_s(
 LDAP *ld,
 PCHAR dn,
 LDAPMod *attrs[],
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls
)
xxxx.ldap_add_ext(
 LDAP *ld,
 PCHAR dn,
 LDAPMod *attrs[],
 PLDAPControlA *ServerControls,
 PLDAPControlA *ClientControls,
 ULONG *MessageNumber
)
xxxx.ldap_add_s(
 LDAP *ld,
 PCHAR dn,
 LDAPMod *attrs[]
)
xxxx.ldap_add(
 LDAP *ld,
 PCHAR dn,
 LDAPMod *attrs[]
)
xxxx.ldap_bind_s(
 LDAP *ld,
 PCHAR dn,
 PCHAR cred,
 ULONG method
)
xxxx.ldap_bind(
 LDAP *ld,
 PCHAR dn,
 PCHAR cred,
 ULONG method
)
xxxx.ldap_check_filter(
 LDAP *ld,
 PWCHAR SearchFilter
)
xxxx.ldap_close_extended_op(
 LDAP *ld,
 ULONG MessageNumber
)
xxxx.ldap_compare_ext_s(
 LDAP *ld,
 PCHAR dn,
 PCHAR Attr,
 PCHAR Value,
 struct berval *Data,
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls
)
xxxx.ldap_compare_ext(
 LDAP *ld,
 PCHAR dn,
 PCHAR Attr,
 PCHAR Value,
 struct berval *Data,
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls,
 ULONG *MessageNumber
)
xxxx.ldap_compare_s(
 LDAP *ld,
 PCHAR dn,
 PCHAR attr,
 CHAR value
)
xxxx.ldap_compare(
 LDAP *ld,
 PCHAR dn,
 PCHAR attr,
 PCHAR value
)
xxxx.ldap_connect(
 LDAP *ld,
 struct l_timeval *timeout
)
xxxx.ldap_control_free(
 LDAPControl *Control
)
xxxx.ldap_controls_free(
 LDAPControl **Controls
)
xxxx.ldap_count_entries(
 LDAP *ld,
 LDAPMessage *res
)
xxxx.ldap_count_references(
 LDAP *ld,
 LDAPMessage *res
)
xxxx.ldap_count_values_len(
 struct berval **vals
)
xxxx.ldap_count_values(
 PCHAR *vals
)
xxxx.ldap_create_page_control(
 PLDAP ExternalHandle,
 ULONG PageSize,
 struct berval *Cookie,
 UCHAR IsCritical,
 PLDAPControl *Control
)
xxxx.ldap_create_sort_control (
 PLDAP ExternalHandle,
 PLDAPSortKey *SortKeys,
 UCHAR IsCritical,
 PLDAPControl *Control
)
xxxx.ldap_create_vlv_control(
 LDAP *ld,
 LDAPVLVInfo *Vlvinfop,
 char IsCritical,
 LDAPControl **ctrlp
)
xxxx.ldap_delete_ext_s(
 LDAP *ld,
 PCHAR dn,
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls
)
xxxx.ldap_delete_ext(
 LDAP *ld,
 PCHAR dn,
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls,
 ULONG *MessageNumber
)
xxxx.ldap_delete_s(
 LDAP *ld,
 PCHAR dn
)
xxxx.ldap_delete(
 LDAP *ld,
 PCHAR dn
)
xxxx.ldap_dn2ufn(
 PCHAR dn
)
xxxx.ldap_encode_sort_control (
 PLDAP ExternalHandle,
 PLDAPSortKey *SortKeys,
 PLDAPControl Control,
 BOOLEAN IsCritical
)
xxxx.ldap_err2string(
 ULONG err
)
xxxx.ldap_escape_filter_element (
 PCHAR sourceFilterElement,
 ULONG sourceLength,
 PCHAR destFilterElement,
 ULONG destLength
)
xxxx.ldap_explode_dn(
 PCHAR dn,
 ULONG notypes
)
xxxx.ldap_extended_operation(
 LDAP *ld,
 PCHAR Oid,
 struct berval *Data,
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls,
 ULONG *MessageNumber
)
xxxx.ldap_first_attribute(
 LDAP *ld,
 LDAPMessage *entry,
 BerElement **ptr
)
xxxx.ldap_first_entry(
 LDAP *ld,
 LDAPMessage *res
)
xxxx.ldap_first_reference(
 LDAP *ld,
 LDAPMessage *res
)
xxxx.ldap_free_controls(OBSOLETE - Use ldap_controls_free)
)
xxxx.ldap_get_dn(
 LDAP *ld,
 LDAPMessage *entry
)
xxxx.ldap_get_next_page_s(
 PLDAP ExternalHandle,
 PLDAPSearch SearchHandle,
 struct l_timeval *timeout,
 ULONG PageSize,
 ULONG *TotalCount,
 LDAPMessage **Results
)
xxxx.ldap_get_next_page(
 PLDAP ExternalHandle,
 PLDAPSearch SearchHandle,
 ULONG PageSize,
 ULONG *MessageNumber
)
xxxx.ldap_get_option(
 LDAP *ld,
 int option,
 void *outvalue
)
xxxx.ldap_get_paged_count(
 PLDAP ExternalHandle,
 PLDAPSearch SearchBlock,
 ULONG *TotalCount,
 PLDAPMessage Results
)
xxxx.ldap_get_values_len(
 LDAP *ExternalHandle,
 LDAPMessage *Message,
 PCHAR attr
)
xxxx.ldap_get_values(
 LDAP *ld,
 LDAPMessage *entry,
 PCHAR attr
)
xxxx.ldap_init(
 PCHAR HostName,
 ULONG PortNumber
)
xxxx.ldap_memfree(
 PCHAR Block
)
xxxx.ldap_modify_ext_s(
 LDAP *ld,
 PCHAR dn,
 LDAPMod *mods[],
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls
)
xxxx.ldap_modify_ext(
 LDAP *ld,
 PCHAR dn,
 LDAPMod *mods[],
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls,
 ULONG *MessageNumber
)
xxxx.ldap_modify_s(
 LDAP *ld,
 PCHAR dn,
 LDAPMod *mods[]
)
xxxx.ldap_modify(
 LDAP *ld,
 PCHAR dn,
 LDAPMod *mods[]
)
xxxx.ldap_modrdn_s(
 LDAP *ExternalHandle,
 PCHAR DistinguishedName,
 PCHAR NewDistinguishedName
)
xxxx.ldap_modrdn(
 LDAP *ExternalHandle,
 PCHAR DistinguishedName,
 PCHAR NewDistinguishedName
)
xxxx.ldap_modrdn2_s(
 LDAP *ExternalHandle,
 PCHAR DistinguishedName,
 PCHAR NewDistinguishedName,
 INT DeleteOldRdn
)
xxxx.ldap_modrdn2(
 LDAP *ExternalHandle,
 PCHAR DistinguishedName,
 PCHAR NewDistinguishedName,
 INT DeleteOldRdn
)
xxxx.ldap_msgfree(
 LDAPMessage *res
)
xxxx.ldap_next_attribute(
 LDAP *ld,
 LDAPMessage *entry,
 BerElement *ptr
)
xxxx.ldap_next_entry(
 LDAP *ld,
 LDAPMessage *entry
)
xxxx.ldap_next_reference(
 LDAP *ld,
 LDAPMessage *entry
)
xxxx.ldap_open(
 PCHAR HostName,
 ULONG PortNumber
)
xxxx.ldap_parse_extended_result(
 LDAP Connection,
 LDAPMessage *ResultMessage,
 PCHAR *ResultOID,
 struct berval **ResultData,
 BOOLEAN Freeit
)
xxxx.ldap_parse_page_control(
 PLDAP ExternalHandle,
 PLDAPControl *ServerControls,
 ULONG *TotalCount,
 struct berval **Cookie
)
xxxx.ldap_parse_reference(
 LDAP *Connection,
 LDAPMessage *ResultMessage,
 PCHAR **Referrals
)
xxxx.ldap_parse_result(
 LDAP *Connection,
 LDAPMessage *ResultMessage,
 ULONG *ReturnCode OPTIONAL,
 PWCHAR *MatchedDNs OPTIONAL,
 PWCHAR *ErrorMessage OPTIONAL,
 PWCHAR **Referrals OPTIONAL,
 PLDAPControl **ServerControls OPTIONAL,
 BOOLEAN Freeit
)
xxxx.ldap_parse_sort_control(
 PLDAP ExternalHandle,
 PLDAPControl *Control,
 ULONG *Result,
 PCHAR *Attribute
)
xxxx.ldap_parse_vlv_control(
 LDAP *ld,
 LDAPControl **ctrls,
 unsigned long *target_posp,
 unsigned long *list_countp,
 struct berval **contextp,
 int *errcodep
)
xxxx.ldap_perror(OBSOLETE - Use LdapGetLastError)
)
xxxx.ldap_rename_ext_s(
 LDAP *ld,
 PWCHAR dn,
 PWCHAR NewRDN,
 PWCHAR NewParent,
 INT DeleteOldRdn,
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls
)
xxxx.ldap_rename_ext(
 LDAP *ld,
 PWCHAR dn,
 PWCHAR NewRDN,
 PWCHAR NewParent,
 INT DeleteOldRdn,
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls,
 ULONG *MessageNumber
)
xxxx.ldap_result(
 LDAP *ld,
 ULONG msgid,
 ULONG all,
 struct l_timeval *timeout,
 LDAPMessage **res
)
xxxx.ldap_result2error(
 LDAP *ld,
 LDAPMessage *res,
 ULONG freeit
)
xxxx.ldap_sasl_bind_s(
 LDAP *ExternalHandle,
 const PCHAR DistName,
 const PCHAR AuthMechanism,
 const BERVAL *cred,
 PLDAPControlA *ServerCtrls,
 PLDAPControlA *ClientCtrls,
 PBERVAL *ServerData
)
xxxx.ldap_sasl_bind(
 LDAP *ExternalHandle,
 const PCHAR DistName,
 const PCHAR AuthMechanism,
 const BERVAL *cred,
 PLDAPControlA *ServerCtrls,
 PLDAPControlA *ClientCtrls,
 int *MessageNumber
)
xxxx.ldap_search_abandon_page(
 PLDAP ExternalHandle,
 PLDAPSearch SearchBlock
)
xxxx.ldap_search_ext_s(
 LDAP *ld,
 PCHAR base,
 ULONG scope,
 PCHAR filter,
 PCHAR attrs[],
 ULONG attrsonly,
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls,
 struct l_timeval *timeout,
 ULONG SizeLimit,
 LDAPMessage **res
)
xxxx.ldap_search_ext(
 LDAP *ld,
 PCHAR base,
 ULONG scope,
 PCHAR filter,
 PCHAR attrs[],
 ULONG attrsonly,
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls,
 ULONG TimeLimit,
 ULONG SizeLimit,
 ULONG *MessageNumber
)
xxxx.ldap_search_init_page(
 PLDAP ExternalHandle,
 PCHAR DistinguishedName,
 ULONG ScopeOfSearch,
 PCHAR SearchFilter,
 PCHAR AttributeList[],
 ULONG AttributesOnly,
 PLDAPControl *ServerControls,
 PLDAPControl *ClientControls,
 ULONG PageTimeLimit,
 ULONG TotalSizeLimit,
 PLDAPSortKey *SortKeys
)
xxxx.ldap_search_s(
 LDAP *ld,
 PCHAR base,
 ULONG scope,
 PCHAR filter,
 PCHAR attrs[],
 ULONG attrsonly,
 LDAPMessage **res
)
xxxx.ldap_search_st(
 LDAP *ld,
 PCHAR base,
 ULONG scope,
 PCHAR filter,
 PCHAR attrs[],
 ULONG attrsonly,
 struct l_timeval *timeout,
 LDAPMessage **res
)
xxxx.ldap_search(
 LDAP *ld,
 PCHAR base,
 ULONG scope,
 PCHAR filter,
 PCHAR attrs[],
 ULONG attrsonly
)
xxxx.ldap_set_option(
 LDAP *ld,
 int option,
 void *invalue
)
xxxx.ldap_simple_bind_s(
 LDAP *ld,
 PCHAR dn,
 PCHAR passwd
)
xxxx.ldap_simple_bind(
 LDAP *ld,
 PCHAR dn,
 PCHAR passwd
)
xxxx.ldap_sslinit(
 PCHAR HostName,
 ULONG PortNumber,
 int secure
)
xxxx.ldap_ufn2dn(
 PCHAR ufn,
 PCHAR *pDn
)
xxxx.ldap_unbind_s(
 LDAP *ld
)
xxxx.ldap_unbind(
 LDAP *ld
)
xxxx.ldap_value_free_len(
 struct berval **vals
)
xxxx.ldap_value_free(
 PCHAR *vals
)
xxxx.LdapGetLastError(VOID)
)
xxxx.LdapMapErrorToWin32(
 ULONG LdapError
)
xxxx.LdapUnicodeToUTF8(
 LPCWSTR lpSrcStr,
 int cchSrc,
 LPSTR lpDestStr,
 int cchDest
)
xxxx.LdapUTF8ToUnicode(
 LPCSTR lpSrcStr,
 int cchSrc,
 LPWSTR lpDestStr,
 int cchDest
)
KERNEL32.LeaveCriticalSection(
 LPCRITICAL_SECTION lpCriticalSection ; critical section
)
xxxx.LimitEmsPages(OBSOLETE)
)
xxxx.lineAccept(
 HCALL hCall,
 LPCSTR lpsUserUserInfo,
 DWORD dwSize
)
TAPI32.lineAddProviderA(
 LPCSTR lpszProviderFilename,
 HWND hwndOwner,
 LPDWORD lpdwPermanentProviderID
)
TAPI32.lineAddToConference(
 HCALL hConfCall,
 HCALL hConsultCall
)
TAPI32.lineAgentSpecific(
 HLINE hLine,
 DWORD dwAddressID,
 DWORD dwAgentExtensionIDIndex,
 LPVOID lpParams,
 DWORD dwSize
)
TAPI32.lineAnswer(
 HCALL hCall,
 LPCSTR lpsUserUserInfo,
 DWORD dwSize
)
TAPI32.lineBlindTransferA(
 HCALL hCall,
 LPCSTR lpszDestAddress,
 DWORD dwCountryCode
)
USER-DEFINED.lineCallbackFunc(
 DWORD hDevice,
 DWORD dwMsg,
 DWORD dwCallbackInstance,
 DWORD dwParam1,
 DWORD dwParam2,
 DWORD dwParam3
)
TAPI32.lineClose(
 HLINE hLine
)
TAPI32.lineCompleteCall(
 HCALL hCall,
 LPDWORD lpdwCompletionID,
 DWORD dwCompletionMode,
 DWORD dwMessageID
)
TAPI32.lineCompleteTransfer(
 HCALL hCall,
 HCALL hConsultCall,
 LPHCALL lphConfCall,
 DWORD dwTransferMode
)
TAPI32.lineConfigDialogA(
 DWORD dwDeviceID,
 HWND hwndOwner,
 LPCSTR lpszDeviceClass
)
TAPI32.lineConfigDialogEditA(
 DWORD dwDeviceID,
 HWND hwndOwner,
 LPCSTR lpszDeviceClass,
 LPVOID const lpDeviceConfigIn,
 DWORD dwSize,
 LPVARSTRING lpDeviceConfigOut
)
TAPI32.lineConfigProvider(
 HWND hwndOwner,
 DWORD dwPermanentProviderID
)
xxxx.lineCreateAgent(
 HLINE hLine,
 LPWSTR lpszAgentID,
 LPWSTR lpszAgentPIN,
 LPHAGENT lphAgent
)
xxxx.lineCreateAgentSession(
 HLINE hLine,
 HAGENT hAgent,
 LPWSTR lpszAgentPIN,
 DWORD dwWorkingAddressID,
 LPGUID lpGroupID,
 LPHAGENTSESSION lphAgentSession
)
GDI32.LineDDA(
 int nXStart, ; x-coordinate of starting point
 int nYStart, ; y-coordinate of starting point
 int nXEnd, ; x-coordinate of ending point
 int nYEnd, ; y-coordinate of ending point
 LINEDDAPROC lpLineFunc, ; callback function
 LPARAM lpData ; application-defined data
)
USER-DEFINED.LineDDAProc(
 int X, ; x-coordinate of point
 int Y, ; y-coordinate of point
 LPARAM lpData ; application-defined data
)
TAPI32.lineDeallocateCall(
 HCALL hCall
)
TAPI32.lineDevSpecific(
 HLINE hLine,
 DWORD dwAddressID,
 HCALL hCall,
 LPVOID lpParams,
 DWORD dwSize
)
TAPI32.lineDevSpecificFeature(
 HLINE hLine,
 DWORD dwFeature,
 LPVOID lpParams,
 DWORD dwSize
)
TAPI32.lineDialA(
 HCALL hCall,
 LPCSTR lpszDestAddress,
 DWORD dwCountryCode
)
TAPI32.lineDrop(
 HCALL hCall,
 LPCSTR lpsUserUserInfo,
 DWORD dwSize
)
TAPI32.lineForwardA(
 HLINE hLine,
 DWORD bAllAddresses,
 DWORD dwAddressID,
 LPLINEFORWARDLIST const lpForwardList,
 DWORD dwNumRingsNoAnswer,
 LPHCALL lphConsultCall,
 LPLINECALLPARAMS const lpCallParams
)
TAPI32.lineGatherDigitsA(
 HCALL hCall,
 DWORD dwDigitModes,
 LPSTR lpsDigits,
 DWORD dwNumDigits,
 LPCSTR lpszTerminationDigits,
 DWORD dwFirstDigitTimeout,
 DWORD dwInterDigitTimeout
)
TAPI32.lineGenerateDigitsA(
 HCALL hCall,
 DWORD dwDigitMode,
 LPCSTR lpszDigits,
 DWORD dwDuration
)
TAPI32.lineGenerateDigits(
 HCALL hCall,
 DWORD dwDigitMode,
 LPCSTR lpszDigits,
 DWORD dwDuration
)
TAPI32.lineGetAddressCapsA(
 HLINEAPP hLineApp,
 DWORD dwDeviceID,
 DWORD dwAddressID,
 DWORD dwAPIVersion,
 DWORD dwExtVersion,
 LPLINEADDRESSCAPS lpAddressCaps
)
TAPI32.lineGetAddressIDA(
 HLINE hLine,
 LPDWORD lpdwAddressID,
 DWORD dwAddressMode,
 LPCSTR lpsAddress,
 DWORD dwSize
)
TAPI32.lineGetAddressStatusA(
 HLINE hLine,
 DWORD dwAddressID,
 LPLINEADDRESSSTATUS lpAddressStatus
)
TAPI32.lineGetAgentActivityListA(
 HLINE hLine,
 DWORD dwAddressID,
 LPLINEAGENTACTIVITYLIST lpAgentActivityList
)
TAPI32.lineGetAgentCapsA(
 HLINEAPP hLineApp,
 DWORD dwDeviceID,
 DWORD dwAddressID,
 DWORD dwAppAPIVersion,
 LPLINEAGENTCAPS lpAgentCaps
)
TAPI32.lineGetAgentGroupListA(
 HLINE hLine,
 DWORD dwAddressID,
 LPLINEAGENTGROUPLIST lpAgentGroupList
)
TAPI32.lineGetAgentInfo(
 HLINE hLine,
 HAGENT hAgent,
 LPLINEAGENTINFO lpAgentInfo
)
TAPI32.lineGetAgentSessionInfo(
 HLINE hLine,
 HAGENTSESSION hAgentSession,
 LPLINEAGENTSESSIONINFO lpAgentSessionInfo
)
TAPI32.lineGetAgentSessionList(
 HLINE hLine,
 HAGENT hAgent,
 LPLINEAGENTSESSIONLIST lpAgentSessionList
)
TAPI32.lineGetAgentStatusA(
 HLINE hLine,
 DWORD dwAddressID,
 LPLINEAGENTSTATUS lpAgentStatus
)
TAPI32.lineGetAppPriorityA(
 LPCSTR lpszAppFilename,
 DWORD dwMediaMode,
 LPLINEEXTENSIONID lpExtensionID,
 DWORD dwRequestMode,
 LPVARSTRING lpExtensionName,
 LPDWORD lpdwPriority
)
TAPI32.lineGetCallInfoA(
 HCALL hCall,
 LPLINECALLINFO lpCallInfo
)
TAPI32.lineGetCallStatus(
 HCALL hCall,
 LPLINECALLSTATUS lpCallStatus
)
TAPI32.lineGetConfRelatedCalls(
 HCALL hCall,
 LPLINECALLLIST lpCallList
)
TAPI32.lineGetCountryA(
 DWORD dwCountryID,
 DWORD dwAPIVersion,
 LPLINECOUNTRYLIST lpLineCountryList
)
TAPI32.lineGetDevCapsA(
 HLINEAPP hLineApp,
 DWORD dwDeviceID,
 DWORD dwAPIVersion,
 DWORD dwExtVersion,
 LPLINEDEVCAPS lpLineDevCaps
)
TAPI32.lineGetDevConfigA(
 DWORD dwDeviceID,
 LPVARSTRING lpDeviceConfig,
 LPCSTR lpszDeviceClass
)
TAPI32.lineGetGroupList(
 HLINE hLine,
 LPLINEAGENTGROUPLIST lpGroupList
)
TAPI32.lineGetIconA(
 DWORD dwDeviceID,
 LPCSTR lpszDeviceClass,
 LPHICON lphIcon
)
TAPI32.lineGetIDA(
 HLINE hLine,
 DWORD dwAddressID,
 HCALL hCall,
 DWORD dwSelect,
 LPVARSTRING lpDeviceID,
 LPCSTR lpszDeviceClass
)
TAPI32.lineGetLineDevStatusA(
 HLINE hLine,
 LPLINEDEVSTATUS lpLineDevStatus
)
TAPI32.lineGetMessage(
 HLINEAPP hLineApp,
 LPLINEMESSAGE lpMessage,
 DWORD dwTimeout
)
TAPI32.lineGetNewCalls(
 HLINE hLine,
 DWORD dwAddressID,
 DWORD dwSelect,
 LPLINECALLLIST lpCallList
)
TAPI32.lineGetNumRings(
 HLINE hLine,
 DWORD dwAddressID,
 LPDWORD lpdwNumRings
)
TAPI32.lineGetProviderListA(
 DWORD dwAPIVersion,
 LPLINEPROVIDERLIST lpProviderList
)
TAPI32.lineGetProxyStatus(
 HLINEAPP hLineApp,
 DWORD dwDeviceID,
 DWORD dwAppAPIVersion,
 LPLINEPROXYREQUESTLIST lpLineProxyRequestList
)
TAPI32.lineGetQueueInfo(
 HLINE hLine,
 DWORD dwQueueID,
 LPLINEQUEUEINFO lpLineQueueInfo
)
TAPI32.lineGetQueueList(
 HLINE hLine,
 LPGUID lpGroupID,
 LPLINEQUEUELIST lpQueueList
)
TAPI32.lineGetRequestA(
 HLINEAPP hLineApp,
 DWORD dwRequestMode,
 LPVOID lpRequestBuffer
)
TAPI32.lineGetStatusMessages(
 HLINE hLine,
 LPDWORD lpdwLineStates,
 LPDWORD lpdwAddressStates
)
TAPI32.lineGetTranslateCapsA(
 HLINEAPP hLineApp,
 DWORD dwAPIVersion,
 LPLINETRANSLATECAPS lpTranslateCaps
)
TAPI32.lineHandoffA(
 HCALL hCall,
 LPCSTR lpszFileName,
 DWORD dwMediaMode
)
TAPI32.lineHold(
 HCALL hCall
)
TAPI32.lineInitialize(
 LPHLINEAPP lphLineApp,
 HINSTANCE hInstance,
 LINECALLBACK lpfnCallback,
 LPCSTR lpszAppName,
 LPDWORD lpdwNumDevs
)
TAPI32.lineInitializeExA(
 LPHLINEAPP lphLineApp,
 HINSTANCE hInstance,
 LINECALLBACK lpfnCallback,
 LPCSTR lpszFriendlyAppName,
 LPDWORD lpdwNumDevs,
 LPDWORD lpdwAPIVersion,
 LPLINEINITIALIZEEXPARAMS lpLineInitializeExParams
)
TAPI32.lineMakeCallA(
 HLINE hLine,
 LPHCALL lphCall,
 LPCSTR lpszDestAddress,
 DWORD dwCountryCode,
 LPLINECALLPARAMS const lpCallParams
)
TAPI32.lineMonitorDigits(
 HCALL hCall,
 DWORD dwDigitModes
)
TAPI32.lineMonitorMedia(
 HCALL hCall,
 DWORD dwMediaModes
)
TAPI32.lineMonitorTones(
 HCALL hCall,
 LPLINEMONITORTONE const lpToneList,
 DWORD dwNumEntries
)
TAPI32.lineNegotiateAPIVersion(
 HLINEAPP hLineApp,
 DWORD dwDeviceID,
 DWORD dwAPILowVersion,
 DWORD dwAPIHighVersion,
 LPDWORD lpdwAPIVersion,
 LPLINEEXTENSIONID lpExtensionID
)
TAPI32.lineNegotiateExtVersion(
 HLINEAPP hLineApp,
 DWORD dwDeviceID,
 DWORD dwAPIVersion,
 DWORD dwExtLowVersion,
 DWORD dwExtHighVersion,
 LPDWORD lpdwExtVersion
)
TAPI32.lineOpenA(
 HLINEAPP hLineApp,
 DWORD dwDeviceID,
 LPHLINE lphLine,
 DWORD dwAPIVersion,
 DWORD dwExtVersion,
 DWORD_PTR dwCallbackInstance,
 DWORD dwPrivileges,
 DWORD dwMediaModes,
 LPLINECALLPARAMS const lpCallParams
)
TAPI32.lineParkA(
 HCALL hCall,
 DWORD dwParkMode,
 LPCSTR lpszDirAddress,
 LPVARSTRING lpNonDirAddress
)
TAPI32.linePickupA(
 HLINE hLine,
 DWORD dwAddressID,
 LPHCALL lphCall,
 LPCSTR lpszDestAddress,
 LPCSTR lpszGroupID
)
TAPI32.linePrepareAddToConferenceA(
 HCALL hConfCall,
 LPHCALL lphConsultCall,
 LPLINECALLPARAMS const lpCallParams
)
TAPI32.lineProxyMessage(
 HLINE hLine,
 HCALL hCall,
 DWORD dwMsg,
 DWORD dwParam1,
 DWORD dwParam2,
 DWORD dwParam3
)
TAPI32.lineProxyResponse(
 HLINE hLine,
 LPLINEPROXYREQUEST lpProxyRequest,
 DWORD dwResult
)
TAPI32.lineRedirectA(
 HCALL hCall,
 LPCSTR lpszDestAddress,
 DWORD dwCountryCode
)
TAPI32.lineRegisterRequestRecipient(
 HLINEAPP hLineApp,
 DWORD dwRegistrationInstance,
 DWORD dwRequestMode,
 DWORD bEnable
)
TAPI32.lineReleaseUserUserInfo(
 HCALL hCall
)
TAPI32.lineRemoveFromConference(
 HCALL hCall
)
TAPI32.lineRemoveProvider(
 DWORD dwPermanentProviderID,
 HWND hwndOwner
)
TAPI32.lineSecureCall(
 HCALL hCall
)
TAPI32.lineSendUserUserInfo(
 HCALL hCall,
 LPCSTR lpsUserUserInfo,
 DWORD dwSize
)
TAPI32.lineSetAgentActivity(
 HLINE hLine,
 DWORD dwAddressID,
 DWORD dwActivityID
)
TAPI32.lineSetAgentGroup(
 HLINE hLine,
 DWORD dwAddressID,
 LPLINEAGENTGROUPLIST lpAgentGroupList
)
TAPI32.lineSetAgentMeasurementPeriod(
 HLINE hLine,
 HAGENT hAgent,
 DWORD dwMeasurementPeriod
)
TAPI32.lineSetAgentSessionState(
 HLINE hLine,
 HAGENTSESSION hAgentSession,
 DWORD dwAgentSessionState,
 DWORD dwNextAgentSessionState
)
TAPI32.lineSetAgentState(
 HLINE hLine,
 DWORD dwAddressID,
 DWORD dwAgentState,
 DWORD dwNextAgentState
)
TAPI32.lineSetAgentStateEx(
 HLINE hLine,
 HAGENT hAgent,
 DWORD dwAgentState,
 DWORD dwNextAgentState
)
TAPI32.lineSetAppPriority(
 LPCSTR lpszAppFilename,
 DWORD dwMediaMode,
 LPLINEEXTENSIONID lpExtensionID,
 DWORD dwRequestMode,
 LPCSTR lpszExtensionName,
 DWORD dwPriority
)
TAPI32.lineSetAppSpecific(
 HCALL hCall,
 DWORD dwAppSpecific
)
TAPI32.lineSetCallData(
 HCALL hCall,
 LPVOID lpCallData,
 DWORD dwSize
)
TAPI32.lineSetCallParams(
 HCALL hCall,
 DWORD dwBearerMode,
 DWORD dwMinRate,
 DWORD dwMaxRate,
 LPLINEDIALPARAMS const lpDialParams
)
TAPI32.lineSetCallPrivilege(
 HCALL hCall,
 DWORD dwCallPrivilege
)
TAPI32.lineSetCallQualityOfService(
 HCALL hCall,
 LPVOID lpSendingFlowspec,
 DWORD dwSendingFlowspecSize,
 LPVOID lpReceivingFlowspec,
 DWORD dwReceivingFlowspecSize
)
TAPI32.lineSetCallTreatment(
 HCALL hCall,
 DWORD dwTreatment
)
TAPI32.lineSetCurrentLocation(
 HLINEAPP hLineApp,
 DWORD dwLocation
)
TAPI32.lineSetDevConfigA(
 DWORD dwDeviceID,
 LPVOID const lpDeviceConfig,
 DWORD dwSize,
 LPCSTR lpszDeviceClass
)
TAPI32.lineSetLineDevStatus(
 HLINE hLine,
 DWORD dwStatusToChange,
 DWORD fStatus
)
TAPI32.lineSetMediaControl(
 HLINE hLine,
 DWORD dwAddressID,
 HCALL hCall,
 DWORD dwSelect,
 LPLINEMEDIACONTROLDIGIT const lpDigitList,
 DWORD dwDigitNumEntries,
 LPLINEMEDIACONTROLMEDIA const lpMediaList,
 DWORD dwMediaNumEntries,
 LPLINEMEDIACONTROLTONE const lpToneList,
 DWORD dwToneNumEntries,
 LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
 DWORD dwCallStateNumEntries
)
TAPI32.lineSetMediaMode(
 HCALL hCall,
 DWORD dwMediaModes
)
TAPI32.lineSetNumRings(
 HLINE hLine,
 DWORD dwAddressID,
 DWORD dwNumRings
)
TAPI32.lineSetQueueMeasurementPeriod(
 HLINE hLine,
 DWORD dwQueueID,
 DWORD dwMeasurementPeriod
)
TAPI32.lineSetStatusMessages(
 HLINE hLine,
 DWORD dwLineStates,
 DWORD dwAddressStates
)
TAPI32.lineSetTerminal(
 HLINE hLine,
 DWORD dwAddressID,
 HCALL hCall,
 DWORD dwSelect,
 DWORD dwTerminalModes,
 DWORD dwTerminalID,
 DWORD bEnable
)
TAPI32.lineSetTollListA(
 HLINEAPP hLineApp,
 DWORD dwDeviceID,
 LPCSTR lpszAddressIn,
 DWORD dwTollListOption
)
TAPI32.lineSetupConferenceA(
 HCALL hCall,
 HLINE hLine,
 LPHCALL lphConfCall,
 LPHCALL lphConsultCall,
 DWORD dwNumParties,
 LPLINECALLPARAMS const lpCallParams
)
TAPI32.lineSetupTransferA(
 HCALL hCall,
 LPHCALL lphConsultCall,
 LPLINECALLPARAMS const lpCallParams
)
TAPI32.lineShutdown(
 HLINEAPP hLineApp
)
TAPI32.lineSwapHold(
 HCALL hActiveCall,
 HCALL hHeldCall
)
GDI32.LineTo(
 HDC hdc, ; device context handle
 int nXEnd, ; x-coordinate of ending point
 int nYEnd ; y-coordinate of ending point
)
TAPI32.lineTranslateAddressA(
 HLINEAPP hLineApp,
 DWORD dwDeviceID,
 DWORD dwAPIVersion,
 LPCSTR lpszAddressIn,
 DWORD dwCard,
 DWORD dwTranslateOptions,
 LPLINETRANSLATEOUTPUT lpTranslateOutput
)
TAPI32.lineTranslateDialogA(
 HLINEAPP hLineApp,
 DWORD dwDeviceID,
 DWORD dwAPIVersion,
 HWND hwndOwner,
 LPCSTR lpszAddressIn
)
TAPI32.lineUncompleteCall(
 HLINE hLine,
 DWORD dwCompletionID
)
TAPI32.lineUnhold(
 HCALL hCall
)
TAPI32.lineUnparkA(
 HLINE hLine,
 DWORD dwAddressID,
 LPHCALL lphCall,
 LPCSTR lpszDestAddress
)
USER32.LoadAcceleratorsA(
 HINSTANCE hInstance, ; handle to module
 LPCTSTR lpTableName ; accelerator table name
)
USER32.LoadBitmapA(
 HINSTANCE hInstance, ; handle to application instance
 LPCTSTR lpBitmapName ; name of bitmap resource
)
USER32.LoadCursorA(
 HINSTANCE hInstance, ; handle to application instance
 LPCTSTR lpCursorName ; name or resource identifier
)
USER32.LoadCursorFromFileA(
 LPCTSTR lpFileName ; file or identifier
)
USER32.LoadIconA(
 HINSTANCE hInstance, ; handle to application instance
 LPCTSTR lpIconName ; name string or resource identifier
)
USER32.LoadImageA(
 HINSTANCE hinst, ; handle to instance
 LPCTSTR lpszName, ; image to load
 UINT uType, ; image type
 int cxDesired, ; desired width
 int cyDesired, ; desired height
 UINT fuLoad ; load options
)
USER32.LoadKeyboardLayoutA(
 LPCTSTR pwszKLID, ; input locale identifier
 UINT Flags ; input locale identifier options
)
KERNEL32.LoadLibraryA(
 LPCTSTR lpFileName ; file name of module
)
KERNEL32.LoadLibraryExA(
 LPCTSTR lpFileName, ; file name of module
 HANDLE hFile, ; reserved, must be NULL
 DWORD dwFlags ; entry-point execution option
)
USER32.LoadMenuA(
 HINSTANCE hInstance, ; handle to module
 LPCTSTR lpMenuName ; menu name or resource identifier
)
USER32.LoadMenuIndirectA(
 CONST MENUTEMPLATE *lpMenuTemplate ; menu template
)
KERNEL32.LoadModule(
 LPCSTR lpModuleName, ; file name of application
 LPVOID lpParameterBlock ; parameter block
)
KERNEL32.LoadResource(
 HMODULE hModule, ; module handle
 HRSRC hResInfo ; resource handle
)
USER32.LoadStringA(
 HINSTANCE hInstance, ; handle to resource module
 UINT uID, ; resource identifier
 LPTSTR lpBuffer, ; resource buffer
 int nBufferMax ; size of buffer
)
xxxx.LoadUserProfile(
 HANDLE hToken, ; user token
 LPPROFILEINFO lpProfileInfo ; profile
)
KERNEL32.LocalAlloc(
 UINT uFlags, ; allocation attributes
 SIZE_T uBytes ; number of bytes to allocate
)
xxxx.LocalCompact(OBSOLETE)
)
xxxx.LocalDiscard(
 HLOCAL hlocMem ; handle to local memory object
)
KERNEL32.LocalFileTimeToFileTime(
 CONST FILETIME *lpLocalFileTime, ; local file time
 LPFILETIME lpFileTime ; file time
)
KERNEL32.LocalFlags(
 HLOCAL hMem ; handle to local memory object
)
KERNEL32.LocalFree(
 HLOCAL hMem ; handle to local memory object
)
KERNEL32.LocalHandle(
 LPCVOID pMem ; pointer to local memory object
)
KERNEL32.LocalLock(
 HLOCAL hMem ; handle to local memory object
)
KERNEL32.LocalReAlloc(
 HLOCAL hMem, ; handle to local memory object
 SIZE_T uBytes, ; new block size
 UINT uFlags ; how to reallocate object
)
xxxx.LocalShrink(OBSOLETE)
)
KERNEL32.LocalSize(
 HLOCAL hMem ; handle to local memory object
)
KERNEL32.LocalUnlock(
 HLOCAL hMem ; handle to local memory object
)
KERNEL32.LockFile(
 HANDLE hFile, ; handle to file
 DWORD dwFileOffsetLow, ; low-order word of offset
 DWORD dwFileOffsetHigh, ; high-order word of offset
 DWORD nNumberOfBytesToLockLow, ; low-order word of length
 DWORD nNumberOfBytesToLockHigh ; high-order word of length
)
KERNEL32.LockFileEx(
 HANDLE hFile, ; handle to file
 DWORD dwFlags, ; lock options
 DWORD dwReserved, ; reserved
 DWORD nNumberOfBytesToLockLow, ; low-order word of length
 DWORD nNumberOfBytesToLockHigh, ; high-order word of length
 LPOVERLAPPED lpOverlapped ; contains starting offset
)
KERNEL32.LockResource(
 HGLOBAL hResData ; handle to resource
)
xxxx.LockSegment(OBSOLETE)
)
ADVAPI32.LockServiceDatabase(
 SC_HANDLE hSCManager ; handle to SCM database
)
xxxx.LockSetForegroundWindow(
 UINT uLockCode ; disable or enable calls
)
USER32.LockWindowUpdate(
 HWND hWndLock ; handle to window
)
USER32.LockWorkStation(VOID)
LookupIconIdFromDirectory(
 PBYTE presbits, ; resource data
 BOOL fIcon ; icon or cursor
)
USER32.LookupIconIdFromDirectoryEx(
 PBYTE presbits, ; resource data
 BOOL fIcon, ; icon or cursor
 int cxDesired, ; width of icon or cursor
 int cyDesired, ; height of icon or cursor
 UINT Flags ; resource options
)
USER-DEFINED.LowLevelKeyboardProc(
 int nCode, ; hook code
 WPARAM wParam, ; message identifier
 LPARAM lParam ; message data
)
USER-DEFINED.LowLevelMouseProc(
 int nCode, ; hook code
 WPARAM wParam, ; message identifier
 LPARAM lParam ; message data
)
USER-DEFINED.LPFNBUTTON(
 ULONG ulUIParam,
 LPVOID lpvContext,
 ULONG cbEntryID,
 LPENTRYID lpSelection,
 ULONG ulFlags
)
MAPI32.LPropCompareProp(
 LPSPropValue lpSPropValueA,
 LPSPropValue lpSPropValueB
)
GDI32.LPtoDP(
 HDC hdc, ; handle to device context
 LPPOINT lpPoints, ; array of points
 int nCount ; count of points in array
)
KERNEL32.lstrcatA(
 LPTSTR lpString1, ; first string
 LPCTSTR lpString2 ; second string
)
KERNEL32.lstrcmpA(
 LPCTSTR lpString1, ; first string
 LPCTSTR lpString2 ; second string
)
KERNEL32.lstrcmpiA(
 LPCTSTR lpString1, ; first string
 LPCTSTR lpString2 ; second string
)
KERNEL32.lstrcpyA(
 LPTSTR lpString1, ; destination buffer
 LPCTSTR lpString2 ; string
)
KERNEL32.lstrcpynA(
 LPTSTR lpString1, ; destination buffer
 LPCTSTR lpString2, ; string
 int iMaxLength ; number of characters to copy
)
KERNEL32.lstrlenA(
 LPCTSTR lpString ; string to count
)
LZ32.LZClose(
 INT hFile ; LZ file handle
)
LZ32.LZCopy(
 INT hfSource, ; LZ file handle for source file
 INT hfDest ; LZ file handle for destination file
)
xxxx.LZDone(OBSOLETE - Use LZOpenFile)
)
LZ32.LZInit(
 INT hfSource ; handle to source file
)
LZ32.LZOpenFileA(
 LPTSTR lpFileName, ; file name
 LPOFSTRUCT lpReOpenBuf, ; file information buffer
 WORD wStyle ; action to take
)
LZ32.LZRead(
 INT hFile, ; LZ file handle to file
 LPSTR lpBuffer, ; buffer for bytes
 INT cbRead ; count of bytes
)
LZ32.LZSeek(
 INT hFile, ; handle to source file
 LONG lOffset, ; number of bytes to move
 INT iOrigin ; starting position
)
xxxx.LZStart(OBSOLETE - Use LZCopy)
)
MAKEDLLVERULL(
 WORD wMajorVersion,
 WORD wMinorVersion,
 WORD wBuild,
 WORD wQFE
)
COMCTL32.MakeDragList(
 HWND hLB
)
xxxx.MakeProcInstance(OBSOLETE)
)
USER32.MapDialogRect(
 HWND hDlg, ; handle to dialog box
 LPRECT lpRect ; dialog box coordinates
)
MAPI32.MAPIAddress(
 LHANDLE lhSession,
 ULONG ulUIParam,
 LPTSTR lpszCaption,
 ULONG nEditFields,
 LPTSTR lpszLabels,
 ULONG nRecips,
 lpMapiRecipDesc lpRecips,
 FLAGS flFlags,
 ULONG ulReserved,
 LPULONG lpnNewRecips,
 lpMapiRecipDesc FAR * lppNewRecips
)
MAPI32.MAPIAdminProfiles(
 ULONG ulFlags,
 LPPROFADMIN FAR * lppProfAdmin
)
MAPI32.MAPIAllocateBuffer(
 ULONG cbSize,
 LPVOID FAR * lppBuffer
)
MAPI32.MAPIAllocateMore(
 ULONG cbSize,
 LPVOID lpObject,
 LPVOID FAR * lppBuffer
)
MAPI32.MAPIDeInitIdle(VOID)
MAPIDeleteMail(
 LHANDLE lhSession,
 ULONG ulUIParam,
 LPTSTR lpszMessageID,
 FLAGS flFlags,
 ULONG ulReserved
)
MAPI32.MAPIDetails(
 LHANDLE lhSession,
 ULONG ulUIParam,
 lpMapiRecipDesc lpRecip,
 FLAGS flFlags,
 ULONG ulReserved
)
MAPI32.MAPIFindNext(
 LHANDLE lhSession,
 ULONG ulUIParam,
 LPTSTR lpszMessageType,
 LPTSTR lpszSeedMessageID,
 FLAGS flFlags,
 ULONG ulReserved,
 LPTSTR lpszMessageID
)
MAPI32.MAPIFreeBuffer(
 LPVOID lpBuffer
)
MAPI32.MAPIGetDefaultMalloc(VOID)
)
MAPI32.MAPIInitialize(
 LPVOID lpMapiInit
)
MAPI32.MAPIInitIdle(
 LPVOID lpvReserved
)
MAPI32.MAPILogoff (
 LHANDLE lhSession,
 ULONG ulUIParam,
 FLAGS flFlags,
 ULONG ulReserved
)
MAPI32.MAPILogon(
 ULONG ulUIParam,
 LPTSTR lpszProfileName,
 LPTSTR lpszPassword,
 FLAGS flFlags,
 ULONG ulReserved,
 LPLHANDLE lplhSession
)
MAPI32.MAPILogonEx(
 ULONG ulUIParam,
 LPTSTR lpszProfileName,
 LPTSTR lpszPassword,
 FLAGS flFlags,
 LPMAPISESSION FAR * lppSession
)
MAPI32.MAPIOpenFormMgr(
 LPMAPISESSION pSession,
 LPMAPIFORMMGR FAR * ppmgr
)
MAPI32.MAPIOpenLocalFormContainer(
 LPMAPIFORMCONTAINER FAR * ppfcnt
)
MAPI32.MAPIReadMail(
 LHANDLE lhSession,
 ULONG ulUIParam,
 LPTSTR lpszMessageID,
 FLAGS flFlags,
 ULONG ulReserved,
 lpMapiMessage FAR * lppMessage
)
MAPI32.MAPIResolveName(
 LHANDLE lhSession,
 ULONG ulUIParam,
 LPTSTR lpszName,
 FLAGS flFlags,
 ULONG ulReserved,
 lpMapiRecipDesc FAR * lppRecip
)
MAPI32.MAPISaveMail(
 LHANDLE lhSession,
 ULONG ulUIParam,
 lpMapiMessage lpMessage,
 FLAGS flFlags,
 ULONG ulReserved,
 LPTSTR lpszMessageID
)
MAPI32.MAPISendDocuments(
 ULONG ulUIParam,
 LPTSTR lpszDelimChar,
 LPTSTR lpszFullPaths,
 LPTSTR lpszFileNames,
 ULONG ulReserved
)
MAPI32.MAPISendMail(
 LHANDLE lhSession,
 ULONG ulUIParam,
 lpMapiMessage lpMessage,
 FLAGS flFlags,
 ULONG ulReserved
)
MAPI32.MAPIUninitialize(VOID)
)
xxxx.MapStorageSCode(
 SCODE StgSCode
)
xxxx.MapUserPhysicalPages(
 PVOID lpAddress, ; starting address of region
 ULONG_PTR NumberOfPages, ; size of physical memory
 PULONG_PTR UserPfnArray ; array of page frame numbers
)
xxxx.MapUserPhysicalPagesScatter(
 PVOID *VirtualAddresses, ; starting address of region
 ULONG_PTR NumberOfPages, ; size of physical memory
 PULONG_PTR PageArray ; array of values
)
KERNEL32.MapViewOfFile(
 HANDLE hFileMappingObject, ; handle to file-mapping object
 DWORD dwDesiredAccess, ; access mode
 DWORD dwFileOffsetHigh, ; high-order DWORD of offset
 DWORD dwFileOffsetLow, ; low-order DWORD of offset
 SIZE_T dwNumberOfBytesToMap ; number of bytes to map
)
KERNEL32.MapViewOfFileEx(
 HANDLE hFileMappingObject, ; handle to file-mapping object
 DWORD dwDesiredAccess, ; access mode
 DWORD dwFileOffsetHigh, ; high-order DWORD of offset
 DWORD dwFileOffsetLow, ; low-order DWORD of offset
 SIZE_T dwNumberOfBytesToMap, ; number of bytes to map
 LPVOID lpBaseAddress ; starting address
)
USER32.MapVirtualKeyA(
 UINT uCode, ; virtual-key code or scan code
 UINT uMapType ; translation to perform
)
USER32.MapVirtualKeyExA(
 UINT uCode, ; virtual-key code or scan code
 UINT uMapType, ; translation to perform
 HKL dwhkl ; input locale identifier
)
USER32.MapWindowPoints(
 HWND hWndFrom, ; handle to source window
 HWND hWndTo, ; handle to destination window
 LPPOINT lpPoints, ; array of points to map
 UINT cPoints ; number of points in array
)
GDI32.MaskBlt(
 HDC hdcDest, ; handle to destination DC
 int nXDest, ; x-coord of destination upper-left corner
 int nYDest, ; y-coord of destination upper-left corner
 int nWidth, ; width of source and destination
 int nHeight, ; height of source and destination
 HDC hdcSrc, ; handle to source DC
 int nXSrc, ; x-coord of upper-left corner of source
 int nYSrc, ; y-coord of upper-left corner of source
 HBITMAP hbmMask, ; handle to monochrome bit mask
 int xMask, ; horizontal offset into mask bitmap
 int yMask, ; vertical offset into mask bitmap
 DWORD dwRop ; raster operation code
)
COMCTL32.MenuHelp(
 UINT uMsg,
 WPARAM wParam,
 LPARAM lParam,
 HMENU hMainMenu,
 HINSTANCE hInst,
 HWND hwndStatus,
 LPUINT lpwIDs
)
USER32.MenuItemFromPoint(
 HWND hWnd, ; handle to window
 HMENU hMenu, ; handle to menu
 POINT ptScreen ; location to test
)
USER32.MessageBeep(
 UINT uType ; sound type
)
USER32.MessageBoxA(
 HWND hWnd, ; handle to owner window
 LPCTSTR lpText, ; text in message box
 LPCTSTR lpCaption, ; message box title
 UINT uType ; message box style
)
USER32.MessageBoxExA(
 HWND hWnd, ; handle to owner window
 LPCTSTR lpText, ; text in message box
 LPCTSTR lpCaption, ; message box title
 UINT uType, ; message box style
 WORD wLanguageId ; language identifier
)
USER32.MessageBoxIndirectA(
 CONST LPMSGBOXPARAMS lpMsgBoxParams ; message box parameters
)
USER-DEFINED.MessageProc(
 int code, ; hook code
 WPARAM wParam, ; not used
 LPARAM lParam ; message data
)
xxxx.MgmAddGroupMembershipEntry(
 HANDLE hProtocol,
 DWORD dwSourceAddr,
 DWORD dwSourceMask,
 DWORD dwGroupAddr,
 DWORD dwGroupMask,
 DWORD dwIfIndex,
 DWORD dwIfNextHopIPAddr,
 DWORD dwFlags
)
xxxx.MgmDeleteGroupMembershipEntry(
 HANDLE hProtocol,
 DWORD dwSourceAddr,
 DWORD dwSourceMask,
 DWORD dwGroupAddr,
 DWORD dwGroupMask,
 DWORD dwIfIndex,
 DWORD dwIfNextHopIPAddr,
 DWORD dwFlags
)
xxxx.MgmDeRegisterMProtocol(
 HANDLE hProtocol
)
xxxx.MgmGetFirstMfe(
 PDWORD pdwBufferSize,
 PBYTE pbBuffer,
 PDWORD pdwNumEntries
)
xxxx.MgmGetFirstMfeStats(
 PDWORD pdwBufferSize,
 PBYTE pbBuffer,
 PDWORD pdwNumEntries
)
xxxx.MgmGetMfe(
 PMIB_IPMCAST_MFE pimm,
 PDWORD pdwBufferSize,
 PBYTE pbBuffer
)
xxxx.MgmGetMfeStats(
 PMIB_IPMCAST_MFE pimm,
 PDWORD pdwBufferSize,
 PBYTE pbBuffer
)
xxxx.MgmGetNextMfe(
 PMIB_IPMCAST_MFE pimmStart,
 PDWORD pdwBufferSize,
 PBYTE pbBuffer,
 PDWORD pdwNumEntries
)
xxxx.MgmGetNextMfeStats(
 PMIB_IPMCAST_MFE pimmStart,
 PDWORD pdwBufferSize,
 PBYTE pbBuffer,
 PDWORD pdwNumEntries
)
xxxx.MgmGetProtocolOnInterface(
 DWORD dwIfIndex,
 DWORD dwIfNextHopAddr,
 PDWORD pdwIfProtocolId,
 PDWORD pdwIfComponentId
)
xxxx.MgmGroupEnumerationEnd(
 HANDLE hEnum
)
xxxx.MgmGroupEnumerationGetNext(
 HANDLE hEnum,
 PDWORD pdwBufferSize,
 PBYTE pbBuffer,
 PDWORD pdwNumEntries
)
xxxx.MgmGroupEnumerationStart(
 HANDLE hProtocol,
 MGM_ENUM_TYPES metEnumType,
 HANDLE *phEnumHandle
)
xxxx.MgmRegisterMProtocol(
 PROUTING_PROTOCOL_CONFIG prpiInfo,
 DWORD dwProtocolId,
 DWORD dwComponentId,
 HANDLE *phProtocol
)
xxxx.MgmReleaseInterfaceOwnership(
 HANDLE hProtocol,
 DWORD dwIfIndex,
 DWORD dwIfNextHopAddr
)
xxxx.MgmSetMfe(
 HANDLE hProtocol,
 PMIB_IPMCAST_MFE pmimm
)
xxxx.MgmTakeInterfaceOwnership(
 HANDLE hProtocol,
 DWORD dwIfIndex,
 DWORD dwIfNextHopAddr
)
USER-DEFINED.MibCreate(
 ULONG InputDataSize, ; size of the data for the request
 PVOID InputData ; address of the data for the request
)
USER-DEFINED.MibDelete(
 ULONG InputDataSize, ; size of the data for the request
 PVOID InputData ; address of the data for the request
)
USER-DEFINED.MibGet(
 ULONG InputDataSize, ; size of the data for the request
 PVOID InputData, ; address of the data for the request
 ULONG *OutputDataSize, ; size of the data returned
 PVOID OutputData ; address of data returned
)
USER-DEFINED.MibGetFirst(
 ULONG InputDataSize, ; size of the data for the request
 PVOID InputData, ; address of the data for the request
 ULONG *OutputDataSize, ; size of the data returned
 PVOID OutputData ; address of the data returned
)
USER-DEFINED.MibGetNext(
 ULONG InputDataSize, ; size of the data for the request
 PVOID InputData, ; address of the data for the request
 ULONG *OutputDataSize, ; size of the returned data
 PVOID OutputData ; address of the returned data
)
xxxx.MibGetTrapInfo(
 ULONG InputDataSize,
 PVOID InputData,
 PULONG OutputDataSize,
 PVOID OutputData
)
USER-DEFINED.MibSet(
 ULONG InputDataSize, ; size of the data for the request
 PVOID InputData ; address of the data for the request
)
xxxx.MibSetTrapInfo(
 HANDLE Event,
 ULONG InputDataSize,
 PVOID InputData,
 PULONG OutputDataSize,
 PVOID OutputData
)
xxxx.MIMEAssociationDialogA(
 HWND hwndParent,
 DWORD dwInFlags,
 LPCSTR pcszFile,
 LPCSTR pcszMIMEContentType,
 LPSTR pszAppBuf,
 UINT ucAppBufLen
)
xxxx.MLLoadLibrary(
 LPCTSTR lpLibFileName,
 HANDLE hFile,
 DWORD dwFlags,
 LPCTSTR lpComponent,
 BOOL bCrossCodePage
)
xxxx.ModifyMenuA(
 HMENU hMnu, ; handle to menu
 UINT uPosition, ; menu item to modify
 UINT uFlags, ; options
 UINT_PTR uIDNewItem, ; identifier, menu, or submenu
 LPCTSTR lpNewItem ; menu item content
)
GDI32.ModifyWorldTransform(
 HDC hdc, ; handle to device context
 CONST XFORM *lpXform, ; transformation data
 DWORD iMode ; modification mode
)
KERNEL32.Module32First(
 HANDLE hSnapshot,
 LPMODULEENTRY32 lpme
)
KERNEL32.Module32Next(
 HANDLE hSnapshot,
 LPMODULEENTRY32 lpme
)
USER-DEFINED.MonitorEnumProc(
 HMONITOR hMonitor, ; handle to display monitor
 HDC hdcMonitor, ; handle to monitor DC
 LPRECT lprcMonitor, ; monitor intersection rectangle
 LPARAM dwData ; data
)
USER32.MonitorFromPoint(
 POINT pt, ; point
 DWORD dwFlags ; determine return value
)
USER32.MonitorFromRect(
 LPCRECT lprc, ; rectangle
 DWORD dwFlags ; determine return value
)
USER32.MonitorFromWindow(
 HWND hwnd, ; handle to a window
 DWORD dwFlags ; determine return value
)
USER32.mouse_event(
 DWORD dwFlags, ; motion and click options
 DWORD dx, ; horizontal position or change
 DWORD dy, ; vertical position or change
 DWORD dwData, ; wheel movement
 ULONG_PTR dwExtraInfo ; application-defined information
)
USER-DEFINED.MouseProc(
 int nCode, ; hook code
 WPARAM wParam, ; message identifier
 LPARAM lParam ; mouse coordinates
)
KERNEL32.MoveFileA(
 LPCTSTR lpExistingFileName, ; file name
 LPCTSTR lpNewFileName ; new file name
)
KERNEL32.MoveFileExA(
 LPCTSTR lpExistingFileName, ; file name
 LPCTSTR lpNewFileName, ; new file name
 DWORD dwFlags ; move options
)
KERNEL32.MoveFileWithProgressA(
 LPCTSTR lpExistingFileName, ; file name
 LPCTSTR lpNewFileName, ; new file name
 LPPROGRESS_ROUTINE lpProgressRoutine, ; callback function
 LPVOID lpData, ; parameter for callback
 DWORD dwFlags ; move options
)
xxxx.MoveMemory(
 PVOID Destination, ; move destination
 CONST VOID *Source, ; block to move
 SIZE_T Length ; size of block to move
)
GDI32.MoveToEx(
 HDC hdc, ; handle to device context
 int X, ; x-coordinate of new current position
 int Y, ; y-coordinate of new current position
 LPPOINT lpPoint ; old current position
)
USER32.MoveWindow(
 HWND hWnd, ; handle to window
 int X, ; horizontal position
 int Y, ; vertical position
 int nWidth, ; width
 int nHeight, ; height
 BOOL bRepaint ; repaint option
)
USER-DEFINED.MprAdminAcceptNewConnection(
 RAS_CONNECTION_0 *pRasConnection0, ; struct that describes connection
 RAS_CONNECTION_1 *pRasConnection1 ; struct that describes connection
)
xxxx.MprAdminAcceptNewConnection2(
 RAS_CONNECTION_0 *pRasConnection0,
 RAS_CONNECTION_1 *pRasConnection1,
 RAS_CONNECTION_2 *pRasConnection2
)
USER-DEFINED.MprAdminAcceptNewLink(
 RAS_PORT_0 *pRasPort0, ; struct that describes the port
 RAS_PORT_1 *pRasPort1 ; struct that describes the port
)
MPRAPI.MprAdminBufferFree(
 LPVOID pBuffer ; memory buffer to free
)
MPRAPI.MprAdminConnectionClearStats(
 RAS_SERVER_HANDLE hRasServer, ; handle to server
 HANDLE hRasConnection ; handle to the connection
)
MPRAPI.MprAdminConnectionEnum(
 RAS_SERVER_HANDLE hRasServer, ; handle to the server
 DWORD dwLevel, ; must be zero, one, or two
 LPBYTE *lplpbBuffer, ; pointer to array of connection structs
 DWORD dwPrefMaxLen, ; maximum preferred length of returned data
 LPDWORD lpdwEntriesRead, ; number of connections enumerated
 LPDWORD lpdwTotalEntries, ; number of connections that could've been enumerated
 LPDWORD lpdwResumeHandle ; handle with which to resume enumeration
)
MPRAPI.MprAdminConnectionGetInfo(
 RAS_SERVER_HANDLE hRasServer, ; handle to server
 DWORD dwLevel, ; level of info returned
 HANDLE hConnection, ; handle to connection
 LPBYTE *lplpbBuffer ; pointer to returned info
)
USER-DEFINED.MprAdminConnectionHangupNotification(
 RAS_CONNECTION_0 *pRasConnection0, ; struct that describes connection
 RAS_CONNECTION_1 *pRasConnection1 ; struct that describes connection
)
xxxx.MprAdminConnectionHangupNotification2(
 RAS_CONNECTION_0 *pRasConnection0,
 RAS_CONNECTION_1 *pRasConnection1,
 RAS_CONNECTION_2 *pRasConnection2
)
xxxx.MprAdminDeregisterConnectionNotification(
 MPR_SERVER_HANDLE hMprServer, ; handle to server
 HANDLE hEventNotification ; handle to event
)
MPRAPI.MprAdminGetErrorString(
 DWORD dwError, ; router error code
 LPWSTR *lplpwsErrorString ; descriptive text for error
)
USER-DEFINED.MprAdminGetIpAddressForUser(
 WCHAR *lpwszUserName, ; pointer to username
 WCHAR *lpwszPortName, ; pointer to port name
 DWORD *lpdwIpAddress, ; pointer to IP address
 BOOL *bNotifyRelease ; notify DLL when user disconnects
)
MPRAPI.MprAdminGetPDCServer(
 const WCHAR *lpwsDomainName, ; pointer to domain name
 const WCHAR *lpwsServerName, ; pointer to server name
 LPWSTR lpwsPDCName ; pointer to buffer to receive name of server with UAS
)
MPRAPI.MprAdminInterfaceConnect(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 HANDLE hInterface, ; handle to interface
 HANDLE hEvent, ; event to signal when connection attempt is complete
 BOOL fSynchronous ; flag to control synchronous versus asychronous operation
)
MPRAPI.MprAdminInterfaceCreate(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 DWORD dwLevel, ; level of information provided
 LPBYTE lpBuffer, ; info that describes interface
 HANDLE *phInterface ; handle to the interface
)
MPRAPI.MprAdminInterfaceDelete(
 MPR_SERVER_HANDLE hMprServer, ; handle to the router
 HANDLE hInterface ; handle to the interface
)
xxxx.MprAdminInterfaceDeviceGetInfo(
 MPR_SERVER_HANDLE hMprServer,
 HANDLE hInterface,
 DWORD dwIndex,
 DWORD dwLevel,
 LPBYTE *lplpBuffer
)
xxxx.MprAdminInterfaceDeviceSetInfo(
 MPR_SERVER_HANDLE hMprServer,
 HANDLE hInterface,
 DWORD dwIndex,
 DWORD dwLevel,
 LPBYTE lplpBuffer
)
MPRAPI.MprAdminInterfaceDisconnect(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 HANDLE hInterface ; handle to interface
)
MPRAPI.MprAdminInterfaceEnum(
 MPR_SERVER_HANDLE hMprServer, ; handle to the router
 DWORD dwLevel, ; level of information provided
 LPBYTE *lplpbBuffer, ; array of information structures
 DWORD dwPrefMaxLen, ; maximum length of data to return
 HANDLE lpdwEntriesRead, ; number of interfaces enumerated
 HANDLE lpdwTotalEntries, ; number of interfaces that could have been enumerated
 LPDWORD lpdwResumeHandle ; handle for continuing the enumeration
)
xxxx.MprAdminInterfaceGetCredentials(
 LPWSTR lpwsServer, ; string containing name of router
 LPWSTR lpwsInterfaceName, ; string containing name of interface
 LPWSTR lpwsUserName, ; string to receive user name
 LPWSTR lpwsPassword, ; string to receive password
 LPWSTR lpwsDomainName ; string to receive domain name
)
xxxx.MprAdminInterfaceGetCredentialsEx(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 HANDLE hInterface, ; handle to interface
 DWORD dwLevel, ; format of credentials
 LPBYTE *lplpbBuffer ; retrieved credentials
)
MPRAPI.MprAdminInterfaceGetHandle(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 LPWSTR lpwsInterfaceName, ; name of interface
 HANDLE *phInterface, ; handle to interface
 BOOL fIncludeClientInterfaces ; toggles inclusion of client interfaces
)
xxxx.MprAdminInterfaceGetInfo(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 HANDLE hInterface, ; handle to interface
 DWORD dwLevel, ; level of information
 LPBYTE *lplpbBuffer ; buffer for information
)
MPRAPI.MprAdminInterfaceQueryUpdateResult(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 HANDLE hInterface, ; handle to interface
 DWORD dwTransportId, ; transport/router manager ID
 LPDWORD lpdwUpdateResult ; result of last route update
)
xxxx.MprAdminInterfaceSetCredentials(
 LPWSTR lpwsServer, ; string containing name of router
 LPWSTR lpwsInterfaceName, ; string containing name of interface
 LPWSTR lpwsUserName, ; string containing user name
 LPWSTR lpwsDomainName, ; string containing domain name
 LPWSTR lpwsPassword ; string containing password
)
xxxx.MprAdminInterfaceSetCredentialsEx(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 HANDLE hInterface, ; handle to interface
 DWORD dwLevel, ; format of credentials
 LPBYTE lpbBuffer ; new credentials
)
xxxx.MprAdminInterfaceSetInfo(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 HANDLE hInterface, ; handle to interface
 DWORD dwLevel, ; level of information
 LPBYTE lpbBuffer ; buffer of information
)
MPRAPI.MprAdminInterfaceTransportAdd(
 MPR_SERVER_HANDLE hMprServer, ; handle to the router
 HANDLE hInterface, ; handle to the interface
 DWORD dwTransportId, ; transport/router manager ID
 LPBYTE pInterfaceInfo, ; interface information
 DWORD dwInterfaceInfoSize ; size of interface information
)
MPRAPI.MprAdminInterfaceTransportGetInfo(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 HANDLE hInterface, ; handle to interface
 DWORD dwTransportId, ; transport/router manager ID
 LPBYTE *ppInterfaceInfo, ; buffer to receive interface information
 LPDWORD lpdwInterfaceInfoSize ; size of interface information returned
)
MPRAPI.MprAdminInterfaceTransportRemove(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 HANDLE hInterface, ; handle to interface
 DWORD dwTransportId ; transport/router manager ID
)
MPRAPI.MprAdminInterfaceTransportSetInfo(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 HANDLE hInterface, ; handle to interface
 DWORD dwTransportId, ; identifier for the transport
 LPBYTE pInterfaceInfo, ; interface information
 DWORD dwInterfaceInfoSize ; size of interface information
)
xxxx.MprAdminInterfaceUpdatePhonebookInfo(
 MPR_SERVER_HANDLE hMprServer, ; handle to the router
 HANDLE hInterface ; handle to the interface
)
MPRAPI.MprAdminInterfaceUpdateRoutes(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 HANDLE hInterface, ; handle to interface
 DWORD dwTransportId, ; identifies the router manager
 HANDLE hEvent ; event to signal when update complete
)
MPRAPI.MprAdminIsServiceRunning(
 LPWSTR lpwsServerName ; name of machine to query
)
USER-DEFINED.MprAdminLinkHangupNotification(
 RAS_PORT_0 *pRasPort0, ; struct that describes the port
 RAS_PORT_1 *pRasPort1 ; struct that describes the port
)
MPRAPI.MprAdminMIBBufferFree(
 LPVOID pBuffer ; address of memory to free
)
MPRAPI.MprAdminMIBEntryCreate(
 MIB_SERVER_HANDLE hMibServer, ; handle to router
 DWORD dwTransportId, ; transport/router manager ID
 DWORD dwRoutingPid, ; routing protocol ID
 LPVOID lpEntry, ; opaque data structure
 DWORD dwEntrySize ; size of opaque data structure
)
MPRAPI.MprAdminMIBEntryDelete(
 MIB_SERVER_HANDLE hMibServer, ; handle to router
 DWORD dwTransportId, ; transport/router manager ID
 DWORD dwRoutingPid, ; routing protocol ID
 LPVOID lpEntry, ; opaque data structure
 DWORD dwEntrySize ; size of opaque data structure
)
MPRAPI.MprAdminMIBEntryGet(
 MIB_SERVER_HANDLE hMibServer, ; handle to router
 DWORD dwTransportId, ; transport/router manager ID
 DWORD dwRoutingPid, ; routing protocol ID
 LPVOID lpInEntry, ; address of data to identify variable
 DWORD dwInEntrySize, ; size of data to identify variable
 LPVOID *lplpOutEntry, ; address of output data
 LPDWORD lpdwOutEntrySize ; size of output data
)
MPRAPI.MprAdminMIBEntryGetFirst(
 MIB_SERVER_HANDLE hMibServer, ; handle to router
 DWORD dwTransportId, ; transport/router manager ID
 DWORD dwRoutingPid, ; routing protocol ID
 LPVOID lpInEntry, ; address of data to identify variable
 DWORD dwInEntrySize, ; size of data to identify variable
 LPVOID *lplpOutEntry, ; address of output data
 LPDWORD lpdwOutEntrySize ; size of output data
)
MPRAPI.MprAdminMIBEntryGetNext(
 MIB_SERVER_HANDLE hMibServer, ; handle to router
 DWORD dwTransportId, ; transport/router manager ID
 DWORD dwRoutingPid, ; routing protocol ID
 LPVOID lpInEntry, ; address of data to identify variable
 DWORD dwInEntrySize, ; size of data to identify variable
 LPVOID *lplpOutEntry, ; address of output data
 LPDWORD lpdwOutEntrySize ; size of output data
)
MPRAPI.MprAdminMIBEntrySet(
 MIB_SERVER_HANDLE hMibServer, ; handle to router
 DWORD dwTransportId, ; transport/router manager ID
 DWORD dwRoutingPid, ; routing protocol ID
 LPVOID lpEntry, ; opaque data structure
 DWORD dwEntrySize ; size of opaque data structure
)
xxxx.MprAdminMIBGetTrapInfo(
 MIB_SERVER_HANDLE hMibServer,
 DWORD dwTransportId,
 DWORD dwRoutingPid,
 LPVOID lpInData,
 DWORD dwInDataSize,
 LPVOID *lplpOutData,
 LPDWORD lpdwOutDataSize
)
MPRAPI.MprAdminMIBServerConnect(
 LPWSTR lpwsServerName, ; name of router
 MIB_SERVER_HANDLE *phMibServer ; handle to router
)
MPRAPI.MprAdminMIBServerDisconnect(
 MIB_SERVER_HANDLE hMibServer ; handle to router
)
xxxx.MprAdminMIBSetTrapInfo(
 DWORD dwTransportId,
 DWORD dwRoutingPid,
 HANDLE hEvent,
 LPVOID lpInData,
 DWORD dwInDataSize,
 LPVOID *lplpOutData,
 LPDWORD lpdwOutDataSize
)
MPRAPI.MprAdminPortClearStats(
 RAS_SERVER_HANDLE hRasServer, ; handle to the server
 HANDLE hPort ; handle to the port
)
MPRAPI.MprAdminPortDisconnect(
 RAS_SERVER_HANDLE hRasServer, ; handle to the server
 HANDLE hPort ; handle to the port
)
MPRAPI.MprAdminPortEnum(
 RAS_SERVER_HANDLE hRasServer, ; handle to the server
 DWORD dwLevel, ; must be zero
 HANDLE hConnection, ; handle to connection
 LPBYTE *lplpbBuffer, ; pointer to array of port structs
 DWORD dwPrefMaxLen, ; maximum preferred length of returned data
 LPDWORD lpdwEntriesRead, ; number of ports enumerated
 LPDWORD lpdwTotalEntries, ; number of ports that could have been enumerated
 LPDWORD lpdwResumeHandle ; handle with which to resume enumeration
)
MPRAPI.MprAdminPortGetInfo(
 RAS_SERVER_HANDLE hRasServer, ; handle to the server
 DWORD dwLevel, ; level of info returned
 HANDLE hPort, ; handle to port
 LPBYTE *lplpbBuffer ; pointer returned data
)
MPRAPI.MprAdminPortReset(
 RAS_SERVER_HANDLE hRasServer, ; handle to the server
 HANDLE hPort ; handle to the port
)
xxxx.MprAdminRegisterConnectionNotification(
 MPR_SERVER_HANDLE hMprServer, ; handle to server
 HANDLE hEventNotification ; handle to event
)
USER-DEFINED.MprAdminReleaseIpAddress(
 WCHAR *lpwszUserName, ; pointer to username
 WCHAR *lpwszPortName, ; pointer to port name
 DWORD *lpdwIpAddress ; pointer to IP address
)
xxxx.MprAdminSendUserMessage(
 HANDLE hConnection, ; handle to connection
 LPWSTR lpwszMessage ; pointer to message
)
MPRAPI.MprAdminServerConnect(
 LPWSTR lpwsServerName, ; name of router
 MPR_SERVER_HANDLE *phMprServer ; handle to router
)
MPRAPI.MprAdminServerDisconnect(
 MPR_SERVER_HANDLE hMprServer ; handle to router
)
MPRAPI.MprAdminServerGetInfo(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 DWORD dwLevel, ; level of information requested
 LPBYTE *lplpbBuffer ; MPR_SERVER_0 structure
)
xxxx.MprAdminTransportCreate(
 MPR_SERVER_HANDLE hMprServer,
 DWORD dwTransportId,
 LPWSTR lpwsTransportName,
 LPBYTE pGlobalInfo,
 DWORD dwGlobalInfoSize,
 LPBYTE pClientInterfaceInfo,
 DWORD dwClientInterfaceInfoSize,
 LPWSTR lpwsDLLPath
)
MPRAPI.MprAdminTransportGetInfo(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 DWORD dwTransportId, ; identifies the transport
 LPBYTE *ppGlobalInfo, ; buffer to receive global information for transport
 LPDWORD lpdwGlobalInfoSize, ; size of global information returned
 LPBYTE *ppClientInterfaceInfo, ; buffer to receive client interface information
 LPDWORD lpdwClientInterfaceInfoSize ; size of client interface information returned
)
MPRAPI.MprAdminTransportSetInfo(
 MPR_SERVER_HANDLE hMprServer, ; handle to router
 DWORD dwTransportId, ; identifies the transport
 LPBYTE pGlobalInfo, ; global information for transport
 DWORD dwGlobalInfoSize, ; size of global information
 LPBYTE pClientInterfaceInfo, ; information for client interfaces
 DWORD dwClientInterfaceInfoSize ; size of information for client interfaces
)
MPRAPI.MprAdminUserGetInfo(
 const WCHAR *lpwsServerName, ; name of PDC or BDC with UAS
 const WCHAR *lpwsUserName, ; name of user
 DWORD dwLevel, ; must be zero
 LPBYTE lpbBuffer ; RAS_USER_0 structure
)
MPRAPI.MprAdminUserSetInfo(
 const WCHAR *lpwsServerName, ; name of PDC or BDC with UAS
 const WCHAR *lpwsUserName, ; name of user
 DWORD dwLevel, ; must be zero
 const LPBYTE lpbBuffer ; RAS_USER_0 structure
)
MPRAPI.MprConfigBufferFree(
 LPVOID pBuffer ; address of memory buffer to free
)
xxxx.MprConfigGetFriendlyName(
 HANDLE hMprConfig, ; handle to router configuration
 PWCHAR pszGuidName, ; GUID name for the interface
 PWCHAR pszBuffer, ; buffer to receive friendly name
 DWORD dwBufferSize ; size of buffer passed in
)
xxxx.MprConfigGetGuidName(
 HANDLE hMprConfig, ; handle to router configuration
 PWCHAR pszFriendlyName, ; friendly name for the interface
 PWCHAR pszBuffer, ; buffer to receive GUID name
 DWORD dwBufferSize ; size of buffer passed in
)
MPRAPI.MprConfigInterfaceCreate(
 HANDLE hMprConfig, ; handle to the router configuration
 DWORD dwLevel, ; level of information requested
 LPBYTE lpbBuffer, ; MPR_INTERFACE_0 structure
 HANDLE *phRouterInterface ; handle to the interface configuration
)
MPRAPI.MprConfigInterfaceDelete(
 HANDLE hMprConfig, ; handle to the router configuration
 HANDLE hRouterInterface ; handle to the interface configuration
)
MPRAPI.MprConfigInterfaceEnum(
 HANDLE hMprConfig, ; handle to the router configuration
 DWORD dwLevel, ; level of information requested
 LPBYTE *lplpBuffer, ; array of MPR_INTERFACE_0 structures
 DWORD dwPrefMaxLen, ; maximum length of data to return
 LPDWORD lpdwEntriesRead, ; number of entries enumerated
 LPDWORD lpdwTotalEntries, ; number of entries that could've been enumerated
 LPDWORD lpdwResumeHandle ; handle for continuing the enumeration
)
MPRAPI.MprConfigInterfaceGetHandle(
 HANDLE hMprConfig, ; handle to the router configuration
 LPWSTR lpwsInterfaceName, ; Unicode string containing name of interface
 HANDLE *phRouterInterface ; handle to the specified interface
)
MPRAPI.MprConfigInterfaceGetInfo(
 HANDLE hMprConfig, ; handle to the router configuration
 HANDLE hRouterInterface, ; handle to the interface configuration
 DWORD dwLevel, ; level of information requested
 LPBYTE *lplpBuffer, ; MPR_INTERFACE_0 structure
 LPDWORD lpdwBufferSize ; size of returned data
)
MPRAPI.MprConfigInterfaceSetInfo(
 HANDLE hMprConfig, ; handle to the router configuration
 HANDLE hRouterInterface, ; handle to the interface configuration
 DWORD dwLevel, ; level of the information requested
 LPBYTE lpBuffer ; MPR_INTERFACE_0 structure
)
MPRAPI.MprConfigInterfaceTransportAdd(
 HANDLE hMprConfig, ; handle to the router configuration
 HANDLE hRouterInterface, ; handle to the interface configuration
 DWORD dwTransportId, ; identifier of the transport/router manager
 LPWSTR lpwsTransportName, ; transport name
 LPBYTE pInterfaceInfo, ; interface information
 DWORD dwInterfaceInfoSize, ; size of interface information
 HANDLE *phRouterIfTransport ; handle to transport configuration
)
MPRAPI.MprConfigInterfaceTransportEnum(
 HANDLE hMprConfig, ; handle to the router configuration
 HANDLE hRouterInterface, ; handle to the interface configuration
 DWORD dwLevel, ; level of information requested
 LPBYTE *lplpBuffer, ; array of MPR_IFTRANSPORT_0 structures
 DWORD dwPrefMaxLen, ; maximum length of data to return
 LPDWORD lpdwEntriesRead, ; number of entries enumerated
 LPDWORD lpdwTotalEntries, ; number of entries that could've been enumerated
 LPDWORD lpdwResumeHandle ; handle for continuing the enumeration
)
MPRAPI.MprConfigInterfaceTransportGetHandle(
 HANDLE hMprConfig, ; handle to the router configuration
 HANDLE hRouterInterface, ; handle to the interface configuration
 DWORD dwTransportId, ; identifier of the transport configuration
 HANDLE *phRouterIfTransport ; handle to the transport configuration
)
MPRAPI.MprConfigInterfaceTransportGetInfo(
 HANDLE hMprConfig, ; handle to the router configuration
 HANDLE hRouterInterface, ; handle to the interface configuration
 HANDLE hRouterIfTransport, ; handle to the transport configuration
 LPBYTE *ppInterfaceInfo, ; configuration information for interface and interface
 LPDWORD lpdwInterfaceInfoSize ; size of interface transport information
)
MPRAPI.MprConfigInterfaceTransportRemove(
 HANDLE hMprConfig, ; handle to the router configuration
 HANDLE hRouterInterface, ; handle to the interface configuration
 HANDLE hRouterIfTransport ; handle to the transport configuration
)
MPRAPI.MprConfigInterfaceTransportSetInfo(
 HANDLE hMprConfig, ; handle to the router configuration
 HANDLE hRouterInterface, ; handle to the interface configuration
 HANDLE hRouterIfTransport, ; handle to the transport configuration
 LPBYTE pInterfaceInfo, ; configuration information for transport and interface
 DWORD dwInterfaceInfoSize ; size of configuration information
)
xxxx.MprConfigServerBackup (
 HANDLE hMprConfig, ; handle to the router configuration
 LPWSTR lpwsPath ; path to backup directory
)
MPRAPI.MprConfigServerConnect(
 LPWSTR lpwsServerName, ; address of server name
 HANDLE *phMprConfig ; address of router configuration handle
)
MPRAPI.MprConfigServerDisconnect(
 HANDLE hMprConfig ; handle to router configuration
)
MPRAPI.MprConfigServerGetInfo(
 HANDLE hMprConfig, ; handle to the router configuration
 DWORD dwLevel, ; level of information
 LPBYTE *lplpBuffer ; buffer to receive information
)
xxxx.MprConfigServerInstall(
 DWORD dwLevel,
 PVOID pBuffer
)
MPRAPI.MprConfigServerRestore(
 HANDLE hMprConfig, ; handle to the router configuration
 LPWSTR lpwsPath ; path to backup directory
)
MPRAPI.MprConfigTransportCreate(
 HANDLE hMprConfig, ; handle to the router configuration
 DWORD dwTransportId, ; identifier of the transport/router manager
 LPWSTR lpwsTransportName, ; address of the transport name
 LPBYTE pGlobalInfo, ; address of the global info
 DWORD dwGlobalInfoSize, ; size of the global info buffer
 LPBYTE pClientInterfaceInfo, ; address of info for client routers
 DWORD dwClientInterfaceInfoSize, ; size of the client info buffer
 LPWSTR lpwsDLLPath, ; address of the router manager DLL name
 HANDLE phRouterTransport ; handle to the transport configuration
)
MPRAPI.MprConfigTransportDelete(
 HANDLE hMprConfig, ; handle to the router configuration
 HANDLE hRouterTransport ; handle to the transport configuration
)
MPRAPI.MprConfigTransportEnum(
 HANDLE hMprConfig, ; handle to the router configuration
 DWORD dwLevel, ; level of information requested
 LPBYTE *lplpBuffer, ; array of MPR_TRANSPORT_0 structures
 DWORD dwPrefMaxLen, ; maximum length of data to return
 LPDWORD lpdwEntriesRead, ; number of entries enumerated
 LPDWORD lpdwTotalEntries, ; number of entries that could've been enumerated
 LPDWORD lpdwResumeHandle ; handle for continuing the enumeration
)
MPRAPI.MprConfigTransportGetHandle(
 HANDLE hMprConfig, ; handle to the router configuration
 DWORD dwTransportId, ; transport identifier
 HANDLE *phRouterTransport ; handle to the transport's configuration
)
MPRAPI.MprConfigTransportGetInfo(
 HANDLE hMprConfig, ; handle to the router configuration
 HANDLE hRouterTransport, ; handle to the transport configuration
 LPBYTE *ppGlobalInfo, ; global information for the transport
 LPDWORD lpdwGlobalInfoSize, ; size of global information
 LPBYTE *ppClientInterfaceInfo, ; interface information for client routers
 LPDWORD lpdwClientInterfaceInfoSize, ; size of interface information
 LPWSTR *lplpwsDLLPath ; name of router manager DLL
)
MPRAPI.MprConfigTransportSetInfo(
 HANDLE hMprConfig, ; handle to the router configuration
 HANDLE hRouterTransport, ; handle to the transport configuration
 LPBYTE pGlobalInfo, ; global information for the transport
 DWORD dwGlobalInfoSize, ; size of global information
 LPBYTE pClientInterfaceInfo, ; interface information for client routers
 DWORD dwClientInterfaceInfoSize, ; size of interface information
 LPWSTR lpwsDLLPath ; name of router manager DLL
)
xxxx.MprInfoBlockAdd(
 LPVOID lpHeader, ; pointer to existing header
 DWORD dwInfoType, ; info type of new block
 DWORD dwItemSize, ; size of items in new block
 DWORD dwItemCount, ; number of items in new block
 LPBYTE lpItemData, ; data for new block
 LPVOID *lplpNewHeader ; new header (incl. new block)
)
xxxx.MprInfoBlockFind(
 LPVOID lpHeader, ; info header to search
 DWORD dwInfoType, ; block type to search for
 LPDWORD lpdwItemSize, ; size of data items in found block
 LPDWORD lpdwItemCount, ; number of data items in found block
 LPBYTE *lplpItemData ; data in found block
)
xxxx.MprInfoBlockQuerySize(
 LPVOID lpHeader
)
xxxx.MprInfoBlockRemove(
 LPVOID lpHeader, ; pointer to existing header
 DWORD dwInfoType, ; info type of block to remove
 LPVOID *lplpNewHeader ; new header with block removed
)
xxxx.MprInfoBlockSet(
 LPVOID lpHeader, ; pointer to existing header
 DWORD dwInfoType, ; info type of block to modify
 DWORD dwItemSize, ; new size of items in the modified block
 DWORD dwItemCount, ; new number of items in the modified block
 LPBYTE lpItemData, ; new data for the modified block
 LPVOID *lplpNewHeader ; new header (incl. modified block)
)
xxxx.MprInfoCreate(
 DWORD dwVersion, ; version of info header
 LPVOID *lplpNewHeader ; pointer to new info header
)
xxxx.MprInfoDelete(
 LPVOID lpHeader ; pointer to header to delete
)
xxxx.MprInfoDuplicate(
 LPVOID lpHeader, ; pointer to existing info header
 LPVOID *lplpNewHeader ; pointer to pointer to duplicate
)
xxxx.MprInfoRemoveAll(
 LPVOID lpHeader,
 LPVOID *lplpNewHeader
)
xxxx.MQBeginTransaction(
 ITransaction **ppTransaction
)
xxxx.MQCloseCursor(
 HANDLE hCursor
)
xxxx.MQCloseQueue(
 QUEUEHANDLE hQueue
)
xxxx.MQCreateCursor(
 QUEUEHANDLE hQueue,
 PHANDLE phCursor
)
xxxx.MQCreateQueue(
 PSECURITY_DESCRIPTOR pSecurityDescriptor,
 MQQUEUEPROPS *pQueueProps,
 LPWSTR lpwcsFormatName,
 LPDWORD lpdwFormatNameLength
)
xxxx.MQDeleteQueue(
 LPCWSTR lpwcsFormatName
)
xxxx.MQFreeMemory(
 PVOID pvMemory
)
xxxx.MQFreeSecurityContext(
 HANDLE hSecurityContext
)
xxxx.MQGetMachineProperties(
 LPCWSTR lpwcsMachineName,
 const GUID *pguidMachineID,
 MQQMPROPS *pQMProps
)
xxxx.MQGetOverlappedResult(
LPOVERLAPPED lpOverlapped
)
xxxx.MQGetPrivateComputerInformation(
 LPCWSTR lpwcsComputerName,
 MQPRIVATEPROPS *pPrivateProps
)
xxxx.MQGetQueueProperties(
 LPCWSTR lpwcsFormatName,
 MQQUEUEPROPS *pQueueProps
)
xxxx.MQGetQueueSecurity(
 LPCWSTR lpwcsFormatName,
 SECURITY_INFORMATION SecurityInformation,
 PSECURITY_DESCRIPTOR pSecurityDescriptor,
 DWORD nLength,
 LPDWORD lpnLengthNeeded
)
xxxx.MQGetSecurityContext(
 LPVOID lpCertBuffer,
 DWORD dwCertBufferLength,
 HANDLE *hSecurityContext
)
xxxx.MQHandleToFormatName(
 QUEUEHANDLE hQueue,
 LPWSTR lpwcsFormatName,
 LPDWORD lpdwCount
)
xxxx.MQInstanceToFormatName(
 GUID *pGUID,
 LPWSTR lpwcsFormatName,
 LPDWORD lpdwCount
)
xxxx.MQLocateBegin(
 LPCWSTR lpwcsContext,
 MQRESTRICTION *pRestriction,
 MQCOLUMNSET *pColumns,
 MQSORTSET *pSort,
 PHANDLE phEnum
)
xxxx.MQLocateEnd(
 HANDLE hEnum
)
xxxx.MQLocateNext(
 HANDLE hEnum,
 DWORD *pcProps,
 MQPROPVARIANT aPropVar[]
)
xxxx.MQMailComposeBody(
 LPMQMailEMail pEMail,
 ULONG FAR *pcbBuffer,
 LPBYTE FAR ppbBuffer
)
xxxx.MQMailFreeMemory(
 LPVOID lpBuffer
)
xxxx.MQMailParseBody(
 ULONG cbBuffer,
 LPBYTE FAR *pbBuffer,
 LPMQMailEMail FAR *ppEMail
)
xxxx.MQOpenQueue(
 LPCWSTR lpwcsFormatName,
 DWORD dwAccess,
 DWORD dwShareMode,
 QUEUEHANDLE phQueue
)
xxxx.MQPathNameToFormatName(
 LPCWSTR lpwcsPathName,
 LPWSTR lpwcsFormatName,
 LPDWORD lpdwCount
)
xxxx.MQReceiveMessage(
 QUEUEHANDLE hSource,
 DWORD dwTimeout,
 DWORD dwAction,
 MQMSGPROPS pMessageProps,
 LPOVERLAPPED lpOverlapped,
 PMQRECEIVECALLBACK fnReceiveCallback,
 HANDLE hCursor,
 Transaction *pTransaction
)
xxxx.MQReceiveMessageByLookupId(
 QUEUEHANDLE hSource,
 ULONGLONG ullLookupId
 DWORD dwLookupAction,
 MQMSGPROPS* pMessageProps,
 LPOVERLAPPED lpOverlapped,
 PMQRECEIVECALLBACK fnReceiveCallback,
 Transaction *pTransaction
)
xxxx.MQRegisterCertificate(
 DWORD dwFlags,
 PVOID lpCertBuffer,
 DWORD dwCertBufferLength
)
xxxx.MQSendMessage(
 QUEUEHANDLE hDestinationQueue,
 MQMSGPROPS *pMessageProps,
 ITransaction *pTransaction
)
xxxx.MQSetQueueProperties(
 LPCWSTR lpwcsFormatName,
 MQQUEUEPROPS *pQueueProps
)
xxxx.MQSetQueueSecurity(
 LPCWSTR lpwcsFormatName,
 SECURITY_INFORMATION SecurityInformation,
 PSECURITY_DESCRIPTOR pSecurityDescriptor
)
USER-DEFINED.MSGCALLRELEASE(
 ULONG ulCallerData,
 LPMESSAGE lpMessage
)
USER-DEFINED.MSGSERVICEENTRY(
 HINSTANCE hInstance,
 LPMALLOC lpMalloc,
 LPMAPISUP lpMAPISup,
 ULONG ulUIParam,
 ULONG ulFlags,
 ULONG ulContext,
 ULONG cValues,
 LPSPropValue lpProps,
 LPPROVIDERADMIN lpProviderAdmin,
 LPMAPIERROR FAR * lppMapiError
)
USER32.MsgWaitForMultipleObjects(
 DWORD nCount, ; number of handles in array
 CONST HANDLE pHandles, ; object-handle array
 BOOL fWaitAll, ; wait option
 DWORD dwMilliseconds, ; time-out interval
 DWORD dwWakeMask ; input-event type
)
USER32.MsgWaitForMultipleObjectsEx(
 DWORD nCount, ; number of handles in array
 CONST HANDLE pHandles, ; object-handle array
 DWORD dwMilliseconds, ; time-out interval
 DWORD dwWakeMask, ; input-event type
 DWORD dwFlags ; wait options
)
USER-DEFINED.MSProviderInit(
 HINSTANCE hInstance,
 LPMALLOC lpMalloc,
 LPALLOCATEBUFFER lpAllocateBuffer,
 LPALLOCATEMORE lpAllocateMore,
 LPFREEBUFFER lpFreeBuffer,
 ULONG ulFlags,
 ULONG ulMAPIVer,
 ULONG FAR * lpulProviderVer,
 LPMSPROVIDER FAR * lppMSProvider
)
KERNEL32.MultiByteToWideChar(
 UINT CodePage, ; code page
 DWORD dwFlags, ; character-type options
 LPCSTR lpMultiByteStr, ; string to map
 int cbMultiByte, ; number of bytes in string
 LPWSTR lpWideCharStr, ; wide-character buffer
 int cchWideChar ; size of buffer
)
NETAPI32 (NT) OR SVRAPI (95).NetAccessAdd(
 const char FAR * pszServer,
 short sLevel,
 char FAR * pbBuffer,
 unsigned short cbBuffer
)
NETAPI32 (NT) OR SVRAPI (95).NetAccessCheck(
 char FAR *pszReserved,
 char FAR *pszUserName,
 char FAR *pszResource,
 unsigned short usOperation,
 unsigned short FAR *pusResult
)
NETAPI32 (NT) OR SVRAPI (95).NetAccessDel(
 const char FAR * pszServer,
 char FAR * pszResource
)
NETAPI32 (NT) OR SVRAPI (95).NetAccessEnum(
 const char FAR * pszServer,
 char FAR * pszBasePath,
 short fsRecursive,
 short sLevel,
 char FAR * pbBuffer,
 unsigned short cbBuffer,
 unsigned short FAR * pcEntriesRead,
 unsigned short FAR * pcTotalAvail
)
NETAPI32 (NT) OR SVRAPI (95).NetAccessGetInfo(
 const char FAR * pszServer,
 short sLevel,
 char FAR * pbBuffer,
 unsigned short cbBuffer,
 unsigned short FAR * pcbTotalAvail
)
NETAPI32 (NT) OR SVRAPI (95).NetAccessGetUserPerms(
 char FAR * pszServer,
 char FAR * pszUgName,
 char FAR * pszResource,
 unsigned short FAR * pusPerms
)
NETAPI32 (NT) OR SVRAPI (95).NetAccessSetInfo(
 const char FAR * pszServer,
 char FAR * pszResource,
 short sLevel,
 char FAR * pbBuffer,
 unsigned short cbBuffer,
 short sParmNum
)
NETAPI32.NetAlertRaise(
 LPCWSTR AlertEventName,
 LPVOID Buffer,
 DWORD BufferSize
)
NETAPI32.NetAlertRaiseEx(
 LPCWSTR AlertEventName,
 LPVOID VariableInfo,
 DWORD VariableInfoSize,
 LPCWSTR ServiceName
)
NETAPI32.NetApiBufferAllocate(
 DWORD ByteCount,
 LPVOID *Buffer
)
NETAPI32.NetApiBufferFree(
 LPVOID Buffer
)
NETAPI32.NetApiBufferReallocate(
 LPVOID OldBuffer,
 DWORD NewByteCount,
 LPVOID *NewBuffer
)
NETAPI32.NetApiBufferSize(
 LPVOID Buffer,
 LPDWORD ByteCount
)
NETAPI32.NetAuditClear(OBSOLETE)
)
NETAPI32.NetAuditRead(OBSOLETE)
)
NETAPI32.NetAuditWrite(OBSOLETE)
)
NETAPI32.NetConfigGet(OBSOLETE)
)
NETAPI32.NetConfigGetAll(OBSOLETE)
)
NETAPI32.NetConfigSet(OBSOLETE)
)
NETAPI32.NetConnectionEnum(
 -NT/2000-
 LPWSTR servername,
 LPWSTR qualifier,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 LPDWORD resume_handle
 -95/98-
 const char FAR *pszServer,
 const char FAR *pszQualifier,
 short sLevel,
 char FAR *pbBuffer,
 unsigned short cbBuffer,
 unsigned short FAR *pcEntriesRead,
 unsigned short FAR *pcTotalAvail
)
NETAPI32.NetDfsAdd(
 LPWSTR DfsEntryPath, ; Dfs entry path for added Dfs link
 LPWSTR ServerName, ; name of server exporting the storage
 LPWSTR ShareName, ; existing share name for the storage
 LPWSTR Comment, ; optional comment for the Dfs link
 DWORD Flags ; zero for no flags
)
NETAPI32.NetDfsAddFtRoot(
 LPWSTR ServerName,
 LPWSTR RootShare,
 LPWSTR FtDfsName,
 LPWSTR Comment,
 DWORD Flags
)
NETAPI32.NetDfsAddStdRoot(
 LPWSTR ServerName,
 LPWSTR RootShare,
 LPWSTR Comment,
 DWORD Flags
)
NETAPI32.NetDfsAddStdRootForced(
 LPWSTR ServerName,
 LPWSTR RootShare,
 LPWSTR Comment,
 LPWSTR Store
)
NETAPI32.NetDfsEnum(
 LPWSTR DfsName, ; name of the Dfs for enumeration
 DWORD Level, ; level of information requested
 DWORD PrefMaxLen, ; advisory, but -1 means return all information
 LPBYTE *Buffer, ; function allocates and returns the buffer with requested info
 LPDWORD EntriesRead, ; number of entries returned
 LPDWORD ResumeHandle ; must be 0 on first call, reused on subsequent calls
)
NETAPI32.NetDfsGetClientInfo(
 LPWSTR DfsEntryPath, ; Dfs entry path for the junction point
 LPWSTR ServerName, ; name of server exporting the storage
 LPWSTR ShareName, ; name of share exporting the storage
 DWORD Level, ; level of information requested
 LPBYTE *Buffer ; receives requested information
)
NETAPI32.NetDfsGetInfo(
 LPWSTR DfsEntryPath, ; Dfs entry path for the Dfs link
 LPWSTR ServerName, ; name of server exporting the storage
 LPWSTR ShareName, ; name of share exporting the storage
 DWORD Level, ; level of information requested
 LPBYTE *Buffer ; function allocates and returns
 ; buffer with requested info
)
NETAPI32.NetDfsManagerInitialize(
 LPWSTR ServerName,
 DWORD Flags
)
NETAPI32.NetDfsRemove(
 LPWSTR DfsEntryPath, ; Dfs entry path for the junction point
 LPWSTR ServerName, ; name of server exporting the storage
 LPWSTR ShareName ; name of share exporting the storage
)
NETAPI32.NetDfsRemoveFtRoot(
 LPWSTR ServerName,
 LPWSTR RootShare,
 LPWSTR FtDfsName,
 DWORD Flags
)
NETAPI32.NetDfsRemoveFtRootForced(
 LPWSTR DomainName,
 LPWSTR ServerName,
 LPWSTR RootShare,
 LPWSTR FtDfsName,
 DWORD Flags
)
NETAPI32.NetDfsRemoveStdRoot(
 LPWSTR ServerName,
 LPWSTR RootShare,
 DWORD Flags
)
NETAPI32.NetDfsSetClientInfo(
 LPWSTR DfsEntryPath, ; Dfs entry path for the junction point
 LPWSTR ServerName, ; name of server exporting the storage
 LPWSTR ShareName, ; name of share exporting the storage
 DWORD Level, ; level of information to set
 LPBYTE Buffer ; buffer holding information
)
NETAPI32.NetDfsSetInfo(
 LPWSTR DfsEntryPath, ; Dfs entry path for the Dfs link
 LPWSTR ServerName, ; name of server exporting the storage
 LPWSTR ShareName, ; name of share exporting the storage
 DWORD Level, ; level of information to be set
 LPBYTE Buffer ; buffer holding information
)
NETAPI32.NetErrorLogClear(OBSOLETE)
)
NETAPI32.NetErrorLogRead(OBSOLETE)
)
NETAPI32.NetErrorLogWrite(OBSOLETE)
)
NETAPI32.NetFileClose(
 LPWSTR servername,
 DWORD fileid
)
NETAPI32.NetFileClose2(
 const char FAR * pszServer,
 unsigned long ulFileId
)
NETAPI32 (NT) OR SVRAPI (95).NetFileEnum(
 -NT/2000-
 LPWSTR servername,
 LPWSTR basepath,
 LPWSTR username,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 PDWORD_PTR resume_handle
 -95/98-
 const char FAR * pszServer,
 const char FAR * pszBasePath,
 short sLevel,
 char FAR * pbBuffer,
 unsigned short cbBuffer,
 unsigned short FAR * pcEntriesRead,
 unsigned short FAR * pcTotalAvail
)
NETAPI32.NetFileGetInfo(
 LPWSTR servername,
 DWORD fileid,
 DWORD level,
 LPBYTE *bufptr
)
NETAPI32.NetGetAnyDCName(
 LPCWSTR servername,
 LPCWSTR domainname,
 LPBYTE *bufptr
)
NETAPI32.NetGetDCName(
 LPCWSTR servername,
 LPCWSTR domainname,
 LPBYTE *bufptr
)
NETAPI32.NetGetDisplayInformationIndex(
 LPCWSTR ServerName,
 DWORD Level,
 LPCWSTR Prefix,
 LPDWORD Index
)
NETAPI32.NetGetJoinableOUs(
 LPCWSTR lpServer,
 LPCWSTR lpDomain,
 LPCWSTR lpAccount,
 LPCWSTR lpPassword,
 DWORD *OUCount,
 LPWSTR **OUs
)
NETAPI32.NetGetJoinInformation(
 LPCWSTR lpServer,
 LPWSTR *lpNameBuffer,
 PNETSETUP_JOIN_STATUS BufferType
)
NETAPI32.NetGroupAdd(
 LPCWSTR servername,
 DWORD level,
 LPBYTE buf,
 LPDWORD parm_err
)
NETAPI32.NetGroupAddUser(
 LPCWSTR servername,
 LPCWSTR GroupName,
 LPCWSTR username
)
NETAPI32.NetGroupDel(
 LPCWSTR servername,
 LPCWSTR groupname
)
NETAPI32.NetGroupDelUser(
 LPCWSTR servername,
 LPCWSTR GroupName,
 LPCWSTR Username
)
NETAPI32.NetGroupEnum(
 LPCWSTR servername,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 PDWORD_PTR resume_handle
)
NETAPI32.NetGroupGetInfo(
 LPCWSTR servername,
 LPCWSTR groupname,
 DWORD level,
 LPBYTE *bufptr
)
NETAPI32.NetGroupGetUsers(
 LPCWSTR servername,
 LPCWSTR groupname,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 PDWORD_PTR ResumeHandle
)
NETAPI32.NetGroupSetInfo(
 LPCWSTR servername,
 LPCWSTR groupname,
 DWORD level,
 LPBYTE buf,
 LPDWORD parm_err
)
NETAPI32.NetGroupSetUsers(
 LPCWSTR servername,
 LPCWSTR groupname,
 DWORD level,
 LPBYTE buf,
 DWORD totalentries
)
NETAPI32.NetJoinDomain(
 LPCWSTR lpServer,
 LPCWSTR lpDomain,
 LPCWSTR lpAccountOU,
 LPCWSTR lpAccount,
 LPCWSTR lpPassword,
 DWORD fJoinOptions
)
NETAPI32.NetLocalGroupAdd(
 LPCWSTR servername,
 DWORD level,
 LPBYTE buf,
 LPDWORD parm_err
)
NETAPI32.NetLocalGroupAddMember(OBSOLETE - Use NetLocalGroupAddMembers)
)
NETAPI32.NetLocalGroupAddMembers(
 LPCWSTR servername,
 LPCWSTR groupname,
 DWORD level,
 LPBYTE buf,
 DWORD totalentries
)
NETAPI32.NetLocalGroupDel(
 LPCWSTR servername,
 LPCWSTR groupname
)
NETAPI32.NetLocalGroupDelMember(OBSOLETE - Use NetLocalGroupDelMembers)
)
NETAPI32.NetLocalGroupDelMembers(
 LPCWSTR servername,
 LPCWSTR groupname,
 DWORD level,
 LPBYTE buf,
 DWORD totalentries
)
NETAPI32.NetLocalGroupEnum(
 LPCWSTR servername,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 PDWORD_PTR resumehandle
)
NETAPI32.NetLocalGroupGetInfo(
 LPCWSTR servername,
 LPCWSTR groupname,
 DWORD level,
 LPBYTE *bufptr
)
NETAPI32.NetLocalGroupGetMembers(
 LPCWSTR servername,
 LPCWSTR localgroupname,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 PDWORD_PTR resumehandle
)
NETAPI32.NetLocalGroupSetInfo(
 LPCWSTR servername,
 LPCWSTR groupname,
 DWORD level,
 LPBYTE buf,
 LPDWORD parm_err
)
NETAPI32.NetLocalGroupSetMembers(
 LPCWSTR servername,
 LPCWSTR groupname,
 DWORD level,
 LPBYTE buf,
 DWORD totalentries
)
NETAPI32.NetMessageBufferSend(
 LPCWSTR servername,
 LPCWSTR msgname,
 LPCWSTR fromname,
 LPBYTE buf,
 DWORD buflen
)
NETAPI32.NetMessageNameAdd(
 LPCWSTR servername,
 LPCWSTR msgname
)
NETAPI32.NetMessageNameDel(
 LPCWSTR servername,
 LPCWSTR msgname
)
NETAPI32.NetMessageNameEnum(
 LPCWSTR servername,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 LPDWORD resume_handle
)
NETAPI32.NetMessageNameGetInfo(
 LPCWSTR servername,
 LPCWSTR msgname,
 DWORD level,
 LPBYTE *bufptr
)
NETAPI32.NetQueryDisplayInformation(
 LPCWSTR ServerName,
 DWORD Level,
 DWORD Index,
 DWORD EntriesRequested,
 DWORD PreferredMaximumLength,
 LPDWORD ReturnedEntryCount,
 PVOID *SortedBuffer
)
NETAPI32.NetRemoteComputerSupports(
 LPCWSTR UncServerName,
 DWORD OptionsWanted,
 LPDWORD OptionsSupported
)
NETAPI32.NetRemoteTOD(
 LPCWSTR UncServerName,
 LPBYTE *BufferPtr
)
xxxx.NetRenameMachineInDomain(
 LPCWSTR lpServer,
 LPCWSTR lpNewMachineName,
 LPCWSTR lpAccount,
 LPCWSTR lpPassword,
 DWORD fRenameOptions
)
NETAPI32.NetReplExportDirAdd(
 LPCWSTR servername,
 DWORD level,
 const LPBYTE buf,
 LPDWORD parm_err
)
NETAPI32.NetReplExportDirDel(
 LPCWSTR servername,
 LPCWSTR dirname
)
NETAPI32.NetReplExportDirEnum(
 LPCWSTR servername,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 LPDWORD resumehandle
)
NETAPI32.NetReplExportDirGetInfo(
 LPCWSTR servername,
 LPCWSTR dirname,
 DWORD level,
 LPBYTE *bufptr
)
NETAPI32.NetReplExportDirLock(
 LPCWSTR servername,
 LPCWSTR dirname
)
NETAPI32.NetReplExportDirSetInfo(
 LPCWSTR servername,
 LPCWSTR dirname,
 DWORD level,
 const LPBYTE buf,
 LPDWORD parm_err
)
NETAPI32.NetReplExportDirUnlock(
 LPCWSTR servername,
 LPCWSTR dirname,
 DWORD unlockforce
)
NETAPI32.NetReplGetInfo(
 LPCWSTR servername,
 DWORD level,
 LPBYTE *bufptr
)
NETAPI32.NetReplImportDirAdd(
 LPCWSTR servername,
 DWORD level,
 const LPBYTE buf,
 LPDWORD parm_err
)
NETAPI32.NetReplImportDirDel(
 LPCWSTR servername,
 LPCWSTR dirname
)
NETAPI32.NetReplImportDirEnum(
 LPCWSTR servername,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 LPDWORD resumehandle
)
NETAPI32.NetReplImportDirGetInfo(
 LPCWSTR servername,
 LPCWSTR dirname,
 DWORD level,
 LPBYTE *bufptr
)
NETAPI32.NetReplImportDirLock(
 LPCWSTR servername,
 LPCWSTR dirname
)
NETAPI32.NetReplImportDirUnlock(
 LPCWSTR servername,
 LPCWSTR dirname,
 DWORD unlockforce
)
NETAPI32.NetReplSetInfo(
 LPCWSTR servername,
 DWORD level,
 const LPBYTE buf,
 LPDWORD parm_err
)
NETAPI32.NetScheduleJobAdd(
 LPCWSTR Servername,
 LPBYTE Buffer,
 LPDWORD JobId
)
NETAPI32.NetScheduleJobDel(
 LPCWSTR Servername,
 DWORD MinJobId,
 DWORD MaxJobId
)
NETAPI32.NetScheduleJobEnum(
 LPCWSTR Servername,
 LPBYTE *PointerToBuffer,
 DWORD PreferredMaximumLength,
 LPDWORD EntriesRead,
 LPDWORD TotalEntries,
 LPDWORD ResumeHandle
)
NETAPI32.NetScheduleJobGetInfo(
 LPCWSTR Servername,
 DWORD JobId,
 LPBYTE *PointerToBuffer
)
NETAPI32.NetSecurityGetInfo(
 const char FAR *pszServer,
 short sLevel,
 char FAR *pbBuffer,
 unsigned short cbBuffer,
 unsigned short FAR *pcbTotalAvail
)
NETAPI32.NetServerComputerNameAdd(
 LPWSTR ServerName,
 LPWSTR EmulatedDomainName,
 LPWSTR EmulatedServerName
)
NETAPI32.NetServerComputerNameDel(
 LPWSTR ServerName,
 LPWSTR EmulatedServerName
)
NETAPI32.NetServerDiskEnum(
 LPWSTR servername,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 LPDWORD resume_handle
)
NETAPI32.NetServerEnum(
 LPCWSTR servername,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 DWORD servertype,
 LPCWSTR domain,
 LPDWORD resume_handle
)
NETAPI32 (NT) OR SVRAPI (95).NetServerGetInfo(
 -NT/2000-
 LPWSTR servername,
 DWORD level,
 LPBYTE *bufptr
 -95/98-
 const char FAR *pszServer,
 short sLevel,
 char FAR *pbBuffer,
 unsigned short cbBuffer,
 unsigned short FAR *pcbTotalAvail
)
NETAPI32.NetServerSetInfo(
 LPWSTR servername,
 DWORD level,
 LPBYTE buf,
 LPDWORD ParmError
)
NETAPI32.NetServerTransportAdd(
 LPWSTR servername,
 DWORD level,
 LPBYTE bufptr
)
NETAPI32.NetServerTransportAddEx(
 LPSTR servername,
 DWORD level,
 LPBYTE bufptr
)
NETAPI32.NetServerTransportDel(
 LPWSTR servername,
 DWORD level,
 LPBYTE bufptr
)
NETAPI32.NetServerTransportEnum(
 LPWSTR servername,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 LPDWORD resumehandle
)
NETAPI32.NetServiceControl(OBSOLETE)
)
NETAPI32.NetServiceEnum(OBSOLETE)
)
NETAPI32.NetServiceGetInfo(OBSOLETE)
)
NETAPI32.NetServiceInstall(OBSOLETE)
)
NETAPI32.NetSessionDel(
 -NT/2000-
 LPWSTR servername,
 LPWSTR UncClientName,
 LPWSTR username
 -95/98-
 const char FAR *pszServer,
 const char FAR *pszClientName,
 short sReserved
)
NETAPI32 (NT) OR SVRAPI (95).NetSessionEnum(
 -NT/2000-
 LPWSTR servername,
 LPWSTR UncClientName,
 LPWSTR username,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 LPDWORD resume_handle
 -95/98-
 const char FAR *pszServer,
 short sLevel,
 char FAR *pbBuffer,
 unsigned short cbBuffer,
 unsigned short FAR *pcEntriesRead,
 unsigned short FAR *pcTotalAvail
)
NETAPI32 (NT) OR SVRAPI (95).NetSessionGetInfo(
 -NT/2000-
 LPWSTR servername,
 LPWSTR UncClientName,
 LPWSTR username,
 DWORD level,
 LPBYTE *bufptr
 -95/98-
 const char FAR *pszServer,
 const char FAR *pszClientName,
 short sLevel,
 char FAR *pbBuffer,
 unsigned short cbBuffer,
 unsigned short FAR *pcbTotalAvail
)
NETAPI32 (NT) OR SVRAPI (95).NetShareAdd(
 -NT/2000-
 LPWSTR servername,
 DWORD level,
 LPBYTE buf,
 LPDWORD parm_err
 -95/98-
 const char FAR *pszServer,
 short sLevel,
 const char FAR *pbBuffer,
 unsigned short cbBuffer
)
NETAPI32.NetShareCheck(
 LPWSTR servername,
 LPWSTR device,
 LPDWORD type
)
NETAPI32 (NT) OR SVRAPI (95).NetShareDel(
 -NT/2000-
 LPWSTR servername,
 LPWSTR netname,
 DWORD reserved
 -95/98-
 const char FAR *pszServer,
 const char FAR *pszNetName,
 unsigned short usReserved
)
NETAPI32 (NT) OR SVRAPI (95).NetShareEnum(
 -NT/2000-
 LPWSTR servername,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 LPDWORD resume_handle
 -95/98-
 const char FAR *pszServer,
 short sLevel,
 char FAR *pbBuffer,
 unsigned short cbBuffer,
 unsigned short FAR *pcEntriesRead,
 unsigned short FAR *pcTotalAvail
)
NETAPI32 (NT) OR SVRAPI (95).NetShareGetInfo(
 -NT/2000-
 LPWSTR servername,
 LPWSTR netname,
 DWORD level,
 LPBYTE *bufptr
 -95/98-
 const char FAR *pszServer,
 const char FAR *pszNetName,
 short sLevel,
 char FAR * pbBuffer,
 unsigned short cbBuffer,
 unsigned short FAR *pcbTotalAvail
)
NETAPI32 (NT) OR SVRAPI (95).NetShareSetInfo(
 -NT/2000-
 LPWSTR servername,
 LPWSTR netname,
 DWORD level,
 LPBYTE buf,
 LPDWORD parm_err
 -95/98-
 const char FAR *pszServer,
 const char FAR *pszNetName,
 short sLevel,
 char FAR *pbBuffer,
 unsigned short cbBuffer,
 short sParmNum
)
NETAPI32.NetStatisticsGet(
 LPWSTR server,
 LPWSTR service,
 DWORD level,
 DWORD options,
 LPBYTE *bufptr
)
NETAPI32..NetUnjoinDomain(
 LPCWSTR lpServer,
 LPCWSTR lpAccount,
 LPCWSTR lpPassword,
 DWORD fUnjoinOptions
)
NETAPI32.NetUseAdd(
 LPWSTR UncServerName,
 DWORD Level,
 LPBYTE Buf,
 LPDWORD ParmError
)
NETAPI32.NetUseDel(
 LPWSTR UncServerName,
 LPWSTR UseName,
 DWORD ForceCond
)
NETAPI32.NetUseEnum(
 LPWSTR UncServerName,
 DWORD Level,
 LPBYTE *BufPtr,
 DWORD PreferedMaximumSize,
 LPDWORD EntriesRead,
 LPDWORD TotalEntries,
 LPDWORD ResumeHandle
)
NETAPI32.NetUseGetInfo(
 LPWSTR UncServerName,
 LPWSTR UseName,
 DWORD Level,
 LPBYTE *BufPtr
)
NETAPI32.NetUserAdd(
 LPCWSTR servername,
 DWORD level,
 LPBYTE buf,
 LPDWORD parm_err
)
NETAPI32.NetUserChangePassword(
 LPCWSTR domainname,
 LPCWSTR username,
 LPCWSTR oldpassword,
 LPCWSTR newpassword
)
NETAPI32.NetUserDel(
 LPCWSTR servername,
 LPCWSTR username
)
NETAPI32.NetUserEnum(
 LPCWSTR servername,
 DWORD level,
 DWORD filter,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 LPDWORD resume_handle
)
NETAPI32.NetUserGetGroups(
 LPCWSTR servername,
 LPCWSTR username,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries
)
NETAPI32.NetUserGetInfo(
 LPCWSTR servername,
 LPCWSTR username,
 DWORD level,
 LPBYTE *bufptr
)
NETAPI32.NetUserGetLocalGroups(
 LPCWSTR servername,
 LPCWSTR username,
 DWORD level,
 DWORD flags,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries
)
NETAPI32.NetUserModalsGet(
 LPCWSTR servername,
 DWORD level,
 LPBYTE *bufptr
)
NETAPI32.NetUserModalsSet(
 LPCWSTR servername,
 DWORD level,
 LPBYTE buf,
 LPDWORD parm_err
)
NETAPI32.NetUserSetGroups(
 LPCWSTR servername,
 LPCWSTR username,
 DWORD level,
 LPBYTE buf,
 DWORD num_entries
)
NETAPI32.NetUserSetInfo(
 LPCWSTR servername,
 LPCWSTR username,
 DWORD level,
 LPBYTE buf,
 LPDWORD parm_err
)
NETAPI32..NetValidateName(
 LPCWSTR lpServer,
 LPCWSTR lpName,
 LPCWSTR lpAccount,
 LPCWSTR lpPassword,
 NETSETUP_NAME_TYPE NameType
)
NETAPI32.NetWkstaGetInfo(
 LPWSTR servername,
 DWORD level,
 LPBYTE *bufptr
)
NETAPI32.NetWkstaSetInfo(
 LPWSTR servername,
 DWORD level,
 LPBYTE buffer,
 LPDWORD parm_err
)
NETAPI32.NetWkstaTransportAdd(
 LPWSTR servername,
 DWORD level,
 LPBYTE buf,
 LPDWORD parm_err
)
NETAPI32.NetWkstaTransportDel(
 LPWSTR servername,
 LPWSTR transportname,
 DWORD ucond
)
NETAPI32.NetWkstaTransportEnum(
 LPWSTR servername,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 LPDWORD resumehandle
)
NETAPI32.NetWkstaUserEnum(
 LPWSTR servername,
 DWORD level,
 LPBYTE *bufptr,
 DWORD prefmaxlen,
 LPDWORD entriesread,
 LPDWORD totalentries,
 LPDWORD resumehandle
)
NETAPI32.NetWkstaUserGetInfo(
 LPWSTR reserved,
 DWORD level,
 LPBYTE *bufptr
)
NETAPI32.NetWkstaUserSetInfo(
 LPWSTR reserved,
 DWORD level,
 LPBYTE buf,
 LPDWORD parm_err
)
USER-DEFINED.NOTIFCALLBACK(
 LPVOID lpvContext,
 ULONG cNotification,
 LPNOTIFICATION lpNotifications
)
ADVAPI32.NotifyBootConfigStatus(
 BOOL BootAcceptable ; boot status
)
ADVAPI32.NotifyChangeEventLog(
 HANDLE hEventLog, ; handle to event log
 HANDLE hEvent ; handle to event object
)
USER32.OemKeyScan(
 WORD wOemChar ; ASCII value of OEM character
)
xxxx.OemToAnsi(OBSOLETE - Use OemToChar)
)
xxxx.OemToAnsiBuff(OBSOLETE - Use OemToCharBuff)
)
USER32.OemToCharA(
 LPCSTR lpszSrc, ; string to translate
 LPTSTR lpszDst ; translated string
)
USER32.OemToCharBuffA(
 LPCTSTR lpszSrc, ; string to translate
 LPTSTR lpszDst, ; translated string buffer
 DWORD cchDstLength ; TCHARs to translate
)
GDI32.OffsetClipRgn(
 HDC hdc, ; handle to DC
 int nXOffset, ; offset along x-axis
 int nYOffset ; offset along y-axis
)
USER32.OffsetRect(
 LPRECT lprc, ; rectangle
 int dx, ; horizontal offset
 int dy ; vertical offset
)
GDI32.OffsetRgn(
 HRGN hrgn, ; handle to region
 int nXOffset, ; offset along x-axis
 int nYOffset ; offset along y-axis
)
GDI32.OffsetViewportOrgEx(
 HDC hdc, ; handle to device context
 int nXOffset, ; horizontal offset
 int nYOffset, ; vertical offset
 LPPOINT lpPoint ; original origin
)
GDI32.OffsetWindowOrgEx(
 HDC hdc, ; handle to device context
 int nXOffset, ; horizontal offset
 int nYOffset, ; vertical offset
 LPPOINT lpPoint ; original origin
)
USER-DEFINED.OFNHookProc(
 HWND hdlg, ; handle to child dialog box
 UINT uiMsg, ; message identifier
 WPARAM wParam, ; message parameter
 LPARAM lParam ; message parameter
)
USER-DEFINED.OFNHookProcOldStyle(
 HWND hdlg, ; handle to dialog box
 UINT uiMsg, ; message identifier
 WPARAM wParam, ; message parameter
 LPARAM lParam ; message parameter
)
ADVAPI32.OpenBackupEventLogA(
 LPCTSTR lpUNCServerName, ; backup file server name
 LPCTSTR lpFileName ; backup file name
)
USER32.OpenClipboard(
 HWND hWndNewOwner ; handle to window
)
USER32.OpenDesktopA(
 LPTSTR lpszDesktop, ; desktop name
 DWORD dwFlags, ; interaction option
 BOOL fInherit, ; inheritance option
 ACCESS_MASK dwDesiredAccess ; handle access
)
KERNEL32.OpenEventA(
 DWORD dwDesiredAccess, ; access
 BOOL bInheritHandle, ; inheritance option
 LPCTSTR lpName ; object name
)
ADVAPI32.OpenEventLogA(
 LPCTSTR lpUNCServerName, ; server name
 LPCTSTR lpSourceName ; file name
)
KERNEL32.OpenFile(
 LPCSTR lpFileName, ; file name
 LPOFSTRUCT lpReOpenBuff, ; file information
 UINT uStyle ; action and attributes
)
KERNEL32.OpenFileMappingA(
 DWORD dwDesiredAccess, ; access mode
 BOOL bInheritHandle, ; inherit flag
 LPCTSTR lpName ; object name
)
USER32.OpenIcon(
 HWND hWnd ; handle to window
)
MAPI32.OpenIMsgOnIStg(
 LPMSGSESS lpMsgSess,
 LPALLOCATEBUFFER lpAllocateBuffer,
 LPALLOCATEMORE lpAllocateMore,
 LPFREEBUFFER lpFreeBuffer,
 LPMALLOC lpmalloc,
 LPVOID lpMapiSup,
 LPSTORAGE lpStg,
 MSGCALLRELEASE FAR * lpfMsgCallRelease,
 ULONG ulCallerData,
 ULONG ulFlags,
 LPMESSAGE FAR * lppMsg
)
MAPI32.OpenIMsgSession(
 LPMALLOC lpMalloc,
 ULONG ulFlags,
 LPMSGSESS FAR * lppMsgSess
)
USER32.OpenInputDesktop(
 DWORD dwFlags, ; interaction option
 BOOL fInherit, ; inheritance option
 ACCESS_MASK dwDesiredAccess ; handle access
)
KERNEL32.OpenJobObjectA(
 DWORD dwDesiredAccess, ; access right
 BOOL bInheritHandles, ; inheritance state
 LPCTSTR lpName ; job name
)
KERNEL32.OpenMutexA(
 DWORD dwDesiredAccess, ; access
 BOOL bInheritHandle, ; inheritance option
 LPCTSTR lpName ; object name
)
WINSPOOL.OpenPrinterA(
 LPTSTR pPrinterName, ; printer or server name
 LPHANDLE phPrinter, ; printer or server handle
 LPPRINTER_DEFAULTS pDefault ; printer defaults
)
KERNEL32.OpenProcess(
 DWORD dwDesiredAccess, ; access flag
 BOOL bInheritHandle, ; handle inheritance option
 DWORD dwProcessId ; process identifier
)
ADVAPI32.OpenSCManagerA(
 LPCTSTR lpMachineName, ; computer name
 LPCTSTR lpDatabaseName, ; SCM database name
 DWORD dwDesiredAccess ; access type
)
KERNEL32.OpenSemaphoreA(
 DWORD dwDesiredAccess, ; access
 BOOL bInheritHandle, ; inheritance option
 LPCTSTR lpName ; object name
)
ADVAPI32.OpenServiceA(
 SC_HANDLE hSCManager, ; handle to SCM database
 LPCTSTR lpServiceName, ; service name
 DWORD dwDesiredAccess ; access
)
MAPI32.OpenStreamOnFile(
 LPALLOCATEBUFFER lpAllocateBuffer,
 LPFREEBUFFER lpFreeBuffer,
 ULONG ulFlags,
 LPTSTR lpszFileName,
 LPTSTR lpszPrefix,
 LPSTREAM FAR * lppStream
)
xxxx.OpenThread(
 DWORD dwDesiredAccess, ; access right
 BOOL bInheritHandle, ; handle inheritance option
 DWORD dwThreadId ; thread identifier
)
MAPI32.OpenTnefStream(
 LPVOID lpvSupport,
 LPSTREAM lpStream,
 LPTSTR lpszStreamName,
 ULONG ulFlags,
 LPMESSAGE lpMessage,
 WORD wKey,
 LPITNEF FAR * lppTNEF
)
MAPI32.OpenTnefStreamEx(
 LPVOID lpvSupport,
 LPSTREAM lpStreamName,
 LPTSTR lpszStreamName,
 ULONG ulFlags,
 LPMESSAGE lpMessage,
 WORD wKeyVal,
 LPADRBOOK lpAdressBook,
 LPITNEF FAR * lppTNEF
)
KERNEL32.OpenWaitableTimerA(
 DWORD dwDesiredAccess, ; access
 BOOL bInheritHandle, ; inheritance option
 LPCTSTR lpTimerName ; object name
)
USER32.OpenWindowStationA(
 LPTSTR lpszWinSta, ; window station name
 BOOL fInherit, ; inheritance option
 ACCESS_MASK dwDesiredAccess ; handle access
)
USER-DEFINED.OPTIONCALLBACK(
 HINSTANCE hInst,
 LPMALLOC lpMalloc,
 ULONG ulFlags,
 ULONG cbOptionData,
 LPBYTE lpbOptionData,
 LPMAPISUP lpMAPISup,
 LPMAPIPROP lpDataSource,
 LPMAPIPROP FAR * lppWrappedSource,
 LPMAPIERROR FAR * lppMAPIError
)
USER-DEFINED.ORASADFunc(
 HWND hwndOwner, ; handle of an owner window
 LPSTR lpszEntry, ; pointer to a phone-book entry
 DWORD dwFlags, ; reserved; must be zero
 LPDWORD lpdwRetCode ; receives the results of a dialing operation
)
KERNEL32.OutputDebugStringA(
 LPCTSTR lpOutputString ; string to be displayed
)
USER-DEFINED.OutputProc(
 HDC hdc, ; handle to DC
 LPARAM lpData, ; string
 int cchData ; length of string
)
USER32.PackDDElParam(
 UINT msg, ; DDE message to be posted
 UINT_PTR uiLo, ; low-order word of lParam of message
 UINT_PTR uiHi ; high-order word of lParam of message
)
USER-DEFINED.PagePaintHook(
 HWND hdlg, ; handle to dialog box
 UINT uiMsg, ; message identifier
 WPARAM wParam, ; message parameter
 LPARAM lParam ; message parameter
)
COMMDLG32.PageSetupDlgA(
 LPPAGESETUPDLG lppsd ; initialization data
)
USER-DEFINED.PageSetupHook(
 HWND hdlg, ; handle to dialog box
 UINT uiMsg, ; message identifier
 WPARAM wParam, ; message parameter
 LPARAM lParam ; message parameter
)
USER32.PaintDesktop(
 HDC hdc ; handle to DC
)
xxxx.PaintMenuBar(
 HWND hwnd, ; window handle
 HDC hdc, ; device context handle
 int iLeftOffset, ; offset from left edge
 int iRightOffset, ; offset from right edge
 int iTopOffset, ; offset from top edge
 DWORD dwFlags ; flag
)
GDI32.PaintRgn(
 HDC hdc, ; handle to device context
 HRGN hrgn ; handle to region to be painted
)
GDI32.PatBlt(
 HDC hdc, ; handle to DC
 int nXLeft, ; x-coord of upper-left rectangle corner
 int nYLeft, ; y-coord of upper-left rectangle corner
 int nWidth, ; width of rectangle
 int nHeight, ; height of rectangle
 DWORD dwRop ; raster operation code
)
SHLWAPI.PathAddBackslashA(
 LPTSTR lpszPath
)
xxxx.PathAddExtensionA(
 LPTSTR pszPath,
 LPCTSTR pszExtension
)
SHLWAPI.PathAppendA(
 LPTSTR pszPath,
 LPCTSTR pszMore
)
SHLWAPI.PathBuildRootA(
 LPTSTR szRoot,
 int iDrive
)
SHLWAPI.PathCanonicalizeA(
 LPTSTR lpszDst,
 LPCTSTR lpszSrc
)
SHLWAPI.PathCombineA(
 LPTSTR lpszDest,
 LPCTSTR lpszDir,
 LPCTSTR lpszFile
)
SHLWAPI.PathCommonPrefixA(
 LPCTSTR pszFile1,
 LPCTSTR pszFile2,
 LPTSTR pszPath
)
SHLWAPI.PathCompactPathA(
 HDC hDC,
 LPTSTR lpszPath,
 UINT dx
)
SHLWAPI.PathCompactPathExA(
 LPTSTR pszOut,
 LPCTSTR pszSrc,
 UINT cchMax,
 DWORD dwFlags
)
xxxx.PathCreateFromUrlA(
 LPCTSTR pszUrl,
 LPTSTR pszPath,
 LPDWORD pcchPath,
 DWORD dwReserved
)
SHLWAPI.PathFileExistsA(
 LPCTSTR pszPath
)
SHLWAPI.PathFindExtensionA(
 LPCTSTR pPath
)
SHLWAPI.PathFindFileNameA(
 LPCTSTR pPath
)
SHLWAPI.PathFindNextComponentA(
 LPCTSTR pszPath
)
SHLWAPI.PathFindOnPathA(
 LPTSTR pszFile,
 LPCTSTR *ppszOtherDirs
)
xxxx.PathFindSuffixArray(
 LPCTSTR pszPath,
 LPCTSTR *apszSuffix,
 int iArraySize
)
SHLWAPI.PathGetArgsA(
 LPCTSTR pszPath
)
SHLWAPI.PathGetCharTypeA(
 TUCHAR ch
)
SHLWAPI.PathGetDriveNumberA(
 LPCTSTR lpsz
)
SHLWAPI.PathIsContentTypeA(
 LPCTSTR pszPath,
 LPCTSTR pszContentType
)
SHLWAPI.PathIsDirectoryA(
 LPCTSTR pszPath
)
xxxx.PathIsDirectoryEmpty(
 LPCTSTR pszPath
)
SHLWAPI.PathIsFileSpecA(
 LPCTSTR lpszPath
)
SHLWAPI.PathIsHTMLFile(
 LPCTSTR pszFile
)
xxxx.PathIsLFNFileSpec(
 LPCTSTR pszName
)
xxxx.PathIsNetworkPath(
 LPCTSTR pszPath
)
SHLWAPI.PathIsPrefixA(
 IN LPCTSTR pszPrefix,
 IN LPCTSTR pszPath
)
SHLWAPI.PathIsRelativeA(
 LPCTSTR lpszPath
)
SHLWAPI.PathIsRootA(
 LPCTSTR pPath
)
SHLWAPI.PathIsSameRootA(
 LPCTSTR pszPath1,
 LPCTSTR pszPath2
)
SHLWAPI.PathIsSystemFolderA(
 LPCTSTR pszPath,
 DWORD dwAttrb
)
SHLWAPI.PathIsUNCA(
 LPCTSTR pszPath
)
SHLWAPI.PathIsUNCServerA(
 LPCTSTR pszPath
)
SHLWAPI.PathIsUNCServerShareA(
 LPCTSTR pszPath
)
SHLWAPI.PathIsURLA(
 LPCTSTR pszPath
)
SHLWAPI.PathMakePrettyA(
 LPTSTR lpPath
)
SHLWAPI.PathMakeSystemFolderA(
 LPTSTR pszPath
)
SHLWAPI.PathMatchSpecA(
 LPCTSTR pszFileParam,
 LPCTSTR pszSpec
)
SHLWAPI.PathParseIconLocationA(
 LPTSTR pszIconFile
)
SHLWAPI.PathQuoteSpacesA(
 LPTSTR lpsz
)
SHLWAPI.PathRelativePathToA(
 LPTSTR pszPath,
 LPCTSTR pszFrom,
 DWORD dwAttrFrom,
 LPCTSTR pszTo,
 DWORD dwAttrTo
)
SHLWAPI.PathRemoveArgsA(
 LPTSTR pszPath
)
SHLWAPI.PathRemoveBackslashA(
 LPTSTR lpszPath
)
SHLWAPI.PathRemoveBlanksA(
 LPTSTR lpszString
)
SHLWAPI.PathRemoveExtensionA(
 LPTSTR pszPath
)
SHLWAPI.PathRemoveFileSpecA(
 LPTSTR pszPath
)
SHLWAPI.PathRenameExtensionA(
 LPTSTR pszPath,
 LPCTSTR pszExt
)
SHLWAPI.PathSearchAndQualifyA(
 LPCTSTR pcszPath,
 LPTSTR pszFullyQualifiedPath,
 UINT cchFullyQualifiedPath
)
SHLWAPI.PathSetDlgItemPathA(
 HWND hDlg,
 int id,
 LPCSTR pszPath
)
SHLWAPI.PathSkipRootA(
 LPCTSTR pszPath
)
SHLWAPI.PathStripPathA(
 LPTSTR pszPath
)
SHLWAPI.PathStripToRootA(
 LPTSTR szRoot
)
GDI32.PathToRegion(
 HDC hdc ; handle to DC
)
xxxx.PathUndecorate(
 LPTSTR pszPath
)
xxxx.PathUnExpandEnvStrings(
 LPCTSTR pszPath,
 LPTSTR pszBuf,
 UINT cchBuf
)
SHLWAPI.PathUnmakeSystemFolderA(
 LPTSTR pszPath
)
SHLWAPI.PathUnquoteSpacesA(
 LPTSTR lpsz
)
KERNEL32.PeekConsoleInputA(
 HANDLE hConsoleInput, ; handle to console input buffer
 PINPUT_RECORD lpBuffer, ; peek data
 DWORD nLength, ; number of records to read
 LPDWORD lpNumberOfEventsRead ; number of records read
)
USER32.PeekMessageA(
 LPMSG lpMsg, ; message information
 HWND hWnd, ; handle to window
 UINT wMsgFilterMin, ; first message
 UINT wMsgFilterMax, ; last message
 UINT wRemoveMsg ; removal options
)
KERNEL32.PeekNamedPipe(
 HANDLE hNamedPipe, ; handle to pipe
 LPVOID lpBuffer, ; data buffer
 DWORD nBufferSize, ; size of data buffer
 LPDWORD lpBytesRead, ; number of bytes read
 LPDWORD lpTotalBytesAvail, ; number of bytes available
 LPDWORD lpBytesLeftThisMessage ; unread bytes
)
xxxx.PfAddFiltersToInterface(
 INTERFACE_HANDLE ih,
 DWORD cInFilters,
 PPF_FILTER_DESCRIPTOR pfiltIn,
 DWORD cOutFilters,
 PPF_FILTER_DESCRIPTOR pfiltOut,
 PFILTER_HANDLE pfHandle
)
xxxx.PfAddGlobalFilterToInterface(
 INTERFACE_HANDLE pInterface,
 GLOBAL_FILTER gfFilter
)
xxxx.PfBindInterfaceToIndex(
 INTERFACE_HANDLE pInterface,
 DWORD dwIndex,
 PFADDRESSTYPE pfatLinkType,
 PBYTE LinkIPAddress
)
xxxx.PfBindInterfaceToIPAddress(
 INTERFACE_HANDLE pInterface,
 PFADDRESSTYPE pfatType,
 PBYTE IPAddress
)
xxxx.PfCreateInterface(
 DWORD dwName,
 PFFORWARD_ACTION inAction,
 PFFORWARD_ACTION outAction,
 BOOL bUseLog,
 BOOL bMustBeUnique,
 INTERFACE_HANDLE *ppInterface
)
xxxx.PfDeleteInterface(
 INTERFACE_HANDLE pInterface
)
xxxx.PfDeleteLog(VOID)
)
xxxx.PfGetInterfaceStatistics(
 INTERFACE_HANDLE pInterface,
 PPF_INTERFACE_STATS ppfStats,
 PDWORD pdwBufferSize,
 BOOL fResetCounters
)
xxxx.PfMakeLog(
 HANDLE hEvent
)
xxxx.PfRebindFilters(
 INTERFACE_HANDLE pInterface,
 PPF_LATEBIND_INFO pLateBindInfo
)
xxxx.PfRemoveFilterHandles(
 INTERFACE_HANDLE pInterface,
 DWORD cFilters,
 PFILTER_HANDLE pvHandles
)
xxxx.PfRemoveFiltersFromInterface(
 INTERFACE_HANDLE ih,
 DWORD cInFilters,
 PPF_FILTER_DESCRIPTOR pfiltIn,
 DWORD cOutFilters,
 PPF_FILTER_DESCRIPTOR pfiltOut
)
xxxx.PfRemoveGlobalFilterFromInterface(
 INTERFACE_HANDLE pInterface,
 GLOBAL_FILTER gfFilter
)
xxxx.PfSetLogBuffer(
 PBYTE pbBuffer,
 DWORD dwSize,
 DWORD dwThreshold,
 DWORD dwEntries,
 PDWORD pdwLoggedEntries,
 PDWORD pdwLostEntries,
 PDWORD pdwSizeUsed
)
xxxx.PfTestPacket(
 INTERFACE_HANDLE pInInterface, ; OPTIONAL
 INTERFACE_HANDLE pOutInterface, ; OPTIONAL
 DWORD cBytes,
 PBYTE pbPacket,
 PPFFORWARD_ACTION ppAction
)
xxxx.PfUnBindInterface(
 INTERFACE_HANDLE pInterface
)
USER-DEFINED.phoneCallbackFunc(
 HANDLE hDevice,
 DWORD dwMsg,
 DWORD dwCallbackInstance,
 DWORD dwParam1,
 DWORD dwParam2,
 DWORD dwParam3
)
TAPI32.phoneClose(
 HPHONE hPhone
)
TAPI32.phoneConfigDialogA(
 DWORD dwDeviceID,
 HWND hwndOwner,
 LPCSTR lpszDeviceClass
)
TAPI32.phoneDevSpecific(
 HPHONE hPhone,
 LPVOID lpParams,
 DWORD dwSize
)
TAPI32.phoneGetButtonInfoA(
 HPHONE hPhone,
 DWORD dwButtonLampID,
 LPPHONEBUTTONINFO lpButtonInfo
)
TAPI32.phoneGetData(
 HPHONE hPhone,
 DWORD dwDataID,
 LPVOID lpData,
 DWORD dwSize
)
TAPI32.phoneGetDevCapsA(
 HPHONEAPP hPhoneApp,
 DWORD dwDeviceID,
 DWORD dwAPIVersion,
 DWORD dwExtVersion,
 LPPHONECAPS lpPhoneCaps
)
TAPI32.phoneGetDisplay(
 HPHONE hPhone,
 LPVARSTRING lpDisplay
)
TAPI32.phoneGetGain(
 HPHONE hPhone,
 DWORD dwHookSwitchDev,
 LPDWORD lpdwGain
)
TAPI32.phoneGetHookSwitch(
 HPHONE hPhone,
 LPDWORD lpdwHookSwitchDevs
)
TAPI32.phoneGetIconA(
 DWORD dwDeviceID,
 LPCSTR lpszDeviceClass,
 LPHICON lphIcon
)
TAPI32.phoneGetIDA(
 HPHONE hPhone,
 LPVARSTRING lpDeviceID,
 LPCSTR lpszDeviceClass
)
TAPI32.phoneGetLamp(
 HPHONE hPhone,
 DWORD dwButtonLampID,
 LPDWORD lpdwLampMode
)
TAPI32.phoneGetMessage(
 HPHONEAPP hPhoneApp,
 LPPHONEMESSAGE lpMessage,
 DWORD dwTimeout
)
TAPI32.phoneGetRing(
 HPHONE hPhone,
 LPDWORD lpdwRingMode,
 LPDWORD lpdwVolume
)
TAPI32.phoneGetStatusA(
 HPHONE hPhone,
 LPPHONESTATUS lpPhoneStatus
)
TAPI32.phoneGetStatusMessages(
 HPHONE hPhone,
 LPDWORD lpdwPhoneStates,
 LPDWORD lpdwButtonModes,
 LPDWORD lpdwButtonStates
)
TAPI32.phoneGetVolume(
 HPHONE hPhone,
 DWORD dwHookSwitchDev,
 LPDWORD lpdwVolume
)
TAPI32.phoneInitialize(
 LPHPHONEAPP lphPhoneApp,
 HINSTANCE hInstance,
 PHONECALLBACK lpfnCallback,
 LPCSTR lpszAppName,
 LPDWORD lpdwNumDevs
)
TAPI32.phoneInitializeExA(
 LPHPHONEAPP lphPhoneApp,
 HINSTANCE hInstance,
 PHONECALLBACK lpfnCallback,
 LPCSTR lpszFriendlyAppName,
 LPDWORD lpdwNumDevs,
 LPDWORD lpdwAPIVersion,
 LPPHONEINITIALIZEEXPARAMS lpPhoneInitializeExParams
)
TAPI32.phoneNegotiateAPIVersion(
 HPHONEAPP hPhoneApp,
 DWORD dwDeviceID,
 DWORD dwAPILowVersion,
 DWORD dwAPIHighVersion,
 LPDWORD lpdwAPIVersion,
 LPPHONEEXTENSIONID lpExtensionID
)
TAPI32.phoneNegotiateExtVersion(
 HPHONEAPP hPhoneApp,
 DWORD dwDeviceID,
 DWORD dwAPIVersion,
 DWORD dwExtLowVersion,
 DWORD dwExtHighVersion,
 LPDWORD lpdwExtVersion
)
TAPI32.phoneOpen(
 HPHONEAPP hPhoneApp,
 DWORD dwDeviceID,
 LPHPHONE lphPhone,
 DWORD dwAPIVersion,
 DWORD dwExtVersion,
 DWORD_PTR dwCallbackInstance,
 DWORD dwPrivilege
)
TAPI32.phoneSetButtonInfoA(
 HPHONE hPhone,
 DWORD dwButtonLampID,
 LPPHONEBUTTONINFO const lpButtonInfo
)
TAPI32.phoneSetData(
 HPHONE hPhone,
 DWORD dwDataID,
 LPVOID const lpData,
 DWORD dwSize
)
TAPI32.phoneSetDisplay(
 HPHONE hPhone,
 DWORD dwRow,
 DWORD dwColumn,
 LPCSTR lpsDisplay,
 DWORD dwSize
)
TAPI32.phoneSetGain(
 HPHONE hPhone,
 DWORD dwHookSwitchDev,
 DWORD dwGain
)
TAPI32.phoneSetHookSwitch(
 HPHONE hPhone,
 DWORD dwHookSwitchDevs,
 DWORD dwHookSwitchMode
)
TAPI32.phoneSetLamp(
 HPHONE hPhone,
 DWORD dwButtonLampID,
 DWORD dwLampMode
)
TAPI32.phoneSetRing(
 HPHONE hPhone,
 DWORD dwRingMode,
 DWORD dwVolume
)
TAPI32.phoneSetStatusMessages(
 HPHONE hPhone,
 DWORD dwPhoneStates,
 DWORD dwButtonModes,
 DWORD dwButtonStates
)
TAPI32.phoneSetVolume(
 HPHONE hPhone,
 DWORD dwHookSwitchDev,
 DWORD dwVolume
)
TAPI32.phoneShutdown(
 HPHONEAPP hPhoneApp
)
GDI32.Pie(
 HDC hdc, ; handle to DC
 int nLeftRect, ; x-coord of upper-left corner of rectangle
 int nTopRect, ; y-coord of upper-left corner of rectangle
 int nRightRect, ; x-coord of lower-right corner of rectangle
 int nBottomRect, ; y-coord of lower-right corner of rectangle
 int nXRadial1, ; x-coord of first radial's endpoint
 int nYRadial1, ; y-coord of first radial's endpoint
 int nXRadial2, ; x-coord of second radial's endpoint
 int nYRadial2 ; y-coord of second radial's endpoint
)
GDI32.PlayEnhMetaFile(
 HDC hdc, ; handle to DC
 HENHMETAFILE hemf, ; handle to an enhanced metafile
 CONST RECT *lpRect ; bounding rectangle
)
GDI32.PlayEnhMetaFileRecord(
 HDC hdc, ; handle to DC
 LPHANDLETABLE lpHandletable, ; metafile handle table
 CONST ENHMETARECORD *lpEnhMetaRecord, ; metafile record
 UINT nHandles ; count of handles
)
xxxx.PlayMetaFile(
 HDC hdc, ; handle to DC
 HMETAFILE hmf ; handle to metafile
)
xxxx.PlayMetaFileRecord(
 HDC hdc, ; handle to DC
 LPHANDLETABLE lpHandletable, ; metafile handle table
 LPMETARECORD lpMetaRecord, ; metafile record
 UINT nHandles ; count of handles
)
GDI32.PlgBlt(
 HDC hdcDest, ; handle to destination DC
 CONST POINT *lpPoint, ; destination vertices
 HDC hdcSrc, ; handle to source DC
 int nXSrc, ; x-coord of source upper-left corner
 int nYSrc, ; y-coord of source upper-left corner
 int nWidth, ; width of source rectangle
 int nHeight, ; height of source rectangle
 HBITMAP hbmMask, ; handle to bitmask
 int xMask, ; x-coord of bitmask upper-left corner
 int yMask ; y-coord of bitmask upper-left corner
)
xxxx.PMGM_CREATION_ALERT_CALLBACK(
 DWORD dwSourceAddr,
 DWORD dwSourceMask,
 DWORD dwGroupAddr,
 DWORD dwGroupMask,
 DWORD dwInIfIndex,
 DWORD dwInIfNextHopAddr,
 DWORD dwIfCount,
 PMGM_IF_ENTRY pmieOutIfList
)
xxxx.PMGM_DISABLE_IGMP_CALLBACK(
 DWORD dwIfIndex,
 DWORD dwIfNextHopAddr
)
xxxx.PMGM_ENABLE_IGMP_CALLBACK(
 DWORD dwIfIndex,
 DWORD dwIfNextHopAddr
)
xxxx.PMGM_JOIN_ALERT_CALLBACK(
 DWORD dwSourceAddr,
 DWORD dwSourceMask,
 DWORD dwGroupAddr,
 DWORD dwGroupMask,
 BOOL bMemberUpdate
)
xxxx.PMGM_LOCAL_JOIN_CALLBACK(
 DWORD dwSourceAddr,
 DWORD dwSourceMask,
 DWORD dwGroupAddr,
 DWORD dwGroupMask,
 DWORD dwIfIndex,
 DWORD dwIfNextHopAddr
)
xxxx.PMGM_LOCAL_LEAVE_CALLBACK(
 DWORD dwSourceAddr,
 DWORD dwSourceMask,
 DWORD dwGroupAddr,
 DWORD dwGroupMask,
 DWORD dwIfIndex,
 DWORD dwIfNextHopAddr
)
xxxx.PMGM_PRUNE_ALERT_CALLBACK(
 DWORD dwSourceAddr,
 DWORD dwSourceMask,
 DWORD dwGroupAddr,
 DWORD dwGroupMask,
 DWORD dwIfIndex,
 DWORD dwIfNextHopAddr,
 BOOL bMemberDelete,
 PDWORD pdwTimeout
)
xxxx.PMGM_RPF_CALLBACK(
 DWORD dwSourceAddr,
 DWORD dwSourceMask,
 DWORD dwGroupAddr,
 DWORD dwGroupMask,
 PDWORD pdwInIfIndex,
 PDWORD pdwInIfNextHopAddr,
 PDWORD pdwUpStreamNbr,
 DWORD dwHdrSize,
 PBYTE pbPacketHdr,
 PBYTE pbRoute
)
xxxx.PMGM_WRONG_IF_CALLBACK(
 DWORD dwSourceAddr,
 DWORD dwGroupAddr,
 DWORD dwIfIndex,
 DWORD dwIfNextHopAddr,
 DWORD dwHdrSize,
 PBYTE pbPacketHdr
)
GDI32.PolyBezier(
 HDC hdc, ; handle to device context
 CONST POINT *lppt, ; endpoints and control points
 DWORD cPoints ; count of endpoints and control points
)
GDI32.PolyBezierTo(
 HDC hdc, ; handle to device context
 CONST POINT *lppt, ; endpoints and control points
 DWORD cCount ; count of endpoints and control points
)
GDI32.PolyDraw(
 HDC hdc, ; handle to device context
 CONST POINT *lppt, ; array of points
 CONST BYTE *lpbTypes, ; line and curve identifiers
 int cCount ; count of points
)
GDI32.Polygon(
 HDC hdc, ; handle to DC
 CONST POINT *lpPoints, ; polygon vertices
 int nCount ; count of polygon vertices
)
GDI32.Polyline(
 HDC hdc, ; handle to device context
 CONST POINT *lppt, ; array of endpoints
 int cPoints ; number of points in array
)
GDI32.PolylineTo(
 HDC hdc, ; handle to device context
 CONST POINT *lppt, ; array of points
 DWORD cCount ; number of points in array
)
GDI32.PolyPolygon(
 HDC hdc, ; handle to DC
 CONST POINT *lpPoints, ; array of vertices
 CONST INT *lpPolyCounts, ; array of count of vertices
 int nCount ; count of polygons
)
GDI32.PolyPolyline(
 HDC hdc, ; handle to device context
 CONST POINT *lppt, ; array of points
 CONST DWORD *lpdwPolyPoints, ; array of values
 DWORD cCount ; number of entries in values array
)
GDI32.PolyTextOutA(
 HDC hdc, ; handle to DC
 CONST POLYTEXT *pptxt, ; array of strings
 int cStrings ; number of strings in array
)
xxxx.PostAppMessage(OBSOLETE - Use PostThreadMessage)
)
USER32.PostMessageA(
 HWND hWnd, ; handle to destination window
 UINT Msg, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
KERNEL32.PostQueuedCompletionStatus(
 HANDLE CompletionPort, ; handle to an I/O completion port
 DWORD dwNumberOfBytesTransferred, ; bytes transferred
 ULONG_PTR dwCompletionKey, ; completion key
 LPOVERLAPPED lpOverlapped ; overlapped buffer
)
USER32.PostQuitMessage(
 int nExitCode ; exit code
)
USER32.PostThreadMessageA(
 DWORD idThread, ; thread identifier
 UINT Msg, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
MAPI32.PpropFindProp(
 LPSPropValue rgprop,
 ULONG cprop,
 ULONG ulPropTag
)
KERNEL32.PrepareTape(
 HANDLE hDevice, ; handle to device
 DWORD dwOperation, ; preparation method
 BOOL bImmediate ; return after operation begins
)
USER-DEFINED.PreprocessMessage(
 LPVOID lpvSession,
 LPMESSAGE lpMessage,
 LPADRBOOK lpAdrBook,
 LPMAPIFOLDER lpFolder,
 LPALLOCATEBUFFER AllocateBuffer,
 LPALLOCATEMORE AllocateMore,
 LPFREEBUFFER FreeBuffer,
 ULONG FAR * lpcOutbound,
 LPMESSAGE FAR * FAR * lpppMessage,
 LPADRLIST FAR * lppRecipList
)
COMDLG32.PrintDlgA(
 LPPRINTDLG lppd ; initialization data
)
COMDLG32.PrintDlgEx(
 LPPRINTDLGEX lppd ; initialization data
)
WINSPOOL.PrinterMessageBoxA(OBSOLETE)
)
WINSPOOL.PrinterProperties(
 HWND hWnd, ; handle to parent window
 HANDLE hPrinter ; handle to printer object
)
USER-DEFINED.PrintHookProc(
 HWND hdlg, ; handle to dialog box
 UINT uiMsg, ; message identifier
 WPARAM wParam, ; message parameter
 LPARAM lParam ; message parameter
)
xxxx.PrintWindow(
 HWND hwnd, ; Window to copy
 HDC hdcBlt, ; HDC to print into
 UINT nFlags ; Optional flags
)
KERNEL32.Process32First(
 HANDLE hSnapshot,
 LPPROCESSENTRY32 lppe
)
KERNEL32.Process32Next(
 HANDLE hSnapshot,
 LPPROCESSENTRY32 lppe
)
MAPI32.PropCopyMore(
 LPSPropValue lpSPropValueDest,
 LPSPropValue lpSPropValueSrc,
 ALLOCATEMORE * lpfAllocMore,
 LPVOID lpvObject
)
USER-DEFINED.PropEnumProc(
 HWND hwnd, ; handle to window
 LPCTSTR lpszString, ; string component
 HANDLE hData ; data handle component
)
USER-DEFINED.PropEnumProcEx(
 HWND hwnd, ; handle to window
 LPTSTR lpszString, ; string component
 HANDLE hData, ; data handle component
 ULONG_PTR dwData ; application-defined data
)
COMCTL32.PropertySheetA(
 LPCPROPSHEETHEADER lppsph
)
USER-DEFINED.PropSheetPageProc(
 HWND hwnd,
 UINT uMsg,
 LPPROPSHEETPAGE ppsp
)
USER-DEFINED.PropSheetProc(
 HWND hwndDlg,
 UINT uMsg,
 LPARAM lParam
)
USER32.PtInRect(
 CONST RECT *lprc, ; rectangle
 POINT pt ; point
)
GDI32.PtInRegion(
 HRGN hrgn, ; handle to region
 int X, ; x-coordinate of point
 int Y ; y-coordinate of point
)
GDI32.PtVisible(
 HDC hdc, ; handle to DC
 int X, ; x-coordinate of point
 int Y ; y-coordinate of point
)
KERNEL32.PulseEvent(
 HANDLE hEvent ; handle to event object
)
KERNEL32.PurgeComm(
 HANDLE hFile, ; handle to communications resource
 DWORD dwFlags ; action to perform
)
xxxx.QUERYCLIENTCERT(
 PLDAP Connection,
 PSecPkgContext_IssuerListInfoEx trusted_CAs,
 HCERTSTORE hCertStore,
 DWORD *pcCreds
)
KERNEL32.QueryDosDeviceA(
 LPCTSTR lpDeviceName, ; MS-DOS device name string
 LPTSTR lpTargetPath, ; query results buffer
 DWORD ucchMax ; maximum size of buffer
)
KERNEL32.QueryInformationJobObject(
 HANDLE hJob, ; handle to job
 JOBOBJECTINFOCLASS JobObjectInfoClass, ; information class
 LPVOID lpJobObjectInfo, ; limit information
 DWORD cbJobObjectInfoLength, ; limit information size
 LPDWORD lpReturnLength ; data written
)
KERNEL32.QueryPerformanceCounter(
 LARGE_INTEGER *lpPerformanceCount ; counter value
)
KERNEL32.QueryPerformanceFrequency(
 LARGE_INTEGER *lpFrequency ; current frequency
)
xxxx.QueryPower(
 DWORD PowerType
)
xxxx.QueryRecoveryAgentsOnEncryptedFile(
 LPCWSTR lpFileName, ; file name
 PENCRYPTION_CERTIFICATE_HASH_LIST *pRecoveryAgents ; hash list
)
ADVAPI32.QueryServiceConfig(
 SC_HANDLE hService, ; handle to service
 LPQUERY_SERVICE_CONFIG lpServiceConfig, ; buffer
 DWORD cbBufSize, ; size of buffer
 LPDWORD pcbBytesNeeded ; bytes needed
)
ADVAPI32.QueryServiceConfig2A(
 SC_HANDLE hService, ; handle to service
 DWORD dwInfoLevel, ; information level
 LPBYTE lpBuffer, ; buffer
 DWORD cbBufSize, ; size of buffer
 LPDWORD pcbBytesNeeded ; bytes needed
)
ADVAPI32.QueryServiceLockStatus(
 SC_HANDLE hSCManager, ; handle to SCM database
 LPQUERY_SERVICE_LOCK_STATUS lpLockStatus, ; buffer
 DWORD cbBufSize, ; size of buffer
 LPDWORD pcbBytesNeeded ; bytes needed
)
ADVAPI32.QueryServiceStatus(
 SC_HANDLE hService, ; handle to service
 LPSERVICE_STATUS lpServiceStatus ; service status
)
xxxx.QueryServiceStatusEx(
 SC_HANDLE hService, ; handle to service
 SC_STATUS_TYPE InfoLevel, ; information level
 LPBYTE lpBuffer, ; buffer
 DWORD cbBufSize, ; size of buffer
 LPDWORD pcbBytesNeeded ; bytes needed
)
xxxx.QueryUsersOnEncryptedFile(
 LPCWSTR lpFileName, ; file name
 PENCRYPTION_CERTIFICATE_HASH_LIST *pUsers ; hash list
)
KERNEL32.QueueUserAPC(
 PAPCFUNC pfnAPC, ; APC function
 HANDLE hThread, ; handle to thread
 ULONG_PTR dwData ; APC function parameter
)
xxxx.QueueUserWorkItem(
 LPTHREAD_START_ROUTINE Function, ; starting address
 PVOID Context, ; function data
 ULONG Flags ; worker options
)
xxxx.RadiusExtensionInit(VOID)
)
xxxx.RadiusExtensionTerm(VOID)
)
xxxx.RadiusExtensionProcess(
 RADIUS_ATTRIBUTE *pAttrs, ; pointer to array of attributes
 PRADIUS_ACTION pfAction ; action that IAS should take
)
xxxx.RadiusExtensionProcessEx(
 CONST RADIUS_ATTRIBUTE *pInAttrs, ; pointer to array of input attributes
 RADIUS_ATTRIBUTE *pOutAttrs, ; pointer to array of output attributes
 PRADIUS_ACTION pfAction ; action that IAS should take
)
KERNEL32.RaiseException(
 DWORD dwExceptionCode, ; exception code
 DWORD dwExceptionFlags, ; continuable exception flag
 DWORD nNumberOfArguments, ; number of arguments
 CONST ULONG_PTR *lpArguments ; array of arguments
)
USER-DEFINED.RASADFunc(
 LPTSTR lpszPhonebook, ; pointer to full path and file name of phone-book file
 LPTSTR lpszEntry, ; pointer to the entry name to validate
 LPRASADPARAMS lpAutoDialParams, ; pointer to a RASADPARAMS structure
 LPDWORD lpdwRetCode ; receives results of dialing operation
)
xxxx.RasAdminAcceptNewConnection(
 RAS_PORT_1 *pRasPort1, ; pointer to information about the connection
 RAS_PORT_STATISTICS *pRasStats, ; pointer to statistics about the port
 RAS_PARAMETERS *pRasParams ; pointer to an array of media-specific parameters and values
)
xxxx.RasAdminConnectionHangupNotification(
 RAS_PORT_1 *pRasPort1, ; pointer to information about the connection
 RAS_PORT_STATISTICS *pRasStats, ; pointer to statistics about the port
 RAS_PARAMETERS *pRasParams ; pointer to an array of media-specific parameters and values
)
RASSAPI.RasAdminFreeBuffer(
 PVOID Pointer ; pointer to the buffer to free
)
RASSAPI.RasAdminGetErrorString(
 UINT ResourceId, ; error code to get message for
 WCHAR *lpszString, ; pointer to a buffer that receives the error string
 DWORD InBufSize ; size, in characters, of the buffer
)
xxxx.RasAdminGetIpAddressForUser(
 WCHAR *lpszUserName, ; pointer to the name of the remote user
 WCHAR *lpszPortName, ; pointer to the name of the port
 IPADDR *pipAddress, ; pointer to the IP address
 BOOL *bNotifyRelease ; indicates whether RAS should call RasAdminReleaseIpAddress
)
RASSAPI.RasAdminGetUserAccountServer(
 const WCHAR *lpszDomain, ; pointer to the name of the Windows NT/2000 domain
 const WCHAR *lpszServer, ; pointer to the name of the RAS server
 LPWSTR lpszUserAccountServer ; receives the name of the user account server
)
RASSAPI.RasAdminPortClearStatistics(
 const WCHAR *lpszServer, ; pointer to the server name
 const WCHAR *lpszPort ; pointer to the name of port on the server
)
RASSAPI.RasAdminPortDisconnect(
 const WCHAR *lpszServer, ; pointer to the server name
 const WCHAR *lpszPort ; pointer to the name of port on the server
)
RASSAPI.RasAdminPortEnum(
 const WCHAR *lpszServer, ; pointer to the server name
 PRAS_PORT_0 *ppRasPort0, ; receives a pointer to an array of port information
 WORD *pcEntriesRead ; receives the number of ports enumerated
)
RASSAPI.RasAdminPortGetInfo(
 const WCHAR *lpszServer, ; pointer to the server name
 const WCHAR *lpszPort, ; pointer to the name of port on the server
 RAS_PORT_1 *pRasPort1, ; receives the state of the port
 RAS_PORT_STATISTICS *pRasStats, ; receives statistics about the port
 RAS_PARAMETERS **ppRasParams ; receives an array of media-specific parameters and values
)
xxxx.RasAdminReleaseIpAddress(
 WCHAR *lpszUserName, ; pointer to the name of the remote user
 WCHAR *lpszPortName, ; pointer to the name of the port
 IPADDR *pipAddress ; pointer to the IP address
)
RASSAPI.RasAdminServerGetInfo(
 const WCHAR *lpszServer, ; pointer to the name of the RAS server
 PRAS_SERVER_0 pRasServer0 ; pointer to server information
)
RASSAPI.RasAdminUserGetInfo(
 const WCHAR *lpszUserAccountServer, ; pointer to the name of the user account server
 const WCHAR *lpszUser, ; pointer to the name of the user
 PRAS_USER_0 pRasUser0 ; receives the user's RAS information
)
RASSAPI.RasAdminUserSetInfo(
 const WCHAR *lpszUserAccountServer, ; pointer to the name of the user account server
 const WCHAR *lpszUser, ; pointer to the name of the user
 const PRAS_USER_0 pRasUser0 ; pointer to the new RAS information for this user
)
xxxx.RasClearConnectionStatistics(
 HRASCONN hRasConn ; handle to connection
)
xxxx.RasClearLinkStatistics(
 HRASCONN hRasConn, ; handle to connection
 DWORD dwSubEntry ; SubEntry for link
)
RASAPI32.RasConnectionNotificationA(
 HRASCONN hrasconn, ; handle to a RAS connection
 HANDLE hEvent, ; handle to an event object
 DWORD dwFlags ; type of event to receive notifications for
)
RASAPI32.RasCreatePhonebookEntryA(
 HWND hwnd, ; handle to the parent window of the dialog box
 LPCTSTR lpszPhonebook, ; pointer to the full path and file name of the phone-book file
)
xxxx.RasCustomDeleteEntryNotify(
 LPCTSTR lpszPhonebook,
 LPCTSTR lpszEntry,
 DWORD dwFlags
)
xxxx.RasCustomDial(
 HINSTANCE hInstDll, ; handle to DLL instance
 LPRASDIALEXTENSIONS lpRasDialExtensions, ; pointer to function extensions data
 LPCTSTR lpszPhonebook, ; pointer to full path and file name of phone-book file
 LPRASDIALPARAMS lpRasDialParams, ; pointer to calling parameters data
 DWORD dwNotifierType, ; specifies type of RasDial event handler
 LPVOID lpvNotifier, ; specifies a handler for RasDial events
 LPHRASCONN lphRasConn ; pointer to variable to receive connection handle
)
xxxx.RasCustomDialDlg(
 HINSTANCE hInstDll, ; handle to DLL instance
 DWORD dwFlags, ; reserved
 LPTSTR lpszPhonebook, ; pointer to the full path and file name of the phone-book file
 LPTSTR lpszEntry, ; pointer to the name of the phone-book entry to dial
 LPTSTR lpszPhoneNumber, ; pointer to replacement phone number to dial
 LPRASDIALDLG lpInfo ; pointer to a structure that contains additional parameters
)
xxxx.RasCustomEntryDlg(
 HINSTANCE hInstDll, ; handle to DLL instance
 LPTSTR lpszPhonebook, ; pointer to the full path and file name of the phone-book file
 LPTSTR lpszEntry, ; pointer to the name of the phone-book entry to edit, copy, or create
 LPRASENTRYDLG lpInfo ; pointer to a structure that contains additional parameters
)
xxxx.RasCustomHangUp(
 HRASCONN hRasConn ; handle to a RAS connection
)
xxxx.RasCustomScriptExecute(
 HANDLE hPort,
 LPCWSTR lpszPhonebook,
 LPCWSTR lpszEntryName,
 PFNRASGETBUFFER pfnRasGetBuffer,
 PFNRASFREEBUFFER pfnRasFreeBuffer,
 PFNRASSENDBUFFER pfnRasSendBuffer,
 PFNRASRECEIVEBUFFER pfnRasReceiveBuffer,
 PFNRASRETRIEVEBUFFER pfnRasRetrieveBuffer,
 HWND hWnd,
 RASDIALPARAMS *pRasDialParams,
 RASCUSTOMSCRIPTEXTENSIONS *pRasCustomScriptExtensions
)
RASAPI32.RasDeleteEntryA(
 LPCTSTR lpszPhonebook, ; pointer to full path and file name of phone-book file
 LPCTSTR lpszEntry ; pointer to an entry name to delete
)
xxxx.RasDeleteSubEntry(
 LPCTSTR lpszPhonebook,
 LPCTSTR lpszEntry,
 DWORD dwSubEntryId
)
RASAPI32.RasDialA(
 LPRASDIALEXTENSIONS lpRasDialExtensions, ; pointer to function extensions data
 LPCTSTR lpszPhonebook, ; pointer to full path and file name of phone-book file
 LPRASDIALPARAMS lpRasDialParams, ; pointer to calling parameters data
 DWORD dwNotifierType, ; specifies type of RasDial event handler
 LPVOID lpvNotifier, ; specifies a handler for RasDial events
 LPHRASCONN lphRasConn ; pointer to variable to receive connection handle
)
RASDLG.RasDialDlgA(
 LPTSTR lpszPhonebook, ; pointer to the full path and file name of the phone-book file
 LPTSTR lpszEntry, ; pointer to the name of the phone-book entry to dial
 LPTSTR lpszPhoneNumber, ; pointer to replacement phone number to dial
 LPRASDIALDLG lpInfo ; pointer to a structure that contains additional parameters
)
USER-DEFINED.RasDialFunc(
 UINT unMsg, ; type of event that has occurred
 RASCONNSTATE rasconnstate, ; connection state about to be entered
 DWORD dwError ; error that may have occurred
)
USER-DEFINED.RasDialFunc1(
 HRASCONN hrasconn, ; handle to RAS connection
 UINT unMsg, ; type of event that has occurred
 RASCONNSTATE rascs, ; connection state about to be entered
 DWORD dwError, ; error that may have occurred
 DWORD dwExtendedError ; extended error information for some errors
)
USER-DEFINED.RasDialFunc2(
 DWORD dwCallbackId, ; user-defined value specified in RasDial call
 DWORD dwSubEntry, ; subentry index in multilink connection
 HRASCONN hrasconn, ; handle to RAS connection
 UINT unMsg, ; type of event that has occurred
 RASCONNSTATE rascs, ; connection state about to be entered
 DWORD dwError, ; error that may have occurred
 DWORD dwExtendedError ; extended error information for some errors
)
xxxx.RasEapBegin(
 VOID **ppWorkBuffer, ; buffer used in subsequent calls to protocol
 PPP_EAP_INPUT *pPppEapInput ; initialization information
)
xxxx.RasEapEnd(
 VOID *pWorkBuffer ; work buffer to free
)
xxxx.RasEapFreeMemory(
 BYTE *pMemory ; pointer to the memory to free
)
xxxx.RasEapGetIdentity(
 DWORD dwEapTypeId, ; identifies the protocol
 HWND hwndParent, ; handle to parent window
 DWORD dwFlags, ; flags that qualify authentication process
 const WCHAR *pwszPhonebook, ; path to phone book to use
 const WCHAR *pwszEntry, ; name of entry in phone book
 BYTE *pConnectionDataIn, ; pointer to current connection data
 DWORD dwSizeOfConnectionDataIn, ; size of current connection data
 BYTE *pUserDataIn, ; pointer to current user data from registry
 DWORD dwSizeOfUserDataIn, ; size of current user data
 BYTE **ppUserDataOut, ; new user data
 DWORD *pdwSizeOfUserDataOut, ; size of new user data
 WCHAR *ppwszIdentity ; identity of user
)
xxxx.RasEapGetInfo(
 DWORD dwEapTypeId ; identifies the protocol
 PPP_EAP_INFO *pEapInfo ; pointer to information for a particular EAP
)
xxxx.RasEapInitialize(
 BOOL fInitialize ; TRUE to init, FALSE to deinit
)
xxxx.RasEapInvokeConfigUI(
 DWORD dwEapTypeId, ; identifies the protocol
 HWND hwndParent, ; handle to parent window
 DWORD dwFlags, ; indicates whether caller is router or RAS client
 BYTE *pConnectionDataIn, ; current connection data
 DWORD dwSizeOfConnectionDataIn, ; size of current connection data
 BYTE **ppConnectionDataOut, ; new connection data
 DWORD *pdwSizeOfConnectionDataOut, ; size of new connection data
)
xxxx.RasEapInvokeInteractiveUI(
 DWORD dwEapTypeId, ; identifies the protocol
 HWND hwndParent, ; handle to parent window
 BYTE *pUIContextData, ; pointer to context data
 DWORD dwSizeofUIContextData, ; size of context data
 BYTE **ppDataFromInteractiveUI, ; pointer to data returned from UI
 DWORD *pdwSizeOfDataFromInteractiveUI ; size of data returned from UI.
)
xxxx.RasEapMakeMessage(
 VOID *pWorkBuf, ; pointer to the workbuffer for this authentication sesssion
 PPP_EAP_PACKET *pReceivePacket, ; pointer to incoming packet
 PPP_EAP_PACKET *pSendPacket, ; pointer to packet to transmit
 DWORD cbSendPacket, ; max size of packet to transmit
 PPP_EAP_OUTPUT *pEapOutput, ; info/requests from EAP to RAS
 PPP_EAP_INPUT *pEapInput ; info/requests from RAS to EAP
)
RASAPI32.RasEditPhonebookEntry(
 HWND hwnd, ; handle to the parent window of the dialog box
 LPCTSTR lpszPhonebook, ; pointer to the full path and file name of the phone-book file
 LPCTSTR lpszEntryName ; pointer to the phone-book entry name
)
RASDLG.RasEntryDlgA(
 LPTSTR lpszPhonebook, ; pointer to the full path and file name of the phone-book file
 LPTSTR lpszEntry, ; pointer to the name of the phone-book entry to edit, copy, or create
 LPRASENTRYDLG lpInfo ; pointer to a structure that contains additional parameters
)
RASAPI32.RasEnumAutodialAddressesA(
 LPTSTR *lppAddresses, ; pointer to buffer that receives network address strings
 LPDWORD lpdwcbAddresses, ; pointer to size, in bytes, of the buffer
 LPDWORD lpdwcAddresses ; pointer to number of strings returned
)
RASAPI32.RasEnumConnectionsA(
 LPRASCONN lprasconn, ; buffer to receive connections data
 LPDWORD lpcb, ; size in bytes of buffer
 LPDWORD lpcConnections ; number of connections written to buffer
)
RASAPI32.RasEnumDevicesA(
 LPRASDEVINFO lpRasDevInfo, ; buffer to receive information about RAS devices
 LPDWORD lpcb, ; size, in bytes, of the buffer
 LPDWORD lpcDevices ; receives the number of entries written to the buffer
)
RASAPI32.RasEnumEntriesA(
 LPCTSTR reserved, ; reserved, must be NULL
 LPTCSTR lpszPhonebook, ; pointer to full path and file name of phone-book file
 LPRASENTRYNAME lprasentryname, ; buffer to receive phone-book entries
 LPDWORD lpcb, ; size in bytes of buffer
 LPDWORD lpcEntries ; number of entries written to buffer
)
xxxx.RasFreeBuffer(
 PBYTE pBuffer
)
xxxx.RasFreeEapUserIdentity(
 LPRASEAPUSERIDENTITY pRasEapUserIdentity ; pointer to memory to free
)
RASAPI32.RasGetAutodialAddressA(
 LPCTSTR lpszAddress, ; pointer to a network address string
 LPDWORD lpdwReserved, ; reserved; must be NULL
 LPRASAUTODIALENTRY lpAutoDialEntries, ; pointer to buffer for AutoDial entry data
 LPDWORD lpdwcbAutoDialEntries, ; pointer to size, in bytes, of buffer
 LPDWORD lpdwcAutoDialEntries ; pointer to number of entries returned
)
RASAPI32.RasGetAutodialEnableA(
 DWORD dwDialingLocation, ; identifier of the TAPI dialing location
 LPBOOL lpfEnabled ; pointer to variable that receives AutoDial state for this location
)
RASAPI32.RasGetAutodialParamA(
 DWORD dwKey, ; indicates the parameter to retrieve
 LPVOID lpvValue, ; pointer to a buffer that receives the value
 LPDWORD lpdwcbValue ; size, in bytes, of the buffer
)
xxxx.RasGetBuffer(
 PBYTE *ppBuffer,
 PDWORD pdwSize
)
xxxx.RasGetConnectionStatistics(
 HRASCONN hRasConn, ; handle to the connection
 RAS_STATS *lpStatistics ; buffer to receive statistics
)
RASAPI32.RasGetConnectStatusA(
 HRASCONN hrasconn, ; handle to RAS connection of interest
 LPRASCONNSTATUS lprasconnstatus ; buffer to receive status data
)
RASAPI32.RasGetCountryInfoA(
 LPRASCTRYINFO lpRasCtryInfo, ; buffer that receives country information
 LPDWORD lpdwSize ; size, in bytes, of the buffer
)
RASAPI32.RasGetCredentialsA(
 LPCTSTR lpszPhonebook, ; pointer to the full path and file name of a phone-book file
 LPCTSTR lpszEntry, ; pointer to the name of a phone-book entry
 LPRASCREDENTIALS lpCredentials ; pointer to structure that receives credentials
)
xxxx.RasGetCustomAuthData (
 LPCWSTR pszPhonebook, ; path to phone book to use
 LPCWSTR pszEntry, ; name of entry in phone book
 BYTE *pbCustomAuthData, ; buffer to receive data
 DWORD *pdwSizeofCustomAuthData ; size of buffer
)
xxxx.RasGetEapUserData (
 HANDLE hToken, ; access token for user
 LPCTSTR pszPhonebook, ; path to phone book to use
 LPCTSTR pszEntry, ; name of entry in phone book
 BYTE *pbEapData, ; retrieved data for the user
 DWORD *pdwSizeofEapData ; size of retrieved data
)
xxxx.RasGetEapUserIdentity(
 LPCSTR pszPhonebook, ; path to phone book to use
 LPCSTR pszEntry, ; name of entry in phone book
 DWORD dwFlags, ; flags that qualify authentication
 HWND hwnd, ; handle to UI parent
 LPRASEAPUSERIDENTITY *ppRasEapUserIdentity ; identity info
)
RASAPI32.RasGetEntryDialParamsA(
 LPCTSTR lpszPhonebook, ; pointer to the full path and file name of the phone-book file
 LPRASDIALPARAMS lprasdialparams, ; pointer to a structure that receives the connection parameters
 LPBOOL lpfPassword ; indicates whether the user's password was retrieved
)
RASAPI32.RasGetEntryPropertiesA(
 LPCTSTR lpszPhonebook, ; pointer to full path and file name of phone-book file
 LPCTSTR lpszEntry, ; pointer to an entry name
 LPRASENTRY lpRasEntry, ; buffer that receives entry information
 LPDWORD lpdwEntryInfoSize, ; size, in bytes, of the lpRasEntry buffer
 LPBYTE lpbDeviceInfo, ; buffer that receives device-specific configuration information
 LPDWORD lpdwDeviceInfoSize ; size, in bytes, of the lpbDeviceInfo buffer
)
RASAPI32.RasGetErrorStringA(
 UINT uErrorValue, ; error to get string for
 LPTSTR lpszErrorString, ; buffer to hold error string
 DWORD cBufSize ; size, in characters, of buffer
)
xxxx.RasGetLinkStatistics(
 HRASCONN hRasConn, ; handle to connection
 DWORD dwSubEntry, ; SubEntry for link
 RAS_STATS *lpStatistics ; buffer to receive statistics
)
RASAPI32.RasGetProjectionInfoA(
 HRASCONN hrasconn, ; handle that specifies remote access connection of interest
 RASPROJECTION rasprojection, ; specifies type of projection information to obtain
 LPVOID lpprojection, ; points to buffer that receives projection information
 LPDWORD lpcb ; points to variable that specifies buffer size
)
RASAPI32.RasGetSubEntryHandleA(
 HRASCONN hrasconn,
 DWORD dwSubEntry,
 LPHRASCONN lphrasconn
)
RASAPI32.RasGetSubEntryPropertiesA(
 LPCTSTR lpszPhonebook, ; pointer to full path and file name of phone-book file
 LPCTSTR lpszEntry, ; pointer to an entry name
 DWORD dwSubEntry, ; index of the subentry
 LPRASSUBENTRY lpRasSubEntry, ; pointer to structure that receives information about subentry
 LPDWORD lpdwcb, ; size, in bytes, of the structure
 LPBYTE lpbDeviceConfig, ; pointer to TAPI device configuration
 LPDWORD lpcbDeviceConfig ; pointer to size of device configuration
)
RASAPI32.RasHangUpA(
 HRASCONN hrasconn ; handle to the RAS connection to hang up
)
xxxx.RasInvokeEapUI(
 HRASCONN hRasConn, ; handle to connection
 DWORD dwSubEntry, ; subentry from callback
 LPRASDIALEXTENSIONS lpExtensions,
 HWND hwnd ; handle to parent window for user interface
)
RASDLG.RasMonitorDlgA(
 LPTSTR lpszDeviceName, ; pointer to the name of the device to display initially
 LPRASMONITORDLG lpInfo ; pointer to structure that contains input and output parameters
)
USER-DEFINED.RasPBDlgFunc(
 DWORD dwCallbackId, ; an application-defined value
 DWORD dwEvent, ; indicates the event that occurred
 LPTSTR pszText, ; pointer to an additional string argument
 LPVOID pData ; pointer to an additional buffer argument
)
RASDLG.RasPhonebookDlgA(
 LPTSTR lpszPhonebook, ; pointer to the full path and file name of the phone-book file
 LPTSTR lpszEntry, ; pointer to the name of the phone-book entry to highlight
 LPRASPBDLG lpInfo ; pointer to a structure that contains additional parameters
)
xxxx.RasReceiveBuffer(
 HANDLE hPort,
 PBYTE pBuffer,
 PDWORD pdwSize,
 DWORD dwTimeout,
 HANDLE hEvent
)
RASAPI32.RasRenameEntryA(
 LPCTSTR lpszPhonebook, ; pointer to full path and file name of phone-book file
 LPCTSTR lpszOldEntry, ; pointer to the old entry name
 LPCTSTR lpszNewEntry ; pointer to the new entry name
)
xxxx.RasRetrieveBuffer(
 HPORT hPort,
 PBYTE pBuffer,
 PDWORD pdwSize
)
xxxx.RasSecurityDialogBegin(
 HPORT hPort, ; RAS handle to the port
 PBYTE pSendBuf, ; pointer to buffer for sending data
 DWORD SendBufSize, ; size, in bytes, of the send buffer
 PBYTE pRecvBuf, ; pointer to buffer for receiving data
 DWORD RecvBufSize, ; size, in bytes, of the receive buffer
 VOID (WINAPI *RasSecurityDialogComplete) ; pointer to the completion function
)
xxxx.RasSecurityDialogComplete(
 SECURITY_MESSAGE *pSecMsg ; pointer to the security message structure
)
xxxx.RasSecurityDialogEnd(
 HPORT hPort ; RAS handle to the port
)
RASMAN.RasSecurityDialogGetInfo(
 HPORT hPort, ; RAS handle to port
 RAS_SECURITY_INFO *pBuffer ; pointer to structure that gets port information
)
RASMAN.RasSecurityDialogReceive(
 HPORT hPort, ; RAS handle to the port
 PBYTE pBuffer, ; pointer to buffer that receives the user's response
 PWORD pBufferLength, ; returns size, in bytes, of the data received
 DWORD Timeout, ; time-out period, in seconds
 HANDLE hEvent ; event that is signaled when operation is finished
)
RASMAN.RasSecurityDialogSend(
 HPORT hPort, ; RAS handle to the port
 PBYTE pBuffer, ; pointer to buffer containing data to send
 WORD BufferLength ; size, in bytes, of the data being sent
)
xxxx.RasSendBuffer(
 HANDLE hPort,
 PBYTE pBuffer,
 DWORD dwSize
)
RASAPI32.RasSetAutodialAddressA(
 LPCTSTR lpszAddress, ; pointer to a network address string
 DWORD dwReserved, ; reserved; must be zero
 LPRASAUTODIALENTRY lpAutoDialEntries, ; pointer to buffer containing AutoDial entry data
 DWORD dwcbAutoDialEntries, ; size, in bytes, of the buffer
 DWORD dwcAutoDialEntries ; number of entries in the buffer
)
RASAPI32.RasSetAutodialEnableA(
 DWORD dwDialingLocation, ; identifier of the TAPI dialing location
 BOOL fEnabled ; AutoDial state for this location
)
RASAPI32.RasSetAutodialParamA(
 DWORD dwKey, ; indicates the parameter to set
 LPVOID lpvValue, ; pointer to a buffer that specifies the value
 DWORD dwcbValue ; size, in bytes, of the buffer
)
xxxx.RasSetCommSettings(
 HANDLE hPort,
 RASCOMMSETTINGS *pRasCommSettings,
 PVOID pvReserved
)
RASAPI32.RasSetCredentialsA(
 LPCTSTR lpszPhonebook, ; pointer to the full path and file name of a phone-book file
 LPCTSTR lpszEntry, ; pointer to the name of a phone-book entry
 LPRASCREDENTIALS lpCredentials, ; pointer to structure that specifies the credentials
 BOOL fClearCredentials ; if true, credentials are cleared. if false, credentials are set
)
xxxx.RasSetCustomAuthData(
 LPCWSTR pszPhonebook, ; path to phone book to use
 LPCWSTR pszEntry, ; name of entry in phone book
 BYTE *pbCustomAuthData, ; pointer to data
 DWORD dwSizeofCustomAuthData ; size of data
)
xxxx.RasSetEapUserData(
 HANDLE hToken, ; access token for user
 LPCTSTR pszPhonebook, ; path to phone book to use
 LPCTSTR pszEntry, ; name of entry in phone book
 BYTE *pbEapData, ; data to store for the user
 DWORD dwSizeofEapData ; size of data
)
RASAPI32.RasSetEntryDialParamsA(
 LPCTSTR lpszPhonebook, ; pointer to the full path and file name of the phone book file
 LPRASDIALPARAMS lprasdialparams, ; pointer to a structure with the new connection parameters
 BOOL fRemovePassword ; indicates whether to remove password from entry's parameters
)
RASAPI32.RasSetEntryPropertiesA(
 LPCTSTR lpszPhonebook, ; pointer to full path and file name of phone-book file
 LPCTSTR lpszEntry, ; pointer to an entry name
 LPRASENTRY lpRasEntry, ; buffer that contains entry information
 DWORD dwEntryInfoSize, ; size, in bytes, of the lpRasEntry buffer
 LPBYTE lpbDeviceInfo, ; buffer that contains device specific configuration information
 DWORD dwDeviceInfoSize ; size, in bytes, of the lpbDeviceInfo buffer
)
RASAPI32.RasSetSubEntryPropertiesA(
 LPCTSTR lpszPhonebook, ; pointer to full path and file name of the phone-book file
 LPCTSTR lpszEntry, ; pointer to an entry name
 DWORD dwSubEntry, ; index of the subentry
 LPRASSUBENTRY lpRasSubEntry, ; pointer to structure containing information about subentry
 DWORD dwcbRasSubEntry ; size, in bytes, of the structure
 LPBYTE lpbDeviceConfig, ; pointer to TAPI device configuration
 DWORD dwcbDeviceConfig ; size of TAPI device configuration
)
RASAPI32.RasValidateEntryNameA(
 LPCTSTR lpszPhonebook, ; pointer to full path and file name of phone-book file
 LPCTSTR lpszEntry ; pointer to the entry name to validate
)
KERNEL32.ReadConsoleA(
 HANDLE hConsoleInput, ; handle to console input buffer
 LPVOID lpBuffer, ; data buffer
 DWORD nNumberOfCharsToRead, ; number of characters to read
 LPDWORD lpNumberOfCharsRead, ; number of characters read
 LPVOID lpReserved ; reserved
)
KERNEL32.ReadConsoleInputA(
 HANDLE hConsoleInput, ; handle to console input buffer
 PINPUT_RECORD lpBuffer, ; data buffer
 DWORD nLength, ; number of records to read
 LPDWORD lpNumberOfEventsRead ; number of records read
)
KERNEL32.ReadConsoleOutputA(
 HANDLE hConsoleOutput, ; handle to screen buffer
 PCHAR_INFO lpBuffer, ; data buffer
 COORD dwBufferSize, ; column-row size of buffer
 COORD dwBufferCoord, ; upper-left cell to write
 PSMALL_RECT lpReadRegion ; read rectangle
)
KERNEL32.ReadConsoleOutputAttribute(
 HANDLE hConsoleOutput, ; handle to screen buffer
 LPWORD lpAttribute, ; attributes buffer
 DWORD nLength, ; number of cells to read
 COORD dwReadCoord, ; coordinates of first cell
 LPDWORD lpNumberOfAttrsRead ; number of cells read
)
KERNEL32.ReadConsoleOutputCharacterA(
 HANDLE hConsoleOutput, ; handle to screen buffer
 LPTSTR lpCharacter, ; character buffer
 DWORD nLength, ; number of cells to read
 COORD dwReadCoord, ; coordinates of first cell
 LPDWORD lpNumberOfCharsRead ; number of cells read
)
KERNEL32.ReadDirectoryChangesW(
 HANDLE hDirectory, ; handle to directory
 LPVOID lpBuffer, ; read results buffer
 DWORD nBufferLength, ; length of buffer
 BOOL bWatchSubtree, ; monitoring option
 DWORD dwNotifyFilter, ; filter conditions
 LPDWORD lpBytesReturned, ; bytes returned
 LPOVERLAPPED lpOverlapped, ; overlapped buffer
 LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine ; completion routine
)
ADVAPI32.ReadEventLogA(
 HANDLE hEventLog, ; handle to event log
 DWORD dwReadFlags, ; how to read log
 DWORD dwRecordOffset, ; offset of first record
 LPVOID lpBuffer, ; buffer for read data
 DWORD nNumberOfBytesToRead, ; bytes to read
 DWORD *pnBytesRead, ; number of bytes read
 DWORD *pnMinNumberOfBytesNeeded ; bytes required
)
KERNEL32.ReadFile(
 HANDLE hFile, ; handle to file
 LPVOID lpBuffer, ; data buffer
 DWORD nNumberOfBytesToRead, ; number of bytes to read
 LPDWORD lpNumberOfBytesRead, ; number of bytes read
 LPOVERLAPPED lpOverlapped ; overlapped buffer
)
KERNEL32.ReadFileEx(
 HANDLE hFile, ; handle to file
 LPVOID lpBuffer, ; data buffer
 DWORD nNumberOfBytesToRead, ; number of bytes to read
 LPOVERLAPPED lpOverlapped, ; offset
 LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine ; completion routine
)
KERNEL32.ReadFileScatter(
 HANDLE hFile, ; handle to file
 FILE_SEGMENT_ELEMENT aSegmentArray[ ], ; array of buffer pointers
 DWORD nNumberOfBytesToRead, ; number of bytes to read
 LPDWORD lpReserved, ; reserved; must be NULL
 LPOVERLAPPED lpOverlapped ; OVERLAPPED structure
)
WINSPOOL.ReadPrinter(
 HANDLE hPrinter, ; handle to printer object
 LPVOID pBuf, ; data buffer
 DWORD cbBuf, ; size of data buffer
 LPDWORD pNoBytesRead ; bytes received
)
KERNEL32.ReadProcessMemory(
 HANDLE hProcess, ; handle to the process
 LPCVOID lpBaseAddress, ; base of memory area
 LPVOID lpBuffer, ; data buffer
 DWORD nSize, ; number of bytes to read
 LPDWORD lpNumberOfBytesRead ; number of bytes read
)
xxxx.RealChildWindowFromPoint(
 HWND hwndParent, ; handle to window
 POINT ptParentClientCoords ; client coordinates
)
xxxx.RealGetWindowClassA(
 HWND hwnd, ; handle to window
 LPTSTR pszType, ; window type buffer
 UINT cchType ; size of window type buffer
)
GDI32.RealizePalette(
 HDC hdc ; handle to DC
)
GDI32.Rectangle(
 HDC hdc, ; handle to DC
 int nLeftRect, ; x-coord of upper-left corner of rectangle
 int nTopRect, ; y-coord of upper-left corner of rectangle
 int nRightRect, ; x-coord of lower-right corner of rectangle
 int nBottomRect ; y-coord of lower-right corner of rectangle
)
GDI32.RectInRegion(
 HRGN hrgn, ; handle to region
 CONST RECT *lprc ; pointer to rectangle
)
GDI32.RectVisible(
 HDC hdc, ; handle to DC
 CONST RECT *lprc ; rectangle
)
USER32.RedrawWindow(
 HWND hWnd, ; handle to window
 CONST RECT *lprcUpdate, ; update rectangle
 HRGN hrgnUpdate, ; handle to update region
 UINT flags ; array of redraw flags
)
ADVAPI32.RegCloseKey(
 HKEY hKey ; handle to key to close
)
ADVAPI32.RegConnectRegistryA(
 LPCTSTR lpMachineName, ; computer name
 HKEY hKey, ; predefined registry handle
 PHKEY phkResult ; buffer for remote key handle
)
ADVAPI32.RegCreateKeyA(
 HKEY hKey, ; handle to an open key
 LPCTSTR lpSubKey, ; subkey name
 PHKEY phkResult ; buffer for key handle
)
ADVAPI32.RegCreateKeyExA(
 HKEY hKey, ; handle to open key
 LPCTSTR lpSubKey, ; subkey name
 DWORD Reserved, ; reserved
 LPTSTR lpClass, ; class string
 DWORD dwOptions, ; special options
 REGSAM samDesired, ; desired security access
 LPSECURITY_ATTRIBUTES lpSecurityAttributes, ; inheritance
 PHKEY phkResult, ; key handle
 LPDWORD lpdwDisposition ; disposition value buffer
)
ADVAPI32.RegDeleteKeyA(
 HKEY hKey, ; handle to open key
 LPCTSTR lpSubKey ; subkey name
)
ADVAPI32.RegDeleteValueA(
 HKEY hKey, ; handle to key
 LPCTSTR lpValueName ; value name
)
xxxx.RegDisablePredefinedCache(VOID)
)
ADVAPI32.RegEnumKeyA(
 HKEY hKey, ; handle to key to query
 DWORD dwIndex, ; index of subkey to query
 LPTSTR lpName, ; buffer for subkey name
 DWORD cchName ; size of subkey name buffer
)
ADVAPI32.RegEnumKeyExA(
 HKEY hKey, ; handle to key to enumerate
 DWORD dwIndex, ; subkey index
 LPTSTR lpName, ; subkey name
 LPDWORD lpcName, ; size of subkey buffer
 LPDWORD lpReserved, ; reserved
 LPTSTR lpClass, ; class string buffer
 LPDWORD lpcClass, ; size of class string buffer
 PFILETIME lpftLastWriteTime ; last write time
)
ADVAPI32.RegEnumValueA(
 HKEY hKey, ; handle to key to query
 DWORD dwIndex, ; index of value to query
 LPTSTR lpValueName, ; value buffer
 LPDWORD lpcValueName, ; size of value buffer
 LPDWORD lpReserved, ; reserved
 LPDWORD lpType, ; type buffer
 LPBYTE lpData, ; data buffer
 LPDWORD lpcbData ; size of data buffer
)
ADVAPI32.RegFlushKey(
 HKEY hKey ; handle to key to write
)
USER32.RegisterClassA(
 CONST WNDCLASS *lpWndClass ; class data
)
USER32.RegisterClassExA(
 CONST WNDCLASSEX *lpwcx ; class data
)
USER32.RegisterClipboardFormat(
 LPCTSTR lpszFormat ; name of new format
)
xxxx.RegisterDeviceNotificationA(
 HANDLE hRecipient,
 LPVOID NotificationFilter,
 DWORD Flags
)
SCRNSAVE.RegisterDialogClasses(
 HANDLE hInst
)
ADVAPI32.RegisterEventSourceA(
 LPCTSTR lpUNCServerName, ; server name
 LPCTSTR lpSourceName ; source name
)
USER32.RegisterHotKey(
 HWND hWnd, ; handle to window
 int id, ; hot key identifier
 UINT fsModifiers, ; key-modifier options
 UINT vk ; virtual-key code
)
USER-DEFINED.RegisterProtocol(
 PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
 PMPR_SERVICE_CHARACTERISTICS pServiceChar
)
ADVAPI32.RegisterServiceCtrlHandlerA(
 LPCTSTR lpServiceName, ; service name
 LPHANDLER_FUNCTION lpHandlerProc ; handler function
)
xxxx.RegisterServiceCtrlHandlerEx(
 LPCTSTR lpServiceName, ; name of service
 LPHANDLER_FUNCTION_EX lpHandlerProc, ; handler function
 LPVOID lpContext ; user data
)
xxxx.RegisterWaitForSingleObject(
 PHANDLE phNewWaitObject, ; wait handle
 HANDLE hObject, ; handle to object
 WAITORTIMERCALLBACK Callback, ; timer callback function
 PVOID Context, ; callback function parameter
 ULONG dwMilliseconds, ; time-out interval
 ULONG dwFlags ; options
)
USER32.RegisterWindowMessageA(
 LPCTSTR lpString ; message string
)
ADVAPI32.RegLoadKeyA(
 HKEY hKey, ; handle to open key
 LPCTSTR lpSubKey, ; subkey name
 LPCTSTR lpFile ; registry file name
)
ADVAPI32.RegNotifyChangeKeyValue(
 HKEY hKey, ; handle to key to watch
 BOOL bWatchSubtree, ; subkey notification option
 DWORD dwNotifyFilter, ; changes to be reported
 HANDLE hEvent, ; handle to event to be signaled
 BOOL fAsynchronous ; asynchronous reporting option
)
ADVAPI32.RegOpenCurrentUser(
 REGSAM samDesired, ; access rights
 PHKEY phkResult ; handle to open key
)
ADVAPI32.RegOpenKeyA(
 HKEY hKey, ; handle to open key
 LPCTSTR lpSubKey, ; name of subkey to open
 PHKEY phkResult ; handle to open key
)
ADVAPI32.RegOpenKeyExA(
 HKEY hKey, ; handle to open key
 LPCTSTR lpSubKey, ; subkey name
 DWORD ulOptions, ; reserved
 REGSAM samDesired, ; security access mask
 PHKEY phkResult ; handle to open key
)
xxxx.RegOpenUserClassesRoot(
 HANDLE hToken, ; token
 DWORD dwOptions, ; reserved; must be zero
 REGSAM samDesired, ; security access mask
 PHKEY phkResult ; receives key handle
)
xxxx.RegOverridePredefKey(
 HKEY hKey, ; predefined handle to key
 HKEY hNewHKey ; new handle to key
)
ADVAPI32.RegQueryInfoKeyA(
 HKEY hKey, ; handle to key
 LPTSTR lpClass, ; class buffer
 LPDWORD lpcClass, ; size of class buffer
 LPDWORD lpReserved, ; reserved
 LPDWORD lpcSubKeys, ; number of subkeys
 LPDWORD lpcMaxSubKeyLen, ; longest subkey name
 LPDWORD lpcMaxClassLen, ; longest class string
 LPDWORD lpcValues, ; number of value entries
 LPDWORD lpcMaxValueNameLen, ; longest value name
 LPDWORD lpcMaxValueLen, ; longest value data
 LPDWORD lpcbSecurityDescriptor, ; descriptor length
 PFILETIME lpftLastWriteTime ; last write time
)
KERNEL32.RegQueryMultipleValuesA(
 HKEY hKey, ; handle to key to query
 PVALENT val_list, ; array of value entries
 DWORD num_vals, ; size of array
 LPTSTR lpValueBuf, ; value information buffer
 LPDWORD ldwTotsize ; size of value information buffer
)
ADVAPI32.RegQueryValueA(
 HKEY hKey, ; handle to key to query
 LPCTSTR lpSubKey, ; subkey name
 LPTSTR lpValue, ; string buffer
 PLONG lpcbValue ; size of returned string
)
ADVAPI32.RegQueryValueExA(
 HKEY hKey, ; handle to key
 LPCTSTR lpValueName, ; value name
 LPDWORD lpReserved, ; reserved
 LPDWORD lpType, ; type buffer
 LPBYTE lpData, ; data buffer
 LPDWORD lpcbData ; size of data buffer
)
ADVAPI32.RegReplaceKeyA(
 HKEY hKey, ; handle to open key
 LPCTSTR lpSubKey, ; subkey name
 LPCTSTR lpNewFile, ; data file
 LPCTSTR lpOldFile ; backup file
)
ADVAPI32.RegRestoreKeyA(
 HKEY hKey, ; handle to key where restore begins
 LPCTSTR lpFile, ; registry file
 DWORD dwFlags ; options
)
ADVAPI32.RegSaveKeyA(
 HKEY hKey, ; handle to key
 LPCTSTR lpFile, ; data file
 LPSECURITY_ATTRIBUTES lpSecurityAttributes ; SD
)
ADVAPI32.RegSetValueA(
 HKEY hKey, ; handle to key
 LPCTSTR lpSubKey, ; subkey name
 DWORD dwType, ; information type
 LPCTSTR lpData, ; value data
 DWORD cbData ; size of value data
)
ADVAPI32.RegSetValueExA(
 HKEY hKey, ; handle to key
 LPCTSTR lpValueName, ; value name
 DWORD Reserved, ; reserved
 DWORD dwType, ; value type
 CONST BYTE *lpData, ; value data
 DWORD cbData ; size of value data
)
ADVAPI32.RegUnLoadKeyA(
 ;RegUnLoadKey
 HKEY hKey, ; handle to open keye
 LPCTSTR lpSubKey ; subkey name
)
USER32.ReleaseCapture(VOID)
)
USER32.ReleaseDC(
 HWND hWnd, ; handle to window
 HDC hDC ; handle to DC
)
KERNEL32.ReleaseMutex(
 HANDLE hMutex ; handle to mutex
)
KERNEL32.ReleaseSemaphore(
 HANDLE hSemaphore, ; handle to semaphore
 LONG lReleaseCount, ; count increment amount
 LPLONG lpPreviousCount ; previous count
)
KERNEL32.RemoveDirectoryA(
 LPCTSTR lpPathName ; directory name
)
GDI32.RemoveFontMemResourceEx(
 HANDLE fh ; handle to the font resource
)
GDI32.RemoveFontResourceA(
 LPCTSTR lpFileName ; name of font file
)
GDI32.RemoveFontResourceExA(
 LPCTSTR lpFileName, ; name of font file
 DWORD fl, ; font characteristics
 PVOID pdv ; Reserved.
)
USER32.RemoveMenu(
 HMENU hMenu, ; handle to menu
 UINT uPosition, ; menu item identifier or position
 UINT uFlags ; options
)
USER-DEFINED.RemovePreprocessInfo(
 LPMESSAGE lpMessage
)
USER32.RemovePropA(
 HWND hWnd, ; handle to window
 LPCTSTR lpString ; atom or string
)
xxxx.RemoveUsersFromEncryptedFile(
 LPCWSTR lpFileName, ; file name
 PENCRYPTION_CERTIFICATE_HASH_LIST pHashes ; hash list
)
xxxx.RemoveVectoredExceptionHandler(
 PVOID VectoredHandlerHandle
)
xxxx.RemoveWindowSubclass(
 HWND hWnd,
 SUBCLASSPROC pfnSubclass,
 UINT_PTR uIdSubclass
)
xxxx.ReplaceFile(
 LPCTSTR lpReplacedFileName, ; file name
 LPCTSTR lpReplacementFileName, ; replacement file
 LPCTSTR lpBackupFileName, ; optional backup file
 DWORD dwReplaceFlags, ; replace options
 LPVOID lpExclude, ; reserved
 LPVOID lpReserved ; reserved
)
COMDLG32.ReplaceTextA(
 LPFINDREPLACE lpfr ; initialization data
)
USER32.ReplyMessage(
 LRESULT lResult ; message-specific reply
)
ADVAPI32.ReportEventA(
 HANDLE hEventLog, ; handle to event log
 WORD wType, ; event type
 WORD wCategory, ; event category
 DWORD dwEventID, ; event identifier
 PSID lpUserSid, ; user security identifier
 WORD wNumStrings, ; number of strings to merge
 DWORD dwDataSize, ; size of binary data
 LPCTSTR *lpStrings, ; array of strings to merge
 LPVOID lpRawData ; binary data buffer
)
KERNEL32.RequestWakeupLatency(
 LATENCY_TIME latency ; latency requirement
)
GDI32.ResetDCA(
 HDC hdc, ; handle to DC
 CONST DEVMODE *lpInitData ; DC information
)
KERNEL32.ResetEvent(
 HANDLE hEvent ; handle to event
)
WINSPOOL.ResetPrinterA(
 HANDLE hPrinter, ; handle to printer
 LPPRINTER_DEFAULTS pDefault ; printer defaults
)
xxxx.ResetWriteWatch(
 LPVOID lpBaseAddress, ; base address
 SIZE_T dwRegionSize ; size of memory region
)
GDI32.ResizePalette(
 HPALETTE hpal, ; handle to logical palette
 UINT nEntries ; number of entries in logical palette
)
GDI32.RestoreDC(
 HDC hdc, ; handle to DC
 int nSavedDC ; restore state
)
KERNEL32.ResumeThread(
 HANDLE hThread ; handle to thread
)
USER32.ReuseDDElParam(
 LPARAM lParam, ; posted lParam to be reused
 UINT msgIn, ; received message
 UINT msgOut, ; posted message
 UINT_PTR uiLo, ; low-order word of new lParam
 UINT_PTR uiHi ; high-order word of new lParam
)
GDI32.RoundRect(
 HDC hdc, ; handle to DC
 int nLeftRect, ; x-coord of upper-left corner of rectangle
 int nTopRect, ; y-coord of upper-left corner of rectangle
 int nRightRect, ; x-coord of lower-right corner of rectangle
 int nBottomRect, ; y-coord of lower-right corner of rectangle
 int nWidth, ; width of ellipse
 int nHeight ; height of ellipse
)
MAPI32.RTFSync(
 LPMESSAGE lpMessage,
 ULONG ulFlags,
 BOOL FAR * lpfMessageUpdated
)
xxxx.RTM_ENTITY_EXPORT_METHOD(
 RTM_ENTITY_HANDLE CallerHandle,
 RTM_ENTITY_HANDLE CalleeHandle,
 RTM_ENTITY_METHOD_INPUT *Input,
 RTM_ENTITY_METHOD_OUTPUT *Output
)
xxxx.RTM_EVENT_CALLBACK(
 IRTM_ENTITY_HANDLE RtmRegHandle,
 RTM_EVENT_TYPE EventType,
 PVOID Context1,
 PVOID Context2
)
xxxx.RtmAddNextHop(
 RTM_ENTITY_HANDLE RtmRegHandle,
 PRTM_NEXTHOP_INFO NextHopInfo,
 PRTM_NEXTHOP_HANDLE NextHopHandle,
 PRTM_NEXTHOP_CHANGE_FLAGS ChangeFlags
)
RTM.RtmAddRoute(
 HANDLE ClientHandle, ; handle that identifies the client
 PVOID Route, ; pointer to new route structure
 DWORD TimeToLive, ; how long to keep the route
 DWORD Flags, ; best route change status
 PVOID CurBestRoute, ; pointer to new best route
 PVOID PrevBestRoute ; pointer to previous best route
)
xxxx.RtmAddRouteToDest(
 RTM_ENTITY_HANDLE RtmRegHandle,
 PRTM_ROUTE_HANDLE RouteHandle,
 PRTM_NET_ADDRESS DestAddress,
 PRTM_ROUTE_INFO RouteInfo,
 ULONG TimeToLive,
 RTM_ROUTE_LIST_HANDLE RouteListHandle,
 RTM_NOTIFY_FLAGS NotifyType,
 RTM_NOTIFY_HANDLE NotifyHandle,
 PRTM_ROUTE_CHANGE_FLAGS ChangeFlags
)
RTM.RtmBlockDeleteRoutes(
 HANDLE ClientHandle, ; handle that identifies client
 DWORD EnumerationFlags, ; flags that specify type of criteria
 PVOID CriteriaRoute ; structure that hold criteria values
)
xxxx.RtmBlockMethods(
 RTM_ENTITY_HANDLE RtmRegHandle,
 HANDLE TargetHandle,
 UCHAR TargetType,
 DWORD BlockingFlag
)
RTM.RtmCloseEnumerationHandle(
 HANDLE EnumerationHandle ; handle that identifies enumeration
)
xxxx.RtmCreateDestEnum(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_VIEW_SET TargetViews,
 RTM_ENUM_FLAGS EnumFlags,
 PRTM_NET_ADDRESS NetAddress,
 ULONG ProtocolId,
 PRTM_ENUM_HANDLE RtmEnumHandle
)
RTM.RtmCreateEnumerationHandle(
 DWORD ProtocolFamily, ; type of network (IP or IPX)
 DWORD EnumerationFlags, ; flags that specify type of criteria
 PVOID CriteriaRoute ; structure that holds criteria values
)
xxxx.RtmCreateNextHopEnum(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ENUM_FLAGS EnumFlags,
 PRTM_NET_ADDRESS NetAddress,
 PRTM_ENUM_HANDLE RtmEnumHandle
)
xxxx.RtmCreateRouteEnum(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_DEST_HANDLE DestHandle,
 RTM_VIEW_SET TargetViews,
 RTM_ENUM_FLAGS EnumFlags,
 PRTM_NET_ADDRESS StartDest,
 RTM_MATCH_FLAGS MatchingFlags,
 PRTM_ROUTE_INFO CriteriaRoute,
 ULONG CriteriaInterface,
 PRTM_ENUM_HANDLE RtmEnumHandle
)
xxxx.RtmCreateRouteList(
 RTM_ENTITY_HANDLE RtmRegHandle,
 PRTM_ROUTE_LIST_HANDLE RouteListHandle
)
xxxx.RtmCreateRouteListEnum(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ROUTE_LIST_HANDLE RouteListHandle,
 PRTM_ENUM_HANDLE RtmEnumHandle
)
xxxx.RtmDeleteEnumHandle(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ENUM_HANDLE EnumHandle
)
xxxx.RtmDeleteNextHop(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_NEXTHOP_HANDLE NextHopHandle,
 PRTM_NEXTHOP_INFO NextHopInfo
)
RTM.RtmDeleteRoute(
 HANDLE ClientHandle, ; handle that identifies client
 PVOID Route, ; pointer to route structure
 DWORD Flags, ; best-route change status
 PVOID CurBestRoute ; pointer to new best route
)
xxxx.RtmDeleteRouteList(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ROUTE_LIST_HANDLE RouteListHandle
)
xxxx.RtmDeleteRouteToDest(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ROUTE_HANDLE RouteHandle,
 PRTM_ROUTE_CHANGE_FLAGS ChangeFlags
)
RTM.RtmDequeueRouteChangeMessage(
 HANDLE ClientHandle, ; handle that identifies the client
 DWORD Flags, ; type of change message
 PVOID CurBestRoute, ; the new best route
 PVOID PrevBestRoute ; the previous best route
)
RTM.RtmDeregisterClient(
 HANDLE ClientHandle ; handle that identifies the client
)
xxxx.RtmDeregisterEntity(
 RTM_ENTITY_HANDLE RtmRegHandle
)
xxxx.RtmDeregisterFromChangeNotification(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_NOTIFY_HANDLE NotifyHandle
)
RTM.RtmEnumerateGetNextRoute(
 HANDLE EnumerationHandle, ; handle that identifies enumeration
 PVOID Route ; structure to receive next route
)
xxxx.RtmFindNextHop(
 RTM_ENTITY_HANDLE RtmRegHandle,
 PRTM_NEXTHOP_INFO NextHopInfo,
 PRTM_NEXTHOP_HANDLE NextHopHandle,
 PRTM_NEXTHOP_INFO *NextHopPointer
)
xxxx.RtmGetChangedDests(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_NOTIFY_HANDLE NotifyHandle,
 PUINT NumDests,
 PRTM_DEST_INFO ChangedDests
)
xxxx.RtmGetChangeStatus(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_NOTIFY_HANDLE NotifyHandle,
 RTM_DEST_HANDLE DestHandle,
 PBOOL ChangeStatus
)
xxxx.RtmGetDestInfo(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_DEST_HANDLE DestHandle,
 ULONG ProtocolId,
 RTM_VIEW_SET TargetViews,
 PRTM_DEST_INFO DestInfo
)
xxxx.RtmGetEntityInfo(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ENTITY_HANDLE EntityHandle,
 PRTM_ENTITY_INFO EntityInfo
)
xxxx.RtmGetEntityMethods(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ENTITY_HANDLE EntityHandle,
 PUINT NumMethods,
 PRTM_ENTITY_EXPORT_METHOD ExptMethods
)
xxxx.RtmGetEnumDests(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ENUM_HANDLE EnumHandle,
 PUINT NumDests,
 PRTM_DEST_INFO DestInfos
)
xxxx.RtmGetEnumNextHops(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ENUM_HANDLE EnumHandle,
 PUINT NumNextHops,
 PRTM_NEXTHOP_HANDLE NextHopHandles
)
xxxx.RtmGetEnumRoutes(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ENUM_HANDLE EnumHandle,
 PUINT NumRoutes,
 PRTM_ROUTE_HANDLE RouteHandles
)
xxxx.RtmGetExactMatchDestination(
 RTM_ENTITY_HANDLE RtmRegHandle,
 PRTM_NET_ADDRESS DestAddress,
 ULONG ProtocolId,
 RTM_VIEW_SET TargetViews,
 PRTM_DEST_INFO DestInfo
)
xxxx.RtmGetExactMatchRoute(
 RTM_ENTITY_HANDLE RtmRegHandle,
 PRTM_NET_ADDRESS DestAddress,
 RTM_MATCH_FLAGS MatchingFlags,
 PRTM_ROUTE_INFO RouteInfo,
 ULONG InterfaceIndex,
 RTM_VIEW_SET TargetViews,
 PRTM_ROUTE_HANDLE RouteHandle
)
RTM.RtmGetFirstRoute(
 DWORD ProtocolFamily, ; type of network (IP or IPX)
 DWORD EnumerationFlags, ; flags that specify type of criteria
 PVOID Route ; structure for criteria values and returned route
)
xxxx.RtmGetLessSpecificDestination(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_DEST_HANDLE DestHandle,
 ULONG ProtocolId,
 RTM_VIEW_SET TargetViews,
 PRTM_DEST_INFO DestInfo
)
xxxx.RtmGetListEnumRoutes(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ENUM_HANDLE EnumHandle,
 PUINT NumRoutes,
 PRTM_ROUTE_HANDLE RouteHandles
)
xxxx.RtmGetMostSpecificDestination(
 RTM_ENTITY_HANDLE RtmRegHandle,
 PRTM_NET_ADDRESS DestAddress,
 ULONG ProtocolId,
 RTM_VIEW_SET TargetViews,
 PRTM_DEST_INFO DestInfo
)
RTM.RtmGetNetworkCount(
 DWORD ProtocolFamily ; type of network (IP or IPX)
)
xxxx.RtmGetNextHopInfo(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_NEXTHOP_HANDLE NextHopHandle,
 PRTM_NEXTHOP_INFO NextHopInfo
)
xxxx.RtmGetNextHopPointer(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_NEXTHOP_HANDLE NextHopHandle,
 PRTM_NEXTHOP_INFO *NextHopPointer
)
RTM.RtmGetNextRoute(
 DWORD ProtocolFamily, ; type of network (IP or IPX)
 DWORD EnumerationFlags, ; flags that specify type of criteria
 PVOID Route ; structure for criteria values and returned route
)
xxxx.RtmGetOpaqueInformationPointer(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_DEST_HANDLE DestHandle,
 PVOID *OpaqueInfoPointer
)
xxxx.RtmGetRegisteredEntities(
 RTM_ENTITY_HANDLE RtmRegHandle,
 PUINT NumEntities,
 PRTM_ENTITY_HANDLE EntityHandles,
 PRTM_ENTITY_INFO EntityInfos
)
RTM.RtmGetRouteAge(
 PVOID Route ; pointer to route structure
)
xxxx.RtmGetRouteInfo(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ROUTE_HANDLE RouteHandle,
 PRTM_ROUTE_INFO RouteInfo,
 PRTM_NET_ADDRESS DestAddress
)
xxxx.RtmGetRoutePointer(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ROUTE_HANDLE RouteHandle,
 PRTM_ROUTE_INFO *RoutePointer
)
xxxx.RtmHoldDestination(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_DEST_HANDLE DestHandle,
 RTM_VIEW_SET TargetViews,
 ULONG HoldTime
)
xxxx.RtmIgnoreChangedDests(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_NOTIFY_HANDLE NotifyHandle,
 UINT NumDests,
 PRTM_DEST_HANDLE ChangedDests
)
xxxx.RtmInsertInRouteList(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ROUTE_LIST_HANDLE RouteListHandle,
 UINT NumRoutes,
 PRTM_ROUTE_HANDLE RouteHandles
)
xxxx.RtmInvokeMethod(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ENTITY_HANDLE EntityHandle,
 PRTM_ENTITY_METHOD_INPUT Input,
 PUINT OutputSize,
 PRTM_ENTITY_METHOD_OUTPUT Output
)
xxxx.RtmIsBestRoute(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ROUTE_HANDLE RouteHandle,
 PRTM_VIEW_SET BestInViews
)
xxxx.RtmIsMarkedForChangeNotification(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_NOTIFY_HANDLE NotifyHandle,
 RTM_DEST_HANDLE DestHandle,
 PBOOL DestMarked
)
RTM.RtmIsRoute(
 DWORD ProtocolFamily, ; specifies type of network
 PVOID Network, ; specifies the network
 PVOID BestRoute ; receives best route for the network
)
xxxx.RtmLockDestination(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_DEST_HANDLE DestHandle,
 BOOL Exclusive,
 BOOL LockDest
)
xxxx.RtmLockNextHop(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_NEXTHOP_HANDLE NextHopHandle,
 BOOL Exclusive,
 BOOL LockNextHop,
 PRTM_NEXTHOP_INFO *NextHopPointer
)
xxxx.RtmLockRoute(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ROUTE_HANDLE RouteHandle,
 BOOL Exclusive,
 BOOL LockRoute,
 PRTM_ROUTE_INFO *RoutePointer
)
xxxx.RtmMarkDestForChangeNotification(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_NOTIFY_HANDLE NotifyHandle,
 RTM_DEST_HANDLE DestHandle,
 BOOL MarkDest
)
xxxx.RtmReferenceHandles(
 RTM_ENTITY_HANDLE RtmRegHandle,
 UINT NumHandles,
 HANDLE *RtmHandles
)
RTM.RtmRegisterClient(
 DWORD ProtocolFamily, ; identifier of protocol family
 DWORD RoutingProtocol, ; identifier of routing protocol
 HANDLE ChangeEvent, ; event to signal when best routes change
 DWORD Flags ; flags to indicate special handling of routing protocol
)
xxxx.RtmRegisterEntity(
 PRTM_ENTITY_INFO RtmEntityInfo,
 PRTM_ENTITY_EXPORT_METHODS ExportMethods,
 RTM_EVENT_CALLBACK EventCallback,
 BOOL ReserveOpaquePointer,
 PRTM_REGN_PROFILE RtmRegProfile,
 PRTM_ENTITY_HANDLE RtmRegHandle
)
xxxx.RtmRegisterForChangeNotification(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_VIEW_SET TargetViews,
 RTM_NOTIFY_FLAGS NotifyFlags,
 PVOID NotifyContext,
 PRTM_NOTIFY_HANDLE NotifyHandle
)
xxxx.RtmReleaseChangedDests(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_NOTIFY_HANDLE NotifyHandle,
 UINT NumDests,
 PRTM_DEST_INFO ChangedDests
)
xxxx.RtmReleaseDestInfo(
 RTM_ENTITY_HANDLE RtmRegHandle,
 PRTM_DEST_INFO DestInfo
)
xxxx.RtmReleaseDests(
 RTM_ENTITY_HANDLE RtmRegHandle,
 UINT NumDests,
 PRTM_DEST_INFO DestInfos
)
xxxx.RtmReleaseEntities(
 RTM_ENTITY_HANDLE RtmRegHandle,
 UINT NumEntities,
 PRTM_ENTITY_HANDLE EntityHandles
)
xxxx.RtmReleaseEntityInfo(
 RTM_ENTITY_HANDLE RtmRegHandle,
 PRTM_ENTITY_INFO EntityInfo
)
xxxx.RtmReleaseNextHopInfo(
 RTM_ENTITY_HANDLE RtmRegHandle,
 PRTM_NEXTHOP_INFO NextHopInfo
)
xxxx.RtmReleaseNextHops(
 RTM_ENTITY_HANDLE RtmRegHandle,
 UINT NumNextHops,
 PRTM_NEXTHOP_HANDLE NextHopHandles
)
xxxx.RtmReleaseRouteInfo(
 RTM_ENTITY_HANDLE RtmRegHandle,
 PRTM_ROUTE_INFO RouteInfo
)
xxxx.RtmReleaseRoutes(
 RTM_ENTITY_HANDLE RtmRegHandle,
 UINT NumRoutes,
 PRTM_ROUTE_HANDLE RouteHandles
)
xxxx.RtmUpdateAndUnlockRoute(
 RTM_ENTITY_HANDLE RtmRegHandle,
 RTM_ROUTE_HANDLE RouteHandle,
 ULONG TimeToLive,
 RTM_ROUTE_LIST_HANDLE RouteListHandle,
 RTM_NOTIFY_FLAGS NotifyType,
 RTM_NOTIFY_HANDLE NotifyHandle,
 PRTM_ROUTE_CHANGE_FLAGS ChangeFlags
)
GDI32.SaveDC(
 HDC hdc ; handle to DC
)
GDI32.ScaleViewportExtEx(
 HDC hdc, ; handle to device context
 int Xnum, ; horizontal multiplicand
 int Xdenom, ; horizontal divisor
 int Ynum, ; vertical multiplicand
 int Ydenom, ; vertical divisor
 LPSIZE lpSize ; previous viewport extents
)
GDI32.ScaleWindowExtEx(
 HDC hdc, ; handle to device context
 int Xnum, ; horizontal multiplicand
 int Xdenom, ; horizontal divisor
 int Ynum, ; vertical multiplicand
 int Ydenom, ; vertical divisor
 LPSIZE lpSize ; previous window extents
)
MAPI32.ScBinFromHexBounded(
 LPTSTR sz,
 LPBYTE pb,
 ULONG cb
)
MAPI32.ScCopyNotifications(
 int cntf,
 LPNOTIFICATION rgntf,
 LPVOID pvDst,
 ULONG FAR * pcb
)
MAPI32.ScCopyProps(
 int cprop,
 LPSPropValue rgprop,
 LPVOID pvDst,
 ULONG FAR * pcb
)
MAPI32.ScCountNotifications(
 int cntf,
 LPNOTIFICATION rgntf,
 ULONG FAR * pcb
)
MAPI32.ScCountProps(
 int cprop,
 LPSPropValue rgprop,
 ULONG FAR * pcb
)
MAPI32.ScCreateConversationIndex(
 ULONG cbParent,
 LPBYTE lpbParent,
 ULONG FAR* lpcbIndex,
 LPBYTE FAR * lppbIndex
)
MAPI32.ScDupPropset(
 int cprop,
 LPSPropValue rgprop,
 LPALLOCATEBUFFER lpAllocateBuffer,
 LPSPropValue FAR * prgprop
)
WINSPOOL.ScheduleJob(
 HANDLE hPrinter, ; handle to printer
 DWORD dwJobID ; print job identifier
)
MAPI32.ScInitMapiUtil(
 ULONG ulFlags
)
MAPI32.ScLocalPathFromUNC(
 LPSTR szUNC,
 LPSTR szLocal,
 UINT cchLocal
)
MAPI32.ScMAPIXFromCMC(
 CMC_SESSION cmcsession,
 ULONG ulFlags,
 LPCIID lpInterface,
 LPMAPISESSION FAR * lppMAPISession
)
MAPI32.ScMAPIXFromSMAPI(
 LHANDLE lhSimpleSession,
 ULONG ulFlags,
 LPCIID lpInterface,
 LPMAPISESSION FAR * lppMAPISession
)
SCRNSAVE.ScreenSaverConfigureDialog(
 HWND hDlg,
 UINT message,
 WPARAM wParam,
 LPARAM lParam
)
SCRNSAVE.ScreenSaverProc(
 HWND hWnd,
 UINT message,
 WPARAM wParam,
 LPARAM lParam
)
USER32.ScreenToClient(
 HWND hWnd, ; handle to window
 LPPOINT lpPoint ; screen coordinates
)
MAPI32.ScRelocNotifications(
 int cntf,
 LPNOTIFICATION rgntf,
 LPVOID pvBaseOld,
 LPVOID pvBaseNew,
 ULONG FAR * pcb
)
MAPI32.ScRelocProps(
 int cprop,
 LPSPropValue rgprop,
 LPVOID pvBaseOld,
 LPVOID pvBaseNew,
 ULONG FAR * pcb
)
xxxx.ScriptApplyDigitSubstitution(
 const SCRIPT_DIGITSUBSTITUTE *psds,
 SCRIPT_CONTROL *psc,
 SCRIPT_STATE *pss
)
xxxx.ScriptApplyLogicalWidth(
 const int *piDx,
 int cChars,
 int cGlyphs,
 const WORD *pwLogClust,
 const SCRIPT_VISATTR *psva,
 const int *piAdvance,
 const SCRIPT_ANALYSIS *psa,
 ABC *pABC,
 int *piJustify
)
xxxx.ScriptBreak(
 const WCHAR *pwcChars,
 int cChars,
 const SCRIPT_ANALYSIS *psa,
 SCRIPT_LOGATTR *psla
)
xxxx.ScriptCacheGetHeight(
 HDC hdc,
 SCRIPT_CACHE *psc,
 long *tmHeight
)
xxxx.ScriptCPtoX(
 int iCP,
 BOOL fTrailing,
 int cChars,
 int cGlyphs,
 const WORD *pwLogClust,
 const SCRIPT_VISATTR *psva,
 const int *piAdvance,
 const SCRIPT_ANALYSIS *psa,
 int *piX
)
xxxx.ScriptFreeCache(
 SCRIPT_CACHE *psc
)
xxxx.ScriptGetCMap(
 HDC hdc,
 SCRIPT_CACHE *psc,
 const WCHAR *pwcInChars,
 int cChars,
 DWORD dwFlags,
 WORD *pwOutGlyphs
)
xxxx.ScriptGetFontProperties(
 HDC hdc,
 SCRIPT_CACHE *psc,
 SCRIPT_FONTPROPERTIES *sfp
)
xxxx.ScriptGetGlyphABCWidth(
 HDC hdc,
 SCRIPT_CACHE *psc,
 WORD wGlyph,
 ABC *pABC
)
xxxx.ScriptGetLogicalWidths(
 const SCRIPT_ANALYSIS *psa,
 int cChars,
 int cGlyphs,
 const int *piGlyphWidth,
 const WORD *pwLogClust,
 const SCRIPT_VISATTR *psva,
 int *piDx
)
xxxx.ScriptGetProperties(
 const SCRIPT_PROPERTIES ***ppSp,
 int *piNumScripts
)
xxxx.ScriptIsComplex(
 const WCHAR *pwcInChars,
 int cInChars,
 DWORD dwFlags
)
xxxx.ScriptItemize(
 const WCHAR *pwcInChars,
 int cInChars,
 int cMaxItems,
 const SCRIPT_CONTROL *psControl,
 const SCRIPT_STATE *psState,
 SCRIPT_ITEM *pItems,
 int *pcItems
)
xxxx.ScriptJustify(
 const SCRIPT_VISATTR *psva,
 const int *piAdvance,
 int cGlyphs,
 int iDx,
 int iMinKashida,
 int *piJustify
)
xxxx.ScriptLayout(
 int cRuns,
 const BYTE *pbLevel,
 int *piVisualToLogical,
 int *piLogicalToVisual
)
xxxx.ScriptPlace(
 HDC hdc,
 SCRIPT_CACHE *psc,
 const WORD *pwGlyphs,
 int cGlyphs,
 const SCRIPT_VISATTR *psva,
 SCRIPT_ANALYSIS *psa,
 int *piAdvance,
 GOFFSET *pGoffset,
 ABC *pABC
)
xxxx.ScriptRecordDigitSubstitution(
 LCID Locale,
 SCRIPT_DIGITSUBSTITUTE *psds
)
xxxx.ScriptShape(
 HDC hdc,
 SCRIPT_CACHE *psc,
 const WCHAR *pwcChars,
 int cChars,
 int cMaxGlyphs,
 SCRIPT_ANALYSIS *psa,
 WORD *pwOutGlyphs,
 WORD *pwLogClust,
 SCRIPT_VISATTR *psva,
 int *pcGlyphs
)
xxxx.ScriptString_pcOutChars(
 SCRIPT_STRING_ANALYSIS ssa
)
xxxx.ScriptString_pLogAttr(
 SCRIPT_STRING_ANALYSIS ssa
)
xxxx.ScriptString_pSize(
 SCRIPT_STRING_ANALYSIS ssa
)
xxxx.ScriptStringAnalyse(
 HDC hdc,
 const void *pString,
 int cString,
 int cGlyphs,
 int iCharset,
 DWORD dwFlags,
 int iReqWidth,
 SCRIPT_CONTROL *psControl,
 SCRIPT_STATE *psState,
 const int *piDx,
 SCRIPT_TABDEF *pTabdef,
 const BYTE *pbInClass,
 SCRIPT_STRING_ANALYSIS *pssa
)
xxxx.ScriptStringCPtoX(
 SCRIPT_STRING_ANALYSIS ssa,
 int icp,
 BOOL fTrailing,
 int *pX
)
xxxx.ScriptStringFree(
 SCRIPT_STRING_ANALYSIS *pssa
)
xxxx.ScriptStringGetLogicalWidths(
 SCRIPT_STRING_ANALYSIS ssa,
 int *piDx
)
xxxx.ScriptStringGetOrder(
 SCRIPT_STRING_ANALYSIS ssa,
 UINT *puOrder
)
xxxx.ScriptStringOut(
 SCRIPT_STRING_ANALYSIS ssa,
 int iX,
 int iY,
 UINT uOptions,
 const RECT *prc,
 int iMinSel,
 int iMaxSel,
 BOOL fDisabled
)
xxxx.ScriptStringValidate(
 SCRIPT_STRING_ANALYSIS ssa
)
xxxx.ScriptStringXtoCP(
 SCRIPT_STRING_ANALYSIS ssa,
 int iX,
 int *piCh,
 int *piTrailing
)
xxxx.ScriptTextOut(
 const HDC hdc,
 SCRIPT_CACHE *psc,
 int x,
 int y,
 UINT fuOptions,
 const RECT *lprc,
 const SCRIPT_ANALYSIS *psa,
 const WCHAR *pwcReserved,
 int iReserved,
 const WORD *pwGlyphs,
 int cGlyphs,
 const int *piAdvance,
 const int *piJustify,
 const GOFFSET *pGoffset
)
xxxx.ScriptXtoCP(
 int iX,
 int cChars,
 int cGlyphs,
 const WORD *pwLogClust,
 const SCRIPT_VISATTR *psva,
 const int *piAdvance,
 const SCRIPT_ANALYSIS *psa,
 int *piCP,
 int *piTrailing
)
KERNEL32.ScrollConsoleScreenBufferA(
 HANDLE hConsoleOutput, ; handle to screen buffer
 CONST SMALL_RECT *lpScrollRectangle, ; scroll rectangle
 CONST SMALL_RECT *lpClipRectangle, ; clipping rectangle
 COORD dwDestinationOrigin, ; new location
 CONST CHAR_INFO *lpFill ; fill character and color
)
USER32.ScrollDC(
 HDC hDC, ; handle to DC
 int dx, ; horizontal scrolling
 int dy, ; vertical scrolling
 CONST RECT *lprcScroll, ; scrolling rectangle
 CONST RECT *lprcClip, ; clipping rectangle
 HRGN hrgnUpdate, ; handle to scrolling region
 LPRECT lprcUpdate ; update rectangle
)
USER32.ScrollWindow(
 HWND hWnd, ; handle to window
 int XAmount, ; horizontal scrolling
 int YAmount, ; vertical scrolling
 CONST RECT *lpRect, ; client area
 CONST RECT *lpClipRect ; clipping rectangle
)
USER32.ScrollWindowEx(
 HWND hWnd, ; handle to window
 int dx, ; horizontal scrolling
 int dy, ; vertical scrolling
 CONST RECT *prcScroll, ; client area
 CONST RECT *prcClip, ; clipping rectangle
 HRGN hrgnUpdate, ; handle to update region
 LPRECT prcUpdate, ; invalidated region
 UINT flags ; scrolling options
)
MAPI32.ScUNCFromLocalPath(
 LPSTR szLocal,
 LPSTR szUNC,
 UINT cchUNC
)
KERNEL32.SearchPathA(
 LPCTSTR lpPath, ; search path
 LPCTSTR lpFileName, ; file name
 LPCTSTR lpExtension, ; file extension
 DWORD nBufferLength, ; size of buffer
 LPTSTR lpBuffer, ; found file name buffer
 LPTSTR *lpFilePart ; file component
)
GDI32.SelectClipPath(
 HDC hdc, ; handle to DC
 int iMode ; clipping mode
)
GDI32.SelectClipRgn(
 HDC hdc, ; handle to DC
 HRGN hrgn ; handle to region
)
GDI32.SelectObject(
 HDC hdc, ; handle to DC
 HGDIOBJ hgdiobj ; handle to object
)
GDI32.SelectPalette(
 HDC hdc, ; handle to DC
 HPALETTE hpal, ; handle to logical palette
 BOOL bForceBackground ; foreground or background mode
)
USER-DEFINED.SendAsyncProc(
 HWND hwnd, ; handle to destination window
 UINT uMsg, ; message
 ULONG_PTR dwData, ; application-defined value
 LRESULT lResult ; result of message processing
)
USER32.SendDlgItemMessageA(
 HWND hDlg, ; handle to dialog box
 int nIDDlgItem, ; control identifier
 UINT Msg, ; message to send
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
USER32.SendInput(
 UINT nInputs, ; count of input events
 LPINPUT pInputs, ; array of input events
 int cbSize ; size of structure
)
USER32.SendMessageA(
 HWND hWnd, ; handle to destination window
 UINT Msg, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
USER32.SendMessageCallbackA(
 HWND hWnd, ; handle to window
 UINT Msg, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam, ; second message parameter
 SENDASYNCPROC lpCallBack, ; callback function
 ULONG_PTR dwData ; application-defined value
)
USER32.SendMessageTimeoutA(
 HWND hWnd, ; handle to window
 UINT Msg, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam, ; second message parameter
 UINT fuFlags, ; send options
 UINT uTimeout, ; time-out duration
 PDWORD_PTR lpdwResult ; return value for synchronous call
)
USER32.SendNotifyMessageA(
 HWND hWnd, ; handle to window
 UINT Msg, ; message
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
USER-DEFINED.ServiceMain(
 DWORD dwArgc, ; number of arguments
 LPTSTR *lpszArgv ; array of arguments
)
USER-DEFINED.SERVICEWIZARDDLGPROC(
 HWND hDlg,
 UINT wMsgID,
 WPARAM wParam,
 LPARAM lParam
)
GDI32.SetAbortProc(
 HDC hdc, ; handle to DC
 ABORTPROC lpAbortProc ; abort function
)
USER32.SetActiveWindow(
 HWND hWnd ; handle to window
)
GDI32.SetArcDirection(
 HDC hdc, ; handle to device context
 int ArcDirection ; new arc direction
)
MAPI32.SetAttribIMsgOnIStg(
 LPVOID lpObject,
 LPSPropTagArray lpPropTags,
 LPSPropAttrArray lpPropAttrs,
 LPSPropProblemArray FAR * lppPropProblems
)
xxxx.SetBitmapBits(
 HBITMAP hbmp, ; handle to bitmap
 DWORD cBytes, ; number of bytes in bitmap array
 CONST VOID *lpBits ; array with bitmap bits
)
GDI32.SetBitmapDimensionEx(
 HBITMAP hBitmap, ; handle to bitmap
 int nWidth, ; bitmap width in .01-mm units
 int nHeight, ; bitmap height in .01-mm units
 LPSIZE lpSize ; original dimensions
)
GDI32.SetBkColor(
 HDC hdc, ; handle to DC
 COLORREF crColor ; background color value
)
GDI32.SetBkMode(
 HDC hdc, ; handle to DC
 int iBkMode ; background mode
)
GDI32.SetBoundsRect(
 HDC hdc, ; handle to DC
 CONST RECT *lprcBounds, ; bounding rectangle
 UINT flags ; rectangle combination option
)
GDI32.SetBrushOrgEx(
 HDC hdc, ; handle to device context
 int nXOrg, ; x-coord of new origin
 int nYOrg, ; y-coord of new origin
 LPPOINT lppt ; points to previous brush origin
)
xxxx.SetCalendarInfo(
 LCID Locale, ; locale
 CALID Calendar, ; calendar
 CALTYPE CalType, ; calendar information type
 LPCTSTR lpCalData ; calendar data
)
USER32.SetCapture(
 HWND hWnd ; handle to window
)
USER32.SetCaretBlinkTime(
 UINT uMSeconds ; blink time
)
USER32.SetCaretPos(
 int X, ; horizontal position
 int Y ; vertical position
)
USER32.SetClassLongA(
 HWND hWnd, ; handle to window
 int nIndex, ; index of value to change
 LONG dwNewLong ; new value
)
USER32.SetClassLongPtr(
 HWND hWnd, ; handle to window
 int nIndex, ; index of value to change
 LONG_PTR dwNewLong ; new value
)
USER32.SetClassWord(
 HWND hWnd, ; handle to window
 int nIndex, ; index of value to change
 WORD wNewWord ; new value
)
USER32.SetClipboardData(
 UINT uFormat, ; clipboard format
 HANDLE hMem ; data handle
)
USER32.SetClipboardViewer(
 HWND hWndNewViewer ; handle to clipboard viewer window
)
GDI32.SetColorAdjustment(
 HDC hdc, ; handle to DC
 CONST COLORADJUSTMENT *lpca ; color adjustment values
)
KERNEL32.SetCommBreak(
 HANDLE hFile ; handle to communications device
)
KERNEL32.SetCommConfig(
 HANDLE hCommDev, ; handle to communications device
 LPCOMMCONFIG lpCC, ; configuration services
 DWORD dwSize ; size of structure
)
KERNEL32.SetCommMask(
 HANDLE hFile, ; handle to communications device
 DWORD dwEvtMask ; mask that identifies enabled events
)
KERNEL32.SetCommState(
 HANDLE hFile, ; handle to communications device
 LPDCB lpDCB ; device-control block
)
KERNEL32.SetCommTimeouts(
 HANDLE hFile, ; handle to comm device
 LPCOMMTIMEOUTS lpCommTimeouts ; time-out values
)
KERNEL32.SetComputerNameA(
 LPCTSTR lpComputerName ; computer name
)
KERNEL32.SetComputerNameEx(
 COMPUTER_NAME_FORMAT NameType, ; name type
 LPCTSTR lpBuffer ; new name buffer
)
KERNEL32.SetConsoleActiveScreenBuffer(
 HANDLE hConsoleOutput ; handle to screen buffer
)
KERNEL32.SetConsoleCP(
 UINT wCodePageID ; code page
)
KERNEL32.SetConsoleCtrlHandler(
 PHANDLER_ROUTINE HandlerRoutine, ; handler function
 BOOL Add ; add or remove handler
)
KERNEL32.SetConsoleCursorInfo(
 HANDLE hConsoleOutput, ; handle to screen buffer
 CONST CONSOLE_CURSOR_INFO *lpConsoleCursorInfo ; cursor information
)
KERNEL32.SetConsoleCursorPosition(
 HANDLE hConsoleOutput, ; handle to screen buffer
 COORD dwCursorPosition ; new cursor coordinates
)
KERNEL32.SetConsoleMode(
 HANDLE hConsoleHandle, ; handle to console input or screen buffer
 DWORD dwMode ; input or output mode
)
KERNEL32.SetConsoleOutputCP(
 UINT wCodePageID ; code page
)
KERNEL32.SetConsoleScreenBufferSize(
 HANDLE hConsoleOutput, ; handle to screen buffer
 COORD dwSize ; new screen buffer size
)
KERNEL32.SetConsoleTextAttribute(
 HANDLE hConsoleOutput, ; handle to screen buffer
 WORD wAttributes ; text and background colors
)
KERNEL32.SetConsoleTitleA(
 LPCTSTR lpConsoleTitle ; new console title
)
KERNEL32.SetConsoleWindowInfo(
 HANDLE hConsoleOutput, ; handle to screen buffer
 BOOL bAbsolute, ; coordinate type
 CONST SMALL_RECT *lpConsoleWindow ; window corners
)
KERNEL32.SetCriticalSectionSpinCount(
 LPCRITICAL_SECTION lpCriticalSection, ; critical section
 DWORD dwSpinCount ; spin count
)
KERNEL32.SetCurrentDirectoryA(
 LPCTSTR lpPathName ; new directory name
)
USER32.SetCursor(
 HCURSOR hCursor ; handle to cursor
)
USER32.SetCursorPos(
 int X, ; horizontal position
 int Y ; vertical position
)
GDI32.SetDCBrushColor(
 HDC hdc, ; handle to DC
 COLORREF crColor ; new brush color
)
GDI32.SetDCPenColor(
 HDC hdc, ; handle to DC
 COLORREF crColor ; new pen color
)
USER32.SetDebugErrorLevel(OBSOLETE)
SetDefaultCommConfig(
 LPCTSTR lpszName, ; device name string
 LPCOMMCONFIG lpCC, ; configuration information
 DWORD dwSize ; size of structure
)
xxxx.SetDefaultPrinterA(
 LPCTSTR pszPrinter ; default printer name
)
GDI32.SetDIBColorTable(
 HDC hdc, ; handle to DC
 UINT uStartIndex, ; color table index of first entry
 UINT cEntries, ; number of color table entries
 CONST RGBQUAD *pColors ; array of color table entries
)
GDI32.SetDIBits(
 HDC hdc, ; handle to DC
 HBITMAP hbmp, ; handle to bitmap
 UINT uStartScan, ; starting scan line
 UINT cScanLines, ; number of scan lines
 CONST VOID *lpvBits, ; array of bitmap bits
 CONST BITMAPINFO *lpbmi, ; bitmap data
 UINT fuColorUse ; type of color indexes to use
)
GDI32.SetDIBitsToDevice(
 HDC hdc, ; handle to DC
 int XDest, ; x-coord of destination upper-left corner
 int YDest, ; y-coord of destination upper-left corner
 DWORD dwWidth, ; source rectangle width
 DWORD dwHeight, ; source rectangle height
 int XSrc, ; x-coord of source lower-left corner
 int YSrc, ; y-coord of source lower-left corner
 UINT uStartScan, ; first scan line in array
 UINT cScanLines, ; number of scan lines
 CONST VOID *lpvBits, ; array of DIB bits
 CONST BITMAPINFO *lpbmi, ; bitmap information
 UINT fuColorUse ; RGB or palette indexes
)
USER32.SetDlgItemInt(
 HWND hDlg, ; handle to dialog box
 int nIDDlgItem, ; control identifier
 UINT uValue, ; value to set
 BOOL bSigned ; signed or unsigned indicator
)
USER32.SetDlgItemTextA(
 HWND hDlg, ; handle to dialog box
 int nIDDlgItem, ; control identifier
 LPCTSTR lpString ; text to set
)
USER32.SetDoubleClickTime(
 UINT uInterval ; double-click interval
)
KERNEL32.SetEndOfFile(
 HANDLE hFile ; handle to file
)
GDI32.SetEnhMetaFileBits(
 UINT cbBuffer, ; buffer size
 CONST BYTE *lpData ; enhanced metafile data buffer
)
KERNEL32.SetEnvironmentVariableA(
 LPCTSTR lpName, ; environment variable name
 LPCTSTR lpValue ; new value for variable
)
KERNEL32.SetErrorMode(
 UINT uMode ; process error mode
)
KERNEL32.SetEvent(
 HANDLE hEvent ; handle to event
)
KERNEL32.SetFileApisToANSI(VOID)
)
KERNEL32.SetFileApisToOEM(VOID)
)
KERNEL32.SetFileAttributesA(
 LPCTSTR lpFileName, ; file name
 DWORD dwFileAttributes ; attributes
)
KERNEL32.SetFilePointer(
 HANDLE hFile, ; handle to file
 LONG lDistanceToMove, ; bytes to move pointer
 PLONG lpDistanceToMoveHigh, ; bytes to move pointer
 DWORD dwMoveMethod ; starting point
)
KERNEL32.SetFilePointerEx(
 HANDLE hFile, ; handle to file
 LARGE_INTEGER liDistanceToMove, ; bytes to move pointer
 PLARGE_INTEGER lpNewFilePointer, ; new file pointer
 DWORD dwMoveMethod ; starting point
)
KERNEL32.SetFileTime(
 HANDLE hFile, ; handle to file
 CONST FILETIME *lpCreationTime, ; creation time
 CONST FILETIME *lpLastAccessTime, ; last-access time
 CONST FILETIME *lpLastWriteTime ; last-write time
)
USER32.SetFocus(
 HWND hWnd ; handle to window
)
USER32.SetForegroundWindow(
 HWND hWnd ; handle to window
)
WINSPOOL.SetFormA(
 HANDLE hPrinter, ; handle to printer object
 LPTSTR pFormName, ; form name
 DWORD Level, ; information level
 LPBYTE pForm ; form buffer
)
USER-DEFINED.SetGlobalInfo(
 PVOID GlobalInfo ; address of GlobalInfo block
)
GDI32.SetGraphicsMode(
 HDC hdc, ; handle to device context
 int iMode ; graphics mode
)
KERNEL32.SetHandleCount(
 UINT uNumber ; number of file handles needed
)
KERNEL32.SetHandleInformation(
 HANDLE hObject, ; handle to object
 DWORD dwMask, ; flags to change
 DWORD dwFlags ; new values for flags
)
KERNEL32.SetInformationJobObject(
 HANDLE hJob, ; handle to job
 JOBOBJECTINFOCLASS JobObjectInfoClass, ; information class
 LPVOID lpJobObjectInfo, ; limit information
 DWORD cbJobObjectInfoLength ; size of limit information
)
xxxx.SetInterfaceInfo(
 ULONG InterfaceIndex, ; index of interface
 PVOID InterfaceInfo, ; interface information block
 ULONG StructureVersion,
 ULONG StructureSize,
 ULONG StructureCount
)
WINSPOOL.SetJobA(
 HANDLE hPrinter, ; handle to printer object
 DWORD JobId, ; print job identifier
 DWORD Level, ; information level
 LPBYTE pJob, ; job information buffer
 DWORD Command ; job command value
)
USER32.SetKeyboardState(
 LPBYTE lpKeyState ; array of virtual-key codes
)
KERNEL32.SetLastError(
 DWORD dwErrCode ; per-thread error code
)
USER32.SetLastErrorEx(
 DWORD dwErrCode, ; per-thread error code
 DWORD dwType ; error type
)
xxxx.SetLayeredWindowAttributes(
 HWND hwnd, ; handle to the layered window
 COLORREF crKey, ; specifies the color key
 BYTE bAlpha, ; value for the blend function
 DWORD dwFlags ; action
)
xxxx.SetLayout(
 HDC hdc, ; handle to DC
 DWORD dwLayout ; layout options
)
KERNEL32.SetLocaleInfoA(
 LCID Locale, ; locale identifier
 LCTYPE LCType, ; information type
 LPCTSTR lpLCData ; information buffer
)
KERNEL32.SetLocalTime(
 CONST SYSTEMTIME *lpSystemTime ; local time
)
KERNEL32.SetMailslotInfo(
 HANDLE hMailslot, ; mailslot handle
 DWORD lReadTimeout ; read time-out interval
)
GDI32.SetMapMode(
 HDC hdc, ; handle to device context
 int fnMapMode ; new mapping mode
)
GDI32.SetMapperFlags(
 HDC hdc, ; handle to DC
 DWORD dwFlag ; font-mapper option
)
USER32.SetMenu(
 HWND hWnd, ; handle to window
 HMENU hMenu ; handle to menu
)
USER32.SetMenuContextHelpId(
 HMENU hmenu,
 DWORD dwContextHelpId
)
USER32.SetMenuDefaultItem(
 HMENU hMenu, ; handle to menu
 UINT uItem, ; identifier or position
 UINT fByPos ; meaning of uItem
)
xxxx.SetMenuInfo(
 HMENU hmenu, ; handle to menu
 LPCMENUINFO lpcmi ; menu information
)
USER32.SetMenuItemBitmaps(
 HMENU hMenu, ; handle to menu
 UINT uPosition, ; menu item
 UINT uFlags, ; options
 HBITMAP hBitmapUnchecked, ; handle to unchecked bitmap
 HBITMAP hBitmapChecked ; handle to checked bitmap
)
USER32.SetMenuItemInfoA(
 HMENU hMenu, ; handle to menu
 UINT uItem, ; identifier or position
 BOOL fByPosition, ; meaning of uItem
 LPMENUITEMINFO lpmii ; menu item information
)
USER32.SetMessageExtraInfo(
 LPARAM lParam ; application-defined value
)
xxxx.SetMessageQueue(OBSOLETE)
)
GDI32.SetMetaFileBitsEx(
 UINT nSize, ; size of Windows-format metafile
 CONST BYTE *lpData ; metafile data
)
GDI32.SetMetaRgn(
 HDC hdc ; handle to DC
)
GDI32.SetMiterLimit(
 HDC hdc, ; handle to DC
 FLOAT eNewLimit, ; new miter limit
 PFLOAT peOldLimit ; previous miter limit
)
KERNEL32.SetNamedPipeHandleState(
 HANDLE hNamedPipe, ; handle to named pipe
 LPDWORD lpMode, ; new pipe mode
 LPDWORD lpMaxCollectionCount, ; maximum collection count
 LPDWORD lpCollectDataTimeout ; time-out value
)
GDI32.SetPaletteEntries(
 HPALETTE hpal, ; handle to logical palette
 UINT iStart, ; index of first entry to set
 UINT cEntries, ; number of entries to set
 CONST PALETTEENTRY *lppe ; array of palette entries
)
USER32.SetParent(
 HWND hWndChild, ; handle to window
 HWND hWndNewParent ; new parent window
)
GDI32.SetPixel(
 HDC hdc, ; handle to DC
 int X, ; x-coordinate of pixel
 int Y, ; y-coordinate of pixel
 COLORREF crColor ; pixel color
)
GDI32.SetPixelV(
 HDC hdc, ; handle to device context
 int X, ; x-coordinate of pixel
 int Y, ; y-coordinate of pixel
 COLORREF crColor ; new pixel color
)
GDI32.SetPolyFillMode(
 HDC hdc, ; handle to device context
 int iPolyFillMode ; polygon fill mode
)
WINSPOOL.SetPortA(
 LPTSTR pName, ; printer server name
 LPTSTR pPortName, ; printer port name
 DWORD dwLevel, ; information level
 LPBYTE pPortInfo ; information buffer
)
xxxx.SetPower(
 DWORD PowerType
)
WINSPOOL.SetPrinterA(
 HANDLE hPrinter, ; handle to printer object
 DWORD Level, ; information level
 LPBYTE pPrinter, ; printer data buffer
 DWORD Command ; printer-state command
)
WINSPOOL.SetPrinterDataA(
 HANDLE hPrinter, ; handle to printer or print server
 LPTSTR pValueName, ; data to set
 DWORD Type, ; data type
 LPBYTE pData, ; configuration data buffer
 DWORD cbData ; size of buffer
)
WINSPOOL.SetPrinterDataExA(
 HANDLE hPrinter, ; handle to printer or print server
 LPCTSTR pKeyName, ; registry key name
 LPCTSTR pValueName, ; registry value name
 DWORD Type, ; data type
 LPBYTE pData, ; configuration data buffer
 DWORD cbData ; size of configuration data buffer
)
KERNEL32.SetPriorityClass(
 HANDLE hProcess, ; handle to process
 DWORD dwPriorityClass ; priority class
)
KERNEL32.SetProcessAffinityMask(
 HANDLE hProcess, ; handle to process
 DWORD_PTR dwProcessAffinityMask ; process affinity mask
)
KERNEL32.SetProcessDefaultLayout(
 DWORD dwDefaultLayout ; required default layout
)
KERNEL32.SetProcessPriorityBoost(
 HANDLE hProcess, ; handle to process
 BOOL DisablePriorityBoost ; priority boost state
)
KERNEL32.SetProcessShutdownParameters(
 DWORD dwLevel, ; shutdown priority
 DWORD dwFlags ; shutdown options
)
USER32.SetProcessWindowStation(
 HWINSTA hWinSta ; handle to window station
)
KERNEL32.SetProcessWorkingSetSize(
 HANDLE hProcess, ; handle to process
 SIZE_T dwMinimumWorkingSetSize, ; minimum working set size
 SIZE_T dwMaximumWorkingSetSize ; maximum working set size
)
USER32.SetPropA(
 HWND hWnd, ; handle to window
 LPCTSTR lpString, ; atom or string
 HANDLE hData ; handle to data
)
USER32.SetRect(
 LPRECT lprc, ; rectangle
 int xLeft, ; left side
 int yTop, ; top side
 int xRight, ; right side
 int yBottom ; bottom side
)
USER32.SetRectEmpty(
 LPRECT lprc ; rectangle
)
GDI32.SetRectRgn(
 HRGN hrgn, ; handle to region
 int nLeftRect, ; x-coordinate of upper-left corner of rectangle
 int nTopRect, ; y-coordinate of upper-left corner of rectangle
 int nRightRect, ; x-coordinate of lower-right corner of rectangle
 int nBottomRect ; y-coordinate of lower-right corner of rectangle
)
GDI32.SetROP2(
 HDC hdc, ; handle to DC
 int fnDrawMode ; drawing mode
)
USER32.SetScrollInfo(
 HWND hwnd, ; handle to window
 int fnBar, ; scroll bar type
 LPCSCROLLINFO lpsi, ; scroll parameters
 BOOL fRedraw ; redraw flag
)
USER32.SetScrollPos(
 HWND hWnd, ; handle to window
 int nBar, ; scroll bar
 int nPos, ; new position of scroll box
 BOOL bRedraw ; redraw flag
)
USER32.SetScrollRange(
 HWND hWnd, ; handle to window
 int nBar, ; scroll bar
 int nMinPos, ; minimum scrolling position
 int nMaxPos, ; maximum scrolling position
 BOOL bRedraw ; redraw flag
)
ADVAPI32.SetServiceBits(
 SERVICE_STATUS_HANDLE hServiceStatus, ; service status handle
 DWORD dwServiceBits, ; service type
 BOOL bSetBitsOn, ; set or clear
 BOOL bUpdateImmediately ; update type
)
ADVAPI32.SetServiceStatus(
 SERVICE_STATUS_HANDLE hServiceStatus, ; service status handle
 LPSERVICE_STATUS lpServiceStatus ; status buffer
)
KERNEL32.SetStdHandle(
 DWORD nStdHandle, ; input, output, or error device
 HANDLE hHandle ; handle
)
GDI32.SetStretchBltMode(
 HDC hdc, ; handle to DC
 int iStretchMode ; bitmap stretching mode
)
xxxx.SetSwapAreaSize(OBSOLETE)
)
USER32.SetSysColors(
 int cElements, ; number of elements
 CONST INT *lpaElements, ; array of elements
 CONST COLORREF *lpaRgbValues ; array of RGB values
)
xxxx.SetSysModalWindow(OBSOLETE)
)
USER32.SetSystemCursor (
 HCURSOR hcur, ; handle to cursor
 DWORD id ; system cursor identifier
)
GDI32.SetSystemPaletteUse(
 HDC hdc, ; handle to DC
 UINT uUsage ; palette usage
)
KERNEL32.SetSystemPowerState(
 BOOL fSuspend, ; system state
 BOOL fForce ; forced suspension option
)
KERNEL32.SetSystemTime(
 CONST SYSTEMTIME *lpSystemTime ; system time
)
KERNEL32.SetSystemTimeAdjustment(
 DWORD dwTimeAdjustment, ; size of adjustment
 BOOL bTimeAdjustmentDisabled ; disable option
)
KERNEL32.SetTapeParameters(
 HANDLE hDevice, ; handle to device
 DWORD dwOperation, ; information type
 LPVOID lpTapeInformation ; information buffer
)
KERNEL32.SetTapePosition(
 HANDLE hDevice, ; handle to device
 DWORD dwPositionMethod, ; positioning type
 DWORD dwPartition, ; new tape partition
 DWORD dwOffsetLow, ; low-order bits of position
 DWORD dwOffsetHigh, ; high-order bits of position
 BOOL bImmediate ; return after operation begins
)
GDI32.SetTextAlign(
 HDC hdc, ; handle to DC
 UINT fMode ; text-alignment option
)
GDI32.SetTextCharacterExtra(
 HDC hdc, ; handle to DC
 int nCharExtra ; extra-space value
)
GDI32.SetTextColor(
 HDC hdc, ; handle to DC
 COLORREF crColor ; text color
)
GDI32.SetTextJustification(
 HDC hdc, ; handle to DC
 int nBreakExtra, ; length of extra space
 int nBreakCount ; count of space characters
)
KERNEL32.SetThreadAffinityMask(
 HANDLE hThread, ; handle to thread
 DWORD_PTR dwThreadAffinityMask ; thread affinity mask
)
KERNEL32.SetThreadContext(
 HANDLE hThread, ; handle to thread
 CONST CONTEXT *lpContext ; context structure
)
USER32.SetThreadDesktop(
 HDESK hDesktop ; handle to the desktop
)
KERNEL32.SetThreadExecutionState(
 EXECUTION_STATE esFlags ; execution requirements
)
KERNEL32.SetThreadIdealProcessor(
 HANDLE hThread, ; handle to the thread
 DWORD dwIdealProcessor ; ideal processor number
)
KERNEL32..SetThreadLocale (
 LCID Locale ; locale identifier
)
KERNEL32.SetThreadPriority(
 HANDLE hThread, ; handle to the thread
 int nPriority ; thread priority level
)
KERNEL32.SetThreadPriorityBoost(
 HANDLE hThread, ; handle to thread
 BOOL DisablePriorityBoost ; priority boost state
)
USER32.SetTimer(
 HWND hWnd, ; handle to window
 UINT_PTR nIDEvent, ; timer identifier
 UINT uElapse, ; time-out value
 TIMERPROC lpTimerFunc ; timer procedure
)
KERNEL32.SetTimeZoneInformation(
 CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
)
KERNEL32.SetUnhandledExceptionFilter(
 LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
)
KERNEL32.SetupComm(
 HANDLE hFile, ; handle to communications device
 DWORD dwInQueue, ; size of input buffer
 DWORD dwOutQueue ; size of output buffer
)
xxxx.SetupDiCreateDeviceInfoList(
 CONST LPGUID ClassGuid,
 HWND hwndParent
)
xxxx.SetupDiCreateDeviceInfoListExA(
 CONST LPGUID ClassGuid,
 HWND hwndParent,
 PCTSTR MachineName,
 PVOID Reserved
)
xxxx.SetupDiCreateDeviceInterfaceRegKeyA(
 HDEVINFO DeviceInfoSet,
 PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
 DWORD Reserved,
 REGSAM samDesired,
 HINF InfHandle,
 PCTSTR InfSectionName
)
xxxx.SetupDiDeleteDeviceInterfaceData(
 HDEVINFO DeviceInfoSet,
 PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
)
xxxx.SetupDiDeleteDeviceInterfaceRegKey(
 HDEVINFO DeviceInfoSet,
 PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
 DWORD Reserved
)
xxxx.SetupDiDestroyDeviceInfoList(
 HDEVINFO DeviceInfoSet
)
xxxx.SetupDiEnumDeviceInterfaces(
 HDEVINFO DeviceInfoSet,
 PSP_DEVINFO_DATA DeviceInfoData,
 CONST LPGUID InterfaceClassGuid,
 DWORD MemberIndex,
 PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
)
xxxx.SetupDiGetClassDevsA(
 CONST LPGUID ClassGuid,
 PCTSTR Enumerator,
 HWND hwndParent,
 DWORD Flags
)
xxxx.SetupDiGetClassDevsExA(
 CONST LPGUID ClassGuid,
 PCTSTR Enumerator,
 HWND hwndParent,
 DWORD Flags,
 HDEVINFO DeviceInfoSet,
 PCTSTR MachineName,
 PVOID Reserved
)
xxxx.SetupDiGetDeviceInterfaceAlias(
 HDEVINFO DeviceInfoSet,
 PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
 CONST LPGUID AliasInterfaceClassGuid,
 PSP_DEVICE_INTERFACE_DATA AliasDeviceInterfaceData
)
xxxx.SetupDiGetDeviceInterfaceDetailA(
 HDEVINFO DeviceInfoSet,
 PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
 PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData,
 DWORD DeviceInterfaceDetailDataSize,
 PDWORD RequiredSize,
 PSP_DEVINFO_DATA DeviceInfoData
)
xxxx.SetupDiOpenClassRegKeyExA(
 CONST LPGUID ClassGuid,
 REGSAM samDesired,
 DWORD Flags,
 PCTSTR MachineName,
 PVOID Reserved
)
xxxx.SetupDiOpenDeviceInterfaceA(
 HDEVINFO DeviceInfoSet,
 PCTSTR DevicePath,
 DWORD OpenFlags,
 PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
)
xxxx.SetupDiOpenDeviceInterfaceRegKey(
 HDEVINFO DeviceInfoSet,
 PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
 DWORD Reserved,
 REGSAM samDesired
)
USER-DEFINED.SetupHookProc(
 HWND hdlg, ; handle to dialog box
 UINT uiMsg, ; message identifier
 WPARAM wParam, ; message parameter
 LPARAM lParam ; message parameter
)
xxxx.SetUserFileEncryptionKey(
 PENCRYPTION_CERTIFICATE pEncryptionCertificate ; certificate
)
xxxx.SetUserGeoID(
 GEOID GeoID ; user's geographical ID
)
USER32.SetUserObjectInformationA(
 HANDLE hObj, ; handle to the object
 int nIndex, ; type of information to set
 PVOID pvInfo, ; information buffer
 DWORD nLength ; size of buffer
)
GDI32.SetViewportExtEx(
 HDC hdc, ; handle to device context
 int nXExtent, ; new horizontal viewport extent
 int nYExtent, ; new vertical viewport extent
 LPSIZE lpSize ; original viewport extent
)
GDI32.SetViewportOrgEx(
 HDC hdc, ; handle to device context
 int X, ; new x-coordinate of viewport origin
 int Y, ; new y-coordinate of viewport origin
 LPPOINT lpPoint ; original viewport origin
)
KERNEL32.SetVolumeLabelA(
 LPCTSTR lpRootPathName, ; name of volume root directory
 LPCTSTR lpVolumeName ; name for the volume
)
KERNEL32.SetVolumeMountPoint(
 LPCTSTR lpszVolumeMountPoint, ; mount point
 LPCTSTR lpszVolumeName ; volume to be mounted
)
KERNEL32.SetWaitableTimer(
 HANDLE hTimer, ; handle to timer
 const LARGE_INTEGER *pDueTime, ; timer due time
 LONG lPeriod, ; timer interval
 PTIMERAPCROUTINE pfnCompletionRoutine, ; completion routine
 LPVOID lpArgToCompletionRoutine, ; completion routine parameter
 BOOL fResume ; resume state
)
USER32.SetWindowContextHelpId(
 HWND hwnd,
 DWORD dwContextHelpId
)
GDI32.SetWindowExtEx(
 HDC hdc, ; handle to device context
 int nXExtent, ; new horizontal window extent
 int nYExtent, ; new vertical window extent
 LPSIZE lpSize ; original window extent
)
USER32.SetWindowLongA(
 HWND hWnd, ; handle to window
 int nIndex, ; offset of value to set
 LONG dwNewLong ; new value
)
USER32.SetWindowLongPtr(
 HWND hWnd, ; handle to window
 int nIndex, ; offset of value to set
 LONG_PTR dwNewLong ; new value
)
GDI32.SetWindowOrgEx(
 HDC hdc, ; handle to device context
 int X, ; new x-coordinate of window origin
 int Y, ; new y-coordinate of window origin
 LPPOINT lpPoint ; original window origin
)
USER32.SetWindowPlacement(
 HWND hWnd, ; handle to window
 CONST WINDOWPLACEMENT *lpwndpl ; position data
)
USER32.SetWindowPos(
 HWND hWnd, ; handle to window
 HWND hWndInsertAfter, ; placement-order handle
 int X, ; horizontal position
 int Y, ; vertical position
 int cx, ; width
 int cy, ; height
 UINT uFlags ; window-positioning options
)
USER32.SetWindowRgn(
 HWND hWnd, ; handle to window
 HRGN hRgn, ; handle to region
 BOOL bRedraw ; window redraw option
)
xxxx.SetWindowsHookA(OBSOLETE - Use SetWindowsHookEx)
)
USER32.SetWindowsHookExA(
 int idHook, ; hook type
 HOOKPROC lpfn, ; hook procedure
 HINSTANCE hMod, ; handle to application instance
 DWORD dwThreadId ; thread identifier
)
xxxx.SetWindowSubclass(
 HWND hWnd,
 SUBCLASSPROC pfnSubclass,
 UINT_PTR uIdSubclass,
 DWORD dwRefData
)
USER32.SetWindowTextA(
 HWND hWnd, ; handle to window or control
 LPCTSTR lpString ; title or text
)
xxxx.SetWindowWord(OBSOLETE - Use SetWindowLong)
)
GDI32.SetWinMetaFileBits(
 UINT cbBuffer, ; size of buffer
 CONST BYTE *lpbBuffer, ; metafile data buffer
 HDC hdcRef, ; handle to reference DC
 CONST METAFILEPICT *lpmfp ; size of metafile picture
)
GDI32.SetWorldTransform(
 HDC hdc, ; handle to device context
 CONST XFORM *lpXform ; transformation data
)
SHELL32.SHAddToRecentDocs(
 UINT uFlags,
 LPCVOID pv
)
SHELL32.SHAppBarMessage(
 DWORD dwMessage,
 PAPPBARDATA pData
)
xxxx.SHAutoComplete(
 HWND hwndEdit,
 DWORD dwFlags
)
xxxx.SHBindToParent(
 LPCITEMIDLIST pidl,
 REFIID riid,
 VOID **ppv,
 LPCITEMIDLIST *ppidlLast
)
SHELL32.SHBrowseForFolderA(
 LPBROWSEINFO lpbi
)
SHELL32.SHChangeNotify(
 LONG wEventId,
 UINT uFlags,
 LPCVOID dwItem1,
 LPCVOID dwItem2
)
xxxx.SHCopyKey(
 HKEY hkeySrc,
 LPCTSTR szSrcSubKey,
 HKEY hkeyDest,
 DWORD fReserved
)
xxxx.SHCreateDirectoryEx(
 HWND hwnd,
 LPCSTR pszPath,
 SECURITY_ATTRIBUTES *psa
)
xxxx.SHCreateProcessAsUserW(
 PSHCREATEPROCESSINFOW pscpi
)
xxxx.SHCreateShellPalette(
 HDC hdc
)
xxxx.SHCreateStreamOnFile(
 LPCTSTR pszFile,
 DWORD grfMode,
 IStream **ppstm
)
xxxx.SHCreateThread(
 LPTHREAD_START_ROUTINE pfnThreadProc,
 VOID *pData,
 DWORD dwFlags,
 LPTHREAD_START_ROUTINE pfnCallback
)
SHLWAPI.SHDeleteEmptyKeyA(
 HKEY hkey,
 LPCTSTR pszSubKey
)
SHLWAPI.SHDeleteKeyA(
 HKEY hkey,
 LPCTSTR pszSubKey
)
SHLWAPI.SHDeleteValueA(
 HKEY hkey,
 LPCTSTR pszSubKey,
 LPCTSTR pszValue
)
SHELL32.Shell_NotifyIconA(
 DWORD dwMessage,
 PNOTIFYICONDATA pnid
)
SHELL32.ShellAboutA(
 HWND hWnd,
 LPCTSTR szApp,
 LPCTSTR szOtherStuff,
 HICON hIcon
)
SHELL32.ShellExecuteA(
 HWND hwnd,
 LPCTSTR lpVerb,
 LPCTSTR lpFile,
 LPCTSTR lpParameters,
 LPCTSTR lpDirectory,
 INT nShowCmd
)
SHELL32.ShellExecuteExA(
 LPSHELLEXECUTEINFO lpExecInfo
)
USER-DEFINED.ShellProc(
 int nCode, ; hook code
 WPARAM wParam, ; event-specific information
 LPARAM lParam ; event-specific information
)
xxxx.SHEmptyRecycleBinA(
 HWND hwnd,
 LPCTSTR pszRootPath,
 DWORD dwFlags
)
SHLWAPI.SHEnumKeyExA(
 HKEY hkey,
 DWORD dwIndex,
 LPTSTR pszName,
 LPDWORD pcchName
)
SHLWAPI.SHEnumValueA(
 HKEY hkey,
 DWORD dwIndex,
 LPTSTR pszValueName,
 LPDWORD pcchValueName,
 LPDWORD pdwType,
 LPVOID pvData,
 LPDWORD pcbData
)
SHELL32.SHFileOperationA(
 LPSHFILEOPSTRUCT lpFileOp
)
SHELL32.SHFreeNameMappings(
 HANDLE hNameMappings
)
SHELL32.SHGetDataFromIDListA(
 IShellFolder *psf,
 LPCITEMIDLIST pidl,
 int nFormat,
 PVOID pv,
 int cb
)
SHELL32.SHGetDesktopFolder(
 IShellFolder **ppshf
)
xxxx.SHGetDiskFreeSpaceA(
 LPCTSTR pszVolume,
 ULARGE_INTEGER *pqwFreeCaller,
 ULARGE_INTEGER *pqwTot,
 ULARGE_INTEGER *pqwFree
)
SHELL32.SHGetFileInfoA(
 LPCTSTR pszPath,
 DWORD dwFileAttributes,
 SHFILEINFO *psfi,
 UINT cbFileInfo,
 UINT uFlags
)
xxxx.SHGetFolderLocation(
 HWND hwndOwner,
 int nFolder,
 HANDLE hToken,
 DWORD dwReserved,
 LPITEMIDLIST *ppidl
)
xxxx.SHGetFolderPath(
 HWND hwndOwner,
 int nFolder,
 HANDLE hToken,
 DWORD dwFlags,
 LPTSTR pszPath
)
xxxx.SHGetIconOverlayIndex(
 LPCTSTR pszIconPath,
 int iIconIndex
)
SHELL32.SHGetInstanceExplorer(
 IUnknown **ppunk
)
xxxx.SHGetUnreadMailCount(
 HKEY hKeyUser,
 LPCTSTR pszMailAddress,
 DWORD *pdwCount,
 FILETIME *pFileTime,
 LPCTSTR pszShellExecuteCommand,
 int cchShellExecuteCommand
)
SHELL32.SHGetMalloc(
 LPMALLOC *ppMalloc
)
xxxx.SHGetNewLinkInfo(
 LPCTSTR pszLinkTo,
 LPCTSTR pszDir,
 LPTSTR pszName,
 BOOL *pfMustCopy,
 UINT uFlags
)
SHELL32.SHGetPathFromIDListA(
 LPCITEMIDLIST pidl,
 LPSTR pszPath
)
xxxx.SHGetSettings(
 LPSHELLFLAGSTATE lpsfs,
 DWORD dwMask
)
SHELL32.SHGetSpecialFolderLocation(
 HWND hwndOwner,
 int nFolder,
 LPITEMIDLIST *ppidl
)
xxxx.SHGetSpecialFolderPathA(
 HWND hwndOwner,
 LPTSTR lpszPath,
 int nFolder,
 BOOL fCreate
)
xxxx.SHGetThreadRef(
 IUnknown **ppunk
)
SHLWAPI.SHGetValueA(
 HKEY hkey,
 LPCTSTR pszSubKey,
 LPCTSTR pszValue,
 LPDWORD pdwType,
 LPVOID pvData,
 LPDWORD pcbData
)
xxxx.SHIsFileAvailableOffline(
 LPCWSTR pszPath,
 [LPDWORD pdwStatus]
)
xxxx.SHLoadNonloadedIconOverlayIdentifiers(VOID)
)
xxxx.SHPathPrepareForWrite(
 HWND hwnd,
 IUnknown *punkEnableModless,
 LPCTSTR pszPath,
 DWORD dwFlags
)
xxxx.SHInvokePrinterCommand(
 HWND hwnd,
 UINT uAction,
 LPCTSTR lpBuf1,
 LPCTSTR lpBuf2,
 BOOL fModal
)
xxxx.SHIsFileAvailableOffline(
 LPCWSTR pszPath,
 [LPDWORD pdwStatus]
)
SHELL32.SHLoadInProc(
 REFCLSID rclsid
)
xxxx.SHLoadNonloadedIconOverlayIdentifiers(VOID)
)
xxxx.SHOpenFolderAndSelectItems(
 LPCITEMIDLIST pidlFolder,
 UINT cidl,
 LPCITEMIDLIST *apidl,
 DWORD dwFlags
)
SHLWAPI.SHOpenRegStreamA(
 HKEY hkey,
 LPCTSTR pszSubkey,
 LPCTSTR pszValue,
 DWORD grfMode
)
xxxx.SHOpenRegStream2(
 HKEY hkey,
 LPCSTR pszSubkey,
 LPCSTR pszValue,
 DWORD grfMode
)
USER32.ShowCaret(
 HWND hWnd ; handle to window with caret
)
USER32.ShowCursor(
 BOOL bShow ; cursor visibility
)
COMCTL32.ShowHideMenuCtl(
 HWND hWnd,
 UINT uFlags,
 LPINT lpInfo
)
USER32.ShowOwnedPopups(
 HWND hWnd, ; handle to window
 BOOL fShow ; window visibility
)
USER32.ShowScrollBar(
 HWND hWnd, ; handle to window
 int wBar, ; scroll bar
 BOOL bShow ; scroll bar visibility
)
USER32.ShowWindow(
 HWND hWnd, ; handle to window
 int nCmdShow ; show state
)
USER32.ShowWindowAsync(
 HWND hWnd, ; handle to window
 int nCmdShow ; show state
)
xxxx.SHPathPrepareForWrite(
 HWND hwnd,
 IUnknown *punkEnableModless,
 LPCTSTR pszPath,
 DWORD dwFlags
)
SHLWAPI.SHQueryInfoKeyA(
 HKEY hkey,
 LPDWORD pcSubKeys,
 LPDWORD pcchMaxSubKeyLen,
 LPDWORD pcValues,
 LPDWORD pcchMaxValueNameLen
)
xxxx.SHQueryRecycleBinA(
 LPCTSTR pszRootPath,
 LPSHQUERYRBINFO pSHQueryRBInfo
)
SHLWAPI.SHQueryValueExA(
 HKEY hkey,
 LPCTSTR pszValue,
 LPDWORD pdwReserved,
 LPDWORD pdwType,
 LPVOID pvData,
 LPDWORD pcbData
)
xxxx.SHRegCloseUSKey(
 HUSKEY hUSKey
)
SHLWAPI.SHRegCreateUSKeyA(
 LPCTSTR pszPath,
 REGSAM samDesired,
 HUSKEY hRelativeUSKey,
 PHUSKEY phNewUSKey,
 DWORD dwFlags
)
SHLWAPI.SHRegDeleteEmptyUSKeyA(
 HUSKEY hUSKey,
 LPCSTR pszValue,
 SHREGDEL_FLAGS delRegFlags
)
SHLWAPI.SHRegDeleteUSValueA(
 HUSKEY hUSKey,
 LPCTSTR pszValue,
 SHREGDEL_FLAGS delRegFlags
)
xxxx.SHRegDuplicateHKeyA(
 HKEY hkey
)
SHLWAPI.SHRegEnumUSKeyA(
 HUSKEY hUSKey,
 DWORD dwIndex,
 LPSTR pszName,
 LPDWORD pcchName,
 SHREGENUM_FLAGS enumRegFlags
)
SHLWAPI.SHRegEnumUSValueA(
 HUSKEY hUSkey,
 DWORD dwIndex,
 LPTSTR pszValueName,
 LPDWORD pcchValueNameLen,
 LPDWORD pdwType,
 LPVOID pvData,
 LPDWORD pcbData,
 SHREGENUM_FLAGS enumRegFlags
)
xxxx.SHRegGetBoolUSValueA(
 LPCTSTR pszSubKey,
 LPCTSTR pszValue,
 BOOL fIgnoreHKCU,
 BOOL fDefault
)
xxxx.SHRegGetInt(
 HKEY hk,
 LPCWSTR szKey,
 int nDefault
)
xxxx.SHRegGetPath(
 HKEY hkey,
 LPCTSTR pszSubkey,
 LPCTSTR pszValue,
 LPTSTR pszPath,
 DWORD dwFlags
)
SHLWAPI.SHRegGetUSValueA(
 LPCTSTR pszSubKey,
 LPCTSTR pszValue,
 LPDWORD pdwType,
 LPVOID pvData,
 LPDWORD pcbData,
 BOOL fIgnoreHKCU,
 LPVOID pvDefaultData,
 DWORD dwDefaultDataSize
)
SHLWAPI.SHRegOpenUSKeyA(
 LPCTSTR pszPath,
 REGSAM samDesired,
 HUSKEY hRelativeUSKey,
 PHUSKEY phNewUSKey,
 BOOL fIgnoreHKCU
)
SHLWAPI.SHRegQueryInfoUSKeyA(
 HUSKEY hUSKey,
 LPDWORD pcSubKeys,
 LPDWORD pcchMaxSubKeyLen,
 LPDWORD pcValues,
 LPDWORD pcchMaxValueNameLen
)
SHLWAPI.SHRegQueryUSValueA(
 HUSKEY hUSKey,
 LPCTSTR pszValue,
 LPDWORD pdwType,
 LPVOID pvData,
 LPDWORD pcbData,
 BOOL fIgnoreHKCU,
 LPVOID pvDefaultData,
 DWORD dwDefaultDataSize
)
xxxx.SHRegSetPath(
 HKEY hkey,
 LPCTSTR pszSubkey,
 LPCTSTR pszValue,
 LPCTSTR pszPath,
 DWORD dwFlags
)
SHLWAPI.SHRegSetUSValueA(
 LPCTSTR pszSubKey,
 LPCTSTR pszValue,
 DWORD dwType,
 LPVOID pvData,
 DWORD cbData,
 DWORD dwFlags
)
SHLWAPI.SHRegWriteUSValueA(
 HUSKEY hUSKey,
 LPCTSTR pszValue,
 DWORD dwType,
 LPVOID pvData,
 DWORD cbData,
 DWORD dwFlags
)
xxxx.SHSetLocalizedName(
 LPWSTR pszPath,
 LPCWSTR pszResModule,
 int idsRes
)
xxxx.SHSetThreadRef(
 IUnknown *punk
)
xxxx.SHSetUnreadMailCount(
 LPCTSTR pszMailAddress,
 DWORD dwCount,
 LPCTSTR pszShellExecuteCommand
)
SHLWAPI.SHSetValueA(
 HKEY hkey,
 LPCTSTR pszSubKey,
 LPCTSTR pszValue,
 DWORD dwType,
 LPCVOID pvData,
 DWORD cbData
)
xxxx.SHSkipJunction(
 IBindCtx *pbc,
 const CLSID *pclsid
)
xxxx.SHStrDup(
 LPCTSTR pszSource,
 LPWSTR *ppwszTarget
)
xxxx.SHUpdateImage(
 LPCTSTR pszHashItem,
 int iIndex,
 UINT uFlags,
 int iImageIndex
)
KERNEL32.SignalObjectAndWait(
 HANDLE hObjectToSignal, ; handle to object to signal
 HANDLE hObjectToWaitOn, ; handle to object to watch
 DWORD dwMilliseconds, ; time-out interval
 BOOL bAlertable ; alertable option
)
KERNEL32.SizeofResource(
 HMODULE hModule, ; module handle
 HRSRC hResInfo ; resource handle
)
KERNEL32.Sleep(
 DWORD dwMilliseconds ; sleep time
)
KERNEL32.SleepEx(
 DWORD dwMilliseconds, ; time-out interval
 BOOL bAlertable ; early completion option
)
xxxx.SOANGLETENTHS(
 AngleInTenthsOfADegree
)
xxxx.SOBailOut(
 WORD wError,
 HPROC reserved
)
xxxx.SOBeginTable(
 HPROC reserved
)
xxxx.SOEndColumnInfo(
 HPROC reserved
)
xxxx.SOEndFieldInfo(
 HPROC reserved
)
xxxx.SOEndFontTable(
 HPROC reserved
)
xxxx.SOEndPalette(
 HPROC reserved
)
xxxx.SOEndTable(
 HPROC reserved
)
xxxx.SOEndTabStops(
 HPROC reserved
)
xxxx.SoftwareUpdateMessageBox(
 HWND hWnd,
 LPCWSTR szDistUnit,
 DWORD dwFlags,
 LPSOFTDISTINFO psdi
)
xxxx.SOGetInfo(
 WORD wInfo,
 void VWPTR *pInfo,
 HPROC reserved
)
xxxx.SOGetScanLineBuffer(
 VOID VWPTR *ppScanLineData,
 HPROC reserved
)
xxxx.SOPALETTEINDEX(
 Index
)
xxxx.SOPALETTERGB(
 Red,
 Green,
 Blue
)
xxxx.SOPutBitmapHeader(
 PSOBITMAPHEADER pBitmapHeader,
 HPROC reserved
)
xxxx.SOPutBreak(
 WORD wType,
 DWORD dwInfo,
 HPROC reserved
)
xxxx.SOPutChar(
 WORD wCh,
 HPROC reserved
)
xxxx.SOPutCharAttr(
 WORD wAttr,
 WORD wState,
 HPROC reserved
)
xxxx.SOPutCharFontById(
 DWORD dwFontId,
 HPROC reserved
)
xxxx.SOPutCharFontByName(
 WORD wFontType,
 WORD pFontName,
 HPROC reserved
)
xxxx.SOPutCharHeight(
 WORD wHeight,
 HPROC reserved
)
xxxx.SOPutCharX(
 WORD wCh,
 WORD wType,
 HPROC reserved
)
xxxx.SOPutColumnInfo(
 PSOCOLUMN pColumn,
 HPROC reserved
)
xxxx.SOPutDataCell(
 PSODATACELL pCell,
 HPROC reserved
)
xxxx.SOPutEmbeddedObject(
 PSOEMBEDDEDOBJECT pObject,
 HPROC reserved
)
xxxx.SOPutField(
 void VWPTR *pData,
 HPROC reserved
)
xxxx.SOPutFieldInfo(
 PSOFIELD pField,
 HPROC reserved
)
xxxx.SOPutFontTableEntry(
 DWORD dwFontId,
 WORD wFontType,
 Char VWPTR *pFontName,
 HPROC reserved
)
xxxx.SOPutHdrEntry(
 char VWPTR *pLabel,
 char VWPTR *pData,
 WORD wId,
 HPROC reserved
)
xxxx.SOPutMoreText(
 WORD wCount,
 char VWPTR *pText,
 WORD bMore,
 HPROC reserved
)
xxxx.SOPutMoreVarField(
 VOID VWPTR *pData,
 WORD wCount,
 WORD bMore,
 HPROC reserved
)
xxxx.SOPutPaletteEntry(
 unsigned char Red,
 unsigned char Green,
 unsigned char Blue,
 HPROC reserved
)
xxxx.SOPutParAlign(
 WORD wType,
 HPROC reserved
)
xxxx.SOPutParaIndents(
 LONG dwLeft,
 LONG dwRight,
 LONG dwFirst,
 HPROC reserved
)
xxxx.SOPutParaMargins(
 LONG dwLeft,
 LONG dwRight,
 HPROC reserved
)
xxxx.SOPutParaSpacing(
 WORD wLineHeightType,
 DWORD dwLineHeight,
 DWORD dwSpaceBefore,
 DWORD dwSpaceAfter,
 HPROC reserved
)
xxxx.SOPutScanLineData(
 U_BYTE VWPTR *pScanLineData,
 HPROC reserved
)
xxxx.SOPutSectionName(
 char VWPTR *pName,
 HPROC reserved
)
xxxx.SOPutSectionType(
 WORD wType,
 HPROC reserved
)
xxxx.SOPutSpecialCharX(
 WORD wCh,
 WORD wType,
 HPROC reserved
)
xxxx.SOPutSubdocInfo(
 WORD wType,
 WORD wSubType,
 HPROC reserved
)
xxxx.SOPutTableCellInfo(
 PSOTABLECELLINFO pCellInfo,
 HPROC reserved
)
xxxx.SOPutTableRowFormat(
 WORD wLeftEdge,
 WORD wRowHeight,
 WORD wRowHeightType,
 WORD wCellMargin,
 WORD wRowAlignment,
 WORD wNumCells,
 HPROC reserved
)
xxxx.SOPutTabStop(
 PSOTAB pTabs,
 HPROC reserved
)
xxxx.SOPutTextCell(
 PSOTEXTCELL pCell,
 WORD wCount,
 char VWPTR *pText,
 HPROC reserved
)
xxxx.SOPutVarField(
 void VWPTR *pData,
 WORD wCount,
 WORD *bMore,
 HPROC reserved
)
xxxx.SOPutVectorHeader(
 PSOVECTORHEADER pVectorHeader,
 HPROC reserved
)
xxxx.SORGB(
 Red,
 Green,
 Blue
)
xxxx.SOSetDataBase(
 DWORD dwBase,
 WORD wFlags,
 HPROC reserved
)
xxxx.SOSETRATIO(
 Numerator,
 Denominator
)
xxxx.SOStartColumnInfo(
 HPROC reserved
)
xxxx.SOStartFieldInfo(
 HPROC reserved
)
xxxx.SOStartFontTable(
 HPROC reserved
)
xxxx.SOStartPalette(
 HPROC reserved
)
xxxx.SOStartTabStops(
 HPROC reserved
)
xxxx.SOVectorAttr(
 INT nItemId,
 DWORD wDataSize,
 VOID VWPTR *pData,
 HPROC reserved
)
xxxx.SOVectorObject(
 INT nItemId,
 DWORD wDataSize,
 VOID VWPTR *pData,
 HPROC reserved
)
SQLITE3.sqlite3_aggregate_context(
;allocates|returns pMem to nByte of context zeroed|in-use mem
  sqlite3_context *pCtx,            ;user function context
  int nByte                         ;bytes to allocate
)
SQLITE3.sqlite3_aggregate_count(
;return step-call count
  sqlite3_context *pCtx             ;user function context
)
SQLITE3.sqlite3_bind_blob(
                  ;set blob parameter value
  sqlite3_stmt *pStmt,              ;pointer to the prepared statement
  int i,                            ;index of the parameter to be set (first parameter = 1)
  const void *zData,                
  int nData, 
  void (*xDel)(void*)               ;SQLITE_STATIC|SQLITE_TRANSIENT
)
SQLITE3.sqlite3_bind_double(

  sqlite3_stmt *pStmt,              ;pointer to the prepared statement
  int i,                            ;index of the parameter to be set (first parameter = 1)
  double rValue
)
SQLITE3.sqlite3_bind_int(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i,                             ;index of the parameter to be set (first parameter = 1)
  int iValue
)
SQLITE3.sqlite3_bind_int64(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i,                             ;index of the parameter to be set (first parameter = 1)
  sqlite_int64 iValue
)
SQLITE3.sqlite3_bind_null(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i                              ;index of the parameter to be set (first parameter = 1)
)
SQLITE3.sqlite3_bind_parameter_count(

  sqlite3_stmt *pStmt              ;pointer to the prepared statement
)
SQLITE3.sqlite3_bind_parameter_index(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  const char *zName ;paramenter name
)
SQLITE3.sqlite3_bind_parameter_name(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i                              ;index of the parameter to be set (first parameter = 1)
)
SQLITE3.sqlite3_bind_text(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i,                             ;index of the parameter to be set (first parameter = 1)
  const char *zData, 
  int nData, 
  void (*xDel)(void*)               ;SQLITE_STATIC|SQLITE_TRANSIENT
)
SQLITE3.sqlite3_bind_text16(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i,                             ;index of the parameter to be set (first parameter = 1)
  const void *zData, 
  int nData, 
  void (*xDel)(void*)               ;SQLITE_STATIC|SQLITE_TRANSIENT
)
SQLITE3.sqlite3_busy_handler(
   
  sqlite3 *db,              ; Database handle.
  int (*xBusy)(void*,int), ;callback function
  void *pArg ;argument
)
SQLITE3.sqlite3_busy_timeout(

  sqlite3 *db,              ; Database handle. 
  int ms
)
SQLITE3.sqlite3_changes(

  sqlite3 *db              ; Database handle.
)
SQLITE3.sqlite3_close(

  sqlite3 *db              ; Database handle.
)
SQLITE3.sqlite3_collation_needed(

  sqlite3 *db,              ; Database handle. 
  void *pCollNeededArg, 
  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*)
)
SQLITE3.sqlite3_collation_needed16(

  sqlite3 *db,              ; Database handle. 
  void *pCollNeededArg, 
  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*)
)
SQLITE3.sqlite3_column_blob(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i
)
SQLITE3.sqlite3_column_bytes(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i
)
SQLITE3.sqlite3_column_bytes16(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i
)
SQLITE3.sqlite3_column_count(

  sqlite3_stmt *pStmt                ;pointer to the prepared statement
)
SQLITE3.sqlite3_column_decltype(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int N
)
SQLITE3.sqlite3_column_decltype16(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int N
)
SQLITE3.sqlite3_column_double(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i
)
SQLITE3.sqlite3_column_int(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i
)
SQLITE3.sqlite3_column_int64(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i
)
SQLITE3.sqlite3_column_name(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int N
)
SQLITE3.sqlite3_column_name16(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int N
)
SQLITE3.sqlite3_column_text(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i
)
SQLITE3.sqlite3_column_text16(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i
)
SQLITE3.sqlite3_column_type(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i
)
SQLITE3.sqlite3_column_type(

  sqlite3_stmt *pStmt,               ;pointer to the prepared statement
  int i
)
SQLITE3.sqlite3_commit_hook(

  sqlite3 *db,              ; Database handle.
  int (*xCallback)(void*),  ; Function to invoke on each commit 
  void *pArg                ; Argument to the function 
)
SQLITE3.sqlite3_complete(

  const char *zSql
)
SQLITE3.sqlite3_complete16(

  const void *zSql
)
SQLITE3.sqlite3_create_collation(
    ; add new collation sequences to database
  sqlite3 *db,               ; Database handle.
  const char *zName,         ; name of collation sequence
  int enc,      ; string enc SQLITE_UTF8|SQLITE_UTF16BE|SQLITE_UTF16LE|SQLITE_UTF16
  void *pCtx,                ; value passed as first arg on each call to xCompare
  int*xCompare ;ptr to function xCompare[*pCtx, int Len1, *pStr1, int Len2, *pStr2] 
)
SQLITE3.sqlite3_create_collation16(
  ; add new collation sequences to database
  sqlite3 *db,               ; Database handle.
  const char *zName,         ; name of collation sequence
  int enc,       ; string enc SQLITE_UTF8|SQLITE_UTF16BE|SQLITE_UTF16LE|SQLITE_UTF16
  void *pCtx,                ; value passed as first arg on each call to xCompare
  int*xCompare ;ptr to function xCompare[*pCtx, int Len1, *pStr1, int Len2, *pStr2] 
)
SQLITE3.sqlite3_create_function(

  sqlite3 *db,              ; Database handle.
  const char *zFunctionName,
  int nArg,
  int enc,
  void *pUserData,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value **),
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*)
)
SQLITE3.sqlite3_create_function16(

  sqlite3 *db,              ; Database handle.
  const void *zFunctionName,
  int nArg,
  int eTextRep,
  void *pUserData,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
)
SQLITE3.sqlite3_data_count(

  sqlite3_stmt *pStmt              ;pointer to the prepared statement
)
SQLITE3.sqlite3_errcode(

  sqlite3 *db              ; Database handle.
)
SQLITE3.sqlite3_errmsg(

  sqlite3 *db              ; Database handle.
)
SQLITE3.sqlite3_errmsg16(

  sqlite3 *db              ; Database handle.
)
SQLITE3.sqlite3_exec(

  sqlite3 *db,              ; Database handle.
  const char *zSql,           ; The SQL to be executed 
  sqlite3_callback xCallback, ; Invoke this callback routine 
  void *pArg,                 ; First argument to xCallback 
  char **pzErrMsg             ; Write error messages here 
)
SQLITE3.sqlite3_finalize(

  sqlite3_stmt *pStmt      ;pointer to the prepared statement
)
SQLITE3.sqlite3_free(

  char *p
)
SQLITE3.sqlite3_free_table(

  char **azResult            ; Result returned from from sqlite3_get_table() 
)
SQLITE3.sqlite3_get_auxdata(

  sqlite3_context *pCtx, 
  int iArg
)
SQLITE3.sqlite3_get_table(

  sqlite3 *db,              ; Database handle.
  const char *zSql,           ; The SQL to be executed 
  char ***pazResult,          ; Write the result table here 
  int *pnRow,                 ; Write the number of rows in the result here 
  int *pnColumn,              ; Write the number of columns of result here 
  char **pzErrMsg             ; Write error messages here 
)
SQLITE3.sqlite3_interrupt(

  sqlite3 *db              ; Database handle.
)
SQLITE3.sqlite3_last_insert_rowid(
  ;returns sqlite_int64
  sqlite3 *db              ; Database handle.
)
SQLITE3.sqlite3_libversion(

  void
)
SQLITE3.sqlite3_mprintf(

  const char *zFormat, 
  ...
)
SQLITE3.sqlite3_open(

  const char *zFilename, 
  sqlite3 **ppDb 
)
SQLITE3.sqlite3_open16(

  const void *zFilename, 
  sqlite3 **ppDb
)
SQLITE3.sqlite3_prepare(

  sqlite3 *db,              ; Database handle. 
  const char *zSql,         ; UTF-8 encoded SQL statement. 
  int nBytes,               ; Length of zSql in bytes. 
  sqlite3_stmt **ppStmt,    ; OUT: A pointer to the prepared statement 
  const char** pzTail       ; OUT: End of parsed string 
)
SQLITE3.sqlite3_prepare16(

  sqlite3 *db,              ; Database handle.
  const void *zSql,         ; UTF-8 encoded SQL statement.
  int nBytes,               ; Length of zSql in bytes.
  sqlite3_stmt **ppStmt,    ; OUT: A pointer to the prepared statement
  const void **pzTail       ; OUT: End of parsed string
)
SQLITE3.sqlite3_progress_handler(

  sqlite3 *db,              ; Database handle. 
  int nOps,
  int (*xProgress)(void*), 
  void *pArg
)
SQLITE3.sqlite3_reset(

  sqlite3_stmt *pStmt
)
SQLITE3.sqlite3_result_blob(

  sqlite3_context *pCtx, 
  const void *z, 
  int n, 
  void (*xDel)(void *)
)
SQLITE3.sqlite3_result_double(

  sqlite3_context *pCtx, 
  double rVal
)
SQLITE3.sqlite3_result_error(

  sqlite3_context *pCtx, 
  const char *z, 
  int n
)
SQLITE3.sqlite3_result_error16(

  sqlite3_context *pCtx, 
  const void *z, 
  int n
)
SQLITE3.sqlite3_result_int(

  sqlite3_context *pCtx, 
  int iVal
)
SQLITE3.sqlite3_result_int64(

  sqlite3_context *pCtx, 
  i64 iVal
)
SQLITE3.sqlite3_result_null(

  sqlite3_context *pCtx
)
SQLITE3.sqlite3_result_text(

  sqlite3_context *pCtx, 
  const char *z, 
  int n,
  void (*xDel)(void *)
)
SQLITE3.sqlite3_result_text16(

  sqlite3_context *pCtx, 
  const void *z, 
  int n, 
  void (*xDel)(void *)
)
SQLITE3.sqlite3_result_text16be(

  sqlite3_context *pCtx, 
  const void *z, 
  int n, 
  void (*xDel)(void *)
)
SQLITE3.sqlite3_result_text16le(

  sqlite3_context *pCtx, 
  const void *z, 
  int n, 
  void (*xDel)(void *)
)
SQLITE3.sqlite3_result_value(

  sqlite3_context *pCtx, 
  sqlite3_value *pValue
)
SQLITE3.sqlite3_set_authorizer(

  sqlite3 *db,              ; Database handle.
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
  void *pArg
)
SQLITE3.sqlite3_set_auxdata(

  sqlite3_context *pCtx, 
  int iArg, 
  void *pAux, 
  void (*xDelete)(void*)
)
SQLITE3.sqlite3_snprintf(

  int n, 
  char *zBuf, 
  const char *zFormat, 
  ...
)
SQLITE3.sqlite3_step(

  sqlite3_stmt *pStmt              ;pointer to the prepared statement
)
SQLITE3.sqlite3_total_changes(

  sqlite3 *db
)
SQLITE3.sqlite3_trace(

  sqlite3 *db,              ; Database handle. 
  void (*xTrace)(void*,const char*), 
  void *pArg
)
SQLITE3.sqlite3_user_data(

  sqlite3_context *p
)
SQLITE3.sqlite3_value_blob(

  sqlite3_value *pVal
)
SQLITE3.sqlite3_value_bytes(

  sqlite3_value *pVal
)
SQLITE3.sqlite3_value_bytes16(

  sqlite3_value *pVal
)
SQLITE3.sqlite3_value_double(

  sqlite3_value *pVal
)
SQLITE3.sqlite3_value_int(

  sqlite3_value *pVal
)
SQLITE3.sqlite3_value_int64(

  sqlite3_value *pVal
)
SQLITE3.sqlite3_value_text(

  sqlite3_value *pVal
)
SQLITE3.sqlite3_value_text16(

  sqlite3_value* pVal
)
SQLITE3.sqlite3_value_text16be(

  sqlite3_value *pVal
)
SQLITE3.sqlite3_value_text16le(

  sqlite3_value *pVal
)
SQLITE3.sqlite3_value_type(

  sqlite3_value* pVal
)
SQLITE3.sqlite3_vmprintf(

  const char *zFormat, 
  va_list ap
)
xxxx.StartComplete(VOID)
)
GDI32.StartDocA(
 HDC hdc, ; handle to DC
 CONST DOCINFO *lpdi ; contains file names
)
WINSPOOL.StartDocPrinterA(
 HANDLE hPrinter, ; handle to printer object
 DWORD Level, ; information level
 LPBYTE pDocInfo ; information buffer
)
GDI32.StartPage(
 HDC hDC ; handle to DC
)
WINSPOOL.StartPagePrinter(
 HANDLE hPrinter ; handle to printer object
)
USER-DEFINED.StartProtocol(
 HANDLE NotificationEvent, ; handle to an event object
 PSUPPORT_FUNCTIONS SupportFunctions, ; address of SUPPORT_FUNCTIONS structure
 PVOID GlobalInfo ; address of configuration information
 ULONG StructureVersion,
 ULONG StructureSize,
 ULONG StructureCount
)
ADVAPI32.StartServiceA(
 SC_HANDLE hService, ; handle to service
 DWORD dwNumServiceArgs, ; number of arguments
 LPCTSTR *lpServiceArgVectors ; array of arguments
)
ADVAPI32.StartServiceCtrlDispatcherA(
 CONST LPSERVICE_TABLE_ENTRY lpServiceTable ; service table
)
USER-DEFINED.StopProtocol(VOID)
)
xxxx.StrCat(
 LPTSTR psz1,
 LPCTSTR psz2
)
xxxx.StrCatBuff(
 LPTSTR pszDestination,
 LPCTSTR pszSource,
 int cchDestBuffSize
)
xxxx.StrChrA(
 LPCSTR lpStart,
 WORD wMatch
)
xxxx.StrChrW(
 LPCWSTR lpStart,
 WCHAR wMatch
)
xxxx.StrChrIA(
 LPCSTR lpStart,
 WORD wMatch
)
xxxx.StrChrIW(
 LPCWSTR lpStart,
 WCHAR wMatch
)
xxxx.StrCmp(
 LPCTSTR lpStr1,
 LPCTSTR lpStr2
)
xxxx.StrCmpI(
 LPCTSTR lpStr1,
 LPCTSTR lpStr2
)
SHLWAPI.StrCmpNA(
 LPCTSTR lpStr1,
 LPCTSTR lpStr2,
 int nChar
)
SHLWAPI.StrCmpNIA(
 LPCTSTR lpStr1,
 LPCTSTR lpStr2,
 int nChar
)
xxxx.StrCpy(
 LPTSTR psz1,
 LPCTSTR psz2
)
SHLWAPI.StrCpyNA(
 LPTSTR psz1,
 LPCTSTR psz2,
 int cchMax
)
SHLWAPI.StrCSpnA(
 LPCTSTR lpStr,
 LPCTSTR lpSet
)
xxxx.StrCSpnIA(
 LPCTSTR lpStr,
 LPCTSTR lpSet
)
SHLWAPI.StrDupA(
 LPCTSTR lpsz
)
GDI32.StretchBlt(
 HDC hdcDest, ; handle to destination DC
 int nXOriginDest, ; x-coord of destination upper-left corner
 int nYOriginDest, ; y-coord of destination upper-left corner
 int nWidthDest, ; width of destination rectangle
 int nHeightDest, ; height of destination rectangle
 HDC hdcSrc, ; handle to source DC
 int nXOriginSrc, ; x-coord of source upper-left corner
 int nYOriginSrc, ; y-coord of source upper-left corner
 int nWidthSrc, ; width of source rectangle
 int nHeightSrc, ; height of source rectangle
 DWORD dwRop ; raster operation code
)
GDI32.StretchDIBits(
 HDC hdc, ; handle to DC
 int XDest, ; x-coord of destination upper-left corner
 int YDest, ; y-coord of destination upper-left corner
 int nDestWidth, ; width of destination rectangle
 int nDestHeight, ; height of destination rectangle
 int XSrc, ; x-coord of source upper-left corner
 int YSrc, ; y-coord of source upper-left corner
 int nSrcWidth, ; width of source rectangle
 int nSrcHeight, ; height of source rectangle
 CONST VOID *lpBits, ; bitmap bits
 CONST BITMAPINFO *lpBitsInfo, ; bitmap data
 UINT iUsage, ; usage options
 DWORD dwRop ; raster operation code
)
xxxx.StrFormatByteSizeA(
 DWORD dw,
 LPSTR pszBuf,
 UINT cchBuf
)
xxxx.StrFormatByteSizeW(
 LONGLONG qdw,
 LPWSTR pwszBuf,
 UINT cchBuf
)
xxxx.StrFormatByteSize64(
 LONGLONG qdw,
 LPTSTR pszBuf,
 UINT uiBufSize
)
xxxx.StrFormatKBSize(
 LONGLONG qdw,
 LPTSTR pszBuf,
 UINT uiBufSize
)
SHLWAPI.StrFromTimeIntervalA(
 LPTSTR pszOut,
 UINT cchMax,
 DWORD dwTimeMS,
 int digits
)
SHLWAPI.StrIsIntlEqualA(
 BOOL fCaseSens,
 LPCTSTR lpString1,
 LPCTSTR lpString2,
 int nChar
)
SHLWAPI.StrNCatA(
 LPTSTR pszFront,
 LPCTSTR pszBack,
 int cchMax
)
GDI32.StrokeAndFillPath(
 HDC hdc ; handle to DC
)
GDI32.StrokePath(
 HDC hdc ; handle to DC
)
SHLWAPI.StrPBrkA(
 LPCTSTR psz,
 LPCTSTR pszSet
)
xxxx.StrRChrA(
 LPCSTR lpStart,
 LPCSTR lpEnd,
 WORD wMatch
)
xxxx.StrRChrW(
 LPCWSTR lpStart,
 LPCWSTR lpEnd,
 WCHAR wMatch
)
xxxx.StrRChrIA(
 LPCSTR lpStart,
 LPCSTR lpEnd,
 WORD wMatch
)
xxxx.StrRChrIW(
 LPCWSTR lpStart,
 LPCWSTR lpEnd,
 WCHAR wMatch
)
xxxx.StrRetToBuf(
 LPSTRRET pstr,
 LPCITEMIDLIST pidl,
 LPTSTR pszBuf,
 UINT cchBuf
)
xxxx.StrRetToStr(
 LPSTRRET pstr,
 LPCITEMIDLIST pidl,
 LPTSTR *ppszName
)
xxxx.StrRStrI(
 LPCTSTR pszSource,
 LPCTSTR pszLast,
 LPCTSTR pszSrch
)
SHLWAPI.StrSpnA(
 LPCTSTR psz,
 LPCTSTR pszSet
)
SHLWAPI.StrStrA(
 LPCTSTR lpFirst,
 LPCTSTR lpSrch
)
xxxx.StrStrIA(
 LPCTSTR lpFirst,
 LPCTSTR lpSrch
)
SHLWAPI.StrToIntA(
 LPCTSTR lpSrc
)
SHLWAPI.StrToIntExA(
 LPCTSTR pszString,
 DWORD dwFlags,
 int FAR *piRet
)
xxxx.StrToInt64Ex(
 LPCTSTR pszString,
 DWORD dwFlags,
 LONGLONG *pllRet
)
SHLWAPI.StrTrimA(
 LPTSTR pszSource,
 LPCTSTR pszTrimChars
)
USER32.SubtractRect(
 LPRECT lprcDst, ; destination rectangle
 CONST RECT *lprcSrc1, ; first rectangle
 CONST RECT *lprcSrc2 ; second rectangle
)
KERNEL32.SuspendThread(
 HANDLE hThread ; handle to thread
)
xxxx.SUUserPopData(
 VOID VWPTR *pData,
 HPROC reserved
)
xxxx.SUUserPushData(
 VOID VWPTR *pData,
 HPROC reserved
)
xxxx.SUUserRetrieveData(
 WORD wIndex,
 VOID VWPTR *pData,
 HPROC reserved
)
xxxx.SUUserSaveData(
 VOID VWPTR *pData,
 HPROC reserved
)
USER32.SwitchDesktop(
 HDESK hDesktop ; handle to desktop to activate
)
KERNEL32.SwitchToFiber(
 LPVOID lpFiber ; fiber to schedule
)
KERNEL32.SwitchToThread(VOID)
)
xxxx.SyncUpdateProc(
 LPVOID pData,
 PDS_REPSYNCALL_UPDATE pUpdate
)
USER-DEFINED.SysMsgProc(
 int nCode, ; message flag
 WPARAM wParam, ; not used
 LPARAM lParam ; message data
)
USER32.SystemParametersInfoA(
 UINT uiAction, ; system parameter to retrieve or set
 UINT uiParam, ; depends on action to be taken
 PVOID pvParam, ; depends on action to be taken
 UINT fWinIni ; user profile update option
)
KERNEL32.SystemTimeToFileTime(
 CONST SYSTEMTIME *lpSystemTime, ; system time
 LPFILETIME lpFileTime ; file time
)
KERNEL32.SystemTimeToTzSpecificLocalTime(
 LPTIME_ZONE_INFORMATION lpTimeZone, ; time zone
 LPSYSTEMTIME lpUniversalTime, ; universal time
 LPSYSTEMTIME lpLocalTime ; local time
)
MAPI32.SzFindCh(
 LPCTSTR lpsz,
 USHORT ch
)
MAPI32.SzFindLastCh(
 LPCTSTR lpsz,
 USHORT ch
)
USER32.TabbedTextOut(
 HDC hDC, ; handle to DC
 int X, ; x-coord of start
 int Y, ; y-coord of start
 LPCTSTR lpString, ; character string
 int nCount, ; number of characters
 int nTabPositions, ; number of tabs in array
 CONST LPINT lpnTabStopPositions, ; array of tab positions
 int nTabOrigin ; start of tab expansion
)
TAPI32.tapiGetLocationInfoA(
 LPSTR lpszCountryCode,
 LPSTR lpszCityCode
)
xxxx.tapiRequestDrop(Obsolete)
)
xxxx.tapiRequestMakeCallA(
 LPCSTR lpszDestAddress,
 LPCSTR lpszAppName,
 LPCSTR lpszCalledParty,
 LPCSTR lpszComment
)
xxxx.tapiRequestMediaCallA(Obsolete)
)
xxxx.TerminateJobObject(
 HANDLE hJob, ; handle to job
 UINT uExitCode ; exit code
)
KERNEL32.TerminateProcess(
 HANDLE hProcess, ; handle to the process
 UINT uExitCode ; exit code for the process
)
KERNEL32.TerminateThread(
 HANDLE hThread, ; handle to thread
 DWORD dwExitCode ; exit code
)
GDI32.TextOutA(
 HDC hdc, ; handle to DC
 int nXStart, ; x-coordinate of starting position
 int nYStart, ; y-coordinate of starting position
 LPCTSTR lpString, ; character string
 int cbString ; number of characters
)
KERNEL32.Thread32First(
 HANDLE hSnapshot,
 LPTHREADENTRY32 lpte
)
KERNEL32.Thread32Next(
 HANDLE hSnapshot,
 LPTHREADENTRY32 lpte
)
USER-DEFINED.ThreadProc(
 LPVOID lpParameter ; thread data
)
USER32.TileWindows(
 HWND hwndParent, ; handle to parent window
 UINT wHow, ; tiling options
 CONST RECT *lpRect, ; client area
 UINT cKids, ; number of windows to arrange
 const HWND *lpKids ; array of window handles
)
USER-DEFINED.TimerAPCProc(
 LPVOID lpArgToCompletionRoutine, ; data value
 DWORD dwTimerLowValue, ; timer low value
 DWORD dwTimerHighValue ; timer high value
)
USER-DEFINED.TimerProc(
 HWND hwnd, ; handle to window
 UINT uMsg, ; WM_TIMER message
 UINT_PTR idEvent, ; timer identifier
 DWORD dwTime ; current system time
)
KERNEL32.TlsAlloc(VOID)
)
KERNEL32.TlsFree(
 DWORD dwTlsIndex ; TLS index
)
KERNEL32.TlsGetValue(
 DWORD dwTlsIndex ; TLS index
)
KERNEL32.TlsSetValue(
 DWORD dwTlsIndex, ; TLS index
 LPVOID lpTlsValue ; value to store
)
USER32.ToAscii(
 UINT uVirtKey, ; virtual-key code
 UINT uScanCode, ; scan code
 CONST PBYTE lpKeyState, ; key-state array
 LPWORD lpChar, ; buffer for translated key
 UINT uFlags ; active-menu option
)
USER32.ToAsciiEx(
 UINT uVirtKey, ; virtual-key code
 UINT uScanCode, ; scan code
 CONST PBYTE lpKeyState, ; key-state array
 LPWORD lpChar, ; buffer for translated key
 UINT uFlags, ; active-menu option
 HKL dwhkl ; input locale identifier
)
KERNEL32.Toolhelp32ReadProcessMemory(
 DWORD th32ProcessID,
 LPCVOID lpBaseAddress,
 LPVOID lpBuffer,
 DWORD cbRead,
 LPDWORD lpNumberOfBytesRead
)
USER32.ToUnicode(
 UINT wVirtKey, ; virtual-key code
 UINT wScanCode, ; scan code
 CONST PBYTE lpKeyState, ; key-state array
 LPWSTR pwszBuff, ; translated key buffer
 int cchBuff, ; size of translated key buffer
 UINT wFlags ; function options
)
USER32.ToUnicodeEx(
 UINT wVirtKey, ; virtual-key code
 UINT wScanCode, ; scan code
 CONST PBYTE lpKeyState, ; key-state array
 LPWSTR pwszBuff, ; translated key buffer
 int cchBuff, ; size of translated key buffer
 UINT wFlags, ; function options
 HKL dwhkl ; input locale identifier
)
RTUTILS.TraceDeregisterA(
 DWORD dwTraceID ; handle from initial TraceRegister call
)
RTUTILS.TraceDump(
 DWORD dwTraceID, ; handle from initial TraceRegister call
 LPBYTE lpbBytes, ; pointer to dump buffer
 DWORD dwByteCount, ; number of bytes to dump
 DWORD dwGroupSize, ; size of byte grouping (1,2 or4)
 BOOL bAddressPrefix, ; include memory address toggle
 LPCTSTR lpszPrefix ; prefix
)
RTUTILS.TraceDumpExA(
 DWORD dwTraceID,
 DWORD dwFlags, ; OPTIONAL
 LPBYTE lpbBytes,
 DWORD dwByteCount,
 DWORD dwGroupSize,
 BOOL bAddressPrefix,
 LPCTSTR lpszPrefix
)
RTUTILS.TracePrintf(
 DWORD dwTraceID, ; handle from initial TraceRegister call
 LPCTSTR lpszFormat, ; printf()-style formatting information
 ... ; one or more optional arguments
)
RTUTILS.TracePrintfEx(
 DWORD dwTraceID, ; handle returned by TraceRegister
 DWORD dwFlags, ; flags to control output
 LPCTSTR lpszFormat, ; pointer to printf-style format string
 ... ; optional args, which depend on format string.
)
RTUTILS.TracePuts(
 DWORD dwTraceID,
 LPCTSTR lpszString
)
RTUTILS.TracePutsExA(
 DWORD dwTraceID,
 DWORD dwFlags, ; OPTIONAL
 LPCTSTR lpszString
)
RTUTILS.TraceRegister(
 LPCTSTR lpszCallerName ; caller name
)
RTUTILS.TraceRegisterExA(
 LPCTSTR lpszCallerName,
 DWORD dwFlags ; OPTIONAL
)
RTUTILS.TraceVprintf(
 DWORD dwTraceID, ; handle from initial TraceRegister call
 LPCTSTR lpszFormat, ; printf-style formatting information
 va_list arglist ; prepared list of variable arguments
)
RTUTILS.TraceVprintfExA(
 DWORD dwTraceID,
 DWORD dwFlags, ; OPTIONAL
 LPCTSTR lpszFormat,
 va_list arglist
)
USER32.TrackMouseEvent(
 LPTRACKMOUSEEVENT lpEventTrack ; tracking information
)
USER32.TrackPopupMenu(
 HMENU hMenu, ; handle to shortcut menu
 UINT uFlags, ; options
 int x, ; horizontal position
 int y, ; vertical position
 int nReserved, ; reserved, must be zero
 HWND hWnd, ; handle to owner window
 CONST RECT *prcRect ; ignored
)
USER32.TrackPopupMenuEx(
 HMENU hmenu, ; handle to shortcut menu
 UINT fuFlags, ; options
 int x, ; horizontal position
 int y, ; vertical position
 HWND hwnd, ; handle to window
 LPTPMPARAMS lptpm ; area not to overlap
)
KERNEL32.TransactNamedPipe(
 HANDLE hNamedPipe, ; handle to named pipe
 LPVOID lpInBuffer, ; write buffer
 DWORD nInBufferSize, ; size of write buffer
 LPVOID lpOutBuffer, ; read buffer
 DWORD nOutBufferSize, ; size of read buffer
 LPDWORD lpBytesRead, ; bytes read
 LPOVERLAPPED lpOverlapped ; overlapped structure
)
USER32.TranslateAcceleratorA(
 HWND hWnd, ; handle to destination window
 HACCEL hAccTable, ; handle to accelerator table
 LPMSG lpMsg ; message information
)
GDI32.TranslateCharsetInfo(
 DWORD *lpSrc, ; information
 LPCHARSETINFO lpCs, ; character set information
 DWORD dwFlags ; translation option
)
USER32.TranslateMDISysAccel(
 HWND hWndClient, ; handle to MDI client window
 LPMSG lpMsg ; message data
)
USER32.TranslateMessage(
 CONST MSG *lpMsg ; message information
)
xxxx.TranslateName(
 LPCTSTR lpAccountName, ; object name
 EXTENDED_NAME_FORMAT AccountNameFormat, ; name format
 EXTENDED_NAME_FORMAT DesiredNameFormat, ; new name format
 LPTSTR lpTranslatedName, ; name buffer
 PULONG nSize ; buffer size
)
xxxx.TranslateURLA(
 LPCSTR pcszURL,
 DWORD dwInFlags,
 LPSTR *ppszTranslatedURL
)
KERNEL32.TransmitCommChar(
 HANDLE hFile, ; handle to communications device
 char cChar ; character to transmit
)
MSIMG32.TransparentBlt(
 HDC hdcDest, ; handle to destination DC
 int nXOriginDest, ; x-coord of destination upper-left corner
 int nYOriginDest, ; y-coord of destination upper-left corner
 int nWidthDest, ; width of destination rectangle
 int hHeightDest, ; height of destination rectangle
 HDC hdcSrc, ; handle to source DC
 int nXOriginSrc, ; x-coord of source upper-left corner
 int nYOriginSrc, ; y-coord of source upper-left corner
 int nWidthSrc, ; width of source rectangle
 int nHeightSrc, ; height of source rectangle
 UINT crTransparent ; color to make transparent
)
KERNEL32.TryEnterCriticalSection(
 LPCRITICAL_SECTION lpCriticalSection ; critical section
)
MAPI32.UFromSz(
 LPCTSTR lpsz
)
MAPI32.UlFromSzHex(
 LPCTSTR lpsz
)
MAPI32.UlAddRef(
 LPVOID punk
)
MAPI32.UlPropSize(
 LPSPropValue lpSPropValue
)
MAPI32.UlRelease(
 LPVOID punk
)
MAPI32.UlValidateParameters(
 METHODS eMethod,
 LPVOID First
)
MAPI32.UlValidateParms(
 METHODS eMethod,
 LPVOID First
)
USER-DEFINED.UnbindInterface(
 ULONG InterfaceIndex ; index of the interface
)
USER-DEFINED.UndeleteFile(
 HWND hwndOwner,
 LPSTR lpszDir
)
KERNEL32.UnhandledExceptionFilter(
 STRUCT _EXCEPTION_POINTERS *ExceptionInfo
)
xxxx.UnhookWindowsHook(OBSOLETE - Use UnhookWindowsHookEx)
)
USER32.UnhookWindowsHookEx(
 HHOOK hhk ; handle to hook procedure
)
COMCTL32.UninitializeFlatSB(
 HWND hwnd
)
USER32.UnionRect(
 LPRECT lprcDst, ; destination rectangle
 CONST RECT *lprcSrc1, ; first rectangle
 CONST RECT *lprcSrc2 ; second rectangle
)
USER32.UnloadKeyboardLayout(
 HKL hkl ; input locale identifier
)
xxxx.UnloadUserProfile(
 HANDLE hToken, ; user token
 HANDLE hProfile ; handle to registry key
)
KERNEL32.UnlockFile(
 HANDLE hFile, ; handle to file
 DWORD dwFileOffsetLow, ; low-order word of start
 DWORD dwFileOffsetHigh, ; high-order word of start
 DWORD nNumberOfBytesToUnlockLow, ; low-order word of length
 DWORD nNumberOfBytesToUnlockHigh ; high-order word of length
)
KERNEL32.UnlockFileEx(
 HANDLE hFile, ; handle to file
 DWORD dwReserved, ; reserved
 DWORD nNumberOfBytesToUnlockLow, ; low-order part of length
 DWORD nNumberOfBytesToUnlockHigh, ; high-order part of length
 LPOVERLAPPED lpOverlapped ; unlock region start
)
xxxx.UnlockResource(OBSOLETE)
)
xxxx.UnlockSegment(OBSOLETE)
)
ADVAPI32.UnlockServiceDatabase(
 SC_LOCK ScLock ; SCM database lock
)
KERNEL32.UnmapViewOfFile(
 LPCVOID lpBaseAddress ; starting address
)
USER32.UnpackDDElParam(
 UINT msg, ; posted DDE message
 LPARAM lParam, ; lParam of posted DDE message
 PUINT_PTR puiLo, ; low-order word of lParam
 PUINT_PTR puiHi ; high-order word of lParam
)
GDI32.UnrealizeObject(
 HGDIOBJ hgdiobj ; handle to logical palette
)
USER32.UnregisterClassA(
 LPCTSTR lpClassName, ; class name
 HINSTANCE hInstance ; handle to application instance
)
xxxx.UnregisterDeviceNotification(
 HDEVNOTIFY Handle
)
USER32.UnregisterHotKey(
 HWND hWnd, ; handle to window
 int id ; hot key identifier
)
xxxx.UnregisterWait(
 HANDLE WaitHandle ; wait handle
)
xxxx.UnregisterWaitEx(
 HANDLE WaitHandle, ; wait handle
 HANDLE CompletionEvent ; completion event
)
GDI32.UpdateColors(
 HDC hdc ; handle to DC
)
xxxx.UpdateLayeredWindow(
 HWND hwnd, ; handle to layered window
 HDC hdcDst, ; handle to screen DC
 POINT *pptDst, ; new screen position
 SIZE *psize, ; new size of the layered window
 HDC hdcSrc, ; handle to surface DC
 POINT *pptSrc, ; layer position
 COLORREF crKey, ; color key
 BLENDFUNCTION *pblend, ; blend function
 DWORD dwFlags ; options
)
KERNEL32.UpdateResourceA(
 HANDLE hUpdate, ; update-file handle
 LPCTSTR lpType, ; resource type
 LPCTSTR lpName, ; resource name
 WORD wLanguage, ; language identifier
 LPVOID lpData, ; resource data
 DWORD cbData ; length of resource data
)
USER32.UpdateWindow(
 HWND hWnd ; handle to window
)
xxxx.UrlApplySchemeA(
 LPCTSTR pszIn,
 LPTSTR pszOut,
 LPDWORD pcchOut,
 DWORD dwFlags
)
xxxx.URLAssociationDialogA(
 HWND hwndParent,
 DWORD dwInFlags,
 LPCSTR pcszFile,
 LPCSTR pcszURL,
 LPSTR pszAppBuf,
 UINT ucAppBufLen
)
xxxx.UrlCanonicalizeA(
 LPCTSTR pszUrl,
 LPTSTR pszCanonicalized,
 LPDWORD pcchCanonicalized,
 DWORD dwFlags
)
xxxx.UrlCombineA(
 LPCTSTR pszBase,
 LPCTSTR pszRelative,
 LPTSTR pszCombined,
 LPDWORD pcchCombined,
 DWORD dwFlags
)
xxxx.UrlCompareA(
 LPCTSTR pszURL1,
 LPCTSTR pszURL2,
 BOOL fIgnoreSlash
)
xxxx.UrlCreateFromPathA(
 LPCTSTR pszPath,
 LPTSTR pszUrl,
 LPDWORD pcchUrl,
 DWORD dwReserved
)
xxxx.UrlEscapeA(
 LPCTSTR pszURL,
 LPTSTR pszEscaped,
 LPDWORD pcchEscaped,
 DWORD dwFlags
)
xxxx.UrlEscapeSpaces(
 LPCTSTR pszURL,
 LPTSTR pszEscaped,
 LPDWORD pcchEscaped
)
xxxx.UrlGetLocationA(
 LPCTSTR pszURL
)
xxxx.UrlGetPartA(
 LPCTSTR pszIn,
 LPTSTR pszOut,
 LPDWORD pcchOut,
 DWORD dwPart,
 DWORD dwFlags
)
xxxx.UrlHashA(
 LPCTSTR pszURL,
 LPBYTE pbHash,
 DWORD cbHash
)
xxxx.UrlIsA(
 LPCTSTR pszUrl,
 URLIS UrlIs
)
xxxx.UrlIsFileUrl(
 LPCTSTR pszUrl
)
xxxx.UrlIsNoHistoryA(
 LPCTSTR pszURL
)
xxxx.UrlIsOpaqueA(
 LPCTSTR pszURL
)
xxxx.UrlUnescapeA(
 LPTSTR pszURL,
 LPTSTR pszUnescaped,
 LPDWORD pcchUnescaped,
 DWORD dwFlags
)
xxxx.UrlUnescapeInPlace(
 LPTSTR pszURL,
 DWORD dwFlags
)
KERNEL32.UserHandleGrantAccess(
 HANDLE hUserHandle, ; handle to User object
 HANDLE hJob, ; handle to job
 BOOL bGrant ; access granted or denied
)
MAPI32.ValidateParameters(
 METHODS eMethod,
 LPVOID First
)
MAPI32.ValidateParms(
 METHODS eMethod,
 LPVOID First
)
USER32.ValidateRect(
 HWND hWnd, ; handle to window
 CONST RECT *lpRect ; validation rectangle coordinates
)
USER32.ValidateRgn(
 HWND hWnd, ; handle to window
 HRGN hRgn ; handle to region
)
xxxx.VectoredHandler(
 PEXCEPTION_POINTERS ExceptionInfo
)
VERSION.VerFindFileA(
 DWORD dwFlags, ; option
 LPTSTR szFileName, ; file to be installed
 LPTSTR szWinDir, ; Windows directory
 LPTSTR szAppDir, ; install directory
 LPTSTR szCurDir, ; current directory buffer
 PUINT lpuCurDirLen, ; size of current directory buffer
 LPTSTR szDestDir, ; recommended destination directory buffer
 PUINT lpuDestDirLen ; size of destination directory buffer
)
xxxx.VERIFYSERVERCERT(
 PLDAP Connection,
 PCCERT_CONTEXT pServerCert
)
xxxx.VerifyVersionInfo(
 LPOSVERSIONINFOEX lpVersionInfo, ; version info
 DWORD dwTypeMask, ; attributes
 DWORDLONG dwlConditionMask ; comparison type
)
VERSION.VerInstallFileA(
 DWORD uFlags, ; options
 LPTSTR szSrcFileName, ; file to install
 LPTSTR szDestFileName, ; name of installed file
 LPTSTR szSrcDir, ; source directory
 LPTSTR szDestDir, ; install directory
 LPTSTR szCurDir, ; current directory
 LPTSTR szTmpFile, ; temporary file name buffer
 PUINT lpuTmpFileLen ; size of temporary file name buffer
)
KERNEL32.VerLanguageNameA(
 DWORD wLang, ; Microsoft language identifier
 LPTSTR szLang, ; language description buffer
 DWORD nSize ; size of buffer
)
VERSION.VerQueryValueA(
 const LPVOID pBlock, ; buffer for version resource
 LPTSTR lpSubBlock, ; value to retrieve
 LPVOID *lplpBuffer, ; buffer for version value pointer
 PUINT puLen ; version length
)
xxxx.VerSetConditionMask(
 ULONGLONG dwlConditionMask, ; mask whose bits are set
 DWORD dwTypeBitMask, ; type of attribute
 BYTE dwConditionMask ; type of comparison
)
KERNEL32.VirtualAlloc(
 LPVOID lpAddress, ; region to reserve or commit
 SIZE_T dwSize, ; size of region
 DWORD flAllocationType, ; type of allocation
 DWORD flProtect ; type of access protection
)
KERNEL32.VirtualAllocEx(
 HANDLE hProcess, ; process to allocate memory
 LPVOID lpAddress, ; desired starting address
 SIZE_T dwSize, ; size of region to allocate
 DWORD flAllocationType, ; type of allocation
 DWORD flProtect ; type of access protection
)
KERNEL32.VirtualFree(
 LPVOID lpAddress, ; address of region
 SIZE_T dwSize, ; size of region
 DWORD dwFreeType ; operation type
)
KERNEL32.VirtualFreeEx(
 HANDLE hProcess, ; handle to process
 LPVOID lpAddress, ; starting address of memory region
 SIZE_T dwSize, ; size of memory region
 DWORD dwFreeType ; operation type
)
KERNEL32.VirtualLock(
 LPVOID lpAddress, ; first byte in range
 SIZE_T dwSize ; number of bytes in range
)
KERNEL32.VirtualProtect(
 LPVOID lpAddress, ; region of committed pages
 SIZE_T dwSize, ; size of the region
 DWORD flNewProtect, ; desired access protection
 PDWORD lpflOldProtect ; old protection
)
KERNEL32.VirtualProtectEx(
 HANDLE hProcess, ; handle to process
 LPVOID lpAddress, ; region of committed pages
 SIZE_T dwSize, ; size of region
 DWORD flNewProtect, ; desired access protection
 PDWORD lpflOldProtect ; old protection
)
KERNEL32.VirtualQuery(
 LPCVOID lpAddress, ; address of region
 PMEMORY_BASIC_INFORMATION lpBuffer, ; information buffer
 DWORD dwLength ; size of buffer
)
KERNEL32.VirtualQueryEx(
 HANDLE hProcess, ; handle to process
 LPCVOID lpAddress, ; address of region
 PMEMORY_BASIC_INFORMATION lpBuffer, ; information buffer
 DWORD dwLength ; size of buffer
)
KERNEL32.VirtualUnlock(
 LPVOID lpAddress, ; first byte in range
 SIZE_T dwSize ; number of bytes in range
)
USER32.VkKeyScanA(
 TCHAR ch ; character to translate
)
USER32.VkKeyScanExA(
 TCHAR ch, ; character to translate
 HKL dwhkl ; input locale identifier
)
xxxx.VwStreamCloseFunc(
 SOFILE hFile,
 HPROC reserved
)
xxxx.VwStreamOpenFunc(
 SOFILE hFile,
 INT wFileId,
 U_BYTE VWPTR *pFileName,
 SOFILTERINFO VWPTR *pFilterInfo,
 HPROC reserved
)
xxxx.VwStreamReadFunc(
 SOFILE hFile,
 HPROC reserved
)
xxxx.VwStreamReadRecordFunc(
 SOFILE hFile,
 DWORD dwData,
 HPROC reserved
)
xxxx.VwStreamSectionFunc(
 SOFILE hFile,
 HPROC reserved
)
xxxx.VwStreamSeekFunc(
 SOFILE hFile,
 HPROC reserved
)
xxxx.VwStreamTellFunc(
 SOFILE hFile,
 HPROC reserved
)
KERNEL32.WaitCommEvent(
 HANDLE hFile, ; handle to comm device
 LPDWORD lpEvtMask, ; event type
 LPOVERLAPPED lpOverlapped ; overlapped structure
)
KERNEL32.WaitForDebugEvent(
 LPDEBUG_EVENT lpDebugEvent, ; debug event information
 DWORD dwMilliseconds ; time-out value
)
USER32.WaitForInputIdle(
 HANDLE hProcess, ; handle to process
 DWORD dwMilliseconds ; time-out interval
)
KERNEL32.WaitForMultipleObjects(
 DWORD nCount, ; number of handles in array
 CONST HANDLE *lpHandles, ; object-handle array
 BOOL fWaitAll, ; wait option
 DWORD dwMilliseconds ; time-out interval
)
KERNEL32.WaitForMultipleObjectsEx(
 DWORD nCount, ; number of handles in array
 CONST HANDLE *lpHandles, ; object-handle array
 BOOL fWaitAll, ; wait option
 DWORD dwMilliseconds, ; time-out interval
 BOOL bAlertable ; alertable option
)
xxxx.WaitForPrinterChange(OBSOLETE)
)
KERNEL32.WaitForSingleObject(
 HANDLE hHandle, ; handle to object
 DWORD dwMilliseconds ; time-out interval
)
KERNEL32.WaitForSingleObjectEx(
 HANDLE hHandle, ; handle to object
 DWORD dwMilliseconds, ; time-out interval
 BOOL bAlertable ; alertable option
)
USER32.WaitMessage(VOID)
)
KERNEL32.WaitNamedPipeA(
 LPCTSTR lpNamedPipeName, ; pipe name
 DWORD nTimeOut ; time-out interval
)
xxxx.WaitOrTimerCallback(
 PVOID lpParameter, ; thread data
 BOOLEAN TimerOrWaitFired ; reason
)
KERNEL32.WideCharToMultiByte(
 UINT CodePage, ; code page
 DWORD dwFlags, ; performance and mapping flags
 LPCWSTR lpWideCharStr, ; wide-character string
 int cchWideChar, ; number of chars in string
 LPSTR lpMultiByteStr, ; buffer for new string
 int cbMultiByte, ; size of buffer
 LPCSTR lpDefaultChar, ; default for unmappable chars
 LPBOOL lpUsedDefaultChar ; set when default char used
)
GDI32.WidenPath(
 HDC hdc ; handle to DC
)
USER32.WindowFromDC(
 HDC hDC ; handle to window
)
USER32.WindowFromPoint(
 POINT Point ; point
)
USER-DEFINED.WindowProc(
 HWND hwnd, ; handle to window
 UINT uMsg, ; message identifier
 WPARAM wParam, ; first message parameter
 LPARAM lParam ; second message parameter
)
KERNEL32..WinExec(
 LPCSTR lpCmdLine, ; command line
 UINT uCmdShow ; window style
)
USER32.WinHelp(
 HWND hWndMain,
 LPCTSTR lpszHelp,
 UINT uCommand,
 DWORD dwData
)
USER-DEFINED.WinMain(
 HINSTANCE hInstance, ; handle to current instance
 HINSTANCE hPrevInstance, ; handle to previous instance
 LPSTR lpCmdLine, ; command line
 int nCmdShow ; show state
)
USER-DEFINED.WIZARDENTRY(
 HINSTANCE hProviderDLLInstance,
 LPTSTR FAR * lpcsResourceName,
 DLGPROC FAR * lppDlgProc,
 LPMAPIPROP lpMAPIProp,
)
xxxx.wnsprintf(
 LPTSTR lpOut,
 int cchLimitIn,
 LPCTSTR pszFmt,
 ...
)
MAPI32.WrapCompressedRTFStream(
 LPSTREAM lpCompressedRTFStream,
 ULONG ulflags,
 LPSTREAM FAR * lpUncompressedRTFStream
)
MAPI32.WrapStoreEntryID(
 ULONG ulFlags,
 LPTSTR szDLLName,
 ULONG cbOrigEntry,
 LPENTRYID lpOrigEntry,
 ULONG * lpcbWrappedEntry,
 LPENTRYID * lppWrappedEntry
)
KERNEL32.WriteConsoleA(
 HANDLE hConsoleOutput, ; handle to screen buffer
 CONST VOID *lpBuffer, ; write buffer
 DWORD nNumberOfCharsToWrite, ; number of characters to write
 LPDWORD lpNumberOfCharsWritten, ; number of characters written
 LPVOID lpReserved ; reserved
)
KERNEL32.WriteConsoleInputA(
 HANDLE hConsoleInput, ; handle to console input buffer
 CONST INPUT_RECORD *lpBuffer, ; data buffer
 DWORD nLength, ; number of records to write
 LPDWORD lpNumberOfEventsWritten ; number of records written
)
KERNEL32.WriteConsoleOutputA(
 HANDLE hConsoleOutput, ; handle to screen buffer
 CONST CHAR_INFO *lpBuffer, ; data buffer
 COORD dwBufferSize, ; size of data buffer
 COORD dwBufferCoord, ; cell coordinates
 PSMALL_RECT lpWriteRegion ; rectangle to write
)
KERNEL32.WriteConsoleOutputAttribute(
 HANDLE hConsoleOutput, ; handle to screen buffer
 CONST WORD *lpAttribute, ; write attributes
 DWORD nLength, ; number of cells
 COORD dwWriteCoord, ; first cell coordinates
 LPDWORD lpNumberOfAttrsWritten ; number of cells written
)
KERNEL32.WriteConsoleOutputCharacterA(
 HANDLE hConsoleOutput, ; handle to screen buffer
 LPCTSTR lpCharacter, ; characters
 DWORD nLength, ; number of characters to write
 COORD dwWriteCoord, ; first cell coordinates
 LPDWORD lpNumberOfCharsWritten ; number of cells written
)
KERNEL32.WriteFile(
 HANDLE hFile, ; handle to file
 LPCVOID lpBuffer, ; data buffer
 DWORD nNumberOfBytesToWrite, ; number of bytes to write
 LPDWORD lpNumberOfBytesWritten, ; number of bytes written
 LPOVERLAPPED lpOverlapped ; overlapped buffer
)
KERNEL32.WriteFileEx(
 HANDLE hFile, ; handle to output file
 LPCVOID lpBuffer, ; data buffer
 DWORD nNumberOfBytesToWrite, ; number of bytes to write
 LPOVERLAPPED lpOverlapped, ; overlapped buffer
 LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine ; completion routine
)
KERNEL32.WriteFileGather(
 HANDLE hFile, ; handle to file
 FILE_SEGMENT_ELEMENT aSegmentArray[ ], ; array of buffer pointers
 DWORD nNumberOfBytesToWrite, ; number of bytes to write
 LPDWORD lpReserved, ; reserved; must be NULL
 LPOVERLAPPED lpOverlapped ; overlapped buffer
)
WINSPOOL.WritePrinter(
 HANDLE hPrinter, ; handle to printer object
 LPVOID pBuf, ; array of printer data
 DWORD cbBuf, ; size of array
 LPDWORD pcWritten ; bytes received
)
xxxx.WritePrivateProfileSectionA(
 LPCTSTR lpAppName, ; section name
 LPCTSTR lpString, ; data
 LPCTSTR lpFileName ; file name
)
xxxx.WritePrivateProfileStringA(
 LPCTSTR lpAppName, ; section name
 LPCTSTR lpKeyName, ; key name
 LPCTSTR lpString, ; string to add
 LPCTSTR lpFileName ; initialization file
)
xxxx.WritePrivateProfileStructA(
 LPCTSTR lpszSection, ; section name
 LPCTSTR lpszKey, ; key name
 LPVOID lpStruct, ; data buffer
 UINT uSizeStruct, ; size of data buffer
 LPCTSTR szFile ; initialization file
)
KERNEL32.WriteProcessMemory(
 HANDLE hProcess, ; handle to process
 LPVOID lpBaseAddress, ; base of memory area
 LPVOID lpBuffer, ; data buffer
 DWORD nSize, ; number of bytes to write
 LPDWORD lpNumberOfBytesWritten ; number of bytes written
)
xxxx.WriteProfileSectionA(
 LPCTSTR lpAppName, ; section name
 LPCTSTR lpString ; data buffer
)
xxxx.WriteProfileStringA(
 LPCTSTR lpAppName, ; section name
 LPCTSTR lpKeyName, ; key name
 LPCTSTR lpString ; string to write
)
KERNEL32.WriteTapemark(
 HANDLE hDevice, ; handle to device
 DWORD dwTapemarkType, ; tapemark type
 DWORD dwTapemarkCount, ; number of tapemarks to write
 BOOL bImmediate ; return after write begins
)
USER32.wsprintf(
 LPTSTR lpOut, ; output buffer
 LPCTSTR lpFmt, ; format-control string
 ... ; optional arguments
)
xxxx.wvnsprintf(
 LPTSTR lpOut,
 int cchLimitIn,
 LPCTSTR pszFmt,
 va_list arglist
)
USER32.wvsprintfA(
 LPTSTR lpOutput, ; buffer for output
 LPCTSTR lpFormat, ; format-control string
 va_list arglist ; variable list of format-control arguments
)
USER-DEFINED.XPProviderInit(
 HINSTANCE hInstance,
 LPMALLOC lpMalloc,
 LPALLOCATEBUFFER lpAllocateBuffer,
 LPALLOCATEMORE lpAllocateMore,
 LPFREEBUFFER lpFreeBuffer,
 ULONG ulFlags,
 ULONG ulMAPIVer,
 ULONG FAR * lpulProviderVer,
 LPXPPROVIDER FAR * lppXPProvider
)
xxxx.Yield(OBSOLETE)
)
xxxx.ZeroMemory(
 PVOID Destination, ; memory block
 SIZE_T Length ; size of memory block
)