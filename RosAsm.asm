;;

                               R O S A S M    S O U R C E

_____________________________________________________________________________________________
_____________________________________________________________________________________________


 RosAsm: The Top Down Assembler for ReactOS PE files.

 This program is free open source.

 First Author: René Tournois.
 
 (i begun to work on SpAsm, the ancestor of RosAsm, in September 1998)

 Actual maintainer: René Tournois.

____________________________________________________________________________________________
____________________________________________________________________________________________

         Copyright (C) 1998, René Tournois

         This program is free software; you can redistribute it and/or modify
         it under the terms of the GNU General Public License as published by
         the Free Software Foundation.

         This program is distributed in the hope that it will be useful,
         but WITHOUT ANY WARRANTY; without even the implied warranty of
         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
         GNU General Public License included in B_U_Asm.exe for more details.

         You should have received a copy of the GNU General Public License
         along with this program; if not, write to the Free Software
         Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

Rules:

;;
  Developments rules for the volunteers contributing to RosAsm itself


  * In order to give the Source a bit of shape, it is wishable to apply a consistent
    writing Style, where each part would try to follow up, with a couple of rules.
    See an example of the actualy choosen Style with, 'CompactLabelListAndCodeRef':
    
    - Indent must be 4 Spaces.
    
    - The Text of the Multi-Lines Comments are two spaces away from the left margin.
    
    - Mono-Lines Comments start two Spaces before the next (or previous Statement).
      Never: Comment at the end of lines.
      A comment for the next Statement(s) end(s) with a column (":")
      A comment for the previous Statement ends with a "."
      Comments must be "english only".
      Comments start with a Space after the ";".
      
    - Old fashion vertical alignements of the Statements members: NEVER.
      
    - Symbolic Names: Never: "Routine_1", "Buffer", "Variable", and so on. Never,
      ever. The Symbols must be in the form of 'InitLabelListScanDwordPointer'
      (no '_', upper case for each leading char of a component), and should be as
      self-descriptive as possible. English required.
    
    - Equates must be UPPER_CASE. ['_' tolerated inside Equates when wishable for
      readability].
      
    - Separators: Make use of [F8] only. Avoid "---------" and friends.
    
    - There still exist users with a small screen and low resolution. So, the
      Source must not be too wide. 80 Chars is a good base.
      
    - For the same reasons as above, do not use anything like "MMX and above"
    
    - Verticaly, try to make your source optimal with the most proper usage
      of blank lines.
      
    - A multi-Instructions line should "make sense": Try to not group instructions
      which have completely different purposes, and to group the ones which concure
      to a given action, such as you could give it a kind of 'name', if you were
      making it a Routine.


  * Macros:
  
    - Do not implement your own Macros.
    
  
  * At top of your TITLE, we should found, at least:
  
    - The Name of the maintainer (yours).
      
    - The Date of the first release.
      
    - The Data of the actual release.
      
    - An organized list of the TITLE Routines. See an example at the top
      of the TITLE [Optimize], above 'InitShortenJmpsTable'.


  * For exchanging (updates) with the main maintainer:
  
    - For the TITLE you make a [Ctrl][S], and save your "MyTitle.asm". RosAsm is
      full featured for this. Sending a zip of RosAsm.exe is never necessary.
      
    - For Dialogs, make use of Binary Saving Format (Menu).
      
    - The zips of these Files are all that should be necessary for the updates.
      
    - When a new implementation requires to modify something in the main Source
      (branching, typically), this is the job of the main maintainer to do that.
  
  
  * Developments "property":

    At any given time, there can only be _one_ volunteer "touching" a TITLE.
    So, the very first step, before anything else, is about defining a new TITLE
    with the main maintainer. Once done, this TITLE is your "private area", and
    nobody else is allowed to touch it as long as you are the active maintainer.
    
    If two volunteers wish to work upon the same TITLE, the TITLE must be "splitted"
    to create "each one, each private room, each provate task", even if the two TITLEs
    will be merged, later. This simple method is very helpfull for defining "who does
    what".
;;
_____________________________________________________________________________________________
_____________________________________________________________________________________________
; Colors:

[DialogsBackColor: 0_FF_FC_F2]         ; For Edit Controls, List Boxes (Default: Light Blue)

                                       ; Source Editor colors:
[NormalBackColor:  0_FF_FF_FF          ; white BackGround color (Default: light yellow)
 StatementColor: 0                     ; black for instructions
 BracketColor: 0A0                     ; [red] for Data / Equates / Macros
 TextColor: 0_64_00                    ; 'green' for text
 CommentColor: 0_82_00_00 ]            ; blue for comments


[DRAWLINELEN 92]    ; This is the number of '_' in a Line drawn by [Ctrl][_]

[UPPERCASEMASK 0DF] ; (not 020) applied on a Byte.

;;
 To modify the default font used by the [Print] feature, Right Click on >>>  cbbuffer  <<<
 and do what you can there. Be aware that specifying a font for a Printer under Win32
 is absolutely crazy; i won't help you... Welcome to the one who could rewrite this
 in RosAsm.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

; Displacements inside a 'SectionsHeaders': ; 'PeHeader'

[SECTION_NAME 0
 SECTION_RVASIZE 8
 SECTION_RVA 12
 SECTION_FILESIZE 16
 SECTION_FILEPOINTER 20

 SECTION_RELOC_PTR 24
 SECTION_LINES_NUMBER_PTR 28
 SECTION_RELOC_NUMBER 32
 SECTION_NUMBER_OF_LINES_NUMBER 34

 SECTION_FLAG 36

 SECTIONHEADERSIZE 40]
_____________________________________________________________________________________________
_____________________________________________________________________________________________

;;
 Used abreviations:

 EOI,      End Of Instruction
 meEOI,    Macro Expension EOI
 CR,       Carriage Returrn
 LF,       Line Feed
 ALEOD,    Api Lists End Of Data
 RVA,      Relative Virtual Adress
 Len,      Lenght

 Usual Tintel abreviations:

 SIB,      Scale_Base_Index Byte
 Mod/RM,   Mode and Register/Memory Byte
 tttnBits  condition encodage


 MLC       Multi-Lines Comments
;;

_____________________________________________________________________________________________
_____________________________________________________________________________________________

; General purpose macros:

[push | push #1 | #+1]  [pop | pop #1 | #+1]

[mov | mov #1 #2 | #+2]

[inc | inc #1 | #+1]    [dec | dec #1 | #+1]

[On | cmp #1 #3 | jn#2 M1> | #4>L | M1:]

[call | push #L>2 | call #1]

[move | push #2 | pop #1 | #+2]      ; (for mem to mem moves, for exemple)

[If | #=3 | cmp #1 #3 | jn#2 I1>]
[Else_if | #=3 | jmp I9> | I1: | cmp #1 #3 | jn#2 I1>]
[Else | Jmp I9> | I1:]
[End_if | I1: | I9:]

[.If | #=3 | cmp #1 #3 | jn#2 J1>>]
[.Else_if | #=3 | jmp J9>> | J1: | cmp #1 #3 | jn#2 j1>>]
[.Else | Jmp j9>> | j1:]
[.End_if | j1: | j9:]

[..If | #=3 | cmp #1 #3 | jn#2 K1>>]
[..Else_if | #=3 | jmp K9>> | K1: | cmp #1 #3 | jn#2 K1>>]
[..Else | Jmp K9>> | K1:]
[..End_if | K1: | K9:]

[...If | #=3 | cmp #1 #3 | jn#2 Z1>>]
[...Else_if | #=3 | jmp Z9>> | Z1: | cmp #1 #3 | jn#2 Z1>>]
[...Else | Jmp Z9>> | Z1:]
[...End_if | Z1: | Z9:]

[While | #=3 | W0: | cmp #1 #3 | jn#2 W9>]
[End_While | jmp W0< | W9:]

[.While | #=3 | X0: | cmp #1 #3 | jn#2 X9>>]
[.End_While | jmp X0<< | X9:]

[..While | #=3 | Y0: | cmp #1 #3 | jn#2 Y9>>]
[..End_While | jmp Y0<< | Y9:]

[Do | D0:]
[Loop_Until | #=3 | cmp #1 #3 | jn#2 D0<]
[Do_Loop | jmp D0<<]

[.Do | E0:]
[.Loop_Until | #=3 | cmp #1 #3 | jn#2 E0<<]

[Exchange | push #1 | push #2 | pop #1 | pop #2 | #+2]


[Agree | cmp #1 #3 | j#2 A9> | #+3]
[Reject | cmp #1 #3 | j#2 A8> | #+3 | jmp A9> | A8: | ret | A9:]

_________________________________________________________________________________________
_________________________________________________________________________________________
; Proc Macros and Equates. Internal storages are:
;
; &1 <<< Size of Argument(s) (for ending Ret n, in EndP). Set by Argument(s)
; &2 <<< Size of Local (for Stack Management). Set by Local
; &3 <<< What to pop before ret. Set by Uses.

[Proc | &1=0 | &2=0 | &3= | #1 | push ebp | mov ebp esp]

[ExitP | jmp P9>>]

[Arguments | {#1 Arg#x} | #+1 | &1=SizeOf#x]
[Argument  | {#1 Arg#x} | #+1 | &1=SizeOf#x]

[Local | {#1 Local#x} | #+1 | sub esp SizeOf#x | &2=SizeOf#x]

[StrucPtrs | {#3 ebp+#2+#F} | #+2]

[Structure | {#1 ebp-&2-4} | sub esp #2+4 | mov D$#1 esp | StrucPtrs 0-&2-#2-4 #L>3]

[Uses | push #1>L | &3=pop #L>1]

[EndP | P9: | &3 | mov esp ebp | pop ebp | ret &1]

; For pointing to transmitted parameters (upper "Arg#x" fall here):

[Arg1 ebp+8    Arg2 ebp+12    Arg3 ebp+16    Arg4 ebp+20   Arg5 ebp+24
 Arg6 ebp+28   Arg7 ebp+32    Arg8 ebp+36    Arg9 ebp+40   Arg10 ebp+44]

; For pointing Local Stack declared data (upper "Local#x" fall here):

[Local1 ebp-4     Local2 ebp-8     Local3 ebp-12    Local4 ebp-16    Local5 ebp-20
 Local6 ebp-24    Local7 ebp-28    Local8 ebp-32    Local9 ebp-36    Local10 ebp-40]

; To help preventing from stack sizes' mistakes (upper "SizeOf#x" fall here):

[SizeOf1 4     SizeOf2 8     SizeOf3 12    SizeOf4 16    SizeOf5 20
 SizeOf6 24    SizeOf7 28    SizeOf8 32    SizeOf9 36    SizeOf10 40]

____________________________________________________________________________________________
____________________________________________________________________________________________
; Equates for HLL comparisons (with 'If' and friends):

[= e   < b    > a    <s l    >s g    =< be    <= be    => ae    >= ae    <> ne]

_____________________________________________________________________________________________
_____________________________________________________________________________________________

; Some basic System calls:

[PrintErrorCode | call 'KERNEL32.GetLastError' | hexprint eax]

 ________________________________________________________________________________________

; Messages:

; in: eax = string adress

MessageBox:
    call 'USER32.MessageBoxA' D$hwnd,               ; hwin
                             eax,                   ; Message
                             D$ErrorMessageTitlePtr,     ; Message-Window-Title
                             &MB_SYSTEMMODAL        ; Style (0 to 4) 0 > 'OK'
ret
 ________________________________________________________________________________________

[HexprintString: '        h', 0]

HexPrn:
    mov ebx, eax | mov edi HexPrintString | add edi 7
    std
        mov ecx, 8
L1:     mov al bl | and al 0F | On al >= 0A, add al 7
        add al, '0' | stosb | shr ebx, 4 | loop L1
    cld
    call 'USER32.MessageBoxA' D$hwnd, HexPrintString, ErrorMessageTitle, &MB_SYSTEMMODAL
ret

[HexPrint | pushad | push #1 | pop eax | call hexprn | popad | #+1]
[ShowMe | pushad  | call 'USER32.MessageBoxA' D$hwnd, #1, argh, &MB_SYSTEMMODAL | popad]

____________________________________________________________________________________________
____________________________________________________________________________________________

; Replaces a Chunk in an existing Data set, by another Chunk.

Proc ChunkReplace:
    Argument @TargetA,          ; Original Buffer insertion start Point (first Byte)
             @TargetB,          ; Original Buffer insertion End Point (after last Byte)
             @TargetEnd,        ; Original Buffer end (Byte after last valid content)
             @TargetMemEnd,     ; Original Buffer Memory limit (after last Byte)
             @SourceA,          ; Substitute Start Point (first Byte)
             @SourceB           ; Substitute End Point (after last Byte)
    Local @NewEnd
    Uses esi, edi, ecx, edx

        mov ecx D@SourceB | sub ecx D@SourceA
        mov edx D@TargetB | sub edx D@TargetA
        move D@NewEnd D@TargetEnd | add D@NewEnd ecx | sub D@NewEnd edx
        .If ecx > edx
          ; If the new Chunk is bigger than the old one:
            sub ecx edx
            mov edi D@TargetEnd | dec edi | mov esi edi | add edi ecx

            If edi >= D@TargetMemEnd
                mov eax &FALSE | ExitP
            End_If

            mov ecx D@TargetEnd | sub ecx D@TargetB | inc ecx | std | rep movsb | cld

        .Else_If ecx < edx
          ; If the new Chunk is smaller than the old one:
            xchg ecx edx | sub ecx edx
            mov edi D@TargetB, esi edi | sub edi ecx

            mov ecx D@TargetEnd | sub ecx D@TargetB | rep movsb
        .End_If

      ; Now, Copy the Chunk:
        mov esi D@SourceA, edi D@TargetA
        mov ecx D@SourceB | sub ecx D@SourceA | jecxz L9>
            mov edx ecx | shr ecx 2 | rep movsd
            mov ecx edx | and ecx 00_11 | jecxz L9>
                rep movsb

L9:     mov eax D@NewEnd, B$eax 0 | mov eax &TRUE
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[NewMen: ?]

[Surprise: U$ 048, 06F, 077, 020, 061, 072, 065, 020, 079, 06F, 075,
              020, 04D, 061, 073, 074, 065, 072, 020, 050, 064, 066,
              03F, 0
 SurpriseNchars: D$ 017]

[TABLES_SECURITY 100]

; Tag Unicode Surprise

Proc ExtendTableMemory:
    Argument @Mem, @Pointer, @End
    Uses ecx, ebx, esi, edi

        If B$Dynamic = &FALSE
            call 'USER32.MessageBoxW' D$hwnd, Surprise, Surprise, &MB_OK
            call CloseProgressBar
            mov esp D$OldStackPointer | ret
        End_If

        mov eax D@Mem, eax D$eax
        push eax
            mov ecx D@Pointer, ecx D$ecx
          ; Get the actual Size, multiply by 2, and add the security:
            sub ecx eax | shl ecx 1
            push ecx
                add ecx TABLES_SECURITY | VirtualAlloc NewMen ecx
              ; Copy:
                mov edi eax
                mov esi D@Mem, esi D$esi
                mov ecx D@End, ecx D$ecx | sub ecx esi | Align_On 01000, ecx
                shr ecx 2 | rep movsd
            pop ecx
          ; Save the new Mem Limit:
            add ecx D$NewMen | mov eax D@End, D$eax ecx
          ; Adjust and Save the new follow-up Pointer:
            mov ebx D@Mem, ebx D$ebx
            mov eax D@Pointer, eax D$eax
            sub eax ebx | add eax D$NewMen
            mov ebx D@Pointer, D$ebx eax
          ; Save the new Mem:
            mov eax D$NewMen | mov ebx D@Mem, D$ebx eax
        pop eax
        VirtualFree eax
Endp
____________________________________________________________________________________________
____________________________________________________________________________________________

; Enough for small Tables:

Proc BubbleSort:
    Arguments @Array, @Size ; In Bytes!
    Uses eax, ebx, ecx, edi

        mov edi D@Array, ecx D@Size | shr ecx 2 | jecxz L9>

L0:     lea ebx D$edi+ecx*4 | mov eax D$edi

L1:     sub ebx 4 | cmp eax D$ebx | jle L2>
            xchg eax D$ebx

L2:         cmp ebx edi | jne L1<

        stosd | loop L0<
L9: EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc zStringsSort:
    Argument @Source, @Destination, @Number

        mov ecx D@Number, edi D@Destination

L0:     push ecx
            mov esi D@Source, ecx D@Number, edx 0, bl 0FF

L1:         lodsb

            .If al = 0FF
                ; nop
            .Else_If al < bl
                mov bl al | lea edx D$esi-1
            .Else_If al = bl
                push ebx
                    push edx, esi
                        While al = bl
                            lodsb | inc edx | mov bl B$edx
                            cmp al 0 | je L2>
                        End_While
L2:                 pop esi, edx
                    On al < bl, lea edx D$esi-1
                pop ebx
            .End_If

            While B$esi <> 0 | inc esi | End_While | inc esi | loop L1<

            If edx > 0
                mov esi edx
                While B$esi <> 0
                    movsb | mov B$esi-1 0FF
                End_While

                mov B$edi 0 | inc edi
            End_If

        pop ecx | dec ecx | cmp ecx 0 | ja L0<<
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

WaitForUserAction:
L0: call 'USER32.PeekMessageA' FirstMSG, D$hwnd, 0, 0FFFF, &PM_REMOVE
    cmp D$FuMsg &WM_LBUTTONUP | je L9>
    cmp D$FuMsg &WM_RBUTTONUP | je L9>
    cmp D$FuMsg &WM_KEYDOWN | jne L0<
L9: ret

____________________________________________________________________________________________
____________________________________________________________________________________________

[RosAsmFilesPath: ? #&MaxPath]

GetRosAsmFilesPath:
    push esi, edi
        mov esi EquatesName, edi RosAsmFilesPath
        While B$esi <> 0 | movsb | End_While
        While B$edi <> '\' | dec edi | End_While
        mov B$edi+1 0
    pop edi, esi
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Trash Buffers:

[TrashPointer: ?]
[TrashString: ? #80]
[Trash: Trash1: ? #10000] [Trash2: ? #10000] [Trash3: ? #10000]

ClearTrashTables:
    push edi, ecx, eax
        mov edi TrashString, ecx 20080, eax 0 | rep stosd
    pop eax, ecx, edi
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

[GetHexaFromTextError: ?]

Proc GetHexaFromText:
    Argument @Buffer
    Uses esi

        mov esi D@Buffer, edx 0, B$GetHexaFromTextError &FALSE

        While B$esi > 0
            lodsb | On al > 'Z', sub al 020
            sub al '0' | On al > 9, sub al 7

            If al > 0F
                mov eax {'The Number should be HexaDecimal', 0}
                call MessageBox
                mov B$GetHexaFromTextError &TRUE | ExitP
            End_If
            shl edx 4 | or dl al
        End_While

        mov eax edx
EndP


[zCopy | mov esi #1 | While B$esi <> 0 | movsb | End_While | #+1]

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc ClearBuffer: ; (Guga: Instead of ClearCharMapData)
    Arguments @Buffer, @Size
    Uses edi, ecx

        mov edi D@Buffer, ecx D@Size, eax 0

        rep stosb
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

[RGB | (#1 or (#2 shl 8) or (#3 shl 16))]

____________________________________________________________________________________________
____________________________________________________________________________________________

; Computes the Length of a zero-ended Ascii String. Regs under caller responsability:

StrLen: ; edi -> String // StrLenProc
    mov ecx 0-1, al 0
    repne scasb
    mov eax 0-2 | sub eax ecx      ; Lenght in eax.
ret
____________________________________________________________________________________________________________

; Same with regs under Proc responsability:

Proc StrLenProc:
    Arguments @Pointer
    Uses edi, ecx

        mov edi D@Pointer, ecx 0-1, al 0
        repne scasb
        mov eax 0-2 | sub eax ecx      ; Lenght in eax
EndP








TITLE TimeDateStampConvert
______________________________________________________________________________________
______________________________________________________________________________________


; Functions related to Time convertion:
; TimeDateStampToString , CurrentTimeDateStampToString , TimeDateStringtoDword, GetDayofWeekinCurrentMonth
; GetMonthStringandValue, CurrentDateStampToString, CurrentTimeStampToString, SBMBinSearch



;;

        __________________________________________________________________________________________________

                                        Time Date Stamp to String function.
                                                by Beyond2000! (Guga)
        __________________________________________________________________________________________________

TimeDateStampToString



    The TimeDateStampToString function was builded to help the user to convert a time date stamp (found inside the IMAGE_NT_HEADERS
structure) into a readable string.

    Nowadays, there are five time formats, as described in the table below:
    
    
    
    Format      Type Definition         Description
    _______________________________________________________________________________________________________________
    
    System      SYSTEMTIME              Year, month, day, hour, second, millisecond,
                                        achieved internally from the hardware clock.
                                        
    File        FILETIME                100-nanosecond intervals since January 1, 1601.
    
    Local       SYSTEMTIME or FILETIME  A system time or file time converted to the system's local time zone. 
    
    MS-DOS      WORD                    A packed word for the date, another for the time.
    
    Windows     DWORD                   The number of milliseconds since the system booted; a quantity that cycles
                                        every 49.7 days.


    Our function basically compares 02 diferents time data. The diference resultant is our data time.
For start we have to calculate the time stamp of IMAGE_NT_HEADERS structure.

    The member that we use is TimeDateStamp, that represents the date and time the file header was created by the linker.
The value is represented in the number of seconds elapsed since midnight (00:00:00), January 1, 1970,
Universal Coordinated Time (UTC), according to the system clock.


    Next, for calculating the time that the file was created, we must use the FILETIME structure. A file time is a
64-bit value (Qword) that represents the number of 100 nanosecond intervals that have elapsed since
12:00 A.M. January 1, 1601 (UTC). The system records file times whenever applications create, access, and write to files.
   
   So, for files, there should not be any with a date before 1st of january, 1601. This is our comparison time start.
Since, the TimeDateStamp member calculates values after 1970, we need to calculate the data between 1601 and 1970,
which is nothing more, nothing less then the amount of seconds between them.

    When we deal with those periods of time, we are naming them as Epochs. Both epochs are Gregorian.
TimeDateStamp Member (And also Unix files) is 1970 and win32 is 1601 so 370 is the number of years (1970-1601 = 369)

    Assuming a leap year every four years gives 92 leap years (369 / 4 = 92).
However, 1700, 1800, and 1900 were NOT leap years, which leaves us with 89 leap years and 280 non-leap years.

    To Calculate the number of days:

    (Leap Years)*(Number of days on 01 Leap year) + (Non Leap Years)*(Number of days on 01 Non Leap year)
    
    89 * 366 + 280 * 365 = 134744 days between epochs.
    
    To Calculate the number of seconds:
    
    01 Day = 24 Hours * 60 minutes * 60 seconds = 86400 seconds per day,
    

    The amount of seconds between the epochs are calculated by multiplying both results.
    So, 134744 * 86400 = 11644473600 seconds between epochs.
    
    
    This result is also confirmed in the MSDN documentation on how to convert a time_t value to a win32 FILETIME. Example
found there is:

        Microsoft:
        
            void TimetToFileTime( time_t t, LPFILETIME pft )
            {
                LONGLONG ll = Int32x32To64(t, 10000000) + 116444736000000000;
                pft->dwLowDateTime = (DWORD) ll;
                pft->dwHighDateTime = ll >>32;
            }

        Unix:
        
            static void TimetToFileTime( time_t t, LPFILETIME pft )
            {
                UINT64 u = ((UINT64)t + &EPOCH_DIFF_SECS) * &SECS_TO_100NS;
                pft->dwLowDateTime = (DWORD)u;
                pft->dwHighDateTime = (DWORD)(u>>32);
            }



    Ok, now that we calculated the amount of seconds between the Epochs, we need to calculate the amount of 100 nanoseconds
intervals to be used with the FILETIME structure. To do that we just perform this calculation:

    01 sec = 1000000000 nanoseconds

    The interval is from each 100 nanoseconds...So:
    
    Interval = 1000000000 / 100 = 10000000


    To calculate the amount of intervals of 100 nanoseconds between 1601 and 1970 we just multiply the results:
    
    11644473600 * 10000000 = 116444736000000000 intervals (019DB1DED53E8000 in hexadecimal value)


    All of this is necessary because our function will just perform a check for the time stamp strings, after calculating
the amount of time based on a fixed value. This value is exactely the amount of 100 nanoseconds intervals between 1601 and 1970.
So, the time stamp will begin with any value after that period of time.

    We get the actual time stamp found in the IMAGE_FILE_HEADER structure, and then multily the value with 10000000 to 
know exactly the amount of 100 nanoseconds intervals existant. Then we add to the result the amount of the intervals between
1601 and 1970.

    This express better the situation:
    
    
    Initial Basic Time Period               End of Basic Time Period (IMAGE_NT_HEADERS)                      PE FILE

   12:00:00 AM January 1, 1601                      (00:00:00), January 1, 1970                               XXXXX
   
            |<________________________________________________>|<______________________________________________>|
            
                                     |                                                     |
                 Fixed Basic Time interval of 100 nanoseconds       Time interval of 100 nanoseconds after 01/01/1970
                          (116444736000000000)                 +                 (XXXXXXXXXXXXXXXXXXXXXXX)
                          
                          
            <------------------------|-----------------------------------------------------|-------------------->
                                        The resultant value is the sum of the 02 intervals
   

    The final data will then be passed onto the FILEIME structure and used values on SYSTEMTIME structure to we get the value
of month, day, year, hours etc...related to that structure.    


    Constants related to this function and other eventually used to find or convert the time stamp are:

&MAX_UTC_TIME_LEN    =   80 ; Maximum bytes to be displayed on the string to be shownd

&SECS_PER_MIN        =   60  ; Amount of total seconds in 01 Minute

&SECS_PER_HOUR       =   (60*SECS_PER_MIN)   = 3600 ; Amount of total seconds in 01 Hour

&SECS_PER_DAY        =   (24*SECS_PER_HOUR)  = 86400 ; Amount of total seconds in 01 Day

&SECS_PER_YEAR       =   (365*SECS_PER_DAY)  = 31536000 ; Amount of total seconds in 01 Year

&EPOCH_DIFF_DAYS     =   134744  ; Amount of days between epochs (1601/1970).

&EPOCH_DIFF_SECS     =   (EPOCH_DIFF_DAYS*SECS_PER_DAY)  =  11644473600 ; Amount of seconds between epochs (1601/1970).
                                    This data is represented as Qword.
                                    
&SECS_TO_100NS       =   10000000 ; Amount of 100 nanoseconds intervals per second (10^7)

&EPOCH_DIFF_SECS_INTERVAL    =   (EPOCH_DIFF_SECS*SECS_TO_100NS) = 116444736000000000 = 019DB1DED53E8000 (In hexadecimal) ;
                                Amount of 100 nanoseconds intervals between epochs (1601/1970), represented as Qword.

&EPOCH_DIFF_SECS_INTERVAL_LOW    =   0D53E8000 (In hexadecimal);  Low-order Part of EPOCH_DIFF_SECS_INTERVAL.

&EPOCH_DIFF_SECS_INTERVAL_HIGH   =   019DB1DE  (In hexadecimal);  High-order Part of EPOCH_DIFF_SECS_INTERVAL.

&EPOCH_DIFF_SECS_INTERVAL ; &EPOCH_DIFF_SECS ; &MAX_TIME_VALUE (Also a qword), but is not being shownd completelly on
Win Equate Value and on Bases Forms....
And on compilation, only the low order part is being compiled, and not the full value
                

Syntax:

TimeDateStampToString ; (Function name)

    TimeStamp, DateFmt, TimeFmt, DateOut, TimeOut ; (Parameters names)
        


Parameters:


    TimeStamp:  Pointer to the Data Value of the time stamp found in the Target File. If you loaded the file and achieved
              the value of the TimeDateStamp on the IMAGE_NT_HEADERS, this parameters is a pointer to the value. For example:
              D$TimeData, where TimeData = 03836401D (1999/11/20 sab 06:30:53 UTC).
              Also, if you don't want to use this parameter as a pointer, you can directly use the value of the timedate stamp,
              assuming you know what it is. This parameter is used as Input.
              
    
    
    DateFmt:  Pointer to a string used to form the date string. The string must be zero terminated. This parameter can't
              be NULL.
              
              Use the following letters to build the formated string.
              
              If you use spaces to separate the letters in the formated string, these spaces will appear in the same
              location in the output string.
              
              The letters must be in uppercase or lowercase as shown in the table (for example, "MM" not "mm").
              
              Characters in the format string that are enclosed in single quotation marks will appear in the same
              location and unchanged in the output string.

                            Letters     Description
                            
                            d           Day of month as digits with no leading zero for single-digit days.
                            
                            dd          Day of month as digits with leading zero for single-digit days.
                            
                            ddd         Day of week as a three-letter abbreviation. The function uses the
                                        LOCALE_SABBREVDAYNAME value associated with the specified locale.
                                        
                            dddd        Day of week as its full name. The function uses the LOCALE_SDAYNAME value
                                        associated with the specified locale.
                                        
                            M           Month as digits with no leading zero for single-digit months.
                            
                            MM          Month as digits with leading zero for single-digit months.
                            
                            MMM         Month as a three-letter abbreviation. The function uses the LOCALE_SABBREVMONTHNAME
                                        value associated with the specified locale.
                            
                            MMMM        Month as its full name. The function uses the LOCALE_SMONTHNAME value associated
                                        with the specified locale.
                            
                            y           Year as last two digits, but with no leading zero for years less than 10.
                            
                            yy          Year as last two digits, but with leading zero for years less than 10.
                            
                            yyyy        Year represented by full four digits.
                            
                            gg          Period/era string. The function uses the CAL_SERASTRING value associated with the
                                        specified locale. This element is ignored if the date to be formatted does not have
                                        an associated era or period string.
                                        

              For example, to get the date string
                
                "Sun, Jun 06 04"
              
              use the following picture string:
                
                "ddd',' MMM dd yy"

              
              This parameter is used as input.

    
    TimeFmt:  Pointer to a string used to form the time string. The string must be zero terminated. This parameter can't
              be NULL.

              Use the following letters to build the formated string.
              
              If you use spaces to separate the letters in the formated string, these spaces will appear in the same
              location in the output string.
              
              The letters must be in uppercase or lowercase as shown in the table (for example, "ss" not "SS").
              
              Characters in the format string that are enclosed in single quotation marks will appear in the same
              location and unchanged in the output string.

                            Letters     Description
    
                            h           Hours with no leading zero for single-digit hours; 12-hour clock.
                            
                            hh          Hours with leading zero for single-digit hours; 12-hour clock.
                            
                            H           Hours with no leading zero for single-digit hours; 24-hour clock.
                            
                            HH          Hours with leading zero for single-digit hours; 24-hour clock.
                            
                            m           Minutes with no leading zero for single-digit minutes.
                            
                            mm          Minutes with leading zero for single-digit minutes.
                            
                            s           Seconds with no leading zero for single-digit seconds.
                            
                            ss          Seconds with leading zero for single-digit seconds.
                            
                            t           One character time-marker string, such as A or P.
                            
                            tt          Multicharacter time-marker string, such as AM or PM.

              
              For example, to get the time string 

                "11:29:40 PM"

              use the following picture string: 

                "hh':'mm':'ss tt"


              This parameter is used as input.
    
    
    DateOut:    Pointer to a buffer that receives the formatted date string, and output the result in the format specified
              in DateFmt. The buffer can be limited to the lenght of the formated string.
    
    
    TimeOut:    Pointer to a buffer that receives the formatted time string, and output the result in the format specified
              in TimeFmt. The buffer can be limited to the lenght of the formated string.

        


Usage Examples:


a)

[DataPointer: D$ ?] ; Points to the data that stored the value of the timedate stamp.
[szDateString: B$ ? #64] ; Lenght of the date string. (Maximum is &MAX_UTC_TIME_LEN)
[szTimeString: B$ ? #64] ; Lenght of the time string. (Maximum is &MAX_UTC_TIME_LEN)


        call TimeDateStampToString D$DataPointer {"yyyy/MM/dd ddd ", 0},
                                                 {"HH:mm:ss UTC", 0},
                                                  szDateString szTimeString

b)

[DataPointer: D$ ?] ; Points to the data that stored the value of the timedate stamp.

[Sz_Year: B$ "yyyy/MM/dd ddd ",0]
[Sz_Hour: B$ "HH:mm:ss UTC",0]

[szDateString: B$ ? #64] ; Lenght of the date string. (Maximum is &MAX_UTC_TIME_LEN)
[szTimeString: B$ ? #64] ; Lenght of the time string. (Maximum is &MAX_UTC_TIME_LEN)


        call TimeDateStampToString D$DataPointer Sz_Year Sz_Hour szDateString szTimeString

c)


[DataPointer: D$ ?] ; Points to the data that stored the value of the timedate stamp.

[Sz_Year: B$ "yyyy/MM/dd ddd ",0
 Year_Len: D$ len]
[Sz_Hour: B$ "HH:mm:ss UTC",0
 Hour_Len: D$ len]


        call TimeDateStampToString D$DataPointer Sz_Year Sz_Hour Year_Len Hour_Len
        

Notes:

I - Concerning the Equates

    The Equates used on this function are mostly Dwords. So, you can use them like:
    
        push &MAX_UTC_TIME_LEN
        
        or
        
        mov eax &MAX_UTC_TIME_LEN
        
        or
        
        call XXXX &MAX_UTC_TIME_LEN YYYYY
        
        
        etc etc
        
        
      But, there are exceptions. Two of the equates are Qwords. So, to fully get their high and low parts, you must
    use them as the following example:
    
    

    [EPOCH_DIFF_SECS_INTERVAL 019DB1DED53E8000]
                                    
    [Data01: Q$ EPOCH_DIFF_SECS_INTERVAL]
        
        push Q$Data01
        
        or
        
        mov eax Q$Data01
        
        etc etc
        
        
    These exceptions are inside the equates.equ, but to use them fully you must define them as an constant, and not
  use them as an regular Equate. So, you don't need to use the "&" char. At least untill the tme this function was written (06/06/04).
  Since RosAsm is under constant development, in the future, you may be able to use the Qworded equates fully.
      
        
    List of Equates and their data types
    
    Equates                         Data Type
    
    &MAX_UTC_TIME_LEN               Dword
    
    &SECS_PER_MIN                   Dword

    &SECS_PER_HOUR                  Dword

    &SECS_PER_DAY                   Dword

    &SECS_PER_YEAR                  Dword

    &EPOCH_DIFF_DAYS                Dword

    &EPOCH_DIFF_SECS_INTERVAL_LOW   Dword

    &EPOCH_DIFF_SECS_INTERVAL_HIGH  Dword

    &SECS_TO_100NS                  Dword

    &EPOCH_DIFF_SECS_INTERVAL       Qword

    &EPOCH_DIFF_SECS                Qword


    
    
      
        mov eax D$edi+FileHeader.TimeDateStampDis
        mov edx 10000000
        mul edx

                   
        add eax 0D53E8000 ; 019DB1DE D53E8000
        adc edx 019DB1DE ; 019DB1DE

 
        mov D$St_DateTimeStamp.dwLowDateTime eax
        mov D$St_DateTimeStamp.dwHighDateTime edx
        
        call 'kernel32.FileTimeToSystemTime' St_DateTimeStamp St_UTC;stLocal

        call 'KERNEL32.GetDateFormatA' &LOCALE_SYSTEM_DEFAULT &NULL St_UTC Sz_Year2 szDateString 64
        call 'KERNEL32.GetTimeFormatA' &LOCALE_SYSTEM_DEFAULT &NULL St_UTC Sz_Hour2 szTimeString 64


II - Structures used

    This function uses two fixed structures. FILETIME and SYSTEMTIME.
    
    The FILETIME structure is used to store the data found by TimeStamp. When the time date is found he add the result in
higher and lower part to  &EPOCH_DIFF_SECS_INTERVAL_LOW &EPOCH_DIFF_SECS_INTERVAL_HIGH equates.
                   
    The result is a new data time stamp stored at FILETIME structure.
    
    
    Then, the result will be passed to the SYSTEMTIME structure in order to convert the data to minutes, days, hours etc. It
will be converted through the FileTimeToSystemTime function.

    To achieve the results for date and time, all you need is use the new data in the SYSTEMTIME structure and pass it through
GetDateFormat and GetTimeFormat functions.


    This function is limited, since we use fixed values for the parameters of the GetDateFormat and GetTimeFormat functions, but
you can also define another parameter in the TimeDateStampToString that can be a pointer to a structure that can handle those values.
This structure, can contain data to be stored to be used in the timing functinos, to the user define wheter he will use a &LOCALE_SYSTEM_DEFAULT,
or a &MAX_UTC_TIME_LEN etc etc....You can define in this structure a mix of the parameters used in the GetDateFormat and GetTimeFormat functions.

    On that way you can get more control on the functinos. This structure can be used either as local or a regular one.
    

Bibliographic Reference:

    http://dotnet.di.unipi.it/Content/sscli/docs/doxygen/pal/filetime_8c-source.html
    http://xml-x.org/time.html#time
    http://bg.php.net/manual/de/function.date.php
    http://de3.php.net/manual/it/function.mktime.php
    http://www.tex.ac.uk/CTAN/systems/texlive/Source/source-win32-4.diff
    http://lists.helixcommunity.org/pipermail/common-cvs/2003-February/000516.html    
    http://msdn.microsoft.com/library/default.asp?url=/library/en-us/sysinfo/base/converting_a_time_t_value_to_a_file_time.asp

;;




; FILETIME structure
[St_DateTimeStamp:
 St_DateTimeStamp.dwLowDateTime: D$ 0
 St_DateTimeStamp.dwHighDateTime: D$ 0]


; SYSTEMTIME structure

[St_UTC:
 St_UTC.wYear: W$ 0
 St_UTC.wMonth: W$ 0
 St_UTC.wDayOfWeek: W$ 0
 St_UTC.wDay: W$ 0
 St_UTC.wHour: W$ 0
 St_UTC.wMinute: W$ 0
 St_UTC.wSecond: W$ 0
 St_UTC.wMilliseconds: W$ 0]

Proc TimeDateStampToString:
    Arguments @TimeStamp, @DateFmt, @TimeFmt, @DateOut, @TimeOut

        mov eax D@TimeStamp
        mov edx &SECS_TO_100NS
        mul edx

        add eax &EPOCH_DIFF_SECS_INTERVAL_LOW
        adc edx &EPOCH_DIFF_SECS_INTERVAL_HIGH

        mov D$St_DateTimeStamp.dwLowDateTime eax
        mov D$St_DateTimeStamp.dwHighDateTime edx

        call 'kernel32.FileTimeToSystemTime' St_DateTimeStamp, St_UTC

        call 'KERNEL32.GetDateFormatA' &LOCALE_SYSTEM_DEFAULT,
                                       &NULL,
                                       St_UTC,
                                       D@DateFmt,
                                       D@DateOut,
                                       &MAX_UTC_TIME_LEN

        call 'KERNEL32.GetTimeFormatA' &LOCALE_SYSTEM_DEFAULT,
                                       &NULL,
                                       St_UTC,
                                       D@TimeFmt,
                                       D@TimeOut,
                                       &MAX_UTC_TIME_LEN
EndP




_____________________________________________________________________________________________________________________

;;

        __________________________________________________________________________________________________

                                        Current Time and Date Stamp to String function.
                                                by Beyond2000! (Guga)
        __________________________________________________________________________________________________

CurrentTimeDateStampToString


    The CurrentTimeDateStampToString function was builded to help the user to convert the current time date stamp
    of his system into a readable string.


Parameters:

 @DateFmt, @TimeFmt, @DateOut, @TimeOut, @SysTimeStr, @FileTimeStr
    
    DateFmt:  Pointer to a string used to form the date string. The string must be zero terminated. This parameter can't
              be NULL.
              
              Use the following letters to build the formated string.
              
              If you use spaces to separate the letters in the formated string, these spaces will appear in the same
              location in the output string.
              
              The letters must be in uppercase or lowercase as shown in the table (for example, "MM" not "mm").
              
              Characters in the format string that are enclosed in single quotation marks will appear in the same
              location and unchanged in the output string.

                            Letters     Description
                            
                            d           Day of month as digits with no leading zero for single-digit days.
                            
                            dd          Day of month as digits with leading zero for single-digit days.
                            
                            ddd         Day of week as a three-letter abbreviation. The function uses the
                                        LOCALE_SABBREVDAYNAME value associated with the specified locale.
                                        
                            dddd        Day of week as its full name. The function uses the LOCALE_SDAYNAME value
                                        associated with the specified locale.
                                        
                            M           Month as digits with no leading zero for single-digit months.
                            
                            MM          Month as digits with leading zero for single-digit months.
                            
                            MMM         Month as a three-letter abbreviation. The function uses the LOCALE_SABBREVMONTHNAME
                                        value associated with the specified locale.
                            
                            MMMM        Month as its full name. The function uses the LOCALE_SMONTHNAME value associated
                                        with the specified locale.
                            
                            y           Year as last two digits, but with no leading zero for years less than 10.
                            
                            yy          Year as last two digits, but with leading zero for years less than 10.
                            
                            yyyy        Year represented by full four digits.
                            
                            gg          Period/era string. The function uses the CAL_SERASTRING value associated with the
                                        specified locale. This element is ignored if the date to be formatted does not have
                                        an associated era or period string.
                                        

              For example, to get the date string
                
                "Sun, Jun 06 04"
              
              use the following picture string:
                
                "ddd',' MMM dd yy"

              
              This parameter is used as input.

    
    TimeFmt:  Pointer to a string used to form the time string. The string must be zero terminated. This parameter can't
              be NULL.

              Use the following letters to build the formated string.
              
              If you use spaces to separate the letters in the formated string, these spaces will appear in the same
              location in the output string.
              
              The letters must be in uppercase or lowercase as shown in the table (for example, "ss" not "SS").
              
              Characters in the format string that are enclosed in single quotation marks will appear in the same
              location and unchanged in the output string.

                            Letters     Description
    
                            h           Hours with no leading zero for single-digit hours; 12-hour clock.
                            
                            hh          Hours with leading zero for single-digit hours; 12-hour clock.
                            
                            H           Hours with no leading zero for single-digit hours; 24-hour clock.
                            
                            HH          Hours with leading zero for single-digit hours; 24-hour clock.
                            
                            m           Minutes with no leading zero for single-digit minutes.
                            
                            mm          Minutes with leading zero for single-digit minutes.
                            
                            s           Seconds with no leading zero for single-digit seconds.
                            
                            ss          Seconds with leading zero for single-digit seconds.
                            
                            t           One character time-marker string, such as A or P.
                            
                            tt          Multicharacter time-marker string, such as AM or PM.

              
              For example, to get the time string 

                "11:29:40 PM"

              use the following picture string: 

                "hh':'mm':'ss tt"


              This parameter is used as input.
    
    
    DateOut:  Pointer to a buffer that receives the formatted date string, and output the result in the format specified
              in DateFmt. The buffer can be limited to the lenght of the formated string.
    
    
    TimeOut:  Pointer to a buffer that receives the formatted time string, and output the result in the format specified
              in TimeFmt. The buffer can be limited to the lenght of the formated string.


    SysTimeStr: Pointer to a SYSTEMTIME structure buffer where it will output the result data of it's members (Day, Day of Week,
                time, hour, seconds, etc).
                If the value of this parameter is &NULL, it won´ output the data.


    FileTimeStr:    Pointer to a FILETIME structure buffer where it will output the result data of it's members (Low and High Values ot the timedate stamp).
                If the value of this parameter is &NULL, it won´ output the data.


Usage Examples:


a)

[szDateString: B$ ? #64] ; Lenght of the date string. (Maximum is &MAX_UTC_TIME_LEN)
[szTimeString: B$ ? #64] ; Lenght of the time string. (Maximum is &MAX_UTC_TIME_LEN)


        call CurrentTimeDateStampToString {"yyyy/MM/dd ddd ", 0}, {"HH:mm:ss UTC", 0}, szDateString, szTimeString, &NULL, &NULL

b)

[Sz_Year: B$ "yyyy/MM/dd ddd ",0]
[Sz_Hour: B$ "HH:mm:ss UTC",0]

[szDateString: B$ ? #64] ; Lenght of the date string. (Maximum is &MAX_UTC_TIME_LEN)
[szTimeString: B$ ? #64] ; Lenght of the time string. (Maximum is &MAX_UTC_TIME_LEN)


        call CurrentTimeDateStampToString Sz_Year, Sz_Hour, szDateString, szTimeString, &NULL, &NULL

c)

; system_time SYSTEMTIME Structure
[system_time:
 system_time.wYear: W$ 0
 system_time.wMonth: W$ 0
 system_time.wDayOfWeek: W$ 0
 system_time.wDay: W$ 0
 system_time.wHour: W$ 0
 system_time.wMinute: W$ 0
 system_time.wSecond: W$ 0
 system_time.wMilliseconds: W$ 0]

; FILETIME structure
[St_DateTimeStamp:
 St_DateTimeStamp.dwLowDateTime: D$ 0
 St_DateTimeStamp.dwHighDateTime: D$ 0]


[Sz_Year: B$ "yyyy/MM/dd ddd ",0
 Year_Len: D$ len]
[Sz_Hour: B$ "HH:mm:ss UTC",0
 Hour_Len: D$ len]


        call CurrentTimeDateStampToString Sz_Year, Sz_Hour, Year_Len, Hour_Len, system_time, St_DateTimeStamp
        
;;

Proc CurrentTimeDateStampToString:
    Arguments @DateFmt, @TimeFmt, @DateOut, @TimeOut, @SysTimeStr, @FileTimeStr
    Structure @St_UTC 16, @St_UTC.wYearDis 0,  @St_UTC.wMonthDis 2,  @St_UTC.wDayOfWeekDis 4,  @St_UTC.wDayDis 6,  @St_UTC.wHourDis 8,  @St_UTC.wMinuteDis 10,  @St_UTC.wSecondDis 12,  @St_UTC.wMillisecondsDis 14
    Local @St_DateTimeStamp.dwLowDateTime, @St_DateTimeStamp.dwHighDateTime

    call 'KERNEL32.GetLocalTime' D@St_UTC
    If D@SysTimeStr <> 0
        mov edi D@SysTimeStr
        mov esi D@St_UTC
        mov ecx 0
        While ecx <> Size_Of_SYSTEMTIME
            movsb
            inc ecx
        End_While
    End_If
    lea eax D@St_DateTimeStamp.dwLowDateTime
    call 'KERNEL32.SystemTimeToFileTime' D@St_UTC, D$eax

    lea eax D@St_DateTimeStamp.dwLowDateTime
    call 'kernel32.FileTimeToSystemTime' D$eax, D@St_UTC
    If D@FileTimeStr <> 0
        mov edi D@FileTimeStr
        mov esi D@St_DateTimeStamp.dwLowDateTime
        mov ecx 0
        While ecx <> Size_Of_FILETIME
            movsb
            inc ecx
        End_While
    End_If
    call 'KERNEL32.GetDateFormatA' &LOCALE_SYSTEM_DEFAULT &NULL D@St_UTC D@DateFmt D@DateOut &MAX_UTC_TIME_LEN
    call 'KERNEL32.GetTimeFormatA' &LOCALE_SYSTEM_DEFAULT &NULL D@St_UTC D@TimeFmt D@TimeOut &MAX_UTC_TIME_LEN

EndP

_____________________________________________________________________________________________________________________



;;

        __________________________________________________________________________________________________

                                   Time and Date String to TimeDate Stamp (Dword) function. v 1.0
                                                by Beyond2000! (Guga)
        __________________________________________________________________________________________________

TimeDateStringtoDword


    The TimeDateStringtoDword function converts a Time and Date Strings to the dword value of the TimeDateStamp.
    It is the reverse of the function TimeDateStampToString.
    
    When this function was built (20/03/2006), we did not inserted any error checkings. So, you must obey the
    formats for the strings to be parsed to avoid errors.


Parameters:
 @TimeStamp, @DateFmt, @TimeFmt, @DateString, @TimeString
     
    TimeStamp: Pointer to a Buffer that will hold the outputed value of the converted timestamp.
    
    DateFmt:  Pointer to a string used to form the date string. The string must be zero terminated. This parameter can't
              be NULL.
              
              Use the following letters to build the formated string.
              
              If you use spaces to separate the letters in the formated string, these spaces will appear in the same
              location in the output string.
              
              The letters must be in uppercase or lowercase as shown in the table (for example, "MM" not "mm").
              
              Characters in the format string that are enclosed in single quotation marks will appear in the same
              location and unchanged in the output string.

                            Letters     Description
                            
                            d           Day of month as digits with no leading zero for single-digit days.
                            
                            dd          Day of month as digits with leading zero for single-digit days.
                            
                            ddd         Day of week as a three-letter abbreviation. The function uses the
                                        LOCALE_SABBREVDAYNAME value associated with the specified locale.
                                        
                            dddd        Day of week as its full name. The function uses the LOCALE_SDAYNAME value
                                        associated with the specified locale.
                                        
                            M           Month as digits with no leading zero for single-digit months.
                            
                            MM          Month as digits with leading zero for single-digit months.
                            
                            MMM         Month as a three-letter abbreviation. The function uses the LOCALE_SABBREVMONTHNAME
                                        value associated with the specified locale.
                            
                            MMMM        Month as its full name. The function uses the LOCALE_SMONTHNAME value associated
                                        with the specified locale.
                            
                            y           Year as last two digits, but with no leading zero for years less than 10.
                            
                            yy          Year as last two digits, but with leading zero for years less than 10.
                            
                            yyyy        Year represented by full four digits.
                            
                            gg          Period/era string. The function uses the CAL_SERASTRING value associated with the
                                        specified locale. This element is ignored if the date to be formatted does not have
                                        an associated era or period string.
                                        

              For example, to get the date string
                
                "Sun, Jun 06 04"
              
              use the following picture string:
                
                "ddd',' MMM dd yy"

              
              This parameter is used as input.

    
    TimeFmt:  Pointer to a string used to form the time string. The string must be zero terminated. This parameter can't
              be NULL.

              Use the following letters to build the formated string.
              
              If you use spaces to separate the letters in the formated string, these spaces will appear in the same
              location in the output string.
              
              The letters must be in uppercase or lowercase as shown in the table (for example, "ss" not "SS").
              
              Characters in the format string that are enclosed in single quotation marks will appear in the same
              location and unchanged in the output string.

                            Letters     Description
    
                            h           Hours with no leading zero for single-digit hours; 12-hour clock.
                            
                            hh          Hours with leading zero for single-digit hours; 12-hour clock.
                            
                            H           Hours with no leading zero for single-digit hours; 24-hour clock.
                            
                            HH          Hours with leading zero for single-digit hours; 24-hour clock.
                            
                            m           Minutes with no leading zero for single-digit minutes.
                            
                            mm          Minutes with leading zero for single-digit minutes.
                            
                            s           Seconds with no leading zero for single-digit seconds.
                            
                            ss          Seconds with leading zero for single-digit seconds.
                            
                            t           One character time-marker string, such as A or P.
                            
                            tt          Multicharacter time-marker string, such as AM or PM.

              
              For example, to get the time string 

                "11:29:40 PM"

              use the following picture string: 

                "hh':'mm':'ss tt"


              This parameter is used as input.
    

    DateString: Pointer to a buffer containing the Date string to be parsed. The string must fits exactly with the DateFmt.
                It means that you must use the same locations for day, month, year, day of the week, respecting the chars
                used as a separator on the DateFmt.
                
                For example, if the DateFmt is "yyyy/MM/dd ddd ", the separatos are the "/" and the " " char. So the 
                string to be parsed must use them as well, like "2006/10/02 wed ". Below are some examples of good and bad strings
                
                a) Good Strings
                    "yyyy/MM/dd ddd " 
                    "2006/10/02 wed "
                b) Good Strings
                    "dddd MMMM yy" 
                    "tuesday december 02"

                c) Bad Strings
                    "dddd \ MMMM yy"
                    "tuesday december 02"
                    The correct one should be:
                    "tuesday \ december 02"

                d) Bad Strings
                    "yyyy/MM/dd ddd "
                    "2006/10/02 wed"
                    The correct one should be:
                    "2006/10/02 wed " ; with the last space at the end.

    
    TimeString: Pointer to a buffer containing the Time string to be parsed. The string must fits exactly with the TimeFmt.
                It means that you must use the same locations for hour, minutes, seconds, respecting the chars
                used as a separator on the TimeFmt.
                
                For example, if the TimeFmt is "hh:mm:ss tt", the separators are the ":" and the " " char. So the 
                string to be parsed must use them as well, like "11:29:40 PM". Below are some examples of good and bad strings
                
                a) Good Strings
                    "hh:mm:ss tt" 
                    "11:29:40 PM"
                b) Good Strings
                    "HH:mm:ss UTC" 
                    "01:54:10 UTC"

                c) Bad Strings
                    "hh:mm:ss tt" 
                    "18:29:40 PM"
                    hh time mark is from 1 to 12. So, The correct one should be:
                    "06:29:40 PM"

                d) Bad Strings
                    "hh:mm:ss tt "
                    "18:29:40 PM"
                    The correct one should be:
                    "18:29:40 PM " ; with the last space at the end.
    
    

Usage Examples:


a)

[szDateString: B$ "2005/08/11 thu ", 0]
[szTimeString: B$ "01:54:10 UTC", 0]
[TimeStamp: D$ 0]

        call TimeDateStringtoDword TimeStamp, {"yyyy/MM/dd ddd ", 0}, {"HH:mm:ss UTC", 0}, szDateString, szTimeString
        
        The output will be:
        [TimeStamp: D$ 042FAAFC2]

;;


[TimeBuffer: B$ 0 #80]
[TimeMap: B$ 0 #80]
[NewDateBuffer: B$ 0 #80]
[FullWeekFmt: B$ 0 #5]

Proc TimeDateStringtoDword:
    Arguments @TimeStamp, @DateFmt, @TimeFmt, @DateString, @TimeString
    Local @TimeMark, @TmpHour, @TmpMinute, @TmpSecond, @TmpYear, @TmpDayofWeek, @UseFullWeek_Month, @TmpMonth, @TmpDay, @FoundSourceLen
    Uses ebx, ecx, edx, esi, edi
; _________________________________________________________________
;   1St Step. Get the Time Stamp
; _________________________________________________________________

    mov edi TimeBuffer
    mov eax D@TimeFmt
    mov esi D@TimeString

    ; Initialize all Local variables.
    mov D@TimeMark 0
    mov D@TmpHour 0
    mov D@TmpMinute 0
    mov D@TmpSecond 0
    mov D@TmpYear 0
    mov D@TmpDayofWeek 0
    mov D@UseFullWeek_Month 0
    mov D@TmpMonth 0
    mov D@TmpDay 0
    mov D@FoundSourceLen 0

    ; 1St Locate the Hour chars. It can be "HH", "H", "hh", "h"

    mov edi TimeBuffer
    mov esi D@TimeFmt
    mov ecx 0

    .While B$esi <> 0

        ..If B$esi = 'H'
            .If B$esi+1 = 'H' ; Is it of the Format 'HH' ?
                mov esi D@TimeString
                add esi ecx
                movsw       ; copy the Decimal String (Hour) to the buffer
                mov B$edi 0 ; ensure it ends with 0
                sub edi 2   ; decrease it by 2 to ensure it will point to the start of the string.
            .Else
                ; Found only the 'H' time format. Check the byte immediate after it to get the end of the string
                ; ecx = starting point of the address
                movzx edx B$esi+1 ; edx is the ending char we need to find.

                mov esi D@TimeString
                add esi ecx ; esi is now the starting address
                push esi
                    mov eax 0 ; Our byte counter
                    While B$esi <> dl ; is it equal to the lower part of edx ? (The lower part is where it is stored our char)
                        inc eax
                        inc esi
                    End_While
                pop esi

                If eax = 1
                    movsb
                    mov B$edi 0 ; ensure it ends with 0
                Else
                    movsw
                    mov B$edi 0 ; ensure it ends with 0
                End_If
                sub edi eax
            .End_If

            call String2Dword edi ; convert the Decimal String to Dword
            ; At eax we have the dword value of the Hour. Now we need to put it on the St_UTC structure
            mov D@TmpHour eax
            mov D@TimeMark 0 ; No Time Marks (AM/PM, A/P)
            jmp @HourFound


        ..Else_If B$esi = 'h'
            .If B$esi+1 = 'h' ; Is it of the Format 'hh' ?
                mov esi D@TimeString
                add esi ecx
                movsw       ; copy the Decimal String (Hour) to the buffer
                mov B$edi 0 ; ensure it ends with 0
                sub edi 2   ; decrease it by 2 to ensure it will point to the start of the string.
            .Else
                ; Found only the 'h' time format. Check the byte immediate after it to get the end of the string
                ; ecx = starting point of the address
                movzx edx B$esi+1 ; edx is the ending char we need to find.

                mov esi D@TimeString
                add esi ecx ; esi is now the starting address
                push esi
                    mov eax 0 ; Our byte counter
                    While B$esi <> dl ; is it equal to the lower part of edx ? (The lower part is where it is stored our char)
                        inc eax
                        inc esi
                    End_While
                pop esi

                If eax = 1
                    movsb
                    mov B$edi 0 ; ensure it ends with 0
                Else
                    movsw
                    mov B$edi 0 ; ensure it ends with 0
                End_If
                sub edi eax
            .End_If

            call String2Dword edi ; convert the Decimal String to Dword
            ; At eax we have the dword value of the Hour. Now we need to put it on the St_UTC structure
            mov D@TmpHour eax

            ; Now we check for the time markers (AM/PM, A/P)

            mov esi D@TimeFmt
            mov ecx 0

            While B$esi <> 0
                .If B$esi = 't'
                    mov esi D@TimeString
                    add esi ecx
                    If B$esi = 'A'
                        mov D@TimeMark 1 ; AM
                    Else_If B$esi = 'P'
                        mov D@TimeMark 2 ;PM
                    Else ; something is wrong. Set it to 0
                        mov D@TimeMark 0
                    End_If
                    jmp @HourFound
                .End_If
                inc ecx
                inc esi
            End_While

            mov D@TimeMark 0
            jmp @HourFound

        ..End_If
        inc ecx
        inc esi
    .End_While

@HourNotFound:
    mov W$St_UTC.wHour 0  ; Could not find any Hours chars. It is possible that it is something wrong with the Hour Format
                            ; so we settle the Hour to 0.

@HourFound:

    ; 2nd Locate the Minutes chars. It can be 'mm', 'm'

    mov edi TimeBuffer
    mov esi D@TimeFmt
    mov ecx 0

    .While B$esi <> 0

        ..If B$esi = 'm'
            .If B$esi+1 = 'm' ; Is it of the Format 'mm' ?
                mov esi D@TimeString
                add esi ecx
                movsw       ; copy the Decimal String (Minute) to the buffer
                mov B$edi 0 ; ensure it ends with 0
                sub edi 2   ; decrease it by 2 to ensure it will point to the start of the string.
            .Else
                ; Found only the 'm' time format. Check the byte immediate after it to get the end of the string
                ; ecx = starting point of the address
                movzx edx B$esi+1 ; edx is the ending char we need to find.

                mov esi D@TimeString
                add esi ecx ; esi is now the starting address
                push esi
                    mov eax 0 ; Our byte counter
                    While B$esi <> dl ; is it equal to the lower part of edx ? (The lower part is where it is stored our char)
                        inc eax
                        inc esi
                    End_While
                pop esi

                If eax = 1
                    movsb
                    mov B$edi 0 ; ensure it ends with 0
                Else
                    movsw
                    mov B$edi 0 ; ensure it ends with 0
                End_If
                sub edi eax
            .End_If

            call String2Dword edi ; convert the Decimal String to Dword
            ; At eax we have the dword value of the Hour. Now we need to put it on the St_UTC structure
            mov D@TmpMinute eax
            jmp @MinuteFound

        ..End_If
        inc ecx
        inc esi
    .End_While

@MinuteNotFound:
    mov W$St_UTC.wMinute 0  ; Could not find any Hours chars. It is possible that it is something wrong with the Hour Format
                            ; so we settle the Hour to 0.

@MinuteFound:

    ; 3rd Locate the Seconds chars. It can be 'ss', 's'
    mov edi TimeBuffer
    mov esi D@TimeFmt
    mov ecx 0

    .While B$esi <> 0

        ..If B$esi = 's'
            .If B$esi+1 = 's' ; Is it of the Format 'mm' ?
                mov esi D@TimeString
                add esi ecx
                movsw       ; copy the Decimal String (Minute) to the buffer
                mov B$edi 0 ; ensure it ends with 0
                sub edi 2   ; decrease it by 2 to ensure it will point to the start of the string.
            .Else
                ; Found only the 's' time format. Check the byte immediate after it to get the endof the string
                ; ecx = starting point of the address
                movzx edx B$esi+1 ; edx is the ending char we need to find.

                mov esi D@TimeString
                add esi ecx ; esi is now the starting address
                push esi
                    mov eax 0 ; Our byte counter
                    While B$esi <> dl ; is it equal to the lower part of edx ? (The lower part is where it is stored our char)
                        inc eax
                        inc esi
                    End_While
                pop esi
                If eax = 1
                    movsb
                    mov B$edi 0 ; ensure it ends with 0
                Else
                    movsw
                    mov B$edi 0 ; ensure it ends with 0
                End_If
                sub edi eax
            .End_If

            call String2Dword edi ; convert the Decimal String to Dword
            ; At eax we have the dword value of the Hour. Now we need to put it on the St_UTC structure
            mov D@TmpSecond eax
            jmp @SecondFound

        ..End_If
        inc ecx
        inc esi
    .End_While

@SecondNotFound:
    mov W$St_UTC.wSecond 0  ; Could not find any Hours chars. It is possible that it is something wrong with the Hour Format
                            ; so we settle the Hour to 0.

@SecondFound:

    ; 4th Now that we computed all time data, we check for erros.
    ; If we have no errors, we copy them to the proper structure members

    ; a) See if all Dat fits their proper values

;;
    ; Guga Note 14/02/06. Skip this error checking for now.
    ..If D@TimeMark <> 0 ; If TimeMark is not zero, it means that we have the type 'hh' or 'h' for hour data.
        
        ; So, let's check if the values are smaller then 12
        If D@TmpHour > 12
            mov eax 1
            ExitP
        End_If
        
         ; PM. Need to multiply the hour by 2 to we get the proper hour in 24 hour type
        .If_And D@TimeMark = 2, D@TmpHour = 12
            If_Or D@TmpMinute <> 0, D@TmpSecond <> 0 
            
            End_If
        .End_If
    ..End_If

;;
; St_UTC.wHour: W$ 0
 ;St_UTC.wMinute: W$ 0
 ;St_UTC.wSecond: W$ 0

    ; 5th Now that we computed all time data, we just copy them to the proper structure members.

    move W$St_UTC.wHour W@TmpHour
    move W$St_UTC.wMinute W@TmpMinute
    move W$St_UTC.wSecond W@TmpSecond



; _________________________________________________________________
;   2nd Step. Get the Date Stamp
; _________________________________________________________________


    ; 1st Locate the Year chars. It can be 'yyyy', 'yy', 'y'

    mov edi TimeBuffer
    mov esi D@DateFmt
    mov ecx 0

    ; 1st Since we can have string with unknown len (from dddd or MMMM)
L1:

    .While B$esi <> 0
        ..If W$esi = 'dd' ; Full week name

            If W$esi+2 = 'dd' ; is it 'dddd' ?
                mov D$FullWeekFmt 'dddd'
                mov B$FullWeekFmt+4 0 ; ensure it will end with 0
            Else_If B$esi+2 = 'd' ; is it 'ddd' ?
                mov W$FullWeekFmt 'dd'
                mov B$FullWeekFmt+2 'd'
                mov B$FullWeekFmt+3 0 ; ensure it will end with 0
                mov B$FullWeekFmt+4 0 ; ensure it will end with 0
            Else
                ; Found only 'dd' or 'd'
                jmp Z5>>
            End_If

            ; Compare the full week name and mark it as a dword already.
            mov edx ecx ; edx = starting address of the found string.
            mov ecx 1

            .Do

                call GetDayofWeekinCurrentMonth ecx, FullWeekFmt, TimeBuffer; 0 = monday
                mov D@TmpDayofWeek eax
                call StrLenProc D@DateString
                mov esi eax
                call StrLenProc TimeBuffer
                mov D@FoundSourceLen eax
                call SBMBinSearch 0, D@DateString, esi, TimeBuffer, eax
                .If eax <> 0-1
                    mov ebx eax
                    add ebx D@FoundSourceLen
                    ; The String was found
                    ; At eax we have the pos (in bytes) where the string starts.
                    ; At ebx we have ending pos of the found string
                    mov edi TimeMap
                    If D@UseFullWeek_Month = &FALSE
                        mov esi D@DateFmt
                    Else
                        mov esi NewDateBuffer
                    End_If
                    ; Copy the initial part before the changes
                    mov ecx edx
                    rep movsb
                    mov B$edi 0

                   ; Copy the changed part
                    mov ecx ebx
                    sub ecx eax
                    mov al 'z'
                    rep stosb

                    ; Copy the final part to the new changed one.

                    If D@UseFullWeek_Month = &FALSE
                        mov esi D@DateFmt
                    Else
                        mov esi NewDateBuffer
                    End_If

                    add esi edx

                    If D$FullWeekFmt = 'dddd'
                        add esi 4
                    Else
                        add esi 3
                    End_If

                    While B$esi <> 0
                        movsb
                    End_While

                    mov B$edi 0
                    mov esi TimeMap
                    mov edi NewDateBuffer
                    push esi | ZCopy TimeMap | pop esi
                    mov D@UseFullWeek_Month &TRUE

                    jmp L1<< ; do again to we see if we don´ have the 'MMMM' format type

                .End_If
                inc ecx
            .Loop_Until ecx = 8 ; 1 week have 7 days. So we limit it to 8 (from day 1 to day 8)

        ..Else_If W$esi = 'MM'

            If W$esi+2 = 'MM' ; is it 'MMMM' ?
                mov D$FullWeekFmt 'MMMM'
                mov B$FullWeekFmt+4 0 ; ensure it will end with 0
            Else_If B$esi+2 = 'M' ; is it 'MMM' ?
                mov W$FullWeekFmt 'MM'
                mov B$FullWeekFmt+2 'M'
                mov B$FullWeekFmt+3 0 ; ensure it will end with 0
                mov B$FullWeekFmt+4 0 ; ensure it will end with 0
            Else
                jmp Z5>> ; Found only 'MM' or 'M'
            End_If
            ; Compare the full week name and mark it as a dword already.
            mov edx ecx ; edx = starting address of the found string.
            mov ecx 1

            .Do

                call GetMonthStringandValue ecx, FullWeekFmt, TimeBuffer; 0 = monday
                mov D@TmpMonth eax
                call StrLenProc D@DateString
                mov esi eax
                call StrLenProc TimeBuffer
                mov D@FoundSourceLen eax
                call SBMBinSearch 0, D@DateString, esi, TimeBuffer, eax
                .If eax <> 0-1
                    mov ebx eax
                    add ebx D@FoundSourceLen
                    ; The String was found
                    ; At eax we have the pos (in bytes) where the string starts.
                    ; At ebx we have ending pos of the found string
                    mov edi TimeMap

                    ; Copy the initial part before the changes
                    If D@UseFullWeek_Month = &FALSE
                        mov esi D@DateFmt
                    Else
                        mov esi NewDateBuffer
                    End_If
                    mov ecx edx
                    rep movsb
                    mov B$edi 0

                   ; Copy the changed part
                    mov ecx ebx
                    sub ecx eax
                    mov al 'x'
                    rep stosb

                    ; Copy the final part to the new changed one.
                    If D@UseFullWeek_Month = &FALSE
                        mov esi D@DateFmt
                    Else
                        mov esi NewDateBuffer
                    End_If
                    add esi edx

                    If D$FullWeekFmt = 'MMMM'
                        add esi 4
                    Else
                        add esi 3
                    End_If

                    While B$esi <> 0
                        movsb
                    End_While

                    mov B$edi 0
                    mov esi TimeMap
                    mov edi NewDateBuffer
                    push esi | ZCopy TimeMap | pop esi
                    mov D@UseFullWeek_Month &TRUE
                    jmp L1<< ; do again to we see if we don´ have the 'MMMM' format type

                .End_If
                inc ecx
            .Loop_Until ecx = 13 ; maximum months of 1 year (From 1 to 12)

        ..End_If
Z5:

        inc ecx
        inc esi
    .End_While

    ; 2nd Find now the year

    xor ecx ecx ; clear ecx

    If D@UseFullWeek_Month = &TRUE
        mov esi NewDateBuffer
    Else
        mov esi D@DateFmt
    End_If

    .While B$esi <> 0

        ..If D$esi = 'yyyy'
            mov esi D@DateString
            add esi ecx
            movsd       ; copy the Decimal String (Minute) to the buffer
            mov B$edi 0 ; ensure it ends with 0
            sub edi 4   ; decrease it by 2 to ensure it will point to the start of the string.
            call String2Dword edi ; convert the Decimal String to Dword
            ; At eax we have the dword value of the Year. Now we need to put it on the St_UTC structure
            mov D@TmpYear eax
            jmp @YearFound

        ..Else_If B$esi = 'y' ; In any case (yy or y), we must check with the actual system date, because we are dealing with decade.
                              ; It means that the year is smaller then 10
            .If B$esi+1 = 'y' ; Is it of the Format 'mm' ?
                mov esi D@DateString
                add esi ecx
                movsw       ; copy the Decimal String (Minute) to the buffer
                mov B$edi 0 ; ensure it ends with 0
                sub edi 2   ; decrease it by 2 to ensure it will point to the start of the string.
            .Else
                ; Found only the 'y' time format. Check the byte immediate after it to get the end of the string
                ; ecx = starting point of the address
                movzx edx B$esi+1 ; edx is the ending char we need to find.

                mov esi D@DateString
                add esi ecx ; esi is now the starting address
                push esi
                    mov eax 0 ; Our byte counter
                    While B$esi <> dl ; is it equal to the lower part of edx ? (The lower part is where it is stored our char)
                        inc eax
                        inc esi
                    End_While
                pop esi

                If eax = 1
                    movsb
                    mov B$edi 0 ; ensure it ends with 0
                Else
                    movsw
                    mov B$edi 0 ; ensure it ends with 0
                End_If
                sub edi eax
            .End_If

            call String2Dword edi ; convert the Decimal String to Dword
            mov ecx eax ; copy the Date Value to ecx
            ; Now, since we are dealing with 'yy' or 'y' format, we have to find which full year we are.
            ; This is because the formats we are parsing refers to the current decade (values from 0 to 9).
            ; For example. now it is year 2006. If we found a value of 02, it means that the year we parsed is 2002

            call CurrentDateStampToString {"yyyy", 0}, edi, &NULL, &NULL
            mov B$edi+3 '0' ; Zero the last String Byte. Ex: 2006 turns onto 2000

            call String2Dword edi ; convert the Decimal String to Dword
            add eax ecx ; eax = eax+ecx (2000+6)
            ; At eax we have the dword value of the Year. Now we need to put it on the St_UTC structure
            mov D@TmpYear eax
            jmp @YearFound

        ..End_If
        inc ecx
        inc esi
    .End_While

@YearNotFound:
    mov W$St_UTC.wYear 0  ; Could not find any Hours chars. It is possible that it is something wrong with the Hour Format
                            ; so we settle the Hour to 0.

@YearFound:


    ; 3rd Locate the Day of Month chars. It can be 'dd', 'd'
    mov edi TimeBuffer

    xor ecx ecx ; clear ecx

    If D@UseFullWeek_Month = &TRUE
        mov esi NewDateBuffer
    Else
        mov esi D@DateFmt
    End_If


    .While B$esi <> 0

        ..If B$esi = 'd'
            .If B$esi+1 = 'd' ; Is it of the Format 'dd' ?
                mov esi D@DateString
                add esi ecx
                movsw       ; copy the Decimal String (Minute) to the buffer
                mov B$edi 0 ; ensure it ends with 0
                sub edi 2   ; decrease it by 2 to ensure it will point to the start of the string.
            .Else
                ; Found only the 's' time format. Check the byte immediate after it to get the endof the string
                ; ecx = starting point of the address
                movzx edx B$esi+1 ; edx is the ending char we need to find.

                mov esi D@DateString
                add esi ecx ; esi is now the starting address
                push esi
                    mov eax 0 ; Our byte counter
                    While B$esi <> dl ; is it equal to the lower part of edx ? (The lower part is where it is stored our char)
                        inc eax
                        inc esi
                    End_While
                pop esi
                If eax = 1
                    movsb
                    mov B$edi 0 ; ensure it ends with 0
                Else
                    movsw
                    mov B$edi 0 ; ensure it ends with 0
                End_If
                sub edi eax
            .End_If

            call String2Dword edi ; convert the Decimal String to Dword
            ; At eax we have the dword value of the Hour. Now we need to put it on the St_UTC structure
            mov D@TmpDay eax
            jmp @DayofMonth

        ..End_If
        inc ecx
        inc esi
    .End_While

@DayofMonthNotFound:
    mov W$St_UTC.wDay 0  ; Could not find any Hours chars. It is possible that it is something wrong with the Hour Format
                            ; so we settle the Hour to 0.

@DayofMonth:



    ; 3rd Locate the Month chars. It can be 'MM', 'M'
    mov edi TimeBuffer

    xor ecx ecx ; clear ecx

    If D@UseFullWeek_Month = &TRUE
        mov esi NewDateBuffer
    Else
        mov esi D@DateFmt
    End_If


    .While B$esi <> 0

        ..If B$esi = 'M'
            .If B$esi+1 = 'M' ; Is it of the Format 'dd' ?
                mov esi D@DateString;D@TimeString
                add esi ecx
                movsw       ; copy the Decimal String (Minute) to the buffer
                mov B$edi 0 ; ensure it ends with 0
                sub edi 2   ; decrease it by 2 to ensure it will point to the start of the string.
            .Else
                ; Found only the 's' time format. Check the byte immediate after it to get the endof the string
                ; ecx = starting point of the address
                movzx edx B$esi+1 ; edx is the ending char we need to find.

                mov esi D@DateString
                add esi ecx ; esi is now the starting address
                push esi
                    mov eax 0 ; Our byte counter
                    While B$esi <> dl ; is it equal to the lower part of edx ? (The lower part is where it is stored our char)
                        inc eax
                        inc esi
                    End_While
                pop esi
                If eax = 1
                    movsb
                    mov B$edi 0 ; ensure it ends with 0
                Else
                    movsw
                    mov B$edi 0 ; ensure it ends with 0
                End_If
                sub edi eax
            .End_If

            call String2Dword edi ; convert the Decimal String to Dword
            ; At eax we have the dword value of the Hour. Now we need to put it on the St_UTC structure
            mov D@TmpMonth eax
            jmp @Month

        ..End_If
        inc ecx
        inc esi
    .End_While

@MonthNotFound:
    mov W$St_UTC.wMonth 0  ; Could not find any Hours chars. It is possible that it is something wrong with the Hour Format
                            ; so we settle the Hour to 0.
@Month:


; _________________________________________________________________
;   3rd Step. Get FILETIME Structure
; _________________________________________________________________


    ; Now that we have the full SYSTEMTIME Structure, we must get the proper FILETIME

    move W$St_UTC.wYear W@TmpYear
    move W$St_UTC.wMonth W@TmpMonth
    move W$St_UTC.wDayOfWeek W@TmpDayofWeek
    move W$St_UTC.wDay W@TmpDay
    move W$St_UTC.wHour W@TmpHour
    move W$St_UTC.wMinute W@TmpMinute
    move W$St_UTC.wSecond W@TmpSecond
    mov W$St_UTC.wMilliseconds 0

    call 'KERNEL32.SystemTimeToFileTime' St_UTC, St_DateTimeStamp


; _________________________________________________________________
;   4th Step. Convert the FILETIME to the dword
; _________________________________________________________________


        mov eax D$St_DateTimeStamp.dwLowDateTime
        mov edx D$St_DateTimeStamp.dwHighDateTime


        sub eax &EPOCH_DIFF_SECS_INTERVAL_LOW
        sbb edx &EPOCH_DIFF_SECS_INTERVAL_HIGH

        ; The following routines are used to divide a Qword with a Dword
        mov D$St_DateTimeStamp.dwLowDateTime eax
        mov D$St_DateTimeStamp.dwHighDateTime edx

        xor edx edx
        xor eax eax

        mov eax D$St_DateTimeStamp.dwHighDateTime
        mov ecx &SECS_TO_100NS
        div ecx

        mov eax D$St_DateTimeStamp.dwLowDateTime
        mov ecx &SECS_TO_100NS
        div ecx

        mov edi D@TimeStamp
        mov D$edi eax

;;
Error Types:
1 = The Hour value is of the type AM/PM, so it can´t be bigger then 12
;;

EndP


_____________________________________________________________________________________________________________________



;;

        __________________________________________________________________________________________________

                                          Get Day of Week in current month
                                                by Beyond2000! (Guga)
        __________________________________________________________________________________________________

GetDayofWeekinCurrentMonth


    The GetDayofWeekinCurrentMonth function retrieves the day of week (string) of a given day in the current month.


Parameters:

 @InputMonth, @DateFmt, @DateOut
    
    InputMonth:  Value of the month we want to be converted to string. The values are from 1 to 12 represented as:
                 1 = January
                 2 = February
                 3 = March
                 ....
                 12 = December
    
    DateFmt:  Pointer to a string used to form the month string. The string must be zero terminated. This parameter can't
              be NULL.

              Use the following letters to build the formated string.
              
              The letters must be in uppercase as shown in the table (for example, "MMM" not "mmm").
              
              Characters in the format string that are enclosed in single quotation marks will appear in the same
              location and unchanged in the output string.

                            Letters     Description
    
                            MMM         Month as a three-letter abbreviation. The function uses the LOCALE_SABBREVMONTHNAME
                                        value associated with the specified locale.
                            
                            MMMM        Month as its full name. The function uses the LOCALE_SMONTHNAME value associated
                                        with the specified locale.

              
              For example, to get the time string 

                "December"

              use the following picture string: 

                'MMMM"


              This parameter is used as input.
    
    
    DateOut:  Pointer to a buffer that receives the formatted date string, and output the result in the format specified
              in DateFmt. The buffer can be limited to the lenght of the formated string.
    
    
Usage Examples:


a)

[TimeBuffer: B$ 0 #80]
        call GetMonthStringandValue 2, {"MMMM", 0}, TimeBuffer

    It will output on the timeBuffer the string "february" (Of course, depending of the language on your system).
    At eax it will output the value of the month. In case it is 2 (The same as the input).
b)

[TimeBuffer: B$ 0 #80]
        call GetMonthStringandValue 2, {"MMM", 0}, TimeBuffer

    It will output on the timeBuffer the string "feb" (Of course, depending of the language on your system).
    At eax it will output the value of the month. In case it is 2 (The same as the input).
        
;;

Proc GetDayofWeekinCurrentMonth:
    Arguments @InputDay, @DateFmt, @DateOut
    Structure @St_UTC 16, @St_UTC.wYearDis 0,  @St_UTC.wMonthDis 2,  @St_UTC.wDayOfWeekDis 4,  @St_UTC.wDayDis 6,  @St_UTC.wHourDis 8,  @St_UTC.wMinuteDis 10,  @St_UTC.wSecondDis 12,  @St_UTC.wMillisecondsDis 14
    Local @CurrentDay, @Weekday

    pushad
        call 'KERNEL32.GetLocalTime' D@St_UTC
        movzx eax W@St_UTC.wDayDis
        push eax
            mov ecx D@InputDay
            mov W@St_UTC.wDayDis cx
            call 'KERNEL32.GetDateFormatA' &LOCALE_SYSTEM_DEFAULT &NULL D@St_UTC D@DateFmt D@DateOut &MAX_UTC_TIME_LEN
        pop eax
        ; current Day. 5 = Friday ; 6 Saturday, 0 Sunday, 1 Monday ...
        movzx ecx W@InputDay
        mov W@St_UTC.wDayDis cx ; inputed day
        move W@Weekday W@St_UTC.wDayOfWeekDis
        ; Calculate the dword value related to the day-of-the-week to be found
        .If eax >= ecx ; If current day is bigger or equal to the inputed day

            .While eax <> ecx

                dec eax ; decrease current day
                dec W@St_UTC.wDayOfWeekDis
                If W@St_UTC.wDayOfWeekDis = 0-1 ; when we reach here. we are on Saturday. so we must set it to the proper value
                    mov W@St_UTC.wDayOfWeekDis 6 ; Saturday
                End_If

            .End_While


        .Else ; If current day is smaller then the inputed day

            .While eax <> ecx

                inc eax ; increase current day
                inc W@St_UTC.wDayOfWeekDis
                If W@St_UTC.wDayOfWeekDis = 7 ; when we reach here. we are on Sunday. so we must set it to the proper value
                    mov W@St_UTC.wDayOfWeekDis 0 ; Sunday
                End_If

            .End_While


        .End_If

    popad
        movzx eax W@St_UTC.wDayOfWeekDis

EndP

_____________________________________________________________________________________________________________________

;;

        __________________________________________________________________________________________________

                                        Month Dword to String function.
                                                by Beyond2000! (Guga)
        __________________________________________________________________________________________________

GetMonthStringandValue


    The GetMonthStringandValue function converts a month value into a readable string.


Parameters:

 @InputMonth, @DateFmt, @DateOut
    
    InputMonth:  Value of the month we want to be converted to string. The values are from 1 to 12 represented as:
                 1 = January
                 2 = February
                 3 = March
                 ....
                 12 = December
    
    DateFmt:  Pointer to a string used to form the month string. The string must be zero terminated. This parameter can't
              be NULL.

              Use the following letters to build the formated string.
              
              The letters must be in uppercase as shown in the table (for example, "MMM" not "mmm").
              
              Characters in the format string that are enclosed in single quotation marks will appear in the same
              location and unchanged in the output string.

                            Letters     Description
    
                            MMM         Month as a three-letter abbreviation. The function uses the LOCALE_SABBREVMONTHNAME
                                        value associated with the specified locale.
                            
                            MMMM        Month as its full name. The function uses the LOCALE_SMONTHNAME value associated
                                        with the specified locale.

              
              For example, to get the time string 

                "December"

              use the following picture string: 

                'MMMM"


              This parameter is used as input.
    
    
    DateOut:  Pointer to a buffer that receives the formatted date string, and output the result in the format specified
              in DateFmt. The buffer can be limited to the lenght of the formated string.
    
    
Usage Examples:


a)

[TimeBuffer: B$ 0 #80]
        call GetMonthStringandValue 2, {"MMMM", 0}, TimeBuffer

    It will output on the timeBuffer the string "february" (Of course, depending of the language on your system).
    At eax it will output the value of the month. In case it is 2 (The same as the input).
b)

[TimeBuffer: B$ 0 #80]
        call GetMonthStringandValue 2, {"MMM", 0}, TimeBuffer

    It will output on the timeBuffer the string "feb" (Of course, depending of the language on your system).
    At eax it will output the value of the month. In case it is 2 (The same as the input).
        
;;

Proc GetMonthStringandValue:
    Arguments @InputMonth, @DateFmt, @DateOut
    Structure @St_UTC 16, @St_UTC.wYearDis 0,  @St_UTC.wMonthDis 2,  @St_UTC.wDayOfWeekDis 4,  @St_UTC.wDayDis 6,  @St_UTC.wHourDis 8,  @St_UTC.wMinuteDis 10,  @St_UTC.wSecondDis 12,  @St_UTC.wMillisecondsDis 14
    Local @CurrentDay, @Weekday

    pushad
        call 'KERNEL32.GetLocalTime' D@St_UTC
        movzx eax W@St_UTC.wMonthDis ; 1 = January ; 2 = February ; 3 = March....; 12 = December
        push eax
            mov ecx D@InputMonth
            mov W@St_UTC.wMonthDis cx
            call 'KERNEL32.GetDateFormatA' &LOCALE_SYSTEM_DEFAULT &NULL D@St_UTC D@DateFmt D@DateOut &MAX_UTC_TIME_LEN
        pop eax
    popad
        mov eax D@InputMonth

EndP

_____________________________________________________________________________________________________________________


;;

        __________________________________________________________________________________________________

                                        Current Date Stamp to String function.
                                                by Beyond2000! (Guga)
        __________________________________________________________________________________________________

CurrentDateStampToString

    The CurrentDateStampToString function was builded to help the user to convert the current date stamp
    of his system into a readable string.


Parameters:

 @DateFmt, @DateOut, @SysTimeStr, @FileTimeStr
    
    DateFmt:  Pointer to a string used to form the date string. The string must be zero terminated. This parameter can't
              be NULL.
              
              Use the following letters to build the formated string.
              
              If you use spaces to separate the letters in the formated string, these spaces will appear in the same
              location in the output string.
              
              The letters must be in uppercase or lowercase as shown in the table (for example, "MM" not "mm").
              
              Characters in the format string that are enclosed in single quotation marks will appear in the same
              location and unchanged in the output string.

                            Letters     Description
                            
                            d           Day of month as digits with no leading zero for single-digit days.
                            
                            dd          Day of month as digits with leading zero for single-digit days.
                            
                            ddd         Day of week as a three-letter abbreviation. The function uses the
                                        LOCALE_SABBREVDAYNAME value associated with the specified locale.
                                        
                            dddd        Day of week as its full name. The function uses the LOCALE_SDAYNAME value
                                        associated with the specified locale.
                                        
                            M           Month as digits with no leading zero for single-digit months.
                            
                            MM          Month as digits with leading zero for single-digit months.
                            
                            MMM         Month as a three-letter abbreviation. The function uses the LOCALE_SABBREVMONTHNAME
                                        value associated with the specified locale.
                            
                            MMMM        Month as its full name. The function uses the LOCALE_SMONTHNAME value associated
                                        with the specified locale.
                            
                            y           Year as last two digits, but with no leading zero for years less than 10.
                            
                            yy          Year as last two digits, but with leading zero for years less than 10.
                            
                            yyyy        Year represented by full four digits.
                            
                            gg          Period/era string. The function uses the CAL_SERASTRING value associated with the
                                        specified locale. This element is ignored if the date to be formatted does not have
                                        an associated era or period string.
                                        

              For example, to get the date string
                
                "Sun, Jun 06 04"
              
              use the following picture string:
                
                "ddd',' MMM dd yy"

              
              This parameter is used as input.

    
    
    DateOut:  Pointer to a buffer that receives the formatted date string, and output the result in the format specified
              in DateFmt. The buffer can be limited to the lenght of the formated string.
    
    
    SysTimeStr: Pointer to a SYSTEMTIME structure buffer where it will output the result data of it's members (Day, Day of Week,
                time, hour, seconds, etc).
                If the value of this parameter is &NULL, it won´t output the data.


    FileTimeStr:    Pointer to a FILETIME structure buffer where it will output the result data of it's members (Low and High Values ot the timedate stamp).
                If the value of this parameter is &NULL, it won´t output the data.


Usage Examples:


a)

[szDateString: B$ ? #64] ; Lenght of the date string. (Maximum is &MAX_UTC_TIME_LEN)

        call CurrentDateStampToString {"yyyy", 0}, szDateString, &NULL, &NULL

b)

[Sz_Year: B$ "yyyy/MM/dd ddd ",0]

[szDateString: B$ ? #64] ; Lenght of the date string. (Maximum is &MAX_UTC_TIME_LEN)

        call CurrentDateStampToString Sz_Year, szDateString, &NULL, &NULL

c)

; system_time SYSTEMTIME Structure
[system_time:
 system_time.wYear: W$ 0
 system_time.wMonth: W$ 0
 system_time.wDayOfWeek: W$ 0
 system_time.wDay: W$ 0
 system_time.wHour: W$ 0
 system_time.wMinute: W$ 0
 system_time.wSecond: W$ 0
 system_time.wMilliseconds: W$ 0]

; FILETIME structure
[St_DateTimeStamp:
 St_DateTimeStamp.dwLowDateTime: D$ 0
 St_DateTimeStamp.dwHighDateTime: D$ 0]


[Sz_Year: B$ "yyyy/MM/dd ddd ",0]
[szDateString: B$ ? #64] ; Lenght of the date string. (Maximum is &MAX_UTC_TIME_LEN)

        call CurrentDateStampToString Sz_Year, szDateString, system_time, St_DateTimeStamp
        
;;

[Size_Of_SYSTEMTIME 16]
[Size_Of_FILETIME 8]

Proc CurrentDateStampToString:
    Arguments @DateFmt, @DateOut, @SysTimeStr, @FileTimeStr
    Structure @St_UTC 16, @St_UTC.wYearDis 0,  @St_UTC.wMonthDis 2,  @St_UTC.wDayOfWeekDis 4,  @St_UTC.wDayDis 6,  @St_UTC.wHourDis 8,  @St_UTC.wMinuteDis 10,  @St_UTC.wSecondDis 12,  @St_UTC.wMillisecondsDis 14
    Local @St_DateTimeStamp.dwLowDateTime, @St_DateTimeStamp.dwHighDateTime
    Uses ecx, edx

    call 'KERNEL32.GetLocalTime' D@St_UTC

    If D@SysTimeStr <> 0
        mov edi D@SysTimeStr
        mov esi D@St_UTC
        mov ecx 0
        While ecx <> Size_Of_SYSTEMTIME
            movsb
            inc ecx
        End_While
    End_If

    lea eax D@St_DateTimeStamp.dwLowDateTime
    call 'KERNEL32.SystemTimeToFileTime' D@St_UTC, D$eax

    If D@FileTimeStr <> 0
        mov edi D@FileTimeStr
        mov esi D@St_DateTimeStamp.dwLowDateTime
        mov ecx 0
        While ecx <> Size_Of_FILETIME
            movsb
            inc ecx
        End_While
    End_If

    lea eax D@St_DateTimeStamp.dwLowDateTime
    call 'kernel32.FileTimeToSystemTime' D$eax, D@St_UTC
    call 'KERNEL32.GetDateFormatA' &LOCALE_SYSTEM_DEFAULT &NULL D@St_UTC D@DateFmt D@DateOut &MAX_UTC_TIME_LEN

EndP

_____________________________________________________________________________________________________________________

;;

        __________________________________________________________________________________________________

                                        Current Time Stamp to String function.
                                                by Beyond2000! (Guga)
        __________________________________________________________________________________________________

CurrentTimeStampToString


    The CurrentTimeStampToString function was builded to help the user to convert the current time stamp
    of his system into a readable string.


Parameters:

 @TimeFmt, @TimeOut, @SysTimeStr, @FileTimeStr    

    
    TimeFmt:  Pointer to a string used to form the time string. The string must be zero terminated. This parameter can't
              be NULL.

              Use the following letters to build the formated string.
              
              If you use spaces to separate the letters in the formated string, these spaces will appear in the same
              location in the output string.
              
              The letters must be in uppercase or lowercase as shown in the table (for example, "ss" not "SS").
              
              Characters in the format string that are enclosed in single quotation marks will appear in the same
              location and unchanged in the output string.

                            Letters     Description
    
                            h           Hours with no leading zero for single-digit hours; 12-hour clock.
                            
                            hh          Hours with leading zero for single-digit hours; 12-hour clock.
                            
                            H           Hours with no leading zero for single-digit hours; 24-hour clock.
                            
                            HH          Hours with leading zero for single-digit hours; 24-hour clock.
                            
                            m           Minutes with no leading zero for single-digit minutes.
                            
                            mm          Minutes with leading zero for single-digit minutes.
                            
                            s           Seconds with no leading zero for single-digit seconds.
                            
                            ss          Seconds with leading zero for single-digit seconds.
                            
                            t           One character time-marker string, such as A or P.
                            
                            tt          Multicharacter time-marker string, such as AM or PM.

              
              For example, to get the time string 

                "11:29:40 PM"

              use the following picture string: 

                "hh':'mm':'ss tt"


              This parameter is used as input.
    
    
    TimeOut:  Pointer to a buffer that receives the formatted time string, and output the result in the format specified
              in TimeFmt. The buffer can be limited to the lenght of the formated string.


    SysTimeStr: Pointer to a SYSTEMTIME structure buffer where it will output the result data of it's members (Day, Day of Week,
                time, hour, seconds, etc).
                If the value of this parameter is &NULL, it won´ output the data.


    FileTimeStr:    Pointer to a FILETIME structure buffer where it will output the result data of it's members (Low and High Values ot the timedate stamp).
                If the value of this parameter is &NULL, it won´ output the data.


Usage Examples:


a)

[szTimeString: B$ ? #64] ; Lenght of the time string. (Maximum is &MAX_UTC_TIME_LEN)

        call CurrentTimeStampToString {"HH:mm:ss UTC", 0}, szTimeString, &NULL, &NULL

b)

[Sz_Hour: B$ "HH:mm:ss UTC",0]
[szTimeString: B$ ? #64] ; Lenght of the time string. (Maximum is &MAX_UTC_TIME_LEN)


        call CurrentTimeStampToString Sz_Hour, szTimeString, &NULL, &NULL

c)

; system_time SYSTEMTIME Structure
[system_time:
 system_time.wYear: W$ 0
 system_time.wMonth: W$ 0
 system_time.wDayOfWeek: W$ 0
 system_time.wDay: W$ 0
 system_time.wHour: W$ 0
 system_time.wMinute: W$ 0
 system_time.wSecond: W$ 0
 system_time.wMilliseconds: W$ 0]

; FILETIME structure
[St_DateTimeStamp:
 St_DateTimeStamp.dwLowDateTime: D$ 0
 St_DateTimeStamp.dwHighDateTime: D$ 0]


[Sz_Year: B$ "yyyy/MM/dd ddd ",0
 Year_Len: D$ len]
[Sz_Hour: B$ "HH:mm:ss UTC",0
 Hour_Len: D$ len]

[szTimeString: B$ ? #64]

        call CurrentTimeStampToString {"HH:mm:ss UTC", 0}, szTimeString, system_time, St_DateTimeStamp
        
;;

Proc CurrentTimeStampToString:
    Arguments @TimeFmt, @TimeOut, @SysTimeStr, @FileTimeStr
    Structure @St_UTC 16, @St_UTC.wYearDis 0,  @St_UTC.wMonthDis 2,  @St_UTC.wDayOfWeekDis 4,  @St_UTC.wDayDis 6,  @St_UTC.wHourDis 8,  @St_UTC.wMinuteDis 10,  @St_UTC.wSecondDis 12,  @St_UTC.wMillisecondsDis 14
    Local @St_DateTimeStamp.dwLowDateTime, @St_DateTimeStamp.dwHighDateTime

    pushad

    call 'KERNEL32.GetLocalTime' D@St_UTC
    If D@SysTimeStr <> 0
        mov edi D@SysTimeStr
        mov esi D@St_UTC
        mov ecx 0
        While ecx <> Size_Of_SYSTEMTIME
            movsb
            inc ecx
        End_While
    End_If

    lea eax D@St_DateTimeStamp.dwLowDateTime
    call 'KERNEL32.SystemTimeToFileTime' D@St_UTC, D$eax

    If D@FileTimeStr <> 0
        mov edi D@FileTimeStr
        mov esi D@St_DateTimeStamp.dwLowDateTime
        mov ecx 0
        While ecx <> Size_Of_FILETIME
            movsb
            inc ecx
        End_While
    End_If

    lea eax D@St_DateTimeStamp.dwLowDateTime
    call 'kernel32.FileTimeToSystemTime' D$eax D@St_UTC
    call 'KERNEL32.GetTimeFormatA' &LOCALE_SYSTEM_DEFAULT &NULL D@St_UTC D@TimeFmt D@TimeOut &MAX_UTC_TIME_LEN

    popad
EndP
_____________________________________________________________________________________________________________________

;;

        __________________________________________________________________________________________________

                                        DOS Time and Date Stamp to String function.
                                                by Beyond2000! (Guga)
        __________________________________________________________________________________________________

DOSTimeDateStampToString

    The DOSTimeDateStampToString function was builded to help the user to convert a inputed DOS TimeDate stamp
    into a readable string. This function can be used to retrieve the time and date from files builded in
    delphi, like some .dcu files (kylix), or com files, or 16 Bits windows or dos files and so on.


Parameters:

 @TimeStamp, @DateFmt, @TimeFmt, @DateOut, @TimeOut

    TimeStamp:  Pointer to the Data Value of the DOS time and date stamp found in the Target File. The DOS Time and date
                Stamp consists in 2 encoded values (in Word data type) inside a dword value, relative to date and time.
                These values are called DosFatDate and DosFatTime respectivelly. This parameter is used as Input.
                On this function we will compute both (Date and Time through one single dword value), so, if the input is:
                024CF774A
                It means, that the low word of this value is the DosFatTime,while the Hi Word is the DosFatDate, that will result in:
                [DosFatDate: W$ 024CF]
                [DosFatTime: W$ 0774A]
                
                The DOS Date and Time values are encoded to represent the real time and date of the value we want to convert.
                This functino is similar to TimeDateStampToString, with the difference that we don't compute the interval 
                values. (&EPOCH_DIFF_SECS_INTERVAL_LOW  &EPOCH_DIFF_SECS_INTERVAL_HIGH).
                
                Insetad calculating the interval values, we directly convert the DosTimeDate Stamp through the DosDateTimeToFileTime
                located in kernel32.dll.
                
    DateFmt:  Pointer to a string used to form the date string. The string must be zero terminated. This parameter can't
              be NULL.
              
              Use the following letters to build the formated string.
              
              If you use spaces to separate the letters in the formated string, these spaces will appear in the same
              location in the output string.
              
              The letters must be in uppercase or lowercase as shown in the table (for example, "MM" not "mm").
              
              Characters in the format string that are enclosed in single quotation marks will appear in the same
              location and unchanged in the output string.

                            Letters     Description
                            
                            d           Day of month as digits with no leading zero for single-digit days.
                            
                            dd          Day of month as digits with leading zero for single-digit days.
                            
                            ddd         Day of week as a three-letter abbreviation. The function uses the
                                        LOCALE_SABBREVDAYNAME value associated with the specified locale.
                                        
                            dddd        Day of week as its full name. The function uses the LOCALE_SDAYNAME value
                                        associated with the specified locale.
                                        
                            M           Month as digits with no leading zero for single-digit months.
                            
                            MM          Month as digits with leading zero for single-digit months.
                            
                            MMM         Month as a three-letter abbreviation. The function uses the LOCALE_SABBREVMONTHNAME
                                        value associated with the specified locale.
                            
                            MMMM        Month as its full name. The function uses the LOCALE_SMONTHNAME value associated
                                        with the specified locale.
                            
                            y           Year as last two digits, but with no leading zero for years less than 10.
                            
                            yy          Year as last two digits, but with leading zero for years less than 10.
                            
                            yyyy        Year represented by full four digits.
                            
                            gg          Period/era string. The function uses the CAL_SERASTRING value associated with the
                                        specified locale. This element is ignored if the date to be formatted does not have
                                        an associated era or period string.
                                        

              For example, to get the date string
                
                "Sun, Jun 06 04"
              
              use the following picture string:
                
                "ddd',' MMM dd yy"

              
              This parameter is used as input.

    TimeFmt:  Pointer to a string used to form the time string. The string must be zero terminated. This parameter can't
              be NULL.

              Use the following letters to build the formated string.
              
              If you use spaces to separate the letters in the formated string, these spaces will appear in the same
              location in the output string.
              
              The letters must be in uppercase or lowercase as shown in the table (for example, "ss" not "SS").
              
              Characters in the format string that are enclosed in single quotation marks will appear in the same
              location and unchanged in the output string.

                            Letters     Description
    
                            h           Hours with no leading zero for single-digit hours; 12-hour clock.
                            
                            hh          Hours with leading zero for single-digit hours; 12-hour clock.
                            
                            H           Hours with no leading zero for single-digit hours; 24-hour clock.
                            
                            HH          Hours with leading zero for single-digit hours; 24-hour clock.
                            
                            m           Minutes with no leading zero for single-digit minutes.
                            
                            mm          Minutes with leading zero for single-digit minutes.
                            
                            s           Seconds with no leading zero for single-digit seconds.
                            
                            ss          Seconds with leading zero for single-digit seconds.
                            
                            t           One character time-marker string, such as A or P.
                            
                            tt          Multicharacter time-marker string, such as AM or PM.

              
              For example, to get the time string 

                "11:29:40 PM"

              use the following picture string: 

                "hh':'mm':'ss tt"


              This parameter is used as input.
    
    DateOut:  Pointer to a buffer that receives the formatted date string, and output the result in the format specified
              in DateFmt. The buffer can be limited to the lenght of the formated string.
    
    TimeOut:  Pointer to a buffer that receives the formatted time string, and output the result in the format specified
              in TimeFmt. The buffer can be limited to the lenght of the formated string.



Usage Examples:


a)

[szDateString: B$ ? #64] ; Lenght of the time string. (Maximum is &MAX_UTC_TIME_LEN)
[szTimeString: B$ ? #64] ; Lenght of the time string. (Maximum is &MAX_UTC_TIME_LEN)

        call DOSTimeDateStampToString 024CF774A {"yyyy/MM/dd ddd ", 0} {"HH:mm:ss UTC", 0} szDateString szTimeString
b)

[szDateString: B$ ? #64] ; Lenght of the time string. (Maximum is &MAX_UTC_TIME_LEN)
[szTimeString: B$ ? #64] ; Lenght of the time string. (Maximum is &MAX_UTC_TIME_LEN)
[DosDateStamp: D$ 024CF774A]

        call DOSTimeDateStampToString D$DosDateStamp {"yyyy/MM/dd ddd ", 0} {"HH:mm:ss UTC", 0} szDateString szTimeString
;;


Proc DOSTimeDateStampToString:
    Arguments @TimeStamp, @DateFmt, @TimeFmt, @DateOut, @TimeOut
    Structure @St_UTC 16, @St_UTC.wYearDis 0,  @St_UTC.wMonthDis 2,  @St_UTC.wDayOfWeekDis 4,  @St_UTC.wDayDis 6,  @St_UTC.wHourDis 8,  @St_UTC.wMinuteDis 10,  @St_UTC.wSecondDis 12,  @St_UTC.wMillisecondsDis 14
    Local @St_DateTimeStamp.dwLowDateTime, @St_DateTimeStamp.dwHighDateTime

    pushad
        movzx edx W@TimeStamp   ; DosFatDate
        movzx ecx W@TimeStamp+2 ; DosFatTime

        lea eax D@St_DateTimeStamp.dwLowDateTime
        call 'kernel32.DosDateTimeToFileTime' ecx, edx, D$eax

        lea eax D@St_DateTimeStamp.dwLowDateTime
        call 'kernel32.FileTimeToSystemTime' D$eax, D@St_UTC

        call 'KERNEL32.GetDateFormatA' &LOCALE_SYSTEM_DEFAULT &NULL D@St_UTC D@DateFmt D@DateOut &MAX_UTC_TIME_LEN
        call 'KERNEL32.GetTimeFormatA' &LOCALE_SYSTEM_DEFAULT &NULL D@St_UTC D@TimeFmt D@TimeOut &MAX_UTC_TIME_LEN
    popad
EndP
_____________________________________________________________________________________________________________________










































;;

        __________________________________________________________________________________________________

                                        Simple Boyer Moore Binary Search function.
                                                by Beyond2000! (Guga)
        __________________________________________________________________________________________________


SBMBinSearch

    This function is a variation of a Boyer Moore exact pattern matching algorithm uses the GOOD SUFFIX shift
    with the extra heuristic to handle repeated sequences of characters.
    
    It can be used for a search engine system for Bytes or Strings (Null terminated or not)


Parameters:

 @startpos, @lpSource, @srcLngth, @lpSubStr, @subLngth
 
    startpos:
                Value (in bytes) of the start position of the source string/binary data.
                When the value is 0, the search process will start at position 0 (1st byte included) on the source data.
                If the value is 1, it will start from the 2nd byte.
                Value = 3 start from the 4th byte (including it).....
                Below is a simple scheme of some Bytes to be searched and their related position.
                
                        1st Byte    2nd Byte    3rd Byte    4th Byte    5th Byte ............
                Values    055          044         0FA        088          067   ............
                Position   0            1           2          3            4    ............

    lpSource:
                Pointer to the address of the inputed (Source) data/string to be searched.
 
    srcLngth:
                Lenght of the inputed data/string
 
    lpSubStr:
                Pointer to the address of the data/string to search inside the targeted data/string.

    subLngth:
                Lenght of the data/string to search inside the source data/string.


Return Values:

    If the function suceeds, it returns the position (in bytes) where the string starts in the source data.
    If the function fail, it returns 0-1

Usage Examples:

a)
    call SBMBinSearch 0, {"Hi, my name is Guga. Now i´m typing this", 0}, 40, {"Guga", 0}, 4
    
b)

[Data01: B$ 055 025 014 0 058 0 0 0 025 099 0FA 0DE 045 0DD]
[Data02: B$ 025 099 0FA 0DE 045]
    
    call SBMBinSearch 0, Data01, 14, Data02, 5


Authors:
    Original author (unknown)
    Gustavo (Guga/Beyond2000!) - modified the function a bit, and adapted it to RosAsm

;;

[shift_table: D$ 0 #256]
Proc SBMBinSearch:
    Arguments @startpos, @lpSource, @srcLngth, @lpSubStr, @subLngth
    Uses ebx, esi, edi, ecx, edx

    mov edx D@subLngth

    cmp edx 1 | jg @StrSizeOk
        mov eax 0-2     ; string too short, must be > 1
jmp @Cleanup

@StrSizeOk: F4:
    mov esi D@lpSource
    add esi D@srcLngth
    sub esi edx
    mov ebx esi      ; set Exit Length

  ; ----------------------------------------
  ; load shift table with value in subLngth
  ; ----------------------------------------
    mov ecx 256
    mov eax edx
    lea edi D$shift_table
    rep stosd

  ; ----------------------------------------------
  ; load decending count values into shift table
  ; ----------------------------------------------
    mov ecx edx         ; SubString length in ECX
    dec ecx             ; correct for zero based index
    mov esi D@lpSubStr   ; address of SubString in ESI
    lea edi D$shift_table
    xor eax eax

@Write_Shift_Chars:
    mov al B$esi        ; get the character
    inc esi
    mov D$edi+eax*4 ecx ; write shift for each character
    dec ecx | jne @Write_Shift_Chars ; to ascii location in table

  ; -----------------------------
  ; set up for main compare loop
  ; -----------------------------

    mov esi D@lpSource
    mov edi D@lpSubStr
    dec edx
    xor eax eax         ; zero EAX
    add esi D@startpos    ; add starting position
jmp @Cmp_Loop

@Calc_Suffix_Shift: L6:
    add ecx D$eax*4+shift_table   ; add shift value to loop counter
    sub ecx edx | jns @Pre_Compare        ; sub pattern length
    mov ecx 01              ; minimum shift is 1

@Pre_Compare: N2:
    add esi ecx     ; add suffix shift
    mov ecx edx     ; reset counter for compare loop

@Exit_Text: N6:
    cmp ebx esi | jl @No_Match ; test exit condition

    xor eax eax         ; clear EAX for following partial writes
    mov al B$ecx+esi
    cmp al B$ecx+edi | je @KeepScan    ; cmp characters in ESI / EDI
    add esi D$eax*4+shift_table
jmp @Exit_Text

@KeepScan: P9:
    dec ecx
    xor eax eax         ; clear EAX for following partial writes

@Cmp_Loop: A2:
    mov al B$ecx+esi
    cmp al B$ecx+edi | jne @Calc_Suffix_Shift ; cmp characters in ESI / EDI
    dec ecx | jns @Cmp_Loop  ; if not equal, get next shift

@Match: ; match on fall through
    sub esi D@lpSource  ; sub source from ESI
    mov eax esi         ; put length in eax
jmp @Cleanup

@No_Match: C2:
    mov eax 0-1

@Cleanup:

EndP


____________________________________________________________________________________________________








TITLE Strings

;;
  TITLE where to save the RosAsm Messages Strings having a possible counter-part
  in the national languages Files.
  
  In the RosAsmFiles Folder, if a 'RosAsmStrings.xx' is found out, the substitution
  is done by 'OpenStringsFile'.
  
  Organization:
  
  * The default English Strings are declared the usual way.
  
  * The 'StringsTable' contains 2 dWords Records. Typically:
  
      STRING1 ErrorMessageTitlePtr: ErrorMessageTitle
      
      Where: 
      - 'STRING1' is the StringID (Number 1)
      - 'ErrorMessageTitlePtr' is the Substitution Label
      - 'ErrorMessageTitle' is the Pointer to the default English Strings, in the Source
      
   The StringIDs purpose is to introduce some flexibility in the management:
   
   1) The ID as found in the 'RosAsmStrings.xx' File and in the 'StringsTable'
   are simple Ordinal, and must be given, in both cases, in the Ordinal order.
   
   2) Some Strings and IDs may be missing.
   
   * How it works:
   
   When a National Language String is found out, it is loaded for once, in Memory.
   
   CRLF are zeroed and the Strings are parsed:
   
   When some '$$$$25' is found, the 'OpenStringsFile' translates '25' into Binary
   and searches the matching Record ID, inside the 'StringsTable'. Once this
   Record is pointed out, the String Pointer is overwritten, in order to point
   to the char after '$$$$25 '.
   
   In failures cases, an error Message is send.
   
   __________________________
   For the RosAsm volunteers:
   
   When you develop your TITLE, do not use this. Simply write your own errors
   Messages inside your TITLE, the usual way.
   
   Then, only when you think that your developements are more or less in a fixed
   state, considering the errors Messages, Implement the Internationalization.
   
   How to:
   
   1) Move your Strings here, after the existing ones.
   2) If there is not enough 'STRINGXXX' available, add the ones you need.
   3) Extend the 'StringsTable' to hold your own Strings.
   4) In your Source, replace all the concerned 'StringSymbol' by 'D$StringSymbolPtr'.
   2) Take a copy of 'RosAsmStrings.en', and append your Strings.
   
   For the Equates Ordinals, you can go to the next 1000 Boundary, so that each
   Volunteer (or purpose) will have a set of 1000 Strings IDs reserved, in order
   to ease a little bit the future Maintainance. For example, the Equal Pre-Parser
   Strings could begin at 2000, the Debugger Strings at 3000, and so on... I plan
   to use 1000 for the RosAsm Menu, and some other things.
   
   Once done, send me, all at once: Your TITLE, The Strings TITLE and the
   'RosAsmStrings.en' File.
;;



[ErrorMessageTitle: ' error', 0]  ; Error,  OutOnError

; List of error messages:

 [EmptyString: B$   '                                                        ', 0
  MissingFile:      'File not found', 0
  BusyFile:         'Unable to open: System mangling destination file', 0
  CreationFile:     'Error when trying writting file', 0
  OpenFile:         'File To open Not found', 0
  MissFile:         'File not found', 0
  NoReadFile:       'Unable to read file', 0
  MissEquateVal:    'Missing equate value', 0
  EquateLabel:      'An Equate name can not be followed by a Colon Char', 0
  TextEquate:       'Missing ">" Char at the end of Text Equate', 0
  MacPara:          'Bad parameters number in macro evocation', 0
  MissingParameter: 'Bad parameters number in Macro evocation', 0
  MacNumber:        'Bad # construction', 0
  BadMacroDirection: 'Always ">", for Macros Multiple Parameters. Never "<"', 0
  TooBigX:          '#x limit is 9', 0
  TooMuchParam:     'Too much Parameters found when unfolding', 0
  InfiniteLoop:     'An infinite loop has been generated when unfolding this macro', 0
  MacrosOverFlow:   'More than 4000 Bytes outputed at once, when unfolding this Macro!!!', 0
  UnknownData:      'Unknown data type', 0
  UnknownSize:      'Unknown Size marker', 0
  Mem3D:            '64 Bits (Q$...) mem size expected for all 3D Now instructions' 0
  NewHmem:          '"H$" now reserved for futher developement. Use "R$" or "F$" instead', 0
  PrefetchMem:      'Prefetch/w/0/1/2/NTA syntax: > PrefetchXXX B$Address' 0
  DsizeForLab:      'D$ needed for Labels data', 0
  Unknown:          'Unknown text structure. May be internal error', 0
  BadSeparator:     'Unexpected separator', 0
  BinType:          'Invalid binary number', 0
  HexType:          'Invalid Hexa number', 0
  DezimalType:      'Invalid decimal number', 0
  OutOfRange:       'Out of range value', 0
  DefEquate:        'This equate or macro symbol is already used', 0
  DefReEquate:      'This equate symbole is not in use', 0
  TooMuchLabels:    'More than 2 labels is this expression', 0
  BadLabel:         'Bad character in Label name', 0
  LabelDup:         'Duplicate label definition', 0
  SymbolDup:        'Duplicate symbol definition', 0
  OrphanColon:      'Orphan Colon sign encounted', 0
  LocalDefLabel:    'Local label not allowed in data definition', 0
  NoLocalCall:      'You cannot call for a Local Label', 0
  NotAnOpcode:      'Unknown mnemonic', 0
  OverByte:         'Value out of byte range', 0
  OverWord:         'Value out of word range', 0
  OverDword:        'Value out of Dword range', 0
  LenSize:          'Leading Len can only be dWord or word', 0
  BadReal:          'Bad real number declaration' 0
  OrphanPrefix:     'An instruction prefix can not stand alone', 0
  DoubleSOP:        'Double Segment override not allowed', 0
  NotSegment:       'Unresolved segment override', 0
  Parameter:        'Unvalid parameter', 0
  Double0:          'Only one "&0" automatic Label per Macro', 0
  MissingSign:      'Need of equal or colon sign', 0
  MissingSeparator: 'Missing space at end of a Data String declaration', 0
  BadMacroLoop:     'Bad placement of Loop instruction in Macro', 0
  TooMuch:          'Too much operands found', 0
  DBsize:           'Hexa Octets values expected for Code Bytes', 0
  LockError:        'No Lock Prefix with this instruction', 0
  LockMemError:     'Lock: One Member must be Memory', 0
  MissingOperand:   'Missing operand', 0
  NotEnough:        'Missing operand', 0
  MemMem:           'Expressions are allowed for only one memory adressing parameter', 0
  Parenthesis:      'Unpaired parenthesis', 0
  ParaMacro:        'Bad ParaMacro', 0
  MacroVariableIndice: 'Macros Variables are from "&1" to "&100" (Decimal)', 0
  NestedMacroVariable: 'Imbricated declaration of Macro Variable', 0
  MarkerBefore:     '$ize Marker wanted before Real Expression', 0
  MarkerAfter:      '$ize Marker wanted after Real Expression', 0
  ExpressionMember: 'Immediate only in Expressions', 0
  NoDataLocalLabel: 'No Local Labels in Data: They are reserved for Code', 0
  RealNotation:     'Real Expression: only +-*/ Operators, no nested Parenthesis', 0
  ExpressionSign:   'Bad operator in Expression', 0
  DataLoopNumber:   'For Huge Data Declaration, use Virtual (?) Data or call for VirtualAlloc', 0
  SmallDataLoop:    'What do you mean with "repeat less than 2 times???..."', 0
  BadLoop:          'Loop with no previous Data Declaration', 0
  VDataLoopNumber:  'For huge Virtual Tables: VirtualAlloc or [Configuration]/[Bad Habits]', 0
  TooMuchExpression: 'Expression number too big in result or before multiplication', 0
  ExpressionNOT:    'NOT must be at leading Pos of an Expression member', 0
  ExpressionSHR:    'SHR / SHL Parameter over Byte size in Expression', 0
  OpenText:         'Unpaired text delimiter', 0
  Orphanbracket:    'Unpaired square bracket', 0
  UnexpectedCRLF:   'Unexpected CR LF after Bracket', 0
  MissingSeparator1:'Missing Separator before Text Delimiter', 0
  MissingSeparator2:'Missing Separator after Text Delimiter', 0
  UnPairedNestedBrackets: 'Unpaired {Nested} Brackets', 0
  NestedBrackets:   "'{}' chars are reserved for nested Declarations", 0
  PseudoLocal:      "Pseudo local '@Label' before any Plain Label declaration", 0
  DoubleSIB:        'Only one Index and one base allowed in SIB', 0
  EspIndex:         'ESP can t be use as an index in SIB', 0
  Expression:       'Impossible effective address parameter', 0
  ScaleValue:       'Scale possible values are 2, 4, 8 and extensions to 3, 5, 9', 0
  ESPsib:           'ESP can t be used as index register', 0
  DoubleIndex:      'Only one index allowed in expression', 0
  DoubleLabel:      'Double label or unknown error', 0
  UnknownParameter: 'unable to resolve this parameter', 0
  EnterStack:       'Enter Stack size goes up to 0FFFC and must be 4 Bytes aligned', 0
  EnterLevel:       'Enter level goes from 0 to 31', 0
  LeaInstead:       'To retrieve Label+imm Adress, use LEA. Exemple: " > lea ebx D$Label+8" ', 0
  MixType:          'these two parameters types not allowed together', 0
  MissType:         'UnFitting sizes of operands', 0
  OperandsTypes:    'Failure of Analyze in operands types for this mnemonic', 0
  BadAlign:         'The Alignment must be a power of two between 4 and 0100', 0
  OperandSize:      'Bad operand size', 0
  FPregNotAssumed:  "Can't guess Registers for this FP Instruction", 0
  LeaTypes:         '"lea reg, mem" only. For "lea eax imm", use "mov eax imm"', 0
  LeaSize:          'There is no Byte form for lea', 0
  EndingImm:        'Third imm parameter wanted', 0
  Xmarker:          'X$Memory parameter wanted', 0
  OverFlow:         'Over flow of immediate number', 0
  UnknownSymbol:    'This symbolic name does not fit with any label', 0
  WhatIsThis:       'What is this?', 0
  UnAble:           'RosAsm has been unable to assemble this instruction', 0
  NotYetSign:       'Only + - signs allowed here, or see [Expressions] in Help', 0
  NotYetMnemo:      'Sorry, this mnemonic is not yet implemented. Information needed', 0
  ;ShortDis:         'Need of long dis., >> or << (never on LOOP)', 0
        TooLongOf:  '     Byte(s) out of range', 0
  ShortDis:         "Need of long dis., >> or << (never on LOOP)
#1 #2 out of range", 0

  NoPlainLabelForLoop: 'Local Up Short Label is required for LOOP', 0
  LongLoop:         'Local Up Short Label is required for LOOP', 0
  NoPlainLabelForJECX: 'Short Local Label (up or down) is required for JCXZ / JECXZ', 0
  LongDis:          'Only Short displacement allowed with this mnemonic', 0
  NForbiden:        'N symbol not allowed here. Use L', 0
  MixedLen:         "You can't mix 'head LEN' and 'Free LEN'", 0
  BadLoopNumber:    'decimal value expected for data declaration loop number', 0
  VirtualData:      'Bad Virtual Data', 0
  NestedLoop:       'Sorry, data loop can not be nested', 0
  NeedByteSize:     'Byte size required', 0
  OnlyAcc:          'Only accumulator with this instruction', 0
  TxtTooMuch:       'Text parameter exceeding 4 bytes', 0
  GPregister:       'A register must be general purpose', 0
  VERRword:         'VERR/VERW / LTR parameter must be 16 bits register or memory', 0
  WishEreg:         'Memory adressing expects full 32 bit general purpose registers', 0
  BadApi:           "Api calls form is: call 'Module.Function'", 0
  NoApi:            'No Api call found in source', 0
  DllNotFound:      'Internal error: user called DLL not found at compile time', 0
  ApiNotFound:      'Internal error: user called API not found at compile time', 0
  NoLocal:          'Local Label not allowed here', 0
  NoEntry:          'Entry Point not found (should be "Main:" if not modified)', 0
  BadFPUcond:       'FPU available conditions: B, E, BE, NA, U, NB, AE, NE, NZ, NBE, A, NU', 0
  ST0wished:        'One of these two reg must be ST0', 0
  STwished:         'Only ST0, ST1, ...., ST7  regs with this mnemonic', 0
  FADDPreg0:        'FADDP second Reg must be ST0', 0
  FSUBPreg0:        'FSUBP second Reg must be ST0', 0
  BadFpChar:        'Unexpected Char inside Float Expression', 0
  NoAdressee:       'Internal: Unknown adressee', 0
  BadMemRelease:    'Internal: Fail of Memory release', 0
  NotPE:            'No source in this PE. Disassemble it?', 0
  NotPeExe:         'This is not a PE File', 0
  BadWinEqu:        'Unknown Win Equates name', 0
  IdTooSmall:       'ID base number must be between 1 and 65535', 0
  IdTooBig:         'ID base number must be between 1 and 65535', 0 ;;;1000 and 32000', 0
  BadLibName:       'Wrong Module name', 0
  DoubleFunction:   'Impossible: Same Function in 2 DLLs       ', 0
  BadFunctionName:  'Wrong api name', 0
  BadOrdinal:       'Wrong api Ordinal', 0
  NoAapi:           'No ending "A" here', 0
  MacVarOverFlow:   'Too long Data (or infinite storage loop) for Macro "&x="', 0
  MacVarNumber:     'Too high Number for a Macro Variable', 0
  MissingApiA:      'Ending "A" (or "W") wanted', 0
  BadPreParse:     'PREPARSE is for: Alternates, Equal', 0
  MissingCLASSname: 'Missing Class Name', 0
  NoParentClass:    'Parent CLASS not found when unfolding Inheritance', 0
  SizeOfResource:   'Too Big Resources. Big Images or Sounds should be left in Files', 0
  NumerAsSymbol:    'A Number cannot be a Symbolic Name', 0
  UnexpectedReg:    'Unexpected Register or too short Symbol', 0
  TextKilling:      'This Macro removes a Text Delimiter', 0
  NestedMacroLoop:  'Split your Macro: No Nested Loop here', 0
  ConditionalLoop:  'A Macro Loop cannot be inside a Conditional "If"', 0
  UnpairedMacroIf:  'Unpaired If in the Macro Declaration', 0
  BadCMIndice:      'Bad Conditional Indice (should be from 1 to 99)', 0
  BadConditionalmacro: 'Bad Conditional macro', 0
  ZZZZreserved: 'Symbols in "ZZZZZZZZ" form are reserved for Automatic Labels', 0
  ]


;;
  This Table is for holding the national languages, if some 'RosAsmStrings.xx' is
  found out, at launch time. 
;;

[StringsTable:
 1 ErrorMessageTitlePtr: ErrorMessageTitle
 2 EmptyStringPtr: EmptyString
 3 MissingFilePtr: MissingFile
 4 BusyFilePtr: BusyFile
 5 CreationFilePtr: CreationFile
 6 OpenFilePtr: OpenFile
 7 MissFilePtr: MissFile
 8 NoReadFilePtr: NoReadFile
 9 MissEquateValPtr: MissEquateVal
 10 EquateLabelPtr: EquateLabel
 11 TextEquatePtr: TextEquate
 12 MacParaPtr: MacPara
 13 MacNumberPtr: MacNumber
 14 BadMacroDirectionPtr: BadMacroDirection
 15 TooBigXPtr: TooBigX
 16 TooMuchParamPtr: TooMuchParam
 17 InfiniteLoopPtr: InfiniteLoop
 18 MacrosOverFlowPtr: MacrosOverFlow
 19 UnknownDataPtr: UnknownData
 20 UnknownSizePtr: UnknownSize
 21 Mem3DPtr: Mem3D
 22 NewHmemPtr: NewHmem
 23 PrefetchMemPtr: PrefetchMem
 24 DsizeForLabPtr: DsizeForLab
 25 UnknownPtr: Unknown
 26 BadSeparatorPtr: BadSeparator
 27 BinTypePtr: BinType
 28 HexTypePtr: HexType
 29 DezimalTypePtr: DezimalType
 30 OutOfRangePtr: OutOfRange
 31 DefEquatePtr: DefEquate
 32 DefReEquatePtr: DefReEquate
 33 TooMuchLabelsPtr: TooMuchLabels
 34 BadLabelPtr: BadLabel
 35 LabelDupPtr: LabelDup
 36 SymbolDupPtr: SymbolDup
 37 OrphanColonPtr: OrphanColon
 38 LocalDefLabelPtr: LocalDefLabel
 39 NoLocalCallPtr: NoLocalCall
 40 NotAnOpcodePtr: NotAnOpcode
 41 OverBytePtr: OverByte
 42 OverWordPtr: OverWord
 43 OverDwordPtr: OverDword
 44 LenSizePtr: LenSize
 45 BadRealPtr: BadReal
 46 OrphanPrefixPtr: OrphanPrefix
 47 DoubleSOPPtr: DoubleSOP
 48 NotSegmentPtr: NotSegment
 49 ParameterPtr: Parameter
 50 MissingParameterPtr: MissingParameter
 51 Double0Ptr: Double0
 52 MissingSignPtr: MissingSign
 53 MissingSeparatorPtr: MissingSeparator
 54 BadMacroLoopPtr: BadMacroLoop
 55 TooMuchPtr: TooMuch
 56 DBsizePtr: DBsize
 57 LockErrorPtr: LockError
 58 LockMemErrorPtr: LockMemError
 59 MissingOperandPtr: MissingOperand
 60 NotEnoughPtr: NotEnough
 61 MemMemPtr: MemMem
 62 ParenthesisPtr: Parenthesis
 63 ParaMacroPtr: ParaMacro
 64 MacroVariableIndicePtr: MacroVariableIndice
 65 NestedMacroVariablePtr: NestedMacroVariable
 66 MarkerBeforePtr: MarkerBefore
 67 MarkerAfterPtr: MarkerAfter
 68 ExpressionMemberPtr: ExpressionMember
 69 NoDataLocalLabelPtr:  NoDataLocalLabel
 70 RealNotationPtr: RealNotation
 71 ExpressionSignPtr: ExpressionSign
 72 DataLoopNumberPtr: DataLoopNumber
 73 SmallDataLoopPtr: SmallDataLoop
 74 BadLoopPtr: BadLoop
 75 VDataLoopNumberPtr: VDataLoopNumber
 76 TooMuchExpressionPtr: TooMuchExpression
 77 ExpressionNOTPtr: ExpressionNOT
 78 ExpressionSHRPtr: ExpressionSHR
 79 OpenTextPtr: OpenText
 80 OrphanBracketPtr: OrphanBracket
 81 UnexpectedCRLFPtr: UnexpectedCRLF
 82 MissingSeparator1Ptr: MissingSeparator1
 83 MissingSeparator2Ptr: MissingSeparator2
 84 UnPairedNestedBracketsPtr: UnPairedNestedBrackets
 85 NestedBracketsPtr: NestedBrackets
 86 PseudoLocalPtr: PseudoLocal
 87 DoubleSIBPtr: DoubleSIB
 88 EspIndexPtr: EspIndex
 89 ExpressionPtr: Expression
 90 ScaleValuePtr: ScaleValue
 91 ESPsibPtr: ESPsib
 92 DoubleIndexPtr: DoubleIndex
 93 DoubleLabelPtr: DoubleLabel
 94 UnknownParameterPtr: UnknownParameter
 95 EnterStackPtr: EnterStackPtr
 96 EnterLevelPtr: EnterLevel
 97 LeaInsteadPtr: LeaInstead
 98 MixTypePtr: MixType
 99 MissTypePtr: MissType
 100 OperandsTypesPtr: OperandsTypes
 101 BadAlignPtr: BadAlign
 102 OperandSizePtr: OperandSize
 103 FPregNotAssumedPtr: FPregNotAssumed
 104 LeaTypesPtr: LeaTypes
 105 LeaSizePtr: LeaSize
 106 EndingImmPtr: EndingImm
 107 XmarkerPtr: Xmarker
 108 OverFlowPtr: OverFlow
 109 UnknownSymbolPtr: UnknownSymbol
 110 WhatIsThisPtr: WhatIsThis
 111 UnAblePtr: UnAble
 112 NotYetSignPtr: NotYetSign
 113 NotYetMnemoPtr: NotYetMnemo
 114 ShortDisPtr: ShortDis
 115 TooLongOfPtr: TooLongOf
 116 NoPlainLabelForLoopPtr: NoPlainLabelForLoop
 117 LongLoopPtr: LongLoop
 118 NoPlainLabelForJECXPtr: NoPlainLabelForJECX
 119 LongDisPtr: LongDis
 120 NForbidenPtr: NForbiden
 121 MixedLenPtr: MixedLen
 122 BadLoopNumberPtr: BadLoopNumber
 123 VirtualDataPtr: VirtualData
 124 NestedLoopPtr: NestedLoop
 125 NeedByteSizePtr: NeedByteSize
 126 OnlyAccPtr: OnlyAcc
 127 TxtTooMuchPtr: TxtTooMuch
 128 GPregisterPtr: GPregister
 129 VERRwordPtr: VERRword
 130 WishEregPtr: WishEreg
 131 BadApiPtr: BadApi
 132 NoApiPtr: NoApi
 133 DllNotFoundPtr: DllNotFound
 134 ApiNotFoundPtr: ApiNotFound
 135 NoLocalPtr: NoLocal
 136 NoEntryPtr: NoEntry
 137 BadFPUcondPtr: BadFPUcond
 138 ST0wishedPtr: ST0wished
 139 STwishedPtr: STwished
 140 FADDPreg0Ptr: FADDPreg0
 141 FSUBPreg0Ptr: FSUBPreg0
 142 BadFpCharPtr: BadFpChar
 143 NoAdresseePtr: NoAdressee
 144 BadMemReleasePtr: BadMemRelease
 145 NotPEPtr: NotPE
 146 NotPeExePtr: NotPeExe
 147 BadWinEquPtr: BadWinEqu
 148 IdTooSmallPtr: IdTooSmall
 149 IdTooBigPtr: IdTooBig
 150 BadLibNamePtr: BadLibName
 151 DoubleFunctionPtr: DoubleFunction
 152 BadFunctionNamePtr: BadFunctionName
 153 BadOrdinalPtr: BadOrdinal
 154 NoAapiPtr: NoAapi
 155 MacVarOverFlowPtr: MacVarOverFlow
 156 MacVarNumberPtr: MacVarNumber
 157 MissingApiAPtr: MissingApiA
 158 BadPreParsePtr: BadPreParsePtr
 159 MissingCLASSnamePtr: MissingCLASSname
 160 NoParentClassPtr: NoParentClass
 161 SizeOfResourcePtr: SizeOfResource
 162 NumerAsSymbolPtr: NumerAsSymbol
 163 UnexpectedRegPtr: UnexpectedReg

 164 TextKillingPtr: TextKilling
 165 NestedMacroLoopPtr: NestedMacroLoop
 166 UnpairedMacroIfPtr: UnpairedMacroIf
 167 ConditionalLoopPtr: ConditionalLoop
 168 BadCMIndicePtr: BadCMIndice
 169 BadConditionalmacroPtr: BadConditionalmacro
____________________________________________________________________________________________
; Debugger strings

 3000 StrRunPtr: StrRun
 3001 StrStepIntoPtr: StrStepInto
 3002 StrStepOverPtr: StrStepOver
 3003 StrStepPtr: StrStep
 3004 StrReturnPtr: StrReturn
 3005 StrRetPtr: StrRet
 3006 StrTerminatePtr: StrTerminate
 3007 StrPausePtr: StrPause
 3008 StrHoldOnBpPtr: StrHoldOnBp
 3009 StrInstStepPtr: StrInstStep
 3010 StrSrcStepPtr: StrSrcStep
 3011 StrShowAllPtr: StrShowAll
 3012 StrFontPtr: StrFont
 3013 StrCPUInfoPtr: StrCPUInfo
 3014 StrFPUStatusPtr: StrFPUStatus
 3015 StrShowCodeAtPtr: StrShowCodeAt
 3016 StrAboutPtr: StrAbout
 3017 StrDbgHelpPtr: StrDbgHelp

 3040 StrDataFmtPtr: StrDataFmt

 3050 StrContinuePtr: StrContinue
 3051 StrBreakPtr: StrBreak
 3052 StrSettingsPtr: StrSettings
 3053 StrInformationPtr: StrInformation
 3054 StrHelpPtr: StrHelp

 3060 StrShowInMemInspPtr: StrShowInMemInsp
 3061 StrShowPInMemInspPtr: StrShowPInMemInsp
 3062 StrShowDeclPtr: StrShowDecl
 3063 StrBreakOnWPtr: StrBreakOnW
 3064 StrBreakOnRWPtr: StrBreakOnRW
 3065 StrSortByNamePtr: StrSortByName
 3066 StrSortByAddrPtr: StrSortByAddr

 3080 StrShowInvokePtr: StrShowInvoke
 3081 StrShowAllCallsPtr: StrShowAllCalls
 3082 StrHideModCallsPtr: StrHideModCalls
 3083 StrHideIMCallsPtr: StrHideIMCalls
 3084 StrShowLocalsPtr: StrShowLocals

 3100 FmtHexPtr:      FmtHex
 3101 FmtUDecPtr:     FmtUDec
 3102 FmtSDecPtr:     FmtSDec
 3103 FmtBinaryPtr:   FmtBinary
 3104 FmtFloatPtr:    FmtFloat
 3105 FmtPUBPtr:      FmtPUB
 3106 FmtPSBPtr:      FmtPSB
 3107 FmtPUWPtr:      FmtPUW
 3108 FmtPSWPtr:      FmtPSW
 3109 FmtPUDPtr:      FmtPUD
 3110 FmtPSDPtr:      FmtPSD
 3111 FmtPUQPtr:      FmtPUQ
 3112 FmtPSQPtr:      FmtPSQ
 3113 FmtPFPtr:       FmtPF
 3114 FmtPDPtr:       FmtPD
 3115 FmtHexAnsiPtr:  FmtHexAnsi
 3116 FmtHexDWPtr:    FmtHexDW
 3117 FmtHexWPtr:     FmtHexW
 3118 FmtFloatsPtr:   FmtFloats
 3119 FmtDoublesPtr:  FmtDoubles
 3120 FmtAsciiPtr:    FmtAscii
 3121 FmtHexCookedPtr: FmtHexCooked

 StringsTableEnd: StringsTablePointer: StringsTable]

[StringNamePath: ? #&MAXPATH]
[RosAsmStringsFileHandle: ? RosAsmStringsFilelenght: ? RosAsmStringsMemory: ?]
[StringsLanguage: '.en', 0 RosAsmStringsFiles: 'RosAsmStrings', 0]
[UnicodeStrings: &FALSE]

; Tag Dialog 4800

SetNationalLanguage:
    .If eax = 10
        mov D$StringsLanguage '.en'
    .Else_If eax = 11
        mov D$StringsLanguage '.fr'
    .Else_If eax = 12
        mov D$StringsLanguage '.br'
    .Else_If eax = 13
        mov D$StringsLanguage '.sp'
    .Else_If eax = 14
        mov D$StringsLanguage '.zh'
    .Else_If eax = 15
        mov D$StringsLanguage '.it'
    .Else_If eax = 16
        mov D$StringsLanguage '.de'
    .Else_If eax = 17
        mov D$StringsLanguage '.no'
    .Else_If eax = 18
        mov D$StringsLanguage '.ca'
    .Else_If eax = 201
        call GetNationalFont
    .End_If

    call OpenStringsFile
ret


OpenStringsFile:
    call GetRosAsmFilesPath
    mov esi RosAsmFilesPath, edi StringNamePath
    While B$esi <> 0 | movsb | End_While

    mov D$edi 'Lang', B$edi+4 '\' | add edi 5
    mov esi RosAsmStringsFiles
    While B$esi <> 0 | movsb | End_While | move D$edi D$StringsLanguage

    call 'KERNEL32.FindFirstFileA' StringNamePath, FindFile

    ...If eax <> &INVALID_HANDLE_VALUE

        call 'KERNEL32.FindClose' eax

        call 'KERNEL32.CreateFileA' StringNamePath, &GENERIC_READ,
                                    &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL, 0
        mov D$RosAsmStringsFileHandle eax

        call 'KERNEL32.GetFileSize' eax, 0 | mov D$RosAsmStringsFilelenght eax
        add eax 10

        VirtualAlloc RosAsmStringsMemory eax | add D$RosAsmStringsMemory 10

        call 'KERNEL32.ReadFile' D$RosAsmStringsFileHandle, D$RosAsmStringsMemory,
                                 D$RosAsmStringsFilelenght, NumberOfReadBytes, 0

        call 'KERNEL32.CloseHandle' D$RosAsmStringsFileHandle

        mov esi D$RosAsmStringsMemory
        mov edx esi | add edx D$RosAsmStringsFilelenght

        If D$StringsLanguage = '.zh'
            mov B$UnicodeStrings &TRUE | call ParseNationalUstrings
        Else
            mov B$UnicodeStrings &FALSE | call ParseNationalStrings
        End_If

    ...Else
        mov D$StringsLanguage '.en'

    ...End_If
ret


ParseNationalUstrings:
    .While esi < edx
        ..If W$esi < '1'
            ;
        ..Else_If W$esi <= '9'
            cmp W$esi-8 '$' | jne L9>>
                cmp W$esi-6 '$' | jne L9>>
                    cmp W$esi-4 '$' | jne L9>>
                        cmp W$esi-2 '$' | jne L9>>

          ; Write the Strings Zero End Marks upon the '$':
            mov W$esi-12 0

          ; Compute the ID Number
L0:         mov ecx 0

L0:         lodsw
            cmp ax ' ' | je L7>
            cmp ax '9' | ja L5>
            cmp ax '0' | jb L5>
                sub ax '0'
                lea ecx D$ecx+ecx*4
                lea ecx D$eax+ecx*2
            jmp L0<

L5:         call 'USER32.MessageBoxA', 0, {'Bad National Strings File. English assumed', 0},
                                          {'National Strings', 0}, 0
            mov D$StringsLanguage '.en'
            ret

          ; esi point to the beginning of a String, and ecx is the ID Number.
          ; Write it into the 'StringsTable'. Allow missing Ordinal IDs:
L7:         mov ebx D$StringsTablePointer

            While D$ebx > ecx
                sub ebx 8 | On ebx < StringsTable, jmp L5<
            End_While
            While D$ebx < ecx
                add ebx 8 | On ebx >= StringsTableEnd, jmp L5<
            End_While
            mov D$ebx+4 esi | mov D$StringsTablePointer ebx
        ..End_If

L9:     add esi 2
    .End_While

  ; Write the Strings Zero End Marks for the last Strings:
    mov W$esi 0
ret


ParseNationalStrings:
    .While esi < edx
        ..If B$esi < '1'
            ;
        ..Else_If B$esi <= '9'
            cmp D$esi-4 '$$$$' | jne L9>>

          ; Write the Strings Zero End Marks:
            mov B$esi-6 0

          ; Compute the ID Number
L0:         mov ecx 0

L0:         lodsb
            cmp al ' ' | je L7>
            cmp al '9' | ja L5>
            cmp al '0' | jb L5>
                sub al '0'
                lea ecx D$ecx+ecx*4
                lea ecx D$eax+ecx*2
            jmp L0<

L5:         call 'USER32.MessageBoxA', 0, {'Bad National Strings File. English assumed', 0},
                                          {'National Strings', 0}, 0
            mov D$StringsLanguage '.en'
            ret

          ; esi point to the beginning of a String, and ecx is the ID Number.
          ; Write it into the 'StringsTable'. Allow missing Ordinal IDs:
L7:         mov ebx D$StringsTablePointer

            While D$ebx > ecx
                sub ebx 8 | On ebx < StringsTable, jmp L5<
            End_While
            While D$ebx < ecx
                add ebx 8 | On ebx >= StringsTableEnd, jmp L5<
            End_While
            mov D$ebx+4 esi | mov D$StringsTablePointer ebx
        ..End_If

L9:     inc esi
    .End_While

  ; Write the Strings Zero End Marks for the last Strings:

    mov B$esi 0
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  Custom Strings Routines:
  
  See usage downward, at 'TestCustomString'.
;;
[CustomError
 If D$StringsLanguage = '.zh'
    call CopyUnicodeToTrash1 #1
    BuildTheUnicodeMessage #2>L
 Else
    call CopyToTrash1 #1
    BuildTheAsciiMessage #2>L
 End_If]

[BuildTheUnicodeMessage | call CustomUnicodeStringProc #1, #2, #3 | #+3
    mov esi D$Trash1Ptr, edi TrashString
    While W$esi > 0 | movsw | End_While | movsb]

[BuildTheAsciiMessage | call CustomStringProc #1, #2, #3 | #+3
    mov esi D$Trash1Ptr, edi TrashString
    While B$esi > 0 | movsb | End_While | movsw]

[CustomString | call CopyToTrash1 #1 | CustomString2 #2>L]

[CustomString2 | call CustomStringProc #1, #2, #3 | #+3
 mov esi D$Trash1Ptr, edi TrashString
 While B$esi > 0 | movsb | End_While | movsb]

Proc CopyToTrash1:
    Argument @Source
    Uses esi

        mov esi D@Source, edi Trash1
        While B$esi <> 0 | movsb | End_While | movsb

        mov D$Trash1Ptr Trash1, D$Trash2Ptr Trash2
EndP


Proc CopyUnicodeToTrash1:
    Argument @Source
    Uses esi

        mov esi D@Source, edi Trash1
        While W$esi <> 0 | movsw | End_While | movsw

        mov D$Trash1Ptr Trash1, D$Trash2Ptr Trash2
EndP


Proc CustomStringProc:
    Arguments @Xn, @Type, @Arg
    Uses esi, edi, ebx

        mov esi D$Trash1Ptr, edi D$Trash2Ptr

        mov eax D@Xn
        While W$esi <> ax
            movsb | On B$esi = 0, ExitP
        End_While

        If D@Type = 'Int'
            mov eax D@Arg | call WriteEax

        Else_If D@Type = 'Str'
            push esi
                mov esi D@Arg
                While B$esi <> 0 | movsb | End_While
            pop esi

        End_If

        add esi 2 | While B$esi <> 0 | movsb | End_While | mov B$edi 0

       Exchange D$Trash1Ptr D$Trash2Ptr
EndP


Proc CustomUnicodeStringProc:
    Arguments @Xn, @Type, @Arg
    Uses esi, edi, ebx

        mov esi D$Trash1Ptr, edi D$Trash2Ptr
;;
   '@Xn' stands is the '#1', '#2', '#3' thingies. We make it Unicode, that is,
   for example:
   
   '#1' (031, 023) >>> 0, 031, 0, 023 >>> '#', 0, '1', 0
;;
        mov eax D@Xn | movzx ebx ah
        shl ebx 16 | or eax ebx  | and eax 0FF00FF

        While D$esi <> eax
            movsw | On W$esi = 0, ExitP
        End_While

        If D@Type = 'Int'
            mov eax D@Arg | call WriteEaxUnicode

        Else_If D@Type = 'Str'
            push esi
                mov esi D@Arg
                While B$esi <> 0 | movsb | mov B$edi 0 | inc edi | End_While
            pop esi

        End_If

        add esi 4 | While W$esi <> 0 | movsw | End_While | mov W$edi 0

        Exchange D$Trash1Ptr D$Trash2Ptr
EndP


WriteEaxUnicode:
    mov ebx eax

L3: If ebx = 0
        mov W$edi '0' | add edi 2 | ret
    End_If

    push 0-1

L0: mov eax ebx | shr ebx 4 | and eax 0F

    mov al B$HexaTable+eax
    push eax
    cmp ebx 0 | ja L0<
    mov W$edi '0' | add edi 2
L0: pop eax | cmp eax 0-1 | je L9>
    mov B$edi al | inc edi | mov B$edi 0 | inc edi | jmp L0<
L9: ret


[TestString: 'Access violation at address #1. Tried to read from #2 address', 0]

TestCustomString:
    CustomString TestString, '#1', 'Int', 0112233,
                             '#2', 'Str', {'a very weird', 0}

    Showme TrashString
ret









































TITLE Mem
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
                                   Memory Management.
____________________________________________________________________________________________
____________________________________________________________________________________________
 Managements for VirtualAlloc:

 VirtualAlloc Reserves Memory Chunks with a 01_0000 alignement and Commit Chunks with
 a 0_1000 alignement. These Memory Manager Routines purpose is to completely secure
 and simplify the calls for Mems and to save all these rooms spoiled by the 01_0000
 alignement. To simplify things, let us call 'Mother Chunks' the 01_0000 aligned ones
 (Reservations default) and 'Child Chunks' the 0_1000 aligned ones (Commition default).

 For developements, an Equate 'GUARDPAGE' may be set to 0_1000. This ensure that, in
 case of overflowing writes to a given Memory Chunk, even if 2 chunks are contiguous,
 Win will effectively raise a exception. With this Guard set, the Manager may eat up
 to 8 times less Mem (when dealing with small Chunks). Without Guard (GUARDPAGE set to
 zero), the eaten Mem may be up to 16 times smaller. (This 'GUARDPAGE' has no relation
 with what Win Doc calls so).

 When small Chunks are wanted, the Memory Manager reuse free Chunks that may be found
 inside already Reserved 01_0000 aligned Chunks.

 All Chunks are recorded in a 'MemTable'. Each Record is:

 Pointer / Size / Mother_Pointer

 Where 'Pointer' is the Pointer to the Committed Chunks, Size is the Size of the
 Committed Chunks eventually added of the GUARDPAGE (0_1000 or 0), and 'Mother_Pointer'
 is a Pointer to the 01_0000 aligned Chunk to which may belong the Committed Chunk. Even
 the Mother Chunk get this last Value pointing to itself. This last Value is used to
 control if and when, the Memory manager may effectively Release the whole Chunk. Until
 all of the nested and Mother Chunks are not Decommitted, the Memory Manager do not
 Release the whole Mother Chunk, but proper releasing will be done, whatever order of
 the 'VirtualFree' calls, even if the 'VirtualFree D$MotherChunk' is called first and
 the 'VirtualFree D$ThirdChildChunk' last.

 If more than expected (here 'MEMTABLESIZE') Chunks are required, this is to say,
 if too much Mems are not released (in other words, if i have forgotten to release
 some Allocated Memories), i should also see an error Message ('NoMoreMem') if the
 'MemTable' is overflowed. Added to this i set a Menu Item in [Tools] to see how
 much Memory Chunks are activated at any time ('ViewRosAsmMems'). This does not tell
 how much Mem is used. This only tells how much Chunks are recorded in the 'MemTable',
 no matter what Size.

 When releasing, if the Pointer value is corrupted, we should also see an error
 Message for 'MemInternalAlert'.


 All this is much heavy, but gives full control on any Management problem, and the
 calls remain completly simple:

 > VirtualAlloc Pointer
 > VirtualFree D$Pointer

 When back from 'VirtualAlloc' Macro, the 'Pointer' holds the new Memory Pointer.
 'VirtualFree' reset 'D$Pointer' Value to zero. If called a second time (with a
 zeroed pointer, the Macro aborts without any error Message, because, in some
 complex cases organisation of the source flow, it may become difficult to know if,
 at some given time, the Mem has already be freed or not. This save from having to
 write:

 > On D$Pointer > 0, VirtualFree D$Pointer

 This is the only one case for which the Manager does not send an error Message
 in case of bad call from the Application. If a wrong Address is sent to VirtualFree,
 for example an Application Table Address instead of a Pointer content, the proper
 error Message is sent.


 A 'LastMemRecord' is also managed in order to save from scaning wide 'MenTable' for
 nop, as we cannot rely on zeroed Records to know if we have finished scaning.
;;
____________________________________________________________________________________________

[GUARDPAGE 01000]   ; Comment / unComment these 2 Equates for
;[GUARDPAGE 0]      ; having / not having hand made Guard Pages.

; MemTable is 3 dWords per record: pointer-to-Mem / MemChunkSize / Mother Pointer// ...
[MEMTABLESIZE ((MAXRESOURCE+50)*3) ] ; room for 50 Chunks + Resources Chunks.
[MEMRECORD (4*3)]

[MemTable: ? #MEMTABLESIZE] [MemTableEnd: ?    MemChunSize: ?]

[MemAlert: 'Memory attribution failure', 0
 MemInternalAlert: 'Error inside RosAsm Memory Management', 0
 MemAlertText: "   RosAsm is going to close. Shut down some Aplications and re-run      " 0]

[LastMemRecord: ?    TempoMemPointer: ?]    ; used when no named Pointer is used by
                                            ; caller (cases of Tables of Memory Pointers,
                                            ; for example).
[VirtAllocOverFlowString: 'VirtualAlloc Buffer overflowed', 0]
[VirtAllocFailureString:  'VirtualAlloc Function failure' 0]

VirtAlloc:                                  ; In: ebx = Pointer, edx = size
    push ebx
        mov edi MemTable                    ; Search an empty Record.
        While D$edi > 0
            add edi MEMRECORD
          ; This Alert can only happend if i completly corrupt a Mem Pointer Value
          ; so that it is no more founded in the 'MemTable':
            If edi = MemTableEnd
                call 'USER32.MessageBoxA' D$hwnd, MemAlertText, MemAlert,
                                          &MB_SYSTEMMODAL__&MB_ICONSTOP
                call ViewRosAsmMems
                ShowMe VirtAllocOverFlowString
                call 'KERNEL32.ExitProcess' 0
            End_If
        End_While

      ; The 'add eax GUARDPAGE' is to reserve a never Committed Page (allow Win
      ; error if i overflow write to a Buffer):
        mov eax edx | Align_On PAGESIZE eax | add eax GUARDPAGE
        mov D$MemChunSize eax, D$edi+4 eax

      ; VirtualAlloc Reserves by 01_0000 Octets Block (16 Pages). So, as any previous
      ; Committed Block can not be smaller than 0_1000 or 0_2000 Octets (1 Page + 1 Page
      ; for 'Guard', the not used remaining space of any reservation cannot be bigger
      ; than 01_0000-(PAGESIZE+GUARDPAGE) (0_E000 or 0F000).
        If D$MemChunSize <= (01_0000-(PAGESIZE+GUARDPAGE))
            push edi | call IsThereSomeRoom | pop edi   ; >>> eax= 0 or Pointer.
        Else                                            ; eax= Pointer >>> ebx = MotherPtr.

            mov eax 0
        End_If

        If eax = 0
            push edi
                mov eax D$MemChunSize | Align_On 010_000 eax
                call 'KERNEL32.VirtualAlloc' &NULL, eax, &MEM_RESERVE, &PAGE_READWRITE
                On eax = 0, hexprint D$MemChunSize
                ;hexprint eax
            pop edi
            mov D$edi eax, D$edi+8 eax      ; D$edi+8 = Pointer
        Else
            mov D$edi eax, D$edi+8 ebx      ; D$edi+8 = MotherPointer ('IsThereSomeRoom' ebx)
        End_If

        On edi > D$LastMemRecord, mov D$LastMemRecord edi
        mov ecx D$MemChunSize | sub ecx GUARDPAGE
      ;  push eax, ecx                      ; For my Tests
        call 'KERNEL32.VirtualAlloc' eax, ecx, &MEM_COMMIT, &PAGE_READWRITE
      ;  pop ecx, ebx                       ; For my Tests
        If eax = 0
      ;      hexprint ecx | hexprint ebx    ; For my Tests
            call 'USER32.MessageBoxA' D$hwnd, MemInternalAlert, MemAlert,
                                         &MB_SYSTEMMODAL__&MB_ICONSTOP
            call ViewRosAsmMems
            ShowMe VirtAllocFailureString

            call 'KERNEL32.ExitProcess' 0
        End_If
    pop ebx
    mov D$ebx eax                           ; Return Pointer Value to caller.
ret

[VirtualAlloc | mov ebx #1, edx #2 | call VirtAlloc | #+2]
; Evocation: VirtualAlloc Pointer, Size
____________________________________________________________________________________________

[VirtFreeOverFlowString: 'VirtualFree Buffer overflow' 0]

VirtFree:       ; eax = D$Pointer
    pushad

  ; I sometimes increase the original Pointer to set a security top margin allowing
  ; computation begining by 'If D$esi-4 = ...", for example >>> Restore origin:
    and eax 0_FFFF_F000                 ; (Chunks are always Page-aligned).

    mov esi MemTable
    While D$esi <> eax
        add esi MEMRECORD
        If esi = MemTableEnd
            call 'USER32.MessageBoxA' D$hwnd, MemInternalAlert, MemInternalAlert,
                                      &MB_SYSTEMMODAL__&MB_ICONSTOP
            call ViewRosAsmMems
            ShowMe VirtFreeOverFlowString
            call 'KERNEL32.ExitProcess' 0
        End_If
    End_While

    push esi
        mov ecx D$esi+4 | sub ecx GUARDPAGE
        call 'KERNEL32.VirtualFree' D$esi, ecx, &MEM_DECOMMIT
    pop esi

  ; Now, we can Release the whole Memory Block only if no other Chunk is Committed.
  ; If so, no other Block whith the same origin (Third dWord of records) can be
  ; found in the 'MemTable':
    mov ebx D$esi+8, ecx 0
    mov D$esi 0, D$esi+4 0, D$esi+8 0       ; Clear the record, anyway.
    push esi
        mov esi MemTable
        While esi <= D$LastMemRecord
            If D$esi+8 = ebx
                inc ecx
            End_If
            add esi MEMRECORD
        End_While
        On ecx = 0, call 'KERNEL32.VirtualFree' ebx, &NULL, &MEM_RELEASE
    pop esi
    On esi = D$LastMemRecord, sub D$LastMemRecord MEMRECORD
L9: popad
ret

[VirtualFree | cmp #1 0 | je V9> | mov eax #1
                    call VirtFree
               mov #1 0 | V9: | #+1]

; Evocation: VirtualFree D$Pointer (>>> D$Pointer = 0, when back).
____________________________________________________________________________________________

; Search is some empty room is available inside already Reserved Chunks. 'D$MemChunSize'
; holds the size of the wanted Block + one Page:

IsThereSomeRoom:
    mov esi MemTable
    .While esi <= D$LastMemRecord
        ..If D$esi > 0
            mov eax D$esi | add eax D$esi+4
            mov ebx eax | Align_On 01_0000 eax | sub eax ebx

          ; eax = supposed free room in this 01_0000 aligned reserved Chunk or sub-Chunk.
            .If eax >= D$MemChunSize
                mov eax D$esi | add eax D$esi+4
                mov ebx eax | add ebx D$MemChunSize
              ; eax = Start // ebx = End of possible free Block.
                call IsThisRoomFree
                If eax = &TRUE
                    mov eax D$esi, ebx D$esi+8 | add eax D$esi+4 | jmp L9>>
                End_If
            .End_If
        ..End_If
        add esi MEMRECORD
    .End_While
    mov eax 0
L9: ret

;;
 in: eax = candidate Block start // ebx = end. Both must be outside of any other
 Declared Block. This is to say, down here,  (ebx <= ecx) OR (eax >= edx). Example:
 eax > edx >>> good:

 .....................................(eax)XXXXXXXXXXXXXXXXXXXXX(ebx)......
 ....(ecx)XXXXXXXXXXXXXXXXXXXXX(edx).......................................
;;
IsThisRoomFree:
    push esi
        mov esi MemTable
        While esi <= D$LastMemRecord
            mov ecx D$esi, edx ecx | add edx D$esi+4
            If ebx <= ecx
                ; OK
            Else_If eax >= edx
                ; OK
            Else
                mov eax &FALSE | jmp L9>
            End_If
            add esi MEMRECORD
        End_While
        mov eax &TRUE
L9: pop esi
ret

____________________________________________________________________________________________

____________________________________________________________________________________________
____________________________________________________________________________________________



[ExtendMemory | call NewMemory #1, #2, #3 | #+3]

; AddMemory MemoryPointer, ActualSizePointer, SizeToAdd

Proc NewMemory:
    Arguments @Pointer, @SizePointer, @Added
    [@NewPointer: ?]

        pushad
          ; Compute the new Size:
            mov ecx D@SizePointer, ecx D$ecx | add ecx D@Added

            VirtualAlloc @NewPointer, ecx

          ; Copy from Old to new memory:
            push ecx
                mov esi D@Pointer, esi D$esi, edi eax, ecx D@SizePointer, ecx D$ecx
                shr ecx 2 | rep movsd
            pop ecx

          ; Adjust the new Size:
            mov ebx D@SizePointer, D$ebx ecx

          ; Replace the old Memory Pointer by the new one:
            mov ebx D@Pointer | Exchange D$ebx D@NewPointer

            VirtualFree D@NewPointer
        popad
EndP










TITLE MemView

; Maintainer: Guga june the 29th of 2006

____________________________________________________________________________________________

; Routine for: Menu > Tools > 'View RosAs mMems':

[MemTableView: D$ ? #(MEMTABLESIZE*5)]
[MemTableViewEnd: ?]
[MemTableViewTitle: 'VirtualAlloc Mems actually commited to RosAsm:', 0]


[IDD_VIEWMEMWARNINGMSG 10000]
[IDC_DISPLAYMEMWARNING 10]
[IDC_DISPLAYMEMDATA 20]
[IDC_DUMPMEM 30]
[IDC_SAVEMEMREPORT 35]
[IDC_DISPLAYMEMINFO 40]

ViewRosAsmMems:
    call 'USER32.DialogBoxParamA' D$hinstance, IDD_VIEWMEMWARNINGMSG, &NULL,
                                  MemViewWarning, &NULL
ret


[DumpMemWarnMsg: B$ 0 #256]

_______________________________________________________

; Tag Dialog 10000

Proc MemViewWarning:
    Arguments @Adressee, @Message, @wParam, @lParam

     pushad


    ..If D@Message = &WM_INITDIALOG
       ; Get the handle of the Static Image:
        call 'USER32.GetDlgItem' D@Adressee IDC_LIBWARNING_SHOWICON
        mov D$LibWarningStaticImage eax
        call 'USER32.LoadBitmapA' D$hInstance, IDB_LIBWARNING_BITMAP
        mov D$LibScanhIcon eax

        call 'USER32.SendMessageA' D$LibWarningStaticImage, &STM_SETIMAGE,
                                   &IMAGE_BITMAP, D$LibScanhIcon
        call 'USER32.SendDlgItemMessageA' D@Adressee, IDC_DISPLAYMEMWARNING,
                                          &WM_SETTEXT, 0, DumpMemWarnMsg
        call 'USER32.SendDlgItemMessageA' D@Adressee IDC_DISPLAYMEMWARNING,
                                          &WM_GETTEXT, 0, DumpMemWarnMsg

        call DisplayMemData D@Adressee
        call DisplayMemInfo D@Adressee

    ..Else_If D@Message = &WM_CLOSE
        call ClearBuffer MemTableView (MEMTABLESIZE*5*4)
       ; call ClearBuffer MemTable (MEMTABLESIZE*4)
        call ClearBuffer DumpMemWarnMsg 256
        call 'User32.EndDialog' D@Adressee &NULL

    ..Else_If D@Message = &WM_COMMAND
        .If D@wParam = &IDOK
            call ClearBuffer MemTableView (MEMTABLESIZE*5*4)
          ;  call ClearBuffer MemTable (MEMTABLESIZE*4)
            call ClearBuffer DumpMemWarnMsg 256
            call 'User32.EndDialog' D@Adressee &NULL
        .Else_If D@wParam = IDC_DUMPMEM
            mov eax MemTableEnd
            sub eax MemTable
            call DumpMemory D@Adressee, MemTable, eax
        .Else_If D@wParam = IDC_SAVEMEMREPORT
            call SaveMemoryReport D@Adressee, MemTableView, D$MemReportInfoSize
        .End_If

    ..Else

       popad | mov eax &FALSE | ExitP

    ..End_If

    popad
    mov eax &TRUE
EndP

_______________________________________________________

[DumpMemFileTitle: B$ 'Save Dumped memory as...', 0]
[MemSaveFileFilter: B$ 'RosAsm Memory File (*.mem)', 0  '*.mem', 0 0]
[MemSaveFilter: "Report" 0 #(&MAX_PATH-6)]

[DumpMem:
 DumpMem.lStructSize: D$ Len
 DumpMem.hwndOwner: D$ 0
 DumpMem.hInstance: D$ 0
 DumpMem.lpstrFilter: D$ MemSaveFileFilter
 DumpMem.lpstrCustomFilter: D$ CustomLibFileFilter
 DumpMem.nMaxCustFilter: D$ 260
 DumpMem.nFilterIndex: D$ 1
 DumpMem.lpstrFile: D$ MemSaveFilter
 DumpMem.nMaxFile: D$ 260
 DumpMem.lpstrFileTitle: D$ ChoosenLibFile
 DumpMem.nMaxFileTitle: D$ 260
 DumpMem.lpstrInitialDir: D$ 0
 DumpMem.lpstrTitle: D$ DumpMemFileTitle
 DumpMem.Flags: D$ &OFN_EXPLORER__&OFN_FILEMUSTEXIST__&OFN_LONGNAMES__&OFN_PATHMUSTEXIST
 DumpMem.nFileOffset: W$ 0
 DumpMem.nFileExtension: W$ 0
 DumpMem.lpstrDefExt: D$ 0
 DumpMem.lCustData: D$ 0
 DumpMem.lpfnHook: D$ 0
 DumpMem.lpTemplateName: D$ 0]

Proc DumpMemory:
    Arguments @Adressee, @File, @FileSize
    pushad

    mov D$ChoosenLibFile 0
    move D$DumpMem.lpstrFile MemSaveFilter
    move D$DumpMem.hwndOwner D@Adressee
    move D$DumpMem.hInstance D$hInstance
    move D$DumpMem.lpstrFilter MemSaveFileFilter
    move D$DumpMem.lpstrTitle DumpMemFileTitle
    call 'Comdlg32.GetSaveFileNameA' DumpMem

    ..If eax <> 0
        .If D$ChoosenLibFile <> 0
            call ForceExtension MemSaveFilter, '.mem'
            call SaveLibFile, D@File, D@FileSize, MemSaveFilter
        .End_If
    ..End_If
    popad

EndP
_______________________________________________________

[MemSaveReportFilter: B$ 'RosAsm Memory Report (*.txt)', 0  '*.txt', 0 0]
[SaveReportMemFileTitle: B$ 'Save Report memory as...', 0]

Proc SaveMemoryReport:
    Arguments @Adressee, @File, @FileSize
    pushad

    mov D$ChoosenLibFile 0
    move D$DumpMem.lpstrFile MemSaveFilter
    move D$DumpMem.hwndOwner D@Adressee
    move D$DumpMem.hInstance D$hInstance
    move D$DumpMem.lpstrFilter MemSaveReportFilter
    move D$DumpMem.lpstrTitle SaveReportMemFileTitle
    call 'Comdlg32.GetSaveFileNameA' DumpMem

    ..If eax <> 0
        .If D$ChoosenLibFile <> 0
            call ForceExtension MemSaveFilter, '.txt'
            call SaveLibFile, D@File, D@FileSize, MemSaveFilter
        .End_If
    ..End_If
    popad

EndP
_______________________________________________________

Proc DisplayMemData:
    Arguments @Adressee

    pushad

    mov esi MemTable, edi MemTableView, edx 0

    While esi < MemTableEnd
        mov eax D$esi
        .If eax > 0
            If eax = D$esi+8
                mov B$edi 'X' ; Main committed with Reserved Blocks.
            Else
                mov B$edi 'x' ; Child (small and nested) committed Blocks.
            End_If
        .Else
            mov B$edi '_'
        .End_If
        add esi MEMRECORD | inc edi | inc edx

        ; Spaces and CR/LF each 4 / 8 / 32 Chunk.
        mov eax edx | and eax 00_11
        If eax = 0
            mov al ' ' | stosb
        End_If
            mov eax edx | and eax 00_111
        If eax = 0
            mov eax '    ' | stosd
        End_If
            mov eax edx | and eax 00_11111
        If eax = 0
            mov al CR | stosb | mov al LF | stosb
        End_If
    End_While
    mov B$edi 0
    call 'USER32.SetDlgItemTextA' D@Adressee, IDC_DISPLAYMEMDATA, MemTableView

    popad
EndP
_______________________________________________________

; Calculate the maximum size of the report....
;0000000: 023 069 066 06E  - Ascii: # i f n
;0403ED4: 073 079 073 02F  - Ascii: s y s /  Size = 43
;0403ED4: 073 079 073 02F  - Not used - Ascii: s y s /  Size = 54
;0403ED4: 073 079 073 02F  - Commited - Ascii: s y s /  Size = 54
;0403ED4: 073 079 073 02F  - Reserved - Ascii: s y s /  Size = 54
; MEMTABLESIZE = 10650 dwords = 42600 bytes. The displacement is from 12 to 12 dwords
; So we have 887,5 * 4 (10650/12*4). 3550 Lines.
; On Our case this means:
; Size*3550 = 54*3550 = 191700 bytes
; Multiplication Factor = 191700/42600 = 4,5. So, for safety we do
; [MemTableView: D$ ? #(MEMTABLESIZE*5)] = 213000 Bytes

[MemTitleDisplay1: B$ "_______________________________________________________________________________
MemTable Start Address: ", 0]

[MemTitleDisplay2: B$ "
The data is displayed as:
Address; 4 Bytes sequence, Memory Type, Ascii representation.

Address: The address of the MemTable where the data is found. Each address
         is related to the 1st 12 Bytes, but only the 1st four ones are displayed
         here to preserve space.

Bytes:   1st four bytes of the memory that are displayed.

Memory Type: Specifies what is happening with the memory. It can be:
             Commited: 'x' chars. Child (small and nested) committed Blocks.
             Reserved: 'X' chars. Main committed with Reserved Blocks.
             Not Used:  Zeroed Bytes.

Ascii: Ascii representation of the 1st four bytes.
_______________________________________________________________________________
", 0]

[MemReportInfoSize: D$ 0]

Proc DisplayMemInfo:
    Arguments @Adressee

    pushad

    mov esi MemTable, edi MemTableView, edx 0

    push esi | zCopy MemTitleDisplay1 | pop esi
    mov eax esi
    call Writeeax
    push esi | zCopy MemTitleDisplay2 | pop esi

    .While esi < MemTableEnd
        mov eax D$esi
        call WriteMemTableOffset esi
        call WriteMemDwordChunck eax
        .If eax > 0
            If eax = D$esi+8
                push esi | zCopy {" - Commited - Ascii: ", 0} | pop esi
            Else
                push esi | zCopy {" - Reserved - Ascii: ", 0} | pop esi
            End_If
        .Else
            push esi | zCopy {" - Not used - Ascii: ", 0} | pop esi
        .End_If
        call WriteMemAsciiChunck eax
        add esi MEMRECORD
        mov W$edi 0A0D | add edi 2

    .End_While
    mov B$edi 0
    mov eax edi
    sub eax MemTableView
    mov D$MemReportInfoSize eax
    call 'USER32.SetDlgItemTextA' D@Adressee, IDC_DISPLAYMEMINFO, MemTableView

    popad
EndP
________________________________________________________________________________________________________

Proc WriteMemTableOffset:
    Arguments @Value
    Uses eax, ebx

    mov eax D@Value
    call Writeeax
    mov W$edi ': ' | add edi 2

EndP

________________________________________________________________________________________________________

Proc WriteMemDwordChunck:
    Arguments @Value
    Uses eax, esi, edx, ecx, ebx

    lea esi D@Value
    mov ecx 4
    xor eax eax
    mov edx 0
    Do
        ; Arrange the Strings to the chars be displayed on the same row one below each other.
        ; Ex.:  09 055   0 014
        ;      055  01 0FF 075

        If B$esi = 0
            mov W$edi '  ' | add edi 2
        Else_If B$esi <= 0F
            mov B$edi ' ' | inc edi
        End_If

        lodsb
        call writeeax
        xor eax eax
        mov B$edi ' ' | inc edi
        dec ecx
    Loop_Until ecx = 0

EndP
________________________________________________________________________________________________________

Proc WriteMemAsciiChunck:
    Arguments @Value
    Uses eax, esi, edx, ecx, ebx

    lea esi D@Value
    mov ecx 4
    xor eax eax
    mov edx 0

    .Do
        lodsb
        If eax < ' '
            mov B$edi '.' | inc edi
        Else_If eax >= 127
            mov B$edi '.' | inc edi
        Else
            stosb
        End_If

        xor eax eax
        mov B$edi ' ' | inc edi
        dec ecx
    .Loop_Until ecx = 0

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________
































TITLE Local


;;
  Small Memory Chunks Management. Do not use: Under developement.
  
  
  The 'LocalChunksTable' is a Table of dWords. Each dWord is a Pointer to a
  Table of "Follow-Up Tables", one for each Size of Local Chunk:
  
  32, 64, 128, 256, 512
  020, 040, 080, 0100, 0200
  
  The Memories pointed by the 'LocalChunksTable' dWOrds are extended when
  required and never released. They are extended by 01000 steps (01000, 02000,
  03000).
  
  A Table of Follow-Up Tables is a flow of "Follow-Up Table" of one given Size.
  
  On single "Follow-Up Table" looks like this:
  
  [030510000, xxxxxxxx, xxxxxxxx, xxxxxxxx, xxxxxxxx]
  
  ... where 030510000 is the "Mother Chunk" of Memory, given by VirtualAlloc,
  and where the "xxxxxxxx"s are dWords, where each Bit represents one small
  Chunk inside the Mother Chunk.
  
  All of the "Follow-Up Tables" have 4 Follow-Up Bits Masks dWords, and the Size
  of the Mother Chunk is proportional to the size of the small Chunks. This is
  to say:
   __________            _______________
   Chunk Size            Mother Mem Size
  
   32 Bytes * 128 >>> 4096 Bytes (01000)
   64       * 128 >>>             02000
   128      * 128 >>>             04000
   256      * 128 >>>             08000
   512      * 128 >>>            010000
  1024      * 128 >>>            020000
  2048      * 128 >>>            040000
  
  So, all Mother-Memories hold 128 Local Chunks.
  
  The Mother Chunks (like the 'LocalChunksTable' Memories) are never released
  (no call to VirtualFree). In cases of call to 'LocalFree', the concerned Bit
  is set to zero.
  
  To fasten the LocalFree operation, each Local Chunk begins with two dWOrds:
  The Address, inside one of the "Follow-Up Tables", the bit position of the
  Local Chunk and the indice of chunk size(this last two in the last dword)
  
  So, when calling, for example, a call for a 100 Bytes Local Chunk, the real
  size will be 108 Bytes. Then, the 'LocalAlloc' Routine will align that Value
  on the closer possible Size, that is, 128 Bytes, and return a to the caller
  a Pointer to the third dWord on that boundary.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[LocalChunksTable:      ? ? ? ? ? ? ?]
[LocalChunksTablePages: ? ? ? ? ? ? ?]
[FreeLocalChunkPointer: ? ? ? ? ? ? ?]
; First Allocation for a Table of 'Follow-Up Tables':

Proc CreateLocalChunksTable:
    Argument @Indice

        VirtualAlloc NewMem, PAGESIZE
        mov eax D@Indice, ebx D$NewMem
        mov D$LocalChunksTable+eax*4 ebx
        mov D$LocalChunksTablePages+eax*4 1
EndP

;;
  This Memory extension will only be run, in case when the size of the 'LocalChunksTable'
  dWOrds Memory is found too small. It will never be mad smaller during one execution.
  This is only to make the whole thing entirely dynamic, and should only be executed
  once per need. So, the stupid Copy is enough, as there is no speed problem, here.
;;
[NewMem: ?]

Proc ExtendLocalChunksTable:
    Argument @Indice
    Uses ecx, edx

        mov edx D@Indice

        inc D$LocalChunksTablePages+edx*4
        mov ecx D$LocalChunksTablePages+edx*4 | shl ecx 12 ; 001000000000000 = 01000
        push ecx edx
            VirtualAlloc NewMem ecx
        pop edx ecx
        sub ecx PAGESIZE
        shr ecx 2 | mov esi D$LocalChunksTable+edx*4, edi D$NewMem | rep movsd
        VirtualFree D$LocalChunksTable+edx*4
        move D$FreeLocalChunkPointer+edx*4 D$NewMem | add D$FreeLocalChunkPointer+edx*4  PAGESIZE
        move D$LocalChunksTable+edx*4 D$NewMem

EndP
____________________________________________________________________________________________

[LocalAlloc | call LocAlloc #1, #2 | #+2]
; Evocation: LocalAlloc Pointer, Size

Proc LocAlloc:
    Arguments @Pointer, @Size
    Local @FollowUpTableSize, @Indice
    Uses esi, edx, ecx, ebx

      ; Room for Address and Bit Map:
        add D@Size 8

        If D@Size < 32
            mov D@Size 32
        Else_If D@Size > (PAGESIZE/2)
            VirtualAlloc D@Pointer, D@Size
            mov D$eax eax, D$eax+4 0-1 | add eax 8
            mov ecx D@Pointer | mov D$ecx eax
            ExitP
        End_If

        mov eax D@Size | bsr ecx eax | mov eax 1 | shl eax cl
        If D@Size > eax
            shl eax 1 | inc ecx
        End_If
        sub ecx 5
      ; ecx = Zero Based Indice for the 'LocalChunksTable' // eax = Aligned Chunk Size
        shl eax 7 ; * 128
        mov D@Indice ecx, D@FollowUpTableSize eax

        If D$FreeLocalChunkPointer+ecx*4 = 0
            mov esi D$LocalChunksTable+ecx*4
        Else
            mov esi D$FreeLocalChunkPointer+ecx*4
        End_If

        If esi = 0
            push ecx
                call CreateLocalChunksTable ecx
            pop ecx
            mov esi D$LocalChunksTable+ecx*4
        End_If

      ; esi = Follow-Up Tables List
L0:     lodsd | mov ebx eax
        .If ebx = 0
            push esi ecx
              ; Allocation of a Mother Chunk. (Size * 128)
                VirtualAlloc NewMem, D@FollowUpTableSize
            pop ecx esi
            mov D$esi-4 eax, ebx eax

            ; If at the end of the 'LocalChunksTable', extend it for next allocations:
            mov edx D$LocalChunksTablePages+ecx*4 | shl edx 12 | add edx D$LocalChunksTable+ecx*4
            sub edx 40
            If esi >= edx
                sub esi D$LocalChunksTable+ecx*4
                push esi
                    call ExtendLocalChunksTable ecx
                pop edx
                mov esi D$LocalChunksTable+ecx*4 | add esi edx
            End_If
        .End_If

        If D$esi <> 0-1
            mov eax D$esi, edx 0
        Else_If D$esi+4 <> 0-1
            mov eax D$esi+4, edx 4
        Else_If D$esi+8 <> 0-1
            mov eax D$esi+8, edx 8
        Else_If D$esi+12 <> 0-1
            mov eax D$esi+12, edx 12
        Else
            add esi (4*4)
            mov D$FreeLocalChunkPointer+ecx*4 esi
            jmp L0<<
        End_If

        not eax | bsf ecx eax
      ; edx = number of bytes of the shift (0,4,8 or 12 bytes after the first DWord of the Follow-Up table)
      ; ecx = Bit position in the (edx/4) DWord of the Follow-Up Table. (0 to 31)
      ; Bit Map is updated
        bts D$esi+edx ecx

        lea eax D$ecx+edx*8
      ; eax = bit position in the Follow-Up Table (0 to 127)

      ; Keep (esi+edx), eax and D@Indice value for LocFree
        add esi edx | mov edx eax | shl edx 16 | mov dx W@Indice
      ; Multiplication by ChunkSize
        mov ecx D@Indice | add ecx 5 | shl eax cl | add eax ebx
      ; eax is now the Address of the new Local Chunk (example: 030510000+(BitIndice*ChunkSize)
        mov D$eax esi, D$eax+4 edx | add eax 8
        mov ecx D@Pointer | mov D$ecx eax
EndP
____________________________________________________________________________________________

[LocalFree  | cmp #1 0 | je V9> | mov eax #1
                    call LocFree
               mov #1 0 | V9: | #+1]
; Evocation: LocalFree D$Pointer (>>> D$Pointer = 0, when back).

LocFree: ; eax = Pointer to mem
    push ebx ecx edx
        If D$eax-4 <> 0-1
            movzx ecx W$eax-4 | movzx edx W$eax-2 | mov ebx D$eax-8
            ; ebx: Follow-Up Table address of this chunk (points to the proper DWord in the table)
            ; ecx: Zero Based Indice for the 'LocalChunksTable'
            ; edx: bit position in the Follow-Up Table (0 to 127)
            ; Bit Map is updated
            and edx 31 | btr D$ebx edx
            ; we compute the byte in which this bit is from edx
            movzx edx W$eax-2 | and edx 0-32 | shr edx 3 | sub ebx edx | sub ebx 4
            mov D$FreeLocalChunkPointer+ecx*4 ebx
        Else
            mov eax D$eax-8 | call VirtFree
        End_If
    pop edx ecx ebx
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[LocalTest1: ? LocalTest2: ? LocalTest3: ?]

; 'LocalChunksTable'
[MemAddrList: ? #5000 ]
TestLocals:
    call 'USER32.MessageBoxA' 0, {'Ready to test Local Engine', 0}, {'TestLocals', 0}, 0

    LocalAlloc LocalTest1, 25
    LocalAlloc LocalTest2, 250
    mov ecx 5000
    .While ecx > 0
        LocalAlloc LocalTest3, 504
        mov D$MemAddrList+ecx*4 eax
        mov ebx 0
        While ebx < 504
            mov B$eax cl
            inc eax
            inc ebx
        End_While
        dec ecx
    .End_While

   ; int3

    LocalFree D$LocalTest2
   ; int3
    mov ecx 5000
    While ecx > 0
        push ecx | LocalFree D$MemAddrList+ecx*4 | pop ecx
        dec ecx
    End_While
   ; int3
    LocalFree D$LocalTest1
   ; int3

    call 'USER32.MessageBoxA' 0, {'test done', 0}, {'TestLocals', 0}, 0
ret


[TestLocalTableHandle: ?   TestLocalSize: ?]

; Tag Dialog 15

Proc TestLocalTables:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND                  ; User action
        ..If D@wParam = &IDCANCEL                   ; User clicks on upper right [X]
            VirtualFree D$AllocTestMem
            mov D$FileTypeChoice 0-1
            call 'User32.EndDialog' D@Adressee 0

        ..Else_If D@wParam = &IDOK
            VirtualFree D$AllocTestMem
            call 'User32.EndDialog' D@Adressee 0

      ;  ..Else_If D@wParam = &IDHELP
      ;      call Help B_U_AsmName, DisassemblerHelp, ...

        ..Else
            movzx eax W@wParam
            If ax = 10
                mov D$TestLocalSize 32
            Else_If ax = 11
                mov D$TestLocalSize 64
            Else_If ax = 12
                mov D$TestLocalSize 128

            Else_If ax = 200 ; Allocate
                call AllocationTest

            Else_If ax = 201 ; Release
                call ReleaseTest
            End_If

        ..End_If

    ...Else_If D@Message = &WM_INITDIALOG          ; Win ready to build the Dialog
       call 'USER32.CheckDlgButton' D@Adressee, 10, &TRUE
       mov D$TestLocalSize 32
       move D$TestLocalTableHandle D@Adressee
       VirtualAlloc AllocTestMem, 010000

  ;  ...Else_If D$Message = &WM_CTLCOLOREDIT        ; Win ready to paint the Dialog
          ;      ; Control of output

    ...Else
        popad | mov eax &FALSE | ExitP               ; Non processed

    ...End_If

    popad | mov eax &TRUE                           ; Processed
EndP


[AllocTestMem: ?]

AllocationTest:
    call 'USER32.GetDlgItemInt' D$TestLocalTableHandle, 20, 0, 0

    If eax = 0
        call 'USER32.MessageBoxA' 0, {'Set some number of Chunks (1 to 1024)', 0},
                                     {'LocalTests', 0}, &MB_SYSTEMMODAL
    Else_If eax > (01000/4)
        call 'USER32.MessageBoxA' 0, {'Set some number of Chunks (1 to 1024)', 0},
                                     {'LocalTests', 0}, &MB_SYSTEMMODAL
    Else
        mov ecx eax

L0:     push ecx
            LocalAlloc LocalTest1, D$TestLocalSize
            mov edi D$AllocTestMem
            While D$edi <> 0 | add edi 4 | End_While
            move D$edi D$LocalTest1
        pop ecx | loop L0<
    End_If

    call ShowLocalTest
ret


ReleaseTest:

ret


[ShowLocalTestMem: ?]

ShowLocalTest: ;ret ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    VirtualAlloc ShowLocalTestMem 0FFFF

        mov edi D$ShowLocalTestMem

        mov esi D$LocalChunksTable | On esi = 0, jmp L1>

        If D$esi = 0
L1:         mov D$edi 'None', W$edi+4 CRLF | add edi 6
        Else
            While D$esi <> 0
                lodsd | call WriteEax | mov W$edi ': ' | add edi 2
                lodsd | call WriteEax | mov W$edi ', ' | add edi 2
                lodsd | call WriteEax | mov W$edi ', ' | add edi 2
                lodsd | call WriteEax | mov W$edi ', ' | add edi 2
                lodsd | call WriteEax | mov D$edi ' // ' | add edi 4
            End_While
            mov W$edi CRLF | add edi 2
        End_If

        mov esi D$LocalChunksTable+4 | On esi = 0, jmp L1>

        If D$esi = 0
L1:         mov D$edi 'None', W$edi+4 CRLF | add edi 6
        Else
            While D$esi <> 0
                lodsd | call WriteEax | mov W$edi ': ' | add edi 2
                lodsd | call WriteEax | mov W$edi ', ' | add edi 2
                lodsd | call WriteEax | mov D$edi ' // ' | add edi 4
            End_While
            mov W$edi CRLF | add edi 2
        End_If

        mov esi D$LocalChunksTable+8 | On esi = 0, jmp L1>

        If D$esi = 0
L1:         mov D$edi 'None', W$edi+4 CRLF | add edi 6
        Else
            While D$esi <> 0
                lodsd | call WriteEax | mov W$edi ': ' | add edi 2
                lodsd | call WriteEax | mov D$edi ' // ' | add edi 4
            End_While
            mov W$edi CRLF | add edi 2
        End_If

        mov esi D$LocalChunksTable+12 | On esi = 0, jmp L1>

        If D$esi = 0
L1:         mov D$edi 'None', W$edi+4 CRLF | add edi 6
        Else
            While D$esi <> 0
                lodsd | call WriteEax | mov W$edi ': ' | add edi 2
                lodsd | call WriteEax | mov D$edi ' // ' | add edi 4
            End_While
            mov W$edi CRLF | add edi 2
        End_If

    call 'USER32.SendDlgItemMessageA' D$TestLocalTableHandle, 100,
                                      &WM_SETTEXT, 0, D$ShowLocalTestMem

    VirtualFree D$ShowLocalTestMem
ret













































TITLE AsmMain

; 'AsmMain' 'EncodeLines'
 _________________________________________________________________________________________
 _________________________________________________________________________________________

; After Macros and Equates replacement, CodeSourceA is of no more use.
; we reused it for CodeList storage table:

; EvilBro: This next routine is evil, because it uses D$SourceLen. I will have to do something
; about that in the future.

ReuseSourceAForCodeList:
    mov eax D$CodeSourceA | and eax 0_FFFF_FF00  ; kill +010 margin in CodeSources tables
    mov D$CodeList eax, edi eax                ; (needed for alignement)
    mov ecx D$AsmTablesLength
    shr ecx 2
    push eax, edi                              ; recent add > clean it all for ease of
        mov eax 0 | rep stosd                  ; read of Hexa PEs.
    pop edi, eax
    add eax 0400 | mov D$CodeListPtr eax       ; clear header and
ret

;;
 This table is for the Debug routine. Each intruction got a pointer. When searching
 for some instruction in the Debugger, we read EIP reg and compare with this List
 in order to point to the source instruction (after error search with the computed
 number of instruction). This List is not closed after compilation.
;;

[IpTable: ?    IpTablePtr: ?    CodeOrigine: ?]

InitDebugIpTable:
    VirtualFree D$IpTable

    mov eax D$SourceLen | add eax 01000 | VirtualAlloc IpTable eax
    move D$IpTablePtr D$IpTable, D$CodeOrigine D$CodeListPtr
ret


[Time1: ?  Time2: ?  Time3: ?  Time4: ?  Time5: ?  Time6: ?  Time7: ?]

[Alert: 'Something is overwriting the Resources Pointers!!!', 0
 AlertTitle: 'Internal Error!!!...', 0]

AlertResources:
    call 'USER32.MessageBoxA' D$hwnd, Alert, AlertTitle, &MB_OK
ret


AsmMain:
    mov D$EntryPointLabel 'MAIN', B$EntryPointLabel+4 0, D$EntryPointLabelLen 4

    On D$ResourcePointersSecurity <> 0, jmp AlertResources

    mov B$CompileErrorHappend &TRUE | On B$SourceReady = &FALSE, ret
    mov eax D$CodeSource | On D$SourceEnd = eax, ret

    call 'KERNEL32.GetTickCount' | mov D$Time1 eax

    mov eax esp, D$OldStackPointer eax         ; To restore stack on error jump

    mov D$NoMeanLabel 'ZZZZ', D$NoMeanLabel+4 'ZZZZ'
    mov B$CompileErrorHappend &FALSE, B$FirstPass &True

    If B$WeAreUnfolding = &FALSE
        call InitProgressBar | call InitProgressSteps 16, 1
    End_If

  ; Ensure Source is ended with at least one CR/LF for ease of line analyzes:
    mov eax D$SourceEnd | mov bx W$eax-2
    cmp bx 0A0D | je L1>
        cmp bx 0D0A | je L1>
            mov W$eax 0A0D | add D$SourceEnd 2 | add D$SourceLen 2

L1: call GetAsmTables                       ; files ready for read in 'CodeSource'
    call ClearUserStubMainData
    call BarProgress

; -------------------------------  First Parsers Jobs ---------------------------------

    If B$ProfilerFlag = &TRUE
        call InjectedCopyToCodeSourceA, D$CodeSource, D$SourceLen
    Else
        call NewCopyToCodeSourceA D$CodeSource, D$SourceLen
    End_If

    call CoolParsers
;jmp L7>>
    call NewCountStatements | call BarProgress

    call NewPrepareExport

    call HotParsers

    call NoAutomaticLabel

;jmp L7>>
;;
 The Source is no longer a crude Ascii but a cooked translation.
 For example, spaces are no longer ' ' (020), but 'Space' (03), and so on.
 See 'LowSigns' and 'MyAsciiTable'.
;;
    call ReplaceWin32Equates
;jmp L7>>

    call InitIndex1

;jmp L7>>
   ;On B$ParseOOA = &TRUE, call ClassParser     ; <<<<<<<<< Delayed (doesn't work at all).
    On B$ParseEqual = &TRUE, call EqualParser
;jmp L7>>
    On B$ParseNew = &TRUE, call NewParser       ; Volunteers private room
    On B$ParseBinInclude = &TRUE, call BinIncluderParser

; jmp L7>>
    call BarProgress
    call 'User32.SendMessageA'  D$hwndForBar, &WM_SETTEXT, 0, Storing
;jmp L7>>
    call ClearQwordCheckSum
;jmp L7>>

; ------------------------  Start of the Macros and Equates Jobs ------------------------

L1: call StoreEquatesAndMacros

    call BarProgress
    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, Replacing

    call NewReplaceMacAndEqu

    call NewBrackets

    If B$MoreBracket = &TRUE
        mov B$FirstPass &FALSE
        call ResetForNewBrackets
        On B$WeAreUnfolding = &TRUE, call UnfoldOutput
        jmp L1<
    End_If

    On B$WeAreUnfolding = &TRUE, ret

; ------------------------  End of the Macros and Equates Jobs ------------------------

L2: call ExtendLocalSymbols
;;
  Do not remove this 'Exchange': There must be one, at the end of 'ExtendLocalSymbols',
  because it is also called from inside the 'HotParsers', for the @Locals first Pass.
;;
    Exchange D$CodeSourceA D$CodeSourceB
;;
  Down to here, we alway operated by reading at 'CodeSourceA' and writting at
  'CodeSourceB'. These manipulation are over: From here, we take source in
  'CodeSourceB', and will reuse CodeSourceA for building the Binary
;;

    call InitIndex2

    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, BuildingImport
    call BarProgress

    call ReuseSourceAForCodeList ;| jmp L7>>

    call BuildImport

;jmp L7>>
    call InitIndex3
    call BarProgress
    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, BuildingRsrc

    call BuildRsrc

    call 'KERNEL32.GetTickCount' | mov D$Time2 eax
    call BarProgress
    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, BuildingData


    call BuildData                         ; result 'CodeSourceB' > 'CodeSourceB'

    call BarProgress
    call InitDebugIpTable
    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, Encoding

    If B$ShortenJumpsWanted = &TRUE
        call InitShortenJmpsTable
        call EncodeLines
        call JmpsOptimize
        call ReleaseShortenJmpsTable

    Else_If B$ProfilerFlag = &TRUE
        call EncodeLines
        call CreateProfilerTables

    Else
        call EncodeLines                       ; Line > Para > Code > op
    End_If

;jmp L7>>
    call 'KERNEL32.GetTickCount' | mov D$Time3 eax
    call BarProgress
    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, BuildingHeader

    call PreparePeHeader | call FixTableSizes

    call BarProgress
    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, Fixing

    call BuildRelocationAndFillSymbols

    If B$ExportsectionWanted = &TRUE
        call PrepareDllVariables | call FillExportSection
    End_If

    call WritePeHeaders

    call BarProgress
    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, Writing

    call 'KERNEL32.GetTickCount' | mov D$Time4 eax

    call CloseProgressBar

    If B$ShowStats = &TRUE
        mov D$UnusedSymbolsDialogWanted &FALSE
        call 'USER32.DialogBoxParamA', D$hInstance, 2, D$hWnd, Statistics, 0
    Else
        call WritePE | call RecordMRU | On D$BookMarks > 0, call SaveBookMarks
    End_If

L8:
    On B$CompletionWanted = &TRUE, call BuildCompletionTable

    If D$UnusedSymbolsDialogWanted = &TRUE
        call DisplayUnusedSymbolsDialog D$hInstance
    End_If

    call ReleaseAsmTables

    If D$ShowTreeHandle <> 0
        On B$AutoRebuildTreeView = &TRUE, call TreeUpDate
    End_If
   ;call TestStatementsTable
ret

  ; For developments tests only (comments at "WriteDestination:"):
L7: call SetTestSavingName |  call WriteDestination | call CloseProgressBar | jmp L8<<


QuickOut:    call CloseProgressBar | call ReleaseAsmTables | ret

____________________________________________________________________________________________
____________________________________________________________________________________________

[MultipleCompileFindHandle: ?    OneOfMultiplePathNamePointer: ?]

[MultipleCompilePathTitle: 'For Multiple Compilations Test', 0]

[MultipleCompilePath: B$ ? #&MAXPATH]


MultipleCompileTests:
    call BrowseForFolder D$hwnd, MultipleCompilePathTitle
    On B$BrowseForFolderAborted = &TRUE, ret

    mov esi FolderPath, edi MultipleCompilePath
    While B$esi <> 0 | movsb | End_While | mov B$edi '\' | inc edi
    mov D$OneOfMultiplePathNamePointer edi

    mov edi FolderPath | While B$edi <> 0 | inc edi | End_While
    mov D$edi '\*.e', D$edi+4 'xe'

    call 'KERNEL32.FindFirstFileA' FolderPath, FindFile

    .If eax <> &INVALID_HANDLE_VALUE
        mov D$MultipleCompileFindHandle eax

L1:     mov esi FindFile.cFileName, edi D$OneOfMultiplePathNamePointer
        While B$esi <> 0 | movsb | End_While | movsb

        mov esi MultipleCompilePath, edi SaveFilter
        While D$esi <> 0 | movsb | End_While | movsb

        call DirectLoad

        call 'USER32.MessageBoxA' D$hwnd, SaveFilter,
                                  {'Ready to Compile...', 0}, &MB_SYSTEMMODAL

        call AsmMain | mov D$OldStackPointer 0
        On B$CompileErrorHappend = &TRUE, jmp L9>

        call 'KERNEL32.FindNextFileA' D$MultipleCompileFindHandle, FindFile
        cmp eax &TRUE | je L1<
    .End_If

L9: call 'KERNEL32.FindClose' D$MultipleCompileFindHandle
ret
____________________________________________________________________________________________









TITLE Optimize
____________________________________________________________________________________________

;;
  Release 2: Betov November 2006.
  _______________________________
    SetShortenJmpFlag
    
    SetJMPShortenJmpFlag
  
    JmpsOptimize
        ScanShortenJmpsTable
            InitScanShortenJmpsTable
            TryToShortenLong
                ShortenLongDown
                ShortenLongUp
        CompactLabelListAndCodeRef
            InitLabelListScanDwordPointer
            AdjustAboveListPointers
            AdjustLastListPointers
        CompactCodeList
        CompactShortenJmpsTable
       
        ScanCouples
            InitScanShortenJmpsTable
            IsJumpDownOrUp
            CouldBothBeShorten
                GetDisplacementDown
                GetDisplacementUp
            SetBothShort
  _______________________________
  
  Process:
  
  * A 'ShortenJmpsTable' Map is created by a cal from 'AsmMain': Empty Table,
    representing the Code area.
  
  * Jcc Encodage (above 'JMPmnemo') calls for 'SetShortenJmpFlag': 'LONG_Jcc' at the
    matching Byte of the 'ShortenJmpsTable'.
     
    JMP Encodage ('JMPmnemo') calls for 'SetJMPShortenJmpFlag': 'LONG_JMP' at the
    matching Byte of the 'ShortenJmpsTable'.
     
    Case of Plain Labels are not considered: They are always Long in RosAsm Syntax
    and the Jumps Sizes apply to Local Labels only.
  
  * After the Encodage, a "Long to Short" Optimization is computed, here.
;;
____________________________________________________________________________________________

[ShortenJumpsWanted: &FALSE]

[ShortenJmpsTable: ?   CodeListOrigine: ?]

InitShortenJmpsTable:
    On D$ShortenJmpsTable <> 0, call ReleaseShortenJmpsTable

    VirtualAlloc ShortenJmpsTable, D$SourceLen

    move D$CodeListOrigine D$CodeListPtr
ret


ReleaseShortenJmpsTable:
    VirtualFree D$ShortenJmpsTable
ret
____________________________________________________________________________________________

;;
  Called from 'Encode' // 'Letter_J' // Cases of Jcc and JMP (DownLong or UpLong only):
  
  The Plain Labels are not considered (always long in RosAsm Syntax).
;;

[EndOfShortenJmpsTable: ?]

[LONG_JMP 1, LONG_Jcc 2
 SHORTEN 3
 SHORTEN_LONG_JMP 4, SHORTEN_LONG_Jcc 5
 ALIGN_FLAG 010]

SetShortenJmpFlag:
    push edi
        sub edi D$CodeListOrigine | add edi D$ShortenJmpsTable | add edi 2
        mov B$edi LONG_Jcc, D$EndOfShortenJmpsTable edi
    pop edi
    inc D$NumberOfLongToShort
ret


SetJMPShortenJmpFlag:
    push edi
        sub edi D$CodeListOrigine | add edi D$ShortenJmpsTable | add edi 1
        mov B$edi LONG_JMP, D$EndOfShortenJmpsTable edi
    pop edi
    inc D$NumberOfLongToShort
ret


[AlignFound: ?]

SetAlignFlag:
    mov B$AlignFound &TRUE
ret
    push edi
        sub edi D$CodeListOrigine | add edi D$ShortenJmpsTable
        mov B$edi ALIGN_FLAG, D$EndOfShortenJmpsTable edi

        mov ecx D$imm32
    pop edi
ret
____________________________________________________________________________________________

[CodeRefScan: ?  NumberOfLongToShort: ?  JumpSizeStat: ?]

;;
  On RosAsm itself, the Optimization adds 7% to the Compile time, and resolves
  7,619 Long to Short. The main "While" is run 4 times.
;;

JmpsOptimize:
    mov eax D$CodeListPtr | dec eax

    call ScanShortenJmpsTable
    mov eax D$NumberOfLongToShort, D$JumpSizeStat eax

    While D$NumberOfLongToShort <> 0
L1:     call CompactLabelListAndCodeRef

        call CompactCodeList

        call CompactShortenJmpsTable

        call ScanShortenJmpsTable
        mov eax D$NumberOfLongToShort | add D$JumpSizeStat eax
    End_While

    call ScanCouples
    mov eax D$NumberOfLongToShort | add D$JumpSizeStat eax
    On D$NumberOfLongToShort <> 0, jmp L1<
ret
____________________________________________________________________________________________

[LongInstruction: ?] ; will be either 'LONG_JMP' or 'LONG_Jcc'

InitScanShortenJmpsTable:
    mov ebx D$CodeRef | add ebx 5

  ; Case of Api Calls: ...|0FF dWordCodeAddress|:
  ;                   ....|.....|
    While B$ebx = 0FF | add ebx 6 | End_While

    mov D$CodeRefName ebx

    While B$ebx > EOI | inc ebx | End_While | inc ebx

    mov D$CodeRefScan ebx
  ; 'CodeRefScan' points to the first Char of a LabelName, in 'CodeRef'.

    mov D$NumberOfLongToShort 0

    call InitLabelListScanDwordPointer

    mov esi D$ShortenJmpsTable
ret
____________________________________________________________________________________________

[CodeRefName: ?  CodeRefName1: ?  CodeRefName2: ?]

ScanShortenJmpsTable:
;;
  Job: The 'ShortenJmpsTable' has been filled with 'LONG_JMP' or 'LONG_Jcc' at each
  location of a relative jump address (parallel to 'CodeListOrigine'). If JUMPs can
  be shorten, it turns them into 'SHORTEN_LONG_JMP' or 'SHORTEN_LONG_Jcc'.
  
  Calls for: 'TryToShortenLong' >>> 'ShortenLongDown' and 'ShortenLongUp'
;;

    call InitScanShortenJmpsTable

  ; Scanning 'ShortenJmpsTable' 0 and 1 (esi ---> 'ShortenJmpsTable'):
L0: mov edx D$EndOfShortenJmpsTable

    While B$esi = 0
        inc esi | cmp esi edx | ja L9>>
    End_While

  ; Here we have a Long Displacement that will be computed in 'FillCodeSymbols'.
    mov al B$esi, B$LongInstruction al ; Either 'LONG_JMP' or 'LONG_Jcc'

  ; Translate into a 'CodeList' Pointer:
    mov eax esi | sub eax D$ShortenJmpsTable | add eax D$CodeListOrigine

  ; Scan CodeRef:

  ; >>> Two Pointers (One in CodeList -eax-, and one in CodeRef -ecx-):
L1: mov ecx D$ebx | and ecx (not relativeFlag)

    ..If ecx = eax
      ; Found matching Record, in CodeRef. Take a copy of the Name in 'CodeRefName':
        mov eax ebx | sub eax 5 | move D$CodeRefName D$eax

            call TryToShortenLong

            .If B$CanBeShorten = &TRUE
                If B$LongInstruction = LONG_JMP
                    mov B$esi SHORTEN_LONG_JMP
                Else_If B$LongInstruction = LONG_Jcc
                    mov B$esi SHORTEN_LONG_Jcc
                End_If

              ; For the lasting 'FillCodeSymbols' to know it is a special "Short":
                mov B$ebx-2 '.'
            .End_If

          ; Next CodeRef Record:
            add ebx 9 | inc esi
          ; Skip the Api calls:
            While B$ebx = 0FF | add ebx 6 | End_While
          ; Skip the "labelName|":
            While B$ebx > EOI | inc ebx | End_While | inc ebx

            jmp L0<<

        ..Else_If ecx <> 0
          ; Next CodeRef Record::
            add ebx 9
          ; Skip the Api calls:
            While B$ebx = 0FF | add ebx 6 | End_While
          ; Skip the "labelName|":
            While B$ebx > EOI | inc ebx | End_While | inc ebx

            jmp L1<<

        ..End_If
L9: ret
____________________________________________________________________________________________

[FirstDownCodeRefScan: ?  SecondUpCodeRefScan: ?]
[FirstDownShortenJmp: ?  SecondUpShortenJmp: ?]

ScanCouples:
    call InitScanShortenJmpsTable
  ; >>> ebx ---> 'CodeRefScan' ---> 'CodeRef'.
  ; >>> esi ---> 'ShortenJmpsTable'.
    mov edx D$EndOfShortenJmpsTable

    .While esi <= edx
        ...If B$esi <> 0
            push esi, edx
            call IsJumpDownOrUp

            ..If B$JumpIs = DOWN
                mov D$CodeRefScan eax
                mov D$FirstDownCodeRefScan eax, D$FirstDownShortenJmp esi
                move W$CodeRefName1 W$eax-5
                mov ebx esi | add esi 4
                push esi, edx
                    mov eax esi | add eax 133-4 | On eax < edx, mov edx eax

                    While esi <= edx
                        .If B$esi <> 0
                            call IsJumpDownOrUp ; >>> eax ---> 'CodeRefScan'

                            If B$JumpIs = UP
                                mov D$SecondUpCodeRefScan eax
                                move W$CodeRefName2 W$eax-5
                                mov D$SecondUpShortenJmp esi
                                call CouldBothBeShorten
                                On eax = &FALSE, jmp L2>
                                call SetBothShort | jmp L4>
                            End_If

                        .End_If

L2:                     inc esi
                    End_While
L4:             pop edx, esi

            ..End_If
            pop edx, esi
        ...End_If

L5:     inc esi
    .End_While
ret
____________________________________________________________________________________________

[JumpIs: ?]

[Down 1, Up 2]

IsJumpDownOrUp:
    push ebx, ecx
        mov eax esi | sub eax D$ShortenJmpsTable | add eax D$CodeListOrigine
        mov ebx D$CodeRefScan

    ; >>> Two Pointers (One to CodeList -eax-, and one to CodeRef -ecx-):
L1:     mov ecx D$ebx | and ecx (not relativeFlag)

        .If ecx = eax
            If W$ebx-3 = '>>'
                mov B$JumpIs DOWN
                mov eax ebx

            Else_If W$ebx-3 = '<<'
                mov B$JumpIs UP
                mov eax ebx

            Else
                mov B$JumpIs 0

            End_If

        .Else_If ecx = 0
            mov B$JumpIs 0

        .Else
          ; Next Record in 'CodeRef':
            add ebx 9
          ; No API call:
            While B$ebx = 0FF | add ebx 6 | End_While
          ; Skip the "labelName|":
            While B$ebx > EOI | inc ebx | End_While | inc ebx | jmp L1<<

        .End_If

L9: pop ecx, ebx
ret


CouldBothBeShorten:
;;
  When reducing from (5 or 6) to 2, we reduce of (3 or 4)
  From Flag to Label:
  
  Down: (07F): 1 + 127 +(3 or 4) =
                129  +    3 or 4      = 132 or 133
                
  Up:   (080): 128 -(1 or 0) +(3 or 4) =
                128 or 129     3 or 4    = 130, 131, 132
;;

  ; In between Distance, in the 'ShortenJmpsTable' Table:
    push ebx, ecx, edx
        mov ebx D$FirstDownShortenJmp, edx D$SecondUpShortenJmp
        mov ecx edx | sub ecx ebx

        mov eax &FALSE

        If B$ebx = LONG_Jcc
            mov ecx 135 | On B$edx = LONG_JMP, dec ecx
        Else
            mov ecx 134 | On B$edx = LONG_Jcc, inc ecx
        End_If
        inc ecx

        call GetDisplacementDown

        .If B$CanBeShorten = &TRUE
            If B$edx = LONG_Jcc
                mov ecx 132 | On B$ebx = LONG_JMP, dec ecx
            Else
                mov ecx 130 | On B$ebx = LONG_Jcc, inc ecx
            End_If
            inc ecx

            call GetDisplacementUp

            If B$CanBeShorten = &TRUE
                mov eax &TRUE
            Else
                mov eax &FALSE
            End_If

        .Else
            mov eax &FALSE

        .End_If

L9: pop edx, ecx, ebx
ret
____________________________________________________________________________________________

SetBothShort:
    mov eax D$FirstDownShortenJmp

    If B$eax = LONG_JMP
        mov B$eax SHORTEN_LONG_JMP
    Else
        mov B$eax SHORTEN_LONG_Jcc
    End_If

    mov eax D$SecondUpShortenJmp

    If B$eax = LONG_JMP
        mov B$eax SHORTEN_LONG_JMP
    Else
        mov B$eax SHORTEN_LONG_Jcc
    End_If

    mov eax D$FirstDownCodeRefScan, B$eax-2, '.'
    mov eax D$SecondUpCodeRefScan,  B$eax-2, '.'

    add D$NumberOfLongToShort 2
ret
____________________________________________________________________________________________

[CanBeShorten: ?, ScanSize: ?]

TryToShortenLong:
    pushad
;;
  ecx is a Pointer to CodeRef, to a Long jmp Displacement. Could it be Short?
  
  1) Is it Long Up or Long Down? >>> Read the '<<' or '>>', at D$CodeRefScan
;;
        mov B$CanBeShorten &FALSE

        If W$CodeRefName+2 = '>>'
            mov D$ScanSize (07F+4+1)
;;
  '+4' is the size of the long jump Displacement (We are pointing to the first Byte ot it).
  Either B$LongInstruction = LONG_Jcc, or LONG_JMP do not change a thing:
  Just moving it all upward 1 Byte, later, if LONG_Jcc.
  Why '+1'? Because the Processor will start from the Byte after the jump.
;;
            call ShortenLongDown

        Else_If W$CodeRefName+2 = '<<'
            mov D$ScanSize 080
          ; If an Instruction is a Jcc the Opcode length will switch from 2 to 1:
            On B$LongInstruction = LONG_Jcc, inc D$ScanSize

            call ShortenLongUp

        End_If
    popad
ret
____________________________________________________________________________________________

[ScanLabelPointer: ?]

ShortenLongDown:
  ; ebx = D$CodeRefScan >>> Label Name // ecx = 'CodeRef' Pointer to 'CodeList'

  ; Search a Label Declaration Pointer bigger that the CodeRef Evocation Pointer:
  ; eax = 'LabelList' Pointer to 'CodeList' // ecx = 'CodeRef' Pointer to 'CodeList'
  ; We search for a Pointer, in Label List, such as "ecx < D$esi < edx":
    mov esi D$LabelListScanPointer

    While D$esi > ecx
        PreviousLabelListPointer esi
    End_While

    While D$esi < ecx
        NextLabelListPointer esi
    End_While

    mov D$LabelListScanPointer esi

  ; Search the next same Label, in LabelList, as the one pointed by ebx.
  ; Store, for example 'K9', of "K9>>", in ebx:
    mov bx W$CodeRefName
  ; Scan-Down Limit (07F (127) is the limit for positive signed bytes):
    mov edx ecx | add edx D$ScanSize

  ; Search for the matching Label in the matching range, if any:
    While D$esi < edx
      ; Does 'esi-3' point to "K9", in "|K9|....f|" ?
      ; A LabelList Record is: // EOI, LabelName, EOI, Pointer, Flag, // EOI, ...
        .If W$esi-3 = bx
            cmp B$esi-4 EOI | jne L5>
            cmp B$esi-1 EOI | jne L5>
              ; Found a matching Label, that is Long, and that can be made Short:
                mov B$CanBeShorten &TRUE
                inc D$NumberOfLongToShort | jmp L9>

        .Else
L5:         NextLabelListPointer esi

        .End_If

    End_While

    mov B$CanBeShorten &FALSE
L9: ret
____________________________________________________________________________________________

GetDisplacementDown:
;;
  'FirstDownCodeRefScan' has kept track of the Reference. That is, the pointer to Codelist
  found in the CodeRef Table.
  
  We search for a Pointer, in LabelList, that would be bigger than 'FirstDownCodeRefScan',
  with a matching Name.
  
  Abort if bigger than 'FirstDownCodeRefScan' + 133.
;;
    pushad
      ; Go to the first Label closer to 'FirstDownShortenJmp'
        mov esi D$LabelListScanPointer
        mov eax D$FirstDownCodeRefScan, eax D$eax | and eax (not relativeFlag)

        While D$esi > eax
            PreviousLabelListPointer esi ; 'LabelList'
        End_While

        While D$esi < eax
            NextLabelListPointer esi ; 'LabelList'
        End_While
        PreviousLabelListPointer esi
        mov D$LabelListScanPointer esi

      ; Search the next same Label, in LabelList, as the one pointed by ebx.
      ; Store, for example 'K9', of "K9>>", in ebx:
        mov bx W$CodeRefName1
      ; Scan-Down Limit:
        mov edx eax | add edx ecx

      ; Search for the matching Label in the matching range, if any:
        While D$esi < edx
            .If W$esi-3 = bx
                cmp B$esi-4 EOI | jne L5>
                cmp B$esi-1 EOI | jne L5>
                  ; Found a matching Label, that is Long, and that could be made Short:
                    mov B$CanBeShorten &TRUE | jmp L9>

            .Else
L5:             NextLabelListPointer esi

            .End_If

        End_While

        mov B$CanBeShorten &FALSE
L9: popad
ret
____________________________________________________________________________________________

; A Jump can be short Up if it is > 0FFFF_FF80

ShortenLongUp:
  ; ebx = D$CodeRefScan >>> Label Name // ecx = 'CodeRef' Pointer to 'CodeList'

  ; Search the next same Label, in LabelList, as the one pointed by ebx.
  ; Store, for example 'K9', of "K9>>", in ebx:
    mov bx W$CodeRefName
    mov edx ecx | sub edx D$ScanSize

  ; Search a Label Declaration Pointer smaller that the CodeRef Evocation Pointer:
  ; eax = 'LabelList' Pointer to 'CodeList' // ecx = 'CodeRef' Pointer to 'CodeList'
  ; We search for a Pointer, in Label List, such as "ecx < D$esi < edx":
    mov esi D$LabelListScanPointer

    While D$esi > ecx
        PreviousLabelListPointer esi
    End_While

    While D$esi < ecx
        NextLabelListPointer esi
        On D$esi = 0, jmp L7>
    End_While

L7: PreviousLabelListPointer esi
    mov D$LabelListScanPointer esi

  ; Search for the matching Label in the matching range, if any:
    While D$esi > edx
      ; Does 'esi-7' point to "K9", in "|K9|....f|
      ; A LabelList Record is: // EOI, LabelName, EOI, Pointer, Flag, // EOI, ...
        .If W$esi-3 = bx
            cmp B$esi-4 EOI | jne L5>
            cmp B$esi-1 EOI | jne L5>
          ; Found a matching Label, that is Long, and that can be made Short:
                mov B$CanBeShorten &TRUE
                inc D$NumberOfLongToShort | jmp L9>

        .Else
L5:         PreviousLabelListPointer esi

        .End_If

    End_While

    mov B$CanBeShorten &FALSE
L9: ret
____________________________________________________________________________________________

GetDisplacementUp:
;;
  'FirstDownCodeRefScan' has kept track of the Reference. That is, the pointer to Codelist
  found in the CodeRef Table.
  
  We search for a Pointer, in LabelList, that would be bigger than 'FirstDownCodeRefScan',
  with a matching Name.
;;
    pushad
      ; Go to the first Label closer to 'FirstDownShortenJmp'
        mov esi D$LabelListScanPointer
        mov eax D$SecondUpCodeRefScan, eax D$eax | and eax (not relativeFlag)

        While D$esi < eax
            nextLabelListPointer esi
        End_While

        While D$esi > eax
            PreviousLabelListPointer esi
        End_While
        NextLabelListPointer esi

        mov D$LabelListScanPointer esi

      ; Search the next same Label, in LabelList, as the one pointed by ebx.
      ; Store, for example 'K9', of "K9>>", in ebx:
        mov bx W$CodeRefName2
      ; Scan-Down Limit:
        mov edx eax | sub edx ecx

      ; Search for the matching Label in the matching range, if any:
        mov eax D$FirstDownCodeRefScan
        While D$esi > edx
            If W$esi-3 = bx
                ;On D$esi > eax, jmp L8>
                cmp B$esi-4 EOI | jne L5>
                cmp B$esi-1 EOI | jne L5>
                  ; Found a matching Label, that is Long, and that could be made Short:
                    mov B$CanBeShorten &TRUE | jmp L9>

            Else
L5:             PreviousLabelListPointer esi

            End_If
        End_While

L8:     mov B$CanBeShorten &FALSE
L9: popad
ret
____________________________________________________________________________________________

; LabelListScanPointer points to one of the dWord Pointers, in LabelList:

[LabelListScanPointer: ?]

InitLabelListScanDwordPointer:
  ; Dword | ... // ...| Name | Dword1 Byte | // ....  ;;; 'StoreDataLabel'
  ;    ...|LabelName|....f|LabelName|....f|
    mov esi D$LabelList | add esi 5
L0: While B$esi > EOI | inc esi | End_While | inc esi

    While B$esi+4 < CodeLabelFlag
        NextLabelListPointer esi
    End_While

    mov D$LabelListScanPointer esi
  ; >>> D$LabelListScanPointer points to the dWord (Pointer to CodeList)
ret

[NextLabelListPointer
 add #1 6
 N4: cmp B$#1 EOI | je N5> | cmp D$#1 0 | je N5> | inc #1 | jmp N4<
 N5: inc #1]

[PreviousLabelListPointer
 sub #1 2
 N4: cmp B$#1 EOI | je N5> | cmp #1 LabelList | je N5> | dec #1 | jmp N4<
 N5: sub #1 5]

[CodeRefScanPointer: ?]
____________________________________________________________________________________________

;;
  'SHORTEN_LONG_JMP' or 'SHORTEN_LONG_Jcc' found in 'ShortenJmpsTable':
  
  * add 3 to eax.
  
  * All LabelList References to CodeList, downward this Pos, must be substract
    with eax.
    
  * All CodeRef Pointers to a downward Pos must also be substract with eax.
;;

CompactLabelListAndCodeRef:
    mov ebx D$ShortenJmpsTable, edx D$EndOfShortenJmpsTable

    call InitLabelListScanDwordPointer
  ; >>> esi ---> D$LabelListScanPointer

  ; Edi = Will point to the dWord1 of 'CodeRef':
    mov edi D$CodeRef | add edi 5

  ; Case of Api Calls: ...|0FF dWordCodeAddress|:
  ;                   ....|.....|
    While B$edi = 0FF | add edi 6 | End_While

  ; Pointing to the 'CodeRef' Pointer to 'CodeList';
    While B$edi <> EOI | inc edi | End_While | inc edi

    mov eax 0

    While ebx <= edx
        If B$ebx > SHORTEN
            mov cl B$ebx, B$LongInstruction cl
            call AdjustAboveListPointers
            add eax 3
        End_If

        inc ebx
    End_While

    call AdjustLastListPointers
ret
____________________________________________________________________________________________

AdjustAboveListPointers:
  ; ("Above" means in between the previous access and the actual access).

    push ebx
      ; esi ---> LabelList / edi ---> CodeRef.

      ; ecx = Offset matching the actual Shorten Jump Displacement, in 'CodeList':
        mov ecx ebx | sub ecx D$ShortenJmpsTable | add ecx D$CodeListOrigine

      ; LabelList adjustments of the Pointers to Code:
      ; ("<" because the Label is necessary _before_ the Instruction).
        While D$esi < ecx
            sub D$esi eax
            NextLabelListPointer esi
            On D$esi = 0, jmp L1>
        End_While
;;
  CodeRef adjustments of the Pointers to Code:
  
  2 Problems: 
  
  1) The Records for Api calls are irregular. We just skip over them.
  
  2) The Pointer to 'CodeList', in 'CodeRef' (dWord1) the 'RelativeFlag' is [On].
;;
L1:     mov ebx D$edi | and ebx (not RelativeFlag)
      ; "<=", because the Evocation Reference and the Shorten Jump match exactly:
        .While ebx <= ecx
            .If ebx = ecx
                If B$LongInstruction = SHORTEN_LONG_Jcc
                    inc eax
                End_If
            .End_If
            sub ebx eax
            test D$edi RelativeFlag | jz L2>
                or ebx RelativeFlag
L2:         mov D$edi ebx

          ; Next CodeRef Record:
            add edi 9
          ; Cases of Api calls. Comments in 'FillCodeSymbols'. We just skip over:
            While B$edi = 0FF | add edi 6 | End_While
            While B$edi <> EOI | inc edi
                On D$edi = 0, jmp L9>
            End_While
            inc edi
            mov ebx D$edi | and ebx (not RelativeFlag)
        .End_While

L9: pop ebx
ret
____________________________________________________________________________________________

AdjustLastListPointers:
  ; Same as above 'AdjustAboveListPointers', but just assume the lasting Records:

  ; LabelList adjustments:
    While D$esi <> 0
        sub D$esi eax
        NextLabelListPointer esi
    End_While

  ; CodeRef adjustments:
    .While D$edi <> 0
        mov ebx D$edi | and ebx (not RelativeFlag)
        sub ebx eax | Test D$edi RelativeFlag | jz L1>
            or ebx RelativeFlag

L1:     mov D$edi ebx
      ; Next CodeRef Record:
        add edi 9
      ; Cases of Api calls. Comments in 'FillCodeSymbols'. We just skip over:
        While B$edi = 0FF | add edi 6 | End_While
        While B$edi <> EOI
            inc edi | On D$edi = 0, jmp L9>
        End_While | inc edi
    .End_While
L9: ret
____________________________________________________________________________________________

CompactCodeList:
    mov ebx D$ShortenJmpsTable, edx D$EndOfShortenJmpsTable
    mov esi D$CodeListOrigine, edi esi

    While ebx <= edx
        If B$ebx = SHORTEN_LONG_JMP
          ; jmp Long = 0E9 >>> jmp short = 0EB
            mov B$edi-1 0EB, B$edi 0
            add esi 4 | add ebx 4 | inc edi

        Else_If B$ebx = SHORTEN_LONG_Jcc
          ; Example: B$esi-2 >>> 0F, 084 (JE long) >>> 074 (JE short), 0:
            mov al B$esi-1 | sub al 010 | mov B$edi-2 al, B$edi-1 0
            add esi 4 | add ebx 4

        Else
            movsb | inc ebx

        End_If

    End_While

  ; Copy the Bytes coming after the last modified CodeRef Pointer:
    While esi < D$CodeListPtr | movsb | End_While

  ; Cosmetic clean-up of the trailing Bytes in CodeList:
    push edi
        mov al 0 | While edi < D$CodeListPtr | stosb | End_While
    pop edi
    mov D$CodeListPtr edi
ret
____________________________________________________________________________________________

CompactShortenJmpsTable:
    mov esi D$ShortenJmpsTable, edx D$EndOfShortenJmpsTable
    mov edi esi, eax 0

    While esi <= edx
        If B$esi = SHORTEN_LONG_JMP
            mov B$esi 0 | add esi 3

        Else_If B$esi = SHORTEN_LONG_Jcc
            mov B$esi 0 | add esi 4

        Else
            movsb

        End_If

    End_While

    mov D$EndOfShortenJmpsTable edi
ret
____________________________________________________________________________________________









TITLE Parsers
____________________________________________________________________________________________
; Maintainer: Rikkert Wiggerink (EvilBro)
; Started: Somewhere in april 2003
; Email: r.wiggerink@student.utwente.nl
____________________________________________________________________________________________
;;
29-4-2003:
 This is the first version of the rewritten parsers in an official RosAsm release.
 This is by no means the end of the revision. :)
  
 The philosophy behind this revision:
    The routines that previously cleaned up the source have been replaced and split up into 
    many different routines (duplicate actions were removed). This is done for maintainance 
    purposes. Anyone who has taken a look at the old routines will see the importance of this 
    split up (from a maintainance point of view anyway :) )
    
    There will be some people who will think the clean up needs to be done in a single routine
    (Yes, I mean Kenny :) ). This will not work. It is what Betov started with when the old
    routines were written (and we all know the hell that followed from that... at least I do).
    There is also no need for the extra performance a single clean up routine would bring.
    On my Pentium 90 compilation of RosAsm takes 39.8 seconds with the new routines and 
    38.5 seconds with the old routines (average timing values used). That means that the new 
    routines are roughly a second slower (on a source like RosAsm). However, this second is 
    completely insignificant compared to the total compile time.

 All parsers I've written expect the source to be in CodeSourceA. They will either modify the 
 source in CodeSourceA directly or copy/modify the source to CodeSourceB. On exiting a routine
 the source will be in CodeSourceA. This is done for simplicity.

 Anyway, I expect that now this version is implemented in an official RosAsm release, errors 
 are bound to turn up. Just post them on the RosAsm forum or mail them directly to me and 
 I'll fix them.

 BTW 'Kill' means 'replace by spaces'. 'Strip' means 'replace by nothing'.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________
; NewCopyToCodeSourceA replaces CopyToCodeSourceA which always used CodeSource as the <Source>.
; usage: call NewCopyToCodeSourceA <Source> <SourceLength>

Proc NewCopyToCodeSourceA:
    Arguments @Pointer, @Length

        mov esi D@Pointer, ecx D@Length, edi D$CodeSourceA, D$StripLen ecx
        rep movsb
EndP

Proc InjectedCopyToCodeSourceA:
    Arguments @Pointer, @Length

        mov esi InjectedTIME_COUNT, edi D$CodeSourceA, ecx D$InjectedTIME_COUNT_Len
        mov D$StripLen ecx | rep movsb

        mov esi D@Pointer, ecx D@Length | add D$StripLen ecx | rep movsb
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
; CoolParsers are all parsers that do not change the position of statements in the source.

CoolParsers:
    call CheckTextDelimitersPairing
    call KillMultiLineComments ; and Comments
   ; call KillSingleLineComments
    call NewKillVirtualCRLF
    call KillMeaninglessCommas
    call CheckandKillPreParsers
        On B$ParseIncInclude = &TRUE, call ClearIncludeStateMentsFromSource ;call IncParser
        On B$ParseAlternates = &TRUE, call AlternatesPreparsers
      ; +0.2 seconds (2.850 >>> 3.650) on RosAsm 4 Megas, with a Celeron 1.3.
    call KillTitles ; + Old 'ConvertTextSigns'
   ; call CheckBracketsPairing
    ;call CheckNestedBracketsPairing
    call CheckPairings
    call ReplaceParaMacrosBrackets
   ; call CheckOpenCloseSignPairing
ret

; CoolParsersOnInc:
        call CheckTextDelimitersPairing
        call KillMultiLineComments ; and Comments
       ; call KillSingleLineComments
        call NewKillVirtualCRLF
        call KillMeaninglessCommas


CoolParsersOnInc: ; CoolParsers
    push D$CodeSourceA, D$StripLen

        move D$CodeSourceA D$bininc.mem, D$StripLen D$bininc.filesize

        call CheckTextDelimitersPairing
        call KillMultiLineComments ; and Comments
       ; call KillSingleLineComments
        call NewKillVirtualCRLF
        call KillMeaninglessCommas

    pop D$StripLen, D$CodeSourceA
ret

____________________________________________________________________________________________
; HotParsers are parsers that can change the position of statements in the source.

HotParsers:
    call TranslateAsciiToMyAscii

    call StripUnderscore
    On B$ProfilerFlag = &TRUE, call InjectDashLines

    call StripUnneededSpaces
    call ConvertCommasToSpace
    call StripUnneededEOI
    call ConvertEOIinBracketsTOmeEOI
   ; call ConvertTextSigns    ; This one 'needs' to be done sooner. Would simplify earlier routines
    call ExtendLocalSymbols
    call IdentifyVirtualData
    call ReorderSource
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
CheckTextDelimitersPairing:
    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    mov B$esi-1 LF      ; for MultiLineComment starting on the first line

    .While esi < ecx
        .If B$esi = '"'
            mov edx esi
            Do
                inc esi | cmp esi ecx | je L9>  ; Error: no closing delimiter found inside source.
            Loop_Until B$esi = '"'
        .Else_If B$esi = "'"
            mov edx esi
            Do
                inc esi
                cmp esi ecx | je L9>        ; Error: no closing delimiter found inside source.
                cmp B$esi CR | je L9>       ; Error: ' isn't allowed to be multiline.
            Loop_Until B$esi = "'"
        .Else_If B$esi = ';'
            If D$esi-1 = MLC
                Do
                    inc esi | cmp esi ecx | je L8>
                Loop_Until D$esi = MLC
                inc esi
            Else
                Do
                    inc esi
                Loop_Until B$esi < ' '
            End_If
        .End_If
        inc esi
    .End_While
L8: ret

L9: ;ERROR! Unpaired textdelimiter.
    mov esi edx
    While B$esi > LF | dec esi | End_While
    mov edi CookedErrorMessage
    While B$esi <> CR
        movsb | On edi = EndOfCookedErrorMessage, jmp L2>
    End_While
L2: mov B$edi 0

    mov B$Errorlevel 9 | error D$OpenTextPtr
ret
____________________________________________________________________________________________
; Multiline comments are converted to spaces.

KillMultiLineComments:
    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    mov B$esi-1 LF      ; for MultiLineComment starting on the first line

    .While esi < ecx
        ..If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        ..Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        ..Else_If B$esi = ';'
            .If D$esi-1 = MLC
                Do
                    mov B$esi ' '
                    inc esi | On esi >= ecx, ret
                Loop_Until D$esi = MLC
                mov D$esi 0D202020  ; Replace 'LF ; ; CR' with 'Space Space Space CR'.
                add esi 3
            .Else
                ;On D$esi+1 = ' Tag', call AssemblyTag
                Do | mov B$esi ' ' | inc esi | Loop_Until B$esi < ' '
            .End_If
        ..End_If
        inc esi
    .End_While
L8: ; KillMultiLineComments might have killed the closing CRLF, thus it is restored.
    mov W$esi-2 0A0D
ret
________________________________________________________________________________________________
; Singleline comments are converted to spaces.
; Warning: This routine will also kill ";;", so if it is run before MultiLineComment are killed
; then you can be pretty sure, you won't be able to strip MultiLineComments correctly.

KillSingleLineComments:
    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        .Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        .Else_If B$esi = ';'
            Do | mov B$esi ' ' | inc esi | Loop_Until B$esi < ' '
        .End_If
        inc esi
    .End_While
L8: ret
________________________________________________________________________________________________
; Titles are converted to spaces.

KillTitles: ; ConvertTextSigns
    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = '"'
            mov B$esi TextSign
            Do | inc esi | Loop_Until B$esi = '"'
            mov B$esi TextSign
        .Else_If B$esi = "'"
            mov B$esi TextSign
            Do | inc esi | Loop_Until B$esi = "'"
            mov B$esi TextSign
        .Else_If D$esi = 'TITL'
            If B$esi-1 = LF
                On W$esi+4 <> 'E ', jmp L0>
                    Do | mov B$esi ' ' | inc esi | Loop_Until B$esi < ' '
L0:
            End_If
        .End_If

        inc esi

    .End_While

L8: ret
________________________________________________________________________________________________
; VirtualCRLFs are converted to spaces.

NewKillVirtualCRLF:
    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        .Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        .Else_If B$esi = CR
            mov edi esi, al ' '
            While B$edi <= ' '
                dec edi | On edi < D$CodeSourceA, jmp L7>
            End_While
            If B$edi = ','
                Do
                    stosb | cmp edi ecx | ja L8>
                Loop_Until B$edi > ' '
            End_If
        .End_If

L7:     inc esi

    .End_While
L8: ret
________________________________________________________________________________________________
; Meaningless commas are converted to spaces.
; Note: This routine will probably move to HotParsers in the future.

KillMeaninglessCommas:
    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        .Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        .Else_If B$esi = ','
            mov edi esi
            Do
                inc edi
            Loop_Until B$edi <> ' '

            If B$edi = '+'
                mov esi edi
            Else_If B$edi = '-'
                mov esi edi
            Else
                mov B$esi ' '
            End_If
        .End_If

        inc esi

    .End_While
ret
____________________________________________________________________________________________
; Checks for PREPARSE statements, sets the right flags and then kills the PREPARSE statements.
; Note that any amount of PREPARSE statements can be used in the source with this new routine.

[ParseAlternates: B$ ?    ParseEqual: ?    ParseOOA: ?    ParseNew: ?
 ParseBinInclude: ?       ParseIncInclude: ?]

CheckandKillPreParsers:
    mov B$ParseAlternates &FALSE, B$ParseEqual &FALSE, B$ParseOOA &FALSE, B$Dynamic &FALSE

    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        .Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        .Else_If D$esi = 'PREP'             ; PREPARSE
            ..If D$esi+4 = 'ARSE'
                If B$esi-1 = LF
                    On B$esi+8 <> ' ', jmp L6>
                    call NewCheckPreparser
                    Do
                        mov B$esi ' '
                        inc esi
                    Loop_Until B$esi < ' '
L6:
                End_If
            ..End_If
        .End_If

L7:     inc esi

    .End_While
L8: ret
_______________________________________________________________________________________________
; This routine is not really altered at this point compared to the old routine. This will be
; done in a future version as this version is really unreadable (and thus hard to maintain).

[Dynamic: ?  MemReservation: ?]

NewCheckPreparser:
    mov D$MemReservation 0

    mov edi esi
    add edi 9

L1: While B$edi = ' ' | inc edi | End_While

    mov eax D$edi | and eax (not 020202020)     ; Convert to uppercase.
    ...If eax = 'ALTE'                          ; ALTERNATES
        mov eax D$edi+4 | and eax (not 020202020)
        ..If eax = 'RNAT'
            mov ax W$edi+8 | and eax (not 02020)
            .If ax = 'ES'
                If B$edi+10 <= ' '
                    mov B$ParseAlternates &TRUE | add edi 11 | jmp L8>>
                End_If
            .End_If
    ...Else_If eax = 'EQUA'                     ; EQUAL
        mov al B$edi+4 | and eax (not 020)
        .If al = 'L'
            If B$edi+5 <= ' '
                mov B$ParseEqual &TRUE | add edi 6 | jmp L8>>
            End_If
        .End_If
    ...Else_If eax = 'BINI'                     ; BinIncluder
        mov eax D$edi+4 | and eax (not 020202020)
        .If eax = 'NCLU'
            mov eax D$edi+7 | and eax (not 020202020)
            If eax = 'UDER'
                mov B$ParseBinInclude &TRUE | add edi 12 | jmp L8>>
            End_If
        .End_If
    ...Else_If eax = 'INCI'                     ; IncIncluder
        mov eax D$edi+4 | and eax (not 020202020)
        .If eax = 'NCLU'
            mov eax D$edi+7 | and eax (not 020202020)
            If eax = 'UDER'
                mov B$ParseIncInclude &TRUE | add edi 12 | jmp L8>>
            End_If
        .End_If
    ...Else_If ax = 'OO'                        ; OOA
        mov al B$edi+2 | and eax (not 020)
        .If al = 'A'
            If B$edi+3 <= ' '
                mov B$ParseOOA &TRUE | add edi 4 | jmp L8>>
            End_If
        .End_If
    ...Else_If ax = 'NE'                        ; Prepare New
        mov al B$edi+2 | and eax (not 020)
        .If al = 'W'
            If B$edi+3 <= ' '
                mov B$ParseNew &TRUE | add edi 4 | jmp L8>>
            End_If
        .End_If
    ...Else_If ax = 'EN'                        ; Preparse EntryPoint
        mov eax D$edi+2 | and eax (not 020202020)
        .If eax = 'TRYP'
            mov eax D$edi+6 | and eax (not 020202020)
            If eax = 'OINT'
                call TakeNewEntryPoint | ret   ; Must be separated on one line
            End_If
        .End_If
    ...Else_If eax = 'DYNA'                        ; Preparse Dynamic
        mov eax D$edi+3 | and eax (not 020202020)
        If eax = 'AMIC'
            mov B$Dynamic &TRUE | add edi 8 | jmp L8>
        End_If
;;
  ; Must be run before this time...
  
    ...Else_If eax = 'RESE'                        ; Preparse Reserve
        mov eax D$edi+3 | and eax (not 020202020)
        If eax = 'ERVE'
            call ReadMemoryReservation
            add edi 8 | jmp L8>
        End_If
;;

    ...End_If

    mov B$edi-1 0, esi edi
    While B$edi > ' ' | inc edi | End_While | mov B$edi 0
    mov B$ErrorLevel 9 | error D$BadPreParsePtr, esi

L8:  On B$edi >= ' ', jmp L1<<

; Possible add of multiple Pre-Parsers conflicts checking...
ret


ReadMemoryReservation:
    push esi
        mov esi edi
        While B$esi > ' ' | inc esi | End_While
        While B$esi = ' ' | inc esi | End_While
        If B$esi = '0'
            call TranslateHexa
        Else
            call TranslateDecimal
        End_If

        mov D$MemReservation eax
    pop esi
ret


[BadEntryDef: 'Bad definition of EntryPoint in "Preparse EntryPoint"', 0]

TakeNewEntryPoint: ; Preparse EntryPoint Name
    push esi, edi, ecx
        mov esi edi | add esi 11 | mov edi EntryPointLabel, ecx 0

        While B$esi > ' '
            lodsb | and eax (not 020) | stosb | inc ecx
        End_While
        mov B$edi 0

        mov B$ErrorLevel 9
        mov D$EntryPointLabelLen ecx | On ecx = 0, error BadEntryDef
    pop ecx, edi, esi
ret
________________________________________________________________________________________________
[InsideBrackets: B$ ?]

CheckBracketsPairing:
    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    mov B$InsideBrackets &FALSE

    .While esi < ecx
        .If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        .Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        .Else_If B$esi = '['
            If B$InsideBrackets = &TRUE
                jmp L9>
            Else
                mov edx esi
                mov B$InsideBrackets &TRUE
            End_If
        .Else_If B$esi = ']'
            If B$InsideBrackets = &TRUE
                mov B$InsideBrackets &FALSE
            Else
                mov edx esi
                jmp L9>
            End_If
        .End_If
        inc esi
    .End_While

    On B$InsideBrackets = &TRUE, jmp L9>

L8: ret

L9: ;ERROR! Unpaired bracket
    mov esi edx
    While B$esi > LF | dec esi | End_While
    mov edi CookedErrorMessage
    While B$esi <> CR
        movsb | On edi = EndOfCookedErrorMessage, jmp L2>
    End_While
L2: mov B$edi 0

    mov B$Errorlevel 9 | error D$OrphanBracketPtr
ret


L8: ;ERROR! Unpaired open/close-sign
    mov esi edx
    While B$esi > LF | dec esi | End_While
    mov edi CookedErrorMessage
    While B$esi <> CR
        movsb | On edi = EndOfCookedErrorMessage, jmp L2>
    End_While
L2: mov B$edi 0

    mov B$Errorlevel 9 | error D$ParenthesisPtr
ret
________________________________________________________________________________________________

[VirtualBracketsCount: ?
 FirstBracket: ?         LastBracket: ?
 FirstVirtualBracket: ?  LastVirtualBracket: ?
 FirstParenthesis: ?     LastParenthesis: ?]

CheckPairings:
    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    mov B$InsideBrackets &FALSE, edx esi
    mov D$OpenSignsCount 0, D$VirtualBracketsCount 0

    .While esi < ecx
        mov al B$esi

        .If al = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign

        .Else_If al = '['
            If B$InsideBrackets = &TRUE
                jmp L9>>
            Else_If D$VirtualBracketsCount <> 0
                jmp L9>>
            Else_If D$OpenSignsCount <> 0
                jmp L9>>
            Else
                mov B$InsideBrackets &TRUE, D$FirstBracket esi
            End_If

        .Else_If al = ']'
            mov D$LastBracket esi
            If D$VirtualBracketsCount <> 0
                jmp L9>>
            Else_If B$OpenSignsCount <> 0
                jmp L9>>
            Else_If B$InsideBrackets = &FALSE
                jmp L9>>
            End_If
            mov B$InsideBrackets &FALSE

        .Else_If al = '{'
            mov D$FirstVirtualBracket esi
            If B$InsideBrackets = &FALSE
                On D$VirtualBracketsCount > 0, jmp L9>> ; <<<<<<<<<<<<<<<<<<<<
            End_If
            inc D$VirtualBracketsCount

        .Else_If al = '}'
            mov D$LastVirtualBracket esi
            dec D$VirtualBracketsCount | On D$VirtualBracketsCount = 0-1, jmp L9>>

        .Else_If al = '('
            On B$OpenSignsCount = 0, mov D$FirstParenthesis esi
            inc B$OpenSignsCount

        .Else_If al = ')'
            mov D$LastParenthesis esi
            dec D$OpenSignsCount | On D$OpenSignsCount = 0-1, jmp L9>>
        .End_If

        inc esi
    .End_While

    If B$InsideBrackets = &TRUE
        mov B$esi '[' | jmp L9>
    Else_If D$VirtualBracketsCount <> 0
        mov B$esi '{' | jmp L9>
    Else_If B$OpenSignsCount <> 0
        mov B$esi ')' | jmp L9>
    End_If
ret

L9: ; Pointing the unpairing error:
    push esi
        .If B$esi = '['
            If D$VirtualBracketsCount <> 0
                mov esi D$FirstVirtualBracket
            Else_If D$OpenSignsCount <> 0
                mov esi D$FirstParenthesis
            Else
                mov esi D$FirstBracket
            End_If

        .Else_If B$esi = ']'
            If D$VirtualBracketsCount <> 0
                mov esi D$FirstVirtualBracket
            Else_If D$OpenSignsCount <> 0
                mov esi D$FirstParenthesis
            Else
                ;
            End_If

        .Else_If B$esi = '{'
            mov esi D$FirstVirtualBracket
        .Else_If B$esi = '}'
            ;
        .Else_If B$esi = '('
            mov esi D$FirstParenthesis
        .Else_If B$esi = ')'
            ;
        .End_If

        sub esi D$CodeSourceA | add esi D$CodeSource
        mov eax esi
        While B$esi > LF | dec esi | End_While | inc esi
        While B$eax > LF | inc eax | End_While | dec eax
        mov D$BlockStartTextPtr esi, D$BlockEndTextPtr eax, B$BlockInside &TRUE
        mov D$UpperLine esi
        call UpOneLine | call UpOneLine | call UpOneLine
    pop esi

  ; Set the Error Message Text:
    .If B$esi = '['
        If D$VirtualBracketsCount <> 0
            mov eax UnPairedNestedBrackets
        Else_If D$OpenSignsCount <> 0
            mov eax D$ParenthesisPtr
        Else
            mov eax D$OrphanBracketPtr
        End_If

    .Else_If B$esi = ']'
        If D$VirtualBracketsCount <> 0
            mov eax D$UnPairedNestedBracketsPtr
        Else_If D$OpenSignsCount <> 0
            mov eax D$ParenthesisPtr
        Else
            mov eax D$OrphanBracketPtr
        End_If

    .Else_If B$esi = '{'
        mov eax D$UnPairedNestedBracketsPtr

    .Else_If B$esi = '}'
        mov eax D$UnPairedNestedBracketsPtr

    .Else_If B$esi = '('
        mov eax D$ParenthesisPtr

    .Else_If B$esi = ')'
        mov eax D$ParenthesisPtr

    .Else
        mov eax D$unknownPtr

    .End_If

    mov edi CookedErrorMessage, esi D$BlockStartTextPtr
    While esi < D$BlockEndTextPtr
        movsb | On edi = EndOfCookedErrorMessage, jmp L2>
    End_While

L2: mov B$edi 0

    mov B$Errorlevel 9 | error eax
ret
____________________________________________________________________________________________

[InsideParaMacro: ?]

ReplaceParaMacrosBrackets:
    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    mov B$InsideBrackets &FALSE, B$InsideParaMacro &FALSE, ebx 0, edx 0

    .While esi < ecx
        lodsb

        ..If al = TextSign
            While B$esi <> TextSign | inc esi | End_While | inc esi
        ..Else_If al = '['
            mov B$InsideBrackets &TRUE
        ..Else_If al = ']'
            mov B$InsideBrackets &FALSE
        ..Else_If al = '{'
            .If B$InsideBrackets = &FALSE
                mov B$esi-1 OpenParaMacro
                mov B$InsideParaMacro &TRUE
            .Else
                mov ebx esi | dec ebx
                While B$ebx <> '['
                    dec ebx
                    On B$ebx = '|', jmp L2>
                    On B$ebx = LF, jmp L2>
                    If B$ebx > ' '
                        mov B$esi-1 OpenParaMacro
                        mov B$InsideParaMacro &TRUE | jmp L2>
                    End_If
                End_While
            .End_If

        ..Else_If al = '}'
            If B$InsideParaMacro = &TRUE
                mov B$esi-1 CloseParaMacro
                mov B$InsideParaMacro &FALSE
            End_If

        ..End_If
L2: .End_While
ret
________________________________________________________________________________________________
; This routine will be moved to Hotparsers at a later time.
[OpenSignsCount: B$ ?]

CheckOpenCloseSignPairing:
    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    mov B$OpenSignsCount 0

    .While esi < ecx
        .If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        .Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        .Else_If B$esi = '('
            If B$OpenSignsCount = 0
                mov edx esi
            End_If
            inc B$OpenSignsCount
        .Else_If B$esi = ')'
            If B$OpenSignsCount = 0
                jmp L9>
            End_If
            dec B$OpenSignsCount
        .End_If
        inc esi
    .End_While
L8: ret

L9: ;ERROR! Unpaired open/close-sign
    mov esi edx
    While B$esi > LF | dec esi | End_While
    mov edi CookedErrorMessage
    While B$esi <> CR
        movsb | On edi = EndOfCookedErrorMessage, jmp L2>
    End_While
L2: mov B$edi 0

    mov B$Errorlevel 9 | error D$ParenthesisPtr
ret
____________________________________________________________________________________________
________________________________________________________________________________________________
NewCountStatements:
  ; How many statements:
    mov B$ErrorLevel 0
    mov esi D$CodeSourceA, D$StatementsCounter 0, D$LinesCounter 0
    mov B$DontCountNext &FALSE
    mov ebx esi | add ebx D$StripLen

    .While esi < ebx
        .If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign
        .Else_If B$esi = LF
            mov B$DontCountNext &FALSE
        .Else_If B$esi = '|'
            mov B$DontCountNext &FALSE
        .Else_If B$esi = '['
            inc D$LinesCounter
            .Do
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                End_If
                inc esi
            .Loop_Until B$esi = ']'
            mov B$DontCountNext &FALSE
        .Else_If B$esi > ' '
            ..If B$esi <> '_'
                If B$DontCountNext = &FALSE
                    inc D$LinesCounter
                    mov B$DontCountNext &TRUE
                End_If
            ..End_If
        .End_If

        inc esi
    .End_While

; set mem tables:

L9: If D$LinesCounter = 0
        call CloseProgressBar
        call 'USER32.MessageBoxA' 0, {"RosAsm can't compile empty files", 0},
                                     {' Sorry', 0}, 0
        mov B$CompileErrorHappend &TRUE
        mov esp D$OldStackPointer | ret ; direct error
       ; pop eax | ret                  ; Abort, pop caller and return to Message Loop
    End_If

    mov eax D$LinesCounter | add eax 20 | shl eax 3  ; 2 > dword +1 > security
    push eax
        VirtualAlloc StatementsTable eax
    pop eax
    VirtualAlloc StatementsTable2 eax

;StoreStatements:

    mov ecx D$CodeSource | sub ecx D$CodeSourceA    ; Ajust from CodeSource to CodeSourceA.
    mov esi D$CodeSourceA, edi D$StatementsTable
    mov B$DontCountNext &FALSE
    move D$StatementsPtr D$StatementsTable | move D$edi esi | add D$edi ecx
    mov ebx esi | add ebx D$StripLen

    .While esi < ebx
        .If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign
        .Else_If B$esi = LF
            mov B$DontCountNext &FALSE
        .Else_If B$esi = '|'
            mov B$DontCountNext &FALSE
        .Else_If B$esi = '['

            mov eax esi | add eax ecx | stosd | add D$StatementsPtr 4

            .Do
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                End_If

                inc esi
            .Loop_Until B$esi = ']'

            mov B$DontCountNext &FALSE

        .Else_If B$esi > ' '
            ..If B$esi <> '_'
                If B$DontCountNext = &FALSE
                    mov eax esi | add eax ecx | stosd | add D$StatementsPtr 4
                    mov B$DontCountNext &TRUE
                End_If
            ..End_If
        .End_If

        inc esi
    .End_While

    mov eax 0 | stosd
ret
________________________________________________________________________________________________
________________________________________________________________________________________________
; As of now a '_' outside a Win_equate is the same '' like it is supposed to be according to
; RosAsm help.

StripUnderscore:
    mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = TextSign
            Do | movsb | Loop_Until B$esi = TextSign
        .Else_If B$esi = '&'
            If B$esi+1 > '9'
                Do | movsb | Loop_Until B$esi <= ' '
            End_If
        .Else_If B$esi = '_'
            Do | inc esi | Loop_Until B$esi <> '_'
        .End_If
        movsb
    .End_While

    mov ecx edi
    sub ecx D$CodeSourceB
    mov D$StripLen ecx

    Exchange D$CodeSourceA D$CodeSourceB
ret
________________________________________________________________________________________________
; To simplify operations, the source is converted to a special format called MyAscii.

[LowSigns            31
    TextSign            30

  NoSpaceAfterThis    29
    numSign             28   ; #  01C
    IfNumSign           27   ; Substitute of # for the Conditional macros #If, ... 01B

    OpenParaMacro       26   ; { for ParaMacros  01A
  NoSpaceBeforeThis   25
    CloseParaMacro      24   ; } for ParaMacros

    CommaSign           23   ; ,

    OpenVirtual         22   ; [   016 (Macros expanded '[' -{-)
    CloseVirtual        21   ; ]   015 (Macros expanded ']' -}-) 019
    OpenBracket         20   ; [   014
    CloseBracket        19   ; ]   013
; 18, 17 >>> NewOpenBracket / NewCloseBracket
  PartEnds            16
    memMarker           15   ; $ or $  exemple: MOV B$MYVALUE 1
    colonSign           14   ; :
    openSign            13   ; (
    closeSign           12   ; )

  OperatorSigns       11
    addSign             10   ; +
    subSign              9   ; -
    mulSign              8   ; *
    divSign              7   ; /
    expSign              6   ; ^
; 5
  Separators          4
   ; Statement           0FF
    Space               3    ; space
    EOI                 2    ; |  End Of Instruction (separator)
    meEOI               1]   ; |  End Of Instruction in macro expansion
                             ; 0 is used as erase sign inside treatements


[MyAsciiTable: B$ 0,1,2,3,4,5,6,7,8,Space,EOI,11,12,EOI,14,15,16,17,18,19,20,21,
 22,23,24,25,26,27,28,29,30,31,Space,'!','"',NumSign,memMarker,'%','&',39,OpenSign,
 CloseSign, MulSign,AddSign,CommaSign,SubSign,'.',DivSign,48,49,50,51,52,53,54,
 55,56,57, ColonSign,';','<',61,'>','?','@'
 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90 ; (A > Z)
 Openbracket,'\',Closebracket,expSign,95,96
 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90 ; (A > Z)
 '{',EOI,'}',126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143
 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164
 165,166,memMarker,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,
 184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,
 205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,
 226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,
 247,248,249,250,251,252,253,254,255]

TranslateAsciiToMyAscii:
    mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen, ebx 0
    add ecx D$CodeSourceA

    .While esi < ecx
        If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign

        Else
            mov bl B$esi
            mov al B$ebx+MyAsciiTable
            mov B$esi al

        End_If

        inc esi
    .End_While
ret
________________________________________________________________________________________________

StripUnneededSpaces:
    mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = TextSign
            Do | movsb | Loop_Until B$esi = TextSign | movsb
        .Else_If B$esi = Space
            ..If B$esi+1 = OpenSign
                If B$edi-1 = CloseSign
                    movsb
                Else_If B$edi-1 = CloseParaMacro
                    movsb
                Else_If B$edi-1 < NoSpaceAfterThis
                    inc esi
                Else
                    movsb
                End_If
            ..Else_If B$esi+1 < NoSpaceBeforeThis
                inc esi
            ..Else_If B$edi-1 < NoSpaceAfterThis
                If B$edi-1 = CloseSign
                    movsb
                Else_If B$edi-1 = CloseParaMacro
                    movsb
                Else
                    inc esi
                End_If
            ..Else_If B$esi+1 = '}'
                inc esi
            ..Else_If B$esi-1 = '{'
                inc esi
            ..Else
                movsb
            ..End_If
        .Else
            movsb
        .End_If
    .End_While

    mov ecx edi | sub ecx D$CodeSourceB | mov D$StripLen ecx

    Exchange D$CodeSourceA D$CodeSourceB
ret
____________________________________________________________________________________________

; Remaining some valid Comma. Example "mov eax, -1".

ConvertCommasToSpace:
    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    While esi < ecx
        On B$esi = CommaSign, mov B$esi Space
        inc esi
    End_While
ret
________________________________________________________________________________________________
StripUnneededEOI:
    mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

; Ensure that the source starts with an EOI
    If B$esi <> EOI
        mov B$edi EOI
        inc edi
    End_If

    .While esi < ecx
        .If B$esi = TextSign
            Do | movsb | Loop_Until B$esi = TextSign | movsb
        .Else_If B$esi = EOI
            ..If B$esi+1 = EOI
                inc esi
            ..Else_If B$esi+1 = CloseBracket
                inc esi
            ..Else_If B$esi+1 = OpenBracket
                If B$edi-1 = CloseBracket
                    inc esi
                Else
                    movsb
                End_If
            ..Else
                movsb
            ..End_If
        .Else
            movsb
        .End_If
    .End_While

    mov ecx edi
    sub ecx D$CodeSourceB
    mov D$StripLen ecx

    mov B$edi EOI,  B$edi+1 EOI | add D$Striplen 2          ; write end mark '||'

    Exchange D$CodeSourceA D$CodeSourceB
ret
____________________________________________________________________________________________

ConvertEOIinBracketsTOmeEOI:
    mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen, ebx 0 | add ecx D$CodeSourceA

    mov B$InsideBrackets &FALSE

    .While esi < ecx
        .If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign
        .Else_if B$esi = OpenBracket
            mov B$InsideBrackets &TRUE
        .Else_if B$esi = CloseBracket
            mov B$InsideBrackets &FALSE
        .Else_if B$esi = EOI
            If B$InsideBrackets = &TRUE
                mov B$esi meEOI
            End_If
        .End_If
        inc esi
    .End_While
ret
________________________________________________________________________________________________
ConvertTextSigns:
    mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = '"'
            mov B$esi TextSign
            Do | inc esi | Loop_Until B$esi = '"'
            mov B$esi TextSign
        .ElseIf B$esi = "'"
            mov B$esi TextSign
            Do | inc esi | Loop_Until B$esi = "'"
            mov B$esi TextSign
        .End_If
        inc esi
    .End_While
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  Automatic Labels (created by the Assembler, for example, with the "&0" Macro Key,
  are 8 Bytes Long. Example: ZZZZZZZZ: (See 'NoMeanLabel').
  
  The user cannot make use of this form of Labels.
;;

NoAutomaticLabel:
    mov esi D$CodeSourceA, edx esi | add edx D$Striplen

    .While esi < edx
        If B$esi = TextSign
            inc esi
            While B$esi <> TextSign | inc esi | End_While
        End_If

        ..If B$esi = 'Z'
            .If B$esi-1 < LowSigns
                If D$esi = 'ZZZZ'
                  ; We have something begining with 'ZZZZ'. Must 8 chars long: 'ZZZZZZZ'
                    cmp B$esi+8 LowSigns | ja L2>

                    cmp B$esi+7 LowSigns | jb L2>
                    cmp B$esi+6 LowSigns | jb L2>
                    cmp B$esi+5 LowSigns | jb L2>
                    cmp B$esi+4 LowSigns | jb L2>

                        mov B$esi+9 0, B$Errorlevel 9 | error ZZZZreserved, esi

                End_If
            .End_If
        ..End_If

L2:     inc esi
    .End_While
ret
________________________________________________________________________________________________
; The way local symbols are defined in the RosAsm syntax needs to be reviewed. Until that is
; properly done (somewhere in the future) this routine will have to do. :)

[LastFoundLabel: B$ ? #80]
;;
  Beware: This Routine is called twice:
  
  First time from inside the HotParsers, to expand the 'normal' @Locals
  
  A second time for 'AsmMain', after the Equates and Macros Jobs, to expand the
  @Locals inserted by Macros Evocations.
;;
ExtendLocalSymbols:
    mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

    mov B$LastFoundLabel 0

    .While esi < ecx
        ...If B$esi = TextSign
            Do | movsb | Loop_Until B$esi = TextSign

        ...Else_If B$esi = ColonSign
          ; On '::' don't process (as the label is already stored):
            ..If B$esi-1 < LowSigns
                ; Error holded downward.

            ..Else_If B$esi-1 <> ColonSign
              ; nonlocal label, as local labels are always 2 characters:
                .If B$esi-3 > LowSigns
                    push esi
                    mov al 0
                    Do | dec esi | On B$esi = '@', mov al 1 | Loop_Until B$esi < LowSigns
                    If al = 1
                        pop esi

                    Else
                        pop eax
                        inc esi
                        mov ebx LastFoundLabel
                        Do | lodsb | mov B$ebx al | inc ebx | Loop_Until B$esi = ColonSign
                        mov B$ebx 0
                    End_If

                .End_If
            ..End_If

        ...Else_If B$esi = OpenBracket
            mov ebx esi | inc ebx
            While B$ebx > LowSigns | inc ebx | End_While
            If B$ebx = meEOI
                While B$esi <> CloseBracket | movsb | End_While
            End_If

        ...Else_If B$esi = '@'
            If B$esi-1 < LowSigns
                mov ebx LastFoundLabel
                While B$ebx <> 0
                    mov al B$ebx | inc ebx | stosb
                End_While
            Else_if B$esi-2 < LowSigns
                mov al memMarker | stosb
                mov ebx LastFoundLabel
                While B$ebx <> 0
                    mov al B$ebx | inc ebx | stosb
                End_While
            End_If

            Do | movsb | Loop_Until B$esi < LowSigns
        ...End_If

        movsb
    .End_While

    mov ecx edi | sub ecx D$CodeSourceB | mov D$StripLen ecx

    Exchange D$CodeSourceA D$CodeSourceB
ret
________________________________________________________________________________________________
[VirtualDataFlag: B$ ?]

IdentifyVirtualData:
    mov esi D$CodeSourceA, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign
        .Else_If B$esi = OpenBracket
            mov edx esi, B$VirtualDataFlag &FALSE
            .Do
                inc esi
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                Else_If B$esi = '{'
                    Do | inc esi | Loop_Until B$esi = '}'
                Else_If B$esi = '?'
                    mov B$VirtualDataFlag &TRUE
                End_If
            .Loop_Until B$esi = CloseBracket

            If B$VirtualDataFlag = &TRUE
                mov B$edx OpenVirtual, B$esi CloseVirtual
            End_If
        .End_If
        inc esi
    .End_While
ret
________________________________________________________________________________________________
; The source in CodeSourceA is reorders to: Data/Equates/Macro, Virtual Data, Code..

ReorderSource:
    mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

    move D$StatementsPtr D$StatementsTable, D$StatementsPtr2  D$StatementsTable2

; Copy Brackets to CodeSourceB:

  ; this might be needed to skip first EOI if present.
    On B$esi = EOI, inc esi

    .While esi < ecx
        .If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign | inc esi

        .Else_If B$esi = OpenBracket
            lea edx D$esi+1

            .Do
                If B$esi = TextSign
                    Do | movsb | Loop_Until B$esi = TextSign
                End_If
                movsb

            .Loop_Until B$esi = CloseBracket
            movsb

            mov eax D$StatementsPtr, eax D$eax
            mov ebx D$StatementsPtr2, D$ebx eax
            add D$StatementsPtr2 4 | On D$edx <> 'ZZZZ', add D$StatementsPtr 4

        .Else_If B$esi = OpenVirtual
            .Do
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                End_If
                inc esi
            .Loop_Until B$esi = CloseVirtual
            inc esi

            add D$StatementsPtr 4

        .Else_If B$esi = EOI
            If B$esi-1 = CloseBracket
                ; nop
            Else_If B$esi-1 = CloseVirtual
                ; nop
            Else_If B$esi-1 = EOI
                ; nop
            Else
                add D$StatementsPtr 4
            EndIf
            inc esi
        .Else
            inc esi
        .End_If
    .End_While

    mov esi D$CodeSourceA

  ; Copy Virtual to CodeSourceB.
  ; this might be needed to skip first EOI if present.
    If B$esi = EOI
        inc esi
    End_If

    move D$StatementsPtr D$StatementsTable

    .While esi < ecx
        .If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign | inc esi

        .Else_If B$esi = OpenBracket
            .Do
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                End_If
                inc esi
            .Loop_Until B$esi = CloseBracket
            inc esi

            add D$StatementsPtr 4

        .Else_If B$esi = OpenVirtual
            lea edx D$esi+1

            .Do
                If B$esi = TextSign
                    Do | movsb | Loop_Until B$esi = TextSign
                End_If
                movsb
            .Loop_Until B$esi = CloseVirtual
            movsb

            mov eax D$StatementsPtr, eax D$eax
            mov ebx D$StatementsPtr2, D$ebx eax
            add D$StatementsPtr2 4 | On D$edx <> 'ZZZZ', add D$StatementsPtr 4

        .Else_If B$esi = EOI
            If B$esi-1 = CloseBracket
                ; nop
            Else_If B$esi-1 = CloseVirtual
                ; nop
            Else_If B$esi-1 = EOI
                ; nop
            Else
                add D$StatementsPtr 4
            EndIf
            inc esi

        .Else
            inc esi

        .End_If
    .End_While


    mov B$edi EOI
    inc edi

    mov esi D$CodeSourceA

  ; Copy the other statements to CodeSourceB.
  ; this might be needed to skip first EOI if present.
    If B$esi = EOI
        inc esi
    End_If

    move D$StatementsPtr D$StatementsTable

    .While esi < ecx
        .If B$esi = TextSign
            Do | movsb | Loop_Until B$esi = TextSign | movsb

        .Else_If B$esi = OpenBracket
            .Do
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                End_If
                inc esi
            .Loop_Until B$esi = CloseBracket
            inc esi
            add D$StatementsPtr 4

        .Else_If B$esi = OpenVirtual
            .Do
                If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                End_If
                inc esi
            .Loop_Until B$esi = CloseVirtual
            inc esi
            add D$StatementsPtr 4

        .Else_If B$esi = EOI
            If B$esi-1 = CloseBracket
                ; nop
            Else_If B$esi-1 = CloseVirtual
                ; nop
            Else_If B$esi-1 = EOI
                ; nop
            Else
                mov eax D$StatementsPtr, eax D$eax
                mov ebx D$StatementsPtr2
                mov D$ebx eax

                add D$StatementsPtr 4
                add D$StatementsPtr2 4
            EndIf
            movsb

        .Else
            movsb

        .End_If
    .End_While

    mov ecx edi
    sub ecx D$CodeSourceB
    mov D$StripLen ecx

    mov eax D$StatementsPtr2, D$eax 0

    Exchange D$CodeSourceA D$CodeSourceB
    Exchange D$StatementsTable D$StatementsTable2

    call StripNewlyAddedUnneededEOI
ret
____________________________________________________________________________________________

; called by 'ReorderSource' only. 'StripUnneededEOI' ('HotParsers') is a bit similar.

StripNewlyAddedUnneededEOI:

    mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen | add ecx D$CodeSourceA

    .While esi < ecx
        .If B$esi = TextSign
            Do | movsb | Loop_Until B$esi = TextSign | movsb

        .Else_If B$esi = EOI
            ..If B$esi+1 = EOI
                inc esi
            ..Else
                movsb
            ..End_If

        .Else
            movsb

        .End_If
    .End_While

    mov ecx edi | sub ecx D$CodeSourceB | mov D$StripLen ecx

  ; Write the end mark '||':
    mov B$edi EOI | inc D$Striplen
    If B$edi-1 <> EOI
        mov B$edi+1 EOI | inc D$Striplen
    End_If

    Exchange D$CodeSourceA D$CodeSourceB
ret
________________________________________________________________________________________________
____________________________________________________________________________________________

NewPrepareExport:
    VirtualFree D$ExportListAPtr, D$ExportListBPtr

    call NewHowManyExport

    If B$ExportsectionWanted = &TRUE
        call NewStoreToExportListA
        call NewSortExportListA
    End_If
ret


NewHowManyExport:
    mov B$ExportsectionWanted &FALSE

    mov esi D$CodeSourceA, ecx esi, ebx 0, edx 0 | add ecx D$StripLen

    .While esi < ecx
        .If W$esi = '::'
            mov B$ErrorLevel 9
            If B$esi+2 = ':'
                mov B$esi-1, EOI, B$esi+3 EOI
                error D$WhatIsThisPtr esi
            End_If
            While B$esi-1 > ' ' | dec esi | End_While
            While B$esi <> ':' | inc esi | inc ebx | End_While
            inc ebx
            inc edx
        .Else_If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign
       ; .Else_If B$esi = '['
       ;     .Do
       ;         If B$esi = TextSign
       ;             Do | inc esi | Loop_Until B$esi = TextSign
       ;         End_If
       ;         inc esi
       ;     .Loop_Until B$esi = ']'
        .End_If
        inc esi
    .End_While

    If edx > 0
        mov B$ExportsectionWanted &TRUE
        mov D$NumberOfExportedFunctions edx
        add ebx 40                           ; Header
        add ebx 255                          ; name room
        shl edx 4                            ; pointers > n*16 (*10 would be enough..)
        add ebx edx
        mov D$ExportSectionLen ebx
        push ebx
            VirtualAlloc ExportListAPtr ebx
        pop ebx
        VirtualAlloc ExportListBPtr ebx
    End_If
ret


NewStoreToExportListA:
    mov esi D$CodeSourceA, edi D$ExportListAPtr
    mov ecx esi | add ecx D$StripLen

    ..While esi < ecx
        ..If W$esi = '::'
            While B$esi-1 > ' ' | dec esi | End_While
            If B$esi = '@'
                mov B$esi-1 EOI
                While B$esi <> ':' | inc esi | End_While | mov B$esi+2 EOI
                mov B$ErrorLevel 9
                Error BadLabel, esi
            End_If
            While B$esi <> ':' | movsb | End_While
            mov al EOI | stosb

        ..Else_If B$esi = TextSign
            Do | inc esi | Loop_Until B$esi = TextSign

        ..Else_If B$esi = '['
            .Do
                .If B$esi = TextSign
                    Do | inc esi | Loop_Until B$esi = TextSign
                .Else_If W$esi = '::'
                    While B$esi-1 > ' ' | dec esi | End_While
                    If B$esi = '@'
                        mov B$esi-1 EOI
                        While B$esi <> ':' | inc esi | End_While | mov B$esi+2 EOI
                        mov B$ErrorLevel 9
                        Error BadLabel, esi
                    End_If
                    On B$esi = '[', inc esi
                    While B$esi <> ':' | movsb | End_While | movsb
                    mov al EOI | stosb
                    mov B$esi Space
                .End_If
                inc esi
            .Loop_Until B$esi = ']'

        ..End_If
        inc esi
    ..End_While
ret


; EvilBro: I haven't actually rewritten this routine yet.
NewSortExportListA:
    mov edi D$ExportListBPtr, ecx D$NumberOfExportedFunctions

L0: push ecx
        mov esi D$ExportListAPtr, ecx D$NumberOfExportedFunctions, edx 0, bl 0FF

L1:     lodsb
        .If al = 0FF
            ; nop
        .Else_If al < bl
            mov bl al | lea edx D$esi-1
        .Else_If al = bl
            push ebx
                push edx, esi
                    While al = bl
                        lodsb | inc edx | mov bl B$edx
                        cmp al EOI | je L2>
                    End_While
L2:             pop esi, edx
                On al < bl, lea edx D$esi-1
            pop ebx
        .End_If

        While B$esi > EOI
            inc esi
        End_While
        inc esi | loop L1<

        If edx > 0
            mov esi edx
            While B$esi > EOI
                movsb | mov B$esi-1 0FF
            End_While
            mov al EOI | stosb
        End_If

    pop ecx | dec ecx | cmp ecx 0 | ja L0<<

    Exchange D$ExportListAPtr D$ExportListBPtr
    mov edi D$ExportListBPtr, eax 0 | stosd | stosd | stosd | stosd | stosd
    mov eax D$NumberOfExportedFunctions | stosd | stosd
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; This shouldn't be here, but is now for development purposes.

FromDataToStructure:
    mov D$DisScale 4, D$EquateValue 0

    call 'User32.GetDlgItemTextA' D$DataToStructureDialogHandle, 10, D$DataTextTable, 01000
    On eax < 10, ret

    mov B$WeAreInTheCodeBox &TRUE
;    push D$CodeSource, D$SourceLen, D$SourceEnd
        mov eax esp, D$OldStackPointer eax, B$CompileErrorHappend &FALSE

        mov eax D$DataTextTable
        While B$eax > 0
            inc eax
        End_While
        mov B$eax CR, B$eax+1 LF | add eax 2
        inc eax

        sub eax D$DataTextTable
        push eax
            call GetAsmTables
        pop eax
        call NewCopyToCodeSourceA D$DataTextTable, eax ; D$DataTextTableLen

        call Coolparsers

        call NewCountStatements

        On B$CompileErrorHappend = &TRUE, jmp L9>>

        call Hotparsers | On B$CompileErrorHappend = &TRUE, jmp L9>>


        mov esi D$CodeSourceA, edi D$StructureTextTable, D$FirstDataLabel 0

        On B$esi = OpenBracket, inc esi
        mov B$edi '[' | inc edi

L0:     .While B$esi > EOI
            mov ebx esi
            While B$ebx > LowSigns | inc ebx | End_While
            .If B$ebx = ColonSign
                On D$FirstDataLabel = 0, mov D$FirstDataLabel esi
                While B$esi <> ColonSign | movsb | End_While
                mov B$edi ' ' | inc edi
                mov eax D$EquateValue | call WriteEax
                mov B$edi CR, B$edi+1 LF, B$edi+2 ' ' | add edi 3
            .Else_If B$ebx = MemMarker
                If B$ebx-1 = 'D'
                    mov D$DisScale 4
                Else_If B$ebx-1 = 'W'
                    mov D$DisScale 2
                Else_If B$ebx-1 = 'U'
                    mov D$DisScale 2
                Else_If B$ebx-1 = 'B'
                    mov D$DisScale 1
                Else_If B$ebx-1 = 'Q'
                    mov D$DisScale 8
                Else_If B$ebx-1 = 'R'
                    mov D$DisScale 8
                Else_If B$ebx-1 = 'F'
                    mov D$DisScale 4
                Else_If B$ebx-1 = 'T'
                    mov D$DisScale 10
                End_If
            .Else_If B$ebx = NumSign
                inc esi
                If B$esi = '0'
                    call TranslateHexa
                Else
                    call TranslateDecimal
                End_If
                mul D$DisScale | sub eax D$DisScale | add D$EquateValue eax | jmp L1>>
            .Else_If B$esi = '?'
                mov eax D$DisScale | add D$EquateValue eax
            .Else_If B$esi < '0'

            .Else_If B$esi > '9'

            .Else
                mov eax D$DisScale | add D$EquateValue eax
                While B$esi > LowSigns | inc esi | End_While
            .End_If
            inc esi
L1:     .End_While
        On D$FirstDataLabel = 0, jmp L9>

        inc esi | cmp B$esi EOI | ja L0<<

L2:     mov B$edi CR, B$edi+1 LF | add edi 2
        mov esi D$FirstDataLabel
        While B$esi <> ColonSign
            On B$esi = 0, jmp L9>
            movsb
        End_While
        mov D$edi 'SIZE', B$edi+4 ' ' | add edi 5
        mov eax D$EquateValue | call WriteEax
        mov B$edi ']', B$edi+1 0
        call 'User32.SetDlgItemTextA' D$DataToStructureDialogHandle, 11, D$StructureTextTable

L9:     call ReleaseAsmTables

;    pop D$SourceEnd, D$SourceLen, D$CodeSource
    mov B$WeAreInTheCodeBox &FALSE
ret

____________________________________________________________________________________________

EncodeDecode:
    mov B$WeAreInTheCodeBox &TRUE
;    push D$CodeSource, D$SourceLen, D$SourceEnd
      ; ('AsmMain' 'OutOnError')
        mov eax esp, D$OldStackPointer eax, B$CompileErrorHappend &FALSE

; What on earth is EncodeSource???
        mov eax EncodeSource ;, D$CodeSource eax
        While B$eax > 0
            inc eax
        End_While
        mov B$eax CR, B$eax+1 LF | add eax 2
        inc eax

;        mov D$SourceEnd eax |
[EncodeSourceLen: D$ ?]
        sub eax EncodeSource | mov D$EncodeSourceLen eax

        call GetAsmTables
        call NewCopyToCodeSourceA EncodeSource D$EncodeSourceLen

        call Coolparsers

        call NewCountStatements

        call ClearQwordCheckSum

        On B$CompileErrorHappend = &TRUE, jmp L9>>

        call Hotparsers

        On B$CompileErrorHappend = &TRUE, jmp L9>>
        call InitIndex1 | call InitIndex2

        Exchange D$CodeSourceA D$CodesourceB
        push D$SourceLen
            move D$SourceLen D$EncodeSourceLen
            move D$AsmTablesLength D$SourceLen
            call ReuseSourceAForCodeList
        pop D$SourceLen
        call InitIndex3

        call BuildData                          ; result 'CodeSourceB' > 'CodeSourceB'

        On B$CompileErrorHappend = &TRUE, jmp L9>>
        call InitDebugIpTable
        mov B$ErrorLevel 7                      ; For outOnError, Error

        call ReCodeLine | On B$CompileErrorHappend = &TRUE, jmp L9>>

      ; Prepare Text to show in the Code Hexa view:
        mov esi D$CodeOrigine, edi HexaCodeText
        While esi < D$CodeListPtr
            movzx eax B$esi | inc esi
            mov ebx eax | shr ebx 4
            and eax 0F | and ebx 0F
            mov al B$HexaTable+eax, bl B$HexaTable+ebx
            shl eax 8 | or eax ebx | or eax 020200000 | stosd
        End_While
        mov D$edi 0

      ; Disassemble: (DisMain)
        mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
        mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
        mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
        mov esi D$CodeOrigine, edi DecodeText
L0:     movzx eax B$esi | inc esi | call D$DisOp1+eax*4
        On B$DisFlag = DISDONE, jmp L0<
        mov D$edi 0

      ; In case of text organisation (sub edi 6, for example), we reset:
        If D$DummyDecodeText+4 <> 0
            mov eax DecodeText
            While B$eax-1 > 0
                dec eax
            End_While
            mov ecx DecodeText | sub ecx eax
            mov esi DecodeText | add esi 160-1 | mov edi esi | sub esi ecx
            std
L0:             movsb | cmp edi DecodeText | jae L0<
            cld
            mov D$DummyDecodeText 0, D$DummyDecodeText+4 0
        End_If

L9:     call ReleaseAsmTables

;    pop D$SourceEnd, D$SourceLen, D$CodeSource
    mov B$WeAreInTheCodeBox &FALSE

    mov D$EncodeSecurity 0 ; Ensure the Buffer never overflows
ret


EncodeError:
L0: mov ebx, esp | cmp ebx, D$OldStackPointer | jnb L1>
    pop ebx | jmp L0<
L1: sub esp 8 | call ErrorMessageBox 0, D$ErrorMessagePtr
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
; Some routines I haven't got round to deleting. :)

[StripLen: ?  TextDelimiter: ?  TextGoingOn: ?]

IsItFirstText:
    cmp B$TextGoingOn &FALSE | je L1>            ; if OFF > test if ON  needed
L0:   cmp al, B$TextDelimiter | jne L9>         ; if ON  > test if OFF needed
        Jmp L3>
L1: cmp al '"' | je L2>
      cmp al "'" | jne L9>
L2: mov B$TextDelimiter al
L3: mov al, TextSign | xor B$TextGoingOn &TRUE
L9: cmp B$TextGoingOn &TRUE
ret

IsItText:                                       ; called by many routines after cleaner
    cmp al, TextSign | jne L9>
L2: xor B$TextGoingOn &TRUE
L9: cmp B$TextGoingOn &TRUE
    ret

[IfItIsText | cmp al TextSign | jne M9>         ; macro a bit faster than 'call IsIttext'
 M0: stosb | lodsb | cmp al TextSign | jne M0<     ; when it fits
    jmp #1
 M9:]


; same as IsItFirstText, but simplified: no error check, no modification of AL. This
; is for other text ruling routines:

____________________________________________________________________________________________
____________________________________________________________________________________________
____________________________________________________________________________________________


TITLE Alternates
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
                             Pre-Parser (Alternate syntaxes).
____________________________________________________________________________________________

 None of these routines change the lenght of Data.
 None checks for any Error; Error are holded by downward computations.
;;

AlternatesPreParsers:
    call BToBS | call ByteToBS | call BytePtrToBS | call ImplicitSize
    call BracketsToPPBrackets
        call DbToBS
        call EqualToEquates | call EQUToEquates
    call ReWriteBrackets
ret
____________________________________________________________________________________________


; For Pre-Parser analyzes, we turn '[...]' for Data and Equates into:

[PP_OPEN_DATA 20    PP_CLOSE_DATA 21    PP_OPEN_EQU 22    PP_CLOSE_EQU 23]

BracketsToPPBrackets:
    mov esi D$CodeSourceA, edx D$StripLen, cl 0 | add edx esi

    .While esi < edx
        lodsb
        .If al = ';'
            While al <> LF
                lodsb | cmp esi edx | ja L9>>
            End_While
        .Else_If al = "'"
            Do
                lodsb | cmp esi edx | ja L9>>
            Loop_Until al = "'"
        .Else_If al = '"'
            Do
                lodsb | cmp esi edx | ja L9>>
            Loop_Until al = '"'
        .Else_If al = '['
            mov ebx esi
            While B$ebx = ' '
                inc ebx                         ; jump over possible leading spaces
            End_While
            While B$ebx > ' '
                inc ebx                         ; go to end of first word
            End_While
            If B$ebx-1 = ':'
L1:            mov B$esi-1 PP_OPEN_DATA         ; <<<<<<<<<<<<<<<<<<<<<<
                mov cl PP_OPEN_DATA

            Else   ; ( B$ebx = ' ' )
                While B$ebx = ' '
                    inc ebx                     ; Verify no [Symbol : (>Data) // CR/| (>Macro)
                End_While
                On B$ebx = ':', jmp L1<
                On B$ebx = CR, jmp L3>
                On B$ebx = '|', jmp L3>
                    mov B$esi-1 PP_OPEN_EQU     ; <<<<<<<<<<<<<<<<<<<<<<
                    mov cl PP_OPEN_EQU

          ;  Else_If B$ebx = CR // '|'
L3:            ; case of Macro (not used actually here...).
            End_If

        .Else_If al = ']'
            If cl = PP_OPEN_DATA
                mov B$esi-1 PP_CLOSE_DATA
            Else_If cl = PP_OPEN_EQU
                mov B$esi-1 PP_CLOSE_EQU
            End_If
            mov cl 0
        .End_If

    .End_While
L9: ret


; Turns "DD / DW / DB"   into:   "D$ / W$ / B$":

DbToBS:
    mov edi D$CodeSourceA, ecx D$StripLen

        mov al PPOPENDATA, bl PPCLOSEDATA

L3:     repne scasb
        .If ecx > 0
            push eax
                .While B$edi <> bl
                    mov eax D$edi | or eax 020202020
                    If B$edi = '"'
L1:                     inc edi | dec ecx | jz L7>>
                        cmp B$edi '"' | jne L1<
                    Else_If B$edi = "'"
L1:                     inc edi | dec ecx | jz L7>>
                        cmp B$edi "'" | jne L1<
                    Else_If eax = ' dd '
                        mov D$edi ' D$ '
                    Else_If eax = ' db '
                        mov D$edi ' B$ '
                    Else_If eax = ' dw '
                        mov D$edi ' W$ '
                    Else_If eax = ' dq '
                        mov D$edi ' Q$ '
                    Else_If eax = ' dr '
                        mov D$edi ' R$ '
                    Else_If eax = ' df '
                        mov D$edi ' F$ '
                    Else_If eax = ' dt '
                        mov D$edi ' T$ '
                    End_If
                    inc edi | dec ecx | jz L7>
                .End_While
L7:         pop eax
        .End_If

        cmp ecx 0 | ja L3<<
ret


; Replaces:  "One EQU 1"   by:   "One     1":

EQUToEquates:
    mov edi D$CodeSourceA, ecx D$StripLen

        mov al PPOPENEQU, bl PPCLOSEEQU

L3:     repne scasb
        .If ecx > 0
            push eax
                While B$edi <> bl
                    mov eax D$edi | or eax 020202020
                    If B$edi = '"'
L1:                     inc edi | dec ecx | jz L7>
                        cmp B$edi '"' | jne L1<
                    Else_If B$edi = "'"
L1:                     inc edi | dec ecx | jz L7>
                        cmp B$edi "'" | jne L1<
                    Else_If eax = ' equ'
                        mov al B$edi+4 | or al 020
                        On al = ' ', mov D$edi '    '
                    End_If
                    inc edi | dec ecx | jz L7>
                End_While
L7:         pop eax
        .End_If

        cmp ecx 0 | ja L3<
ret


; Replaces:  "One = 1"   by:   "One   1":

EqualToEquates:
    mov edi D$CodeSourceA, ecx D$StripLen

        mov al PPOPENEQU, bl PPCLOSEEQU

L3:     repne scasb
        ...If ecx > 0
            push eax
                While B$edi <> bl
                    ..If B$edi = '"'
L1:                     inc edi | dec ecx | jz L7>
                        cmp B$edi '"' | jne L1<
                    ..Else_If B$edi = "'"
L1:                     inc edi | dec ecx | jz L7>
                        cmp B$edi "'" | jne L1<
                    ..Else_If B$edi = '='
                        .If B$edi-1 = ' '
                            If B$edi+1 = ' '
                                mov B$edi ' '
                            End_If
                        .End_If
                    ..End_If
                    inc edi | dec ecx | jz L7>
                End_While
L7:         pop eax
        ...End_If

        cmp ecx 0 | ja L3<
ret


; Simple replace of 'Byte Ptr[Value]' by:
;                   'B$       Value '

BytePtrToBS:
    mov esi D$CodeSourceA | mov ecx esi | add ecx D$StripLen

    .While esi < ecx
        push esi

        mov eax D$esi, bl B$esi+4 | or eax 020202020 | or bl 020

        ...If B$esi = '"'
            pop eax
L1:         inc esi | cmp B$esi '"' | jne L1<
            push esi
        ...Else_If B$esi = "'"
            pop eax
L1:         inc esi | cmp B$esi "'" | jne L1<
            push esi
        ...Else_If eax = 'byte'
            mov dx 'B$', ebx 0 | jmp L1>>
        ...Else_If eax = 'dwor'
            If bl = 'd'
                mov dx 'D$', ebx 1 | jmp L1>>
            End_If
        ...Else_If eax = 'word'
            mov dx 'W$', ebx 0 | jmp L1>>
        ...Else_If eax = 'qwor'
            If bl = 'd'
                mov dx 'Q$', ebx 1 | jmp L1>>
            End_If
        ...Else_If eax = 'real'
            mov dx 'R$', ebx 0 | jmp L1>>
        ...Else_If eax = 'floa'
            If bl = 't'
                mov dx 'F$', ebx 1 | jmp L1>>
            End_If
        ...Else_If eax = 'tbyt'
            If bl = 'e'
                mov dx 'T$', ebx 1 | jmp L1>
            End_If
        ...Else_If eax = 'twor'
            If bl = 'd'
                mov dx 'T$', ebx 1 | jmp L1>
            End_If
        ...Else_If eax = 'owor'
            If bl = 'd'
                mov dx 'O$', ebx 1 | jmp L1>
            End_If
        ...Else_If eax = 'xwor'
            If bl = 'd'
                mov dx 'X$', ebx 1 | jmp L1>
            End_If

L1:         ..If B$esi-1 = ' '
                jmp L1>
            ..Else_If B$esi-1 = ','
                jmp L1>
            ..Else
                jmp L7>>
            ..End_If

L1:         mov eax esi | add esi 4 | add esi ebx

L2:         ..If B$esi = ' '
                While B$esi = ' '
                    inc esi | On esi > ecx, jmp L7>>
                End_While
                dec esi
                mov ebx D$esi | or ebx 020202020
                .If ebx = ' ptr'
                    add esi 4
                    While B$esi = ' '
                        inc esi | On esi > ecx, jmp L7>>
                    End_While
                    If B$esi = '['
                        mov W$eax dx | add eax 2
                        While B$eax <> '['
                            mov B$eax ' ' | inc eax | On B$eax = 13, jmp L7>
                        End_While
                        mov B$eax ' '
                        While B$eax <> ']'
                            inc eax | On B$eax = 13, jmp L7>
                        End_While
                        mov B$eax ' '
                    End_If
                .End_If
            ..End_If
        ...End_If
L7:     pop esi
        inc esi
    .End_While
ret


; Simple replace of 'Byte [Value]' by:
;                   'B$    Value '

ByteToBS:
    mov esi D$CodeSourceA | mov ecx esi | add ecx D$StripLen

    .While esi < ecx
        push esi
        mov eax D$esi, bl B$esi+4 | or eax 020202020 | or bl 020
        ...If B$esi = '"'
            pop eax
L1:         inc esi | cmp B$esi '"' | jne L1<
            push esi
        ...Else_If B$esi = "'"
            pop eax
L1:         inc esi | cmp B$esi "'" | jne L1<
            push esi
        ...Else_If eax = 'byte'
            mov dx 'B$', ebx 0 | jmp L1>>
        ...Else_If eax = 'dwor'
            If bl = 'd'
                mov dx 'D$', ebx 1 | jmp L1>>
            End_If
        ...Else_If eax = 'word'
            mov dx 'W$', ebx 0 | jmp L1>>
        ...Else_If eax = 'qwor'
            If bl = 'd'
                mov dx 'D$', ebx 1 | jmp L1>>
            End_If
        ...Else_If eax = 'real'
            mov dx 'R$', ebx 0 | jmp L1>>
        ...Else_If eax = 'floa'
            If bl = 't'
                mov dx 'F$', ebx 1 | jmp L1>>
            End_If
        ...Else_If eax = 'tbyt'
            If bl = 'e'
                mov dx 'T$', ebx 1 | jmp L1>
            End_If
        ...Else_If eax = 'twor'
            If bl = 'd'
                mov dx 'T$', ebx 1 | jmp L1>
            End_If
        ...Else_If eax = 'owor'
            If bl = 'd'
                mov dx 'O$', ebx 1 | jmp L1>
            End_If
        ...Else_If eax = 'xwor'
            If bl = 'd'
                mov dx 'X$', ebx 1 | jmp L1>
            End_If

L1:         ..If B$esi-1 = ' '
                jmp L1>
            ..Else_If B$esi-1 = ','

L1:             mov eax esi | add esi 4 | add esi ebx

                While B$esi = ' '
                    inc esi | On esi > ecx, jmp L7>>
                End_While
                .If B$esi = '['
                    mov W$eax dx | add eax 2
                    While B$eax <> '['
                        mov B$eax ' ' | inc eax | On B$eax = 13, jmp L7>
                    End_While
                    mov B$eax ' '
                    While B$eax <> ']'
                        inc eax | On B$eax = 13, jmp L7>
                    End_While
                    mov B$eax ' '
                .End_If
            ..End_If
        ...End_If
L7:     pop esi
        inc esi
    .End_While
ret


[ImplicitReg: ? ?  EndOfImplicitReg: ?   ImplicitRegSize: ?]

; Replaces  mov eax [ebx]  by  mov eax D$ebx. It never changes the Source size because
; "mov eax [ebx]"  and  "mov eax D$ebx" are same text length.

ImplicitSize:
    mov esi D$CodeSourceA, edi D$CodeSourceB | mov ecx esi | add ecx D$StripLen

L0: .While esi < ecx

        ...If B$esi = '"'
L1:         movsb | cmp B$esi '"' | jne L1<
            movsb
        ...Else_If B$esi = "'"
L1:         movsb | cmp B$esi "'" | jne L1<
            movsb
        ...Else_If B$esi = '['
            mov ebx esi | dec ebx
            ..If B$ebx = ' '
                jmp L1>
            ..Else_If B$ebx = ','

L1:             dec ebx | cmp B$ebx ' ' | je L1<
                          cmp B$ebx ',' | je L1<
                mov B$OneOperandwBit 0FF
                .If B$ebx > ' '                             ; mov eax [ebx]
                    dec ebx
                    While B$ebx > ' '
                        dec ebx                             ; Search start of 'eax'
                    End_While
                    On B$ebx <> ' ', jmp L3>
                        inc ebx
                        pushad
                            mov esi ebx, edi ImplicitReg
                            While B$esi > ' '
                                lodsb | and al 00_1101_1111 | stosb               ; upper case
                                On edi = EndOfImplicitReg, jmp L2>
                            End_While                                             ; wanted for
                            mov B$edi Space | mov esi ImplicitReg | call IsItaReg ; IsItaReg
L2:                     popad

                        cmp B$OneOperandwBit 0FF | jne L4>
                      ; Case of "mov [ebx] eax":
L3:                         While B$ebx <> ']'
                                inc ebx | On B$ebx = CR, jmp L7>>
                            End_While
                            inc ebx | On B$ebx <> ' ', jmp L7>>
                            While B$ebx = ' '
                                inc ebx
                            End_While
                            pushad
                                mov esi ebx, edi ImplicitReg
                                While B$esi > ' '
                                    lodsb | and al 00_1101_1111 | stosb               ; upper case
                                    On edi = EndOfImplicitReg, jmp L2>
                                End_While                                             ; wanted for
                                mov B$edi Space | mov esi ImplicitReg | call IsItaReg ; IsItaReg
L2:                         popad

                        cmp B$OneOperandwBit 0FF | je L7>
L4:                     cmp B$OneOperandwBit ByteSize | jne L4>
                            mov ax 'B$' | stosw | jmp L5>
L4:                     cmp B$OneOperandwBit WordSize | jne L4>
                            mov ax 'W$' | stosw | jmp L5>
L4:                     cmp B$OneOperandwBit DoubleSize | jne L7>
                            mov ax 'D$' | stosw

L5:                     inc esi
L5:                     cmp B$esi ']' | je L6>
                        cmp B$esi 14 | jb L7>
                            movsb | jmp L5<
L6:                         inc esi | jmp L0<<
L7:                     movsb

                .Else
                    movsb

                .End_If

             ..Else
                  movsb

             ..End_If

         ...Else
            movsb

         ...End_If
     .End_While

    Exchange D$CodeSourceA D$CodeSourceB
ret


; Simple replace of 'B[Value]' by:
;                   'B$Value '
;                   'B [Value]' >>>

BToBS:
    mov esi D$CodeSourceA | mov ecx esi | add ecx D$StripLen

    .While esi < ecx
        ...If B$esi = '"'
L1:         inc esi | cmp B$esi '"' | jne L1<
        ...Else_If B$esi = "'"
L1:         inc esi | cmp B$esi "'" | jne L1<
        ...Else_If B$esi = '['
            mov ebx esi | dec ebx
            While B$ebx = ' '
                dec ebx
            End_While
            ..If B$ebx-1 = ' '
                jmp L1>
            ..Else_If B$ebx-1 = ','
L1:             mov al B$ebx | or al 020
                .If al = 'd'
                    jmp L2>>
                .Else_If al = 'b'
                    jmp L2>>
                .Else_If al = 'w'
                    jmp L2>>
                .Else_If al = 'b'
                    jmp L2>
                .Else_If al = 'q'
                    jmp L2>
                .Else_If al = 'r'
                    jmp L2>
                .Else_If al = 'f'
                    jmp L2>
                .Else_If al = 't'
                    jmp L2>
                .Else_If al = 'o'
                    jmp L2>
                .Else_If al = 'x'
L2:                 inc ebx
                    If B$ebx = '['
                        mov B$ebx '$'
                    Else
                        mov B$ebx '$'
                        While B$ebx <> '['
                            inc ebx
                        End_While
                        mov B$ebx ' '
                    End_If
                    While B$ebx <> ']'
                        inc ebx | On B$ebx = 13, jmp L7>
                    End_While
                    mov B$ebx ' '
                .End_If
            ..End_If
        ...End_If
L7:     inc esi
    .End_While
ret


; Last routine:

ReWriteBrackets:
    mov esi D$CodeSourceA | mov ecx esi | add ecx D$StripLen
    mov ebx 0
    .While esi < ecx
        mov al B$esi
        If al = PP_OPEN_DATA
            mov B$esi '['
        Else_If al = PP_CLOSE_DATA
            mov B$esi ']'
        Else_If al = PP_OPEN_EQU
            mov B$esi '['
        Else_If al = PP_CLOSE_EQU
            mov B$esi ']'
        End_If
        inc esi
    .End_While
ret
____________________________________________________________________________________________
























TITLE Assembler

;;

  'EncodeLines' 'NewSearchApiName'
____________________________________________________________________________________________
____________________________________________________________________________________________

 This part holds the various Routines envolved in the general Assembly process. No
 overall description can be given for them. The simpler way to understand the Assembler
 organisation is to start at 'AsmMain', and to follow up with Right-Click.

 At a TITLE point of vue, the Assembler is dispatched into 4 TITLEs:
 
 [Parsers] / [Assembler] / [AsmMain] / [Encoder]


 Just a quick description:
 
 Encodage of an instruction is done in 4 steps.

 In the first one, parameters are analyzed by '...ParameterAnalyze's routines. They
 tell us how many parameters, what kind of parameter each and if they are 'complex'
 (for exemple if SIB is needed); all needed variables and flags are set.

 In 'Encode', (second step) we do nothing else than 'routing' the more stupid way
 according with mnemonics and parameters. I did this this way to give the easiest
 access for new mnemonics adding. Killing to write but blazing fast and simple to
 maintain.

 When jumping out 'Encode', a third party performs ending fitting controls and writes
 true code in CodeList. This is this collection of small routines which names discribe
 the critical Intel significants like 'op_op_modReg2Rm_imm8'. I cut encodage itself
 in second and third steps just to make source shorter but these two steps are, in fact,
 one and same operation.

 At the very end of assembly job, a 'FillSymbol' routine fullfills the zeroed part of
 code with whished labels' adresses, either absolute or relative (at coding time these
 values may be unknown, and we work one pass. RosAsm is, as far as i know, the only
 one assembler that do it this way, with respect of user defined sizes).
____________________________________________________________________________________________
____________________________________________________________________________________________
;;

; some basic equates:
                    ; > (As concerned tables have 3 dwords per pointed resource),
                    ; > Allow 100 differents...

[MAXDIALOG 2100]     ; ... Dialogs.
[MAXMENU 2100]       ; ... Menus.
[MAXBITMAP 2100]     ; ... BitMaps
[MAXSTRINGS 2100]
[MAXFONT 2100]
[MAXWAVE 2100]
[MAXAVI 2100]
[MAXRCDATA 2100]
[MAXCURSOR 2100]
[MAXICON 2100]

[MAXRESOURCE 3500]   ; Allow, as a whole, 1000 different resources in one PE


[LINKERDEFAULT 0400000, DRIVERDEFAULT 010000]    [LinkerDllDefault: 0_1000_0000]

[tab 9
 CR 13
 LF 10
 CRLF 0A0D
 CRLF2 0A0D0A0D
 PageSize 01000
 ;PageMask 00_1111_0000_0000_0000   ; to check if a pointer reach next page
 PageMask 0FFFF_F000
 ByteHighbit  080
 WordHighbit  08000
 dWordHighBit 08000_0000]

; For Encoding of reg field:
[regEax  00_0000  regAx   00_0000  regAl   00_0000  regEcx  00_0001  regCx   00_0001
 regCl   00_0001  regEdx  00_0010  regDx   00_0010  regDl   00_0010  regEbx  00_0011
 regBx   00_0011  regBl   00_0011  regEsp  00_0100  regSp   00_0100  regAh   00_0100
 regEbp  00_0101  regBp   00_0101  regCh   00_0101  regEsi  00_0110  regSi   00_0110
 regDh   00_0110  regEdi  00_0111  regDi   00_0111  regBh   00_0111]

; For Encoding of the Segment Register (sreg) Field:
[regEs  0000_0000  regCs  0000_1000  regSs  0001_0000  regDs  0001_1000
 regFs  0010_0000  regGs  0010_1000]

; For Encoding of Special-Purpose Register (eee) Field
; (Control Registers and Debug Registers cannot be used in applications. There need
;  privilege 0 and are for system - not implemented in 'Encode:' MOV to/from Debug/Control
;  registers))
[regCr0  00_0000  regCr2  00_0010  regCr3  00_0011  regCr4  00_0100
 regDr0  00_0000  regDr1  00_0001  regDr2  00_0010
 regDr3  00_0011  regDr6  00_0110  regDr7  00_0111]

; For encoding of FPU regs:
[regST0 0  regST1 1  regST2 2  regST3 3  regST4 4  regST5 5  regST6 6  regST7 7]

; For encoding of MMX registers:
[regMM0 0  regMM1 1  regMM2 2  regMM3 3  regMM4 4  regMM5 5  regMM6 6  regMM7 7]


; For Encoding of Operand Size (w) Bit

[ByteSize    0000        ; true wBit, when encoding, can only be 0 (byte size) or
 wordSize    0011        ; 1 (full size). Word / Double size discrimination
 doubleSize  0001        ; will be done by Operand-size override (066 if bit 2 set)
 QuadSize  000100        ; for FPU
 TenSize   001000        ; for FPU
 HalfSize  001111        ; for Packed BCD
 FPUsize   001010        ; for 108 bytes of FPU image > now X$ !!!!!
 OctoSize 0010000        ; for XMM memories
 Xsize        0FF]       ; for 'Fitting' with specific unregular size Opcodes
;;
 following are to fill 'Operands', which is a global image of what operands in a line.
 in some unregular cases, AL, AX and EAX may have specific encodage we can't' guess
 while analysing parameters. having symbols in order allow tests like:
    cmp Operands, RegToMem | ja >L1    instead of:
    cmp operands, RegToMem | je >L1    which solves this problem in case of no use
 of possible Areg by an instruction encodage.
;;
[RegToReg  1
 MemToReg  2
 RegToMem  3
 ImmToReg  4
 ImmToMem  5
 RegToImm  6  ; yes...: for 'out imm8, accum'
 ImmToImm  7  ; for ENTER and OUT
 ;;;  MemToMem  8  ; for FPU ???

 reg   1    ; for general registers
 sReg  2    ; for segment register
 cReg  3    ; for control registers
 dReg  4    ; for debug registers
 imm   5    ; immediate values
 mem   6    ; for memory symbolic adresses (.$ Labels)
 dis   7
 STreg 8    ; for FPU regs
 MMreg 9    ; for MMX regs
 XMMreg 10] ; for XMM regs

[bMem  'B'  ; byte sized memory
 uMem  'U'  ; Unicode string
 wMem  'W'  ; word size memory
 dMem  'D'  ; double word size memory
 qMem  'Q'  ; height bytes size memory
 rMem  'R'  ; height bytes size for FPU real numbers
 tMem  'T'  ; Ten bytes size  for FPU real numbers
 hMem  'H'  ; Height bytes size for FPU real numbers (to keep a while....)
 fMem  'F'  ; Four bytes size for FPU real numbers
 oMem  'O'  ; OctoWords XMM sizes
 xMem  'X'  ; Weird and XMM sizes

 NotFound 0FF]

; Where to jump:
[DownLong   00_1000    ; ja L9>>
 DownShort  00_0100    ; jmp L7>
 UpLong        0010    ; jz L0<<
 UpShort       0001]   ; loop L5<

; Labels flags:

[DataLabelFlag 00_0010
 CodeLabelFlag 00_0100
 DoneFlag      00_0001]

____________________________________________________________________________________________
____________________________________________________________________________________________

; Main asm memories:

[AsmTablesLength: ?]

GetAsmTables:
    ;VirtualFree D$NewWinEquatesMem
    VirtualFree D$IpTable, D$StatementsTable, D$StatementsTable2
    VirtualFree D$PlainLabelList, D$EquateList, D$MacroData

    call GetResourcesSize

    add eax D$SourceLen | add eax 1_000_000 | add eax D$MemReservation
    mov D$AsmTablesLength eax
    VirtualAlloc CodeSourceA eax | add D$CodeSourceA 010

    ;mov eax D$SourceLen | add eax 1_000_000 | add eax D$MemReservation
    VirtualAlloc CodeSourceB D$AsmTablesLength | add D$CodeSourceB 010
ret


GetResourcesSize:
    mov esi CursorList, eax 0 | call AddResourcesSyze
    mov esi GroupCursorList | call AddResourcesSyze
    mov esi IconList | call AddResourcesSyze
    mov esi MenuList | call AddResourcesSyze
    mov esi DialogList | call AddResourcesSyze
    mov esi StringsList | call AddResourcesSyze
    mov esi GroupIconList | call AddResourcesSyze
    mov esi WaveList | call AddResourcesSyze
    mov esi AviList | call AddResourcesSyze
    mov esi RCdataList | call AddResourcesSyze
    mov esi BitMapList | call AddResourcesSyze
ret

AddResourcesSyze:
    While D$esi <> 0
        add eax D$esi+8 | add esi (4*3)
    End_While
ret


; clear memory (CodeList now is a reuse of CodeSourceB):

ReleaseAsmTables:
    VirtualFree D$CodeSourceA, D$CodeSourceB, D$LabelList, D$MacroList,
                D$CodeRef, D$DataRef, D$Relocation, D$ApiListA, D$ApiListB,
                D$DllList
    mov D$CookedErrorMessage 0

    If B$ProfilerFlag = &TRUE
        call ReleaseProfilerTables
        mov B$ProfilerFlag &FALSE
    End_If

ret


ReleaseMainFile:
    VirtualFree D$UserPeStart | mov D$CodeSource 0
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; Files access:
____________________________________________________________________________________________
____________________________________________________________________________________________

; 'Open File Name' Box:

[uFileFilter: ? #&MAX_PATH] [SaveFilter: ? #&MAX_PATH] [ChoosenFile: ? #&MAX_PATH]

[FilterPtr: 1  OpenFileTitle: 'Choose a file...' 0]

[UserPeStart: ?   UserPeLen: ?   UserPeEnd: ?]

[SourceHandle: 0 SourceLen: 0
 DestinationHandle: 0 DestinationLen: 0
 NumberOfReadBytes: 0
 SourceFile: B$ 'Src.b', 0]  ;;  DestinationFile: 'Dest2.exe', 0, '                       ']

; All the second 0 in lists declarations are for mem size. We need it for 'VirtualFree'

[CodeSource: ? ? CodeSourceA: ? ? CodeSourceB: ? ?]

;;
  Beware: 'CodeSource' is *not* the Memory Chunk Pointer. 'CodeSource' is a Pointer to
  the Source inside 'UserPeStart'. See, for example 'ReleaseMainFile'.
  
  For a direct Allocation/Re-Allocation, it must be, for example:
  > VirtualAlloc UserPeStart 1_000_000 | move D$CodeSource D$UserPeStart
  
  The only case 'CodeSource' is a real Memory Chunk is while disassembling. The switch
  between the two pointer, with the wished release, is done when the Disassembly is 
  finished.
;;

[InstructionAptr: ?  InstructionBptr: ?]

;;
  'MacroList': |NAME|dWord1 dWord2 Byte|
  
  dWord1: Ptr to MacroData // dWord2: Lenght of these Data // Byte: Done Flag
;;

[EquateList: ? ?  MacroData: ? ?  MacroList: ? ?  Relocation: ? ?  DataList: ? ?
 LabelList: ? ?   CodeList: ? ?   Coderef: ? ?    DataRef: ? ?     DllList: ? ?
 ApiListA: ? ?    ApiListB: ? ?]

; 'CodeRef' is: Dword | ... //... | Name | Dword1 dWord2 | // ....       ; 'CodeRefPtr'
;               ....|LabelName|........|LabelName|........|
; Where dWord is the Table Size.
; In the Records, Dword1 is a Pointer to CodeList and dWord2 a Pointer to Source.

; 'LabelList' is: Dword | ... // ...| Name | Dword1 Byte | // ....
; Where dWord is the Table Size.
; In the Records, Dword1 is the Pointer to CodeList, and Byte can be either/or:
; 'CodeLabelFlag', 'DataLabelFlag' , 'DoneFlag'

[DataRefLimit: ?  EquateListLimit: ? MacroListLimit: ? MacroDataLimit: ?
 LabelListLimit: ?]

[EquateListPtr: ?  MacroDataPtr: ?  MacroListPtr: ?  RelocationPtr: ?  DataListPtr: ?
 DataListPtrAtLastColon: ?
 LabelListPtr: ?   CodeListPtr: ?   CoderefPtr: ?    DataRefPtr: ?     DllListPtr: ?
 ApiListAPtr: ?    ApiListBPtr: ?]

[LenOfCode: ?  SourceReady: ?]

[SourceFilterPtr: 1  OpenSourceFileTitle: B$ 'Choose main asm file...' 0
                     OpenPEFileTitle: B$ 'Choose main RosAsm PE file...' 0
                     ChangeNameTitle:    'Change the PE File Name...', 0
                     SaveDlgNameTitle:   'Give the Dialog Template File Name', 0

 SourceFilesFilters: B$ 'Sources'     0  '*.asm'   0
                        'All'         0  '*.*'   0  0]

 ;[PEFilesFilters: B$ 'RosAsm PE'     0  '*.exe;*.scr;*.dll'   0  0]

[PEFilesFilters: B$ 'Files (*.exe, *.dll, *.wll, *.ocx, *.drv, *.bpl, *.cpl, *.fon, *.mpd, *.vbx, *.vxd, *.sys)', 0

'*.exe;*.dll;*.wll;*.ocx;*.drv;*.bpl;*.cpl;*.fon;*.mpd;*.vbx;*.vxd;*.sys', 0
                 B$ 'Executable Files (*.exe)', 0 '*.exe', 0
                 B$ 'Dll Files (*.dll, *.wll)', 0 '*.dll;*.wll', 0
                 B$ 'Delphi Dll Files (*.bpl)', 0 '*.bpl', 0
                 B$ 'Ocx Files (*.ocx)', 0 '*.ocx', 0
                 B$ 'Driver Files (*.drv)', 0 '*.drv', 0
                 B$ 'Cpl Files (*.cpl)', 0 '*.cpl', 0
                 B$ 'fon Files(*.fon)', 0 '*.fon', 0
                 B$ 'mpd Files(*.mpd)', 0 '*.mpd', 0
                 B$ 'vbx Files(*.ocx)', 0 '*.ocx', 0
                 B$ 'vbx Files(*.vbx)', 0 '*.vbx', 0
                 B$ 'vxd Files(*.vxd)', 0 '*.vxd', 0
                 B$ 'sys Files(*.sys)', 0 '*.sys', 0
                 B$ 'All Files', 0  '*.*', 0 0]

[OpenSourceStruc:  len
 hwndFileOwner: 0  OSSInstance: 0  SourceFilesFilters  uFileFilter  260
 1  SaveFilter  260  ChoosenFile  260  0    ; SaveFilter:  full Path/Name.ext
                                            ; ChoosenFile: only Name.ext
 OpenSourceFileTitle  0281804
 0  0  0  0  0]

[OpenPEStruc: len
 hwndPEFileOwner: 0  OPESInstance: 0  PEFilesFilters  uFileFilter  260
 1 SaveFilter  260  ChoosenFile  260  0
 OpenPEFileTitle  OpenPEStrucFlags: 0281804
 0  0  0  0  0]

; &OFN_NOCHANGEDIR
 _________________________________________________________________________________________


[WindowTitle Trash]

[SetWindowText | call SetRosAsmWindowText | push WindowTitle | push D$hwnd |
 call 'USER32.SetWindowTextA']

SetRosAsmWindowText:
    mov esi AppName, edi WindowTitle, ecx 8 | rep movsb
    While D$esi <> ' -V.' | inc esi | End_While
    mov B$edi ' '| inc edi
    While B$esi <> 0 | movsb | End_While
    mov D$edi '    '| add edi 4
    mov esi SaveFilter
    While B$esi <> 0 | movsb | End_While | mov B$edi 0
ret


;;
  CreateFile is called by 'LoadSrc' 'ReplaceSourceOnly' 'OpenRosAsmPE',
                          'DirectMRUload', 'DirectLoad', 'LastMRULoading',
                          'ReloadForDissassembler'
;;

CreateFile:

    If D$SourceHandle > 0
        push esi
            call 'KERNEL32.CloseHandle' D$SourceHandle
        pop esi
    End_If

    call 'KERNEL32.CreateFileA' esi, &GENERIC_READ, &FILE_SHARE_READ__&FILE_SHARE_WRITE,
                                0, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, &NULL


   .If eax = &INVALID_HANDLE_VALUE
        mov eax D$BusyFileptr | call MessageBox
        mov eax &INVALID_HANDLE_VALUE | ret

   .Else
        mov D$SourceHandle eax

   .End_If

   call 'KERNEL32.GetFileSize'  eax, 0 | mov D$SourceLen eax
ret

 _______________________________

; Opening file:

ClearSaveFilter:
   mov ecx (&MAX_PATH / 4), edi SaveFilter, eax 0 | rep stosd
ret


ClearChoosenFile:
   mov ecx (&MAX_PATH / 4), edi ChoosenFile, eax 0 | rep stosd
ret


LoadSrc:
    call CreateFile
  ; > eax = D$SourceLen
    On eax = &INVALID_HANDLE_VALUE, ret

    add eax 1_000_000

    push eax
        VirtualAlloc UserPeStart eax | move D$CodeSource D$UserPeStart
    pop eax

    add eax D$UserPeStart | Align_On PAGESIZE eax | sub eax 32
    mov D$EndOfSourceMemory eax

    mov edi D$CodeSource
      mov ax 0A0D, ecx 5
        rep stosw
          mov eax edi       ; security for back test like ESI or EDI - 2 (sys page fault)

    mov D$CodeSource eax, D$NumberOfReadBytes 0

    call 'KERNEL32.ReadFile' D$SourceHandle eax,                ; eax = mem buffer start
                            D$SourceLen NumberOfReadBytes 0

    call 'KERNEL32.CloseHandle' D$SourceHandle | mov D$SourceHandle 0

    mov edi D$CodeSource | add edi D$SourceLen | mov eax 0A0D0A0D, ecx 100 | rep stosd
    mov edi D$CodeSource, ecx 5 | sub edi 10 | rep stosw
    mov eax D$CodeSource | add eax D$SourceLen | mov D$SourceEnd eax
  ;  add eax 1_000_000 | mov D$EndOfSourceMemory eax
ret


; In case user wants to Load a Source Only and Resources are actually available, sends
; a warning Message:

[LosingResources: 'Delete actual Resources?', 0
 WarningTitle: ' Warning:', 0]

LooseResources:
    mov B$KeepResources &FALSE, eax 0
    or eax D$CursorList | or eax D$IconList | or eax D$MenuList
    or eax D$DialogList | or eax D$StringsList | or eax D$WaveList
    or eax D$AviList | or eax D$RCdataList | or eax D$BitMapList

    On eax = 0, ret

    mov B$KeepResources &TRUE

    .If D$NoResourcesPE = &FALSE
        call 'USER32.MessageBoxA' D$hwnd, LosingResources, WarningTitle,
                                 &MB_SYSTEMMODAL__&MB_ICONSTOP__&MB_YESNO
        If eax = &IDYES
            mov B$KeepResources &FALSE
        End_If
    .Else
        mov B$KeepResources &FALSE
    .End_If
ret

[LoadSource | mov esi #1 | call LoadSrc]


[MainName: B$ ? #&MAXPATH] [KeepResources: ?]

OpenSourceOnly:
    call ClearSaveFilter | call 'Comdlg32.GetOpenFileNameA' OpenSourceStruc

    On D$SaveFilter = 0, ret

L0: On B$SourceReady = &TRUE, call ReleaseMainFile

    VirtualFree D$UserPeStart

    call ClearBackTable | On B$KeepResources = &FALSE, call ReleaseResourceMemory

    LoadSource SaveFilter | StoreNameOnly SaveFilter

    mov B$SourceReady &TRUE | move D$UpperLine D$CodeSource

    call KillTabs | call KillTrailingSpaces

    SetWindowText
    move D$SavingExtension D$ExeExtension

    call StartEdition
ret


[IncludeLen: ?]

IncludeSource:
    call ClearSaveFilter | call 'Comdlg32.GetOpenFileNameA' OpenSourceStruc

    On D$SaveFilter = 0, ret

    call ClearBackTable

    call 'KERNEL32.CreateFileA' SaveFilter,
                                &GENERIC_READ, &FILE_SHARE_READ__&FILE_SHARE_WRITE,
                                0, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, &NULL
    If eax = &INVALID_HANDLE_VALUE
        mov eax D$BusyFilePtr | call MessageBox | ret
    Else
        mov D$SourceHandle eax
    End_If

    call 'KERNEL32.GetFileSize' eax, 0 | mov D$IncludeLen eax

    call ReMapSourceMemoryIfNeeded D$IncludeLen

    If eax = &IDNO
        call 'KERNEL32.CloseHandle' D$SourceHandle | mov D$SourceHandle 0 | ret
    End_If

  ; Ensure the inclusion will not break an existing line in two parts:
    mov edi D$CurrentWritingPos
    While B$edi-1 <> LF | inc edi | inc D$CurrentWritingPos |  End_While

  ; Make room inside actual Source by copying backward:
  ; esi at Source End // edi at Source End + whished room:
    mov esi D$SourceEnd | add esi 400
    mov edi esi | add edi D$IncludeLen | add edi 2      ; this '2' is for added CRLF at end.

  ; How many bytes to move = how many bytes between Source End and actual Pos:
    mov ecx D$SourceEnd | add ecx 400 | sub ecx D$CurrentWritingPos | inc ecx

    std | rep movsb | cld

    move D$BlockStartTextPtr D$CurrentWritingPos

    mov D$NumberOfReadBytes 0
    call 'KERNEL32.ReadFile' D$SourceHandle, D$BlockStartTextPtr, D$IncludeLen, NumberOfReadBytes, 0
    call 'KERNEL32.CloseHandle' D$SourceHandle | mov D$SourceHandle 0

    mov edi D$CurrentWritingPos | add edi D$IncludeLen | mov W$edi CRLF
    mov D$BlockEndTextPtr edi | dec D$BlockEndTextPtr

    mov eax D$IncludeLen | add eax 2 | add D$SourceLen eax | add D$SourceEnd eax
    mov B$BlockInside &TRUE

    mov esi D$BlockStartTextPtr, ecx D$BlockEndTextPtr | sub ecx esi
    call BlockCleaner
ret


[OpeningSourceOnly: ?]

ReplaceSourceOnly:  ; 'ControlS'
    mov B$KeepResources &TRUE

    ..If D$TitleTable = 0
L1:     call OpenSourceOnly | call LoadBookMarks

    ..Else
        mov B$OpeningSourceOnly &TRUE
      ; Tag Dialog 26001
        call 'USER32.DialogBoxParamA' D$hinstance, 26001, &NULL, AllOrPartProc, &NULL
        mov B$OpeningSourceOnly &FALSE

        .If B$AllOrPart = 0-1
            call RestoreRealSource | mov D$TiTleTable 0 | jmp L1<

        .Else_If B$AllOrPart = 1   ; 'OpenSourceOnly'
            call ClearSaveFilter | call 'Comdlg32.GetOpenFileNameA' OpenSourceStruc
            If D$SaveFilter <> 0
                mov esi SaveFilter | call CreateFile | On eax = &INVALID_HANDLE_VALUE, ret
                mov eax D$CodeSource | add eax D$SourceLen | mov D$SourceEnd eax
                mov D$NumberOfReadBytes 0
                call 'KERNEL32.ReadFile' D$SourceHandle, D$CodeSource, D$SourceLen,
                                         NumberOfReadBytes 0

                call 'KERNEL32.CloseHandle' D$SourceHandle | mov D$SourceHandle 0

                call KillTabs | call KillTrailingSpaces
            End_If
        .End_If

    ..End_If
ret


; In case of 'New' Internaly called because user attempted to load a 'no source inside'
; PE, we change the Saving File Name to 'NoName.exe':

[NoNameNewFile: 'NoName.exe' 0]
[NewFileBoxTitle: 'New File Name', 0]

NewFileNameDialog:
    call GetDirectory ActualDir

  ; Tag Dialog 5
    call 'USER32.DialogBoxParamA' D$hInstance, 5, D$hwnd, NewFileType, 0

    mov eax D$FileTypeChoice

    .If eax = 0-1
L8:     call SetDirectory ActualDir | jmp L9>>

    .Else
        call GetBaseName
X1:     mov edi D$BaseNamePointer
        mov ebx ActualDir
        While B$ebx <> 0 | inc ebx | End_While
        mov B$ebx '\' | inc ebx
        While B$esi <> 0
            mov al B$esi, B$edi al, B$ebx al
            inc esi, ebx, edi
        End_While
        mov B$edi 0, B$ebx 0
    .End_If

    call SetDirectory ActualDir

    call 'KERNEL32.CopyFileA', BaseFilesPath, ActualDir, &TRUE

    ..If eax = &FALSE
        call 'KERNEL32.GetLastError'

        .If eax = &ERROR_FILE_EXISTS

            call 'USER32.MessageBoxA' &NULL, {'Overwrite?', 0},
                                    {'File already exist', 0}, &MB_YESNO
            If eax = &IDYES
                call 'KERNEL32.CopyFileA', BaseFilesPath, ActualDir, &FALSE

            Else
                jmp L9>>
            End_If

        .Else
            jmp L8<<

        .End_If
    ..End_If

    mov esi ActualDir, edi SaveFilter
    While B$esi <> 0 | movsb | End_While | movsb

    call DirectLoad
    call ChangeName
    mov B$SourceReady &TRUE
    call AskForRedraw
    call ReInitUndo
    call SetPartialEditionFromPos | call EnableMenutems
    call LoadBookMarks
L9: ret


ChangeName:
    or D$OpenPEStrucFlags &OFN_OVERWRITEPROMPT
    mov D$OpenPEStruc+(12*4) NewFileBoxTitle
    call 'Comdlg32.GetSaveFileNameA' OpenPEStruc
    mov D$OpenPEStruc+(12*4) &NULL
    On eax = &FALSE, ret

    xor D$OpenPEStrucFlags &OFN_OVERWRITEPROMPT | jmp L1>
AutoNew:
    mov edi SaveFilter, eax 0, ecx 65 | rep stosd


    mov edi SaveFilter

NewEmptyFromMenu:
    mov esi NoNameNewFile
    While B$esi > 0
        movsb
    End_While
    movsb

L1: call SaveNewFileName
    On eax = &FALSE, jmp NewFileNameDialog
    push eax
        SetWindowText
    pop eax
  ; (If here, eax = D$SourceLen)
    xor D$OpenPEStrucFlags &OFN_OVERWRITEPROMPT
    mov eax &TRUE
ret
____________________________________________________________________________________________

;;
  ID in RcData (Files in E:\RosAsm\Start\):
  
  ID 1: Menu
    10: Low/LowStart/Menu      'LowStartMenu.exe'
    11: Low/LowStart           'LowStart.exe'
    20: StandardMacros
    21:     Standard/StandardStart/Menu
    22:     Standard/StandartStart/
    40: HllMacros <<<<<<<<<<<<<<<<<<<< Removed: Now Standard + PREPARSE Equal.
    41:     HLL/HllStart/Menu
    42:     HLL/HllStart
    50: Dll/Standard or HLL
    51: DLL/Low
;;

[PreParseEqual: "PREPARSE Equal


", 0]

FillNewSource:
    mov edi D$CodeSource, bl B$FileTypeChoice+1
    If bl = 20
      ; Standart macros:
        call GetRcData 20 | rep movsb
    Else_If bl = 21
      ; HLL Macros:
        call GetRcData 20 | rep movsb
        mov esi PreParseEqual
        While B$esi <> 0 | movsb | End_While
    End_If

L1: mov al B$FileTypeChoice

      ; exe/Start/Menu:
        .If al = 10
          ; Menu:
            call GetRcData 1
            push esi, edi, ecx, ebx
                VirtualAlloc Trash, ecx
            pop ebx, ecx, edi, esi
            mov D$MenuList 2000, D$MenuList+4 eax, D$MenuList+8 ecx
            lea eax D$MenuList+12 | mov D$MenuListPtr eax

            push edi
                mov edi D$Trash | rep movsb
            pop edi

            If bl = 20
              ; Standard/StandardStart/Menu
                call GetRcData 21 | rep movsb
            Else_If bl = 21
              ; HLL/HllStart/Menu
                call GetRcData 41 | rep movsb
            Else
              ; Low/LowStart/Menu      'LowStartMenu.exe'
                call GetRcData 10 | rep movsb
            End_If

      ; exe/Start:
        .Else_If al = 11
            If bl = 20
              ; Standard/StandardStart
                call GetRcData 22 | rep movsb
            Else_If bl = 21
              ; HLL/HllStart
                call GetRcData 42 | rep movsb
            Else
              ; exe/LowStart
                call GetRcData 11 | rep movsb
            End_If

      ; exe (empty Source):
        .Else_If al = 12
            On bl = 22, jmp L9>>

      ; dll/StandartStart:
        .Else_If al = 13
            If bl = 22
                call GetRcData 51
            Else
                call GetRcData 50
            End_If
            rep movsb

      ; dll (empty Source)
        .Else_If al = 14
            ;
        .End_If

L1: mov D$edi CRLF2 | add edi 4 | mov D$SourceEnd edi
    mov ecx edi | sub ecx D$CodeSource | mov D$SourceLen ecx

    mov eax CRLF2, ecx 100 | rep stosd

L9: call GetEditWindowClientRectangle
    mov D$TitleTable 0, D$PreviousPartialSourceLen 0

    mov B$OnReplaceAll &FALSE, B$BlocKInside &FALSE, B$DownSearch &TRUE, B$ReadyToRun &FALSE
    call StorePosInBackTable

L9: ret


Proc GetRcData:
    Argument @ID
    Local @Handle
    Uses edi

        call 'KERNEL32.FindResourceA' D$hInstance, D@ID, &RT_RCDATA
        mov D@Handle eax
        call 'KERNEL32.SizeofResource' D$hInstance, D@Handle
        push eax
            call 'KERNEL32.LoadResource' D$hInstance, D@Handle
            call 'KERNEL32.LockResource' eax
            mov esi eax
        pop ecx
EndP
____________________________________________________________________________________________

____________________________________________________________________________________________

[FileTypeChoice: ?  NewChoiceListHandle: ?]

; Tag Dialog 5

Proc NewFileType:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND
        ..If D@wParam = &IDCANCEL
L0:         mov D$FileTypeChoice 0-1
L1:         call 'User32.EndDialog' D@Adressee 0

        ..Else
            .If W@wParam = 10
                If W@wParam+2 = &LBN_DBLCLK
                    call 'USER32.SendMessageA' D$NewChoiceListHandle, &LB_GETCURSEL, 0, 0
                    inc eax | mov D$FileTypeChoice eax | jmp L1<

                End_If

            .End_If

        ..End_If

    ...Else_If D@Message = &WM_INITDIALOG
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon

        call 'USER32.GetDlgItem' D@Adressee, 10 | mov D$NewChoiceListHandle eax

        call SetBaseList

    ...Else
        popad | mov eax &FALSE | ExitP

    ...End_If

    popad | mov eax &TRUE
EndP


Proc SetNewChoice:
    Arguments @ListHandle, @Pointer

        pushad
            call 'USER32.SendMessageA' D@ListHandle, &LB_ADDSTRING, 0, D@Pointer
        popad
EndP


[BaseFilesPath: ? #&MAXPATH]

[BaseNamePointer: 0

 BasesNames:
 Base_01.exe: B$ 'Base_01.exe', 0
 Base_02.exe: 'Base_02.exe', 0
 Base_10.exe: 'Base_10.exe', 0
 Base_11.exe: 'Base_11.exe', 0

 Base_03.dll: 'Base_03.dll', 0
 Base_04.dll: 'Base_04.dll', 0
 Base_05.dll: 'Base_05.dll', 0, 0]

[MissBaseTitle: 'Missing Bases Files', 0

 MissBase: "
 Download the Bases Files from RosAsm.org
 and save them in a folder called 'Bases',
 inside your 'RosAsmFiles' Folder.
 
 If you already have these Files at the
 proper Path, update them with the new
 Version.
 ", 0]

[BasesListHandle: ?  BaseListEnd: ?]

SetBaseList:
    ;call SetNewChoice eax, NewEmpty

    call GetRosAsmFilesPath

    mov esi RosAsmFilesPath, edi BaseFilesPath
    While B$esi <> 0 | movsb | End_While
    mov D$edi 'Base', D$edi+4 's\'
    add edi 6 | mov D$BaseNamePointer edi

    zCopy {'BasesList.txt', 0} | mov B$edi 0

    call 'KERNEL32.CreateFileA' BaseFilesPath, &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, 0

    .If eax = &INVALID_HANDLE_VALUE
        mov eax 0-1 | ret

    .Else
        mov D$BasesListHandle eax
        call 'KERNEL32.GetFileSize' eax, 0
        mov D$BaseListEnd Trash | add D$BaseListEnd eax
        call 'KERNEL32.ReadFile' D$BasesListHandle, Trash, eax, NumberOfReadBytes, 0
        call 'KERNEL32.CloseHandle' D$BasesListHandle

        mov esi Trash
        .While esi < D$BaseListEnd
            While B$esi <> ' ' | inc esi | End_While
            mov edi TrashString
            While B$esi <> CR | movsb | End_While | mov B$edi 0 | add esi 2

            call SetNewChoice D$NewChoiceListHandle, TrashString
        .End_While

    .End_If
ret


GetBaseName:
  ; eax = Indice (Indice zero assumed as 'NewEmpty' by 'SetBaseList').
    mov esi Trash, ecx 1

  ; Skip lines until indice matches:
    .While ecx < eax
        While B$esi <> CR | inc esi | End_While | add esi 2
        inc ecx
    .End_While

  ; Set a zero at the end of the File Name:
    push esi
        While B$esi <> ' ' | inc esi | End_While
        mov D$esi 0
    pop esi
ret


VerifyBasesFolder:
    call GetRosAsmFilesPath

    mov esi RosAsmFilesPath, edi BaseFilesPath
    While B$esi <> 0 | movsb | End_While
    mov D$edi 'Base', D$edi+4 's\'
    add edi 6 | mov D$BaseNamePointer edi
    mov esi BasesNames

    .While B$esi <> 0
        push edi
            While B$esi <> 0 | movsb | End_While | movsb
            push esi
                call 'KERNEL32.FindFirstFileA' BaseFilesPath, FindFile
                push eax
                    call 'KERNEL32.FindClose' eax
                pop eax
                If eax = &INVALID_HANDLE_VALUE
                    pop eax, eax
                    call 'USER32.MessageBoxA' &NULL, MissBase, MissBaseTitle, &MB_SYSTEMMODAL
                    mov eax &FALSE | ret
                End_If
            pop esi
        pop edi
    .End_While

    mov eax &TRUE
ret

____________________________________________________________________________________________

[BadNewExtension: 'Bad Extension', 0]

SaveNewFileName:
    mov esi SaveFilter, edi MainName

L0: lodsb | stosb | cmp B$esi '.' | je L8>
    cmp B$esi 0 | jne L0<

L8: On B$esi+4 <> 0, jmp L0<

    mov B$edi 0

  ; Check extension:
    lodsd | or eax 020202000
    If eax = '.exe'
        jmp L9>
    Else_If eax = '.dll'
        jmp L9>
    Else_If eax = '.sys'
        jmp L9>
    Else_If eax = '.scr'
        jmp L9>
    End_If

    If al = '.'
        ; OK
    Else_If al = 0
        ; OK
    Else
        mov eax BadNewExtension | call MessageBox | mov eax &FALSE | ret
    End_If

    sub esi 4 | mov edi esi
    mov eax '.exe' | stosd | mov B$edi 0   ; Complete user given name (any use?...)

L9: or eax 020202000 | xor eax 020202000 | mov D$SavingExtension eax | mov eax &TRUE
ret


StartNewFile:
    call ReInitUndo
    call ReInitHeaderFormat
    On B$SourceReady = &TRUE, call ReleaseMainFile

    call ClearBackTable | call ReleaseResourceMemory

    mov D$SourceLen 0

  ;  VirtualAlloc CodeSource 1_000_000
    VirtualAlloc UserPeStart 1_000_000 | move D$CodeSource D$UserPeStart

    add D$CodeSource 10     ; security for back test like ESI or EDI - 2 (no page fault)

    mov edi D$CodeSource
    mov eax 0A0D0A0D, ecx 100 | rep stosd                            ; end security tail
    mov edi D$CodeSource, ecx 5 | sub edi 10 | rep stosw
    mov eax D$CodeSource
    mov D$SourceEnd eax, D$CurrentWritingPos eax, D$CaretLine 0, D$CaretRow 1
    add eax 1_000_000 | mov D$EndOfSourceMemory eax

    mov B$SourceReady &TRUE | move D$UpperLine D$CodeSource

    mov D$TitleTable 0, D$PreviousPartialSourceLen 0

  ; Clear possible previous resources:
    call ClearCustomList

    call AskForRedraw
ret


[UserPEStartOfResources: ?    ResourcesSize: ?]

SearchPEstartOfResource:
    mov B$NoResourcesPE &FALSE
    mov esi D$UserPeStart, D$UserPEStartOfResources 0
    movzx eax W$esi+8
   ; mov eax 0 | add esi 8 | lodsw    ; parag. size of dos header end >PE header adress
    shl eax 4 | sub eax 4
    mov esi D$UserPeStart | add esi eax | lodsd      ; eax = PE header

    mov esi D$UserPeStart | add esi eax
    cmp W$esi 'PE' | jne L9>
 ______________________________________

; read data in PeHeader:

L0: mov ecx 0 | mov cx w$esi+6            ; word record of section number
    add esi 136 | lodsd | mov ebx eax     ; RVA of resources from "Image Data Dir..."
    mov D$ResourcesRVA eax
    move D$ResourcesSize D$esi

                     ; jmp over general purpose headers and reach PE sections headers:
    add esi 120                           ; esi points to RVA of first section header
    If eax = 0
        mov B$NoResourcesPE &TRUE | ret
    End_If

L0: lodsd | cmp eax ebx | je L1>
        add esi 36 | loop L0<
          jmp L9>
 ______________________________________

  ; if here, '.rsrc' section found:

L1:
    add esi 4 | lodsd                            ; > app ptr to resources
    add eax D$UserPeStart | mov D$UserPEStartOfResources eax
L9: ret


[EndOfSectionSearch: ?]

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
 This is a little 'unregular' CheckSum stored in an 'unregular' place. It does *not*
 prevent final user from viruses. It is designed to protect RosAsm programmers who
 exchange files from dispatching corrupted files.

 The base idea is that we can hope that nobody will ever write any virus specifically
 designed to target RosAsm produced PEs. Not at all sophisticated, and very easy to
 overcome, but who would?

 As is, if infected, when you [Load] the file in RosAsm, you get a MessageBox to alert
 you. Nothing more, but i think that it is a very good solution to allow Asm communauty
 to exchange files without fearing.
;;
[CheckMessageTitle: 'Bad CheckSum', 0
 CheckInfo: "
 This File has been modified, either
 by an external Tool, or by a Virus.     ", 0]

ReadCheckSum:
    pushad
      ; If a real PE CheckSum has been written, it must be zeroed, before calculation
      ; because it was stored after 'MyCheckSum':
        mov esi D$UserPeStart | add esi CheckSum | sub esi DosHeader
        mov D$esi 0

      ; 'MyCheckSum' must not be considered:
        mov esi D$UserPeStart | add esi MyCheckSum | sub esi DosHeader
        mov edx D$esi, D$esi 0, ebx 0, eax 0

        .If edx > 0
            mov esi D$UserPeStart, ecx D$UserPeLen

L0:         lodsb | add ebx eax | loop L0<

            If edx <> ebx
                call 'USER32.MessageBoxA' D$hwnd, CheckInfo, CheckMessageTitle,
                                           &MB_SYSTEMMODAL__&MB_ICONEXCLAMATION
            End_If
        .End_If
    popad
ret


WriteCheckSum:
    mov eax 0, ebx 0, esi D$CodeList, ecx D$LenOfCode
L0: lodsb | add ebx eax | loop L0<

    If B$ExportsectionWanted = &TRUE
        mov esi D$ExportListBPtr, ecx D$ExportSectionLen
L0:     lodsb | add ebx eax | loop L0<
    End_If

    .If D$SavingExtension = '.SYS'
        jmp L0>
    .Else_If D$SavingExtension = '.DLL'
L0:     If D$RelocSectionSize > 8
            mov esi D$Relocation, ecx D$RelocSectionSize
L0:         lodsb | add ebx eax | loop L0<
        End_If
    .End_If

    mov esi D$CodeSource, ecx D$SourceLen
L0: lodsb | add ebx eax | loop L0<

    mov edi D$CodeList | add edi MyCheckSum | sub edi DosHeader
    mov D$edi ebx
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  Regular PE CheckSum (original Source for csum.exe, from 'RudeBoy'):
  
  Will be needed for Drivers.


    mov edx 0, esi D$FilePointer, ecx D$FileLen | shr ecx 1

L0: lodsw
    add edx eax
    mov eax edx
    and edx 0ffff 
    shr eax 010
    add edx eax
    loop L0<

    mov eax edx
    shr eax 010
    add ax dx
    add eax dwFileLen
  
____________________________________________________________________________________________

Another one:

    mov ecx, D$Length, esi D$BufferPointer, eax 0
    shr ecx, 1              

    clc                                 
L0: adc ax W$esi+ecx*2-2 | dec ecx | jnz L0<
    
    adc eax D$Length
    
    
    
    
    MicrosoftCheckSum2              PROC C uses esi, buf:dword, len:dword
        mov             ecx, [len]           
        mov             edx, [buf]           
        shr             ecx, 1               
        xor             eax, eax             

        clc                                  
@@theLoop:
        adc ax, [edx + (ecx * 2) - 2]
        dec ecx
        jnz @@theLoop
        adc  eax, [len]
        ret
;;

WriteSysFile:
    call SetExeSavingName

    call OpenDestinationFile

    mov D$NumberOfReadBytes 0

    call AraseSourceHeader | call AraseCheckSum

    call WritePeCheckSum

    call 'KERNEL32.WriteFile' D$DestinationHandle, D$CodeList, D$LenOfCode,
                              NumberOfReadBytes, 0

    If B$ExportsectionWanted = &TRUE
        call 'KERNEL32.WriteFile' D$DestinationHandle, D$ExportListBPtr,
                                  D$FileAlignedExportSectionLen, NumberOfReadBytes, 0
    End_If

    If D$SavingExtension = '.SYS'
        jmp L1>
    Else_If D$SavingExtension = '.DLL'
L1:     On D$RelocSectionSize > 8, call 'KERNEL32.WriteFile' D$DestinationHandle,
                                   D$Relocation, D$FileAlignedRelocationSize,
                                   NumberOfReadBytes, 0
    End_If

  ;  call 'KERNEL32.WriteFile' D$DestinationHandle, D$CodeSource, D$SourceLen,
  ;                            NumberOfReadBytes, 0

    call 'KERNEL32.CloseHandle' D$DestinationHandle | mov D$DestinationHandle 0
ret


AraseSourceHeader:
    mov edi D$LocOfSourceHeader
    mov ecx 20, eax 0 | rep stosd
ret


AraseCheckSum:
    mov edi D$CodeList | add edi MyCheckSum | sub edi DosHeader
    mov D$edi 0
ret


WritePeCheckSum:
    mov esi D$CodeList, ecx D$LenOfCode, eax 0, ebx ecx
    shr ecx, 1

    clc
L0: adc ax W$esi+ecx*2-2 | dec ecx | jnz L0<
    adc ax 0

    If B$ExportsectionWanted = &TRUE
        mov esi D$ExportListBPtr, ecx D$FileAlignedExportSectionLen
        add ebx ecx
        shr ecx 1
        clc
L0:     adc ax W$esi+ecx*2-2 | dec ecx | jnz L0<
        adc ax 0
    End_If

    If D$RelocSectionSize > 8
        mov esi D$Relocation, ecx D$FileAlignedRelocationSize
        add ebx ecx
        shr ecx 1
        clc
L0:     adc ax W$esi+ecx*2-2 | dec ecx | jnz L0<
       ; adc ax 0
    End_If
;;
    mov esi D$CodeSource, ecx D$SourceLen
        add ebx ecx
        shr ecx 1
        clc
L0:     adc ax W$esi+ecx*2-2 | dec ecx | jnz L0<
;;
    adc eax ebx | call WriteEaxToPeCheckSum
ret


WriteEaxToPeCheckSum:
    mov edi D$CodeList | sub edi DosHeader | add edi CheckSum
    mov D$edi eax
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[BookMarksFileHandle: ?    BookMarksFileLen: ?]

[FindFile:
 FindFile.dwFileAttributes: D$ ?
 FindFile.ftCreationTime.dwLowDateTime: D$ ?
 FindFile.ftCreationTime.dwHighDateTime: D$ ?
 FindFile.ftLastAccessTime.dwLowDateTime: D$ ?
 FindFile.ftLastAccessTime.dwHighDateTime: D$ ?
 FindFile.ftLastWriteTime.dwLowDateTime: D$ ?
 FindFile.ftLastWriteTime.dwHighDateTime: D$ ?
 FindFile.nFileSizeHigh: D$ ?
 FindFile.nFileSizeLow: D$ ?
 FindFile.dwReserved0: D$ ?
 FindFile.dwReserved1: D$ ?]
[FindFile.cFileName: B$ ? #&MAXPATH]
[FindFile.cAlternate: B$ ? #14]

LoadBookMarks:
    mov D$NumberOfBookMarks 0
    mov edi SaveFilter, al 0, ecx 0-1 | repne scasb
    While B$edi <> '.'
        dec edi
    End_While
    push D$edi, edi

        mov D$edi '.BKM'

        call 'KERNEL32.FindFirstFileA' SaveFilter FindFile
        .If eax = &INVALID_HANDLE_VALUE
            VirtualFree D$BookMarks | pop edi, D$edi | ret
        .Else
            call 'KERNEL32.FindClose' eax
        .End_If

        call 'KERNEL32.CreateFileA' SaveFilter &GENERIC_READ,
                                    &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL, 0
   pop edi, D$edi

   .If eax = &INVALID_HANDLE_VALUE
        mov eax D$BusyFilePtr | call MessageBox
        pop eax | ret                       ; pop return adress of caller and ret to Callback
   .Else
        mov D$BookMarksFileHandle eax
   .End_If

    call 'KERNEL32.GetFileSize'  eax 0 | mov D$BookMarksFileLen eax

    VirtualFree D$BookMarks | VirtualAlloc BookMarks 01000

    call 'KERNEL32.ReadFile' D$BookMarksFileHandle D$BookMarks D$BookMarksFileLen,
                            NumberOfReadBytes 0
    call CreateTreeViewList | call SetTreeDialogPos

    call 'KERNEL32.CloseHandle' D$BookMarksFileHandle
ret



[EndOfSourceMemory: ?    OldSourceReady: ?]

OpenRosAsmPE:
    move D$OldSourceReady D$SourceReady | mov B$SourceReady &FALSE

    call ClearSaveFilter | call ClearChoosenFile

    push edi
        mov edi OpenPEStruc
        mov eax 04C | stosd
        mov eax D$hwnd | stosd
        mov eax 0 | stosd
        mov eax PEFilesFilters | stosd
        mov eax uFileFilter | stosd
        mov eax 260 | stosd
        mov eax 1 | stosd
        mov eax SaveFilter | stosd
        mov eax 260 | stosd
        mov eax ChoosenFile | stosd
        mov eax 260 | stosd
        mov eax 0 | stosd
        mov eax OpenPEFileTitle | stosd
        mov eax 0281804 | stosd
        mov eax 0 | stosd
        mov eax 0 | stosd
        mov eax 0 | stosd
        mov eax 0 | stosd
        mov eax 0 | stosd
    pop edi

    call 'Comdlg32.GetOpenFileNameA' OpenPEStruc

    If D$SaveFilter = 0
        move D$SourceReady D$OldSourceReady | ret
    End_If

DirectMRUload:
DirectLoad:
    call ReleaseMainFile | StoreNameOnly SaveFilter
    call ClearBackTable | call ReleaseResourceMemory

    VirtualFree D$UserPeStart

LastMRULoading:
ReloadForDissassembler:
    mov esi MainName
    While B$esi <> 0 | inc esi | EndWhile
    While B$esi <> '\' | dec esi | EndWhile
    push D$esi
        mov B$esi+1 0 | call 'Kernel32.SetCurrentDirectoryA' MainName
    pop D$esi

    mov esi SaveFilter | call CreateFile | On eax = &INVALID_HANDLE_VALUE, ret
    Call GetFileNameFromPath
  ; > eax = source len
;;
  The reason for allocating a twice (>>> shl eax 1) bigger Mem:
  
  When having TITLEs inside, the editor make a Copy of the edited TITLE, at the bottom
  of this Mem. Therefore, if the Source is made of two TITLEs, a very short one, say
  for Macros, and a very big one, for everything else, we need twice more Mem. Plus the
  additional Edition security, of course:
;;
    mov D$UserPeEnd eax, D$UserPeLen eax | shl eax 1 | add eax 100_000

    push eax
        VirtualAlloc UserPeStart eax

        add D$UserPeEnd eax
    pop eax

    Align_On PAGESIZE eax | sub eax 32 | add eax D$UserPeStart
    mov D$EndOfSourceMemory eax

    mov D$NumberOfReadBytes 0

    call 'KERNEL32.ReadFile' D$SourceHandle, D$UserPeStart, D$UserPeLen, NumberOfReadBytes, 0

    call 'KERNEL32.CloseHandle' D$SourceHandle | mov D$SourceHandle 0

    mov eax D$UserPeStart | On W$eax <> 'MZ', jmp ExitNotPeExe

    mov eax D$UserPeStart | sub eax DosHeader | add eax PeHeaderPointer
    mov ebx D$eax, eax D$UserPeStart | add eax ebx
    On eax >= D$UserPeEnd, jmp ExitNotPeExe
    On W$eax <> 'PE', jmp ExitNotPeExe

    mov B$ThisSourceIsDisassembled &FALSE

    mov eax D$UserPeStart | add eax 0178 | mov esi eax     ; +0178 > first section header
    add eax 400 | mov D$EndOfSectionSearch eax             ; +(10*40) bytes per section

L0: lodsd | cmp eax '.src' | je L1>
        add esi 36 | cmp esi D$EndOfSectionSearch | jb L0<
            jmp TryDisassembly

ExitNotPeExe:
    mov eax D$NotPeExePtr | call MessageBox | call AutoNew | jmp StartNewFile


L1: lodsd | lodsd | mov D$SourceLen eax
    lodsd | lodsd | lodsd
  ; eax = 0 based pointer to source

  ; 'MessageBox' messages could send a WM_PAINT before complete initializations:
    mov D$TiTleTable 0, D$ActualTitle 0

    call ReadCheckSum | call ReadHeaderFormat

    add eax D$UserPeStart | mov D$CodeSource eax

    mov edi D$CodeSource | add edi D$SourceLen | mov eax 0A0D0A0D, ecx 100

    rep stosd

    mov eax D$CodeSource | add eax D$SourceLen | mov D$SourceEnd eax
   ; add eax 1_000_000 | mov D$EndOfSourceMemory eax
    move D$UpperLine D$CodeSource | mov B$SourceReady &TRUE

    call KillTabs | call KillTrailingSpaces

    call SearchPEstartOfResource | On B$NoResourcesPE = &TRUE, jmp L9>>

    ; Upload icon:

; Icon storing more stand-alone because of feature for reading icon in other PEs. So does
; it again job done by 'SearchPEstartOfResource'. So, i make it set 'ResourcesRVA' value
; (very durty, but...).

    move D$iExePtr D$UserPeStart | call ReadRosAsmPeIcon ; load icon with icon editor routine

    If B$PeIconFound = &TRUE
        mov esi eax | mov edi iIcon | rep movsb         ; Copying to icon editor buffer
         call StoreIcon                                  ; and copy it to 'compilable' image
    End_If

   ; call ReadRosAsmPeMenus

   ; call ReadRosAsmPeDialogs

  ;  call ReadRosAsmBitMaps

  ;  call ReadRosAsmStrings

   ; call ReadRosAsmWaves

   ; call ReadRosAsmAvis

   ; call ReadRosAsmRCs

   ; call ReadRosAsmCursors | call ReadRosAsmGroupCursors

   ; call ReadRosAsmIcons | call ReadRosAsmGroupIcons

    call ReadRosAsmResources

L9: mov edi D$CodeSource, ecx 5, eax 0A0D | sub edi 10 | rep stosw ; security for back search
    mov D$DestinationFile 0

    SetWindowText | call StartEdition
ret

; For 'FillExportSection':

GetFileNameFromPath:
    push eax, esi, edi
        mov esi SaveFilter, eax esi
        mov edi ChoosenFile

        While B$esi <> 0 | inc esi | End_while

        While esi > eax
            dec esi
            On B$esi = '\', jmp L1>
        End_While

L1:     inc esi

        While B$esi <> 0
            movsb
        End_While
        mov B$edi 0
    pop edi, esi, eax
ret


[DisChoice: ?]

TryDisassembly:
    On D$AddressToBeForced = &TRUE, jmp DisMain

  ; Tag Dialog 27000
    call 'USER32.DialogBoxParamA' D$hInstance, 27000, D$hwnd, DisassembleProc, 0
    Test D$DisChoice 0_8000_0000 | jz L9>
        and D$DisChoice 0FF | jmp Dismain

L9:     call AutoNew | jmp StartNewFile

____________________________________________________________________________________________

[WithCommentedHexa: &FALSE   WithForcedMapFile: &TRUE  WithMacros: &TRUE]

; Tag Dialog 27000

Proc DisassembleProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND                  ; User action
        ..If D@wParam = &IDCANCEL                   ; User clicks on upper right [X]
            and D$DisChoice 0FF
            call 'User32.EndDialog' D@Adressee 0
          ; call 'User32.DestroyWindow' D@Adressee ; Comments...

        ..Else_If D@wParam = &IDOK
            or D$DisChoice 0_8000_0000
            call 'User32.EndDialog' D@Adressee 0

        ..Else_If D@wParam = &IDHELP
            call Help B_U_AsmName, DisassemblerHelp, ContextHlpMessage

        ..Else
            movzx eax W@wParam
            If eax = 10
                mov B$WithCommentedHexa &FALSE
            Else_If eax = 11
                mov B$WithCommentedHexa &TRUE
            Else_If eax = 12
                mov B$WithCommentedHexa &FALSE
            Else_If eax = 14
                xor B$WithForcedMapFile &TRUE
            Else_If eax = 15
                xor B$WithMacros &TRUE
            Else_If eax = 16
                xor B$AMDassumed &TRUE
            End_If

        ..End_If

    ...Else_If D@Message = &WM_INITDIALOG          ; Win ready to build the Dialog
        If B$WithCommentedHexa = &TRUE
            call 'USER32.CheckDlgButton' D@Adressee, 11, &TRUE
        Else_If B$WithMacros = &TRUE
            call 'USER32.CheckDlgButton' D@Adressee, 15, &TRUE
        Else
            call 'USER32.CheckDlgButton' D@Adressee, 10, &TRUE
        End_If

        call IsForcedMapFile
        .If eax = &TRUE
            call Enable D@Adressee, 14
            If B$WithForcedMapFile = &TRUE
                call 'USER32.CheckDlgButton' D@Adressee, 14, &TRUE
            End_If
        .Else
            call Disable D@Adressee, 14
        .End_If

        If B$AMDassumed = &TRUE
            call 'USER32.CheckDlgButton' D@Adressee, 16, &TRUE
        End_If


  ;  ...Else_If D$Message = &WM_CTLCOLOREDIT        ; Win ready to paint the Dialog
  ;      ; Control of output

    ...Else
        popad | mov eax &FALSE | ExitP               ; Non processed

    ...End_If

    popad | mov eax &TRUE                           ; Processed
EndP
____________________________________________________________________________________________

; >>> peheader <<<

ReadHeaderFormat:
    pushad
        mov eax D$UserPeStart | add eax 0178 | mov esi eax     ; +0178 > first section header
        add eax 400 | mov D$EndOfSectionSearch eax             ; +(10*40) bytes per section

      ; Data Characteristics:
        push esi
L0:         lodsd | cmp eax '.dat' | je L1>
                add esi 36 | cmp esi D$EndOfSectionSearch | jb L0<
                jmp L0>
L1:         add esi 32
            lodsd | mov D$DataCharacteristics eax
L0:     pop esi

      ; Code Characteristics:
L0:     lodsd | cmp eax '.tex' | je L1>
            add esi 36 | cmp esi D$EndOfSectionSearch | jb L0<
            mov eax D$NotPEPtr | call MessageBox | ret
L1:     add esi 32
        lodsd | mov D$CodeCharacteristics eax

      ; SubSystem, DLL_characteristcs:
        mov esi PeHeader | sub esi DosHeader
        add esi D$UserPeStart                   ; >>> 'PE' 0 0
        add esi 52                              ; >>>> ImageBase

        mov eax D$esi, D$ImageBase eax, D$LinkerDllDefault eax

        mov edi SubSystem | add esi 40          ; >>> SubSystem // DLL characteristcs
        mov ax W$esi, W$DllAttachDetach ax

        movsd
        movsd   ; AppStackMax
        movsd   ; AppStackMin
        movsd   ; AppHeapMax
        movsd   ; AppHeapMin
    popad
ret


ReInitHeaderFormat:
    push edi
        mov edi SubSystem
        mov eax 2 | stosd                       ; Subsystem GUI  //  DLL characteristics 0
        mov eax 0100000 | stosd                 ; AppStackMax
        mov eax   01000 | stosd                 ; AppStackMin
        mov eax 0100000 | stosd                 ; AppHeapMax
        mov eax       0 | stosd                 ; AppHeapMin
        mov D$CodeCharacteristics 0_60000020    ; readable, runable, code
        mov D$DataCharacteristics 0_C0000040    ; readable, writeble, Data
        mov W$DllCharacteristics 0
    pop edi
ret
 _______________________________

; Writing files:

[DestinationFile: ? #262]

OpenDestinationFile:
    On D$DestinationHandle > 0, call 'KERNEL32.CloseHandle' D$DestinationHandle

    call 'KERNEL32.CreateFileA' DestinationFile, &GENERIC_WRITE,
                                &FILE_SHARE_READ__&FILE_SHARE_WRITE, 0,
                                &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
        mov eax D$BusyFilePtr | call MessageBox
        mov B$CompileErrorHappend &TRUE
      ; pop return adress of caller and ret to Callback:
        pop eax | ret

    Else
        mov D$DestinationHandle eax

    End_If
ret

____________________________________________________________________________________________
;;
 This is for developpements test:

 DANGER >>> Writes a 'Test.a' on the disk without warning.
 
 'WriteDestination' is used only by 'AsmMain' when you branch to it. All these commented
 lines are for tests along developpement giving ability, by calling it, to output
 internal tables for exemple, if we want to see what is in 'DllList', we route here with
 a 'jmp L7>' after 'BuildImport'; with "mov eax, 010000 | push eax" and "push D$DllList"
 uncommented.
;;
WriteDestination:
    call OpenDestinationFile

   ; hexprint D$StripLen
   ; showme DestinationFile

    push 0
    mov D$NumberOfReadBytes 0 | push NumberOfReadBytes

      mov eax, 0100

 ;;;; Just uncomment the one you want in 'Test.a':

    ; push D$LenOfCode, D$CodeSource
    ; push D$StripLen, D$CodeSourceB
     push D$StripLen, D$CodeSourceA
    ; push eax, D$EquateList
    ; push eax, D$MacroList
    ; push eax, D$PlainLabelList
    ; push eax, D$MacroData
    ; push eax, D$DataList
    ; push eax, D$LabelList
    ; push D$StripLen, D$Coderef
    ; push eax, D$DataRef
    ; push eax, D$DllList
    ; push eax, D$ApiListA
    ; push eax, D$ApiListB
    ; push eax, D$Relocation
    ; push eax, D$TreeList
    ; push eax, D$CodeList
    ; push eax, D$ExportListAPtr
;;
    mov esi D$StatementsTable | While D$esi > 0 | add esi 4 | End_While
    sub esi D$StatementsTable
    push esi, D$StatementsTable
;;

   ; mov eax D$EndOfSectionsMap | sub eax D$SectionsMap | push eax
;
 ;   push D$SectionsMap

    push D$DestinationHandle
    call 'KERNEL32.WriteFile'
ret


ControlS:
    ..If D$TitleTable = 0
        call SaveSource
        call 'USER32.MessageBoxA' D$hwnd, DestinationFile,
                                {'Saved in actual Directory:', 0}, 0

    ..Else
        call 'USER32.DialogBoxParamA' D$hinstance, 26000, &NULL, AllOrPartProc, &NULL

        .If B$AllOrPart = 0-1
            call RestoreRealSource | call SaveSource
            call SetPartialEditionFromPos

        .Else_If B$AllOrPart = 1
            mov B$WeAreSavingPart &TRUE
            call SaveSource
            mov B$WeAreSavingPart &FALSE

        .Else_If B$AllOrPart = 9
            call 'USER32.MessageBoxA' D$hwnd, {"     Do you wish to save all the TITLEs
of this Application into as many asm Files?      ", 0}, {'Sure?', 0}, &MB_YESNO
            If eax = &IDYES
                mov B$WeAreSavingPart &TRUE
                call SaveActualPos
                call GetTitlesNumber

L0:             push ecx
                    call SelectTitle ecx | call SaveSource
                pop ecx
                loop L0<

                call 'USER32.MessageBoxA' D$hwnd, {'Done', 0}, 0, 0
                call RestoreActualPos
                mov B$WeAreSavingPart &FALSE
            End_If

        .End_If

    ..End_If
ret


[ActualPos: ?]

SaveActualPos:
    move D$ActualPos D$CurrentWritingPos
ret


Proc SelectTitle:
    Argument @Indice

        call RestoreRealSource
        mov eax D@Indice
        dec eax
        mov D$ActualPartIndex eax
        move D$CurrentWritingPos D$TitleTable+eax*4
        call SetPartialEdition

        mov esi D$CodeSource, edi PartName

        If D$esi = 'TITL'
            add esi 5 | While B$esi = ' ' | inc esi | End_While
            While B$esi > ' ' | movsb | End_While | mov B$edi 0
        Else
            mov D$PartName 'Top'
        End_If
EndP


GetTitlesNumber:
    mov esi TitleTable, ecx 0
    While D$esi <> 0
        inc ecx | add esi 4
    End_While
ret


RestoreActualPos:
    move D$CurrentWritingPos D$ActualPos
ret


[BackUpPathName: B$ ? #&MAXPATH][BackUpNewPathName: B$ ? #&MAXPATH]

[WIN32_FIND_DATA:
 dwFileAttributes: D$ 0
 ftCreationTime.dwLowDateTime: D$ 0
 ftCreationTime.dwHighDateTime: D$ 0
 ftLastAccessTime.dwLowDateTime: D$ 0
 ftLastAccessTime.dwHighDateTime: D$ 0
 ftLastWriteTime.dwLowDateTime: D$ 0
 ftLastWriteTime.dwHighDateTime: D$ 0
 nFileSizeHigh: D$ 0
 nFileSizeLow: D$ 0
 dwReserved0: D$ 0
 dwReserved1: D$ 0]
[cFileName: B$ 0 #&MAX_PATH]
[cAlternate: B$ 0 #80]

[BackUpFileHandle: ?    LastBackUpIndice: ?]    [MaxBackUp: B$ '0010' 0]

ControlK:
    On D$MaxBackUp = '0000', ret

    If B$ReadyToRun = &FALSE
        call 'USER32.MessageBoxA' D$hwnd,
                                 {'You have to [Compile] or to [Run] before a PE BackUp', 0},
                                 {'[Ctrl][K] BackUp aborted:', 0}, 0
        ret
    End_If

    mov esi MainName, edi BackUpPathName

    While B$esi <> 0 | movsb | End_While
    While B$esi <> '\' | dec esi | dec edi | End_While

    push esi
        While B$esi <> 0 | movsb | End_While
        mov B$edi '\' | inc esi
        mov D$edi 'Back', D$edi+4 'Up\ ' | add edi 7
    pop esi

    inc esi | While B$esi <> 0 | movsb | End_While
    mov B$edi '*' | inc edi
    mov eax D$SavingExtension | stosd | mov B$edi 0

    push edi
        call 'KERNEL32.FindFirstFileA' BackUpPathName, WIN32_FIND_DATA
        mov D$BackUpFileHandle eax
    pop edi

    ...If eax = &INVALID_HANDLE_VALUE
        While B$edi <> '\' | dec edi | End_While | mov B$edi 0
        push edi
            call 'KERNEL32.CreateDirectoryA' BackUpPathName, 0
        pop edi
        mov B$edi '\'
        While B$edi <> '*' | inc edi | End_While
        mov D$edi '0000' | add edi 4
L0:     mov eax D$SavingExtension | stosd | mov B$edi 0
        mov esi MainName | While B$esi <> 0 | inc esi | End_While
        move D$esi D$SavingExtension | mov B$esi+4 0
        push esi
            call 'KERNEL32.CopyFileA' MainName, BackUpPathName, &FALSE
        pop esi
        mov B$esi 0

    ...Else
L2:     call 'KERNEL32.FindNextFileA' D$BackUpFileHandle, WIN32_FIND_DATA
        cmp eax &TRUE | je L2<

        call 'KERNEL32.FindClose' D$BackUpFileHandle

        mov esi cFileName
        While B$esi <> 0 | inc esi | End_While
        While B$esi <> '.' | dec esi | End_While
        call IncTextDwordBeforeEsi

        mov edi BackUpPathName
        While B$edi <> 0 | inc edi | End_While
        While B$edi <> '*' | dec edi | End_While
        mov eax D$esi-4, D$LastBackUpIndice eax | stosd | jmp L0<<

    ...End_If

    mov eax D$MaxBackUp, ebx D$LastBackUpIndice | bswap eax | bswap ebx

    .If ebx >= eax
        mov esi BackUpPathName
        While B$esi <> 0 | inc esi | End_While
        While B$esi <> '.' | dec esi | End_While
        sub esi 4 | mov D$esi '0000'
        mov ebx esi | sub ebx BackUpPathName
        push ebx
            call 'KERNEL32.DeleteFileA' BackUpPathName
            mov esi BackUpPathName, edi BackUpNewPathName
            While B$esi <> 0 | movsb | End_While | mov B$edi 0
        pop ebx

L0:     lea esi D$BackUpPathName+ebx+4
        call IncTextDwordBeforeEsi
        mov eax D$MaxBackUp, edx D$esi-4 | bswap eax | bswap edx | cmp edx eax | ja L9>
        push ebx
            call 'KERNEL32.MoveFileA' BackUpPathName, BackUpNewPathName
        pop ebx
        If eax = &TRUE
            lea esi D$BackUpNewPathName+ebx+4
            call IncTextDwordBeforeEsi
        End_If
        jmp L0<

L9:     mov esi BackUpNewPathName, edi BackUpPathName
        While B$esi <> 0 | movsb | End_While | mov B$edi 0
        lea esi D$BackUpPathName+ebx+4
        call DecTextDwordBeforeEsi

    .End_If

    call 'USER32.MessageBoxA' D$hwnd, BackUpPathName, {'Backup done to:', 0}, 0
ret

IncTextDwordBeforeEsi:
    inc B$esi-1
    ..If B$esi-1 > '9'
        mov B$esi-1 '0' | inc B$esi-2
        .If B$esi-2 > '9'
            mov B$esi-2 '0' | inc B$esi-3
            If B$esi-3 > '9'
                mov B$esi-3 '0' | inc B$esi-4
            End_If
        .End_If
    ..End_If
ret

decTextDwordBeforeEsi:
    dec B$esi-1
    ..If B$esi-1 < '0'
        mov B$esi-1 '9' | dec B$esi-2
        .If B$esi-2 < '0'
            mov B$esi-2 '9' | dec B$esi-3
            If B$esi-3 < '0'
                mov B$esi-3 '9' | dec B$esi-4
            End_If
        .End_If
    ..End_If
ret

____________________________________________________________________________________________



[PartName: ? #16] [WeAreSavingPart: ?    AllOrPart: ?]
[ReplaceSourceText: 'Load Source', 0]

; Tag Dialog 26000

Proc AllOrPartProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_INITDIALOG
            On B$OpeningSourceOnly = &TRUE,
                call 'USER32.SendMessageA' D@Adressee, &WM_SETTEXT, 0, ReplaceSourceText

            mov esi D$ActualTitle
            .If esi = D$RealCodeSource
                If D$esi <> 'TITL'
                    mov D$PartName 'Top ', B$PartName+3 0
                    call 'USER32.SetDlgItemTextA' D@Adressee, 1, DefaultTopTitle
                    jmp L8>>
                End_If
            .End_If

            While B$esi > ' ' | inc esi | End_While ; jump over 'TITLE'

            While B$esi = ' ' | inc esi | End_While ; >>> 'TitleName
            mov edi PartName
            While B$esi > ' ' | movsb | End_While
            mov al 0 | stosb
            call 'USER32.SetDlgItemTextA' D@Adressee, 1, PartName
            jmp L8>>

    ...Else_If D@Message = &WM_COMMAND
        mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        If D@wParam = &IDCANCEL
            mov B$AllOrPart 0

        Else_If D@wParam = &IDOK
            mov B$AllOrPart 1

        Else_If D@wParam = 3
            mov B$AllOrPart 0-1

        Else_If D@wParam = 4
            mov B$AllOrPart 9

        End_If

        call 'User32.DestroyWindow' D@Adressee

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE
L9: EndP


[IncSaveTitle: B$ 'Saving .inc or .asm ? ...', 0
 IncSaveBody: "
 
   Yes > Save the inc File in its original Directory      
   
   No  > Save the asm File in current Directory", 0]


SaveSource:
    .If B$WeAreSavingPart = &TRUE
        call RestoreRealSource

        call SearchForIncInclude

        If eax = &TRUE
            mov esi D$PointerToIncFileName, edi DestinationFile
            While B$esi > ' ' | movsb | End_While | mov B$edi 0
        End_If

        push eax
            call SetPartialEditionFromPos
        pop eax

        If eax = &TRUE
            call 'USER32.MessageBoxA' D$hwnd, IncSaveBody, IncSaveTitle,
                                      &MB_SYSTEMMODAL_&MB_YESNO
            On eax = &IDYES, jmp L2>
        End_If
    .End_If

    call SetAsmSavingName

L2: call OpenDestinationFile | mov D$NumberOfReadBytes 0
    call 'KERNEL32.WriteFile'  D$DestinationHandle, D$CodeSource, D$SourceLen,
                               NumberOfReadBytes, 0

    call 'KERNEL32.CloseHandle' D$DestinationHandle | mov D$DestinationHandle 0
ret


SearchForIncInclude:
    mov esi D$CodeSource, eax &FALSE

    .While esi < D$SourceEnd
        call IsItPREPARSE
        .If eax = &TRUE
            add esi 9
L1:         While B$esi = ' ' | inc esi | End_While
            If B$esi = ','
                inc esi | jmp L1<
            End_If

            mov eax &FALSE | call IsItIncIncluder

            If eax = &TRUE
                mov eax &FALSE | call IsTheActualTitleIncluded | On eax = &TRUE, ret
            End_If
        .End_If

        inc esi

    .End_While

    mov eax &FALSE
ret


IsItPREPARSE:
    ..If D$esi = 'PREP'
        .If D$esi+4 = 'ARSE'
            If B$esi-1 < ' '
                On B$esi+8 = ' ', mov eax &TRUE
            End_If
        .End_If
    ..End_If
ret


IsItIncIncluder:
L0:
    mov ebx D$esi | or ebx 020202020
    ..If ebx = 'inci' ; IncIncluder
        mov ebx D$esi+4 | or ebx 020202020
        .If ebx = 'nclu'
            mov bx W$esi+8 | or bx 02020
            If bx = 'de'
                mov bl B$esi+10 | or bl 020 | On bl = 'r', mov eax &TRUE
            End_If
        .End_If
    ..End_If

    .If eax = &FALSE
L1:     While B$esi > ' ' | inc esi | End_While

        While B$esi = ' '  | inc esi | End_While

        If B$esi = ','
            inc esi | jmp L1<
        End_If

        On B$esi > ' ', jmp L0<
    .End_If
ret

IsTheActualTitleIncluded:
    push esi
        mov esi D$CodeSource, eax &FALSE

        While esi < D$SourceEnd
            ...If D$esi = 'INCI'  ; INCI NCLU DE
                ..If D$esi+4 = 'NCLU'
                    .If W$esi+8 = 'DE'
                        If B$esi-1 < ' '
                            On B$esi+10 = ' ', call IsThisTheActualTitle
                            On eax = &TRUE, jmp L9>
                        End_If
                    .End_If
                ..End_If
            ...End_If

            inc esi
        End_While
L9: pop esi
ret


[PointerToIncFileName: ?]

IsThisTheActualTitle:
    add esi 10
    While B$esi = ' ' | inc esi | End_While
    mov D$PointerToIncFileName esi

    mov edx &FALSE
    While B$esi <> CR | inc esi | End_While
    While B$esi <> '\' | dec esi | End_While | inc esi
    mov edi D$ActualTitle  ; TITLE xxxx
    add edi 6 | While B$edi = ' ' | inc edi | End_While

    While B$esi <> '.'
        mov al B$esi, bl B$edi | inc esi | inc edi | cmp al bl | jne L7>
    End_While

    .If B$esi = '.'
        If B$edi <= ' '
            mov edx &TRUE
        End_If
    .End_If

L7: mov eax edx
ret

____________________________________________________________________________________________


[ExportAjust: ?]    ; The value to turn an Export section Adress to RVA

PrepareDllVariables:
    mov eax D$AppStartOfCode
    add eax D$AppTrueCodeSize | Align_On 0200 eax | mov D$AppStartOfExp eax
    add eax D$ExportSectionLen | Align_On 0200 eax

    If D$RelocSectionSize > 8
        mov D$AppStartOfReloc eax | add eax D$RelocSectionSize | Align_On 0200 eax
    Else
        mov D$AppStartOfSrc eax | dec W$NumberOfSections
    End_If
    sub eax D$AppStartOfExp | add D$AppAllDataSize eax

    move eax D$ExportSectionLen , D$AppExpTrueSize eax
    Align_On 0200 eax | mov D$AppExpAlignedSize eax

    mov eax D$AppCodeRVAoffset
    add eax D$AppFileSizeOfCode | Align_On 01000 eax | mov D$AppBaseOfExp eax

    add eax D$AppExpAlignedSize | Align_On 01000 eax

    move D$SectionTable D$AppBaseOfExp
    move D$SectionTable+4 D$AppExpAlignedSize

  ; For ease of 'FillExportSection' job:
    mov eax D$AppBaseOfExp | sub eax D$ExportListBPtr | mov D$ExportAjust eax

    mov eax D$ExportSectionLen | Align_On 0200 eax | mov D$FileAlignedExportSectionLen eax
ret

;;
 Same for Resources (DLL cases, too).

StripResourcesHeader:
    mov edi ResourceSectionHeader | sub edi DosHeader | add edi D$CodeList
    mov esi DataSectionHeader | sub esi DosHeader | add esi D$CodeList
    mov ecx SourceSectionHeader | sub ecx DataSectionHeader

  ; Just because if we already stripped the Import Section in a DLL, all the records
  ; we are attempting to point to are one Section upward now:
    If D$ImportTrueSize = 0
        sub esi 40 | sub edi 40 | sub ecx 40
    End_If

    rep movsb
    mov ebx NumberOfSections | sub ebx DosHeader | add ebx D$CodeList
    dec W$ebx

  ; Clear the Image Base record for Resource RVA and Size:
    mov edi AppBaseOfRsrc | sub edi DosHeader | add edi D$CodeList
    mov eax 0 | stosd | stosd
ret
;;

WritePE:
    If D$SavingExtension = '.SYS'
        call SetSysSourceSavingName
    Else
        call SetExeSavingName
        mov eax 0 | call WriteEaxToPeCheckSum
    End_If

    call OpenDestinationFile

    mov D$NumberOfReadBytes 0

    call WriteCheckSum

    call 'KERNEL32.WriteFile' D$DestinationHandle, D$CodeList, D$LenOfCode,
                              NumberOfReadBytes, 0

    If B$ExportsectionWanted = &TRUE
        call 'KERNEL32.WriteFile' D$DestinationHandle, D$ExportListBPtr,
                                  D$FileAlignedExportSectionLen, NumberOfReadBytes, 0
    End_If

    If D$SavingExtension = '.SYS'
        jmp L1>
    Else_If D$SavingExtension = '.DLL'
L1:     On D$RelocSectionSize > 8, call 'KERNEL32.WriteFile' D$DestinationHandle,
                                   D$Relocation, D$FileAlignedRelocationSize,
                                   NumberOfReadBytes, 0
    End_If

    call 'KERNEL32.WriteFile' D$DestinationHandle, D$CodeSource, D$SourceLen,
                              NumberOfReadBytes, 0

    call 'KERNEL32.CloseHandle' D$DestinationHandle | mov D$DestinationHandle 0

    On D$SavingExtension = '.SYS', call WriteSysFile
ret

;;
  It has happend that under some condition(s), it is possible that a wrong
  paring of CR/LF come out in a Source. For example "0D, 0D, 0A". As these
  conditions are unknown, a fix is done, here, at Write-Time:

CheckCRLFs:
    mov esi D$CodeSource, edx esi, eax 0 | add edx D$SourceLen
    
    While esi < edx
        If B$esi = CR
            On B$esi+1 <> LF, inc eax
        Else_If B$esi = LF
            On B$esi-1 <> CR, inc eax
        End_If
        
        inc esi
    End_While
 
    ..If eax <> 0
        mov ecx D$SourceLen | add ecx eax | VirtualAlloc Trash ecx
        mov esi D$CodeSource, edi D$Trash, edx esi | add edx D$SourceLen
        
        While esi < edx
            .If B$esi = CR
                If B$esi+1 <> LF
                    movsb | mov B$edi LF | inc edi | inc D$SourceLen
                    hexprint 1
                Else
                    movsb
                End_If
            .Else_If B$esi = LF
                If B$esi-1 <> CR
                    mov B$edi CR | inc edi | movsb | inc D$SourceLen
                    hexprint 2
                Else
                    movsb
                End_If
            .Else
                movsb
            .End_If
            
        End_While
        
        call 'KERNEL32.WriteFile' D$DestinationHandle, D$Trash, D$SourceLen,
                              NumberOfReadBytes, 0
hexprint D$SourceLen
        call 'KERNEL32.CloseHandle' D$DestinationHandle | mov D$DestinationHandle 0
        
        call 'USER32.MessageBoxA' 0, {"
A bad pairing of CR/LF has been found in the Source,
at Write-Time. The problem is fixed, but RosAsm is
going to shut down, and you will have to Re-Load.

Do not care, then, of the Alert Message for corruption.

Sorry for the inconvenient.

In case you could point out what action(s), in the Editor,
could help reproducing these wrong CR/LFs, please report.
", 0}, 
                                     {'Source failure', 0}, 0
        
        call 'Kernel32.ExitProcess' 0
        
    ..End_If
ret
;;

SaveBookMarks:
    mov edi DestinationFile, ecx 0-1, al 0 | repne scasb
    While B$edi <> '.'
        dec edi
    End_While

    push D$edi, edi
        mov eax '.BKM' | stosd

        call OpenDestinationFile

        mov edi D$BookMarks, al 0, ecx 0-1
L0:     repne scasb | cmp B$edi 0 | ja L0<
        sub edi D$BookMarks | inc edi                    ; edi = lenght.

        call 'KERNEL32.WriteFile'  D$DestinationHandle, D$BookMarks, edi,
                                   NumberOfReadBytes, 0

        call 'KERNEL32.CloseHandle' D$DestinationHandle | mov D$DestinationHandle 0
    pop edi, D$edi
ret


StoreChoosenName:
    mov edi MainName, ecx 262, al 0 | rep stosb
    mov edi MainName
L0: lodsb | cmp al 0 | je L9>
           ; cmp al '.' | je L9>
      stosb | jmp L0<

L9: dec edi | cmp B$edi '.' | jne L9< ; Recent add ('.' can be inside the name too!)
    mov B$edi 0
    While B$esi <> '.'
        dec esi
    End_While

L9: lodsd | or eax 020202000
    If eax = '.exe'
        move D$SavingExtension D$ExeExtension
    Else_If eax = '.scr'
        move D$SavingExtension D$ScrExtension
    Else_If eax = '.asm'
        move D$SavingExtension D$ExeExtension
    Else_If eax = '.dll'
        move D$SavingExtension D$DLLExtension
    Else_If eax = '.sys'
        move D$SavingExtension D$SysExtension
    Else
       ; hexxxprint 088888
    End_If
ret

[StoreNameOnly | push #1 | pop esi | call StoreChoosenName]

[SavingExtension: '.EXE'    ExeExtension: '.EXE'    ScrExtension: '.SCR'
 DLLExtension: '.DLL'       SysExtension: '.SYS']

SetExeSavingName:
    mov edi DestinationFile, ecx 262, al 0 | rep stosb
    mov edi DestinationFile, esi MainName
    If B$esi = 0
        mov ax W$DefaultFileName | stosw | jmp L9>
    End_If
L0: lodsb | cmp al 0 | je L9>
        stosb | jmp L0<
L9: mov eax D$SavingExtension | stosd
    mov B$edi 0
ret


SetSysSourceSavingName:
    mov edi DestinationFile, ecx 262, al 0 | rep stosb
    mov edi DestinationFile, esi MainName
    If B$esi = 0
        mov ax W$DefaultFileName | stosw | jmp L9>
    End_If
L0: lodsb | cmp al 0 | je L8>
        stosb | jmp L0<

L8: On W$edi-6 <> 'So', jmp L8>

    If D$edi-4 = 'urce'
        mov B$esi  -7, 0 | jmp L9>
    End_If

L8: mov D$edi 'Sour', W$edi+4 'ce' | add edi 6

L9: mov eax D$SavingExtension | stosd
    mov B$edi 0
ret


[TestName: 'Test.a', 0]

SetTestSavingName:
    mov edi DestinationFile, ecx 262, al 0 | rep stosb
    mov edi DestinationFile, esi TestName
L0: lodsb | stosb | cmp al 0 | ja L0<
    mov B$edi 0
ret


[DefaultFileName: 'PE.', 0]


; Revue: Does not work if the Path contains some '.' Period in a Folder Name (!!!!)....

[FullPartName: B$ ? #&MAXPATH]

SetAsmSavingName:
    mov edi DestinationFile, ecx 262, al 0 | rep stosb

    If B$WeAreSavingPart = &TRUE
        mov esi MainName, edi FullPartName, ecx &MAXPATH | rep movsb | dec edi

        While B$edi = 0 | dec edi | End_While
L0:     cmp B$edi '\' | je L1>
        cmp B$edi ':' | je L1>
            dec edi | jmp L0<

L1:     inc edi
        mov esi PartName
        While B$esi > 0 | movsb | End_While | movsb

        mov esi FullPartName

    Else
        mov esi MainName

    End_If

    mov edi DestinationFile

    If B$esi = 0
        mov ax W$DefaultFileName | stosw | jmp L9>
    End_If

L0: lodsb | cmp al 0 | je L9>
           ; cmp al '.' | je L9>
      stosb | jmp L0<

L9: On B$edi-4 = '.', sub esi 4  ; (RosAsm outputs are always with 3 Chars Extensions).

    mov eax '.asm' | stosd
ret

 ________________________________________________________________________________________
 ________________________________________________________________________________________


____________________________________________________________________________________________
____________________________________________________________________________________________

[ShowWinEquateError: &TRUE]

ReplaceWin32Equates:
    mov esi D$CodeSourceA, edi D$CodeSourceB, ecx D$StripLen
    mov B$ShowWinEquateError &TRUE, B$ErrorLevel 8  ; 'error8'

L0: lodsb

    ..If al = '&'
        On B$esi < 'A', jmp L2>>
        push ecx, esi, edi
            ;dec esi |
            mov D$imm32 0 | call NewSearchForWinEquate
        pop edi, eax, ecx
      ; mov ebx esi | sub ebx eax | sub ecx ebx ; Same:
        add ecx eax | sub ecx esi | jz L9>
            mov eax D$imm32 | call WriteEax


    ..Else_If al = textSign
        On B$esi-2 > LowSigns, jmp L7>
        dec ecx | mov bl al
L1:     stosb | lodsb
        If al = TextSign
            On B$esi > LowSigns, jmp L8>
            jmp L2>
        End_If
        loop L1<

    ..Else

L2:     stosb

    ..End_If

    loop L0<

L9: sub edi D$CodeSourceB | mov D$StripLen edi
    Exchange D$CodeSourceA D$CodeSourceB

    mov D$imm32 0
ret

L7: mov edx D$MissingSeparator1Ptr | jmp L9>

L8: mov edx D$MissingSeparator2Ptr

L9: mov B$Errorlevel 9, ebx esi
    While B$esi > EOI | dec esi | End_While | inc esi
    While B$ebx > EOI | inc ebx | End_While | mov B$ebx 0
    error edx, esi

 ________________________________________________________________________________________
 ________________________________________________________________________________________


  _____________________
  _____________________

; Same as Above, but with some specific computing of newly added [] inside macros
; unfolded. To be restructured later: make the OpenBracket > OpenVirtual job a called
; routine for both here and uper treatements. Too hot now...

ResetForNewBrackets:
    mov esi D$CodeSourceA, edx esi | add edx D$StripLen
L0: .While esi < edx
        lodsb

        If al = TextSign
            While B$esi <> TextSign | inc esi | End_While | inc esi

        Else_If al = '?'
            On B$esi > LowSigns, jmp L0<
            On B$esi-2 > LowSigns, jmp L0<
            mov ebx esi
            While B$ebx <> OpenBracket
                On B$ebx = OpenVirtual, jmp L0<
                dec ebx
            End_While
            mov B$ebx OpenVirtual, ecx ebx

            While B$esi <> CloseBracket
                inc esi
                On esi >= edx, error D$UnPairedNestedBracketsPtr, ecx
            End_While
            mov B$esi CloseVirtual

        End_If
    .End_While
;;
 'ReorderSource' halas impossible, here.
 
 keeping instructions and brackets' declarations mixed together drives to many
 problems; so we now rewrite it all: at first all bracket declarations, then all
 Virtual Data and at last all EOI instructions text:
;;
    move D$StatementsPtr D$StatementsTable, D$StatementsPtr2  D$StatementsTable2

    mov esi D$CodeSourceA,  edi D$CodesourceB

    mov ecx esi | add ecx D$Striplen | sub ecx 3         ; end of source adress

    On B$esi = EOI, inc esi

  ; Store, first, Brackets / VirtualBrackets:
L0: lodsb | cmp esi ecx | ja L9>>
    If al = TextSign
T0:     lodsb | cmp al TextSign | jne T0<
        jmp L0<
    End_If

    cmp al OpenVirtual | je L1>
    cmp al Openbracket | je L1>
    .If al = EOI
        If B$esi = OpenVirtual
            call IsMixed | On eax = &TRUE, add D$StatementsPtr 4
        Else_If B$esi = OpenBracket
            call IsMixed | On eax = &TRUE, add D$StatementsPtr 4
        Else
            add D$StatementsPtr 4
        End_If
    .End_If

    jmp L0<

  ; Brackets / VirtualBrackets found >>> adjust the Statements Table and copy:
L1: call FillStatementsTable2 | add D$StatementsPtr 4

    stosb | mov B$esi-1 0FF | lodsb | jmp L2> ; 0FF mark for start of [ in next part
L1: stosb | mov B$esi-1 0 | lodsb             ; write [...brackets...]
L2: call IsItText | je L1<                    ; for "text with CR/LF inside"
    cmp al CloseVirtual | je L3>
    cmp al Closebracket | jne L1<
L3: mov B$esi-1 0 | stosb

    jmp L0<<

L9:  _________________________________

  ; Restart the copy for Code Statements:
L3: mov esi D$CodeSourceA

    move D$StatementsPtr D$StatementsTable

L4: lodsb | cmp esi ecx | jae L9>> ;!!!!!!!!!    ; je and not ja because of ending EOIs...
    .If al = 0FF
        add D$StatementsPtr 4
        While B$esi = 0 | lodsb | End_While | jmp L4<

    .Else_If al = EOI
        If B$edi-1 = EOI
            sub D$StatementsPtr 4 | sub D$StatementsPtr2 4 | dec ebx
            call FillStatementsTable2 | add D$StatementsPtr 4 | jmp L4<<
        End_If
        call FillStatementsTable2 | add D$StatementsPtr 4

    .Else_If al = meEOI
        On B$esi <> 0FF, jmp L8>
        On B$esi-2 = 0, jmp L4<<

    .End_If
  ; Write the instructions:
L8: stosb | jmp L4<<
  ; Last EOI:
L9: stosb | mov eax edi | sub eax D$CodeSourceB | mov D$Striplen eax

    mov eax D$StatementsPtr2, D$eax 0
    Exchange D$StatementsTable D$StatementsTable2
    ;call TestStatementsTable
    Exchange D$CodeSourceA D$CodeSourceB
ret


; Does the Statement's unfold result in mixed chunks of normal Code and of Declarations?

IsMixed:
    push esi
        mov al B$esi

        If al = OpenVirtual
            mov bl CloseVirtual
        Else
            mov bl CloseBracket
        End_If

        While B$esi <> EOI
            inc esi

            .If B$esi = bl
                On B$esi+1 = meEOI, inc esi

                If B$esi+1 = EOI
                    mov eax &FALSE | jmp L9>
                Else_If B$esi+1 = OpenVirtual
                    mov bl CloseVirtual
                Else_If B$esi+1 = OpenBracket
                    mov bl CloseBracket
                Else
                    mov eax &TRUE | jmp L9>
                End_If
            .End_If

        End_While

L9: pop esi
ret


FillStatementsTable2:
    push eax, ebx
        mov eax D$StatementsPtr, eax D$eax
        mov ebx D$StatementsPtr2, D$ebx eax
        add D$StatementsPtr2 4
    pop ebx, eax
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  Parser of the Parameters being declared as Macros (or direct Data with Automatic Labels).
  Example:
  
  > [Return | mov eax #1]

  > return {RGB 011,022,033}        ; Unfold as: mov eax 0332211
;;

[ParaMacrosMaxLevel: ?    ParaMacroLevel: ?    MacroModifiedExpression: ?]

ParaMacrosParser:
    mov esi D$InstructionB, edi D$InstructionA

    mov edx D$StripLen | add edx esi
    mov D$ParaMacrosMaxLevel 0, D$ParaMacroLevel 0

    While esi < edx
        On B$esi = CloseParaMacro, jmp L1>
        On B$esi = OpenParaMacro, inc D$ParaMacrosMaxLevel
        movsb
    End_While

    On D$ParaMacrosMaxLevel = 0, ret

L1: mov B$MacroModifiedExpression &TRUE

    mov esi D$InstructionB, edi D$InstructionA, ecx D$ParaMacrosMaxLevel

    .While esi < edx
        ...If B$esi = OpenParaMacro
            inc D$ParaMacroLevel

            ..If D$ParaMacroLevel = ecx
                push edx
                    inc esi     ; Strip 'OpenParaMacro' Char.

                    If B$esi = TextSign
                        call UnfoldDataParameter

                    Else_If B$esi+1 = memMarker
                        call UnfoldDataParameter

                    Else
                        call UnfoldMacroParameter

                    End_If

                    mov B$MacroJobIsOver &FALSE
                pop edx

            ..Else
                movsb

            ..End_If

        ...Else_If B$esi = CloseParaMacro
            dec D$ParaMacroLevel
            movsb

        ...Else
            movsb

        ...End_If
    .End_While

    mov ecx edi | sub ecx D$InstructionA
    mov D$StripLen ecx
    Exchange D$InstructionA D$InstructionB
    Exchange D$InstructionAEnd D$InstructionBEnd
ret


UnfoldDataParameter:
    call CreateNoMeanLabel | call WriteNoMeanLabel

    push esi
        inc esi | While B$esi <> CloseParaMacro | inc esi | End_While | inc esi

        While esi < edx | movsb | End_While
        While B$edi-1 = EOI | dec edi | End_While

        mov B$edi meEOI, B$edi+1 '{' | add edi 2
        call WriteNoMeanLabel | mov B$edi ColonSign | inc edi
    pop esi

    While B$esi <> CloseParaMacro | movsb | End_While
    mov B$edi '}', B$edi+1 EOI, B$edi+2 EOI | add edi 3

    mov esi edx
ret

UnfoldMacroParameter:
    push D$Striplen
        mov D$InstructionAptr esi, ebx esi, ecx 0

      ; clear all possible 'Done Flag's:
        While B$ebx <> CloseParamacro
            On B$ebx = 0, error D$ParaMacroPtr
            and B$ebx 00_0111_1111
            inc ecx | inc ebx
        End_While

      ; End Mark and 'Striplen', for the Macros Parser:
        mov B$ebx EOI | mov D$StripLen ecx

      ; Count the Macro Name Length for 'IsItInMacroList':
        mov ebx esi, D$OneWordLen 0
        While B$ebx > LowSigns
            inc D$OneWordLen | inc ebx
        End_While

        push esi
            push edi
                call GetFromQwordCheckSum esi, D$MacroList, D$MacroListLimit
                On eax = 0, error D$ParaMacroPtr

                While B$eax > LowSigns | inc eax | End_While | inc eax
                mov esi D$eax, ecx D$eax+4

            pop edi

            mov D$InstructionBptr edi
            call ReplaceFromMacroData

        pop esi

        While B$esi <> EOI | inc esi | End_While | inc esi

    pop D$Striplen
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;
; mov eax (((12*3) xor 001010101)+2)

[InsideExpression: ?    StartOfSourceExpression: ?    StartOfDestinationExpression: ?
 RealExpression: ?      RealHexaSize: ?]
;;
 Simply searches for '(', saves Pos and call for the translation after count of nested
 levels in ebx.

 In case of Real, i change the Mem Marker from 'R$/F$' to 'Q$/D$' because i store the
 computed Real in Hexa format (it would be far too complicated to rewrite them in
 Math Decimal notation).
;;

ExpressionParser:
    mov edx esi | add edx D$Striplen
    mov B$InsideExpression &FALSE, B$RealHexaSize 0
    mov ebx 0, ecx 0

L0: .While esi < edx
        lodsb

        ..If al = TextSign
            stosb | While B$esi <> TextSign | movsb | End_While | movsb | jmp L0<
        ..Else_If al = OpenSign
            .If B$InsideExpression = &FALSE
                cmp B$esi-2 memMarker | jne L3>
                mov al B$esi-3 | and al 00_0111_1111 ; Mask Equates and Macros Done Flag.
                cmp al 'F' | jne L1>
                    mov B$edi-2 'D', B$RealHexaSize 8 | jmp L2>
L1:             cmp al 'R' | jne L3>
                    mov B$edi-2 'Q', B$RealHexaSize 16
L2:                 mov B$RealExpression &TRUE | jmp L4>
L3:             mov B$RealExpression &FALSE
L4:             mov ebx 0, ecx 0
                mov D$StartOfSourceExpression esi, D$StartOfDestinationExpression edi
            .End_If
            inc ebx | inc ecx | mov B$InsideExpression &TRUE

        ..Else_If al = CloseSign
            On ecx = 0, error D$ParenthesisPtr
            dec ecx

        ..Else_If al = OpenVirtual
            On B$InsideExpression = &TRUE, error D$ParenthesisPtr
            call CheckBracketExpression

        ..Else_If al = Openbracket
            On B$InsideExpression = &TRUE, error D$ParenthesisPTR
            call CheckBracketExpression

        ..Else_If al = EOI
            On B$InsideExpression = &TRUE, error D$ParenthesisPtr

        ..End_If

        ..If ebx > 0
            .If ecx = 0
                push edx
                    If B$RealExpression = &TRUE
                        call ComputeRealExpression
                    Else
                        call ComputeExpression
                    End_If
                    call WriteExpresionResult
                    mov ebx 0, ecx 0, B$InsideExpression &FALSE
                pop edx
                jmp L0<<
            .End_If
        ..End_If

        stosb
    .End_While
ret

;;
Due to the way the Expression Parser replaces Real by 'D$' / 'Q$' Hexa, all the
Components of a Data set with Real Expressions have to be given with a size marker.
The checking operations are repeatedly splitted for speed purpose.
;;


CheckBracketExpression:
; To be reviewed entirely. There is something out of logic at "L1":
    push ebx
    push eax, esi
      ; Is there any Parenthesis???
;;
        While esi < edx
            On B$esi = OpenSign, jmp L1>
            inc esi
        End_While
        jmp L9>>

      ; OK, OpenSign Inside. Is there any Real Marker???
L1:     pop esi | push esi
        While esi < edx
            If B$esi = MemMarker
                mov al B$esi-1 | and al 00_0111_1111
                On al = 'F', jmp L1>
                On al = 'R', jmp L1>
            End_If
            inc esi
        End_While
        jmp L9>>
;;
        mov ebx 0
        While esi < edx
            lodsb
            .If al = MemMarker
                mov bl B$esi-2 | and bl 00_0111_1111

            .Else_If al = OpenSign
                If bl = 'F'
                    jmp L1>
                Else_If bl = 'R'
                    jmp L1>
                End_If

            .End_If
        End_While
        jmp L9>>


      ; OK, OpenSign plus Real Marker inside >>> Want SizeMarkers everywhere. Not
      ; 'everywhere', in fact, but before and after the Expression... :
L1:     pop esi | push esi
        .While esi < edx
            ...If B$esi = OpenSign
              ; MemMarker wanted before Real Expression:
                If B$esi-1 <> numSign
                    On B$esi-1 <> MemMarker, error D$MarkerBeforePtr
                End_If

                mov eax 1
                While eax > 0
                    inc esi
                    If B$esi = OpenSign
                        inc eax
                    Else_If B$esi = CloseSign
                        dec eax
                    End_If
                    On B$esi = CloseBracket, error D$ParenthesisPtr
                    On B$esi = CloseVirtual, error D$ParenthesisPtr
                End_While

              ; Now, ebx at the end of Expression. CloseBracket >>> OK:
                cmp B$esi+1 CloseBracket | je L9>
                cmp B$esi+1 CloseVirtual | je L9>

                inc esi | On B$esi > Separators, error D$MarkerAfterPtr

                push esi
                    inc esi
                    While B$esi > PartEnds
                        inc esi
                    End_While
                    .If B$esi = ColonSign
                        On B$esi+2 <> MemMarker, error D$MarkerAfterPtr
                    .Else_If B$esi <> MemMarker
                        Error D$MarkerAfterPtr
                    .End_If
                pop esi

            ...End_If
L8:         inc esi
        .End_While

L9: pop esi, eax
    pop ebx
ret


[ExpressionResult: ? ?    Operator: ?]

[ExpressionA: ? ExpressionB: ?]
[ExpressionAPtr: ? ExpressionBPtr: ?]
[ExpressionALimit: ?  ExpressionBLimit: ?]

InitExpressionBuffers:
    VirtualAlloc ExpressionA 01000 | add eax 0800
    mov D$ExpressionALimit eax, D$ExpressionAPtr eax
    VirtualAlloc ExpressionB 01000 | add eax 0800
    mov D$ExpressionBLimit eax, D$ExpressionBPtr eax
ret

; Main parsing of one Expression. Calls for storage (in Binary) and for re-write after
; computation, from the more inside level to first one:

ComputeExpression:
    push esi
        mov ecx esi, esi D$StartOfSourceExpression, edi D$ExpressionA
        dec esi | sub ecx esi | rep movsb            ; copy the Expression to 'ExpressionA'.
        mov al 0 | stosb

L0:     mov D$ExpressionResult 0, D$ExpressionResult+4 0, B$Operator OpenSign
        mov esi D$ExpressionA, edi D$ExpressionB, edx 0

        push ebx
L1:         lodsb | stosb | cmp al OpenSign | jne L1<
                dec ebx | jnz L1<
        pop ebx

        If edi > D$ExpressionBLimit
            call ExtendTableMemory ExpressionA, ExpressionAPtr, ExpressionALimit
            call ExtendTableMemory ExpressionB, ExpressionBPtr, ExpressionBLimit
        End_If

L2:     On B$esi = Space, inc esi
        mov eax D$esi | and al 00_0111_1111     ; clear possible 'Done Flag'.

        ...If al >= 'A'
            ..If ax = 'OR'
                mov B$Operator 'O' | add esi 2 | On B$esi = Space, inc esi
            ..Else_If ax = 'XO'
                If B$esi+2 = 'R'
                    mov B$Operator 'X' | add esi 3 | On B$esi = Space, inc esi
                Else
                    jmp L9>> ;error D$ExpressionMemberPtr
                End_If
            ..Else_If al = 'S'
                If W$esi+1 = 'HL'
                    mov B$Operator 'L' | add esi 3 | On B$esi = Space, inc esi
                Else_If W$esi+1 = 'HR'
                    mov B$Operator 'R' | add esi 3 | On B$esi = Space, inc esi
                Else
                    jmp L9>> ;error D$ExpressionMemberPtr
                End_If
            ..Else_If ax = 'AN'
                If B$esi+2 = 'D'
                    mov B$Operator 'A' | add esi 3 | On B$esi = Space, inc esi
                Else
                    jmp L9>> ;error D$ExpressionMemberPtr
                End_If
            ..Else_If ax = 'NO'
                If B$esi+2 = 'T'
                    mov B$Operator 'N' | add esi 3 | On B$esi = Space, inc esi
                Else
                    jmp L9>> ;error D$ExpressionMemberPtr
                End_If
            ..Else
                jmp L9>> ;error D$ExpressionMemberPtr
            ..End_If

        ...Else_If al < '0'
            move D$Operator D$esi | mov B$Operator al | inc esi

        ...Else_If al <= '9'
            push ebx
                If ax = '00'
                    call TranslateBinary | dec esi | call StoreOnExpression
                Else_If al = '0'
                    call TranslateHexa | dec esi | call StoreOnExpression
                Else
                    and B$esi 00_0111_1111
                    call TranslateDecimal | dec esi | call StoreOnExpression

                End_If
            pop ebx

        ...Else
            jmp L9>> ;error D$ExpressionMemberPtr

        ...End_If

        cmp B$esi-1 CloseSign | jne L2<<
            call ReWriteExpression
            dec ebx | jnz L0<<
L9: pop esi
    ret


[ExpressionReal: R$ ?    RealExpressionResult: R$ ?]

ComputeRealExpression:
    On ebx > 1, error D$RealNotationPtr

    push esi
        mov ecx esi, esi D$StartOfSourceExpression, edi D$ExpressionA
        dec esi | sub ecx esi ;| rep movsb          ; copy the Expression to 'ExpressionA'.
      ; Since the Expression parser has moved in between the Equates and Macros jobs,
      ; we have to mask out the Byte HighBit (Done Flag):
L0:     lodsb | and al 00_0111_1111 | stosb | loop L0<
        mov al 0 | stosb


L0:     mov D$RealExpressionResult 0, D$RealExpressionResult+4 0, B$Operator OpenSign
        mov esi D$ExpressionA, edi D$ExpressionB, edx 0

        push ebx
L1:         lodsb | stosb | cmp al OpenSign | jne L1<
                dec ebx | jnz L1<
        pop ebx

L2:     On B$esi = Space, inc esi

        ...If B$esi < '0'
            move D$Operator D$esi | inc esi

        ...Else_If B$esi <= '9'
            push ebx
                mov edi ExpressionReal | call atof      ; Result in ST0
                dec esi
                call StoreOnRealExpression
            pop ebx

        ...Else
            error D$RealNotationPtr

        ...End_If

        cmp B$esi CloseSign | jne L2<<
            call ReWriteRealExpression
            dec ebx | jnz L0<<

L9: pop esi
ret


[NegativeMember: ?]

StoreOnExpression:
    ..If B$Operator >= 'A'
        .If B$Operator = 'O'
            or D$ExpressionResult+4 edx | or D$ExpressionResult eax

        .Else_If B$Operator = 'X'
            xor D$ExpressionResult+4 edx | xor D$ExpressionResult eax

        .Else_If B$Operator = 'N'
            On D$ExpressionResult > 0, error D$ExpressionNOTPtr
            On edx > 0, error D$ExpressionNOTPtr
            not eax
            mov D$ExpressionResult eax

        .Else_If B$Operator = 'A'
            and D$ExpressionResult+4 edx | and D$ExpressionResult eax

        .Else_If B$Operator = 'L'
            On edx > 0, error D$ExpressionSHRPtr
            On eax > 0FF, error D$ExpressionSHRPtr
                mov cl al
                shl D$ExpressionResult+4 cl
                shl D$ExpressionResult cl | adc D$ExpressionResult+4 0

        .Else_If B$Operator = 'R'
            On edx > 0, error D$ExpressionSHRPtr
            On eax > 0FF, error D$ExpressionSHRPtr
                mov cl al
                shr D$ExpressionResult cl
                shr D$ExpressionResult+4 cl | adc D$ExpressionResult 0

        .Else
            mov D$ExpressionResult+4 edx, D$ExpressionResult eax

        .End_If

    ..Else_If B$Operator = AddSign
        add D$ExpressionResult+4 edx | add D$ExpressionResult eax

    ..Else_If B$Operator = SubSign
        sub D$ExpressionResult+4 edx | sub D$ExpressionResult eax

    ..Else_If B$Operator = MulSign
        On edx > 0, error D$TooMuchExpressionPtr
        On D$ExpressionResult+4 > 0, error D$TooMuchExpressionPtr
        mov ecx eax, eax D$ExpressionResult
        mul ecx
        mov D$ExpressionResult+4 edx | mov D$ExpressionResult eax

    ..Else_If B$Operator = DivSign
        mov ecx eax, eax D$ExpressionResult, edx D$ExpressionResult+4
        div ecx | mov edx 0
        mov D$ExpressionResult+4 0 | mov D$ExpressionResult eax

    ..Else_If B$Operator = OpenSign
        mov D$ExpressionResult+4 edx, D$ExpressionResult eax

    ..Else
        error D$ExpressionSignPtr

    ..End_If
ret


; The result of new computed Value is in ST0.

[TempoReal: Q$ ?]

StoreOnRealExpression:
    ..If B$RealHexaSize = 8
        fstp F$TempoReal | fld F$RealExpressionResult
        .If B$Operator = AddSign
            fadd F$TempoReal
        .Else_If B$Operator = SubSign
            fsub F$TempoReal
        .Else_If B$Operator = MulSign
            fmul F$TempoReal
        .Else_If B$Operator = DivSign
            fdiv F$TempoReal
        .Else_If B$Operator = OpenSign
            fld F$TempoReal
        .Else
            error D$RealNotationPtr
        .End_If
        fstp F$RealExpressionResult
    ..Else
        fstp R$TempoReal | fld R$RealExpressionResult
        .If B$Operator = AddSign
            fadd R$TempoReal
        .Else_If B$Operator = SubSign
            fsub R$TempoReal
        .Else_If B$Operator = MulSign
            fmul R$TempoReal
        .Else_If B$Operator = DivSign
            fdiv R$TempoReal
        .Else_If B$Operator = OpenSign
            fld R$TempoReal
        .Else
            error D$RealNotationPtr
        .End_If
        fstp R$RealExpressionResult
    ..End_If
ret


[StartOfHexaExpression: ?]

ReWriteExpression:
    push ebx
        On edx > 0, error D$TooMuchExpressionPtr
        mov esi D$ExpressionA, edi D$ExpressionB

L1:     lodsb | stosb | cmp al OpenSign | jne L1<
                dec ebx | jnz L1<
        dec edi                                         ; skip first '('.
        mov eax D$ExpressionResult

        mov ebx eax, ecx 8, B$StartOfHexaExpression &TRUE

L0:     mov eax ebx | and eax 0_F000_0000 | shr eax 28
        add al '0' | On al > '9', add al 7
        shl ebx 4
        .If B$StartOfHexaExpression = &TRUE
            If al > '0'
                mov B$StartOfHexaExpression &FALSE
                mov B$edi '0' | inc edi
            End_If
        .End_If
        On B$StartOfHexaExpression = &FALSE, stosb | loop L0<

        If B$StartOfHexaExpression = &TRUE              ; Case of result = 0
            mov B$edi '0' | inc edi
        End_If

        While B$esi-1 <> CloseSign
            inc esi                                     ; jmp over resolved part.
        End_While

        If B$esi > PartEnds
            mov al Space | stosb
        End_If

        While B$esi-1 > 0
            movsb                       ; recopy remainder of expression.
        End_While
        Exchange D$ExpressionA D$ExpressionB
        Exchange D$ExpressionALimit D$ExpressionBLimit
    pop ebx
ret


ReWriteRealExpression:
    push ebx
       ; On edx > 0, error TooMuchExpression ; ??????!!!!!!......
        mov esi D$ExpressionA, edi D$ExpressionB

L1:     lodsb | stosb | cmp al OpenSign | jne L1<
                dec ebx | jnz L1<
        dec edi                                         ; skip first '('.

        mov ecx D$RealHexaSize, B$StartOfHexaExpression &TRUE

        If ecx = 16
            mov ebx D$RealExpressionResult+4
        Else
            mov ebx D$RealExpressionResult
        End_If

L0:     mov eax ebx | and eax 0_F000_0000 | shr eax 28
        add al '0' | On al > '9', add al 7
        shl ebx 4
        .If B$StartOfHexaExpression = &TRUE
            If al > '0'
                mov B$StartOfHexaExpression &FALSE
                mov B$edi '0' | inc edi
            End_If
        .End_If
        On ecx = 9, mov ebx D$RealExpressionResult
        On B$StartOfHexaExpression = &FALSE, stosb | loop L0<

        If B$StartOfHexaExpression = &TRUE              ; Case of result = 0
            mov B$edi '0' | inc edi
        End_If

        While B$esi-1 <> CloseSign
            inc esi                                     ; jmp over resolved part.
        End_While

        If B$esi > PartEnds
            mov al Space | stosb
        End_If

        While B$esi-1 > 0
            movsb                                       ; recopy remainder of expression.
        End_While
        Exchange D$ExpressionA D$ExpressionB
        Exchange D$ExpressionALimit D$ExpressionBLimit
    pop ebx
ret


; True final result rewrite in source:

WriteExpresionResult:
    push esi
        mov edi D$StartOfDestinationExpression, esi D$ExpressionA
      ; (Expression 'A' and not 'B' as source, because they are switched after each pass).

      ; SourceCleaner may leave one more SpAce when ",(" encounted >>> to review.
        If B$edi-1 <> Space
            .If B$edi-1 > NoSpaceAfterThis
               ; mov al Space | stosb
            .End_If
        End_If

        While B$esi > 0
            movsb
        End_While
;;
   ; For Analyzes:
  
        push edi
            mov B$edi 0
            mov edi D$StartOfDestinationExpression
            sub edi 3
            howme edi
            exprint D$edi
        pop edi
;;
    pop esi
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 Routines for adressing the lists used for data, data labels and code labels
 three main tables are used:
                              DataList, LabelList, CodeRef.
 DataList is a simple list of double words values. LabelList is a index for DataList
 (set of couples of name / adress pointing to DataList). CodeRef is an index
 (same couples structure), pointing to code symbols evocation (offset in code).

 The two index tables are sets of fields like this:
                             ...|MySymbol|000024A0...|...

 Tables will begin with a dWord for the size in bytes. (of little use)


 Filling certain heads words with zeros is usefull in case of error search
;;

[ListsLength: ?]

InitIndex1:
;;
  None of these tables should be greater than stripLen.
  For a big file like RosAsm source, it makes about 3 Mo. for the 11 tables together
  could be much shorter, if any problem, mainly for last 4 tables.
  
  Though, because of Macros possibly creating Data Labels, for example, it is
  possible to overflow easily, particulary on very small files. So one Page is
  added to these Allocations.
  
  Also 'ListsLength', that is used in 'GetFromQwordCheckSum' for controling the
  matching of a scanned Name with its proper List, must be aligned on its final
  - and not so predictable - size (Align_On 01000).
;;
    add D$StripLen 01000

    move D$ListsLength D$StripLen
    Align_On 01000 D$ListsLength

    VirtualAlloc LabelList D$StripLen
    mov edi D$LabelList | mov eax 0 | stosd
    mov al EOI | stosb | mov D$LabelListPtr edi
    add edi D$StripLen | sub edi TABLES_SECURITY | mov D$LabelListLimit edi

    VirtualAlloc EquateList D$StripLen
    mov edi D$EquateList | mov eax 0 | stosd
    mov al EOI | stosb | mov D$EquateListPtr edi
    add edi D$StripLen | sub edi TABLES_SECURITY | mov D$EquateListLimit edi

    VirtualFree D$EquateSubstitutes
    VirtualAlloc EquateSubstitutes D$StripLen
    mov edi D$EquateSubstitutes | mov D$EquateSubstitutesPtr edi
    add edi D$StripLen | sub edi TABLES_SECURITY
    mov D$EquateSubstitutesLimit edi
    move D$LastEquateList D$EquateList
    move D$LastEquateListPtr D$EquateListPtr

    VirtualAlloc MacroList D$StripLen
    mov edi D$MacroList | mov eax 0 | stosd
    mov al EOI | stosb | mov D$MacroListPtr edi
    add edi D$StripLen | sub edi TABLES_SECURITY | mov D$MacroListLimit edi

    VirtualAlloc MacroData D$StripLen | move D$MacroDataPtr D$MacroData
    mov eax D$MacroData | add eax D$StripLen | sub eax TABLES_SECURITY
    mov D$MacroDataLimit eax

    sub D$StripLen 01000
ret


InitIndex2:
  ; Don't supress reloc table: Pointers needed for setting of other values:
    VirtualAlloc Relocation D$StripLen | move D$RelocationPtr D$Relocation

    VirtualAlloc ApiListA D$StripLen | move D$ApiListAPtr D$ApiListA

    VirtualAlloc ApiListB D$StripLen | move D$ApiListBPtr D$ApiListB

    VirtualAlloc DllList D$StripLen | move D$DllListPtr D$DllList
ret


InitIndex3:
    VirtualFree D$DllList, D$ApiListB, D$ApiListA

    VirtualAlloc CodeRef D$StripLen

    mov edi D$CodeRef | mov eax 0 | stosd
    mov al EOI | stosb | mov D$CodeRefPtr edi

    VirtualAlloc DataRef D$StripLen
    mov edi D$DataRef | mov eax 0 | stosd
    mov al EOI | stosb | mov D$DataRefPtr edi
    mov eax D$StripLen | add eax D$DataRef | sub eax TABLES_SECURITY
    mov D$DataRefLimit eax
ret

 ________________________________________________________________________________________
 ________________________________________________________________________________________
;;
 analyze of data declarations and macros (+ equates)

 Macros and equates bodies are all stored in MacroData. MacroList and EquateList
 could also be only one table, but i choose to separate them because i wanted to
 alternate the two replacement routines (see ReplaceEquatesAndMacros) for flow
 control (source goes forth and back between CodeSourceA and CodeSourceB) and
 because i wanted equate to be replaced in macro statement 'before' expanding job
 Third reason: A macro is always first word of a line / equates may be anywhere
 in a line; so, the job is different.
 ________________________________________________________________________________________

 MacroList looks  ....|name|dWord1 dWord2 Byte|....
                            dWord1 = adress in MacroData
                                  dWord2 = lenght of statement(s)
                                         byte is set to 0 when storing
 This byte is not for expanding control. It is only for end user can check if unsused
 macro are in his source file (The "Unused Symbols" thingie in the Statistics)

 EquateList looks the same.

 MacroData is a simple text list of what is to replace equates and macros without
 any separators.

 EquateList:
 MacroList:         ; storage of macros and equates ...|name|adr/len/flag|...
 MacroData:         ; raugh storage of macros and equates body(no lenght as first word)
;;
 _______________________________________________________________________________________

[LoadAndClear | lodsb | mov B$esi-1 0]
 _______________________________________________________________________________________

; MacroList begin with a Dword for lenght of table followed by macro items.
 _______________________________________________________________________________________

[LastOctetInSource: ?]

StoreEquates:
    mov edi D$EquateListPtr,  B$esi-1 0FF

    If edi > D$EquateListLimit
        call ExtendTableMemory EquateList, EquateListPtr, EquateListLimit
        mov edi D$EquateListPtr
    End_If

L0: push esi | mov ebx 0
L1:     lodsb | inc ebx | cmp al LowSigns | ja L1<
    pop esi | dec ebx | ;call IsItNewEquate  ; with lenght in ebx

L1: LoadAndClear
    If al = Closebracket
        Error D$MissEquateValPtr
    Else_If al = ColonSign
        While B$edi-1 <> EOI | dec edi | End_While
        Error D$EquateLabelPtr edi
    End_If
    cmp al, Space | je L2>                  ; write name in EquateList up to first space
    On al < LowSigns, error D$MissEquateValPtr
        stosb | jmp L1<
L2: mov al EOI | stosb
    mov eax D$MacroDataPtr | stosd          ; write futur adress of data in Macrolist

    call SetQwordCheckSum D$EquateListPtr

    mov D$EquateListPtr edi                 ; save pointer
    mov edi eax                             ; switch from index to data

L3: loadAndClear | cmp al Separators | jb L9>   ; write equate body
    cmp al Closebracket | je L9>            ; in macroData

    .If al = TextSign
        stosb
L4:     loadAndClear | stosb | cmp al TextSign | jne L4<

    .Else_If al = '<'
        On B$esi = SpAce, LoadAndClear
L4:     loadAndClear | cmp al '>' | je L3<
        On al = Closebracket, error D$TextEquatePtr
        stosb
      ; If Space before '>', strip Space:
        If B$esi = Space
            On B$esi+1 = '>', LoadAndClear
        End_If
        jmp L4<

    .Else
        stosb

    .End_If
    jmp L3<

L9: mov bl al                               ; save lasting sign for ending test
    mov eax edi | sub eax, D$macroDataPtr   ; written data lenght in ax
    mov D$MacroDataPtr edi                  ; save pointer
    If edi > D$MacroDataLimit
        call ExtendTableMemory MacroData, MacroDataPtr, MacroDataLimit
    End_If
    mov edi D$EquateListPtr | stosd         ; store data lenght in MacroList (second word)
    mov al 0 | stosb                        ; room for 'done' flag used when replacing
    mov al EOI | stosb
    mov D$EquateListPtr edi                 ; save pointer
    cmp bl Separators | jb L0<<             ; one more equate > store again
ret

[Equateee "merde agaa"  ]
 _______________________________________________________________________________________

StoreMacros:
    mov edi D$MacroListPtr,  B$esi-1 0

    If edi > D$MacroListLimit
        call ExtendTableMemory MacroList, MacroListPtr, MacroListLimit
        mov edi D$MacroListPtr
    End_If

    push esi
        mov ebx 0
L0:     lodsb | inc ebx | cmp al LowSigns | ja L0<
    pop esi
    dec ebx | ;call IsItNewMacro           ; with symbol lenght in ebx

L1: LoadAndClear | cmp al meEOI | je L2>  ; write name in MacroList up to first separator
        stosb | jmp L1<

L2: mov al EOI | stosb                    ; no meEOI in MacroList (yes in MacroData)
    mov eax D$MacroDataPtr | stosd        ; write futur adress of data in Macrolist

    call SetQwordCheckSum D$MacroListPtr

    mov D$MacroListPtr edi                ; save pointer
    mov edi eax                           ; switch EDI from index to data

L3: LoadAndClear | cmp al CloseBracket | je L9>
        stosb | jmp L3<                   ; write macro body and loop
L9: mov eax edi | sub eax D$macroDataPtr  ; written data lenght in eax
    mov D$MacroDataPtr edi

    If edi > D$MacroDataLimit
        call ExtendTableMemory MacroData, MacroDataPtr, MacroDataLimit
    End_If

    mov edi D$MacroListPtr

    stosd                                 ; store data lenght in MacroList (second word)
    mov al 0 | stosb                      ; room for 'done' flag used when replacing
    mov al EOI | stosb
    mov D$MacroListPtr edi
ret
 ________________________________________________________________________________________

; here we use 'LastOctetInSource' instead of checking '||'

StripZeros:
    mov esi D$CodeSourceA,  edi D$CodeSourceB,  ebx 0
L0: lodsb | cmp esi D$LastOctetInSource | jae L9>>
        cmp al 0FF | je L0<
        cmp al 0 | je L0<

L1:     .If al = EOI                            ; difficulty: double separators '||' may
            If B$edi-1 = meEOI                  ; result after storage. case: '|[....]|'
                mov B$edi-1 EOI | jmp L0<       ; same on second pass after '{}'.
            Else_If B$edi-1 = EOI
                jmp L0<
            End_If

        .Else_If al = meEOI
            If B$edi-1 = meEOI
                jmp L0<
            Else_If B$edi-1 = EOI
                jmp L0<
            End_If

        .End_If

L5: stosb | inc ebx | jmp L0<<
L9: mov al EOI | stosb | inc ebx | mov D$StripLen ebx
    mov eax 02020202 | stosd                    ; security

    Exchange D$CodeSourceA D$CodeSourceB
ret


StripDoneStatementsPointers:
    mov esi D$StatementsTable, edi esi

L0: lodsd
    If eax = DoneFlag
        jmp L0<
    Else_If eax > 0
        stosd | jmp L0<
    End_If

    stosd

; Test of Last recorded Code Statement:

;    mov eax edi | sub eax 8 | mov eax D$eax
;
;    mov ebx eax, dl B$ebx+3, B$OldChar dl, B$ebx+3 0
;    pushad
;        mov esi eax
;        call SetDebuggeeText
;        call AskForRedraw
;    popad
;    exprint eax

ret
 _______________________________________________________________________________________

; after storing equates and macros, stripped results of remaining source will be
; written from CodeSourceA to CodeSourceB.
; At last, StripZero will work back again < > A
 _______________________________________________________________________________________
[FirstPassTest: ?]

StoreAllEquates:
    mov B$FirstPassTest 0

    mov esi D$CodeSourceA,  ecx D$StripLen | add ecx esi | inc ecx  ; ecx = max esi value
    mov D$LastOctetInSource ecx,  B$ErrorLevel 0,  D$bracketCounter 0
    move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4

L0: lodsb | call IsItText | je L0<
        cmp al EOI | je L9>>                        ; EOI >>> no more brackets.
    cmp al OpenVirtual | jne L1>
        inc D$bracketCounter
        add D$StatementsPtr 4 | jmp L0<
L1: cmp al Openbracket | jne L0<                    ; loop until '['
        inc D$bracketCounter
        add D$StatementsPtr 4
        push esi
        cmp B$esi '<' | jne L2>                     ; Data Alignement?
       ; cmp B$esi+1 '0' | jb L2>
       ; cmp B$esi+1 '9' | ja L2>
        or B$esi 00_1000_0000  ; to prevent ReplaceEquates from replacing '[<' by '[B' in
                               ; case user define an Equate for '<' Char (not reserved Char)
        pop eax | jmp L0<
L2:     lodsb | cmp al, OpenParaMacro | ja L2<
            mov ecx esi                             ; for end reached test
        pop esi
    cmp al ColonSign | jne L3>                      ; data?
        mov esi, ecx | jmp L0<
L3: cmp al Space | jne L3>                          ; equate?
        call StoreEquates
            mov eax D$StatementsPtr, D$eax DoneFlag
        jmp L0<
L3: cmp al meEOI | je L0<                           ; macro?

L3: Error D$UnknownDataPtr

L9: mov edi D$EquateListPtr, ecx 20 | rep stosb     ; '|||||||' as security tail
    mov eax, D$EquateListPtr | sub eax, D$EquateList; write size of equate list
    mov edi, D$Equatelist | inc eax | stosd         ; at first word
ret


StoreAllMacros:
    mov esi D$CodeSourceA,  ecx D$StripLen | add ecx esi | inc ecx  ; ecx = max esi value
    mov D$LastOctetInSource ecx,  B$ErrorLevel 0,  D$bracketCounter 0
    move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4

L0: lodsb | call IsItText | je L0<
    cmp al EOI | je L9>                             ; EOI >>> no more brackets.
    cmp al OpenVirtual | jne L1>
        inc D$bracketCounter
        add D$StatementsPtr 4 | jmp L0<
L1: cmp al 0FF | je L8>
    cmp al Openbracket | jne L0<                    ; loop until '['
    cmp B$esi '<' | je L0<
L7:     inc D$bracketCounter
        add D$StatementsPtr 4
        push esi
L2:         lodsb | cmp al, LowSigns | ja L2<
            mov ecx esi                             ; for end reached test
        pop esi

L3: cmp al meEOI | jne L0<                          ; macro?
        On B$esi = meEOI, error D$UnexpectedCRLFPtr
        call storeMacros
            mov eax D$StatementsPtr, D$eax DoneFlag
        jmp L0<

L8: lodsb | cmp al 0 | je L8<
    inc D$bracketCounter
    add D$StatementsPtr 4
    dec esi | jmp L0<<

L9: mov edi D$MacroListPtr, ecx 20 | rep stosb      ; '|||||||' as security tail
    mov eax, D$MacroListPtr | sub eax D$MacroList   ; write size of macro list
    mov edi, D$Macrolist | inc eax | stosd          ; at first word
ret


StoreEquatesAndMacros:
    call StoreAllEquates
    call ResolveEquates
    call StoreAllMacros
    call StripZeros

    call StripDoneStatementsPointers
  ; Source: A > B
  ; call TestStatementsTable
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[SortTempoMemory: ?]

SortEquatesAndMacrosLists:
    mov eax D$EquateListPtr | sub eax D$EquateList | inc eax
    On eax = 6, jmp L9>>

    push eax
        VirtualAlloc SortTempoMemory eax
    pop ecx
    push ecx
        mov edi D$SortTempoMemory, esi D$EquateList
        shr ecx 2 | inc ecx | rep movsd

        move D$SortSource D$SortTempoMemory | add D$SortSource 5
        move D$SortDestination D$EquateList | add D$SortDestination 5

        mov D$SortStringNumber 0 | mov esi D$SortDestination

L0:     lodsb | cmp al EOI | jne L0<
        add esi 11
        inc D$SortStringNumber
        cmp esi D$EquateListPtr | jb L0<

        call SortStrings

    pop ecx
    mov esi D$EquateList, edi D$SortTempoMemory
    shr ecx 2 | inc ecx | rep movsd

     move D$SortSource D$SortTempoMemory | add D$SortSource 5
     move D$SortDestination D$EquateList | add D$SortDestination 5

    call SortEquatesStringsBySize

    VirtualFree D$SortTempoMemory
L9: ret


;;
 Source and Destination are Pointers to 2 Tables (same lenght). Source holds a set
 of zero ended strings to be sorted and stored in Destination. Source is overwritten
 with 0FF Bytes when finished.
;;
[SortSource: ?    SortDestination: ?    SortStringNumber: ?]

SortStrings:
    mov ecx D$SortStringNumber, edi D$SortDestination

L0: push ecx

        mov esi D$SortSource, ecx D$SortStringNumber, edx 0, bl 0FF

L1:     lodsb
        .If al = 0FF
            ; nop
        .Else_If al < bl
            mov bl al | lea edx D$esi-1
        .Else_If al = bl
            push ebx
                push edx, esi
                    While al = bl
                        lodsb | inc edx | mov bl B$edx
                        cmp al EOI | je L2>
                    End_While
L2:             pop esi, edx
                On al < bl, lea edx D$esi-1
            pop ebx
        .End_If

        While B$esi > EOI
            inc esi
        End_While
        add esi 11 | loop L1<
; add esi 11, because:
; |EquateName| D$ .... .... B$ .|
;            >    >>>> >>>>    >>^

        If edx > 0
            mov esi edx
            While B$esi > EOI
                movsb | mov B$esi-1 0FF
            End_While
            movsb  ; |
            movsd  ; Ptr to MacroData
            movsd  ; MacroData record length
            movsb  ; Flag
            movsb  ; |
        End_If

    pop ecx | dec ecx | cmp ecx 0 | ja L0<<
ret


; Pointers by Sizes: Each dWord will be (possibily -0, if none-) a Pointer to the
; position of the first Equate Equate in the List having the 'given' number of Chars.
; ('given' by the Routine that will finally *search* for the Equate body:
[LabelsPointersBySizes: EquatesPointersBySizes: ? #100]
[MacrosPointersBySizes: ? #100]

[SortBySizeOver: ?]

SortEquatesStringsBySize:
    mov edi EquatesPointersBySizes, eax 0, ecx 100 | rep stosd

    mov edi D$SortDestination, edx 1

L0: mov esi D$SortSource, ecx D$SortStringNumber, B$SortBySizeOver &TRUE

; There is something wrong in this: If i state 'While B$esi <> EOI' instead of
; 'While B$esi > EOI', it doesn't work. It should, and there is no reason for what
; D$esi could be = 0 (this is to say after the end of the Table -i suppose...)...

L1:     lodsb
        .If al = 0FF        ; Done
            While B$esi > EOI | inc esi | End_While
            add esi 11

        .Else
            push ecx
                mov eax esi, ecx 1
                While B$eax > EOI | inc ecx | inc eax | End_While
                If ecx = edx
                    mov al B$esi-1, B$esi-1 0FF
                    On D$EquatesPointersBySizes+edx*4 = 0,
                        mov D$EquatesPointersBySizes+edx*4 edi
                    stosb
                    dec ecx | jecxz L2>
                        rep movsb
L2:                 movsb  ; |
                    movsd  ; Ptr to MacroData
                    movsd  ; MacroData record length
                    movsb  ; Flag
                    movsb  ; |

                Else
                    lea esi D$eax+11
                End_If

            pop ecx
            mov B$SortBySizeOver &FALSE
        .End_If
    loop L1<

    inc edx | cmp B$SortBySizeOver &FALSE | je L0<<
ret




; input: EBX = lenght of researched label set by caller; >ESI > first letter of new label

[ListNumerix: ?]  ; this value is to be add to tables pointers to jmp over numeric data
                  ; when searching for a name

[SearchMain: ?]
SearchForEntryPoint:
    mov B$SearchMain &TRUE
        call GetFromQwordCheckSum EntryPointLabel, D$LabelList, D$LabelListLimit
        If eax = 0
            mov B$ErrorLevel 9
            error D$NoEntryPtr
        End_If

        While B$eax <> EOI | inc eax | End_While | inc eax
        or B$eax+4 DoneFlag
        mov eax D$eax

    mov B$SearchMain &FALSE
ret

 _________________________________________________________________________________________
;;
 replacements of equates and macro evocation of source file
                              source: < > A
 ReplaceMacAndEqu reads one word from source and call IsItInMacroList. If yes, this
 called routine returns, after read in Macrolist, in ECX the lenght of stored text
 data in MacroData and in ESI the offset of these data.
 Then, ReplaceMacAndEqu calls ReplaceFromMacroData to read these data and write them
 in destination file (a new 'source file'). If a '#' symbol is encounted, in turn,
 ParametersUnfolding is called to read the source parameters
 ________________________________________________________________________________________

 input: InstructionBptr point one text word and OneWordLen gets its lenght; al = last
 character of a one word.
 to avoid a same symbol be booth a label and an equate/macro, no unfolding before ':'
;;

[OneWordLen: ?]

 _______________________________________________________________________________________
;;
 Effective replacement of macros:
 It allows loop if '#+n' statement found at the end of declaration, while getting
 control on parameters number when needed....
 Constant First parameter allowed with '#F'. Last one, with '#L'
 Reverse job allowed with '#n' and global replacement with #x>y'

 Very simple for user > very difficult inside...
;;
 _______________________________________________________________________________________

[AfterLastParameter: ?  NumberOfMacroParameters: ?   LastMacPara: ?
 FirstUnfolded: ?  LastUnfolded: ?  UnfoldingRotations: ?]

SearchLastParameter:
    push esi
        mov B$LastMacPara '0', D$NumberOfMacroParameters 0 | mov esi D$InstructionAptr

      ; Number of spaces >>> Number of Parameters:
        lodsb
        While al > EOI
            If al = space
L1:             inc B$LastMacPara
                inc D$NumberOfMacroParameters
           ; Else_If al = ColonSign
           ;     On B$esi <> EOI, jmp L1<
            End_If
            lodsb
        End_While

        dec esi | mov D$AfterLastParameter esi
    pop esi
ret


[NoLabel: ?  NoSizeMarker: ?]

; Unfolds one parameter

ParameterUnfolding:
    mov B$NoLabel &FALSE, B$NoSizeMarker &FALSE
    .If B$esi = '!'
        inc esi
        If B$esi = '!'
            inc esi | mov B$NoSizeMarker &TRUE
        Else
            mov B$NoLabel &TRUE
        End_If
    .End_If
    push ecx, esi
        mov bl al | cmp bl 'F' | jne L0>    ; 'x' of #x in bl
            mov bl '1' | jmp L6>>
L0:     cmp bl, 'L' | jne L1>
            mov bl B$LastMacPara | jmp L6>>
L1:     cmp bl 'N' | jne L2>
            mov bl B$LastMacPara ; | add bl B$MacrosX ; ah have been 'neg'ed
        ;    On bl = '1',  mov B$FirstUnfolded &TRUE | jmp L6>>

L2:     On bl < '1',  error D$MacNumberPtr
        On bl > '9',  error D$MacNumberPtr
        add bl B$MacrosX | On bl = '1',  mov B$FirstUnfolded &TRUE
        On bl = B$LastMacPara,  mov B$LastUnfolded &TRUE
        ...If B$esi >= '0'
            ..If B$esi <= '9'
              ; Extreemely durty hack to inc _ESI_ and dec ECX: (!!!!!!!!!!!!!!!!!)
                pop eax, ecx
                    inc eax | dec ecx
                push ecx, eax
                sub bl '0' | lea ebx D$ebx*4+ebx | shl ebx 1
                lodsb | sub al '0' | add bl al
                add bl '0'
                .If B$esi >= '0'
                    If B$esi <= '9'
                        error D$TooBigXpTR
                    End_If
                .End_If
            ..End_If

        ...End_If

L6:     mov esi D$InstructionAptr                ; switch from MacroData to clean Code Source (A)

L7:     lodsb                                  ; and search parameter
        On al =< EOI, error D$MissingParameterPtr
        cmp al space | jne L7<                 ; spaces count gives
        inc ecx
            dec bl | cmp bl, '0' | jne L7<       ; parameter position
        and B$esi 00_0111_1111                 ; Strip Equates-done-Flag, if any, because
                                                 ; it may corrupt macro-built-symbols.
        On B$NoSizeMarker = &TRUE, add esi 2

L8:     lodsb | cmp al Separators | jb L9>     ; read in sourceA
        stosb | jmp L8<                        ; write parameter in destination (SourceB)

L9: pop esi, ecx
    If B$NoLabel = &TRUE
       dec edi, ecx
       On B$edi = TextSign, error D$TextKillingPtr
    Else_If B$NoSizeMarker = &TRUE
        sub ecx 2
    End_If
ret


MultiParaCheck:
    cmp al 'F' | jne L0>
        mov al '1' | jmp L9>
L0: cmp al 'L' | jne L1>
        mov al B$LastMacPara | jmp L9>
L1: On al = 'N',  error D$NForbidenPtr
L2: On al < '1',  error D$MacNumberPtr
    On al > '9',  error D$MacNumberPtr
L9: ret
 ____________________________________________
;;
 #
 2   >  al  > bl  |               |  >  al
 >                |  >  xchg  >   |
 L          > al  |               |  >  bl
;;
 ____________________________________________


MultiParametersUnfolding:               ; #x>y  has been found  al = x
   ; On ah > 0, error MacNumber
    On B$MacrosX > 0, error D$MacNumberPtr
    call MultiParacheck

    dec ecx | mov bl al | lodsb         ; ecx = lenght from 'IsItInMacroList'
    dec ecx | lodsb                     ; bl = x   al = y
    call MultiParacheck

    push esi, ecx
        mov esi D$InstructionAptr              ; switch from MacroData to clean Code Source
        xchg al bl | cmp al bl | ja L2>

L1:     call UnfoldOneOfMultiPara | inc al | cmp al bl | jna L1<
            jmp L9>

L2:     call UnfoldOneOfMultiPara | dec al | cmp bl al | jna L2<

L9: pop ecx, esi
ret


UnfoldOneOfMultiPara:
    push eax ebx
        mov bl al | mov esi D$InstructionAptr

      ; Search parameter:
L1:     lodsb
        On al <= EOI, error D$MissingParameterPtr
      ; Spaces count gives parameter position:
        cmp al space | jne L1<
            dec bl | cmp bl, '0' | jne L1<

L2:     lodsb | cmp al, Separators | jb L8>
          ; Cases of Text Parameters (???...):
            If al = TextSign
                stosb
                While B$esi <> TextSign | movsb | End_While
                movsb | jmp L2<
          ; Case of {... #2>L} nested Declarations found in Macro Declarations:
            Else_If al = '}'
                error {"| wanted between Multiple Parameters and '}', in Macro Declaration", 0},
                      D$InstructionAptr
            End_If
          ; write parameter in destination
            stosb | jmp L2<
L3:         dec D$AfterLastParameter
      ; Space forced (avoid '|' when reading, at first, the last parameter)
L8:     mov al space | stosb
L9: pop ebx eax
ret
;;
; I do not recall the reason why i did this strange '}' thingie, previously:
L2:     lodsb
        cmp al, Separators | jb L9>
        cmp al '}' | je L3>
          ; write parameter in destination
            stosb | jmp L2<
L3:         dec D$AfterLastParameter
      ; Space forced (avoid '|' when reading at first the last parameter)
L9:     mov al space | stosb                   
    pop ebx eax
ret
;;

;;
  These are the 128 Bytes Tables for storing whatever the user wants to store:
  The internal macros Variables, &0, &1,... , &99:
;;

[MacrosVariablesTable: ? #(32*102)]
[MacroCounters: ? #100]
[MACRO_VARIABLES 100]

ClearMacroVariable:
    mov edi MacrosVariablesTable, ecx ((32*102)+100), eax 0 | rep stosd
ret


[MixedInternalVariables: 'You cannot mix Internal Variables by text and by Number', 0
 CounterSyntax: "Macros Counters syntax example:
&&21=&&21+1 // &&3=&&60-1 // &&5=0", 0]

StoreMacroVariableByNumber: ; StoreMacroVariable
  ; eax = Displacement to the MacroVariable Record, inside 'MacrosVariablesTable'

  ; esi is pointing after '&&23='

  ; Macros Variables Declarations are not true Statements.
  ; So, we have to strip the leading '|' (meEOI) previously written:
    ;dec edi

    push edi
        lea edi D$MacroCounters+eax*4

L0:     cmp B$esi EOI | jbe L9>>

        lodsb

        .If al = '&'
            lodsb | dec ecx
            On al <> '&', error MixedInternalVariables
                dec ecx
                call ParseCounterToCounterAttribution
              ; Unwanted meEOI:
                ;dec ecx

        .Else_If al = TextSign
          ; skip first TextSign
            dec ecx
            call GetAttributionChar | mov D$edi ebx
          ; skip last TextSign
            inc esi | dec ecx

        .Else_If al = NumSign
            dec ecx | lodsb | dec ecx
            If al = 'N'
                move D$edi D$NumberOfMacroParameters
            Else
                error CounterSyntax
            End_If

        .Else_If al < '0'
            error CounterSyntax

        .Else_If al <= '9'
            dec esi
            call GetAttributionNumber | mov D$edi ebx

        .Else_If al = 'P'
            call SaveStatementCounter | sub ecx 3

        .Else
            error CounterSyntax

        .End_If

        ;loop L0<
L9: pop edi
ret


;;
  Example: &&51=Pos (For the #If #ErrorPos).
  
  Saves the actual Source Parsing Pointer into a Macro Counter that the user will
  possibly reuse for having his private error message coming out, with the source
  being pointed to, eventually, at an upward position from the error detection.
;;
SaveStatementCounter:
    If W$esi = 'OS'
        mov eax D$StatementsPtr
        mov D$edi eax
        add esi 2
    Else
        error CounterSyntax
    End_If
ret


ParseCounterToCounterAttribution:
    call GetMacroVariableDis | mov eax D$MacroCounters+eax*4

    ..If ecx = 0
        ; eax ready

    ..Else_If B$esi <= EOI
        ; eax ready

    ..Else_If B$esi = AddSign
        inc esi | dec ecx
        call GetAttributionNumber
        add eax ebx
        ;.If B$esi = '1'
        ;    inc eax | stosd | inc esi | dec ecx
        ;    If ecx <> 0
        ;        On B$esi > EOI, error CounterSyntax
        ;    End_If
        ;.Else
        ;    error CounterSyntax
        ;.End_If

    ..Else_If B$esi = SubSign
        inc esi | dec ecx
        call GetAttributionNumber
        sub eax ebx
       ; .If B$esi = '1'
       ;     dec eax | stosd | inc esi | dec ecx
       ;     If ecx <> 0
       ;         On B$esi > EOI, error CounterSyntax
       ;     End_If
       ; .Else
       ;     error CounterSyntax
       ; .End_If

    ..Else
        error CounterSyntax

    ..End_If

    mov D$edi eax
ret


[CounterAttribution: 'Bad Number Attribution for internal Counter', 0]

GetAttributionNumber:
    If W$esi = '00'
        call GetAttributionBinary
    Else_If B$esi = '0'
        call GetAttributionHexa
    Else_If B$esi < '0'
        error CounterAttribution
    Else_If B$esi <= '9'
        call GetAttributionDecimal
    Else
        error CounterAttribution
    End_If
ret


GetAttributionBinary:
    mov ebx 0 | inc esi | dec ecx

L0: If B$esi = '1'
        shl ebx 1 | or ebx 1
    Else_If B$esi = '0'
        shl ebx 1
    Else
        ret
    End_If
    inc esi | dec ecx | jnz L0<
ret


GetAttributionHexa:
    mov ebx 0
    push eax
L0:     If B$esi < '0'
            pop eax | ret
        Else_If B$esi <= '9'
            shl ebx 4 | mov al B$esi | sub al '0' | or bl al
        Else_If B$esi < 'A'
            pop eax | ret
        Else_If B$esi <= 'F'
            shl ebx 4 | mov al B$esi | sub al '0' | sub al 7 | or bl al
        Else
            pop eax | ret
        End_If
        inc esi | dec ecx | jnz L0<
    pop eax
ret


GetAttributionDecimal:
    push eax
    mov ebx 0
L0: lodsb
    If al < '0'
        ; Out
    Else_If al > '9'
        ; Out
    Else
        sub al '0'
        lea ebx D$ebx+ebx*4
        lea ebx D$eax+ebx*2
        dec ecx | jnz L0<
    End_If

    dec esi | pop eax
ret

[CounterTextAttribution: 'Max Text Attribution is 4 Chars, for a Counter', 0]

GetAttributionChar:
    mov ebx 0

L0: or bl B$esi  | dec ecx | inc esi
    On B$esi = TextSign, ret
    shl ebx 8 | or bl B$esi  | dec ecx | inc esi
    On B$esi = TextSign, ret
    shl ebx 8 | or bl B$esi  | dec ecx | inc esi
    On B$esi = TextSign, ret
    shl ebx 8 | or bl B$esi  | dec ecx | inc esi
    On B$esi <> TextSign, error CounterTextAttribution
ret
____________________________________________________________________________________________

[WritingLowCounter:
'Only "0" to "9" or "A" to "Z" accepted.', "
Bad writing attempt with Counter &&"
 WritingCounter: 0, 0, 0]

WriteMacroVariableByNumber:
    mov ebx eax
    mov eax D$MacroCounters+eax*4 | stosb

    If al < '0'
        ; bad
    Else_If al > 'Z'
        ; bad
    Else_If al <= '9'
        ; good '1' to '9'
        ret
    Else_If al >= 'A'
        ; goo ''A' to 'Z'
        ret
    End_If

    mov edi WritingCounter, eax ebx
    call WriteEaxDecimal | mov B$edi 0
    error WritingLowCounter
ret


StoreMacroVariable:
  ; eax = Displacement to the MacroVariable Record, inside 'MacrosVariablesTable'

  ; Macros Variables Declarations are not true Statements.
  ; So, we have to strip the leading '|' (meEOI) previously written:
    On B$edi-1 = meEOI, dec edi

    push edi
        lea edi D$MacrosVariablesTable+eax

L0:     cmp B$esi EOI | jbe L9>>
        lodsb                           ; read data from MacroData
        .If al = NumSign                ; if parameter, > unfolding
            lodsb | dec ecx
            If al = 'X'
                mov al B$MacrosX | inc al | call AlToDecimal | loop L0<

            Else_If al = 'N'
                mov al B$NumberOfMacroParameters | call AlToDecimal | loop L0<

            Else_If B$esi = '>'
                mov bl B$LastMacPara
                cmp al '9' | ja L2>
                    cmp al bl | ja L3>
L2:             cmp bl '9' | ja L4>
                    cmp B$esi+1 'L' | je L4>
                        cmp B$esi+1 bl | jbe L4>
L3:             dec edi
                cmp B$edi ColonSign | je C1>
                    cmp B$edi EOI | ja L3<
                        jmp C2>
C1:             inc edi
C2:             add esi 2 | sub ecx 2

                jmp L6>
L4:             call MultiParametersUnfolding
                dec edi
L6:             dec ecx

            Else
                call ParameterUnfolding | dec ecx | jnz L0<<

            End_If

        .Else_If al = '&'
            call GetMacroVariableDis | shl eax 7
            On B$esi = '=', error D$NestedMacroVariablePtr
            call WriteMacroVariable
            jmp L8>
L7:         jmp L0<<
L8:         loop L7<

        .Else_If al = '!'
            dec edi
            jmp L8>
L7:         jmp L0<<
L8:         loop L7<

        .Else
            jmp L8>
L7:         jmp L0<<
L8:         stosb | loop L7<                    ; write body in MacroVx

        .End_If

L9:     mov al 0 | stosb
    pop edi
ret


WriteMacroVariable:
    push esi, ebx
        lea esi D$MacrosVariablesTable+eax
        mov ebx edi | add ebx 80

        If B$esi = 0
         ; This is commented out because it outputs NOPEs every now and then when unwished.
         ; I don't find example, when it could be a problem for Conditional Macros...

         ; mov D$edi 'NOPE' | add edi 4
           pop ebx, esi | ret
        End_If

        .While B$esi > 0
            If B$esi = '&'
                inc esi
                push ecx
                    call GetMacroVariableDis | shl eax 7
                    On B$esi = '=', error D$NestedMacroVariablePtr

                    push esi
                        call WriteMacroVariable
                    pop esi
                pop ecx
            Else
                movsb | On edi = ebx, error D$MacVarOverFlowPtr
            End_If
        .End_While

    pop ebx, esi
ret

____________________________________________________________________________________________

[NoMeanLabel: 'ZZZZZZZZ' 0    NoMeanEaten: 0]

; B$esi > '0' of '&0' when called:

DataNoMeanLabel:
    lodsb                                                ; strip '0'
    If B$esi = ColonSign                                 ; '&0:' Declaration
        On B$NoMeanEaten = &TRUE, error D$Double0Ptr
        call CreateNoMeanLabel
        inc esi | sub ecx 3                              ; strip ':' and '&0:' count
        call WriteNoMeanLabel
        mov al ColonSign | stosb
        mov B$NoMeanEaten &TRUE
    Else                                                 ; '&0' Evocation
        call WriteNoMeanLabel
        sub ecx 2                                        ; strip '&0' count
  ;  Else
        ; i think no error check usefull here because compilation will fail later...
    End_If
ret


; Prepares a new Automatic Label Name, to be written by 'WriteNoMeanLabel':

CreateNoMeanLabel:
    push edi
        mov edi NoMeanLabel | add edi 7
        dec B$edi
        While B$edi < 'A'
            mov B$edi 'Z' | dec edi | dec B$edi
        End_While
    pop edi
ret


; Write the Automatic Label at edi (without trailing Colon):

WriteNoMeanLabel:
    push esi, ecx
        mov esi NoMeanLabel, ecx 8 | rep movsb
    pop ecx, esi
ret

____________________________________________________________________________________________

; Writes al to edi in Decimal form:

AlToDecimal:
    push ecx, eax
        mov ecx 10
        push 0-1
L1:     mov ah 0 | div cl | add ah '0' | push eax | cmp al 0 | ja L1<

L2:     pop eax
        If eax <> 0-1
            mov B$edi ah | inc edi | jmp L2<
        End_If
    pop eax, ecx
ret

;;
  Gets the Macro Variable Displacement, in the 'MacrosVariablesTable'.
  
  called from: 'ReplaceFromMacroData', 'StoreMacroVariable', plus 'WriteFromMacroVariable'
  in cases of nested MacroVariable.
;;

GetMacroVariableDis:
  ; esi points to the Number first Char after the '&':
    mov al B$esi
    cmp al '9' | ja L0>
    cmp al '0' | jae L1>
L0:     error D$MacroVariableIndicePtr

L1: dec ecx
    push ebx
        mov eax 0, ebx 0

L0:     lodsb | sub al '0' | add ebx eax
        cmp B$esi '0' | jb L9>
        cmp B$esi '9' | ja L9>
          ; ebx = ebx*10:
            lea ebx D$ebx*4+ebx | shl ebx 1 | loop L0<

L9:     mov eax ebx
    pop ebx

  ; eax = &Variable Indice from 1 to 100:
    On eax > MACRO_VARIABLES, error D$MacroVariableIndicePtr

  ; eax = Displacement to the proper 128 Byte Record:
  ;  shl eax 7 ; Done by caller
ret


[MacrosX: ?]

; esi point to MacroData, ecx = length of data (set by IsItInMacroList)

testVariable:
    pushad
        mov D$edi '////'
        mov edx D$InstructionBptr | add edx 128
        call ShowMaping D$InstructionBptr, edx, 0
    popad
ret


ReplaceFromMacroData:
    call SearchLastParameter

    mov edi D$InstructionBptr

    mov B$MacrosX 0, B$FirstUnfolded &FALSE, B$LastUnfolded &FALSE, B$NoMeanEaten &FALSE

X0: push ecx, esi
      ; read data from MacroData:
L0:     lodsb

        ...If al = NumSign
          ; "#" Parameter, > Unfolding:
            call ParseMacroParameter

            If ecx = 0-1
                pop esi, ecx | jmp X0<
            Else_If ecx > 0
               jmp L0<
            Else
                jmp L9>>
            End_If

        ...Else_If al = '&'

            ..If B$esi = '0'
            ; '&0' found:
                call DataNoMeanLabel | cmp ecx 0 | ja L0<
                    jmp L9>>

            ..Else
                .If B$esi = '&'
                ; &&1... &&99 numbered Variable:
                    dec ecx | inc esi
                    cmp B$esi '0' | jb N0>
                    cmp B$esi '9' | ja N0>
                        call ParserMacroVariableByNumber | cmp ecx 0 | jg L0<<
                        jmp L9>

                .Else_If B$esi < '1'
                  ; nop
                .Else_If B$esi > '9'
                  ; nop
                .Else
                  ; &1... &99 Variable:
                    call ParseMacroVariable | cmp ecx 0 | ja L0<<

                    jmp L9>

                .End_If

            ..End_If
        ...End_If

N0:     stosb                          ; write
        On edi >= D$InstructionAEnd, error D$MacrosOverFlowPtr
        dec ecx | jnz L0<<
L9: pop esi, ecx                                 ; true stack restore
ret

____________________
; '#' NumSign found:

ParseMacroParameter:
    lodsb | dec ecx

    ..If al = SubSign
        On B$esi-3 > EOI, error D$BadMacroLoopPtr
      ; +/- in bl // 1/.../9 in al:
        mov bl, al | lodsb | dec ecx

      ; Sign was "-":
        If B$FirstUnfolded = &FALSE
            sub al '0' | sub B$MacrosX al
            On B$MacrosX >= 080, error D$InfiniteLoopPtr
            On B$LastMacPara = '0', error D$MacNumberPtr

          ; Restart unfolding signal:
            mov ecx 0-1

        Else
          ; job is done. strip lasting separator:
            dec edi
          ; if some more text after loop symbol (another one is ready from source)
            On ecx > 0, dec ecx

        End_If
        ret

    ..Else_If al = addSign
        On B$esi-3 > EOI, error D$BadMacroLoopPtr
        mov bl, al | lodsb | dec ecx
      ; sign was "+":
        If B$LastUnfolded = &FALSE
            sub al '0' | add B$MacrosX al
            On B$MacrosX >= 080, error D$InfiniteLoopPtr
            On B$LastMacPara = '0', error D$MacNumberPtr

          ; Restart unfolding signal:
            mov ecx 0-1

        Else
          ; job is done. strip lasting separator:
            dec edi
          ; if some more text after loop symbol (another one is ready from source)
            On ecx > 0, dec ecx

        End_If
        ret

    ..Else_If al = 'X'
        mov al B$MacrosX | On al >= 080, neg al
        inc al | call AlToDecimal

    ..Else_If al = 'N'
        mov al B$NumberOfMacroParameters
        call AlToDecimal

    ..Else_If al = '='
      ; Case of "#=4", for forced Parameters control:
        dec ecx | On ecx = 0, error D$MacParaPtr
        lodsb | sub al '0' | On al > 9, error D$MacNumberPtr
        add al '0' | On B$LastMacPara <> al, error D$MissingParameterPtr
        lodsb | dec ecx | On ecx = 0, error D$MacNumberPtr

    ..Else_If B$esi = '<'
        error D$BadMacroDirectionPtr

    ..Else_If B$esi = '>'
        mov bl B$LastMacPara

        If al <= '9'
          ; 'x' expressed number out of parameter range?
            cmp al bl | ja L3>>
        End_If

        .If bl > '9'
          ; #x>y found (x in AL)
            call MultiParametersUnfolding
            dec edi
        .Else_If B$esi+1 = 'L'
            call MultiParametersUnfolding
            dec edi
        .Else_If B$esi+1 <= bl
            call MultiParametersUnfolding
            dec edi
        .Else
L3:         Do
              ; if no parameter fitting with parameter in...
                dec edi

                If B$edi = ColonSign
                    inc edi | jmp C2>
                End_If
            Loop_Until B$edi <= EOI
          ; previous possible mnemonic written at L0:
C2:         add esi 2 | sub ecx 2
        .End_If

    ..Else
      ; #1/.../#9/#F/#L   found:
        call ParameterUnfolding
    ..End_If

L6: dec ecx | ret

____________________________________________________________________________________________



ParserMacroVariableByNumber:
    dec ecx
    call GetMacroVariableDis
    .If B$esi = '='
      ; strip '=', keep '1' in al
        inc esi | dec ecx
        If B$esi = Space
            inc esi | dec ecx
        End_If

        call StoreMacroVariableByNumber

        If ecx = 0
            mov D$edi 'NOPE' | add edi 4
        Else
          ; Strip next '|' (End >>> None >>> 'jg':
            inc esi | dec ecx
        End_If

    .Else
        call WriteMacroVariableByNumber

    .End_If
ret


ParseMacroVariable:
  ; For the previous '&':
    dec ecx
    call GetMacroVariableDis | shl eax 7
    .If B$esi = '='
        inc esi | dec ecx   ; strip '='
        call StoreMacroVariable

      ;  If ecx = 0
      ;      mov D$edi 'NOPE' | add edi 4
      ;  Else
      ;    ; Strip next '|' (End >>> None >>> 'jg':
      ;      inc esi | dec ecx
      ;  End_If

    .Else
        call WriteMacroVariable

    .End_If
ret

 ________________________________________________________________________________________
;;
; NestingCheck compares source before and after unfolding (sourceA / SourceB)
; if something is different , a macro job has been done. We loop all this job
; the stupid way until it be found of no more use.
; When NestingCheck is called, ESI points either to SourceCodeB or to MacroData,
; depending of the replacement work: as text from ESI could be either shorter or
; longer than new text in EDI, a lenght for shorter > ECX > REPE CMPSB can't be known...
; We can't check if parameters were all used because it is allowed to transmit dummy
; parameters (parameters that would be written in macro evocation only for ease of read
; purpose, for exemple).
;
;
; Infinite loop is not completly impossible. exemple:
;        [ mov | mov #2 #1 ]
;          mov eax, ebx      ; >>>>  mov ebx, eax ... and so on.
;
; The only one solution i choose is to stop unfolding after a certain iterations number:
;;

[MacroJobIsOver: B$ ?]

NestingCheck:
    push esi, ecx, eax, edi
        mov esi D$InstructionAptr, edi D$InstructionBptr, ecx 0

        mov ah B$esi-1        ; exemple: with  [Api | push #L>2 | call #1], an
        mov al B$edi-1        ; api call without parameter will be authorized :
        cmp ax ((EOI shl 8)+meEOI) | jne L0>
        ;cmp ax 0201 | jne L0> ; no error message. Compute > (02h)call(03h)Function(02)
            mov B$edi-1 EOI    ; and not:                    (01h)call(03h)Function(02)

L0:     mov ah B$esi,  al B$edi
        ;and eax 00_01111111__01111111
        inc esi | inc edi
        cmp ax ((EOI shl 8)+meEOI) ;0201 ; this appends when a nested macro evocation does'nt have fitting
            jne L1>             ; transmited parameters and is authorized (L>2 for example)
        mov B$edi 2 | mov al 2
L1:     cmp ah al | jne L2>                   ; AH <> AL          >  Job is not over
            cmp al meEOI | je L9>
            cmp al EOI | je L9>               ; AH = AL = '|' (12)    >  Job is over
            jmp L0<
L2:     On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr
        mov D$MacroJobIsOver &FALSE
L9: pop edi, eax, ecx, esi
ret


ReplaceOneMacro: ; esi = D$InstructionB, edi = D$InstructionA
    movsb | jmp L1>                           ; first separator

L0: stosb

L1: lodsb | IfItIsText L0<
        cmp al EOI | je N0>
            cmp al LowSigns | jb L0<          ; meEOI...
                dec esi | jmp L2>
N0:     cmp B$esi EOI | jne L2>               ; end marker = '||' > write it
            stosb | stosb | ret               ; and exit

L2: mov D$InstructionAptr esi,  D$InstructionBptr edi,  D$OneWordLen 0

L3: lodsb | cmp al LowSigns | jb L4>          ; search now lenght of text word:
        inc D$OneWordLen | jmp L3<            ; lenght of one text word in OneWordLen

; now: one source word is pointed by InstructionBptr and OneWordLen contain the length.

L4: cmp al ColonSign | je L9>>                 ; is it a line label?
    mov esi D$InstructionAptr

    and B$esi 00_0111_1111

    call GetFromQwordCheckSum esi, D$MacroList, D$MacroListLimit
    cmp eax 0 | je L5>

        While B$eax > LowSigns | inc eax | End_While | inc eax
        mov esi D$eax, ecx D$eax+4

        call MacroWithIf

        call ReplaceFromMacroData

        call NestingCheck

        mov esi D$AfterLastParameter | jmp L1<<

  ; direct writing:
L5: mov esi D$InstructionAptr,  edi D$InstructionBptr

L6: lodsb | cmp al EOI | jbe L7>
        stosb | jmp L6<
L7:     dec esi | jmp L1<<

  ; write line labels:
L9: mov esi D$InstructionAptr,  edi D$InstructionBptr
L8: lodsb | cmp al ColonSign | je L9>
        stosb | jmp L8<

L9: dec esi | jmp L1<<
____________________________________________________________________________________________

ReplaceEquates:
    movsb | jmp L1>                             ; strip first separator
L0: stosb
L1: lodsb | cmp al TextSign | jne C5>
        stosb
C0: lodsb | stosb | cmp al TextSign | jne C0<
        jmp L1<

C5: cmp al EOI | ja L2>                         ; all possible separators.
C6:     cmp B$esi EOI | jne L0<                 ; end marker = '||' > write it
            stosb | stosb
            ret

L2: cmp al LowSigns | jb L0<
    dec esi | mov D$InstructionBptr esi,  D$InstructionAptr edi,  D$OneWordLen 0

L3: lodsb | cmp al LowSigns | jb L4>            ; search now lenght of text word
        inc D$OneWordLen | jmp L3<              ; > lenght in 'OneWordLen'

  ; now: one source word is pointed by InstructionBptr and OneWordLen contain the length
L4: mov esi D$InstructionBptr
    test B$esi 00_1000_0000 | jnz L6>>           ; to avoid testing words not in list
    cmp B$esi '0' | jb L4>
    cmp B$esi '9' | ja L4>                     ; No need Parsing Numbers.
        mov ecx 0 | jmp L5>

L4: ;call IsItInEquateList                       ; > MacroData adress in esi, len in ecx
   ; On al = ColonSign, inc D$OneWordLen

    cmp al ColonSign | jne L4>
        mov ecx 0 | jmp L5>

L4: call GetFromQwordCheckSum esi, D$EquateList, D$EquateListLimit

    mov ecx eax | cmp ecx 0 | je L5>
        While B$eax > LowSigns | inc eax | End_While | inc eax
        mov esi D$eax, ecx D$eax+4

L5: cmp ecx 0 | ja L5>                          ; ecx = lenght from 'IsItInMacroList'
        mov esi D$InstructionBptr
        or B$esi 00_1000_0000                   ; word was not in list > flag cancel next time
    jmp L6>

  ; write equate body from MacroData (equ and mac body are all in Macrodata)
L5: mov edi D$InstructionAptr | rep movsb | mov D$InstructionAptr edi
    mov esi D$InstructionBptr | add esi D$OneWordLen | mov D$InstructionBptr esi
    mov D$MacroJobIsOver &FALSE | jmp L1<<

L6: ; direct writing from source:
    mov esi D$InstructionBptr,  edi D$InstructionAptr,  ecx D$OneWordLen | rep movsb
    mov D$InstructionBptr esi,  D$InstructionAptr edi | jmp L1<<


NewReplaceEquates:
    mov D$MacroJobIsOver &TRUE, esi D$InstructionA, edi D$InstructionB

    .While B$esi <> 0
        mov al B$esi

        ..If al = TextSign
            movsb | While B$esi <> TextSign | movsb | End_While

        ..Else_If al < LowSigns
            movsb

        ..Else_If al >= '0'
            .If al <= '9'
              ; Skip numbers:
L1:             While B$esi > LowSigns | movsb | End_While

            .Else
              ; Skip non-Equates:
                test B$esi 00_1000_0000 | jnz L1<

              ; Is it in EquateList:
                call GetFromQwordCheckSum esi, D$EquateList, D$EquateListLimit

                If eax = 0
                  ; Not an Equate:
                    or B$esi 00_1000_0000 | jmp L1<

                Else
                  ; Equate body in 'MacroData' (equ and mac body are all in 'Macrodata'):
                    While B$eax > LowSigns | inc eax | End_While | inc eax
                    push esi
                        mov esi D$eax, ecx D$eax+4
                        rep movsb
                    pop esi

                    mov D$MacroJobIsOver &FALSE
                  ; Skip the parsed Equate:
                    jmp L1<

                End_If
            .End_If

        ..End_If
    .End_While

    mov B$esi 0
ret





    movsb | jmp L1>                             ; strip first separator
L0: stosb
L1: lodsb | cmp al TextSign | jne C5>
        stosb
C0: lodsb | stosb | cmp al TextSign | jne C0<
        jmp L1<

C5: cmp al EOI | ja L2>                         ; all possible separators.
C6:     cmp B$esi EOI | jne L0<                 ; end marker = '||' > write it
            stosb | stosb
            ret

L2: cmp al LowSigns | jb L0<
    dec esi | mov D$InstructionBptr esi,  D$InstructionAptr edi,  D$OneWordLen 0

L3: lodsb | cmp al LowSigns | jb L4>            ; search now lenght of text word
        inc D$OneWordLen | jmp L3<              ; > lenght in 'OneWordLen'

  ; now: one source word is pointed by InstructionBptr and OneWordLen contain the length
L4: mov esi D$InstructionBptr
    test B$esi 00_1000_0000 | jnz L6>>           ; to avoid testing words not in list
    cmp B$esi '0' | jb L4>
    cmp B$esi '9' | ja L4>                     ; No need Parsing Numbers.
        mov ecx 0 | jmp L5>

L4: ;call IsItInEquateList                       ; > MacroData adress in esi, len in ecx
   ; On al = ColonSign, inc D$OneWordLen

    cmp al ColonSign | jne L4>
        mov ecx 0 | jmp L5>

L4: call GetFromQwordCheckSum esi, D$EquateList, D$EquateListLimit

    mov ecx eax | cmp ecx 0 | je L5>
        While B$eax > LowSigns | inc eax | End_While | inc eax
        mov esi D$eax, ecx D$eax+4

L5: cmp ecx 0 | ja L5>                          ; ecx = lenght from 'IsItInMacroList'
        mov esi D$InstructionBptr
        or B$esi 00_1000_0000                   ; word was not in list > flag cancel next time
    jmp L6>

  ; write equate body from MacroData (equ and mac body are all in Macrodata)
L5: mov edi D$InstructionAptr | rep movsb | mov D$InstructionAptr edi
    mov esi D$InstructionBptr | add esi D$OneWordLen | mov D$InstructionBptr esi
    mov D$MacroJobIsOver &FALSE | jmp L1<<

L6: ; direct writing from source:
    mov esi D$InstructionBptr,  edi D$InstructionAptr,  ecx D$OneWordLen | rep movsb
    mov D$InstructionBptr esi,  D$InstructionAptr edi | jmp L1<<

____________________________________________________________________________________________


_________________________________________________________________________________________
;;
 As many full passes as needed: one full for equate, one full for macros, ... and loop
 until job is found to be of no more use; this is to say when source and destination
 are the same. All this process is so made one more time than really needed. RosAsm
 Spoil most of compile time here. I have not found something faster with same flexibility.
 Setting a high bit on 'non equates words' saves about 1/7 of compile time.
;;
_________________________________________________________________________________________

ClearDoneHighBit:
    mov esi D$CodeSourceA, ecx D$StripLen, B$InsideText &FALSE
L0: On B$esi = TextSign, xor B$InsideText &TRUE
    On B$InsideText = &FALSE, and B$esi 00_0111_1111
L9: inc esi | loop L0<
  ret


ReplaceEquOnly:
    mov B$UnfoldingRotations 0
L0: inc B$UnfoldingRotations | On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr

    mov D$MacroJobIsOver &TRUE
    mov esi D$InstructionA, edi D$InstructionB

    call ReplaceEquates                         ; SourceB  >  SourceA

    mov ecx edi | sub ecx D$InstructionB
    mov D$StripLen ecx

    If B$MacroJobIsOver = &FALSE
        Exchange D$InstructionA D$InstructionB
        Exchange D$InstructionAEnd D$InstructionBEnd | jmp L0<<
    End_If

    mov esi D$InstructionB, edi D$InstructionA
    call ExpressionParser                       ; SourceA  >  SourceB
    mov ecx edi | sub ecx D$InstructionA | mov D$StripLen ecx

 ;  cmp D$MacroJobIsOver &TRUE | jne L0<        ; set by 'NestingCheck'
ret                                             ; when over > SourceB


NewReplaceEquOnly:
    mov B$UnfoldingRotations 0
L0: inc B$UnfoldingRotations | On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr

    call NewReplaceEquates                         ; SourceB  >  SourceA

    mov ecx edi | sub ecx D$InstructionB
    mov D$StripLen ecx

    If B$MacroJobIsOver = &FALSE
        Exchange D$InstructionA D$InstructionB
        Exchange D$InstructionAEnd D$InstructionBEnd | jmp L0<<
    End_If

    mov esi D$InstructionB, edi D$InstructionA
    call ExpressionParser                       ; SourceA  >  SourceB
    mov ecx edi | sub ecx D$InstructionA | mov D$StripLen ecx

 ;  cmp D$MacroJobIsOver &TRUE | jne L0<        ; set by 'NestingCheck'
ret                                             ; when over > SourceB




ReplaceMacAndEqu:
    mov B$UnfoldingRotations 0
L0: inc B$UnfoldingRotations | On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr

    mov D$MacroJobIsOver &TRUE
    mov esi D$InstructionA, edi D$InstructionB

        call ReplaceEquates ; zReplaceEquates

        mov ecx edi | sub ecx D$InstructionB | mov D$StripLen ecx
            If B$MacroJobIsOver = &FALSE
                Exchange D$InstructionA D$InstructionB
                Exchange D$InstructionAEnd D$InstructionBEnd | jmp L0<<
            End_If

            .Do
                mov B$MacroModifiedExpression &FALSE

                    call ParaMacrosParser

                        mov esi D$InstructionB, edi D$InstructionA

                        call ExpressionParser

                          ; We have to do this here (and not before the RET of
                          ; 'ExpressionParser') because 'ExpressionParser' is
                          ; also called from 'ReplaceEquOnly':
                            mov ecx edi | sub ecx D$InstructionA | mov D$StripLen ecx
                            Exchange D$InstructionA D$InstructionB
                            Exchange D$InstructionAEnd D$InstructionBEnd
                 inc B$UnfoldingRotations
                 On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr

            .Loop_Until B$MacroModifiedExpression = &FALSE

        mov esi D$InstructionB, edi D$InstructionA

        call ReplaceOneMacro

        ;;;;;;;;;;;;;;;;;;; Remove EOI, meEOIs and Spaces right after an EOI:
        mov D$edi 0

        mov esi D$InstructionA, edi esi
        .While B$esi <> 0
            lodsb | stosb
            If al < Separators
                While B$esi = meEOI | inc esi | End_While
            End_If
        .End_While
        ;;;;;;;;;;;;;;;;;;

        mov ecx edi | sub ecx D$InstructionA

      ; If D$InstructionA = EOI, EOI (Cases of empty outputs - impossible actually -):
L2:     If ecx <= 2
            mov edi D$InstructionA, B$edi EOI, D$edi+1 'NOPE', B$edi+5 EOI
            mov D$StripLen 6 | ret
        End_If

        If ecx <> D$StripLen
            mov D$MacroJobIsOver &FALSE
           ; On B$UnfoldingRotations = 0FF, hexprint 6
            On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr
        End_If
        mov D$StripLen ecx

L9: cmp D$MacroJobIsOver &TRUE | jne L0<<                          ; set by 'NestingCheck'
ret                                                                ; when over > SourceB

____________________________________________________________________________________________

zReplaceEquOnly:
    mov B$UnfoldingRotations 0
L0: inc B$UnfoldingRotations | On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr

    call zReplaceEquates

    mov ecx edi | sub ecx D$InstructionB
    mov D$StripLen ecx

    Exchange D$InstructionA D$InstructionB,
             D$InstructionAEnd D$InstructionBEnd

    On B$MacroJobIsOver = &FALSE, jmp L0<<

    call zExpressionParser
ret


zReplaceEquates:
    mov D$MacroJobIsOver &TRUE, esi D$InstructionA, edi D$InstructionB

    .While B$esi <> 0
        mov al B$esi

        ..If al = TextSign
            movsb | While B$esi <> TextSign | movsb | End_While | movsb

        ..Else_If al < LowSigns
            movsb

        ..Else_If al < '0'
          ; Example: '.If':
            jmp L2>

        ..Else_If al >= '0'
            .If al <= '9'
              ; Simple copy (numbers, non-Equates):
L1:             While B$esi > LowSigns | movsb | End_While

            .Else
              ; Skip non-Equates:
L2:             test B$esi 00_1000_0000 | jnz L1<

              ; Is it in EquateList:
                call GetFromQwordCheckSum esi, D$EquateList, D$EquateListLimit

                If eax = 0
                  ; Not an Equate:
                    or B$esi 00_1000_0000 | jmp L1<

                Else
                  ; Equate body in 'MacroData' (equ and mac body are all in 'Macrodata'):
                    While B$eax > LowSigns | inc eax | End_While | inc eax
                    push esi
                        mov esi D$eax, ecx D$eax+4
                        rep movsb
                    pop esi

                    mov D$MacroJobIsOver &FALSE
                  ; Skip the done Equate:
                    While B$esi > LowSigns | inc esi | End_While

                End_If
            .End_If

        ..End_If
    .End_While

    mov B$edi 0
ret



zExpressionParser:
    mov esi D$InstructionA, edi D$InstructionB
    mov edx esi | add edx D$Striplen | inc edx
    mov B$InsideExpression &FALSE, B$RealHexaSize 0
    mov ebx 0, ecx 0

L0: .While esi < edx
        lodsb

        ..If al = TextSign
            stosb | While B$esi <> TextSign | movsb | End_While | movsb | jmp L0<

        ..Else_If al = OpenSign
            .If B$InsideExpression = &FALSE
                cmp B$esi-2 memMarker | jne L3>
                mov al B$esi-3 | and al 00_0111_1111 ; Mask Equates and Macros Done Flag.
                cmp al 'F' | jne L1>
                    mov B$edi-2 'D', B$RealHexaSize 8 | jmp L2>
L1:             cmp al 'R' | jne L3>
                    mov B$edi-2 'Q', B$RealHexaSize 16
L2:                 mov B$RealExpression &TRUE | jmp L4>
L3:             mov B$RealExpression &FALSE
L4:             mov ebx 0, ecx 0
                mov D$StartOfSourceExpression esi, D$StartOfDestinationExpression edi
            .End_If
            inc ebx | inc ecx | mov B$InsideExpression &TRUE

        ..Else_If al = CloseSign
            On ecx = 0, error D$ParenthesisPtr
            dec ecx

        ..Else_If al = 0
            On B$InsideExpression = &TRUE, error D$ParenthesisPtr
            call CheckBracketExpression

        ..End_If

        ..If ebx > 0
            .If ecx = 0
                push edx
                    If B$RealExpression = &TRUE
                        call ComputeRealExpression
                    Else
                        call ComputeExpression
                    End_If
                    call zWriteExpressionResult
                    mov ebx 0, ecx 0, B$InsideExpression &FALSE
                    mov B$MacroModifiedExpression &TRUE
                pop edx
                jmp L0<<
            .End_If
        ..End_If

        stosb
    .End_While

    mov ecx edi | sub ecx D$InstructionB | mov D$StripLen ecx

    Exchange D$InstructionA D$InstructionB,
             D$InstructionAEnd D$InstructionBEnd
ret


zWriteExpressionResult:
    push esi
        mov esi D$ExpressionA, edi D$StartOfDestinationExpression

        While B$esi > 0
            movsb
        End_While
    pop esi
ret
____________________________________________________________________________________________


;;
        mov ecx edi | sub ecx D$InstructionA

      ; If D$InstructionA = EOI, EOI (Cases of empty outputs - impossible actually -):
        If ecx <= 2
            mov edi D$InstructionA, B$edi EOI, D$edi+1 'NOPE', B$edi+5 EOI
            mov D$StripLen 6 | ret
        End_If

        If ecx <> D$StripLen
            mov D$MacroJobIsOver &FALSE
           ; On B$UnfoldingRotations = 0FF, hexprint 6
            On B$UnfoldingRotations = 0FF, error D$InfiniteLoopPtr
        End_If
        mov D$StripLen ecx

L9: cmp D$MacroJobIsOver &TRUE | jne L0<<                          ; set by 'NestingCheck'
ret                                                                ; when over > SourceB
;;

;;
 In previous versions, 'ReplaceMacAndEqu' was called from AsmMain and all replacement job
 was done at once. This new version cuts the job in as tiny parts as possible in order
 to avoid no use loop analyzes.

 First, as Data brackets are stored at the begining of the cleaned source (and can't
 contain any Macro), we compute them one set by one set, only Equates replacement.

 Second, each instruction is done in turn. All this saves about 15% of replacement job.
 2 wide tables are used to store the parts, and exchanges are done between the pointers
 just because i do not wish to rewrite it all for more accurate namings.
;;

[InstructionA: ?  InstructionB: ?   InstructionAEnd: ?  InstructionBEnd: ?
 CodeSourceBpointer: ?  CodeSourceApointer: ?
 OpenType: ?  CloseType: ?]




;;
  NewReplaceMacAndEqu
  
        zReplaceEquOnly
                zReplaceEquates
                zExpressionParser
        
        ReplaceMacAndEquStatement
                zReplaceEquates
                ParaMacrosParser
                        UnfoldDataParameter
                        UnfoldMacroParameter
                zExpressionParser
                        CheckBracketExpression
                        ComputeRealExpression
                        ComputeExpression
                        WriteExpressionResult
                ReplaceOneMacro
                        MacroWithIf
                        ReplaceFromMacroData
                        NestingCheck
;;

NewReplaceMacAndEqu:
  ; Initializations:

    call ClearMacroVariable

    VirtualAlloc InstructionA D$StripLen
    add eax D$StripLen | Align_On 01000 eax | mov D$InstructionAEnd eax

    VirtualAlloc InstructionB D$StripLen
    add eax D$StripLen | Align_On 01000 eax | mov D$InstructionBEnd eax

    mov B$ErrorLevel 0, D$BracketCounter 0

    move D$StatementsPtr D$StatementsTable,
         D$CodeSourceBpointer D$CodeSourceB,
         D$CodeSourceApointer D$CodeSourceA

    mov edi D$CodeSourceBpointer

;;
  The Source has been re-organized: Brackets first // Code Statements last. The
  Brackets sets do not need anything else but the Equates jobs. So, we parse them,
  first. Once an EOI is encounted, this first job is over:
;;

L0: mov esi D$CodeSourceApointer, edi D$InstructionA
    cmp B$esi EOI | je L0>>

  ; Take a copy one Bracket Statement:
    lodsb | mov B$OpenType al

    Do
        lodsb | stosb
        If al = TextSign
L1:         lodsb | stosb | cmp al TextSign | jne L1<
        End_If
        On B$esi-1 = CloseVirtual, jmp C1>
    Loop_Until B$esi-1 = CloseBracket

C1: mov al B$esi-1, B$CloseType al
  ; Keep track of the real Source:
    mov D$CodeSourceApointer esi
  ; Set an end-mark:
    mov B$edi-1 0

    inc D$BracketCounter

    call zReplaceEquOnly ; <<<<<<<<<<<<<<<<

    add D$StatementsPtr 4

  ; Copy the Bracket Statement back to CodeSourceB:
    mov esi D$InstructionA, edi D$CodeSourceBpointer

    mov al B$OpenType | stosb

    While B$esi <> 0 | movsb | End_While

    mov al B$CloseType | stosb

    mov D$CodeSourceBpointer edi | jmp L0<<
____________________________________________________

L0: mov esi D$CodeSourceApointer
    sub D$StatementsPtr 4
    mov B$ErrorLevel 0, D$StatementsCounter 0

[LenghtOfBracketStatements: ?]

    mov eax D$CodeSourceApointer | sub eax D$CodeSourceA | mov D$LenghtOfBracketStatements eax

  ; Take a copy for the Macros jobs:
L0: mov edi D$InstructionA

    mov al EOI | stosb
    Do
        movsb
    Loop_Until B$esi-1 = EOI

    mov D$CodeSourceApointer esi | mov al EOI | stosb | stosb

    inc D$StatementsCounter | call ReplaceMacAndEqu  ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    add D$StatementsPtr 4

    mov esi D$InstructionA, edi D$CodeSourceBpointer | lodsb

L5: lodsb | stosb | cmp al EOI | jne L5<

    mov D$CodeSourceBpointer edi | mov esi D$CodeSourceApointer | cmp B$esi EOI | jne L0<<
    movsb

    Exchange D$CodeSourceA D$CodeSourceB

    push edi
        inc edi | sub edi D$CodeSourceA | mov D$StripLen edi
    pop edi
    mov eax ((EOI shl 24)+(EOI shl 16)+(EOI shl 8)+EOI)  | stosd   ; security

    VirtualFree D$InstructionA, D$InstructionB
    call ClearDoneHighBit
ret

____________________________________________________________________________________________
;;
  'NewBrackets' makes nested Declarations of '[...]' available for next Equates and
  Macros job pass. We have to replace all substitutes by the true signs ('{' > '[',
  and so on). But we have a difficult problem to solve first: These new Declarations
  will be move to top of 'file' by next treatements, and in case of user error search
  among these new created statements, we have to be able to point out the wrong
  original Statement (the user macro Evocation). So have we to add some source pointers
  in 'StatementsTable', with the same pointer value as the one of user Macro. One
  added difficulty is that, is some case, exemple:

  > [CreateEquatesMacro | {#1 #2} | +2]

  ... the original Macro was stored as a Code Statement into 'StatementsTable'. After
  unfolding, there is no more code at this place. So have we to strip one record for
  this, in such cases:
;;
[MoreBracket: ?    InsideNewBracket: ?    TrueCodeInside: ?]

StatementStep:
    mov ebx D$StatementsPtr, ebx D$ebx
    mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4

   ; mov edx D$StatementsPtr+4
   ; While D$edx = ebx
   ;     mov edx D$StatementsPtr2, D$edx ebx
   ;     add D$StatementsPtr 4 | add D$StatementsPtr2 4
   ;     add D$StatementsPtr 4
   ;     mov edx D$StatementsPtr
   ; End_While
ret

NewBrackets:
    mov esi D$CodeSourceA
    mov ecx esi | add ecx D$Striplen                    ; end of source adress

    move D$StatementsPtr D$StatementsTable, D$StatementsPtr2 D$StatementsTable2

    ..While esi < ecx
L0:    lodsb
;On D$esi = 'ENTS', int3
       ...If al = TextSign
L1:         lodsb | cmp al TextSign | jne L1<

       ...Else_If al = '{'
         ; Possible "Bracket only" statement:
      ; On D$esi+15 = 'BIDO', int3
       ; MainWindowProc@BIDON
           ..If B$esi-2 = EOI
               sub D$StatementsPtr 4 | sub D$StatementsPtr2 4
               mov B$TrueCodeInside &FALSE
               .While al <> EOI
                   If al = '{'
                       mov ebx D$StatementsPtr, ebx D$ebx
                       mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4
                       While al <> '}'
                           On al = textSign, call SkipText
                           lodsb
                       End_While
                      ; dec esi ; <<<<<<<< New add while tracking the "Unfolder bug".

                   Else_If al = meEOI
                       On B$esi = EOI, jmp L2>
                       On B$esi <> '{', mov B$TrueCodeInside &TRUE

                   Else_If al = TextSign
                       call Skiptext

                   End_If

L2:                lodsb
               .End_While

               If B$TrueCodeInside = &TRUE
                   mov ebx D$StatementsPtr, ebx D$ebx
                   mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4
               End_If
               add D$StatementsPtr 4
               dec esi

           ..Else
             ; (B$esi-2 = meEOI // al = '{') ---> code sure inside...
               sub D$StatementsPtr 4
               .While al <> EOI
                   If al = '{'
                       mov ebx D$StatementsPtr, ebx D$ebx
                       mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4
                       While al <> '}'
                            On al = textSign, call SkipText
                            lodsb
                       End_While

                   End_If
L2:                lodsb
               .End_While

               dec esi
               add D$StatementsPtr 4

           ..End_If

       ...Else_If al = OpenBracket
           mov ebx D$StatementsPtr, ebx D$ebx | add D$StatementsPtr 4
           mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4

       ...Else_If al = OpenVirtual
           mov ebx D$StatementsPtr, ebx D$ebx | add D$StatementsPtr 4
           mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4

       ...Else_If al = EOI
           On B$esi = OpenVirtual, jmp L3>
           On B$esi = OpenBracket, jmp L3>
               mov ebx D$StatementsPtr, ebx D$ebx | add D$StatementsPtr 4
               mov edx D$StatementsPtr2, D$edx ebx | add D$StatementsPtr2 4
L3:
       ...End_If

    ..End_While

    mov eax D$StatementsPtr2, D$eax 0
    Exchange D$StatementsTable D$StatementsTable2
________________________

; Now, we simply replace substitutes by true Chars. Use of BL reg as a 'Level Counter'
; in order to allow infinite nestings.

    mov B$MoreBracket &FALSE, B$InsideNewBracket &FALSE
    mov esi D$CodeSourceA,  edi D$CodesourceB, ebx 0

    .While esi < ecx
L0:    lodsb
       .If al = TextSign
         ; Skip Text:
L1:        stosb | lodsb | cmp al TextSign | jne L1<

       .Else_If al = '{'
           inc bl | On bl > 1, jmp L8>
           xor B$InsideNewBracket &TRUE
           On B$esi = Space, lodsb
           mov al OpenBracket, B$MoreBracket &TRUE

       .Else_If al = '}'
           dec bl | jnz L8>
           xor B$InsideNewBracket &TRUE
           On B$esi = Space, lodsb
           ;On B$edi-1 = Space, dec edi
           ;On B$edi-1 = meEOI, dec edi
           On B$edi-1 < Separators, dec edi
           mov al CloseBracket

       .Else_If al = '%'
           If B$InsideNewBracket = &TRUE
               On bl = 1, mov al NumSign
               On bl = 2, mov al NumSign

           End_If

       .End_If

L8:    stosb

    .End_While

    mov eax ((EOI shl 24)+(EOI shl 16)+(EOI shl 8)+EOI) | stosd
    mov eax edi | sub eax D$CodeSourceB | mov D$Striplen eax

   ; call TestStatementsTable
    Exchange D$CodeSourceA D$CodeSourceB
ret


SkipText:
    lodsb | While al <> TextSign | lodsb | End_While
ret
__________________________________________________________________________________________
__________________________________________________________________________________________

; PE Import section construction

; uses 3 tables:   ApiListA to store zero ended api calls
;                  ApiListB to store function name with a number at first for Dll
;                  DllList  to store Dll names
__________________________________________________________________________________________


[ALEOD 0FF]       ; Api Lists End Of Data


[Align_on | add #2 #1-1 | and #2 0-#1]
; Same for Aligning on a Variable-defined-Alignment (eax broken):
[Align_on_Variable | push eax
                         mov eax #1 | dec eax | add #2 eax | xor eax 0-1 | and #2 eax
                     pop eax]


[DllNumber: 0  FunctionNumber: 0  ImportHeaderPtr: 0   ImportTablePtr: 0]


InitApiTables:
   mov ax 0FF00                               ; in memory: 00 FF end mark
   mov edi D$ApiListA | mov W$edi ax
   mov edi D$ApiListB | mov W$edi ax
   mov edi D$DllList  | mov W$edi ax
ret
;;
 Test that api call is in the good form:  CALL 'LIB.Function' (one point, no space, not
 open text and turn dll name upper case to prevent from double storage).
 Return: EBX = lenght / ECX = lenght-1  (- last "'")
;;
TestGoodApiCall:
    push esi
      mov ecx 0,  ebx 0                       ; ebx = '.' counter (must be 0 / 1 / or 2)
      push esi
        While B$esi <> TextSign | On B$esi = '.', inc ebx | inc esi | End_While
      pop esi
      On ebx = 0, jmp L9>

      mov ebx 0
L0:   lodsb | inc ecx | cmp ebx, 0 | ja L1>   ; if ebx = 0  >>>  before '.'  >>>  dll name
        cmp al 'a' | jb L1>
        cmp al 'z' | ja L1>
          sub al 32                     ; turn upper case dll name
          mov B$esi-1 al                ; rewrite CodeSourceB
L1:   On al = '.',  inc ebx
      cmp al Space | je L8>
      cmp ecx 1600 ; 150 ; 125 ; 120 |
      je L8>              ; too long
      cmp al TextSign | jne L0<
      cmp ebx 3 |  jb L9>               ; only one '.' wanted
                                        ; ... or 2 in case of Module given Extension...
L8:       mov B$ErrorLevel 6
          mov edi D$ApiListA            ; just to store zero ended name for error search
          pop esi
              While B$esi > TextSign
                  movsb
              End_While
              mov al 0 | stosb
              mov esi D$ApiListA
              Error D$BadApiPtr

L9: pop esi
ret
 ________________________________________________________________________________________

 ; storage of all encounted api calls in ApilistA:

StoreApi:                                ; 5 =  CALL 'LIBRARY.Function'
  ; add esi 5                            ;       .....^
    call TestGoodApiCall
L0: lodsb | cmp al TextSign | je L1>
      stosb | jmp L0<                    ; write in ApilistA
L1: mov al 0 | stosb
ret


; Simple copy of api calls into 'ApiListA' by 'StoreApi'.
; 'ApiListA' will be: LIBRARY.Function, 0, LIBRARY.Function, 0, ... 0FF

SearchForApis:
    mov esi D$CodeSourceB,  edi D$ApiListA

    ;add esi D$LenghtOfBracketStatements

    While B$esi <> EOI | inc esi | End_While | inc esi

  ; Regular Rosasm Api calls:
L0: ...If D$esi = 'CALL'        ; CALL '
L1:     If W$esi+4 = ((TextSign shl 8)+Space)
            add esi 6 | call StoreApi | jmp L0<
        End_If
;;
  For fancyful things for Disassemblies re-compilation: Store in eax +1 for each TextSign,
  +1 for each '.', +1 if lenght > 6.
  
  Must have: 1 or two '.' // 2 TextSigns // be longer than '..xx' (6 Chars).
;;
    ...Else_If B$esi = Textsign
        inc esi | mov eax 1, ebx esi

        While B$esi > LowSigns
            If B$esi = '.'
                inc ah
           ; Else_If B$esi < '0'  ; Dement Chars in some Api Names !!!!.... :(
           ;      jmp L5>
            Else_If B$esi > 'z'
                jmp L5>
            End_If

            inc esi
        End_While

        On B$esi = TextSign, inc al

        On ah = 2, dec ah       ; 2 '.' allowed in:  mov eax 'MODULE.ext.Funtion'

        .If eax = 01_02
            mov ecx esi | sub ecx ebx
            If ecx > 6
                mov esi ebx | call StoreApi | jmp L0<<
            End_If
        .End_If

    ...End_If

L5: lodsb | cmp al EOI | jne L0<<
    cmp B$esi EOI | jne L0<<                     ; End of file reached?

    .If edi = D$ApiListA
        On D$SavingExtension = '.DLL', jmp L9>

            call 'USER32.MessageBoxA' D$hwnd,
            {"Are you sure you want to continue assemblying this?" 0},
            D$NoApiPtr, &MB_SYSTEMMODAL__&MB_ICONEXCLAMATION__&MB_YESNO
            If eax = &IDNO
                mov B$CompileErrorHappend &TRUE, D$NextSearchPos 0
                call CloseProgressBar
                cld | mov esp D$OldStackPointer
                call ReleaseAsmTables
                ret ; for 'no search' errors (esi known) or 'Main:' missing
           End_If
           jmp L9>
    .End_If

    mov al ALEOD |  stosb                       ; end mark for ApiList (strings are zero ended)
L9: ret

;;
'ApiListA' may contain 3 different forms o api calls: 
> MODULE.Function, 0, MODULE.ext.Function, 0, Function, 0...
We turn them all into:
> MODULE.ext.Function, 0, MODULE.ext.Function, 0, MODULE.ext.Function, 0...
;;
FullfillApiList:
    mov D$ModuleHandlesListPointer ModuleHandlesList

  ; First generalise the found MODULE(s) to all naked 'Function'(s)
    mov esi D$ApiListA, edi D$ApiListB

    call FullfillWithExtensions

    mov esi D$ApiListA | While B$esi = 0 | inc esi | End_While

    call FullfillWithoutExtensions

    mov B$edi ALEOD | Exchange D$ApiListA D$ApiListB

    mov ebx D$ModuleHandlesListPointer, D$ebx 0

; Test for viewing the new Api List:
;;
    mov esi D$ApiListA
    .While B$esi <> ALEOD
        howMe esi
        While B$esi <> 0 | inc esi | End_While | inc esi
    .End_While
    Error BadApi
;;

  ; Now, verify that 'ApiListB' is entirely zeroed:

    mov esi D$ApiListB
    .While B$esi <> ALEOD
        If B$esi <> 0
            mov B$ErrorLevel 6 | Error D$BadApiPtr
        End_If
        inc esi
    .End_While
ret


FullfillWithExtensions: ; 'FullfillWithoutExtensions'
    ..While B$esi <> ALEOD
        mov ebx esi, edx 0, ecx 0

        While B$esi <> 0
            inc esi
            .If B$esi = '.'
                If edx = 0
                    lea edx D$esi+1
                Else_If ecx = 0
                    mov ecx edx | lea edx D$esi+1
                Else
                    Error D$BadApiPtr
                End_If
            .End_If
        End_While
      ; Here, edx > Start of Function Name,
      ;       ecx > Start of Module Extension,
      ;       ebx > Start of Module Name
      ;       esi > ending 0
        ..If ecx <> 0
          ; Cases of 'MODULE.ext.Function':
            mov eax edx | sub eax ecx
            If eax > 4
                mov B$ErrorLevel 6, esi ebx
                error D$BadApiPtr
            End_If
            mov esi ebx, D$StartOfDllName edi, D$StartOfFunctionName edx

            While B$esi <> '.' | movsb | End_While | movsb

          ; HAL DLL cannot be loaded in User Mode (consider it like a .sys):
            mov B$WasSysModule &FALSE

            call IsItHAL

          ; Also, .sys Modules cannot be loaded like a DLL:
            mov eax D$esi | or eax 0202020
            On eax = 'sys.', mov B$WasSysModule &TRUE

            While B$esi <> '.' | movsb | End_While | mov D$edi 0

            .If D$ApiCheckFlag <> 2
                If B$WasSysModule = &FALSE
                    call VerifyModuleWithExtensionExist
                    call VerifyFunctionExist
                End_If
            .End_If

            movsb | While B$esi <> 0 | movsb | End_While | movsb

            call AraseSameFunctions

        ..End_If

        While B$esi = 0 | inc esi | End_While
    ..End_While
ret


[WasSysModule: WasHALdll: ?]

IsItHAL:
    mov eax D$StartOfDllName, eax D$eax | or eax 0202020
    If eax = 'hal.'
        mov B$WasSysModule &TRUE
    Else_If eax = 'hal'
        mov B$WasSysModule &TRUE
    End_If
ret


FullfillWithoutExtensions: ; 'FullfillWithExtensions'
L0: ..While B$esi <> ALEOD
        mov ebx esi, edx 0, ecx 0
        While B$esi <> 0
            inc esi
            If B$esi = '.'
                lea edx D$esi+1 | jmp L1>
            End_If
        End_While

      ; Here, edx > Start of Function Name,
      ;       ebx > Start of Module Name
L1:     ..If edx <> 0
          ; Cases of 'MODULE.Function'
            mov D$StartOfDllName edi, D$StartOfFunctionName edx
            mov esi ebx | While B$esi <> '.' | movsb | End_While | mov B$edi 0

            mov B$WasSysModule &FALSE | call IsItHAL

            .If B$WasHALdll = &FALSE
                If D$ApiCheckFlag <> 2
                    call VerifyModuleExist | stosd
                    call VerifyFunctionExist
                Else
                    mov D$edi '.dll' | add edi 4
                End_If
            .Else
                mov D$edi '.dll' | add edi 4
            .End_If

            While B$esi <> 0 | movsb | End_While | mov D$edi 0 | inc edi

            call AraseSameFunctions

        ..End_If

        While B$esi = 0 | inc esi | End_While
    ..End_While
ret


; A 'MODULE.ext.Function' or a 'MODULE.Function' has been found, and recorded.
; We arase all other occurences of 'xxxxFunction':
[CopyOfFunctionName TrashString] ;: ? #32]

AraseSameFunctions:
  ; Now, arase all other evocations of 'MODULE.ext.Function', 'MODULE.Function',
  ; 'Function', in 'ApiListA':
    push esi, edi, edx

        mov esi D$StartOfFunctionName, edi CopyOfFunctionName
        While B$esi <> 0 | movsb | End_While | mov D$edi 0

        mov esi D$ApiListA, edi CopyOfFunctionName, bl B$edi
      ; edx used to test if the first name in ApiListA fits with the searched one:
        mov edx esi | inc edx

L1:     .While B$esi <> ALEOD
            lodsb

            ...If al = bl
                If esi = edx
                    ; Compare (Cases of very first api call in 'ApiListA' given without DLL)
                Else_If B$esi-2 = 0
                    ; Compare
                Else_If B$esi-2 = '.'
                    ; Compare
                Else
                    jmp L1<
                End_If
                push ebx, esi
                    dec esi | mov edi CopyOfFunctionName
L2:                 mov al B$esi, bl B$edi
                    On al <> bl, jmp L7>>
                    On al = 0, jmp L5>
                    On bl = 0, jmp L5>
                    inc esi | inc edi | jmp L2<
L5:                 or al bl
                    ..If al = 0               ; Same > arase:
                        mov edx esi
                        pop esi | push esi
                        mov ebx 0
                        While B$esi <> 0
                            dec esi | On B$esi = '.', inc ebx
                            cmp esi D$ApiListA | je L2>
                        End_While
                        inc esi
L2:                     .If ebx > 0
                            mov ebx D$StartOfDllName
                            mov ebx D$ebx
                            On ebx = D$esi, jmp L2>
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ; New: for Disassemblies:
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                If B$CopyOfFunctionName = '0'
                                    While B$esi <> 0 | inc esi | End_While | jmp L7>
                                End_If
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                mov B$ErrorLevel 6 | error D$DoubleFunctionPtr
                        .End_If
L2:                     While B$esi <> 0 | mov B$esi 0 | inc esi | End_While
                    ..End_If
L7:             pop esi, ebx
            ...End_If

        .End_While
    pop edx, edi, esi
ret


IsItNewDll:
    push edi
      mov edi D$DllList | mov ebx 0 | jmp L1>
L0:   mov al 0,  ecx 0FF
        repne scasb
      cmp B$edi ALEOD | jne L1>
        mov ebx 0 | jmp L9>
L1:     push esi edi
          mov ecx 0FF,  eax 0 | inc ebx
            repe cmpsb
          mov al B$edi-1,  ah B$esi-1
        pop edi esi
        cmp eax 02E00 | jne L0<         ; ('.' in ApiListA, 0 in DllList)
L9: pop edi
ret                                     ; >>> ebx = Dll #n or 0


IsItNewFunction:       ; edi > ApiListB end; esi > ApiListA function name; al > dll #n
    push edi
      mov bl al | mov edi D$ApiListB | jmp L1>
L0:   mov al 0,  ecx 0FF
        repne scasb
      cmp B$edi ALEOD | jne L1>             ; reach end ?
        mov al bl | jmp L9>
L1:   cmp B$edi bl | jne L0<
        inc edi
        push esi edi
          mov eax 0
L2:       mov al B$edi,  ah B$esi
          inc edi | inc esi
          cmp eax 0 | je L3>
          cmp ah al | je L2<
L3:     pop edi esi
        cmp eax 0 | jne L0<
L9: pop edi
    cmp al 0
ret                                         ; >>> ebx = Dll #n or 0


StoreDllName:
    cmp D$DllNumber 0 | je L1>
    call IsItNewDll | cmp ebx 0 | je L1>    ; if 0  >>>  new name to store

L0: lodsb | cmp al '.' | jne L0<
    inc esi
L3: lodsb | cmp al '.' | jne L3<
L4: mov eax ebx                             ; ebx from 'IsItNewDll'
ret

L1: push edi
        mov edi D$DllListPtr
      ; write a new "Dll" name (with Extension):
L2:     lodsb | stosb | cmp al '.' | jne L2<
        While B$esi <> '.' | movsb | End_While
        inc esi
        mov al 0 | stosb | mov B$edi ALEOD                     ; end mark
        mov D$DllListPtr edi | inc D$DllNumber | mov eax D$DllNumber
    pop edi
ret


SortApis:
    mov D$DllNumber 0,  D$FunctionNumber 0
    mov esi D$ApiListA,  edi D$ApiListB
    mov eax 0,  ebx 0
L0: cmp B$esi ALEOD | je L9>>
      call StoreDllName             ; return: ebx = 0 if new, else Dll #
      call IsItNewFunction          ; return: ebx = 0 if new, else Dll #
        ja L2>
L1:  lodsb
       cmp al 0 | jne L1<
         jmp L0<
L2:  stosb                          ; write dll #n
L3:  lodsb
     stosb                          ; write function name until 0
       cmp al 0 | jne L3<
         mov B$edi ALEOD | inc D$FunctionNumber | jmp L0<
L9: ret

;;
 "FreeLibrary" function does NOT really strip off the DLL from memory, if it is of no
 more use. This appends only when we exit our Process. So, After each DDL testing, we
 let it in memory. At each test, we first check if it is already loaded, instead.
;;
[DllHandle: ?    StartOfDllName: ?    StartOfFunctionName: ?    RosAsmDLL: ?]

[ModuleHandlesList: ? #100] [ModuleHandlesListPointer: ?]

VerifyModuleExist:
    pushad
        mov esi D$StartOfDllName

        call TryToLoadModule '.dll'
        If eax <> &NULL
            mov D$DllHandle eax | popad | mov eax '.dll' | ret
        End_If

        call TryToLoadModule '.sys'
        If eax <> &NULL
            mov D$DllHandle eax | popad | mov eax '.sys' | ret
        End_If

        call TryToLoadModule '.drv'
        If eax <> &NULL
            mov D$DllHandle eax | popad | mov eax '.drv' | ret
        End_If

        call TryToLoadModule '.exe'
        If eax <> &NULL
            mov D$DllHandle eax | popad | mov eax '.exe' | ret
        End_If

    mov esi D$StartOfDllName, B$ErrorLevel 4 | error D$BadLibNamePtr


VerifyModuleWithExtensionExist:
    pushad
        mov B$RosAsmDLL &TRUE | call 'KERNEL32.GetModuleHandleA' D$StartOfDllName

        .If eax = &NULL
            mov B$RosAsmDLL &FALSE | call 'KERNEL32.LoadLibraryExA' D$StartOfDllName, 0, D$APICheckFlag
; &DONT_RESOLVE_DLL_REFERENCES &LOAD_LIBRARY_AS_DATAFILE &LOAD_WITH_ALTERED_SEARCH_PATH
            If eax = &NULL
                call TryModuleFromAppDirectory D$StartOfDllName
            End_If

            mov ebx D$ModuleHandlesListPointer, D$ebx eax
            add D$ModuleHandlesListPointer 4
        .End_If

        If eax = &NULL
            mov esi D$StartOfDllName, B$ErrorLevel 4 | error D$BadLibNamePtr
        End_If

        mov D$DllHandle eax
    popad
ret


[ExeSysDrvModuleName: ? #20]

Proc TryToLoadModule:
    Argument @Ext

        mov esi D$StartOfDllName, edi ExeSysDrvModuleName
        While B$esi <> 0 | movsb | End_While
        mov B$edi 0
        move D$edi D@Ext | mov B$edi+4 0

        mov B$RosAsmDLL &TRUE | call 'KERNEL32.GetModuleHandleA' ExeSysDrvModuleName

        .If eax = &NULL
            mov B$RosAsmDLL &FALSE | call 'KERNEL32.LoadLibraryExA' ExeSysDrvModuleName, 0, D$APICheckFlag

            If eax = &NULL
                call TryModuleFromAppDirectory ExeSysDrvModuleName
            End_If

            If eax <> &NULL
                mov ebx D$ModuleHandlesListPointer, D$ebx eax
                add D$ModuleHandlesListPointer 4
            End_If
        .End_If
EndP


;;
  Some users' reports seem to imply that, under some OS Versions, the Directory
  that is considered the default one, for the LoadLibrary Function, could be the
  one where RosAsm lies, instead of the one where the Compiled App lies.
  
  This routines tries to force the Full Path as a last rescue.
;;
[ModuleFullPath: B$ ? #&MAXPATH]

Proc TryModuleFromAppDirectory:
    Argument @Module

        mov edi ModuleFullPath, esi MainName
        While B$esi <> 0 | movsb | End_While
        While B$edi-1 <> '\' | dec edi | End_While

        mov esi D@Module
        While B$esi <> 0 | movsb | End_While | movsb

        call 'KERNEL32.LoadLibraryA' ModuleFullPath
;;
        If eax = 0
            ; call 'KERNEL32.GetLastError'
            ; ---> &ERROR_NOACCESS 
            
            call 'KERNEL32.CreateFileA' ModuleFullPath, &GENERIC_READ,
                                    &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL, 0
            
        End_If
;;
EndP


[Aerror: ?]

VerifyFunctionExist:
    pushad
        mov eax D$StartOfFunctionName

        If B$eax = '0'
            mov esi eax | call TranslateHexa
            call 'KERNEL32.GetProcAddress' D$DllHandle, eax
            On eax = &NULL, error D$BadOrdinalPtr
        Else
            call 'KERNEL32.GetProcAddress' D$DllHandle, D$StartOfFunctionName
        End_If

        .If eax = &NULL
            mov edi D$StartOfFunctionName, al 0, ecx 0FFFF | repne scasb
            sub edi 2
            push D$edi, edi
                If B$edi = 'A'
                    mov B$Aerror &FALSE
                Else
                    inc edi | mov al 'A' | stosb | mov B$Aerror &true
                End_If
                mov al 0 | stosb

              ; test with ending 'A'
                call 'KERNEL32.GetProcAddress' D$DllHandle, D$StartOfFunctionName

                mov esi D$StartOfFunctionName, B$ErrorLevel 5  ; error5
            pop edi, D$edi
            inc edi
            push eax
                mov al "'" | stosb | mov al 0 | stosb          ; retore for string search
            pop eax
            If eax = &NULL
                error D$BadFunctionNamePtr
            Else_If B$Aerror = &TRUE
                error D$MissingApiAPtr
            Else
                error D$NoAapiPtr
            End_If
        .End_If
    popad
ret

; Room for headers has been set by 'InitIndex' (CodeListPtr=CodeList+0400)

; We read a Dll Name in DllList (> first = #1)
; We read all #1Functions in ApiListB, and so on.

CreateImportSection:
 ; room for header = (dWord * 5) * (DllNumber + 1)
 ; room for Tables 1, 2 = FunctionNumber + group zero ending = FunctionNumber + DllNumber

    mov D$DllHandle 0
    mov edi D$CodeListPtr                   ; set at 0400 by 'List.a' initialisations
    mov D$ImportHeaderPtr edi

    mov eax D$Dllnumber | inc eax
    shl eax 2 | mov ebx eax | shl ebx 2 | add eax ebx    ; (eax*4)+(eax*16) = eax * 20
    mov ecx eax | mov D$AppImportSize eax   ; write import header size in PE sections header
    push eax
      mov al 0 | rep stosb        ; room for header (eax = header size)
    pop eax
    mov D$ImportTablePtr edi      ; Pointer for Functions names adresses tables writing
    mov eax D$FunctionNumber | add eax D$Dllnumber
    shl eax 2                     ; eax = room for Dwords (shl 2) ptrs
    mov edx eax                   ; EDX = one table size
    add edi eax                   ; room for table 1
    mov ebx edi
      sub ebx D$CodeList
      add ebx 01000                       ; 'uBaseOfImport' not yet filled
        sub ebx 0400                      ; 'uStartOfImport' not yet filled
          mov D$AppSecondImport ebx       ; write adress in PE sections header
          mov D$AppSecondImportSize edx   ; write size in PE sections header
    add edi eax                           ; room for table 2

    mov esi D$DllList | mov eax D$ApiListB,  D$ApiListBPtr eax
    mov cl 1                              ; cl = DLL indice for each function

nextdll:
    On B$esi = ALEOD,  jmp L9>>     ; end mark in DllList
    mov eax edi | sub eax D$CodeList | add eax 01000-0400
    mov ebx D$ImportHeaderPtr
    mov D$ebx+12 eax                ; List adress of dll name written at header fourth dWord
    mov eax D$ImportTablePtr | sub eax D$CodeList | add eax 01000-0400
    mov D$ebx eax | add eax edx | mov D$ebx+16 eax
    mov D$StartOfDllName edi
L0: lodsb                           ; from DllList
      cmp al 0 | je L1>
        stosb                       ; write dll name in Import name list
      jmp L0<
L1: mov B$edi 0                     ; end mark in Import table (will be overwritten)

    mov D$DllListPtr esi
    mov al 0 | stosb
T0: mov esi D$ApiListBPtr

L2: lodsb
     cmp al cl | je L4>             ; actual DLL function?
     cmp al, ALEOD | jne L3>        ; reach end of ApiListB ?
       mov W$edi 0 | add edi 2
       test edi 1 | jz T0>
         mov B$edi 0 | inc edi
T0:    mov ebx D$ImportTablePtr
       mov D$ebx 0                 ; write function name end of chunk in table 1
       mov D$ebx+edx 0             ; write function name end of chunk in table 2
       add D$ImportTablePtr 4      ; ready for next one
       inc cl
       mov  esi D$DllListPtr
       add D$ImportHeaderPtr 20

       jmp nextdll
L3: lodsb
      cmp al 0 | jne L3<
        jmp L2<

L4: mov ebx D$ImportTablePtr
    test edi 1 | jz T0>
      mov B$edi 0 | inc edi
T0: If B$esi = '0'
        pushad
            push ebx, edx
                call TranslateHexa | or eax 08000_0000
            pop edx, ebx
            mov D$ebx eax                  ; write function ordinal in table 1
            mov D$ebx+edx eax              ; write function ordinal in table 2
            add D$ImportTablePtr 4         ; ready for next one
        popad
        mov D$StartOfFunctionName esi
L5:     lodsb | cmp al 0 | jne L5<
    Else
        mov eax edi | sub eax D$CodeList | add eax 01000-0400
        mov D$ebx eax                  ; write function name adress in table 1
        mov D$ebx+edx eax              ; write function name adress in table 2
        add D$ImportTablePtr 4         ; ready for next one
        mov ax 0
        stosw
        mov D$StartOfFunctionName edi

L5:     lodsb | stosb | cmp al 0 | jne L5<   ; writing Functions names list
    End_If
    jmp L2<<                    ; two '0' ??? needed ???... alignement needed ???
                                ; usual import tables names lists seem to be aligned.
L9: ret


BuildImport:
    call InitApiTables

    call SearchForApis      ; copy all api calls in ApiListA (> edi > end of ApiListA).

    If edi = D$ApiListA     ; case of DLL with no api call
        mov D$uBaseOfRsrc 01000, D$uImportSize 0 | ret
    End_If

    call FullfillApiList   ; FullFill each Function in the 'MODULE.ext.Function' Form.

    call SortApis          ; >>> Dll in DllList, Functions in ApiListB + Dll #n at first

    call CreateImportSection

    mov eax edi | Align_on 0200 eax | mov ecx eax | sub ecx edi

    push edi, eax
      mov al 0 | rep stosb  ; fill with 0 because destination have been "reused".
    pop eax edi

    mov D$CodeListPtr eax

    sub eax D$CodeList | sub eax 0400 | add eax 01000 | Align_on 01000 eax
    mov D$uBaseOfRsrc eax
    mov eax edi | sub eax 0400 | sub eax D$CodeList | mov D$uImportSize eax

  ; Release all the loaded Modules not belonging to RosAsm Process:
    mov esi ModuleHandlesList
    While D$esi <> 0
        lodsd
        push esi
            call 'KERNEL32.FreeLibrary' eax
        pop esi
    End_While
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

ExportSectionComments:
;;
; Export Section looks like this:
;
; [.Export: D$ 0, 0, 0, DLLName, 1, NumberOfFunctions, NumberOfFunctions,
;              ExportAdressesTable, ExportNamesTable, ExportOrdinals
;
;  DLLName: 'MYDLL.DLL', 0  0 0 0 0 0 0 0 0 .....
;
;  ExportAdressesTable: Function1, Function2, Function3 ....
;
;  ExportNamesTable: Function1Name, Function2Name, Function3Name  ....
;
;  ExportOrdinals: W$ 0, 1, 2 ....
;
;
;      Function1Name: 'Function1', 0
;      Function2Name: 'Function2', 0
;      Function3Name: 'Function3', 0 ....]
;;

[ExportAdressesTablePtr: ?    ExportNamesTablePtr: ?    ExportOrdinals: ?
 FunctionNamesPtr: ?          ExportSectionLen: ?       FileAlignedExportSectionLen: ?]

FillExportSection:
    mov D$Ordinal 0
    mov edi D$ExportListBPtr, eax 0 | stosd | stosd | stosd
    mov ebx edi                         ; ebx ready to write the DLLName Pointer.
    stosd | mov eax 1 | stosd
    add edi 8                           ; (nf / nf already written by 'NewBuildExport').
    add edi 12                          ; Start of DLLName.
    mov eax edi | add eax D$ExportAjust
    mov D$ebx eax                       ; write DLName pointer.

    mov esi ChoosenFile
    push edi
L0: lodsb
    If al >= 'a'
        and al 00_11011111
    End_If
    stosb | cmp B$esi '.' | ja L0<
    pop eax

    mov eax D$SavingExtension | or eax 020202000 | xor eax 020202000 | stosd
    mov al 0 | stosb | Align_On 4 edi

  ; edi points now to 'ExportAdressesTable'. We store the edi in the Header record
  ; 'FunctionsAdressesTable':
    mov eax edi | add eax D$ExportAjust
    mov esi D$ExportListBPtr, D$esi+28 eax, D$ExportAdressesTablePtr eax

  ; We will have as many dWords for Adresses as Exported Functions. So, next header record,
  ; 'ExportNamesTable' will be:
    mov eax D$NumberOfExportedFunctions | shl eax 2 | add eax edi | add eax D$ExportAjust
    mov esi D$ExportListBPtr, D$esi+32 eax, D$ExportNamesTablePtr eax
    sub eax D$ExportAjust | mov edi eax

  ; We will have as many dWords for Names Pointers as Exported Functions.
    mov eax D$NumberOfExportedFunctions | shl eax 2 | add eax edi | add eax D$ExportAjust
    mov esi D$ExportListBPtr, D$esi+36 eax, D$ExportOrdinals eax
    sub eax D$ExportAjust | mov edi eax

  ; We will have as many Words for Ordinals as Exported Functions.
    mov eax D$NumberOfExportedFunctions | shl eax 1 | add eax edi | add eax D$ExportAjust
    mov D$FunctionNamesPtr eax

    mov esi D$ExportListAPtr

L1: call StoreExportAdresse | call StoreExportNamePtr
    call StoreExportOrdinal | call StoreFunctionName

    dec D$NumberOfExportedFunctions | jnz L1<
ret


; This is same as 'SearchRegularLabel' with some specifics (no error control -impossible-)
; + end control

[DataExportedLabel: ?]

StoreExportAdresse:
    mov B$DataExportedLabel &FALSE
    mov edi D$LabelList | add edi 5

L0: push esi

L1:     lodsb | mov bl B$edi | inc edi
L2:     If al = '_'
            lodsb | jmp L2<
        Else_If al = EOI
            cmp bl EOI | je L8>
        Else_If al = ':'
            mov B$DataExportedLabel &TRUE | jmp L8>
        Else_If al >= 'a'
            and al 00_11011111 | cmp al bl | je L1<
        Else
            cmp al bl | je L1<
        End_If

        cmp bl EOI | jbe L3>            ; case of LabelList name shorter than searched Label
        mov ecx 0FF,  al EOI | repne scasb      ; longer: LabelList edi ptr > after next '|'
L3:     add edi 6                                   ; |LABELNAME|dWord FlagByte|NEXTNAME

L7: pop esi | jmp L0<

L8: pop esi
    mov eax D$edi

    sub eax D$CodeList

    If B$DataExportedLabel = &FALSE
        add eax D$AppBaseOfCode
        sub eax D$AppStartOfCode
    Else
        add eax D$AppBaseOfData
        sub eax D$AppStartOfData
    End_If

    mov edi D$ExportAdressesTablePtr | sub edi D$ExportAjust | stosd   ; Make it RVA.
    add D$ExportAdressesTablePtr 4
ret


StoreExportNamePtr:
    mov edi D$ExportNamesTablePtr, eax D$FunctionNamesPtr
    sub edi D$ExportAjust
    stosd | add D$ExportNamesTablePtr 4
ret


[Ordinal: ?]

StoreExportOrdinal:
    mov edi D$ExportOrdinals, eax D$Ordinal | sub edi D$ExportAjust | stosw
    add D$ExportOrdinals 2 | inc D$Ordinal
ret


StoreFunctionName:
    mov edi D$FunctionNamesPtr | sub edi D$ExportAjust
    While B$esi <> EOI
        If B$esi = ':'
            inc esi | jmp L2>
        End_If
        movsb
    End_While
L2: mov al 0 | stosb | add edi D$ExportAjust | mov D$FunctionNamesPtr edi
    inc esi
ret

[ExportsectionWanted: ?    NumberOfExportedFunctions: ?]
[ExportListAPtr: ?   ExportListBPtr: ?]

PrepareExport:
    VirtualFree D$ExportListAPtr, D$ExportListBPtr

    call HowManyExport

    If B$ExportsectionWanted = &TRUE
        call StoreToExportListA
        call SortExportListA
    End_If
ret


HowManyExport:
    mov B$ExportsectionWanted &FALSE

    mov esi D$CodeSourceA, ecx esi, ebx 0, edx 0 | add ecx D$StripLen

L0: inc esi
    .If B$esi = ':'
        If B$esi+1 = ':'
            While B$esi-1 > ' ' | dec esi | End_While
            While B$esi <> ':' | inc esi | inc ebx | End_While
            inc ebx
            While B$esi > ' ' | inc esi | End_While
            inc edx
        End_If

    .Else_If B$esi = '['
L1:     lodsb
        If al = '"'
L2:         lodsb | cmp al '"' | jne L2<
        Else_If al = "'"
L2:         lodsb | cmp al "'" | jne L2<
        End_If
        cmp al ']' | jne L1<

    .Else_If B$esi = '"'
        lodsb
L1:     lodsb | cmp al '"' | jne L1<
    .Else_If B$esi = "'"
        lodsb
L1:     lodsb | cmp al "'" | jne L1<
    .End_If
    cmp esi ecx | jb L0<<

L9: If edx > 0
        mov B$ExportsectionWanted &TRUE
        mov D$NumberOfExportedFunctions edx
        add ebx 40                           ; Header
        add ebx 255                          ; name room
        shl edx 4                            ; pointers > n*16 (*10 would be enough..)
        add ebx edx
        mov D$ExportSectionLen ebx
        push ebx
            VirtualAlloc ExportListAPtr ebx
        pop ebx
        VirtualAlloc ExportListBPtr ebx
    End_If
ret


StoreToExportListA:
    mov esi D$CodeSourceA, edi D$ExportListAPtr
    mov ecx esi | add ecx D$StripLen

L0: inc esi
    .If B$esi = ':'
        If B$esi+1 = ':'
            While B$esi-1 > ' ' | dec esi | End_While
            While B$esi <> ':' | movsb | End_While
            mov al EOI | stosb
            While B$esi > ' ' | inc esi | End_While
         End_If

    .Else_If B$esi = '['
L1:     lodsb
        If al = '"'
L2:         lodsb | cmp al '"' | jne L2<
        Else_If al = "'"
L2:         lodsb | cmp al "'" | jne L2<
        End_If
        cmp al ']' | jne L1<

    .Else_If B$esi = '"'
        lodsb
L1:     lodsb | cmp al '"' | jne L1<
    .Else_If B$esi = "'"

        lodsb
L1:     lodsb | cmp al "'" | jne L1<
    .End_If

    cmp esi ecx | jb L0<
L9: ret


SortExportListA:
    mov edi D$ExportListBPtr, ecx D$NumberOfExportedFunctions

L0: push ecx
        mov esi D$ExportListAPtr, ecx D$NumberOfExportedFunctions, edx 0, bl 0FF

L1:     lodsb
        .If al = 0FF
            ; nop
        .Else_If al < bl
            mov bl al | lea edx D$esi-1
        .Else_If al = bl
            push ebx
                push edx, esi
                    While al = bl
                        lodsb | inc edx | mov bl B$edx
                        cmp al EOI | je L2>
                    End_While
L2:             pop esi, edx
                On al < bl, lea edx D$esi-1
            pop ebx
        .End_If

        While B$esi > EOI
            inc esi
        End_While
        inc esi | loop L1<

        If edx > 0
            mov esi edx
            While B$esi > EOI
                movsb | mov B$esi-1 0FF
            End_While
            mov al EOI | stosb
        End_If

    pop ecx | dec ecx | cmp ecx 0 | ja L0<<

    Exchange D$ExportListAPtr D$ExportListBPtr
    mov edi D$ExportListBPtr, eax 0 | stosd | stosd | stosd | stosd | stosd
    mov eax D$NumberOfExportedFunctions | stosd | stosd
ret

 __________________________________________________________________________________________
 __________________________________________________________________________________________
;;
 these 2 following stubs are used to create new PE. only 'Labelled' values are
 modified according with source values. Main filling work is done by the 'Build...'
 routines.

 These two stubs must remain all in one single data set (prevent from RosAms data
 alignement).

00000000: Dos exe file header stub:
;;

[DosHeader:
B$ 'MZ'  ; dos exe signature
D$ 030090; Size of file (I don't understand what it means...)
W$ 00    ; Number of reloc. adresses
W$ 04    ; this dos header size (16*4)
W$ 00    ; min size
W$ 0FFFF ; max size
W$ 00    ; SP reg. value at run time

W$ 0B8  ; checksum for header
W$ 00   ; IP reg. value
W$ 00   ; start of Cseg in file
W$ 00   ; start of reloc. table in file
W$ 040  ; overlay default
W$ 0,0,0

W$ 0,0,0,0, 0,0,0,0     ; reserved words

W$ 0,0,0,0
MyCheckSum: D$ 0  ; 30
PeHeaderPointer:
D$ 080   ; File adress of win header

B$   0E, 01F, 0BA, 0E, 00, 0B4, 09, 0CD, 021, 0B8, 01, 04C, 0CD, 021
; push cs // pop ds // mov dx 0E // mov ah 09 // int 021 // mov ax 4C01 // int 021
; 18
B$ ;'Spindoz 32 spit PEfile made wiz RosAsm Assembler.$'
   'This program cannot be run in DOS mode', CR, LF, '$', 0, 0, 0, 0, 0, 0, 0, 0, 0

; 50+18+30 = 98
; if you modify upper string you must absolutely keep the same lenght.

PeHeader:

B$ 'PE',0,0             ; signature
W$ 014C                 ; 386 and more
NumberOfSections:
W$ 04                   ; 4 sections (code, data, import, resource) not 5...
B$ 0,0,0,0              ; time and date stamp
D$ 0                    ; pointer to symbol table (for debug)
D$ 0                    ; number of symbol
W$ 0E0                  ; size of 'optional header'
PeHeaderCharacteristics:
W$ 00100001111          ; characteristics
   ; bit 0 > 1 > reloc. infos not there
  ; bit 1 > 1 > Runable
 ; bit 2 > 1 > no line number for debug
; bit 3 > 1 > no bebug symbol
; others : unknown
B$ 0B,01                ; referred as 'magic'...
W$ 03                   ; linker version
AppCodeSize: D$ 0       ; size of code (.text section)
AppAllDataSize: D$ 0    ; size of initialized data (.data + .rsrc+... + .reloc)
D$ 0                    ; size of uninitialised data
AppRVAentryPoint: D$ 0  ; RVA entry point adress (414h in RDNrect file)
AppBaseOfCode: D$ 0     ; RVA Base of code (0400 in file)
SHAppBaseOfData: D$ 0   ; RVA Base of data ('SH' because one more 'AppBaseOfData' down there)
ImageBase:
D$ 0400000              ; image base (linker base default)
D$ PageSize             ; sections alignement
D$ 0200                 ; file alignement
W$ 04,00                ; OS version
W$ 01,00                ; image version
W$ 04,00                ; sub system version
B$ 00,00,00,00          ; reserved
AppRVAimageSize: D$ 0   ; RVA image size
D$ 0400                 ; headers size
CheckSum:
D$ 0                    ; checksum (works when zero)
SubSystem:
W$ 02                   ; sub system
DllCharacteristics:     ; 0001h - Per-Process Library Initialization
                        ; 0002h - Per-Process Library Termination
                        ; 0004h - Per-Thread Library Initialization
                        ; 0008h - Per-Thread Library Termination
W$ 0                   ; DLL characteristics
AppStackMax: D$ 0100000     ; stack max
AppStackMin: D$ 01000       ; stack min
AppHeapMax: D$ 0100000      ; heap max
AppHeapMin: D$ 0            ; heap min
D$ 0                   ; loader flags
D$ 0_10                 ; number of possible entries in following section table (16 records)

; Section table (called image data directory):
; first Dwords are the RVA adresses; second ones are the sizes
SectionTable:
D$                 00,                        00   ; export
; In fact, not 'Base_of' but rather a pointer to the Import Directory.
; Some Linkers do not write the Import Directory at first place of .Import,
; but at second place (why do it simple when you can do i complicated???...).
AppBaseOfImport: D$ 0  AppImportSize:       D$ 0   ; import header (Directory only)
AppBaseOfRsrc:   D$ 0    AppRsrcSize:       D$ 0   ; resource
D$                 00,                        00   ; exeption
D$                 00,                        00   ; security
RelocSectionTable:
D$                 00,                        00   ; Relocation
DebugDir:
D$                 00,                        00   ; debug
D$                 00,                        00   ; copyright
D$                 00,                        00   ; machine values (mips gp and global ptr)
D$                 00,                        00   ; thread local storage
D$                 00,                        00   ; load configuration directory
D$                 00,                        00   ;
AppSecondImport: D$ 0  AppSecondImportSize: D$ 0   ; second import (Address Table)
D$                 00,                        00
D$                 00,                        00
D$                 00,                        00

SectionsHeaders:

idataSectionHeader:         ; (import section)

B$   '.idata',0,0
AppImportTrueSize: D$ 0     ; EndOfImport - StartOfImport  true size (Virtual Size)
AppBaseOfImports: D$ 0      ; RVA
AppImportAlignedSize: D$ 0  ; 200h+ImportExt (Physical File Size)
AppStartOfImport: D$ 0      ; idata ptr
D$ 0,0,0
D$ 0_C0000040               ; readable, writable, initialised data


ResourceSectionHeader:

B$ '.rsrc',0,0,0
AppRsrcTrueSize: D$ 0       ; EndOfResource-StartOfResource  true size
AppBaseOfRsrcs: D$ 0        ; RVA
AppRsrcAlignedSize: D$ 0    ; 200h+ResourceExt
AppStartOfRsrc: D$  0
D$ 0,0,0
D$ 0_40000040               ; readable initialised data


DataSectionHeader:

B$ '.data',0,0,0
AppDataTrueSize: D$ 0       ; EndOfData-StartOfData  true size
AppBaseOfData: D$ 0         ; RVA
AppDataAlignedSize: D$ 0    ; 200h+DataExt    aligned size
AppStartOfData: D$ 0        ; data ptr
D$ 0,0,0
DataCharacteristics:
D$ 0_C0000040               ; readable, writable, initialised data


; Code section header: (the four 'dummy' D$ and W$ are of no mean in EXE and DLL files)

B$ '.text',0,0,0
AppTrueCodeSize: D$   0     ; true size of code in file
AppCodeRVAoffset: D$   0    ; RVA offset (aligned on 01000 boundary)
AppFileSizeOfCode: D$   0   ; file aligned size of code (0200 aligned)
AppStartOfCode: D$   00     ; pointer to code (true first code in file - not entry point-)
D$   00                     ; dummy reloc ptr
D$   00                     ; dummy line number ptr
W$   00                     ; dummy reloc number
W$   00                     ; dummy number of line number
CodeCharacteristics:
D$   0_60000020             ; characteristics (readable, runable, code)

ExportSectionHeader:        ;, if any:
D$ 0 0
AppExpTrueSize: 0
AppBaseOfExp: 0
AppExpAlignedSize: 0
AppStartOfExp: 0   0 0 0
D$ 0_40000040               ; readable initialised data

RelocSectionHeader:         ;, if Export:
D$ 0 0
AppRelocTrueSize: 0
AppBaseOfReloc: 0
AppRelocAlignedSize: 0
AppStartOfReloc: 0   0 0 0
D$ 0_40000040               ; readable initialised data

D$ 0 0   0 0 0 0   0 0 0 0  ; just ensure to stop win search of sections.

D$ 0 0   0 0 0 0   0 0 0 0

SourceSectionHeader:
B$ '.src',0,0,0,0           ; Used by RosAsm only (not by loader: 4 sections, not 5)
AppSrcTrueSize: D$ 0        ; D$SourceLen  true size
AppBaseOfSrc: D$ 0          ; RVA
AppSrcAlignedSize: D$ 0     ; 200h+ResourceExt
AppStartOfSrc: D$  0
D$ 0,0,0
D$ 06000840                 ; Not readable initialised data; don't keep; don't cache...


EOPE:
PeHeaderSize: D$  EOPE-PeHeader]  ; 'Len' unusable here
 ________________________________________________________________________________________

; User stub main data:

[uImportSize: D$ 0  uRsrcSize: D$ 0  uDataSize: D$ 0  uCodeSize: D$ 0
 uStartOfImport: D$ 0  uStartOfRsrc: D$ 0  uStartOfData: D$ 0  uStartOfCode: D$ 0
 uEndOfFile: D$ 0  uBaseOfImport: D$ 0  uBaseOfRsrc: D$ 0  uBaseOfData: D$ 0
; uBaseOfExport: D$ 0 uExportSize: D$ 0
 uBaseOfCode: D$ 0  uImageSize: D$ 0  uCodeRVA: D$ 0  uAllDataSize: D$ 0
 uStackMax: D$ 0  uStackMin: D$ 0  uHeapMax: D$ 0  uHeapMin: D$ 0]

; exemple with the fixed values i used in the very first versions:

; [CodeExt 05C00  DataExt 01000  ImportExt 0200  RsrcExt 0200]
; [StartOfImport 0400]
; [StartOfRsrc   0800]   ; 0600+ImportExt (0200)
; [StartOfData   0C00]   ; 0800+ImportExt+RsrcExt (0400)
; [StartOfCode   1E00]   ; 0A00+ImportExt+RsrcExt+DataExt (01400)
; [EndOfFile     7D00]   ; 0C00+ImportExt+RsrcExt+DataExt+CodeExt (07100)

 _________________________________________________________________________________________

; For Saving here the true sizes of each section because they are aligned for computations.
; I need them at the end to fill the so called 'Virtual' sizes records (first record of
; each type header:

[ImportTrueSize: 0    ResourcesTrueSize: 0    DataTrueSize: 0    CodeTrueSize: 0]

[LockInstruction: ?]

[TrueUserDataSize: 0]


; Was no use without the new DLLs stuff, but, when building a DLL after having an EXE PE
; compiled, some of these Data may remain with a 'wrong' value from the previous compilation.

ClearUserStubMainData:
    mov edi uImportSize, eax 0, ecx TrueUserDataSize | add ecx 4
    sub ecx edi | shr ecx 2 | rep stosd
ret

UserMainData:
    move D$ImportTrueSize D$uImportSize,
         D$ResourcesTrueSize D$uRsrcSize,
         D$DataTrueSize D$uDataSize

    mov eax D$uImportSize | Align_on 0200 eax

    mov D$uImportSize eax | mov ecx eax
    mov eax D$uRsrcSize | Align_on 0200 eax
    mov D$uRsrcSize eax | add ecx, eax
    move D$TrueUserDataSize D$uDataSize    ; preserve for the whole (with virtual size) Align
    mov eax D$uDataSize | Align_on 0200 eax
    mov D$uDataSize eax | add ecx, eax
    mov eax D$CodelistPtr | sub eax D$CodeList | sub eax 0400 | sub eax, ecx
    move D$CodeTrueSize eax
    mov D$AppTrueCodeSize eax
    Align_on 0200 eax | mov D$uCodeSize eax

    mov eax 0400 | mov D$uStartOfImport eax
        add eax D$uImportSize | mov D$uStartOfRsrc eax
        add eax, D$URsrcSize | mov D$uStartOfData eax
        add eax D$uDataSize | mov D$uStartOfCode eax
        add eax D$uCodeSize | mov D$uEndOfFile eax

    mov eax 01000 | mov D$uBaseOfImport eax
        add eax D$UImportSize | Align_on 01000 eax
        mov D$uBaseOfRsrc eax
        add eax D$uRsrcSize | Align_on 01000 eax
        mov D$uBaseOfData eax
        add eax D$TrueUserDataSize | add eax D$uVirtualDataSize | Align_on 01000 eax
        mov D$uBaseOfCode eax
        add eax D$uCodeSize | Align_on 01000 eax
        mov D$uImageSize eax

    mov eax LINKERDEFAULT | add eax D$uBaseOfCode
        sub eax D$uStartOfCode | mov D$uCodeRVA eax

    mov eax D$uStartOfCode | sub eax D$uStartOfImport | mov D$uAllDataSize eax
ret
 _______________________________________________________________________________________


PreparePeHeader:
  call UserMainData

  move D$AppCodeSize D$uCodeSize
  move D$AppAllDataSize D$uAllDataSize

  call SearchForEntryPoint
  sub eax D$CodeList | sub eax D$uStartOfCode | add eax D$uBaseOfCode
  mov D$AppRVAentryPoint eax

  move D$AppBaseOfCode D$uBaseOfCode
  move D$SHAppBaseOfData D$uBaseOfData
  move D$AppRVAimageSize D$uImageSize

;  hexprint D$uBaseOfCode,
;           D$uBaseOfImport,
;           D$uBaseOfCode

  move D$AppBaseOfImport D$uBaseOfImport

  move D$AppBaseOfRsrc D$uBaseOfRsrc
  move D$AppRsrcSize D$uRsrcSize       ; should be unaligned size of the section

__________________

  move D$AppCodeRVAoffset D$uBaseOfCode
  move D$AppFileSizeOfCode D$uCodeSize
  move D$AppStartOfCode D$uStartOfCode

  mov eax D$DataTrueSize | add eax D$uVirtualDataSize

  move D$AppDataTrueSize eax
  move D$AppBaseOfData D$uBaseOfData
  move D$AppDataAlignedSize D$uDataSize
  move D$AppStartOfData D$uStartOfData

  move D$AppImportTrueSize D$ImportTrueSize
  move D$AppBaseOfImports D$uBaseOfImport
  move D$AppImportAlignedSize D$uImportSize
  move D$AppStartOfImport D$uStartOfImport

  move D$AppRsrcTrueSize D$ResourcesTrueSize
  move D$AppBaseOfRsrcs D$uBaseOfRsrc
  move D$AppRsrcAlignedSize D$uRsrcSize
  move D$AppStartOfRsrc D$uStartOfRsrc

; Store source values in .Src section:
  move D$AppSrcTrueSize D$SourceLen
  mov eax D$uBaseOfCode | add eax D$LenOfCode | Align_on 01000 eax
  mov D$AppBaseOfSrc eax
  mov eax D$SourceLen | Align_on 0200 eax
  mov D$AppSrcAlignedSize eax
  mov eax D$uEndOfFile | mov D$AppStartOfSrc eax

; Copy:
  mov esi DosHeader | mov edi D$CodeList
  mov ecx 080 | rep movsb                                   ; store Dos header
  mov ecx D$PeHeaderSize | mov esi PeHeader | rep movsb     ; room for PE header
ret


[LocOfSourceHeader:?]

WritePeHeaders:
    or D$SavingExtension 020202000 | xor D$SavingExtension 020202000

    mov esi DosHeader, edi D$CodeList

    mov ecx PeHeader | sub ecx esi | shr ecx 2 | rep movsd

    mov W$edi 'PE', W$edi+2 0                   ; signature
    add edi 4 | mov W$edi 014C                  ; 386 and more

  ; Compute Number of Sections (NumberOfSections):
    mov eax 1                                   ; Code Section anyway, i suppose.
    On D$uImportSize > 0, inc eax               ; If Import Section wanted.
    On D$uRsrcList > 0, inc eax                 ; If Resources Section wanted.
    On D$uDataSize > 0, inc eax                 ; If Data Section wanted.
                                                ; Code section assumed.
    On B$ExportsectionWanted = &TRUE, inc eax   ; If Export Section wanted.

    If D$SavingExtension = '.SYS'
        jmp L1>
    Else_If D$SavingExtension = '.DLL'
L1:     On D$RelocSectionSize > 8, inc eax      ; If Reloc Section wanted.
    End_If
    add edi 2 | stosw                           ; NumberOfSections

    mov eax 0 | stosd | stosd | stosd           ; time and date stamp
                                                ; pointer to symbol table (for debug)
                                                ; number of symbol
    mov W$edi 0E0 | add edi 2                   ; size of 'optional header'

    mov eax &IMAGE_FILE_32BIT_MACHINE__&IMAGE_FILE_EXECUTABLE_IMAGE
    or eax &IMAGE_FILE_LINE_NUMS_STRIPPED__&IMAGE_FILE_LOCAL_SYMS_STRIPPED
    If D$SavingExtension = '.DLL'
        or eax &IMAGE_FILE_DLL
        On D$RelocSectionSize <= 8, or eax &IMAGE_FILE_RELOCS_STRIPPED
    Else_If D$SavingExtension = '.SYS'
        On D$RelocSectionSize <= 8, or eax &IMAGE_FILE_RELOCS_STRIPPED
    Else
        or eax &IMAGE_FILE_RELOCS_STRIPPED
    End_If


    mov W$edi ax | add edi 2                    ; 'PeHeaderCharacteristics'

    mov D$edi 03010B | add edi 4                ; B$ 0B,01  ; referred as 'magic'...
                                                ; W$ 03     ; Dummy linker version (???)
    mov eax D$uCodeSize | stosd                 ; size of code (.text section)

    mov eax D$AppAllDataSize | stosd            ; size of initialized data (.data + .rsrc+... + .reloc)

    mov D$edi 0 | add edi 4                     ; Never any real Uninitialised section.

    call SearchForEntryPoint
    sub eax D$CodeList | sub eax D$uStartOfCode
    add eax D$uBaseOfCode | stosd               ; RVA entry point (Adress of 'Main:')

    mov eax D$uBaseOfCode | stosd               ; RVA Base of code (0400 in file)
    mov eax D$uBaseOfData | stosd               ; RVA Base of data

    If D$SavingExtension = '.DLL'
        mov eax D$LinkerDllDefault
    Else_If D$SavingExtension = '.SYS'
        mov eax DRIVERDEFAULT
    Else
        mov eax LINKERDEFAULT                   ; image base
    End_If

   ; mov eax LINKERDEFAULT ; ??? Should it be allowed or not ???
   ; Does not seem to work... Whereas 2 indentical DLLs, with same Base work well.
    stosd

    mov D$edi PageSize | add edi 4              ; sections alignement
    mov D$edi 0200 | add edi 4                  ; file alignement

    mov D$edi 04 | add edi 4                    ; W$ 04,00       ; OS version
    mov D$edi 01 | add edi 4                    ; W$ 01,00       ; image version
    mov D$edi 04 | add edi 4                    ; W$ 04,00       ; sub system version
    mov eax 0 | stosd                           ; B$ 00,00,00,00 ; reserved

; 'AppRVAimageSize:'
    mov D$FinalImageSize edi
    mov eax 0 | stosd                           ; RVA image size
    mov D$edi 0400 | add edi 4                  ; headers size
    mov D$edi 0 | add edi 4                     ; checksum (works when zero)
    mov ax W$SubSystem | stosw                  ; sub system

    If D$SavingExtension = '.DLL'
        mov ax W$DllCharacteristics
    Else_If D$SavingExtension = '.SYS'
        mov ax &IMAGE_DLLCHARACTERISTICS_WDM_DRIVER
    Else
        mov eax 0
    End_If
    stosw                                       ; DllCharacteristics
    mov eax D$AppStackMax | stosd
    mov eax D$AppStackMin | stosd
    mov eax D$AppHeapMax | stosd
    mov eax D$AppHeapMin | stosd

    mov D$edi 0 | add edi 4                     ; loader flags
    mov D$edi 010 | add edi 4                   ; number of possible entries in following
                                                ; section table (16 records)
    _________________________

    push edi
        mov eax 0, ecx 020 | rep stosd  ; Clear all 16 * (2 dWords) Entires ('SectionTable').
    pop edi

 [FinalBaseOfExport: ?    FinalAppBaseOfReloc: ?    FinalImageSize: ?]

    If B$ExportsectionWanted = &TRUE
        mov D$FinalBaseOfExport edi, eax 0 | stosd
        mov eax D$ExportSectionLen | stosd
    Else
        add edi 8
    End_If

    If D$uImportSize > 0
        mov eax D$uBaseOfImport | stosd
        mov eax D$Dllnumber | inc eax
        shl eax 2 | mov ebx eax | shl ebx 2 | add eax ebx    ; (eax*4)+(eax*16) = eax * 20
        stosd
    Else
        add edi 8
    End_If

    If D$uRsrcList > 0
        mov eax D$uBaseOfRsrc | stosd
        mov eax D$uRsrcSize | stosd
    Else
        add edi 8
    End_If

    add edi 16                                  ; Now pointing to 'RelocSectionTable'

    .If D$SavingExtension = '.SYS'
        jmp L1>
    .Else_If D$SavingExtension = '.DLL'
L1:     If D$RelocSectionSize > 8
            mov eax 0, D$FinalAppBaseOfReloc edi | stosd
            mov eax D$RelocSectionSize | stosd
        Else
            add edi 8
        End_If
    .Else
        add edi 8
    .End_If

    add edi (12*4)                              ; Now pointing to 'AppSecondImport'

    mov eax D$AppSecondImport | stosd
    mov eax D$AppSecondImportSize | stosd

    add edi (6*4)                               ; Now pointing to 'SectionsHeaders'
    _____________

    mov D$NextSectionHeaderRVA 01000, D$NextSectionHeaderFilePointer 0400

    If D$uImportSize > 0
        call WriteOneSectionHeader '.ida', 'ta', D$ImportTrueSize,
            &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
    End_If

    If D$uRsrcList > 0
        call WriteOneSectionHeader '.rsr', 'c', D$ResourcesTrueSize,
            &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ
    End_If

    If D$uDataSize > 0
        push D$NextSectionHeaderRVA
        mov eax D$DataTrueSize
        call WriteOneSectionHeader '.dat', 'a', eax, D$DataCharacteristics
           ; &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE

      ;  mov eax D$uDataSize | add eax D$uVirtualDataSize
        mov eax D$TrueUserDataSize | add eax D$uVirtualDataSize

        pop D$NextSectionHeaderRVA
        mov D$edi-(8*4) eax | Align_On 01000 eax | add D$NextSectionHeaderRVA eax
    End_If

  ; 'AppTrueCodeSize'
    call WriteOneSectionHeader '.tex', 't', D$CodeTrueSize, D$CodeCharacteristics
       ; &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_MEM_EXECUTE___&IMAGE_SCN_MEM_READ

  ; 'ExportSectionHeader'
    If B$ExportsectionWanted = &TRUE
        mov ebx D$FinalBaseOfExport, eax D$NextSectionHeaderRVA, D$ebx eax

        call WriteOneSectionHeader '.eda', 'ta', D$ExportSectionLen,
            &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ
    End_If

  ; 'RelocSectionHeader'
    .If D$SavingExtension = '.SYS'
        jmp L1>
    .Else_If D$SavingExtension = '.DLL'
L1:     If D$RelocSectionSize > 8
            mov ebx D$FinalAppBaseOfReloc, eax D$NextSectionHeaderRVA, D$ebx eax

            call WriteOneSectionHeader '.rel', 'oc', D$RelocSectionSize,
                &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ
        End_If
    .End_If

    mov ebx D$FinalImageSize, eax D$NextSectionHeaderRVA, D$ebx eax

  ; Security Dummy empty Headeers before Source
    mov eax 0, ecx 10 | rep stosd
  ; SourceSectionHeader
  ; Not readable initialised data; don't keep; don't cache...
    mov D$LocOfSourceHeader edi
    call WriteOneSectionHeader '.src', 0, D$SourceLen, 06000840

    mov ecx D$CodeList | add ecx 0400 | sub ecx edi | shr ecx 2
    mov eax 0 | rep stosd
;Else
;    mov ecx 20, eax 0 | rep stosd
;End_If
ret


; Writes 10 dWords for each Section Header:

[NextSectionHeaderRVA: ?    NextSectionHeaderFilePointer: ?]

Proc WriteOneSectionHeader:
    Arguments @NameLow, @NameHigh, @Size, @Flags

        mov eax D@NameLow | stosd
        mov eax D@NameHigh | stosd
        mov eax D@Size | stosd
        mov eax D$NextSectionHeaderRVA | stosd
        mov eax D@Size | Align_On 0200 eax | stosd
        mov ecx eax
        Align_On 01000 eax | add D$NextSectionHeaderRVA eax
        mov eax D$NextSectionHeaderFilePointer | stosd
        mov eax 0 | stosd | stosd | stosd
        mov eax D@Flags | stosd
        add D$NextSectionHeaderFilePointer ecx
EndP



;&IMAGE_FILE_32BIT_MACHINE 0100h
;IMAGE_FILE_AGGRESIVE_WS_TRIM 010h
;&IMAGE_FILE_BYTES_REVERSED_HI 8000h
;&IMAGE_FILE_BYTES_REVERSED_LO 080h
;IMAGE_FILE_DEBUG_STRIPPED 0200h
;&IMAGE_FILE_DLL 2000h
;&IMAGE_FILE_EXECUTABLE_IMAGE 02h
;IMAGE_FILE_LARGE_ADDRESS_AWARE 020h
;&IMAGE_FILE_LINE_NUMS_STRIPPED 04h
;&IMAGE_FILE_LOCAL_SYMS_STRIPPED 08h
;IMAGE_FILE_NET_RUN_FROM_SWAP 0800h
;IMAGE_FILE_NET_RUN_FROM_SWAP 800
;IMAGE_FILE_RELOCS_STRIPPED 01h
;IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0400h
;IMAGE_FILE_SYSTEM 1000h
;IMAGE_FILE_UP_SYSTEM_ONLY 4000h
 _________________________________________________________________________________________

ResourcesStub:
____________________________________________________________________________________________

[NodeFlag  080000000]

    ;RT_NEWRESOURCE      02000
    ;RT_ERROR            07fff

[RT_AVI              0-1
 RT_WAVE             0-2
 RT_CURSOR           00_0001
 RT_BITMAP          00_0010
 RT_ICON             00_0011
 RT_MENU             00_0100
 RT_DIALOG           00_0101
 RT_STRING           00_0110
 RT_FONTDIR          00_0111
 RT_FONT             00_1000
 RT_ACCELERATORS     00_1001
 RT_RCDATA           00_1010
 RT_MESSAGETABLE     00_1011
 RT_GROUP_CURSOR     00_1100
 RT_GROUP_ICON       00_1110
 RT_VERSION     00_0001_0000]

    ;[RT_NEWBITMAP        (RT_BITMAP|RT_NEWRESOURCE)
    ; RT_NEWMENU          (RT_MENU|RT_NEWRESOURCE)
    ; RT_NEWDIALOG        (RT_DIALOG|RT_NEWRESOURCE) ]

;RT_GROUP_CURSOR  equ RT_CURSOR + DIFFERENCE
;RT_GROUP_ICON  equ RT_ICON + DIFFERENCE
;RT_VERSION   equ 16
;RT_DLGINCLUDE  equ 17
;RT_PLUGPLAY  equ 19
;RT_VXD   equ 20
;RT_ANICURSOR  equ 21
;RT_ANIICON   equ 22
;RT_HTML   equ 23
 ________________________________________________________________________________________

; Level 1:

[Resources: W$ 0,0,0,0,0,0,0,2                               ; 2 next resources records
 D$ RT_ICON,  0_80000020         ;Level2Rt_Icon-StartOfRsrc+NodeFlag ;80000028h (0C28h)
    RT_GROUP_ICON, 0_80000038    ;Level2Rt_Group_Icon-StartOfRsrc+NodeFlag;80000040h (0C40h)

; Level 2: (resource TYPEs directory)

Level2Rt_Icon:
W$ 0,0,0,0,0,0,0,1   ; 1 record
D$ 01, 080000050     ;Level3Rt_Icon-StartOfRsrc+NodeFlag;80000070h; ID 1: icon; > 0C70h

Level2Rt_Group_Icon:
W$ 0,0,0,0,0,0,0,1   ; 1 record
D$ 064, 080000068    ;Level3Rt_Group_Icon-StartOfRsrc+NodeFlag; ID 64h: Group icon > 0C88h

; Level 3: (last one to one language resources pointers - lang. dir -)

Level3Rt_Icon:
W$ 0,0,0,0,0,0,0,1
D$ 0409, 080 ;Level4Rt_Icon-StartOfRsrc;B8h, 409 = langage ID: can_english; B8h > CB8h

Level3Rt_Group_Icon:
W$ 0,0,0,0,0,0,0,1
D$ 0409, 090  ;Level4Rt_Group_Icon-StartOfRsrc   ;C8h, CC8h

;Level 4: (records of each resource: PTR, size, CodePage, reserved)

;;RsrcRVA = BaseOfRsrc-StartOfRsrc

Level4Rt_Icon:
;;D$ IconHeader+RsrcRVA, 02E8, 0, 0  ; icon at CF0h;         size=2E8h
D$ 020A8, 02E8, 0, 0

Level4Rt_Group_Icon:
;;D$ Group_Icon+RsrcRVA, 014, 0, 0   ; group icon at FD8h;   size = 14h
D$ 02390, 014, 0, 0

; icon data. This icon image is for compilation only. At start of RosAsm Run, the default
; icon is copyed from Icon Editor to here. The Editor version is in fact used as temporary
; storage.

uIcon:

IconHeader:
B$ 028,0,0,0   ; size
 020,0,0,0     ; width
 040,0,0,0     ; height (maybe 40h because of the two masks)
 01,0          ; planes
 04,0          ; bit count
 0,0,0,0       ; compression 0
 080,02,0,0    ; 0280 > size of icon data
 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0   ; (dummy)


IconPalette:
;Blue,green,red,0    (16 color palette -values seams to be fixed ones-)

   0,  0,  0,  0 ; color 0
   0,  0,080,  0 ;       1
   0,080,  0,  0 ;       2
   0,080,080,  0 ;       3
 080,  0,  0,  0 ;       4
 080,  0,080,  0 ;       5
 080,080,  0,  0 ;       6
 0C0,0C0,0C0,  0 ;       7
 080,080,080,  0 ;       8
   0,  0,0FF,  0 ;       9
   0,0FF,  0,  0 ;       A
   0,0FF,0FF,  0 ;       B
 0FF,  0,  0,  0 ;       C
 0FF,  0,0FF,  0 ;       D
 0FF,0FF,  0,  0 ;       E
 0FF,0FF,0FF,  0 ;       F

IconXorMask:
; XOR color mask: (32*16 octets > 2 pixels / byte > 32*32 pixels)

     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0C,0F0,  0
    09,099,099,099,099,099,099,099,099,099,099,099,099, 0C,0C0,  0
    09,099,099,099,099,099,099,099,099,099,099,099,099, 0C,0CC,  0
     0,  0, 09,099,099,099,099,099,099,099,099,099,099, 0C,0CC,0C0
    03,03B, 09,099,099,099,099,099,099,099,099,099,099, 0C,0CC,0CF
     0,033, 09,099,090,  0,  0,  0,  0,099,099,099,099, 0C,0CC,0CF
     0, 03, 09,099,090,0DB,0BB,0BB,0B0,099,099,099,099, 0C,0CC,0CF
     0,  0, 09,099,090,0DD,0BB,0BB,0B0,099,099,099,099, 0C,0CC,0CF
     0,  0, 09,099,090,0DD,0DB,0BB,0B0,099,099,099,099, 0C,0CC,0CF
     0,  0, 09,099,090,0DD,0DD,033,030,099,099,099,099, 0C,0CC,0CF
     0,  0,  0,  0,  0,0DD,0DD,0FF,0F0,099,099,099,099, 0C,0CC,0CF
     0,  0, 03,03B,0BB,0BD,0DD,  0,  0,099,099,099,099, 0C,0CC,0CF
     0, 0F,  0,033,0BB,0BB,0DD,  0,  0,099,099,099,099, 0C,0CC,0CF
     0,  0,0C0, 03,03B,0BB,0BD,  0,  0,  0,  0,  0,  0, 0C,0CC,0CF
    0E,0E0,0CC,  0,033,033,033,  0, 0F,033,0BB,0BB,0BB,0BB,0CC,0CF
    0E,0E0,0CC,0C0,  0,  0,  0,  0,0FF,0F3,03B,0BB,0BB,0BB,0BC,0CF
    0E,0E0,0CC,0CC,  0,  0,  0,  0, 0C,0FF,033,0BB,0BB,0BB,0BB,0CF
    0E,0E0,0CC,0CC,  0, 0E,0EE,0EE, 0C,0CF,0F3,033,033,033,033,03F
    0E,0E0,0CC,0CC,  0, 0E,0EE,0EE, 0C,0CC,0FF,0FF,0FF,0FF,0FF,0FF
    0E,0E0,0CC,0CC,  0, 0E,0EE,0EE, 0C,0CC,0CF,0FF,0FF,0FF,0FF,0FF
    0E,0E0,  0,  0,  0, 0E,0EE,0EE, 0C,0C0,  0,  0,  0,  0,  0,  0
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,  0
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0C0
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0CC
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0CC
     0,  0,  0,  0,  0,  0,  0,  0, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0CC
    03,03B,0BB,0BB,0BB,0BB,0BB,0BB,0BB,0C0,0AA,0AA,0AA,0AA, 0C,0CC
     0,033,0BB,0BB,0BB,0BB,0BB,0BB,0BB,0B0,0AA,0AA,0AA,0AA, 0C,0CC
     0, 03,03B,0BB,0BB,0BB,0BB,0BB,0BB,0B0,  0,  0,  0,  0, 0C,0CC
     0,  0,033,033,033,033,033,033,033,033, 03,0BB,0BB,0BB,0BB,0CC
     0,  0,  0,  0,  0,  0,  0,  0,  0,0FF,0F0,03B,0BB,0BB,0BB,0BC
     0,  0,  0,  0,  0,  0,  0,  0,  0,0FF,0FF, 03,033,033,033,033

IconAndMask:
; AND monochrome mask: (8*16 octects > 8 pixels / byte > 32*32 pixels)

     0,  0,  0, 07,  0,  0,  0, 07,  0,  0,  0, 03,  0,  0,  0, 01
   080,  0,  0,  0,0C0,  0,  0,  0,0E0,  0,  0,  0,0F0,  0,  0,  0
   0F0,  0,  0,  0,0F0,  0,  0,  0,0F0,  0,  0,  0,0F8, 03,080,  0
   0EC, 03,080,  0, 06, 03,080,  0, 03, 03,080,  0, 01,0FF,  0,  0
     0,0C0,  0,  0,  0,0C0,  0,  0,  0,0C0,  0,  0,  0,0C0,  0,  0
     0,  0,  0, 07,  0,  0,  0, 03,  0,  0,  0, 01,  0,  0,  0,  0
     0,  0,  0,  0,  0,  0,  0,  0,080,  0,  0,  0,0C0,  0,  0,  0
   0E0,  0,  0,  0,0F0,  0,  0,  0,0FF,0FF,0C0,  0,0FF,0FF,0C0,  0

uIconEnd:
;;
 Group icon and entry may be considered as fixed, like upper headers. Theorycaly, they are
 not, but in practice, they are. More than that, all these values don't seam to be used
 by win95: changing them all to anything else doesn't make any difference... I suppose
 that Win simply reads the sections headers and jumps directly to the file icon header
 (before palette), which one is NOT unused.
;;
; group icon: (icons directory)

uGroupIcon:
W$  00      ; reserved
    01      ; type 1 (always)
    01      ; 1 entry following
            ; As opposed to what doc says: no padding here.
; icon entry:
B$ 020, 020 ; width, height
B$ 010, 0   ; 16 colors, reserved
W$ 01, 04   ; 1 color plane, 4 bits
D$ 02E8     ; size in bytes (true)
W$ 1        ; Seams to be the order number for both Cursors and icons as they come in the tree.
uGroupIconEnd:
EndOfRsrc: 0]
____________________________________________________________________________________________

[CopyOfuIcon:

;CopyOfIconHeader:
B$ 028,0,0,0   ; size
 020,0,0,0     ; width
 040,0,0,0     ; height (maybe 40h because of the two masks)
 01,0          ; planes
 04,0          ; bit count
 0,0,0,0       ; compression 0
 080,02,0,0    ; 0280 > size of icon data
 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0   ; (dummy)


;CopyOfIconPalette:
;Blue,green,red,0    (16 color palette -values seams to be fixed ones-)

   0,  0,  0,  0 ; color 0
   0,  0,080,  0 ;       1
   0,080,  0,  0 ;       2
   0,080,080,  0 ;       3
 080,  0,  0,  0 ;       4
 080,  0,080,  0 ;       5
 080,080,  0,  0 ;       6
 0C0,0C0,0C0,  0 ;       7
 080,080,080,  0 ;       8
   0,  0,0FF,  0 ;       9
   0,0FF,  0,  0 ;       A
   0,0FF,0FF,  0 ;       B
 0FF,  0,  0,  0 ;       C
 0FF,  0,0FF,  0 ;       D
 0FF,0FF,  0,  0 ;       E
 0FF,0FF,0FF,  0 ;       F

;CopyOfIconXorMask:
; XOR color mask: (32*16 octets > 2 pixels / byte > 32*32 pixels)

     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0C,0F0,  0
    09,099,099,099,099,099,099,099,099,099,099,099,099, 0C,0C0,  0
    09,099,099,099,099,099,099,099,099,099,099,099,099, 0C,0CC,  0
     0,  0, 09,099,099,099,099,099,099,099,099,099,099, 0C,0CC,0C0
    03,03B, 09,099,099,099,099,099,099,099,099,099,099, 0C,0CC,0CF
     0,033, 09,099,090,  0,  0,  0,  0,099,099,099,099, 0C,0CC,0CF
     0, 03, 09,099,090,0DB,0BB,0BB,0B0,099,099,099,099, 0C,0CC,0CF
     0,  0, 09,099,090,0DD,0BB,0BB,0B0,099,099,099,099, 0C,0CC,0CF
     0,  0, 09,099,090,0DD,0DB,0BB,0B0,099,099,099,099, 0C,0CC,0CF
     0,  0, 09,099,090,0DD,0DD,033,030,099,099,099,099, 0C,0CC,0CF
     0,  0,  0,  0,  0,0DD,0DD,0FF,0F0,099,099,099,099, 0C,0CC,0CF
     0,  0, 03,03B,0BB,0BD,0DD,  0,  0,099,099,099,099, 0C,0CC,0CF
     0, 0F,  0,033,0BB,0BB,0DD,  0,  0,099,099,099,099, 0C,0CC,0CF
     0,  0,0C0, 03,03B,0BB,0BD,  0,  0,  0,  0,  0,  0, 0C,0CC,0CF
    0E,0E0,0CC,  0,033,033,033,  0, 0F,033,0BB,0BB,0BB,0BB,0CC,0CF
    0E,0E0,0CC,0C0,  0,  0,  0,  0,0FF,0F3,03B,0BB,0BB,0BB,0BC,0CF
    0E,0E0,0CC,0CC,  0,  0,  0,  0, 0C,0FF,033,0BB,0BB,0BB,0BB,0CF
    0E,0E0,0CC,0CC,  0, 0E,0EE,0EE, 0C,0CF,0F3,033,033,033,033,03F
    0E,0E0,0CC,0CC,  0, 0E,0EE,0EE, 0C,0CC,0FF,0FF,0FF,0FF,0FF,0FF
    0E,0E0,0CC,0CC,  0, 0E,0EE,0EE, 0C,0CC,0CF,0FF,0FF,0FF,0FF,0FF
    0E,0E0,  0,  0,  0, 0E,0EE,0EE, 0C,0C0,  0,  0,  0,  0,  0,  0
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,  0
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0C0
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0CC
    0E,0EE,0EE,0EE,0EE,0EE,0EE,0EE, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0CC
     0,  0,  0,  0,  0,  0,  0,  0, 0C,0C0,0AA,0AA,0AA,0AA, 0C,0CC
    03,03B,0BB,0BB,0BB,0BB,0BB,0BB,0BB,0C0,0AA,0AA,0AA,0AA, 0C,0CC
     0,033,0BB,0BB,0BB,0BB,0BB,0BB,0BB,0B0,0AA,0AA,0AA,0AA, 0C,0CC
     0, 03,03B,0BB,0BB,0BB,0BB,0BB,0BB,0B0,  0,  0,  0,  0, 0C,0CC
     0,  0,033,033,033,033,033,033,033,033, 03,0BB,0BB,0BB,0BB,0CC
     0,  0,  0,  0,  0,  0,  0,  0,  0,0FF,0F0,03B,0BB,0BB,0BB,0BC
     0,  0,  0,  0,  0,  0,  0,  0,  0,0FF,0FF, 03,033,033,033,033

;CopyOfIconAndMask:
; AND monochrome mask: (8*16 octects > 8 pixels / byte > 32*32 pixels)

     0,  0,  0, 07,  0,  0,  0, 07,  0,  0,  0, 03,  0,  0,  0, 01
   080,  0,  0,  0,0C0,  0,  0,  0,0E0,  0,  0,  0,0F0,  0,  0,  0
   0F0,  0,  0,  0,0F0,  0,  0,  0,0F0,  0,  0,  0,0F8, 03,080,  0
   0EC, 03,080,  0, 06, 03,080,  0, 03, 03,080,  0, 01,0FF,  0,  0
     0,0C0,  0,  0,  0,0C0,  0,  0,  0,0C0,  0,  0,  0,0C0,  0,  0
     0,  0,  0, 07,  0,  0,  0, 03,  0,  0,  0, 01,  0,  0,  0,  0
     0,  0,  0,  0,  0,  0,  0,  0,080,  0,  0,  0,0C0,  0,  0,  0
   0E0,  0,  0,  0,0F0,  0,  0,  0,0FF,0FF,0C0,  0,0FF,0FF,0C0,  0

CopyOfuIconEnd: D$ CopyOfuIconEnd-CopyOfuIcon]


RestoreDefaultIcon:
    mov esi CopyOfuIcon, edi uIcon, ecx D$CopyOfuIconEnd | rep movsb
    mov esi CopyOfuIcon, edi iIcon, ecx D$CopyOfuIconEnd | rep movsb
ret


____________________________________________________________________________________________

;;
 This is what would looks like a hand made menu:

[uMenu:     U$ 01 04 00 00       ; 01 unknown by me; 04 must be &RT_MENU

0 0 0 0          M00_Tree       0   0  '&Tree' 0  0


0 0 0 0          0                0   1  '&File' 0  0 0 0
0 0 0 0          M00_New         0   0  '&New' 0
0 0 0 0          M00_Open        0   0  '&Open' Tab 'F3' 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 0 0          M00_Open_source_only 0   0  'Open source only' 0
0 0 1 0          M00_Open_Icon_only   0   0  'Open Icon only' 0
0 0 1 0          M00_Open_Menu_only   0   0  'Open Menu only' 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 1 0          M00_Side_open   0   0  '&Side open' 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 1 0          M00_Save_As      0   0  'Save &As' 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 0 0          M00_Save_Source_only 0   0  'Save source only' Tab 'F2' 0 0
0 0 1 0          M00_Save_Icon_only   0   0  'Save Icon only' Tab 'F2' 0 0
0 0 1 0          M00_Save_Menu_only   0   0  'Save Menu only' Tab 'F2' 0 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 0 0          M00_Exit        0 080  'E&xit' Tab 'Alt+X' 0 0


0 0 0 0          0               0   1  '&Edit' 0  0 0 0
0 0 1 0          M00_Undo       0   0  '&Undo' Tab 'Ctrl+Z' 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 0 0          M00_Cut        0   0  'Cu&t' Tab 'Ctrl+X'   0 0
0 0 0 0          M00_Copy       0   0  '&Copy' Tab 'Ctrl+C'    0
0 0 0 0          M00_Paste      0   0  '&Paste' Tab 'Ctrl+V' 0 0
0 0 0 0          M00_Delete     0   0  '&Delete' Tab 'Del'   0 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 1 0          M00_Select_All  0 080  'Select &All'  0 0

0 0 0 0          0               0   1  'Search' 0 0 0
0 0 0 0          M00_Find       0   0  'Find' 0
0 0 0 0          M00_Replace    0 080  'Replace' 0 0

0 0 0 0          M00_Compile      0   0  '&Compile' 0           ; alone

0 0 1 0          M00_Run          0   0  '&Run' 0

0 0 0 0          M00_Calc         0   0  'Calc' 0

0 0 1 0          M00_HexAsc       0   0  'HexAsc' 0

0 0 0 0          0                 0   1  'Resources' 0 0 0 0
0 0 0 0          M00_Icon         0   0  '&Icon' 0 0
0 0 1 0          M00_Dialog_box       0   0  '&Dialog Box' 0 0
0 0 1 0          M00_BitMap       0   0  '&BitMap' 0 0
0 0 1 0          M00_Cursor       0   0  '&Cursor' 0 0
0 0 1 0          M00_String       0   0  '&String' 0 0
0 0 1 0          M00_Font         0   0  '&Font' 0 0
0 0 1 0          M00_Accelerators 0   0  '&Accelerators' 0 0
0 0 1 0          M00_RcData       0   0  'RcData' 0
0 0 1 0          M00_MessageTable 0   0  'MessageTable' 0
0 0 0 0          M00_Menus         0 080  '&Menus' 0

0 0 0 0          M00_Configuration       0   0  'Configuration' 0 0

0 0 0 0          0                 0    1  '&Help' 0 0 0 0
0 0 0 0          M00_Help_Editor    0    0  'Help &Editor' 0
0 0 0 0          M00_Help_Tree_view    0    0  'Help Tree &View' 0 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 1 0          M00_Asm_Mnemonics        0    0  'Asm &Mnemonics' 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 1 0          M00_Win32_Api_List         0    0  'Win32 &Api List' 0 0
0 0 1 0          M00_Win32_Equates_List      0    0  'Win32 E&quates List' 0 0
0 0 1 0          M00_Win32_Structures_List        0    0  'Win32 &Structures List' 0
0 0 1 0          M00_Win32_Data_Types        0    0  'Win32 Data &Types' 0 0
0 0 0 0          0 0 0 0                                           ; separator
0 0 0 0          M00_About        0  080  '&About' Tab 'F1' 0 0

0 0 0 0          M00_<<<<_         0   0  '   <<<<  ' 0 0

0 0 0 0          M00_>>>>_      0   080  '   >>>>  ' 0 0


    ; hot keys (see later):

  ;  01  070  03E8  00    ;03E8 > about ID  (F1)
  ;  01  071  03F4  00    ;03F4 > Save ID   (F2)
  ;  01  072  03EC  00    ;03EC > Open ID   (F3)
  ; 090  078  03ED  00    ;03ED > Exit ID   (Alt-X)  78 > 'x'

  ; D$ 0 0 0 0 0 0 0

uMenuEnd:]
;;

 __________________________________________________________________________________________
;;
 Resource section begin with a tree structure pointing to data. This tree is like a
 hard disk directory structure. At root, we find the main entries, one for each resource
 type. At last, we find something like a file icon: pointers to true data. This last one
 is a leave (the 'file icon', not the true data). Up others are nodes.
 The levels are:
 - root dir (points to resources types)
 - types dir (points to languages types)
 - pointers dir (points to true data)

 Each dir has an height words header. they are all zero but last one: records number in
 the dir; and as many records of two dWords. Exemple for root dir with two resources:

[Resources: W$ 0,0,0,0,0,0,0,2  ; 2 next resources records
 D$ &RT_ICON,  0_80000020        ; 080 > it points to a node.
 &RT_GROUP_ICON, 0_80000038      ; 020 / 038 are displacememnts Ptr (from start of .rsrc)

 Leaves have no 8 words header and are 4 dWords long (RVA ptr / size / CodePage / reserved)

 The only info i found about CodePage dWord is this:
 "... CodePage ...should be used when decoding code point values within the resource data.
  Typically for new applications the code page would be the unicode code page."
 (??????????????????!!!!!!!!!!!!!!!) >>> set at zero until i understand more...

 For .rsrc section construction, we first search for the total lenght of this tree, save
 pointers to each dir and work downside up: first write the data, then fill dirs backward.
 uRsrcsList is a temporary list containing needed information on each resource in
 memory.
;;
 ___________________________________________________________________________________________

[ID_Icon 1,  Language 0409,  ID_Group_Icon 1]

; resource temporary list: up to 200 resource >>> to change for dynamic memory later.

[DumRL: 0 0 0 0 0]  ; to stop upward search on zeros

[uRsrcList:         ; RosAsm infos storage for .rsrc section building (5 dWords per resource)
   D$ 0             ; Type
      0             ; ID
   0409             ; Language
      0             ; Data pointer
      0             ; Size
      #MAXRESOURCE]
[Dum2RL: 0 0 0 0 0]

[RsrcHeadPtr: 0  RsrcSectionOrigine: 0   RsrcSectionPtr: 0
              RsrcTypePtr: 0  RsrcLangPtr: 0  RsrcPtrPtr:0
              uRsrcListPtr: 0]

[HeadLine | add edi 2  ; we have just written some dWords with strings instructions
            mov eax #1 | stosw | mov eax 0 | stosw | stosd | stosd | stosd
            sub edi 2] ; we are going to write some more dWords...


; We set here the list of existing resources for the app resources section. We store
; the type, the ID, Dummy language, Pointer to resource data and size. For menu, i let
; some 'RosAsm developpement internal' test that i use to study menus encoding:

[TypeByName: 0]

; Re-ordering the resources Tables Records in ID order:

SortRsrcTable:
    push eax, ebx, esi
L0:     mov bl 0
        While D$esi > 0
            mov eax D$esi
            .If eax > D$esi+12
                If D$esi+12 <> 0
                    Exchange D$esi D$esi+12, D$esi+4 D$esi+16, D$esi+8 D$esi+20
                    mov bl 1
                End_If
            .End_If
            add esi 12
        End_While
        pop esi | push esi | cmp bl 1 | je L0<
    pop esi, ebx, eax
ret
____________________________________________________________________________________________

[NoResources: ?    NoMainIcon: ?]
 ________________________________________________________________________________________
 ________________________________________________________________________________________

;                                   data job
 ________________________________________________________________________________________
 ________________________________________________________________________________________

[LenOfDataSet: 0  AfterLastDataLabel: 0  DataLoopValue: 0  DefSize: 0]

BuildData:
    mov eax D$CodeListPtr | mov D$DataList eax | mov D$DataListPtr eax

        call StoreDatas

    mov eax D$DataListPtr | sub eax D$DataList | mov D$uDataSize eax

    mov eax D$DataListPtr

  ; Clear all possible trailing left Source Text:
    push eax
        While B$eax <> 0
            mov B$eax 0 | inc eax
        End_While
    pop eax

    Align_on 0200 eax | mov D$CodeListPtr eax

        call StoreVirtualData

;;
  Case of ?Data without any Data >>> We force a dummy .Data Section, because usually,
  in RosAsm outputed PEs, the ?Data are a simple RVA extension of Data, for saving the
  addition of one more, and no use .bss Section, with a different header:
;;
    .If D$uDataSize = 0
        If D$uVirtualDataSize <> 0
            add D$CodeListPtr 0200
            mov D$uDataSize 1
        End_If
    .End_If

    call StripDoneStatementsPointers
ret


TranslateText:
    lodsb                        ; strip first text sign

    On B$DefSize = uMem, jmp TranslateUnicode

L0: lodsb | cmp al TextSign | je L9>
      stosb | jmp L0<
L9: lodsb                        ; strip lasting one
    If al = CloseBracket
        dec esi
    Else_If al > Separators
        Error D$MissingSeparatorPtr
    End_If
    mov edx 0
ret


TranslateUnicode:
L0: lodsb | cmp al TextSign | je L9>
        stosb | mov al 0 | stosb | jmp L0<
L9: lodsb                        ; strip lasting one
    mov edx 0
ret


; translations from text expressions to true numbers. Text is previously pointed by esi
; results stored in (ebx >) EDX:EAX

TranslateBinary:
    lodsw                                               ; clear first '00'
NackedBinary:
    mov ebx 0, edx 0, ecx 0
L0: lodsb | cmp al Closebracket | jbe L9>
    sub al '0' | shld edx ebx 1 | shl ebx 1 | or bl al
    cmp edx ecx | jb L8>
        mov ecx edx
            cmp al 2 | jb L0<
L8:             mov ecx D$BinTypePtr | jmp BadNumberFormat
L9: mov eax ebx
ret


TranslateHexa:
    lodsb                                               ; clear first '0'
NackedHexa:
    mov ebx 0,  edx 0, ecx 0
L0: lodsb | cmp al LowSigns | jbe L9>
        sub al '0' | cmp al 9 | jbe L2>
            sub al 7
L2: shld edx ebx 4 | shl ebx 4 | or bl al
    cmp edx ecx | jb L8>
        mov ecx edx
            cmp al 0F | jbe L0<
L8: mov ecx D$HexTypePtr | jmp BadNumberFormat
L9: mov eax ebx
ret


TranslateDecimal:
    mov eax 0, ecx 0

L2: mov cl B$esi | inc esi                        ; (eax used for result > no lodsb)
    cmp cl LowSigns | jbe  L9>

      mov edx 10 | mul edx | jo L3>               ; loaded part * 10
                                                  ; Overflow >>> Qword
        sub  ecx '0' | jc L7>
        cmp  ecx 9   | ja L7>

          add  eax ecx | jnc  L2<
            jmp  L4>                              ; carry >>> Qword

                                                  ; if greater than 0FFFF_FFFF:
L3: sub ecx '0' | jc L7>
    cmp ecx 9   | ja L7>

      add eax ecx

L4:   adc edx 0
      mov cl B$esi | inc  esi
      cmp cl LowSigns | jbe L9>

        mov ebx eax, eax edx, edx 10 | mul edx    ; high part * 10
          jo L6>                                  ; Qword overflow
            xchg eax ebx | mov edx 10 | mul edx   ; low part * 10
            add  edx ebx
            jnc   L3<                             ; carry >>> overflow

L6:           On B$esi < '0', error D$OverFlowPtr
              If B$esi <= '9'
                  inc esi | jmp L6<
              End_If

L7: mov ecx D$DezimalTypePtr | jmp BadNumberFormat
L9: ret                                           ; >>> number in EDX:EAX


TranslateAny:
    If W$esi = '00'
        call TranslateBinary
    Else_If B$esi = '0'
        call TranslateHexa
    Else
        call TranslateDecimal
    End_If
ret

;;
 In error cases, we come here with the error Message in ecx. This is done this way, in
 order to give zero time penality to Clean written Sources. Here, we check for
 alternate expressions of Numbers ( ...B, ... xB, ...D, ...xD, ...H, ...xH, and crazy
 leading zeros in excess).
 
 Note that the whole thingy may be run twice (No care of time cost for alien syntaxes,
 but full care of time for clean written Source -zero added cost for them-).
 
 esi is after the bad Char.
;;

BadNumberFormat:
    dec esi
L0: lodsb | On al = 'X', lodsb

    .If al = 'H'
        cmp B$esi LowSigns | ja L7>
    .Else_If al = 'D'
        cmp B$esi LowSigns | ja L7>
    .Else_If al = 'B'
        cmp B$esi LowSigns | ja L7>
    .Else
      ; Try to read a Type Marker at the end, and re-run if possible:
L7:     While B$esi > LowSigns | inc esi | End_While | dec esi | lodsb
        If al = 'H'
            On ecx = HexType, Error ecx
        Else_If al = 'D'
            On ecx = DezimalType, Error ecx
        Else_If al = 'B'
            On ecx = BinType, Error ecx
        Else
            Error ecx
        End_If
    .End_If

    dec esi
;;
 esi now points to the last Char of the Number. We overwrite it: We kill the Types Markers
 and we fill at the other end (start), with zeros:
;;
    push edi
        mov edi esi | dec esi | On B$esi = 'X', dec esi
        std
            While B$esi > LowSigns | movsb | End_While
        cld
        While B$edi > LowSigns | mov B$edi '0' | dec edi | End_While
    pop edi

    inc esi | While B$esi = '0' | inc esi | End_While

  ; Cases of, for example, "[<0200h" DataAlignment:
    On B$esi = '<', inc esi

    If al = 'H'
        jmp NackedHexa
    Else_If al = 'D'
        jmp TranslateDecimal
    Else  ; al = 'B'
        jmp NackedBinary
    End_If

____________________________________________________________________________________________

AsciiToQword:
L0: call atof
    On al > CloseBracket, error D$BadRealPtr
    fadd D$edi
    fstp Q$edi

L9: cmp B$esi-1 addSign | jne L9>
        mov al addSign | dec esi | jmp L0<<
L9: cmp B$esi-1 subSign | jne L9>
        mov al subSign | dec esi | jmp L0<<

L9: add edi 8
    mov eax edi | sub eax D$DataListPtr | add D$LenOfDataSet eax
    mov D$DataListPtr edi
ret

FAsciiToQword:
L0: call atof
    On al > CloseBracket, error D$BadRealPtr
    fadd D$edi
    fstp D$edi

L9: cmp B$esi-1 addSign | jne L9>
        mov al addSign | dec esi | jmp L0<<
L9: cmp B$esi-1 subSign | jne L9>
        mov al subSign | dec esi | jmp L0<<

L9: add edi 4
    mov eax edi | sub eax D$DataListPtr | add D$LenOfDataSet eax
    mov D$DataListPtr edi
ret


TAsciiToQword:
L0: call atof
    On al > CloseBracket, error D$BadRealPtr
    fadd D$edi
    fstp T$edi

L9:   cmp B$esi-1 addSign | jne L9>
        mov al addSign | dec esi | jmp L0<<
L9:   cmp B$esi-1 subSign | jne L9>
        mov al subSign | dec esi | jmp L0<<

L9: add edi 10
    mov eax edi | sub eax D$DataListPtr | add D$LenOfDataSet eax
    mov D$DataListPtr edi
ret


ParseFpWords:
    push esi

        mov ax 07FFF

        If B$esi = addSign
            inc esi
        Else_If B$esi = subSign
            inc esi | mov ax 0FFFF
        End_If

L1:     ...If B$esi = 'N'
            ..If B$esi+1 = 'A'
                .If B$esi+2 = 'N'
                    If B$esi+3 < LowSigns
                        mov D$edi 0, D$edi+4 0, W$edi+8 07FFF
                        or W$edi+8 ax | add esi 4 | pop eax | jmp L9>
                    End_If
                .End_If
            ..End_If

        ...Else_If B$esi = 'I'
            ..If B$esi+1 = 'N'
                .If B$esi+2 = 'F'
                    If B$esi+3 < LowSigns
                        mov D$edi 0FFFFFFFF, D$edi+4 0FFFFFFFF, W$edi+8 07FFF
                        or W$edi+8 ax | add esi 4 | pop eax | jmp L9>
                    End_If
                .End_If
            ..End_If

        ...Else_If D$esi = 'QNAN'
          ; QNaN  : S=0  E=7FFF  I=1  F=4000_0000_0000_0000..7FFF_FFFF_FFFF_FFFF
            mov D$edi 0FFFFFFFF, D$edi+4 0FFFFFFFF, W$edi+8 07FFF
            or W$edi+8 ax | add esi 4 | pop eax | jmp L9>

        ...End_If

    pop esi | ret

L9: add edi 10
    mov eax edi | sub eax D$DataListPtr | add D$LenOfDataSet eax
    mov D$DataListPtr edi
ret


[DataSign: 0]

StoreDataRef:
    On B$DefSize <> 'D' error D$DsizeForLabPtr
    push edi
        mov edi D$DataRefPtr
        ..If B$Dynamic = &TRUE
            If edi > D$DataRefLimit
                call ExtendTableMemory DataRef, DataRefPtr, DataRefLimit
                mov edi D$DataRefPtr
            End_If
        ..End_If

L0:     lodsb | cmp al LowSigns | jb L1>
        stosb | jmp L0<
L1:     mov al EOI | stosb
        mov eax D$DataListPtr | stosd
        mov eax D$bracketCounter | stosd
        mov al B$DataSign | stosb
        mov al EOI | stosb
      mov D$DataRefPtr edi
    pop edi
ret


; j'ai oubli  de commenter   '<<<<' pourquoi faut-il ajouter un dWord apr s la valeur de
; LEN. Sans ce 0 suppl mentaire, la donn e suivante est  crasee (0). Comme  a, tout
; fonctionne mais je ne sais plus pourquoi!!!!!!!!!!...........

[HeadLenPtr: 0    HeadLenFlag: 0    HeadLenSize: dMem]

StoreOneData:
    mov B$DataSign &FALSE
    push edi

        cmp B$esi+1 MemMarker | jne L0>
            lodsb | mov B$DefSize al | lodsb

L0:     mov edi D$DataListPtr | mov D$edi 0 | mov al B$esi
            cmp al Separators | ja L0>
            inc esi | mov al B$esi

L0:     cmp al 'L' | jne L0>>
            cmp B$esi+1 'E' | jne L0>>
            cmp B$esi+2 'N' | jne L0>>
            cmp B$esi+3 LowSigns | ja L0>>

              ; Direct storage for LEN keyword:
                mov eax D$LenOfDataSet
                .If eax = 0
                    mov B$HeadLenFlag &TRUE, D$HeadLenPtr edi

                  ; Store dummy zero. Will be overwritten, after, at the top of 'StoreDatas'
                  ; HeadLen may be W$ for some Win32 Structures. Byte should be no use:
                    If B$DefSize = dMem
                        stosd | mov D$HeadLenSize dMem, D$LenOfDataSet 4
                    Else_If B$DefSize = wMem
                        stosw | mov D$HeadLenSize wMem, D$LenOfDataSet 2
                    Else_If B$DefSize = bMem
                        stosb | mov D$HeadLenSize bMem, D$LenOfDataSet 1
                    Else
                        error D$LenSizePtr
                    End_If

                .Else_If B$HeadLenFlag = &TRUE
                    error D$MixedLenPtr

                .Else
                  ; Normal Len (after Data) is always a dWord, whatever 'DefSize':
                    stosd | mov D$LenOfDataSet 0

                .End_If

                mov D$DataListPtr edi | add esi 4
    pop edi
    ret

L0:     cmp B$DefSize 'R' | jne L0>
        call AsciiToQword
    pop edi
    ret

L0:     cmp B$DefSize 'H' | jne L0>
        error D$NewHmemPtr
      ; call AsciiToQword
    pop edi
    ret

L0:     cmp B$DefSize 'F' | jne L0>
        call FAsciiToQword
    pop edi
    ret

L0:     cmp B$DefSize 'T' | jne L0>
      ;  push esi
      ;      call ParseFpWords
      ;  pop eax
      ;  On esi = eax,
        call TAsciiToQword
    pop edi
    ret

L0:     mov B$DataSign &FALSE | cmp al SubSign | jne L1>
        mov B$DataSign &TRUE | lodsb | mov al B$esi | jmp L1>
L1:     cmp al addsign | jne L2>
        lodsb | mov al B$esi
L2:     cmp al TextSign | jne L2>
        call TranslateText | jmp E9>>   ; (direct storage of text in Translation routine)
L2:     cmp al '0' | ja L4>
        cmp B$esi+1 '0' | jne L2>
            call TranslateBinary | jmp L5>
L2:     call TranslateHexa | jmp L5>
L4:     cmp al '9' | jbe L4>
            call StoreDataRef | jmp L9>>
L4:     call TranslateDecimal

L5:     cmp edx 0 | je L5>
        On B$DefSize <> 'Q', error D$OverFlowPtr
            jmp Q7>>

L5:     cmp B$DefSize 'D' | je L7>
        cmp B$DefSize 'B' | je L6>
        cmp B$DefSize 'W' | je U0>
        cmp B$DefSize 'U' | je U0>
        cmp B$DefSize 'Q' | je Q7>                              ; keep (Q$ with edx = 0)
            error D$UnknownSizePtr

U0:     cmp eax 0FFFF | ja L8>>                                 ; if here, DefSize = 'W'
        On B$DataSign = &TRUE, neg ax | add W$edi ax | jnc L9>  ; include 0 unicode endMark
            jmp L8>>
L6:     cmp eax 0FF | ja L8>>                                   ; 'B'
        On B$DataSign = &TRUE, neg al | add B$edi al | jnc L9>
            jmp L8>>
L7:     On B$DataSign = &TRUE, neg eax | add D$edi eax | jnc L9>; 'D'
        jmp L8>>
Q7:     If B$DataSign = &TRUE
            neg eax | neg ebx
        End_If

        add D$edi eax | jnc Q8>
        add edx 1 | On edx = 0, error D$OverFlowPtr
Q8:     add edi 4 | add D$edi edx | jnc Q9>
            jmp L8>>
Q9:     sub edi 4

L9:     cmp B$esi-1 addSign | jne L9>
            mov al addSign | dec esi | jmp L0<<
L9:     cmp B$esi-1 subSign | jne L9>
            mov al subSign | dec esi | jmp L0<<

L9:     cmp B$DefSize 'D' | jne L9>
            add edi 4 | jmp E9>
L9:     cmp B$DefSize 'B' | jne L9>
            inc edi   | jmp E9>
L9:     cmp B$DefSize 'Q' | jne L9>
            add edi 8 | jmp E9>
L9:     add edi 2                         ; good for 'W' and 'U'

E9:     mov eax edi | sub eax D$DataListPtr | add D$LenOfDataSet eax
        mov D$DataListPtr edi
    pop edi
ret

L8: error D$OverFlowPtr

 _________________________________________________________________________________________
;;
 storage of labels and datas founded in data declarations square brackets:
 datas are stored in 'DataList'. Labels are stored in the same 'LabelList' as
 code labels, but with adress high bit set.
 indentifications of either label or data is made through Space or Colon ending signs.
 the only one difficulty is that a declaration might end with a label (in case
 user programmer wish to know some data lenght without using 'len', for exemple)
;;
 _________________________________________________________________________________________

AlignDataSet:
    ..If B$esi = '<'
        lodsb                       ; strip '<'
        On B$esi = Space, lodsb
        If W$esi = '00'
            call TranslateBinary | cmp eax 0 | je L9>>
            dec eax | add D$DataListPtr eax
            inc eax | neg eax | and D$DataListPtr eax

        Else_If B$esi = '0'
            call TranslateHexa | cmp eax 0 | je L9>>
            dec eax | add D$DataListPtr eax
            inc eax | neg eax | and D$DataListPtr eax

        Else_If B$esi < '1'
            ; Don't Align

        Else_If B$esi > '9'
            ; Don't Align

        Else
            call TranslateDecimal
            dec eax | add D$DataListPtr eax
            inc eax | neg eax | and D$DataListPtr eax

        End_If
    ..Else
        push esi
            While B$esi > LowSigns | inc esi | End_While | inc esi
            mov eax 4
            .If B$esi+1 = memMarker
                If B$esi = 'B'
                    mov eax 1
                Else_If B$esi = 'D'
                    mov eax 4
                Else_If B$esi = 'W'
                    mov eax 2
                Else_If B$esi = 'U'
                    mov eax 2
                Else_If B$esi = 'F'
                    mov eax 4
                Else_If B$esi = 'R'
                    mov eax 8
                Else_If B$esi = 'Q'
                    mov eax 8
                Else_If B$esi = 'T'
                    mov eax 16
                End_If
            .End_If
        pop esi
        Align_On_Variable eax D$DataListPtr
    ..End_If
L9: ret


[DataLabelsCounter: ?    CodeLabelsCounter: ?] [DataLoopWinEquate: ? #20]
[LOOPDATAMAX 01_000]

[ColonWanted: ?]

StoreDatas:
    mov esi D$CodeSourceB
    mov B$ErrorLevel 0,  D$bracketCounter 0, D$DataLabelsCounter 0
    mov D$HeadLenPtr 0, D$HeadLenFlag 0, D$HeadLenSize dMem

    move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4

L0: .If B$HeadLenFlag = &TRUE
        mov ebx D$HeadLenPtr, eax D$LenOfDataSet, B$HeadLenFlag &FALSE

        If B$HeadLenSize = dMem
            mov D$ebx eax
        Else_If B$HeadLenSize = wMem
            On eax > 0FFFF, error D$OverWordPtr
            mov W$ebx ax
        Else
            On eax > 0FF, error D$OverBytePtr
            mov B$ebx al
        End_If
    .End_If

L1: lodsb
    If al = TextSign
        While B$esi <> TextSign
            lodsb
        End_While
        lodsb | jmp L1<

    Else_If al = OpenVirtual
        inc D$bracketCounter | add D$StatementsPtr 4
        While al <> CloseVirtual
             lodsb
        End_While
        jmp L1<

    Else_If al = Openbracket
        inc D$bracketCounter | add D$StatementsPtr 4 | jmp L1>

    Else_If al = EOI
        ret

    Else
        jmp L1<

    End_If

L1: mov D$LenOfDataSet 0
    mov B$DefSize 'D'   ; default size: dWord

    call AlignDataSet

L2: push esi
L3:     lodsb                                   ; we search ending char (first for 'text')
        cmp al LowSigns | ja L3<
          cmp al TextSign     | je L5>          ; Text (first sign, no need of last one)
          cmp al Space        | je L5>          ; data
          cmp al Closebracket | je L5>          ; lasting data
          cmp al meEOI        | je L5>          ; no error if no comma...
          cmp al ColonSign    | je L6>          ; label (last sign)
          cmp al NumSign      | je L7>>
          cmp al addsign      | je L5>
          cmp al subSign      | je L5>

          cmp al memMarker    | je L3<
            error D$BadSeparatorPtr

L5: pop esi

    call StoreOneData | jmp L9>>                ; if data

; Case "__:__"
L6:     mov B$ColonWanted &FALSE
        On B$esi = meEOI, inc esi               ; no '|' betweem ':' and data
        mov D$AfterLastDataLabel esi
    pop esi

    call StoreDataLabel                         ; if label
    On B$LocalLabel = &TRUE, error D$NoDataLocalLabelPtr
    inc D$DataLabelsCounter
    mov esi D$AfterLastDataLabel | jmp L9>>     ; Called Subs don't change ESI

; Case "__#__"
L7: On B$esi-2 > PartEnds, error D$WhatIsThisPtr
    On B$ColonWanted = &TRUE, error D$NestedLoopPtr
    pop eax

    cmp B$esi-2 memMarker | je E1>
    cmp B$esi-2 ColonSign | jne E2>

E1:     error D$BadLoopPtr
E2:
    On B$esi < '0', error D$BadLoopNumberPtr
    On B$esi > '9',  error D$BadLoopNumberPtr
    cmp D$DataLoopValue 0 | ja L7>
      If B$esi = '0'
        call TranslateHexa
      Else
        call TranslateDecimal
      End_If
      On edx > 0, error D$DataLoopNumberPtr
      On eax > LOOPDATAMAX, error D$DataLoopNumberPtr
      On eax < 2, error D$SmallDataLoopPtr
      mov D$DataLoopValue eax

L7: dec D$DataLoopValue | cmp D$DataLoopValue 0 | ja L8>      ; full set when edx ...
L7: lodsb
      cmp al LowSigns | ja L7<
        mov B$ColonWanted &TRUE | jmp L9>

L8: mov esi D$AfterLastDataLabel | jmp L2<<

L9: If B$esi-1 = Closebracket
       mov eax D$StatementsPtr, D$eax DoneFlag
       jmp L0<<                    ; lasting data
    End_If
    On B$esi  <> Closebracket,  jmp L2<<                      ; lasting label
    mov eax D$StatementsPtr, D$eax DoneFlag
    inc esi | jmp L0<<

_____________________________________________________________________________________

StoreOneVirtualData:
    cmp B$esi+1 MemMarker | jne L0>
        lodsb | mov B$DefSize al | lodsb

L0: lodsb
        cmp al Separators | ja L0>
            lodsb

L0: cmp al '?' | je L0>
        error D$VirtualDataPtr

L0: .If B$DefSize = 'D'
        mov eax 4
    .Else_If B$DefSize = 'B'
        mov eax 1
    .Else_If B$DefSize = 'W'
        mov eax 2
    .Else_If B$DefSize = 'U'
        mov eax 2
    .Else_If B$DefSize = 'Q'
        mov eax 8
    .Else_If B$DefSize = 'R'
        mov eax 4
    .Else_If B$DefSize = 'H'
        mov eax 8
    .Else_If B$DefSize = 'F'
        mov eax 4
    .Else_If B$DefSize = 'T'
        mov eax 10
    .Else
        error D$UnknownSizePtr
    .End_If

    add D$uVirtualDataSize eax | add D$DataListPtr eax

    On B$esi < Separators, inc esi
ret

;;
 Beware, here, we both read from and copy to 'CodeSourceB'. We strip off at once Brackets
 and Virtual Brackets Declarations. We didn't strip Data Brackets previouly to allow
 error checking of user source Brackets.
;;
[uVirtualDataSize: ?]
[NoVirtualLimit: &FALSE]
[LOOPVDATAMAX 010_0000]

StoreVirtualData:
    mov esi D$CodeSourceB,  edi D$CodeSourceB
    mov B$ErrorLevel 0,  D$bracketCounter 0, D$uVirtualDataSize 0

    move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4

; Next 'if' could be reused (???) if we want to speed up "Looping" '?' Data.
; (All of this could be much faster...):
;
L0: ;If B$HeadLenFlag = &TRUE
;      mov ebx D$HeadLenPtr, eax D$LenOfDataSet, D$ebx eax, B$HeadLenFlag &FALSE
;    End_If

L1: lodsb
      If al = OpenBracket
          While al <> CloseBracket
              lodsb
              cmp al TextSign | jne T9>
          T0: lodsb | cmp al TextSign | jne T0<
          T9:
          End_While
          inc D$bracketCounter | add D$StatementsPtr 4
          jmp L1<
      End_If
      cmp al OpenVirtual | je L1>               ; search for data declaration
      stosb | cmp al EOI | jne L1<
           On B$esi = OpenVirtual, jmp S0>
           On B$esi = Openbracket, jmp S0>
           add D$StatementsPtr 4
S0:  On B$edi-2 = EOI,  dec edi         ; prevents unwished '||', wich occurs for exemple
                                            ; in: ...|[val: 25]|...  after data strip
        cmp B$esi EOI | jne L0<             ; end of source
          stosb
            mov eax edi | sub eax D$CodeSourceB | mov D$StripLen eax
            mov al EOI, ecx 10 | rep stosb      ; ajout recent pour tester un plantage
          ret

L1: inc D$bracketCounter | add D$StatementsPtr 4

    mov B$DefSize 'D'   ; default size: dWord

  ; Re-Write that shit: Need an 'AlignVirtualDataSet' version, instead.
    push D$DataListPtr
        call AlignDataSet
    pop eax
    If D$DataListPtr > eax
        mov ebx D$DataListPtr | sub ebx eax | add D$uVirtualDataSize ebx
    End_If

L2: push esi
L3:   lodsb                                     ; we search ending char (first for 'text')
        cmp al LowSigns | ja L3<
          cmp al TextSign     | je L4>          ; Text (first sign, no need of last one)
          cmp al Space        | je L5>          ; data
          cmp al CloseVirtual | je L5>          ; lasting data
          cmp al meEOI        | je L5>          ; no error if no comma...
          cmp al ColonSign    | je L6>          ; label (last sign)
          cmp al NumSign      | je L7>>
          cmp al addsign      | je L4>
          cmp al subSign      | je L4>
        jmp L3<

L4: error D$VirtualDataPtr

L5: pop esi | call StoreOneVirtualData | jmp L9>>   ; if data

L6:   mov B$ColonWanted &FALSE
      move D$DataListPtrAtLastColon D$DataListPtr
      On B$esi = meEOI, inc esi                 ; no '|' betweem ':' and data
      mov D$AfterLastDataLabel esi
    pop esi
    call StoreDataLabel                         ; if label
    On B$LocalLabel = &TRUE, error D$NoDataLocalLabelPtr
    inc D$DataLabelsCounter
    mov esi D$AfterLastDataLabel | jmp L9>>     ; Called Subs don't change ESI

L7: On B$esi-2 > PartEnds, error D$WhatIsThisPtr
    On B$ColonWanted = &TRUE, error D$NestedLoopPtr
    pop eax
    cmp B$esi-2 memMarker | je E1>
    cmp B$esi-2 ColonSign | jne E2>
E1:     error D$BadLoopPtr

E2: On B$esi < '0', error D$BadLoopNumberPtr
    On B$esi > '9',  error D$BadLoopNumberPtr

    cmp D$DataLoopValue 0 | ja L7>
        If B$esi = '0'
            call TranslateHexa
        Else
            call TranslateDecimal
        End_If
        On edx > 0, error D$VDataLoopNumberPtr
        If B$NoVirtualLimit = &FALSE
            On eax > LOOPVDATAMAX, error D$VDataLoopNumberPtr
        End_If
        On eax < 2, error D$SmallDataLoopPtr
        mov D$DataLoopValue eax

L7: dec D$DataLoopValue | cmp D$DataLoopValue 0 | ja L8>        ; full set when edx ...
L7: lodsb
      cmp al LowSigns | ja L7<
        mov B$ColonWanted &TRUE | jmp L9>

L8:     If D$DataLoopValue > 1
            mov eax D$DataListPtr | sub eax D$DataListPtrAtLastColon
            mov ecx D$DataLoopValue | dec ecx | mul ecx
            add D$DataListPtr eax | add D$uVirtualDataSize eax
            mov D$DataLoopValue 1
        End_If

        mov esi D$AfterLastDataLabel | jmp L2<<

L9: If B$esi-1 = CloseVirtual
        mov eax D$StatementsPtr, D$eax DoneFlag | jmp L0<<      ; lasting data
    End_If
    On B$esi <> CloseVirtual,  jmp L2<<                         ; lasting label
        inc esi | mov eax D$StatementsPtr, D$eax DoneFlag | jmp L0<<

_________________________________________________________________________________________
 _________________________________________________________________________________________

; Labels deal

[StartOfLabelName: ?  LocalLabel: B$ ?]

E0: error D$BadLabelPtr

StoreDataLabel:
    mov edx D$DataListPtr | mov cl DataLabelFlag | jmp L0>

StoreCodeLabel:
    mov edx D$CodeListPtr | mov cl CodeLabelFlag

L0: push edi
        mov edi D$LabelListPtr | mov ebx 0 | mov D$StartOfLabelName esi
        and B$esi 00_0111_1111

        On B$esi = ColonSign, error D$OrphanColonPtr

L1:     lodsb | cmp al ColonSign | je L2>               ; esi set by caller
        inc ebx                                         ; ebx < lenght of label name
        cmp al '.' | jb E0<
        cmp al 'Z' | ja E0<
        stosb | jmp L1<                                 ; write to LabelList

L2:     mov al EOI | stosb | mov B$LocalLabel &FALSE
        cmp ebx 2 | jne L3>                             ; is it a possible local label?
            mov ah B$esi-3,  al B$esi-2
            cmp ah 'A' | jb L3>
                cmp ah 'Z' | ja L3>
                    cmp al '0' | jb L3>
                        cmp al '9' | ja L3>
                            mov B$LocalLabel &TRUE      ; if yes, multiple decs. allowed

L3:   mov eax edx                                       ; either data or code List Pointer
      stosd                                             ; label offset (code or data)
      mov al cl | stosb                                 ; code or data flag byte
      mov al EOI | stosb

    ;  mov esi D$StartOfLabelName                        ; LabelListPtr > first label letter
      On B$LocalLabel = &FALSE, call SetQwordCheckSum D$LabelListPtr
    ;  On B$LocalLabel = &FALSE, call IsItNewDataOrCodeLabel       ; send error message if not new

      mov D$LabelListPtr edi

      If edi > D$LabelListLimit
        call ExtendTableMemory LabelList, LabelListPtr, LabelListLimit
      End_If

    pop edi
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

OpError: Error D$NotAnOpcodePtr
OperandsError: Error D$OperandsTypesPtr
OperandSizeError: Error D$OperandSizePtr
NoFpAssumeError: Error D$FPregNotAssumedPtr

[BadMnemonic | jmp OpError]
[BadOperand | jmp OperandsError]
[BadOperandSize | jmp OperandSizeError]
[NoFpAssume | jmp NoFpAssumeError]

[op1 ah,  op2 al,  op3 bh,  op4 bl,  op5 ch,  op6 cl,  op7 dh,  op8 dl]

[LineStart: D$ 0,  Operands: B$ 0]

[ParametersData: 0  ParametersNumber: 0
 LongRelative: 0  dis32: 0  imm64: imm32: 0 0   ABSimm32: 0  SignedImm8: 0
 Relative: 0                   ; set with >flag when coding calls or jumps

 LocalSize: B$ 0
 Ereg: 0  SIB: 0
 EregInside: 0  immInside: 0  DisInside: 0   SibInside: 0
 DummyDis: 0                   ; true or false, for SIB without dis and without base

 LabelInside: B$ 0  ExpressedLabels: 0  TrueSize: 0
 FirstParaMem: 0  SecondParaMem: 0
 FirstReg: 0  SecondReg: 0  ThirdReg: 0
 FirstGender: 0  SecondGender: 0  ThirdGender: 0
 FirstRegGender: 0  SecondRegGender: 0  ThirdRegGender: 0

 RMbits: B$ 0  wBit: 0            ; for size encoding 1 or 0
 wBitDisagree: 0  sBit: 0            ; 010B or 0
 sBitPossible: 0  sBitWritten: 0
 OneOperandwBit: 0            ; for temporary storage inside One parameter analyze
 FirstOperandwBit: 0            ; These two
 SecondOperandwBit: 0            ; for test of fitting sizes
 ThirdOperandwBit: 0
 ModBits: 0  SIBreg1: 0  SIBreg2: 0
 ScaledIndex: 0  Base: 0  ScaleFound: 0  Reg1isIndex: 0  Reg2isIndex: 0  TwoRegsFound: 0
 PossibleRmEreg: 0  ExpressedSign: 0

 PossibleImmLabel: B$ 0  PossibleFirstImmLabel: 0

 ParametersDataLen: len]

[relativeFlag  00__10000000_00000000_00000000_00000000]

 _________________________________________________________________________________________
 _________________________________________________________________________________________

; expression deal: ModR/M, SIB and immediate in expressions

[IfEregFound | cmp B$Ereg NotFound | jne #1]

[IfEregNotFound | cmp B$Ereg NotFound | je #1]

[IfNotPartEnd | cmp #1 PartEnds | ja #2]

[IfSeparator | cmp #1 Separators | jb #2]

IsitaReg:
     call Store8cars | On op3 nb Separators,  jmp L5>>      ; a 2 letters reg name?

L0: ifnot op2 'X', L2>
        ifnot op1 'A', L1>
            mov al regAx | jmp L3>
L1:     ifnot op1 'B', L1>
            mov al regBx | jmp L3>
L1:     ifnot op1 'C', L1>
            mov al regCx | jmp L3>
L1:     On op1 <> 'D',  jmp L9>>
            mov al regDx

L3:     mov W$esi 0 | add esi 3 | mov ah reg | mov B$OneOperandwBit WordSize | ret

L2: ifnot op2 'H', L2>
        ifnot op1 'A', L1>
                mov al regAh | jmp L3>
L1:     ifnot op1 'B', L1>
            mov al regBh | jmp L3>
L1:     ifnot op1 'C', L1>
            mov al regCh | jmp L3>
L1:     On ah <> 'D',  jmp L9>>
            mov al regDh | jmp L3>

L2: ifnot op2 'L', L2>
        ifnot op1 'A', L1>
            mov al regAl | jmp L3>
L1:     ifnot op1 'B', L1>
            mov al regBl | jmp L3>
L1:     ifnot op1 'C', L1>
            mov al, regCl | jmp L3>
L1:     On op1 <> 'D',  jmp L9>>
            mov al, regDl

L3:     mov W$esi 0 | add esi 3 | mov ah reg | mov B$OneOperandwBit ByteSize | ret

L2: ifnot op2 'P', L2>
        ifnot op1 'B', L1>
            mov al regBp | jmp L3>
L1:     On op1 <> 'S',  jmp L9>>
            mov al regSp | jmp L3>

L2: ifnot op2 'I', L2>
        ifnot op1 'S', L1>
            mov al regSi | jmp L3>
L1:     On op1 <> 'D',  jmp L9>>
            mov al regDi

L3:     mov W$esi 0 | add esi 3 | mov ah reg | mov B$OneOperandwBit WordSize | ret

L2: ifnot op2 'S', L5>
        ifnot op1 'E', L1>
           mov al regEs | jmp L3>
L1:     ifnot op1 'C', L1>
           mov al regCs | jmp L3>
L1:     ifnot op1 'S', L1>
           mov al regSs | jmp L3>
L1:     ifnot op1 'D', L1>
           mov al regDs | jmp L3>
L1:     ifnot op1 'F', L1>
           mov al regFs | jmp L3>
L1:     On op1 <> 'G',  jmp L9>>
           mov al regGs

L3:     mov W$esi 0 | add esi 3 | mov ah sReg | mov B$OneOperandwBit WordSize | ret

; Is it a 3 letters MMX register name?

L5: On op4 nb Separators,  jmp L9>>
       IfNot op1, 'M', L5>
         IfNot op2, 'M', L5>
           cmp op3, '0' | jb L5>
           cmp op3, '7' | jg L5>
             sub bh, '0' | mov al bh | mov ah MMreg
             and D$esi 0FF000000 | add esi 4 | mov B$OneOperandwBit DoubleSize | ret

; Is it a 3 letters STx register name?

L5: IfNot op1, 'S', L5>
        IfNot op2, 'T', L5>
           cmp op3, '0' | jb L5>
           cmp op3, '7' | jg L5>
             sub bh, '0' | mov al bh | mov ah STreg
             and D$esi 0FF000000 | add esi 4 | mov B$OneOperandwBit DoubleSize | ret

; Is it a 3 letters DRx register name?

L5: IfNot op1, 'D', L5>
        IfNot op2, 'R', L5>
           cmp op3, '0' | jb L5>
           cmp op3, '7' | jg L5>
             sub bh, '0' | mov al bh | mov ah dReg
             and D$esi 0FF000000 | add esi 4 | mov B$OneOperandwBit DoubleSize | ret

; Is it a 3 letters CRx register name?

L5: IfNot op1, 'C', L5>
        IfNot op2, 'R', L5>
           cmp op3, '0' | jb L5>
           cmp op3, '4' | jg L5>
             sub bh, '0' | mov al bh | mov ah cReg
             and D$esi 0FF000000 | add esi 4 | mov B$OneOperandwBit DoubleSize | ret


;IsItAreg32:

L5: On op1 <> 'E',  jmp L9>
        ifnot op3 'X', L3>
            ifnot op2 'A', L2>
                mov al regEAX | jmp L4>
L2:         ifnot op2 'C', L2>
                mov al regECX | jmp L4>
L2:         ifnot op2 'D', L2>
                mov al regEDX | jmp L4>
L2:         On op2 <> 'B',  jmp L9>
            mov al regEBX | jmp L4>
L3:     ifnot op3 'P', L3>
            ifnot op2 'S', L2>
                mov al regESP | jmp L4>
L2:         On op2 <> 'B',  jmp L9>
                mov al regEBP | jmp L4>
L3:     On op3 <> 'I',  jmp L9>
            ifnot op2 'S', L2>
                mov al regESI | jmp L4>
L2:         On op2 <> 'D',  jmp L9>
                mov al regEDI

L4:     and D$esi 0FF000000 | add esi 4 | mov ah, Reg | mov B$OneOperandwBit DoubleSize | ret

L9: ; 4 Chars Register? > XMM.?

    ifnot op1 'X', L9>
        ifnot op2 'M', L9>
            ifnot op3 'M', L9>
                cmp op4, '0' | jb L9>
                    cmp op4, '7' | jg L9>
                        sub op4, '0' | mov al op4 | mov ah XMMreg
                        mov D$esi 0 | add esi 5
                        mov B$OneOperandwBit OctoSize | ret


L9: mov eax 0 | ret


; when called 'E' found, esi points to the next letter
; 'IsItAnEreg' doesn't change esi
; 'SearchForEreg' does.

IsItAnEreg:
    mov B$Ereg NotFound | call Store4cars | IfNotPartEnd op3, L9>>

    IfNotPartEnd B$esi-2, L9>>
        ifnot op2 'X', L2>
            ifnot op1 'A', L1>
                mov B$Ereg regEAX | ret
L1:         ifnot op1 'C', L1>
                mov B$Ereg regECX | ret
L1:         ifnot op1 'D', L1>
                mov B$Ereg regEDX | ret
L1:         ifnot op1 'B', L9>
                mov B$Ereg regEBX | ret
L2:     ifnot op2 'P', L2>
            ifnot op1 'B', L1>
                mov B$Ereg regEBP | ret
L1:         ifnot op1 'S', L9>
                mov B$Ereg regESP | ret
L2:     ifnot op2 'I', L9>
            ifnot op1 'S', L1>
                mov B$Ereg regESI | ret
L1:         ifnot op1 'D', L9>
                mov B$Ereg regEDI | ret
L9: ret


SearchForEreg:
    mov B$Ereg NotFound                     ; this double declaration is NOT useless
L0: lodsb | cmp al, 0 | je L0<
        cmp al Separators | jb L9>
            cmp al PartEnds | jb L0<
                On al = 'E',  call IsItAnEreg
                IfEregNotFound L0<

    mov B$EregInside &TRUE | mov al B$Ereg,  B$PossibleRmEReg al
    add esi 2                               ; esi >>> next char. after Ereg.
    mov B$esi-3 0,  B$esi-2 0,  B$esi-1 0   ; clear eReg
    ret

L9: dec esi                                 ; reach end of text word >>> Stay on EOI
ret                                         ; or Space for further possible calls


; SIB byte is [xx xxx xxx] >>> [sf index base]
; in  ECX*4+EDX  , ECX is the index, 4 is the scale factor, EDX is the base.
; when SearchForScale is called , an Ereg has been found. ESI points to possible '*'

SearchForScale:
    mov B$ScaleFound &FALSE | cmp B$esi MulSign | jne L9>
    IfNotPartEnd B$esi+2,  L8>
    mov al B$esi+1
    cmp al '2' | jne L1>
        mov al 00_0100_0000 | jmp L3>
L1: cmp al '4' | jne L2>
        mov al 00_1000_0000 | jmp L3>
L2: cmp al '8' | jne L8>
        mov al 00_1100_0000
L3: On B$Ereg = regESP,  error D$ESPsibPtr              ; ESP can not be an index
    add esi 2 | mov B$ScaleFound &TRUE
    mov B$esi-2 0,  B$esi-1 0                      ; clear scale
    mov bl B$Ereg | shl bl 3 | or bl al            ; store [xx xxx ...]
    mov B$ScaledIndex bl                           ; in ScaledIndex
L9: ret
L8: error D$ScaleValuePtr


; forbidden use of non extended registers in memory adressing statements:

VerifyNoOtherReg:
    push esi
L0:   lodsb
      cmp al 0 | je L0<
        cmp al Separators | jb L9>
            cmp al PartEnds | jb L0<
                dec esi | call IsItAreg | cmp eax 0 | je L1>
                On B$OneOperandwBit <> DoubleSize, error D$WishEregPtr
                On ah <> Reg, error D$WishEregPtr
L1:             inc esi
L2:             cmp B$esi PartEnds | jb L0>         ; strip remaining text
                    inc esi | jmp L2<
L9: pop esi
ret


SearchForSIB:
    mov B$SibInside &FALSE, B$Reg1isIndex &FALSE, B$Reg2isIndex &FALSE, B$TwoRegsFound &FALSE
    push esi
      call SearchForEreg | IfEregFound L0>
        pop esi
          call VerifyNoOtherReg
        ret

L0: mov al B$Ereg,  B$SIBreg1 al

    call SearchForScale | mov al B$ScaleFound, B$Reg1isIndex al   ; true or FALSE
    call SearchForEreg | IfEregNotFound L1>
        On B$esi-4 <> addSign, error D$ExpressionPtr
        mov al B$Ereg,  B$SIBreg2 al | mov B$TwoRegsFound &TRUE

        call SearchForScale | mov al B$ScaleFound,  B$Reg2isIndex al
        call SearchForEreg | On B$Ereg <> NotFound,  error D$expressionPtr    ; 3 regs forbidden

        .If B$ScaleFound = &FALSE
            If B$SIBreg2 = RegEBP
              ; Exchange the two regs, for saving from having to add the zero Dis:
                mov al B$SIBreg1, bl B$SIBreg2
                mov B$SIBreg2 al, B$SIBreg1 bl
            End_If
        .End_If

L1: mov al B$Reg1isIndex,  ah B$Reg2isIndex                    ; 2 index forbidden
    On ax = 0101,  error D$DoubleIndexPtr
    cmp ax 0 | je L4>                                          ; if no index found >L8

    mov B$SIBinside &TRUE | cmp ax 1 | je L2>            ; if here: 1 reg / 1 index
        mov al B$ScaledIndex | or al B$SIBreg1                 ; reg2 is Index and
        mov B$SIB al | jmp L9>>                                 ; reg1 is base

L2: cmp B$TwoRegsFound &TRUE | je L3>
        mov B$SibReg2 00101                              ; if no base > base = 00101
        mov B$DummyDis &TRUE                                    ;

L3: mov al B$ScaledIndex | or al B$SIBreg2                      ; reg1 is Index
      mov B$SIB al | jmp L9>

L4: cmp B$TwoRegsFound &TRUE | jne L5>                           ; no index, but
        mov B$SibInside &TRUE
        If B$SIBreg1 = 00_100
          ; Other way round, because there is no esp Index (only Base)
            mov al B$SIBreg2 | On al = 00_100, error D$ExpressionPtr
            shl al, 3 | or al B$SIBreg1
        Else
            mov al B$SIBreg1 | shl al, 3 | or al B$SIBreg2
        End_If

        mov B$SIB al | jmp L9>

L5: cmp B$SIBreg1 regESP | jne L9>             ; no index found, only one reg found, but
        mov B$SibInside &TRUE | mov B$SIB 024     ; if reg = ESP >SIB
L9: pop esi
    ret


[immSign: ?]

SearchForImm:      ; if yes, return value set in eax by translating routines
                   ; esi incrementations done by translating routine
    mov B$immSign &FALSE
    push esi | jmp L1>

L9: pop esi | ret

L0:     inc esi
L1:     mov dh B$esi-1,  B$ExpressedSign dh | mov ah B$esi,  al B$esi+1
        cmp ah textSign | je L7>>
        ifSeparator ah, L9<
        cmp ah '0' | jb L0<
        cmp ah '9' | ja L0<
        cmp dh PartEnds | ja L0<
        mov B$immInside &TRUE
        push esi
            IfNot ah, '0', L2>
            IfNot al, '0', L3>
            call translateBinary | jmp L4>
L2:         call TranslateDecimal | jmp L4>
L3:         call TranslateHexa
L4:         On edx > 0, error D$OutOfRangePtr
            cmp B$ExpressedSign Space | je S1>

            cmp B$ExpressedSign addSign | jne S2>
S1:             mov ebx D$imm32 | add D$imm32 eax
                On D$imm32 < ebx, mov B$immSign &FALSE
                jmp L5>
S2:         On B$ExpressedSign <> SubSign,  error D$NotYetSignPtr
            On D$imm32 < eax, mov B$immSign &TRUE
            sub  D$imm32 eax

L5:     pop esi
L6:     mov B$esi 0                                         ; clear imm
        inc esi | cmp B$esi PartEnds | ja L6<
        jmp L1<<
;;
  Why the Api calls (that are "call D$Location" Type...) are routed to 'SearchForImm',
  is because the Text Parameter ('Module.Function') looks like a 'Text' Member, for
  the Parsers of the Instructions Parameters.
;;
L7:     inc esi | call NewSearchApiName | dec esi
        On B$ApiFound = &TRUE, jmp L9<<

        push edi
            mov B$immInside &TRUE | mov edi imm32 | lodsb   ; read text sign
L7:         mov B$esi-1 0 | lodsb                           ; clear imm text
            cmp al TextSign | je L8>
            add B$edi al | inc edi
            On edi = imm32+5,  error D$TxtTooMuchPtr             ; max of 4 letters
            jmp L7<
L8:         mov B$esi-1 0                                   ; clear last text marker sign
        pop edi
        jmp L1<<

L9: pop esi
    cmp D$imm32 07F        ; Test for sBit: turn sBit to 0010 if byte sign imm
        ja L9>                   ; max. is 07F for positive values (and  0FF for
        mov B$sBit 0010               ; negative ones).
        mov B$immSign &FALSE  ; Because no need for storing SignExtended Bytes in 'StoreImm'
L9:     mov eax D$imm32
        and eax 0FFFFFF00 | cmp eax 0FFFFFF00 | jne L9>
        mov B$sBit 0010
        mov B$immSign &FALSE  ; Because no need for storing SignExtended Bytes in 'StoreImm'
L9: ret

;;
 I don't use upper chunk (from 'L9: pop esi'), because of the Sign Extensions able
 Opcodes. In case of Byte immediate with a possible immediate Label, we can't know
 here if there will be or not some trailing Label. Example:

 > and D$Label1+020 Label2-4

 Label2 will only be computed and the end of job, *after* other encodages. There is
 a test Routine, 'sim', that does this complicated job at the end of OpCode encodage.
 In cases of negative Sign Extended imm Bytes, the 'B$immSign' is turned &FALSE there
 to solve the problem of overflow tests done in 'StoreImm', for negative Bytes stored
 as dWords for 'non-Sign-Extended' Opcodes.
;;
____________________________________________________________________________________________

; Search for a displacement. If found, return value set by translating routine in eax:

SearchForDis:
    push esi | jmp L1>
L0:     inc esi
L1:     mov dh B$esi-1,  B$ExpressedSign dh
        mov ah B$esi,  al B$esi+1
        cmp ah 0 | je L0<
        ifSeparator ah, L8>>
        cmp ah '0' | jb L0<
        cmp ah '9' | ja L0<
        cmp dh PartEnds | ja L0<
        mov B$DisInside &TRUE
        push esi
            IfNot ah, '0', L2>
            IfNot al, '0', L3>
            call translateBinary | jmp L4>
L2:         call TranslateDecimal | jmp L4>
L3:         call TranslateHexa
L4:         On edx > 0, error D$OutOfRangePtr
            mov bl B$esi-1
            If bl < Separators
            Else_If bl = addSign
            Else_If bl = subSign
            Else_If bl < LowSigns
                Error D$ExpressionPtr
            End_If
            cmp B$ExpressedSign Space | je S1>  ; ... ???? What case ???? ...
            cmp B$ExpressedSign 0 | je S1>
            cmp B$ExpressedSign addSign | jne S2>
                test D$Dis32 0_8000_0000 | jz S1>
                    neg D$Dis32 | sub D$Dis32 eax | neg D$Dis32 | jmp L6>
S1:                 add D$Dis32 eax | jmp L6>
S2:         On B$ExpressedSign <> SubSign,  error D$NotYetSignPtr
            test D$Dis32 0_8000_0000 | jz L5>
                neg D$Dis32 | add D$Dis32 eax | neg D$Dis32 | jmp L6>
L5:                 sub D$Dis32 eax
L6:     pop esi
L7:     mov B$esi 0
        inc esi | cmp B$esi PartEnds | ja L7<
        jmp L1<<

L8: pop esi

    mov eax D$Dis32        ; 080 > -128          //  07F > +127
    If eax > 0FFFF_FF7F    ; 0FFFF_FF80 > -128  //   0FFFF_FF7F > -129
        mov B$LongRelative &FALSE
    Else_If eax < 080
        mov B$LongRelative &FALSE
    Else
        mov B$LongRelative &TRUE
    End_If
ret


SearchForLabel:
    push esi
        mov edi D$CodeRefPtr
L0:     lodsb | cmp al 0 | je L0<
                cmp al Separators | jb L9>>
                cmp al 'A' | jb L0<
                cmp al, 'Z' | ja L0<
        On B$esi-2 = AddSign,  mov B$esi-2 0
        cmp al 'E' | jne L1>
        push eax
            call IsItAnEreg                 ; usefull only in case of mem adressing
        pop eax
        IfEregNotFound L1>
            add esi 2 | jmp L0<             ; (Mod/RM byte done after)

L1:     mov B$esi-1 0                       ; clear label evocation

      ; Local size is used for Local Labels coding
        .If al = '>'
            add B$LocalSize 4     ; > 00100    >> 001000
            If B$LocalSize = 4
              ; OK.
            Else_If B$LocalSize <> 8
E7:             error D$WhatIsThisPtr
            End_If
            If B$esi = '>'
              ; OK
            Else_If B$esi > Separators
                jmp E7<
            End_If
        .Else_If al = '<'
            add B$LocalSize 1     ; < 001      << 0010
            If B$LocalSize = 1
              ; OK.
            Else_If B$LocalSize <> 2
                jmp E7<
            End_If
            If B$esi = '<'
              ; OK
            Else_If B$esi > Separators
                jmp E7<
            End_If

        .End_If

        .If D$esi-9 = 'LOOP'
            If B$LocalSize = 0
                ; OK.
            Else_If B$LocalSize <> 1
                error D$LongLoopPtr
            End_If
        .End_If

        stosb                               ; write label name in CodeRef
        lodsb | IfNotPartEnd al, L1<<
        mov eax D$CodeRefPtr | add eax 2 | cmp eax edi | jne L2>  ; local label without '<'?
          mov ah B$edi-2,  al B$edi-1
          cmp ah 'A' | jb L2>
            cmp ah 'Z' | ja L2>
              cmp al '0' | jb L2>
                cmp al '9' | ja L2>         ; Local label without direction specifier?
                  mov al '<' | stosb        ; default, for exemple for LOOP L0
                    mov B$LocalSize 1       ; UpShort
L2:       mov al EOI | stosb
          inc B$ExpressedLabels
          On B$ExpressedLabels > 2, error D$TooMuchLabelsPtr
          mov B$LabelInside &TRUE,  B$DisInside &TRUE

L9:     mov D$CodeRefPtr edi
    pop esi
ret


SearchForModRMreg:
    mov cl 32 | cmp B$LabelInside &TRUE | je L0>
    mov eax D$Dis32

    On B$LongRelative = &FALSE, mov cl 8
                                      ; for ByteSize tests on Displacement
                                                ; (080 >>> -128)
L0: push esi
        cmp B$SIBinside &TRUE | je L0>                      ; no SIB found? >>> no more regs
            cmp B$EregInside &FALSE | je L1>                ; may be, an Ereg?
                mov al B$PossibleRmEreg | mov B$RMbits al | jmp L3>>

; no RMreg > choice: simple dis32, dis followed by SIB byte, SIB byte only:

L0:     cmp B$DisInside &TRUE | je L2>
            mov B$ModBits 0 | mov B$RMbits 00100 | jmp L9>> ; SIB with no dis

L1:     cmp B$DisInside &TRUE | jne L9>>                    ; nothing at all > exit
            mov B$ModBits 0 | mov B$RMbits 00101 | jmp L9>> ; dis32 with no SIB and no reg

L2:     mov B$RMbits 00100 | cmp cl 32 | je L2>
            cmp B$DummyDis &TRUE | je L2>
            mov B$ModBits 00_01_000_000 | jmp L9>           ; dis8 + SIB
L2:             If B$TwoRegsFound = &TRUE
                    mov B$ModBits 00_10_000_000             ; dis32 + SIB
                Else_If B$Sib = 024
                    mov B$ModBits 00_10_000_000             ; dis32 + esp only SIB
                Else
                    mov B$ModBits 0                         ; dis32 + SIB with no Base
                End_If
                jmp L9>

; RMreg found > choice: no dis, dis8, dis32 (if reg = EBP and no dis > add zero 8bits dis)

L3:     cmp B$DisInside &FALSE | je L6>
            cmp cl 32 | je L5>
L4:             mov B$ModBits 00_01_000_000 | jmp L9>       ; dis8 + reg
L5:             mov B$ModBits 00_10_000_000 | jmp L9>       ; dis32 + reg

L6:     cmp B$RmBits regEBP | jne L7>                       ; reg EBP >>> add zero dis
            mov B$DisInside &TRUE | jmp L4<

L7:     mov B$ModBits 0                                     ; reg without displacement

L9: pop esi

  ; This is to force things like "push D$fs:+0' to be encoded Long, and not short dis form:
    cmp B$DisInside &TRUE | jne L9>
        cmp B$LabelInside &FALSE | jne L9>
            cmp B$EregInside &FALSE | jne L9>
                mov B$LongRelative &TRUE

L9: ret


SearchForFirstFPUimm:
    mov B$FirstGender imm | jmp L0>
SearchForSecondFPUimm:
    mov B$SecondGender imm

L0: push esi
        call atof
        On al > CloseBracket, error D$BadRealPtr
        fstp D$imm32
        mov B$ImmInside &TRUE, B$immSign &FALSE
    pop esi
L0: mov B$esi 0                                     ; clear imm
    inc esi | cmp B$esi PartEnds | ja L0<
  ret


FirstParameterAnalyze:
    mov esi D$LineStart

L0: lodsb                               ; simply increase esi over first space; after this,
    cmp al Space | jne L0<                    ; save esi pointing to parameter (> push/pop)

    cmp B$esi+1 memMarker | jne L4>>               ; if mem marker found, store ascii value
      mov al B$esi | mov B$FirstParaMem al
      mov W$esi 0 | add esi 2                     ; (see equ. for bMem, wMem, dMem)
      If B$esi = MemMarker
        inc esi
      End_If
      mov B$FirstGender mem

        On B$esi = EOI, error D$ParameterPtr

        .If al = dMem
             mov B$FirstOperandwbit DoubleSize   ; D$            4 bytes
        .Else_If al = bMem
             mov B$FirstOperandwbit ByteSize     ; B$            1 byte
        .Else_If al = wMem
             mov B$FirstOperandwbit WordSize     ; W$            2 bytes
        .Else_If al = qMem
             mov B$FirstOperandwbit QuadSize     ; Q$            8 bytes
        .Else_If al = rMem
             mov B$FirstOperandwbit QuadSize     ; R$ = FPU Q$   8 bytes
      ;  .Else_If al = hMem
      ;       error NewHmem
       ;      mov B$FirstOperandwbit QuadSize     ; H$ = FPU Q$   8 bytes >>> 16 bytes (!!!)
        .Else_If al = fMem
             If B$esi < 'A'
                 call SearchForFirstFPUimm | ret     ; exemple: push F$45.2
             Else
                 mov B$FirstOperandwbit DoubleSize   ; F$ = FPU D$
             End_If
        .Else_If al = tMem
             mov B$FirstOperandwbit TenSize      ; T$ = FPU 10 Bytes / 80 bits (m80)
        .Else_If al = xMem
            mov B$FirstOperandwbit XSize         ; Weird and XMM sizes
        .Else_If al = oMem
            mov B$FirstOperandwbit OctoSize         ; Weird and XMM sizes
        .Else
            On al = hMem, error D$NewHmemPtr
            error D$UnknownSizePtr
        .End_If

L3:   call SearchForSIB
      call SearchForDis
      call SearchForLabel
      ...If B$SibInside = &TRUE
        ..If B$DisInside = &FALSE
            .If B$ParametersNumber = 1
                If B$TwoRegsFound = &TRUE
                    mov al B$SIB | and al 00_111
                    On al = 00_101, mov B$DisInside &TRUE, B$LongRelative &true
                End_If
            .End_If
        ..End_If
    ...End_If
      call SearchForModRMreg
        or B$ExpressedLabels 1                           ; we want B$ExpressedLabels < 3
        On B$ExpressedLabels > 2, error D$TooMuchLabelsPtr ; but only one Lab per member
    ret

L4: call IsItaReg | cmp ah 0 | je L5>
      mov B$FirstGender reg,  B$FirstReg al,  B$FirstRegGender ah
      mov al B$OneOperandwbit,  B$FirstOperandwbit al
    ret

L5: call SearchForImm | cmp B$ImmInside &FALSE | je L6>
      mov B$FirstGender imm | mov B$PossibleFirstImmLabel &TRUE
    ret

L6: If B$ApiFound = &TRUE   ; 'NewSearchApiName'
        mov B$DisInside &TRUE, B$ApiFound &FALSE, B$FirstGender mem
        mov B$ModBits 0, B$RmBits 00101
        mov B$FirstOperandwBit doubleSize
        ret
    End_If

L6: call SearchForLabel | On B$LabelInside = &FALSE,  error D$UnknownParameterPtr
      mov B$FirstGender dis
      or B$ExpressedLabels 1                            ; we want B$ExpressedLabels < 3
      On B$ExpressedLabels > 2, error D$TooMuchLabelsPtr     ; but only one Lab per member
    ret
____________________________________________________________________________________________

SecondParameterAnalyze:
    mov esi D$LineStart

L0: lodsb                                        ; simply increase esi over second space
    cmp al Space | jne L0<
L1: lodsb | cmp al Space | jne L1<

    cmp B$esi+1 memMarker | jne L5>>             ; if mem marker found, store ascii value
        mov al B$esi | mov B$secondParaMem al
        mov W$esi 0 | add esi 2                  ; (see equ. for bMem, wMem, dMem, ...)
        mov B$secondGender mem

        On B$esi = EOI, error D$ParameterPtr

        .If al = dMem
             mov B$SecondOperandwBit DoubleSize   ; D$
        .Else_If al = bMem
             mov B$SecondOperandwBit ByteSize     ; B$
        .Else_If al = wMem
             mov B$SecondOperandwBit WordSize     ; W$
        .Else_If al = qMem
             mov B$SecondOperandwBit QuadSize     ; Q$
        .Else_If al = rMem
             mov B$SecondOperandwBit QuadSize     ; R$ = FPU Q$
        .Else_If al = hMem
             error D$NewHmemPtr
       ;      mov B$SecondOperandwBit QuadSize     ; H$ = FPU Q$ (!!! > 16 bytes / 128 bits !!!)
        .Else_If al = fMem
             If B$esi < 'A'
                 call SearchForSecondFPUimm | ret      ; exemple: mov eax F$45.2
             Else
                 mov B$SecondOperandwBit DoubleSize   ; F$ = FPU D$
             End_If

        .Else_If al = tMem
             mov B$SecondOperandwBit TenSize      ; T$ = FPU 10 Bytes
        .Else_If al = xMem
            mov B$SecondOperandwbit XSize         ; Weird and XMM sizes
        .Else_If al = oMem
            mov B$SecondOperandwbit OctoSize      ; XMM sizes
        .Else
            On al = hMem, error D$NewHmemPtr
            error D$UnknownSizePtr
        .End_If

L4:     call SearchForSIB
        call SearchForDis
        call SearchForLabel
        ...If B$SibInside = &TRUE
            ..If B$DisInside = &FALSE
                .If B$FirstGender = reg
                    If B$TwoRegsFound = &TRUE
                        mov al B$SIB | and al 00_111
                        On al = 00_101, mov B$DisInside &TRUE, B$LongRelative &FALSE
                    End_If
                .End_If
            ..End_If
        ...End_If
        call SearchForModRMreg
    ret

L5:   call IsItaReg | cmp ah 0 | je L6>
      mov B$secondGender reg,  B$secondReg al,  B$SecondRegGender ah
      mov al B$OneOperandwbit,  B$secondOperandwbit al

      ...If B$SibInside = &TRUE
        ..If B$DisInside = &FALSE
            .If B$FirstGender = Mem
                If B$TwoRegsFound = &TRUE
                    mov al B$SIB | and al 00_111
                    On al = 00_101, mov B$DisInside &TRUE, B$LongRelative &FALSE
                    call SearchForModRMreg
                End_If
            .End_If
        ..End_If
    ...End_If

    ret

L6:   call SearchForImm
      cmp B$ImmInside &FALSE | je L7>
      mov B$secondGender imm | mov B$PossibleImmLabel &TRUE
    ret

L7: If B$ApiFound = &TRUE   ; 'NewSearchApiName'
        mov B$DisInside &TRUE, B$ApiFound &FALSE, B$SecondGender mem
        mov B$ModBits 0, B$RmBits 00101
        mov B$SecondOperandwBit doubleSize
        ret
    End_If

L7:   cmp D$DisInside &TRUE | jne L8>
      mov B$secondGender imm | mov B$PossibleImmLabel &TRUE
    ret

L8:  If B$ExpressedLabels = 0
        call SearchForLabel
        On B$LabelInside = &FALSE,  error D$UnknownParameterPtr
        mov B$SecondGender dis
      Else                                     ; Case of 'mov D$Lab1 Lab2'
        mov B$ImmInside &TRUE, B$secondGender imm, B$PossibleImmLabel &TRUE
      End_If                                   ; Lab2 checked by PossibleImmLabel
      mov B$sBit 0
    ret

FirstParameterLabel:
    mov esi D$LineStart | jmp L1>

SecondParameterLabel:
    mov esi D$LineStart
L0: lodsb | cmp al Space | jne L0<
L1: lodsb | cmp al Space | jne L1<
    push esi
      mov edi D$CodeRefPtr
L0:   lodsb | cmp al 0 | je L0<
              cmp al Separators | jb L9>>
              cmp al 'A' | jb L0<
              cmp al, 'Z' | ja L0<
      On B$esi-2 = AddSign,  mov B$esi-2 0
      cmp al 'E' | jne L1>
      push eax
        call IsItAnEreg                      ; usefull only in case of mem adressing
      pop eax
          IfEregNotFound L1>
            add esi 2 | jmp L0<              ; (Mod/RM byte done after)
L1:     cmp al  '>' | je A1>
        cmp al  '<' | jne A2>
A1:       error D$NoLocalPtr
A2:     stosb                                ; write label name in CodeRef
        mov B$esi-1 0
        lodsb | IfNotPartEnd al, L1<
        mov eax D$CodeRefPtr | add eax 2 | cmp eax edi | jne L2>  ; no local label here
          mov ah B$edi-2,  al B$edi-1
          cmp ah 'A' | jb L2>
            cmp ah 'Z' | ja L2>
              cmp al '0' | jb L2>
                cmp al '9' | ja L2>
                  jmp A1<                                          ; no local label here
L2:       mov al EOI | stosb
          mov eax D$CodeListPtr
          On B$immInside = &TRUE, sub eax 4
          stosd

          mov eax D$StatementsPtr, eax D$eax | stosd     ; write pointer to source.
          mov al EOI | stosb |  mov D$CodeRefPtr edi

          If B$immInside = &FALSE
             mov edi D$CodeListPtr, eax 0 | stosd | mov D$CodeListPtr edi
          End_If

        ; Very stupid. 'FirstParameterLabel' /'SecondParameterLabel' to be re-structured:
          If B$ParametersNumber > 1
            On B$FirstOperandWbit <> DoubleSize, error D$MissTypePtr
          End_If
L9: pop esi
ret
____________________________________________________________________________________________

; Used only in case of SHLD / SHRD. third parameter must be either imm8 or CL

ThirdParameterAnalyze:
    mov esi D$LineStart
L0: lodsb                            ; Simply increases esi over third space; after this,
    cmp al Space | jne L0<
L1: lodsb | cmp al Space | jne L1<
L2: lodsb | cmp al Space | jne L2<

        call IsItaReg | cmp ah 0 | je L3>
        mov B$ThirdGender reg,  B$ThirdReg al,  B$ThirdRegGender ah
        mov al B$OneOperandwbit,  B$ThirdOperandwbit al
    ret

L3:     call SearchForImm
        cmp B$ImmInside &FALSE | je L4>
        mov B$ThirdGender imm
    ret

L4: error D$ParameterPtr
 _________________________________________________________________________________________
 _________________________________________________________________________________________
;;
 Main routine for one assembler line encoding (Data lines have been analyzed before)
 esi points to the first letter of an instruction in CodeSourceB
 we may find a label, one or more prefix(es), a mnemonic and parameters.
 Translates StrippedLine in OpCodes.
 after Data Storage, clean source is in  CodeSourceB as input
 results in:
            - LabelList      (data labels done with storage and now code labels)
            - CodeRef        (labels adresses evocations in codeList -will be used by
                              'fillCodeSymbols', in Main.a-)
            - CodeList       (true code for .code section)
            - Relocation     (for .reloc)

 i call a 'Line' one set of statements between between '||'.
;;
 _________________________________________________________________________________________
 _________________________________________________________________________________________

StoreSIB:
   mov edi D$CodeListPtr | mov al B$SIB | stosb | inc D$CodeListPtr
ret
;;
 Label evocations are fulfill by 'Fill'. In case, for exemple, of
 'MOV EDI, My_Data_Label + 8', we store '8'
 as 'LongRelative' default is true, it is used here for any non short relative. this
 is to say even for not relative at all statements (Intel doc is killing on that point)
;;
StoreDis:
    If B$ApiDis = &TRUE
        mov B$ApiDis &FALSE
        mov edi D$CodeRefPtr, eax D$CodeListPtr     ; Store actual code offset in
        stosd                                       ; Coderef for ending 'Fill' routine
        mov al EOI | stosb
        mov D$CodeRefPtr edi
;;
  The CodeRef registration of Api calls does not have the Source Pointer Record.
  (No use as all Errors Checking have already been done when collecting the Api
  calls). So, only // 0FF / PointerToCode / EOI //, here, where "0FF" is written
  by 'NewSearchApiName' (called by 'SearchForImm').
  
  Why the Api calls (that are "call D$Location" Type...) are routed to 'SearchForImm',
  is because the Text Parameter ('Module.Function') looks like a 'Text' Parameter,
  for the Parsers.
;;
        mov edi D$CodeListPtr
        mov eax D$Dis32 | stosd
        mov D$CodeListPtr edi
        ret
    End_If

    cmp B$LabelInside &TRUE | jne L1>
        mov edi D$CodeRefPtr, eax D$CodeListPtr     ; Store actual code offset in
        or eax D$Relative | stosd                   ; Coderef for ending 'Fill' routine
        mov eax D$StatementsPtr, eax D$eax | stosd  ; write pointer to source:
        mov al EOI | stosb
        mov D$CodeRefPtr edi

L1: mov edi D$CodeListPtr
    cmp B$LabelInside &TRUE | jne L2>
      cmp B$LocalSize 4 | je L4>
        cmp B$LocalSize 1 | je L4>
          jmp L3>

L2: cmp B$DummyDis &TRUE | je L3>
    cmp B$LongRelative &TRUE | jne L4>              ; default is true

L3:     mov eax D$Dis32 | stosd                     ; Store displacement in code
        mov D$CodeListPtr edi
    ret

L4:     mov al B$Dis32 | stosb
        mov D$CodeListPtr edi
ret


StoreImm:
    cmp B$immSign &TRUE | jne L0>
        cmp B$TrueSize ByteSize | jne L1>
            On D$imm32 < 0_FFFF_FF00,  error D$overflowPtr
            and D$imm32 0FF | jmp L0>
L1:     cmp B$TrueSize WordSize | jne L0>
            On D$imm32 < 0_FFFF_0000,  error D$overflowPtr
            and D$imm32 0FFFF

L0: mov edi D$CodeListPtr
    cmp B$TrueSize DoubleSize | je L2>
    cmp B$TrueSize ByteSize | je L3>

L1: On D$imm32 > 0FFFF,  error D$overflowPtr     ; word size
    mov ax W$imm32 | stosw | jmp L9>

L2: mov eax D$imm32 | stosd | jmp L9>       ; double size

L3: On D$imm32 > 0FF,  error D$overflowPtr       ; Byte size
    mov al B$imm32 | stosb

L9: mov D$CodeListPtr edi
ret

;;
 wBit is used when encoding instruction as 0 or 1, telling if it is byte or full
 size. full size is either 2 or 4 bytes: 32 bits > double word. With operand size
 override prefix, it is turn to word.
 'TrueSize' is used internally to hold lenght of code to write when fixing adresses
 of symbols after encoding (see Main)
;;
Store2Wbit:
    mov al B$FirstOperandWbit | cmp B$secondOperandWbit al | je L0>
        mov B$wBitDisagree &TRUE
ret


StoreFirstWbit:
    mov al B$FirstOperandWbit

StoreWbit:
L0: cmp al WordSize | jne L1>
        mov edi D$CodeListPtr
        mov B$edi 066 | inc D$CodeListPtr        ; write operand size override prefix
L1:     mov B$TrueSize al | and al 1 | mov B$wBit al
ret


FixInstructionType:
    mov edi D$CodeListPtr
    cmp B$FirstGender reg | jne L3>
      cmp B$SecondGender reg | jne L0>
        mov B$Operands RegToReg | call Store2Wbit | ret
L0:   cmp B$SecondGender mem | jne L1>
        mov B$Operands MemToReg | call Store2Wbit | ret
L1:   cmp B$SecondGender dis | je L2>
      cmp B$SecondGender imm | jne L9>>
L2:     mov B$Operands ImmToReg | call StoreFirstWbit | ret

L3: cmp B$FirstGender Mem | jne L6>
      cmp B$SecondGender reg | jne L4>
        mov B$Operands RegToMem | call Store2Wbit | ret

L4:   cmp B$SecondGender dis | je L5>
      cmp B$SecondGender Imm | jne L9>
L5:
        mov B$Operands ImmToMem | call StoreFirstWbit | ret

L6: cmp B$FirstGender imm | jne L9>
      cmp B$SecondGender reg | jne L7>
        mov B$Operands RegToImm | ret
L7:   cmp B$SecondGender imm | jne L9>
        mov B$Operands ImmToImm
        mov esi D$LineStart | lodsb | cmp al, 'E' | jne L9>
             ret           ; exemple: ENTER 8, 2
                           ; exceptions: Job will be done when coding ENTER
L9: error D$MixTypePtr


SearchLineLabel:
L0: lodsb
    cmp al EOI | jbe L2>                        ; case of simple mnemonics, like |AAA|
        cmp al Space | jne L3>
L2:  mov esi D$LineStart | jmp L9>
L3:     cmp al ColonSign | jne L0<
        push esi
            mov esi D$LineStart | call StoreCodeLabel  ; in 'LabelList'
            inc D$CodeLabelsCounter
        pop esi
        mov D$LineStart esi                     ; new instruction's first letter after label
        If B$esi = ColonSign
            inc esi | inc D$LineStart           ; '::' for .export in DLL.
        End_If
    jmp L0<                                     ; Another Label following?:
L9: ret


ClearParameters:                                ;(clear parameters data area)
    push edi
        mov al 0,  edi ParametersData,  ecx D$ParametersDataLen | rep stosb
    pop edi
ret


; Count of spaces = number of parameters (previous componants are cleared if any)

ParametersCount:
    mov cl 0

    On D$esi = 'ENTE', jmp L9>             ; WordImm / ByteImm Param for Enter...
L0: lodsb | cmp al space | jne L1>
        inc cl                           ; one space >  +1 parameter in cl
        If B$esi-2 = MemMarker
            dec cl | mov B$esi-1 MemMarker
        End_If
L1: cmp al EOI | ja L0<
L9: mov B$ParametersNumber cl
ret

 _______________________________________________________________________________________
;;
 encodage of Apis calls is not done in 'Encode' but here with a memory indirect call:
  1111 1111 : mod 010 r/m
 the 3 routines are linked by jumps when needed (not by calls)
;;

[ApiFound: ?]

; Called with esi pointing to the next Char after 'TextSign'. Called from 'SearchForImm'
; because 'xxxx' may as well be a immediate.


; Previous holding of numbered Api (!!!...):
;
;    push edi
;        mov edx D$ebx               ; Table 1 pointers Ptr
;        mov ebx D$ebx+16            ; table 2 pointers Ptr
;        add edx ecx | add ebx ecx
;
;L0:     mov edi D$edx               ; pointer to function name
;        test edi 0_8000_0000 | jz L1>
;L5:         lodsb | cmp al TextSign | jne L5<
;                pop edi | jmp EncodeApiCall

[ApiByNumber: ? #4] [ApiDis: ?]

NewSearchApiName:
; A Description of .Import is in the Disassembler 'CheckImport'.
    On D$uImportSize = 0, ret

    pushad

    mov B$ApiFound &FALSE

  ; Adjust esi on the FunctionName first Char. We do not take care of DLL Name,
  ; because this verification has already been done by 'BuildImport'. Instead,
  ; we search along all Functions Chunks.
    While B$esi <> TextSign | inc esi | End_While
    While B$esi <> '.'
        dec esi | On B$esi = TextSign, jmp L0>
    End_While
L0: inc esi                             ; Skip '.' or TextSign >>> FunctionName
    mov edx D$CodeList | add edx 0400   ; ebx > Import header dll pointers
    mov ecx edx                         ; to ajust adress, down there.
    sub ecx 01000                       ; Base Of Import.

  ; edx will keep track of the header
  ; ebx will keep track of the Functions Pointers List
L0: mov ebx D$edx+16

  ; Cases of DLL without .Import:
    If ebx = 0
        popad | ret
    End_If

    add ebx ecx      ; Address Table Pointer

  ; ebx > FunctionName Pointers List
L1: mov edi D$ebx
  ; ??????????????
  ; Un-resolved problem: What if several Functions in different DLLs having the same
  ; Function number???!!!...
    test edi 0_8000_0000 | jz L2>
        If B$esi <> '0'
            push esi | jmp L4>
        End_If

        mov eax edi | xor eax 0_8000_0000

        push esi, ebx, eax
            While B$esi = '0' | inc esi | End_While
            mov ebx 0
H0:         lodsb | sub al '0' | On al > 9, sub al 7
            shl ebx 4 | or bl al
            cmp B$esi TextSign | jne H0<
        pop eax

        If eax = ebx
            pop ebx | jmp L5>
        End_If

        pop ebx | jmp L4>

L2: add edi ecx | add edi 2
  ; edi > Function name (+2 is for the leading word).

L3: push esi
L3:     mov al B$esi | mov ah B$edi | inc esi | inc edi | cmp al ah | je L3<
        cmp al TextSign | jne L4>
        cmp ah 0 | je L5>

  ; Not found:
L4: pop esi

    add ebx 4
    .If D$ebx = 0
        add edx 20
        If D$edx = 0
            popad | ret
        Else
            jmp L0<<
        End_If
    .Else
        jmp L1<<
    .End_If

  ; Found:
L5: pop esi
  ; Clear the 'DLL.Function':
    While B$esi <> TextSign | dec esi | End_While
    Do
        mov B$esi 0 | inc esi
    Loop_Until B$esi = TextSign
    mov B$esi 0

    mov eax ebx
    If D$SavingExtension = '.SYS'
        add eax DRIVERDEFAULT | jmp L1>
    Else_If D$SavingExtension = '.DLL'
        add eax D$LinkerDllDefault
L1:     push ebx
          ; Comments in 'FillCodeSymbols':
            mov ebx D$CodeRefPtr, B$ebx 0FF ;, D$ebx+1 edi, B$ebx+5 EOI
            mov B$ApiDis &TRUE
            add D$CodeRefPtr 1 ;6
          ; The CodeRef thingies are now completed by the 'StoreDis', in order
          ; to assume the Relocations of Api Calls in DLLs.
        pop ebx
    Else
        add eax LINKERDEFAULT
    End_If
    sub eax ecx | mov D$Dis32 eax

    mov B$ApiFound &TRUE

    popad
ret
____________________________________________________________________________________________

;;
 Encodage of an instruction is done. At this time, we control that all parameters
 have been translated (they are supposed to be zeroed)? Reg BL is used to jump
 tests over mnemonic (not zeroed):
;;

PointNextInstruction:
    mov esi D$LineStart, bl 0
L0: lodsb
    cmp al Space | jne L1>
      mov bl 1 | jmp L0<
L1: cmp bl 1 | jne L1>
      cmp al '0' | jbe L1>
     ;  call InternalNextControl  ; (for developpement only)
        error D$UnknownParameterPtr
L1: cmp B$esi EOI | ja L0<
    cmp B$esi 0 | je L0<
  ret


; Private developper control of what exactly is wrong (not zeroed):

InternalNextControl:
    mov esi D$LineStart, ecx 80
L5: lodsb | On al < 32, mov B$esi-1 '.' | loop L5<
    mov B$esi 0
    pushad
        call 'USER32.MessageBoxA' D$hwnd, D$LineStart, ErrorMessageTitle, &MB_SYSTEMMODAL
    popad
ret


Proc IsTrueLocalLabel:
    Argument @Pointer
    Uses ebx

        mov ebx D@Pointer

        ..If B$ebx+2 = ColonSign
            mov al B$ebx
            .If al < 'A'

            .Else_If al > 'Z'

            .Else
                mov al B$ebx+1
                If al < '0'

                Else_If al > '9'

                Else
                    mov eax &TRUE | ExitP
                End_If
            .End_If
        ..End_If

        mov eax &FALSE
EndP


; 'DB 0....' encounted:

StoreFlatData:
    push eax
        If al = 'B'
            ; OK

        Else_If al = 'W'
            ; OK
        Else_If al = 'U'
            ; OK
        Else_If al = 'D'
            ; OK
        Else_If al = 'Q'
            ; OK
        Else_If al = 'F'
            ; OK
        Else_If al = 'R'
            ; OK
        Else_If al = 'T'
            ; OK
        Else_If al = 'X'
            ; OK

        Else
            error D$NotAnOpcodePtr
        End_If

    ;  ; We must have a Label at the beginning of Line:
    ;    mov ebx esi | While B$ebx > EOI | dec ebx | End_While | inc ebx
    ;  ; Cannot be a True Local Label:
    ;    call IsTrueLocalLabel ebx | On eax = &TRUE, error D$LocalDefLabelPtr
    ;  ; But must be a Label:
    ;    While B$ebx > LowSigns | inc ebx | End_While
    ;    On B$ebx <> ColonSign, error D$WhatIsThisPtr
    pop eax

  ; in: al = Size_Type // esi >>> 'DB ' >>> Go to the first Data after 'DB '
    mov edi D$CodeListPtr
; StoreDatas StoreOneData
L0: .If al = 'B'

        call StoreDBcode

    .Else_If al = 'W'
        call StoreDWcode
    .Else_If al = 'U'
        call StoreDUcode
    .Else_If al = 'D'
        call StoreDDcode
    .Else_If al = 'Q'
        call StoreDQcode
    .Else_If al = 'F'
        error D$NotYetMnemoPtr
        ;call StoreDFcode
    .Else_If al = 'R'
        error D$NotYetMnemoPtr
        ;call StoreDRcode
    .Else_If al = 'T'
        error D$NotYetMnemoPtr
        ;call StoreDTcode
    .Else_If al = 'X'
        error D$NotYetMnemoPtr
        ;call StoreDXcode
    .Else
        error D$UnknownSizePtr
    .End_If

    dec esi
    If B$esi > EOI
        inc esi | jmp L0<<
    End_If

    mov D$CodeListPtr edi

  ; Arase the Source Line:
    mov ebx D$LineStart
    While ebx < esi
        mov B$ebx 0 | inc ebx
    End_While
    dec esi
ret


GetFlatInteger:
    If W$esi = '00'
        call TranslateBinary
    Else_If B$esi = '0'
        call TranslateHexa
    Else_If B$esi < '0'
        error D$UnknownDataPtr
    Else
        call TranslateDecimal
    End_If
ret


StoreDBcode:
L0: If B$esi = TextSign
      ; Cases of Text:
        inc esi | While B$esi <> TextSign | movsb | End_While | inc esi
        On B$esi > Space, error D$MissingSeparatorPtr
    Else
      ; Cases of Numbers:
        call GetFlatInteger | On eax > 0FF, error D$OverBytePtr
        stosb
    End_If

    On B$esi+2 = memMarker, ret

    If B$esi+3 = Space
        On B$esi+1 = 'D', ret
    End_If

    On B$esi-1 = Space, jmp L0<
ret


StoreDWcode:
L0: call GetFlatInteger | On eax > 0FFFF, error D$OverWordPtr
    stosw | cmp B$esi-1 Space | je L0<
ret


StoreDUcode:
    .If B$esi = TextSign
        inc esi
        While B$esi <> TextSign
            movsb | mov B$edi 0 | inc edi
        End_While
        inc esi
        On B$esi > Space, error D$MissingSeparator
        On B$esi+2 = memMarker, ret
        If B$esi+3 = Space
            On B$esi+1 = 'D', ret
        End_If
    .End_If

    call GetFlatInteger | On eax > 0FFFF, error D$OverWordPtr

    stosw | cmp B$esi-1 Space | je L0<
ret


StoreDDcode:
L0: call GetFlatInteger | On edx > 0, error D$OverDWordPtr
    stosd | cmp B$esi-1 Space | je L0<
ret


StoreDQcode:
L0: call GetFlatInteger
    stosd | mov D$edi edx | add edi 4 | cmp B$esi-1 Space | je L0<
ret


StoreDFcode:

ret


StoreDRcode:

ret


StoreDTcode:

ret


StoreDXcode:

ret

____________________________________________________________________________________________

[InstructionsCounter: ?]

EncodeLines:
    mov B$ErrorLevel 0, D$CodeLabelsCounter 0
ReCodeLine:
    mov esi D$CodeSourceB
    mov D$StatementsCounter 1, D$InstructionsCounter 0

    move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4
L0: lodsb | cmp al 0 | je L0<
    On B$esi <= EOI,  ret                           ; search for end mark '||'

    mov D$LineStart esi

    If al = EOI
        inc D$StatementsCounter | add D$StatementsPtr 4
        mov edi D$IpTablePtr, eax D$CodeListPtr
        sub eax D$CodeOrigine                       ; instruction pointers
        stosd | mov D$IpTablePtr edi                ; List for Debug
    End_If

    call ClearParameters | call SearchLineLabel
      cmp B$esi EOI | jbe L0<                       ; case of Label alone
        inc D$InstructionsCounter

   ; call SearchApiCall | cmp B$esi EOI | jbe L0<
   ; Now done by 'NewSearchApiName' (when computing 'Integers')

    call StoreSOP | call Prefix     ; Is There SOP (Segment Prefix Ovewrite) or prefixes?
                                    ; if yes, coding and striping done by called routines
    cmp B$esi EOI | jbe L0<         ; case of prefix alone


    .If B$esi+1 = memMarker
         mov al B$esi | add esi 2 | call StoreFlatData | jmp L0<<
    .Else_If B$esi+2 = Space
        If B$esi = 'D'
            mov al B$esi+1 | add esi 3 | call StoreFlatData | jmp L0<<
        End_If
    .End_If


L3: call ParametersCount            ; > cl = ParametersNumber

    mov B$LongRelative &TRUE        ; will be turn FALSE when needed for short dis.

    cmp cl 0 | je L3>> ; !!!!!!!!!!!!!!! >>
    If cl = 1
      call FirstParameterAnalyze
      mov al B$FirstOperandwbit | call StoreWbit
    Else_If cl = 2
      call FirstParameterAnalyze | call SecondParameterAnalyze
      call FixInstructionType
    Else_If cl = 3                                            ; (SHLD / SHRD > 3 parameters)
      call FirstParameterAnalyze | call SecondParameterAnalyze
      call ThirdParameterAnalyze | call FixInstructionType
    Else
      mov B$errorLevel 0 | error D$TooMuchPtr
    End_If

    On B$LockInstruction = &TRUE, call CheckLockMem

L3: call Encode | mov D$CodeListPtr edi

    On B$SIBinside = &TRUE,  call storeSIB
    cmp B$DisInside &TRUE | jne L4>
        call StoreDis | jmp L5>                    ; cases of label / displacement

L4: cmp B$DummyDis &TRUE | jne L5>

        mov eax 0 | mov edi D$CodeListPtr | stosd
        add D$CodeListPtr 4

L5: On B$immInside = &TRUE,  call storeImm

    On B$PossibleFirstImmLabel = &TRUE, call FirstParameterLabel
        On B$PossibleImmLabel = &TRUE, call SecondParameterLabel

    If B$mm3Dsuffix <> 0
        mov al B$mm3Dsuffix, B$mm3Dsuffix 0
        mov edi D$CodeListPtr | stosb
        inc D$CodeListPtr
    End_If

L6: call PointNextInstruction       ; Includes a developper Message in case of error
                                    ; cases / searches become a problem.
    jmp L0<<

____________________________________________________________________________________________
____________________________________________________________________________________________

; reading and writing chars.
____________________________________________________________________________________________

Store8cars:
    mov op5 B$esi+4, op6 B$esi+5, op7 B$esi+6, op8 B$esi+7
Store4cars:
    mov op1 B$esi, op2 B$esi+1, op3 B$esi+2, op4 B$esi+3
ret


[IfNot | cmp #1, #2 | jne #3]
 ________________________________________________________________________________________

; Called when cc conditions needed (Jcc, MOVcc, ...). esi set by caller:

[tttnBits: B$ ?]

SearchFortttnbits:
     On W$esi = 'NN', add esi 2      ; accept double negation ('jnna' = 'ja')
     call Store4Cars
     ifnot op2 Space, L2>>
       ifnot op1 'E', L1>
         mov B$tttnBits 00100 | ret        ; e
L1:    ifnot op1 'Z',  L1>
         mov B$tttnBits 00100 | ret        ; z
L1:    ifnot op1 'A', L1>
         mov B$tttnBits 00111 | ret        ; a
L1:    ifnot op1 'G', L1>
         mov B$tttnBits 001111 | ret       ; g
L1:    ifnot op1 'B', L1>
         mov B$tttnBits 0010 | ret         ; b
L1:    ifnot op1 'C', L1>
         mov B$tttnBits 0010 | ret         ; c
L1:    ifnot op1 'L', L1>
         mov B$tttnBits 001100 | ret       ; l
L1:    ifnot op1 'O', L1>
         mov B$tttnBits 0000 | ret         ; o
L1:    ifnot op1 'S', L1>
         mov B$tttnBits 001000 | ret       ; s
L1:    ifnot op1 'P', L1>
         mov B$tttnBits 001010 | ret       ; p
L1:    BadMnemonic

L2:  ifnot op3 Space, L3>>
       ifnot op1 'N', L1>
         ifnot op2 'E', L2>
           mov B$tttnBits 00101 | ret    ; ne
L2:      ifnot op2 'Z', L2>
           mov B$tttnBits 00101 | ret    ; nz
L2:      ifnot op2 'O', L2>
           mov B$tttnBits 0001 | ret     ; no
L2:      ifnot op2 'B', L2>
           mov B$tttnBits 0011 | ret     ; nb
L2:      ifnot op2 'C', L2>
           mov B$tttnBits 0011 | ret     ; nc
L2:      ifnot op2 'L', L2>
           mov B$tttnBits 001101 | ret   ; nl
L2:      ifnot op2 'A', L2>
           mov B$tttnBits 00110 | ret    ; na
L2:      ifnot op2 'G', L2>
           mov B$tttnBits 001110 | ret   ; ng
L2:      ifnot op2 'P', L2>
           mov B$tttnBits 001011 | ret   ; np
L2:      ifnot op2 'S', L2>
           mov B$tttnBits 001001 | ret   ; ns
L2:      BadMnemonic
L1:    ifnot op2 'E', L2>
         ifnot op1 'A', L1>
           mov B$tttnBits 0011 | ret     ; ae
L1:      ifnot op1 'B', L1>
           mov B$tttnBits 00110 | ret    ; be
L1:      ifnot op1 'P', L1>
           mov B$tttnBits 001010 | ret   ; pe
L1:      ifnot op1 'G', L1>
           mov B$tttnBits 001101 | ret   ; ge
L1:      ifnot op1 'L', L1>
           mov B$tttnBits 001110 | ret   ; le
L1:       BadMnemonic
L2:      ifnot op1 'P', L1>
           ifnot op2 'O', L2>
             mov B$tttnBits 001011 | ret  ; po
L2:       ; BadMnemonic
L1:      BadMnemonic

L3:   ifnot op1 'N', L9>
        ifnot op3 'E', L9>
          ifnot op4 Space, L9>
            ifnot op2 'G', L2>
              mov B$tttnBits 001100 | ret  ; nge
L2:         ifnot op2 'B', L2>
              mov B$tttnBits 00111 | ret   ; nbe
L2:         ifnot op2 'A', L2>
              mov B$tttnBits 0010 | ret    ; nae
L2:         ifnot op2 'L', L2>
              mov B$tttnBits 001111 | ret  ; nle
L2:
L9: BadMnemonic
 _______________________________________________________________________________________
;;
 search for prefix(es)
 Only one prefix of each group should be allowed > test addition needed
 (to do later if wanted)

 Segment Override Prefix  (SOP)
 When a xS: encounted, the code value is stored and xS: is stripped by ClearSOP
 esi > CodeSourceB  edi > CodeList by CodeListPtr
;;
 _______________________________________________________________________________________

WriteSOP:
    sub esi 3 | lodsb | mov ah al | lodsb | On al <> 'S', Error D$NotSegmentPtr

    ifnot op1 'C',  L1>
        mov al 02E | jmp L9>
L1: ifnot op1 'S', L1>
        mov al 036 | jmp L9>
L1: ifnot op1 'D', L1>
        mov al 03E | jmp L9>
L1: ifnot op1 'E', L1>
        mov al 026 | jmp L9>
L1: ifnot op1 'F', L1>
        mov al 064 | jmp L9>
L1: On op1 <> 'G', error D$NotSegmentPtr
        mov al 065
L9: mov edi D$CodeListPtr | stosb | inc D$CodeListPtr
ret
 __________________________________________________________________________________________
;;
 exemple of ClearSOP job: when called, esi point to  ':'

                  |MOV CS:D$EBX 1|
          new esi>>>>>^  ^<<<<<<< old esi > new edi


 after std, lodsb and stosb esi (new line start) point to the first letter of mnemonic:

                  |MOVMOV D$EBX 1|
                      ^<<<<< edi > last new esi  >>> last new LineStart
;;
 __________________________________________________________________________________________

ClearSOP:                   ; esi > ':' sign  >>>  '.xS:'  (this point is a space)
    push edi
        mov edi esi | sub esi 3
        std
L0:         lodsb | cmp al EOI | jbe L9>
                    cmp al colonSign | je L9> ; To hold Lines with 'head Labels'.
            stosb | jmp L0<
L9:     cld
        mov esi edi | inc esi       ; esi > new start of instruction
        mov D$LineStart esi
    pop edi
ret

StoreSOP:
    push esi
L0:     lodsb | cmp al EOI | jbe L9>
        cmp al ColonSign | jne L0<  ; no possible confusion:
            call WriteSOP           ; labels have been treated before
            call ClearSOP
        pop eax                     ; scratch old esi
        push esi                    ; (re)save new esi
L9: pop esi
ret

 _______________________________________________________________________________________
 _______________________________________________________________________________________

Prefix:
    mov edi D$CodeListPtr,  esi D$LineStart
L0: call Store8cars
    ifnot op1 'R', L6>
      ifnot op2 'E', L9>>
        ifnot op3 'P', L9>>
          cmp op4 Separators | ja L2>                                   ; REP
            mov B$edi 0F3 | add esi 4 | inc edi | jmp L0<
L2:       cmp op5 Separators | ja L4>
            cmp op4 'E' | je L3>
            ifnot op4 'Z', L9>
L3:           mov B$edi 0F3 | add esi 5 | inc edi | jmp L0<             ; REPE/REPZ
L4:       ifnot op4 'N', L9>
            cmp op6 Separators | ja L9>
              cmp op5 'E' | je L5>
              ifnot op5 'Z', L9>
L5:             mov B$edi 0F2 | add esi 6 | inc edi | jmp L0<           ; REPNE/REPNZ
L6: ifnot op1 'U', L6>
      ifnot op2 'T', L9>
        ifnot op3 'J', L9>
            mov B$esi+3 '_' | jmp L9>
L6: ifnot op1 'L', L9>
      ifnot op2 'T', L6>
        ifnot op3 'J', L9>
            mov B$esi+3 '_' | jmp L9>
L6:   ifnot op2 'O', L9>
        ifnot op3 'C', L9>
          ifnot op4 'K' L9>
            cmp op5 Separators | ja L9>
              call CheckLockInstruction
              mov B$LockInstruction &TRUE
              mov B$edi 0F0 | add esi, 5 | inc edi | jmp L0<<            ; LOCK
L9: On esi = D$LineStart,  ret                                 ; nothing done > exit
      On B$esi-1 <= EOI,  dec esi
      mov D$LineStart esi,  D$CodeListPtr edi
ret


LockInstructionError: mov B$LockInstruction &FALSE | error D$LockErrorPtr


CheckLockMem:
    mov B$LockInstruction &FALSE

    If B$FirstGender <> mem
        On B$SecondGender <> mem, error D$LockMemErrorPtr
    End_If
ret

CheckLockInstruction:
;;
  Edi Points to the next Member of the Instruction.
  
  The Instruction can only be ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC,
  INC, NEG, NOT, OR, SBB, SUB, XADD, XCHG, or XOR
;;

  push esi
  add esi 5
  ; ADD, ADC, AND:
    ...If B$esi = 'A'
        .If B$esi+1 = 'D'
            If B$esi+2 = 'D'           ; ADD
                ;
            Else_If B$esi+2 = 'C'      ; ADC
                ;
            Else
                jmp LockInstructionError
            End_If

            On B$esi+3 <> Space, jmp LockInstructionError

        .Else_If B$esi+1 = 'N'
            If B$esi+2 = 'D'           ; AND
                On B$esi+3 <> Space, jmp LockInstructionError
            Else
                jmp LockInstructionError
            End_If

        .Else
            jmp LockInstructionError
        .End_If

  ; BTC, BTR, BTS:
    ...Else_If B$esi = 'B'
        .If B$esi+1 = 'T'
            If B$esi+2 = 'C'
                On B$esi+3 <> Space, jmp LockInstructionError
            Else_If B$esi+2 = 'R'
                On B$esi+3 <> Space, jmp LockInstructionError
            Else_If B$esi+2 = 'S'
                On B$esi+3 <> Space, jmp LockInstructionError
            Else
                jmp LockInstructionError
            End_If

        .Else
            jmp LockInstructionError

        .End_If

  ; DEC
    ...Else_If W$esi = 'DE'
        If B$esi+2 = 'C'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If

  ; INC, NEG, NOT, OR, SBB
    ...Else_If W$esi = 'IN'
        If B$esi+2 = 'C'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If

    ...Else_If W$esi = 'NE'
        If B$esi+2 = 'G'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If

    ...Else_If W$esi = 'NO'
        If B$esi+2 = 'T'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If

    ...Else_If W$esi = 'OR'
        On B$esi+3 <> Space, jmp LockInstructionError

    ...Else_If W$esi = 'SB'
        If B$esi+2 = 'B'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If
  ; SUB, XADD, XCHG, or XOR
    ...Else_If W$esi = 'SU'
        If B$esi+2 = 'B'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If

    ...Else_If D$esi = 'XADD'
        On B$esi+4 <> Space, jmp LockInstructionError

    ...Else_If D$esi = 'XCHG'
        On B$esi+4 <> Space, jmp LockInstructionError

    ...Else_If W$esi = 'XO'
        If B$esi+2 = 'R'
            On B$esi+3 <> Space, jmp LockInstructionError
        Else
            jmp LockInstructionError
        End_If

  ; CMPXCHG, CMPXCHG8B:
    ...Else_If D$esi = 'CMPX'
        ..If W$esi+4 = 'CH'
            .If B$esi+6 = 'G'
                If B$esi+7 = Space
                    ;
                Else_If W$esi+7 = '8B'
                    On B$esi+9 <> Space, jmp LockInstructionError
                Else
                    jmp LockInstructionError
                End_If
            .Else
                jmp LockInstructionError
            .End_If
        ..Else
            jmp LockInstructionError
        ..End_If

    ...Else
        jmp LockInstructionError

    ...End_If

    pop esi
ret

 _________________________________________________________________________________________
 _________________________________________________________________________________________
;;
 When all encoding job is done, we now fill label evocation in code with label adresses
 stored in LabelList. We creat a .reloc section if wanted (DLLs).
;;

[RelocPage: ?    RelocSectionSize: ?    FileAlignedRelocationSize: ?]
[StartOfCodeSection: 01000  StartOfDataSection: 02000] ; redefined any case after encoding

[LastUpSearchLabel: ?]

SearchLocalLabelUp:                     ; EDI >>> LabelList+3 / EDX >>> end of LabelList
L0: push esi, ecx, ebx                  ; this ESI points to CodeRef <<<<<< ESI >>>>>>
L1:   lodsb                             ; jmp over name in Coderef
      cmp al EOI | ja L1<
        lodsb                           ; strip one '|' ('L1<|..' turn previously 'L1||..')
        On B$LongRelative = &TRUE, lodsb ; idem for long > 'L1>>|'  > 'L1|||'
        lodsd                           ; local label evocation offset in EAX
        and eax 07FFFFFFF   ; 0111111111111111B strip relative flag from offset (if any)
        mov ecx eax
        lodsd | mov D$StatementsCounter eax
        mov esi edi         ; switch ESI to LabelList    <<<<<< ESI >>>>>>
        On D$LastUpSearchLabel > 0, mov esi D$LastUpSearchLabel
; ESI > start of first name in LabelList. We now search in LabelList a fitting adress
; by comparison with evocation offset stored in ECX: search for a neighbour label
; located after evocation and set EDI to previous one's end

L2:   mov ebx esi                       ; save start of LabelList name
L3:   lodsb                             ; jmp over name in LabelList
        cmp esi edx | jae L5>           ; reach end of LabelList? (EDX = Max)
        cmp al EOI | ja L3<
        lodsd                           ; read an offset in LabelList
        test B$esi CodeLabelFlag | je L4>
        cmp eax ecx | ja L5>            ; is it about the same offset than the Coderef one?
L4:     lodsb                           ; jump over flag byte
        lodsb                           ; jmp over '|'
      jmp L2<
                                        ;          |PREVIOUSNAME|Dword byte|NAME|
                                        ;                      ^ <<<<<<<<  ^
L5: sub ebx 8 | mov edi ebx             ; set EDI > end of previous LabelList name
    mov D$LastUpSearchLabel ebx         ; This Value saves a lot of Search tim!!!
    pop ebx, ecx, esi                   ; ESI back to CodeRef     <<<<<<< SI >>>>>>
    inc esi                             ; For 'L1' label, ESI was at 'L'. Now, ready for
                                                                  ; backward search
    std                                 ; ready to check backward

    align 32

L6: push esi ecx
      repe cmpsb                 ;  cmp ESI (CodeRef) to EDI (LabelList) until different
      je L9>                            ;  > found
      cmp B$edi+1 EOI | jbe L7>         ; case of LabelList name shorter than CodeRef's one
      mov ecx 0FF,  al EOI | repne scasb  ; longer: LabelList Di ptr > after next '|'
L7:   sub edi 6                           ;          |PREVIOUSNAME|Dword byte|NAME|
                                          ;                      ^ <<<<<<< ^
    pop ecx, esi
    On edi <= D$LabelList, error D$UnknownSymbolPtr esi      ; (we are searching upward)
    jmp L6<

L9: cld                                  ; ESI, EDI > start of identical found label name
    pop ecx esi                          ; ESI > end of name
    On B$LongRelative = &TRUE,  inc esi   ; strip additionnal '|' (old '<')
    add esi 3                            ; ESI > Dword offset of code evocation
    add edi 5                            ; EDI > Dword offset of code or data label
ret


[LastDownSearchLabel: ?]

SearchLocalLabelDown:
L0: push esi, ecx, ebx
L1:   lodsb                             ; jmp over name in Coderef
        cmp al EOI | jne L1<
        lodsb                           ; stip one '|' ('L1>|..' turn previously 'L1||..')
        On B$LongRelative = &TRUE,  lodsb
        lodsd                           ; local label evocation offset in eax
        test eax RelativeFlag | jz L2>
          and eax 00_01111111_11111111_11111111_11111111   ;07FFFFFFF   ; strip flag
L2:   mov ecx eax
      lodsd | mov D$StatementsCounter eax | mov esi edi
      On D$LastDownSearchLabel > 0, mov esi D$LastDownSearchLabel
L3:   mov ebx esi                       ; save start of LabelList name
L4:   lodsb                             ; jmp over name in LabelList
        cmp esi edx | jae L7>           ; reach end of LabelList? (EDX = Max)
        cmp al EOI | ja L4<
        lodsd
        test B$esi CodeLabelFlag | je L5>
          cmp eax ecx | jae L6>         ; is it about the same offset?
L5:     lodsb                           ; jump over flag byte
        lodsb                           ; jmp over '|'
      jmp L3<
L6: mov edi ebx                         ; restore start of LabelList name in DI
    mov D$LastDownSearchLabel ebx       ; This Value saves lot of search time!!!
    pop ebx ecx esi           ; edi > First label name's letter with possible adress
    call SearchRegularLabel
    inc esi                             ; strip '>' for short jump
    On B$LongRelative = &TRUE,  inc esi  ; strip next '>' if long jump
ret

L7: pop ebx ecx esi
    error D$UnknownSymbolPtr esi


; when called, ESI > start of a label name in CodeRef, ECX lenght of this name
; EDI set to >  LabelList + 5  by FillCodeSymbols (start of first label name in LabelList)

SearchRegularLabel:
    mov al EOI
L0: push esi ecx
        repe cmpsb              ;  cmp esi (CodeRef/DataRef) to edi (LabelList) until different
        je L8>                  ;  > found
            cmp B$edi-1 al | jbe L3>      ; case of LabelList name shorter than CodeRef's one
            mov ecx 0FF | repne scasb     ; longer: LabelList edi ptr > after next '|'
L3:         add edi 6                                 ; |LABELNAME|dword FlagByte|NEXTNAME
                                                    ;        EDI ^ >>>>>>>>     ^
            If edi >= edx                       ; edx = LabelList Max.
                pop ecx, esi
                error D$UnknownSymbolPtr esi
            end_if
    pop ecx, esi | jmp L0<

L8: cmp B$Relative &TRUE | je L9>           ; if comming from 'SearchLocalLabeldown', OK
      test D$esi RelativeFlag | jz L9>           ; if not, possible relative:
        mov D$Relative &TRUE,  B$LongRelative &TRUE     ; this is for 'JMP label'
L9: pop eax eax             ; if here, found: dummy stack restore. edi > code adress dWord
    ret


SearchSortedRegularLabel:
;;
    dec ecx
    If D$LabelsPointersBySizes+ecx*4 <> 0
        mov edi D$LabelsPointersBySizes+ecx*4
    Else
        error UnknownSymbol esi
    End_If
    inc ecx | mov al EOI
    

L0: push esi ecx
        repe cmpsb              ;  cmp esi (CodeRef/DataRef) to edi (LabelList) until different
        je L8>                  ;  > found
            cmp B$edi-1 al | jbe L3>      ; case of LabelList name shorter than CodeRef's one
            mov ecx 0FF | repne scasb     ; longer: LabelList edi ptr > after next '|'
L3:         add edi 6                             ; |LABELNAME|dword FlagByte|NEXTNAME
                                                  ;        EDI ^ >>>>>>>>     ^
            If edi >= edx                       ; edx = LabelList Max.
                pop ecx, esi
                error UnknownSymbol esi
            End_if
    pop ecx, esi | jmp L0<
;;

L8: call GetFromQwordCheckSum esi, D$LabelList, D$LabelListLimit

    If eax = 0
        push D$esi
            pushad
                call IsItAreg | On eax <> 0, error D$UnexpectedRegPtr, esi
            popad
        pop D$esi
        error D$UnknownSymbolPtr, esi
    Else
        While B$eax > LowSigns | inc eax | inc esi | End_While | inc eax | inc esi
        mov edi eax, ecx 0
    End_If

L8: cmp B$Relative &TRUE | je L9>           ; if comming from 'SearchLocalLabeldown', OK
        test D$esi RelativeFlag | jz L9>           ; if not, possible relative:
            mov D$Relative &TRUE,  B$LongRelative &TRUE     ; this is for 'JMP label'

L9: ret


; construction of relocation table. called by FillDataSymbols routine when an uncomputed
; adress is found. EDI > code offset of an evocation.

[CodeOrData: ?]

StoreApiReloc: ; NewSearchApiName PreparePeHeader
  ; eat 0FF found at esi, by 'FillCodeSymbols'
    inc esi | mov edi D$esi | add esi 5

StoreReloc: ; 'RelocComments'
    push eax, ebx, ecx, edi

      mov eax edi
      sub eax D$CodeOrData | and eax PageMask ;| add eax PageSize
     ; cmp eax D$RelocPage | je L3>
      cmp eax 01000 | jb L3>
     ; if in the same page of code, just write (>L3). if not:
     ; writing of reloc page header. Each section begins by a header of two Dwords.
     ; first one is the virtual adress; exemple, 01000 if begins at 00401000.
     ; second one is the total number of octets of the section.
      add D$CodeOrData 01000
      push eax, edi
        mov eax 0 | mov edi D$RelocationPtr
L1:     test D$RelocationPtr 0011 | jz L2>                   ; align on Dword boudary
          stosw                                              ; fill with zeros
          add D$RelocationPtr 2 | add D$RelocSectionSize 2

L2:     mov ebx D$RelocationPtr | sub ebx D$RelocSectionSize | add ebx 4
        mov eax D$RelocSectionSize | mov D$ebx eax     ; set second dWord to section size

        add D$RelocPage PageSize | mov eax D$RelocPage | stosd
        add edi 4 | mov D$RelocationPtr edi | mov D$RelocSectionSize 8
      pop edi, eax

L3:   mov eax edi | sub eax D$CodeOrData | and eax 0FFF| add eax 03000  ; 03000, RelocTypeFlag
      mov edi D$RelocationPtr | stosw

      add D$RelocSectionSize 2 | mov D$RelocationPtr edi
    pop edi, ecx, ebx, eax
ret
 ________________________________________________________________________________________
;;
 Filling code label evocations (set to zeros at coding time, fill when coding is over)

 > esi points to label name in CodeRef (fix)
 > edi points to label name in LabelList (moveable)
 ecx = lenght of researched name (count from CodeRef)

 True labels adresses writing in generated code. See full comments down there
 about the tables used in this deal
 esi > CodeRef  ebx = CodeRef End     edi > LabelList  edx = LabelList End
 The job is difficult enough: it may be about:
 uncomputed code or data references,
 computed (+/-) jumps or calls either short (one byte) or long (four bytes)
 Values are turned RVA with 'CodeAjust' an 'DataAjust' set by 'InitRelocation'
;;
 ________________________________________________________________________________________

[BadShortDisplacement: 0 #4]

ErrorShortDisUp:
    neg eax | sub eax 127
    If eax > 1
        mov ebx {'Bytes Up', 0}
    Else
        mov ebx {'Byte Up', 0}
    End_If

    jmp L1>

ErrorShortDisDown:
    sub eax 080
    If eax > 1
        mov ebx {'Bytes Down', 0}
    Else
        mov ebx {'Byte Down', 0}
    End_If

L1: ;error D$ShortDisPtr

    CustomError D$ShortDisPtr, '#1', 'Int', eax,
                               '#2', 'Str', ebx

    mov B$ErrorLevel 2 | error TrashString

    ;mov ebx eax | mov B$ErrorLevel 12 | error D$ShortDisPtr

[ApplyShortenJump: ?]

FillCodeSymbols:
    mov eax D$CodeRef | add eax 5
    On D$CodeRefPtr = eax,  ret                 ; if no symbol at all (???!!!)
    mov edx D$LabelList | mov esi edx | lodsd   ; len of LabelList (-1) > EAX > EDX
    add edx eax | dec edx                       ; last octet of LabelList table (edx=edi max)
    mov ebx D$CodeRef | mov esi ebx | lodsd     ; len of CodeRef (-1) > EAX > EBX
    add ebx eax | dec ebx                       ; last octet of CodeRef table (ebx=esi max)
    mov esi D$CodeRef | add esi 5               ; (+5) > jmp over len and '|'

L0: mov edi D$LabelList | add edi 5

    mov B$ApplyShortenJump &FALSE
;;
 For Api calls relocations, the 'EncodeLines' does it directely (> 'NewSearchApiName'): 
 The 'CodeRef' Record for such cases is simply:
 |0FF dWordCodeAddress|. This is done by 'NewSearchApiName' only in case of:
 > If D$SavingExtension = '.DLL'
 Again, The record is irregular: 0FF, 1 dWord, EOI, as there is nothing else to be done
 with this, out of the DLL relocations building:
;;
    If B$esi = 0FF
        call StoreApiReloc | cmp esi ebx | jb L0<
        ret
    End_If

    push esi
      mov ecx 0
L1:   lodsb
        inc ecx                                 ; simple lenght counter of Code symbolics'
        cmp al EOI | ja L1<                     ; lenghts, in CodeRef, including separator
        lodsd | lodsd | mov D$StatementsCounter eax
    pop esi                       ; when encoding 'Relative' is either 0 or high bit flag
    mov D$Relative &FALSE                        ; now on, either true or false
      mov ah B$esi,  al B$esi+1
      cmp ah 'A' | jb S9>>
        cmp ah 'Z' | ja S9>>
          cmp al '0' | jb S9>>
            cmp al '9' | ja S9>>                 ; is it a local label evocation?

            .If B$esi+2 = '>'
                mov D$Relative &TRUE
                If B$esi+3 = '>'
                    mov B$LongRelative &TRUE
                Else_If B$esi+3 = '.'
                    mov B$LongRelative &TRUE | mov B$esi+3 '>'
                    mov B$ApplyShortenJump &TRUE
                Else_If B$esi+3 < Separators
                    mov B$LongRelative &FALSE
                Else
                    Error D$WhatIsThisPtr
                End_If

                mov B$esi+2 EOI | mov ecx 3 | call SearchLocalLabelDown

            .Else_If B$esi+2 = '<'
                mov D$Relative &TRUE
                If B$esi+3 = '<'
                    mov B$LongRelative &TRUE
                Else_If B$esi+3 = '.'
                    mov B$LongRelative &TRUE | mov B$esi+3 '<'
                    mov B$ApplyShortenJump &TRUE
                Else_If B$esi+3 < Separators
                    mov B$LongRelative &FALSE
                Else
                    Error D$WhatIsThisPtr
                End_If

                mov B$esi+2 EOI | mov ecx 3 | call SearchLocalLabelUp

            .Else
S9:             push edx
                    call SearchSortedRegularLabel
                pop edx

            .End_If
;;
  got here after label search up, down or regular (and found)
  edi points to a LabelList'symbol adress (code or data true adress of label)
  esi points to a Coderef evocation adress (code ... adress needing 'fill job')
  'add esi 9', 4 lines down here set this ptr on Coderef next label name (2 dWords + EOI)
;;
    mov eax D$edi                              ; true label adress in eax (EDI > LabelList)

    On B$ApplyShortenJump = &TRUE, mov B$LongRelative &FALSE

  ; write 'done' on LabelList flag byte:
    mov cl B$edi+4 | or B$edi+4 DoneFlag
    mov edi D$esi | add esi 9
  ; ESI > CodeRef offset of evocation > EDI

    ...If D$Relative = &TRUE
      ; no flag > uncomputed label adress: Strip flag (computed signed displacement);
        and edi 07FFFFFFF | sub eax edi
      ; no signed displacement?
        .If B$LongRelative = &FALSE
            test eax dWordHighBit | jz L6>
          ; -127 (0FFFF_FF80 = -128) ; short negative value:
          ; -128 (-1) (limit for signed negative byte)
            On eax < 0FFFF_FF81,  jmp ErrorShortDisUp
                jmp L7>

L6:         On eax > 080, jmp ErrorShortDisDown    ; short positive value > 07F + 1
                                                    ; +127 (limit for signed positive byte)
L7:         sub eax 1 | add B$edi al | cmp esi ebx | jb L0<<     ; store on one byte
            ret

        .Else
            On B$ProfilerFlag = &TRUE, call TimingCalls

L8:         sub eax 4 | add D$edi eax | cmp esi ebx | jb L0<<       ; store on 4 bytes
            ret      ; why ADD and not MOV: exemple: 'ADC ebx MyLabel+2' > '2' previously stored
                ; 'sub ax, 4'  is to jump over storage bytes (L7: idem for one byte storage)
        .End_If
    ...End_If

L9: If D$SavingExtension = '.DLL'
        call StoreReloc
    Else_If D$SavingExtension = '.SYS'
        call StoreReloc
    End_If

    If cl < CodeLabelFlag
        add eax D$DataAjust         ; 2 >>> data / 3 >>> data+done
    Else
        add eax D$CodeAjust         ; 4 >>> code / 5 >>> code+done
    End_If

    add D$edi eax                                   ; store on 4 bytes (uncomputed)
    cmp esi ebx | jb L0<<
ret

 ________________________________________________________________________________________
;
; Filling empty rooms left in Data section (same comments as upper ones)
 ________________________________________________________________________________________

FillDataSymbols:
    mov eax D$DataRef | add eax 5
    On D$DataRefPtr = eax,  ret                 ; if no symbol at all
   ; mov edx D$PlainLabelList | mov esi edx | lodsd   ; len of LabelList (-1) > EAX > EDX

   ; add edx eax | dec edx                       ; last octet of LabelList table (edx=edi max)
    mov ebx D$DataRef | mov esi ebx | lodsd     ; len of DataRef (-1) > EAX > EBX
    add ebx eax | dec ebx                       ; last octet of DataRef table (ebx=esi max)
    mov esi D$DataRef | add esi 5               ; (+5) > jmp over len and '|'

L0: ;mov edi D$PlainLabelList | add edi 5
    push esi
        mov ecx 0
L1:     lodsb
            inc ecx                                 ; simple lenght counter of Code symbolics'
            cmp al EOI | ja L1<                     ; lenghts, in DataRef, including separator
            lodsd | mov D$DataFillPtr eax           ; doublon de DataListPtr
            lodsd | mov D$bracketCounter eax
            lodsb | mov B$DataSign al
            lodsb | mov D$DataRefPtr esi            ; strip lasting EOI
    pop esi

    call SearchSortedRegularLabel | mov eax D$edi | mov cl B$edi+4

    cmp cl CodeLabelFlag | jb D1>               ; 'jb' because:
        add eax D$CodeAjust | jmp D2>                 ; 2 > data / 3 > data+done
D1:     add eax D$DataAjust                           ; 4 > code / 5 > code+done
D2:     or B$edi+4 DoneFlag

D2: On B$DataSign = &TRUE, neg eax | mov edi D$DataFillPtr | add D$edi eax

    If D$SavingExtension = '.DLL'
        call StoreReloc
    Else_If D$SavingExtension = '.SYS'
        call StoreReloc
    End_If

    mov esi D$DataRefPtr | cmp esi ebx | jb L0<<
  ret


[DataFillPtr: ?  DataAjust: ?  CodeAjust: ?]

Proc SetCodeAdjust:
    Argument @Base

        mov eax D@Base | add eax D$uBaseOfData | sub eax D$Datalist
        mov D$DataAjust eax
        mov eax D@Base | add eax D$uBaseOfCode | sub eax D$Codelist
        sub eax D$uStartOfCode | mov D$CodeAjust eax
EndP

InitRelocationForData:
    push edi eax

        If D$SavingExtension = '.SYS'
            call SetCodeAdjust DRIVERDEFAULT
        Else_If D$SavingExtension = '.DLL'
            call SetCodeAdjust D$LinkerDllDefault
        Else
            call SetCodeAdjust LINKERDEFAULT
        End_If

        mov edi D$RelocationPtr

        mov eax D$uBaseOfImport | add eax D$ImportTrueSize | Align_On 01000 eax

        If B$NoResources = &FALSE
            add eax D$uRsrcSize | Align_On 01000 eax
        End_If

        mov D$RelocPage eax | stosd

        mov eax 0 | stosd
        mov D$RelocationPtr edi | mov D$RelocSectionSize 8

    pop eax edi
ret


InitRelocationForCode:
    push edi eax
        mov edi D$RelocationPtr

        mov eax D$uBaseOfImport | add eax D$ImportTrueSize | Align_On 01000 eax

        If B$NoResources = &FALSE
            add eax D$uRsrcSize | Align_On 01000 eax
        End_If

        ;add eax D$uDataSize | Align_On 01000 eax
        mov eax D$uBaseOfCode
        mov D$RelocPage eax | stosd

        mov eax 0 | stosd
        mov D$RelocationPtr edi | mov D$RelocSectionSize 8
    pop eax edi
ret


CloseRelocation:
    mov eax 0 | mov edi D$RelocationPtr

L1: test D$RelocationPtr 0011 | jz L2>              ; align on Dword boudary
        stosb                                       ; fill with zeros
        inc D$RelocationPtr | inc D$RelocSectionSize
        jmp L1<

L2: mov ebx D$RelocationPtr | sub ebx D$RelocSectionSize | add ebx, 4
    mov eax D$RelocSectionSize | mov D$ebx eax      ; set second dword to section size
ret

RelocComments:
;;
 Relocation Section looks like this, for example:

 D$ 02000  ; RVA (Liker Default is to be added to this by the Loader).
 D$ 034    ; Aligned number of Bytes in the coming Chunk (including upper 8 Bytes+Alignement)
 W$ 03004 03010 03058 ....
 ; the chunk is aligned on dWord with zero padding if needed.
 D$ 03000  ; Next chunk header
 ....

 Even the last Chunk must be aligned and the number of bytes in this last Chunk Header
 holds it too.
;;

[BigFirstTick: ?  BickTickCount: ?]

BuildRelocationAndFillSymbols:                      ; >>> StoreReloc <<<
    call InitRelocationForData
        mov B$ErrorLevel 3
        move D$CodeOrData D$DataList
        call BuildPlainLabelList

      ; Left for viewing the List of Labels, the Debugger, ...
       call SortPlainLabelList

       call FillDataSymbols

        call CloseRelocation
        If D$RelocSectionSize = 8                   ; Case of no relocation
            sub D$RelocationPtr 8                   ; wanted in Data
        End_If

    call InitRelocationForCode
        mov B$ErrorLevel 2
        mov D$LastDownSearchLabel 0, D$LastUpSearchLabel 0
        move D$CodeOrData D$DataList
        mov eax D$uDataSize | Align_On 0200 eax | add D$CodeOrData eax

        call FillCodeSymbols

        call CloseRelocation

  ; Reuse 'RelocSectionSize' to hold what it says, as a whole for headers values:
    mov eax D$RelocationPtr | sub eax D$Relocation | mov D$RelocSectionSize eax
    Align_On 0200 eax | mov D$FileAlignedRelocationSize eax
ret


SortPlainLabelList:
    mov eax D$PlainLabelList, eax D$eax

    push eax
        add eax 4
        VirtualAlloc SortTempoMemory eax
    pop ecx
    push ecx
        mov edi D$SortTempoMemory, esi D$PlainLabelList
        shr ecx 2 | inc ecx | rep movsd

        move D$SortSource D$SortTempoMemory | add D$SortSource 5
        move D$SortDestination D$PlainLabelList | add D$SortDestination 5

        mov D$SortStringNumber 0 | mov esi D$SortDestination

L0:     lodsb | cmp al EOI | jne L0<
        add esi 6
        inc D$SortStringNumber
        cmp esi D$EndOfPlainLabelList | jb L0<

    pop ecx

    call SortLabelStringsBySize

    VirtualFree D$SortTempoMemory
L9: ret


SortLabelStringsBySize:
    mov edi LabelsPointersBySizes, eax 0, ecx 100 | rep stosd

    mov edi D$SortDestination, edx 1

L0: mov esi D$SortSource, ecx D$SortStringNumber, B$SortBySizeOver &TRUE

; There is something wrong in this: If i state 'While B$esi <> EOI' instead of
; 'While B$esi > EOI', it doesn't work. It should, and there is no reason for what
; D$esi could be = 0 (this is to say after the end of the Table -i suppose...)...

L1:     lodsb
        .If al = 0FF        ; Done
            While B$esi > EOI | inc esi | End_While
            add esi 7

        .Else
            push ecx
                mov eax esi, ecx 1
                While B$eax > EOI | inc ecx | inc eax | End_While
                If ecx = edx
                    mov al B$esi-1, B$esi-1 0FF
                    On D$LabelsPointersBySizes+edx*4 = 0,
                        mov D$LabelsPointersBySizes+edx*4 edi
                    stosb
                    dec ecx | jecxz L2>
                        rep movsb
L2:                 movsb  ; |
                    movsd  ; Ptr
                    movsb  ; Flag
                    movsb  ; |

                Else
                    lea esi D$eax+7
                End_If

            pop ecx
            mov B$SortBySizeOver &FALSE
        .End_If
    loop L1<

    inc edx | cmp B$SortBySizeOver &FALSE | je L0<<
ret

;;
 When searching Labels for filling Data Sybols, we do not need Meaningless Local
 Labels. So, we can build a List without them to make FillDataSymbols faster (No
 use sorting the list, as all Label are supposed to be found. If not error later):
 The 'PlainLabelList' Table is: ...|Name|Ptr Flag|Name....
                                        ...... .  ..
                                        1 4   1  1
;;

[PlainLabelList: ?    EndOfPlainLabelList: ?]

BuildPlainLabelList:
    mov eax D$LabelList, eax D$eax | inc eax

    VirtualAlloc PlainLabelList eax

    mov edx D$LabelList | add edx D$edx
    mov edi D$PlainLabelList | add edi 5
    mov esi D$LabelList | add esi 5

    .While esi < edx
        cmp B$esi+2 EOI | jne L1>
            cmp B$esi 'A' | jb L1>
            cmp B$esi 'Z' | ja L1>
                cmp B$esi+1 '0' | jb L1>
                cmp B$esi+1 '9' | ja L1>
                    ; |L0|dWord Byte| >>> 9
                    add esi 9 | jmp L2>

L1:     While B$esi <> EOI
            movsb
        End_While
        movsb   ; |
        movsd   ; Ptr
        movsb   ; Flag
        movsb   ; |
L2: .End_While

    mov eax edi | mov D$EndOfPlainLabelList eax | sub eax D$PlainLabelList
    mov edi D$PlainLabelList | stosd | mov al EOI | stosb
ret

 _______________________________________________________________________________________


FixTableSizes:
    mov eax D$CodeListPtr | Align_on 0200 eax
    mov edi D$CodeList | sub eax edi | mov D$LenOfCode eax

    mov eax D$CodeRefPtr   | mov edi D$CodeRef  | sub eax edi  | stosd

    mov eax D$DataRefPtr   | mov edi D$DataRef  | sub eax edi  | stosd

   ; mov eax D$DataListPtr  | mov edi D$DataList  | sub eax edi | stosd ; no need ???...
    mov eax D$LabelListPtr | mov edi D$LabelList | sub eax edi | stosd

    mov eax D$StartOfCodeSection | add eax D$LenOfCode
    and eax 0FFFFFF00
    add eax 01000 | add eax 0400000
    mov D$StartOfDataSection eax
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  The Symbolic Names are encoded into a qWord CheckSum. Then, this qWord is encoded
  into one another Word CheckSum. Let's call them 'CheckSum64' and 'CheckSum16'.
  __________________
  A two Stages Table is declared to hold 010000h (for storing the distributions
  of the Records) plus 010000h Records (for storing the Linked Records in case
  of identical CheckSum16).
  
  The CheckSum16 is used as a Index to point to the Records of the first stage
  of the Table.
  
  _______________
  Each Record is: [CheckSum64, Pointer, LinkedPointer]

  * 'Pointer' points to a Name, in one of the Assembler internal Lists. It is
    nothing but the Pointer transmitted to the 'SetQwordCheckSum' Procedure,
    when called. We do not need to do do any Name String Copy, as it is already
    there, in the concerned List ('LabelList', 'MacroList', 'EquateList').
    
  * If the second half of the Records Table is empty, 'LinkedPointer' points to
    the top of this Second half Table. Otherwise, in case several 'CheckSum64'
    achieve into the same 'CheckSum16', 'LinkedPointer' points to the next same
    'CheckSum16' Record, in the second half of the Table... and so on...
    
  * The first half of the Table is filled 'randomaly-like' (depending on the
    CheckSum16 value. The second half of the Table is filled in order (Top-Down),
    each time a Record of the First Half Table is found to not be empty.
    
  _________
  Routines:
  
  * 'ClearQwordCheckSum' zeroes the Records Table and sets
    'PointerToCheckSumsLinkedRecords' to the Top of the second half Table.
  
  * 'SetQwordCheckSum' is called with a Parameter pointing to the first Char
    of a Name - in its family List - to be recorded. It also call for:
    
  * 'NoDuplication' to make sure of unique Symbolics Declarations.
  
  * 'GetFromQwordCheckSum' is called with a Parameter pointing to a Name to
     be checked. If found, the Procedure returns the Pointers that was used
     when calling 'SetQwordCheckSum', that are nothing but Pointers to the
     Lists ('MacroList', 'EquateList', 'LabelList'), that hold all infos the
     Assembler needs for doing its job. If not found, it returns zero to the
     caller.
     
  * 'TestRepartition', is just a Dev-test for viewing how all of this goes.
  
  ______________________________
  How the Records Table is used:
  
  When calling 'SetQwordCheckSum', the CheckSum64 is computed from the given
  Name. Then, the CheckSum16 is computed from the given CheckSum64.
  
  CheckSum16 is used as an Indice to the first half of the Records Table.
  For example, if CheckSum16 is 25, we point to the 25th Record, that is
  (CheckSumsRecords + (25*(8+4+4))).
  
  If this record is found empty, it is written: CheckSum64 / Pointer / Link
  
  As long as there is nothing in the second half of the Table, 'Link' points
  to the empty Record at (CheckSumsRecords + (010000h*16) ).
  
  If the first half Table is not found empty, the 'Link' Pointer is read,
  and we jump there,... and so on...
  
  The chances for having two different Symbols achieving into the same CheckSum64
  are, of course, of 1 on 01_0000_0000_0000_0000h, for the second Name, of 1 on
  01_0000_0000_0000_0000h, for the third name, and so on... So, in the very unlikely
  coming out cases when two different Names are computed into the same CheckSum64,
  the new record is linked downward, the same way the Duplications of the CheckSum16
  are Linked.
  
  The reverse case is also theorically possible: For example, you do _not_ implement,
  say, some 'GetPointer' Macro, and you use it in a Statement. It is theorically
  not impossible that some other _declared_ Macro achieves into the same CheckSum64
  as would your non existing 'GetPointer'. In such -very unlikely coming out cases-,
  the 'GetFromQwordCheckSum' would return a pointer, instead of zero. So, when a
  valid CheckSum64 is found, 'GetFromQwordCheckSum' also calls for 'CompareSymbols',
  to make it 100% secure.
;;
____________________________________________________________________________________________

; CheckSum64 / Pointer / Link

[CheckSumsRecords: ? ? ? ? #010000    CheckSumsLinkedRecords: ? ? ? ? #020000
 PointerToCheckSumsLinkedRecords: ?   CheckSumsEnd: ]

ClearQwordCheckSum:
    mov edi CheckSumsRecords, eax 0
    mov ecx CheckSumsEnd | sub ecx CheckSumsRecords | shr ecx 2
    rep stosd

    mov D$PointerToCheckSumsLinkedRecords CheckSumsLinkedRecords
ret

[CheckSumImage: ?]

SaveCheckSumTable:
    pushad
        mov ecx PointerToCheckSumsLinkedRecords | sub ecx CheckSumsRecords

        push ecx
            VirtualAlloc CheckSumImage, ecx
        pop ecx

        shr ecx 2

        mov esi CheckSumsRecords, edi D$CheckSumImage | rep movsd
    popad
ret

RestoreCheckSumTable:
    pushad
        mov ecx PointerToCheckSumsLinkedRecords | sub ecx CheckSumsRecords | shr ecx 2

        mov esi D$CheckSumImage, edi CheckSumsRecords | rep movsd

        VirtualFree D$CheckSumImage
    popad
ret

____________________________________________________________________________________________

CheckSum64:
  ; esi -> Name
    mov eax 0, ebx 0, ecx 0

    While B$esi > ' ' ;LowSigns
        rol eax 1 | lodsb | mul eax | xor ebx edx | inc ecx
    End_While
    add ebx ecx
    If eax = 0
        On ebx = 0, mov eax 1
    End_If
  ; ebx:eax = CheckSum64 // ecx = Length
ret


CheckSum16:
  ; ebx:eax = CheckSum64 (not modified here))
    mov ecx eax | xor ecx ebx | mov edx ecx
    rol edx 16 | xor cx dx
    and ecx 0FFFF | shl ecx 4
  ; ecx = CheckSum16, to be used as a Displacement to the matching Record
  ; (To 'CheckSumsRecords' first half part, 16 Bytes per Record)
ret
____________________________________________________________________________________________

Proc SetQwordCheckSum:
    Argument @Pointer

    pushad

        mov esi D@Pointer

        If B$esi < '0'
            ;
        Else_If B$esi <= '9'
            error D$NumerAsSymbolPtr, D@Pointer
        End_If

        call CheckSum64 | call NoDuplication D@Pointer | call CheckSum16

      ; The List Pointer is used to test empty Records (Lists Pointers can never be zero):
        .If D$CheckSumsRecords+ecx = 0
            On D$CheckSumsRecords+ecx+4 <> 0, jmp L1>
            mov D$CheckSumsRecords+ecx eax
            mov D$CheckSumsRecords+ecx+4 ebx
            move D$CheckSumsRecords+ecx+8 D@Pointer
          ; D$CheckSumsRecords+ecx+12 = 0
        .Else
L1:         If D$CheckSumsRecords+ecx+12 = 0
                move D$CheckSumsRecords+ecx+12 D$PointerToCheckSumsLinkedRecords
            Else
                mov edi D$CheckSumsRecords+ecx+12
                While D$edi+12 <> 0 | mov edi D$edi+12 | End_While
                move D$edi+12 D$PointerToCheckSumsLinkedRecords
            End_If

            mov edi D$PointerToCheckSumsLinkedRecords
            mov D$edi eax
            mov D$edi+4 ebx
            move D$edi+8 D@Pointer
            ;mov eax D$PointerToCheckSumsLinkedRecords | add eax 16
          ; D$edi+12 = 0
            ;mov D$PointerToCheckSumsLinkedRecords eax
            add D$PointerToCheckSumsLinkedRecords 16
        .End_If

    popad
EndP
____________________________________________________________________________________________

Proc GetFromQwordCheckSum:
    Argument @Pointer, @List, @Limit
    Uses esi, edi, ebx, ecx, edx

        mov esi D@Pointer

        call CheckSum64 | call CheckSum16

        lea esi D$CheckSumsRecords+ecx | mov ecx &TRUE

L0:     ..If D$esi = eax
            .If D$esi+4 = ebx
                mov eax D$esi+8
                mov ebx D@List | On eax < ebx, mov ecx &FALSE
                mov ebx D@Limit | On eax > ebx, mov ecx &FALSE

                On ecx = &TRUE, call CompareSymbols D@Pointer, eax

                If ecx = &FALSE
                    push esi
                        mov esi D@Pointer | call CheckSum64
                    pop esi

                    mov ecx &TRUE | jmp L2>
                End_If

            .Else
                jmp L2>

            .End_If

        ..Else
L2:
            ;inc D$EquatesPasses
            mov esi D$esi+12 | cmp esi 0 | je L3>

          ; If no List Pointer, this is the first empty Record in the Linked Record Table:
            mov ecx &TRUE | cmp D$esi+8 0 | ja L0<<

L3:         mov eax 0

        ..End_If
   ; hexprint D$EquatesPasses
EndP
____________________________________________________________________________________________



Proc NoDuplication:
    Argument @Pointer
    Uses eax, ebx, ecx

      ; ebx:eax = CheckSum64
        mov ecx eax | xor ecx ebx | mov edx ecx
        rol edx 16 | xor cx dx
        and ecx 0FFFF | shl ecx 4

        lea esi D$CheckSumsRecords+ecx

L0:     While D$esi+4 <> 0
            If D$esi = eax
                On D$esi+4 = ebx, call CompareSymbols D@Pointer, D$esi+8
                On ecx = &TRUE, error D$SymbolDupPtr
            End_If

            mov esi D$esi+12 | On esi = 0, ExitP

        End_While
EndP
____________________________________________________________________________________________

Proc CompareSymbols:
    Argument @Source, @Destination
    Uses eax, esi, edi

        mov esi D@Source, edi D@Destination

L0:     lodsb | cmp al LowSigns | jb L5>
        inc edi | cmp al B$edi-1 | je L0<

        mov ecx &FALSE | ExitP

L5:     If B$edi < LowSigns
            mov ecx &TRUE
        Else
            mov ecx &FALSE
        End_If
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  This test is for viewing the Records distribution, in the CheckSums Table.
  
  The first Pixels square shows the occupied Records in the first half Part of
  the Table (black Pixels). The occupied Records, in the second half of the
  Table are represented by red Pixels. They, of course, come in the form of
  a red _line_.
  
  The actual distribution seems to be pretty close to a good random one.
;;

[CheckSumsPixelsCount: ?     CheckSumsLinkedRecordsPixels: ?]
[SecondTable: ?]

TestRepartition:
    mov D$CheckSumsPixelsCount 0, D$CheckSumsLinkedRecordsPixels 0

    call 'User32.BeginPaint' D$EditWindowHandle, PAINTSTRUCT | mov D$hdc eax
    call 'User32.GetClientRect' D$EditWindowHandle, RECT

    mov esi CheckSumsRecords

L0: mov eax D$esi | or eax D$esi+4
    If eax <> 0
        mov eax esi | sub eax CheckSumsRecords | shr eax 4
        mov ebx eax | shr eax 8 | and ebx 0FF
        inc D$CheckSumsPixelsCount
        call 'GDI32.SetPixel' D$hdc, eax, ebx, 0
    End_If

    add esi 16 | cmp esi CheckSumsLinkedRecords | jb L0<

L0: mov eax D$esi | or eax D$esi+4
    If eax <> 0
        mov eax esi | sub eax CheckSumsLinkedRecords | shr eax 4
        mov ebx eax | shr eax 8 | and ebx 0FF | add eax 0100
        inc D$CheckSumsPixelsCount
        inc D$CheckSumsLinkedRecordsPixels
        call 'GDI32.SetPixel' D$hdc, ebx, eax, 0FF
    End_If

    add esi 16 | cmp esi PointerToCheckSumsLinkedRecords | jb L0<

    call 'USER32.ReleaseDC' D$EditWindowHandle, D$hdc
    call 'USER32.EndPaint' D$EditWindowHandle, PAINTSTRUCT

    If D$CheckSumsPixelsCount > 0
       call WaitForUserAction

      ; Comment out to have the total number of Pixel and how many Linked Records:
      ; (On RosAsm, for V.1.24e: 64,536 // 313)

      ; Hexprint D$CheckSumsPixelsCount
      ; hexprint D$CheckSumsLinkedRecordsPixels

;;
  __________________________
  Results on RosAsm V.1.25d:
  
  Total = 019D9 = 6617
  Links =  0139 =  313

  Total of available Records in the Table first half = 010000 = 65536

  6617 / 65536 = 10.09 % of the Table is occupied by Records(+Linked Records)

  313 / 6617 = 4.73 % of the Records require a linkage
  
  In short: 5% of the Records are Linked when 10% of the table first half is occupied
;;

    Else
        call 'USER32.MessageBoxA' 0,
      {"The Symoblics'CheckSums'Table can be viewed only after a Compilation.", 0},
      {'Nothing to show', 0}, &MB_OK

    End_If
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  Reuse of the CkeckSum64 Method for computing the Win32 Equates:
  
  The CheckSum64 Method is so fast, that it is now useless to save the computed
  Tables, 'Equates.nam' and 'Equates.num', like we did, before V.2.015c.
  
  So, each time RosAsm is started, it now loads the 'Equates.equ' File, and reuse
  the CheckSum64 Tables, to rebuild the search Table.
  
  The Records are used in different menner. Instead of "CheckSum64 / Pointer / Link",
  the 'CheckSumsRecords' for the Win32 Equates, are, "CheckSum64 / Value / Link",
  so that, - as the integrity is verified before usage of the Equates.equ File -,
  we can retrieve the Value immidiately from the CheckSum64 Table.
  
  Another difference is that the normal 'CheckSumsRecords' is Static, for the Symbols
  Jobs for the Assembler. We use it, as is, for building the Win32 Equates Table, but,
  once done, we copy this Table to a Dynamic Memory Chunk.
  
  'NewBuildWin32Equates':
  
      Build the Win32 Equates Table and saves it in 'NewWinEquatesMem'. This Routine
      includes two commented out calls to verify the conformity of the List:
    
      'VerifyEquatesFileConformity' and 'NoDuplicationOfEquates'
    
  'NewSearchForWinEquate' and 'NewGetEquates' are for retrieving the Value from
  an &EQUATE_NAME, from the Assembler ('ReplaceWin32Equates') and/or from 'RightClick'
  
  At Start-Up, you can see the Win32 Equates Table with
  [Tools] / [RosAsm Devs Tests] / [Show Symbols Repartition]
  
  Depending on the Processor, the speed improvement is between 1.5 and 5 %, compared
  to the previous Method, on an Auto-Compilation of RosAsm. For the Table built, it
  is many times faster (now, one second, on my old 95 Box with a generic Pentium, and
  the Click time on my Celeron 1.3).
;;
____________________________________________________________________________________________
____________________________________________________________________________________________


[NewWinEquatesMem: ?   dWordsLenOfEquatesList: ?]

; Called from 'Main', each time RosAsm is started:

NewBuildWin32Equates: ; 'CheckSumsRecords' call OpenEquFiles
    call OpenEquFiles | On B$IncludesOK = &FALSE, ret

    ;call VerifyEquatesFileConformity

    call CountEquates ; >>> 'NumberOfEquates'
    ;hexprint D$NumberOfEquates
    push D$NumberOfEquates

        mov esi D$EquateIncMemory

        mov D$PointerToCheckSumsLinkedRecords CheckSumsLinkedRecords

L0:     mov ebx esi | While B$ebx > ' ' | inc ebx | End_While | mov B$ebx 0

        call CheckSum64 | call CheckSum16
    ; ebx:eax = CheckSum64 // ecx = CheckSum16

    ; Get the Hexa Value into edx:
        push eax
            inc esi  ; skip over the space
            mov edx 0
L1:         shl edx 4 | mov al B$esi | sub al '0' | On al > 9, sub al 7
            or dl al
            inc esi | cmp B$esi CR | ja L1<
            add esi 2
        pop eax

        .If D$CheckSumsRecords+ecx = 0
            On D$CheckSumsRecords+ecx+4 <> 0, jmp L1>
            mov D$CheckSumsRecords+ecx eax
            mov D$CheckSumsRecords+ecx+4 ebx
            move D$CheckSumsRecords+ecx+8 edx
        .Else
L1:         If D$CheckSumsRecords+ecx+12 = 0
                move D$CheckSumsRecords+ecx+12 D$PointerToCheckSumsLinkedRecords
            Else
                mov edi D$CheckSumsRecords+ecx+12
                While D$edi+12 <> 0
                    ;call NoDuplicationOfEquates
                    mov edi D$edi+12
                End_While
                ;call NoDuplicationOfEquates
                move D$edi+12 D$PointerToCheckSumsLinkedRecords
            End_If

            mov edi D$PointerToCheckSumsLinkedRecords
            mov D$edi eax
            mov D$edi+4 ebx
            move D$edi+8 edx
            add D$PointerToCheckSumsLinkedRecords 16
        .End_If

        dec D$NumberOfEquates | cmp D$NumberOfEquates 0 | jne L0<<

    pop D$NumberOfEquates

  ; Now, store the Win32 Equates CheckSums Table into Memory:

    mov ecx D$PointerToCheckSumsLinkedRecords | add ecx 010 | sub ecx CheckSumsRecords

    push ecx
        VirtualAlloc NewWinEquatesMem, ecx
    pop ecx

    mov esi CheckSumsRecords, edi D$NewWinEquatesMem | shr ecx 2
    mov D$dWordsLenOfEquatesList ecx | rep movsd
;;
  Adjust all of the Linked Records Pointer (above, they are pointing for a Base
  of 'CheckSumsRecords'. Now, the Base must be inside 'NewWinEquatesMem'
;;
  ; Adjustement Value:
    mov eax CheckSumsRecords | sub eax D$NewWinEquatesMem

    mov ebx CheckSumsRecords | sub ebx eax
  ; edi still points to the End of the fresh copied 'NewWinEquatesMem':
    While ebx < edi
        On D$ebx+12 <> 0, sub D$ebx+12 eax
        add ebx 16
    End_While

    ;call ClearQwordCheckSum
ret
____________________________________________________________________________________________

VerifyEquatesFileConformity:
     mov esi D$EquateIncMemory, edx esi | add edx D$EquatesIncFileSize

     .While esi < edx
L0:   ; Read one Symbol;
        If W$esi = '__'
            jmp BadEquateLine
        Else_If B$esi = '_'
            ; Good
        Else_If B$esi < '0'
            jmp BadEquateLine
        Else_If B$esi > 'Z'
            jmp BadEquateLine
        End_If
        inc esi | cmp B$esi ' ' | ja L0<

      ; No trailing '_':
        On B$esi-1 = '_', jmp BadEquateLine

      ; One Space, followed by one single '0':
        inc esi
        On B$esi <> '0', jmp BadEquateLine
        On B$esi+1 = '0', jmp BadEquateLine

      ; One Hexa Value:
        While B$esi > ' '
            If B$esi < '0'
                jmp BadEquateLine
            Else_If B$esi > 'F'
                jmp BadEquateLine
            End_If

            inc esi
        End_While

      ; CRLF
        On W$esi <> CRLF, jmp BadEquateLine

        add esi 2
    .End_While
ret


[BadEquateLineMessage: "Bad Equate line in Equates.equ: 

"
 BadEquateLineLine: '                                                        ' ]

BadEquateLine:
    While B$esi > CR
        inc esi | On esi = edx, jmp L0>
    End_While

    mov D$esi 0

    dec esi

    While B$esi > LF
        dec esi | On esi = D$EquateIncMemory, jmp L0>
    End_While

L0: mov edi BadEquateLineLine
    While B$esi <> 0 | movsb | End_While | mov B$edi 0

    showme BadEquateLineMessage
ret

____________________________________________________________________________________________

[DuplicatedEquate: 'Duplicated Equates', 0]

NoDuplicationOfEquates:
    If D$edi = eax
        On D$edi+4 = ebx, call ShowDumplicatedEquates
    End_If
ret

[CheckSumEax: ?   CheckSumEbx: ?]

ShowDumplicatedEquates:
    pushad
        mov D$CheckSumEax eax, D$CheckSumEbx ebx
        mov esi D$EquateIncMemory

L0:     mov ebx esi | While B$ebx > ' ' | inc ebx | End_While | mov B$ebx 0

        push esi
            call CheckSum64
        pop edx

        .If eax = D$CheckSumEax
            If ebx = D$CheckSumEbx
                mov edi TrashString
                While B$edx <> 0 | mov al B$edx, B$edi al | inc edx | inc edi | End_While
                mov D$edi ' == ' | add edi 4
                jmp L0>
            End_If
        .End_If
        While B$esi > CR | inc esi | End_While
        add esi 2 | jmp L0<

L0:     mov ebx esi | While B$ebx > ' ' | inc ebx | End_While | mov B$ebx 0

        push esi
            call CheckSum64
        pop edx

        .If eax = D$CheckSumEax
            If ebx = D$CheckSumEbx
                While B$edx <> 0 | mov al B$edx, B$edi al | inc edx | inc edi | End_While
                mov B$edi 0
                jmp L0>
            End_If
        .End_If
        While B$esi > CR | inc esi | End_While
        add esi 2 | jmp L0<

L0: showme TrashString
    popad
ret
____________________________________________________________________________________________

[EquateFound: ?]

NewSearchForWinEquate:
    push esi
        call NewGetEquates

        If B$EquateFound = &FALSE
            mov esi TrashString | error D$BadWinEquPtr ; error8
        End_If

        or D$imm32 eax
    pop esi

    add esi D$NewWinEquateLenght

    .If B$esi = addSign
        On B$esi+1 <> '&', ret
        add esi 2 | jmp NewSearchForWinEquate
    .Else_If B$esi = '&'
        inc esi | jmp NewSearchForWinEquate
    .Else
        While B$esi = '_'
            inc esi
        End_While
        If B$esi = '&'
            inc esi | jmp NewSearchForWinEquate
        End_If
    .End_If
ret


[NewWinEquateLenght: ?]

; Called from the Assembler and from 'RightClick'

NewGetEquates: ;New GetEquates: RightClick
    mov edi TrashString
    While B$esi > ' '
        mov ax W$esi
        If al = '+'
            jmp L1>
        Else_If al = '-'
            jmp L1>
        Else_If ax = '__'
            jmp L1>
        Else_If al = ','
            jmp L1>
        Else_If al = ';'
            jmp L1>
        Else_If ax = '_&'
            jmp L1>
        Else_If al = '&'
            jmp L1>
        Else_If al = ']'
            jmp L1>
        Else_If al = ')'
            jmp L1>
        Else
            On al >= 'a', sub al 32
            mov B$edi al | inc esi | inc edi
        End_If
    End_While

L1: mov B$edi 0 | sub edi TrashString | mov D$NewWinEquateLenght edi

  ; Simplified 'GetFromQwordCheckSum':
    mov esi TrashString

ReadWin32Equate:
    call CheckSum64 | call CheckSum16

    mov esi D$NewWinEquatesMem | add esi ecx

L0: .If D$esi = eax
        If D$esi+4 = ebx
            mov eax D$esi+8, B$EquateFound &TRUE | ret
        End_If
    .End_If

    mov esi D$esi+12 | cmp esi 0 | jne L0<

    mov B$EquateFound &FALSE
ret




TITLE EquateResolver

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
    Nested Equate Resolver - Ludwig Haehne <wkx@gmx.li>
    
    Substitute nested equates by its values in the equate table to reduce compilation time
    and memory requirements.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[EquateInflation: B$
"Buffer overrun because of equate inflation detected!

Put expressions inside your equates in brackets to
allow the parser to merge them.

e.g. write [B (A+4)] instead of [B A+4]" 0]

[BackwardNesting: B$
"Maximum equate nesting level exceeded! 
Declare equates *before* you reuse them in other equates!" 0]

[CyclicDependancy: B$ "Cyclic dependency detected!" 0]

[CompilationStopped: B$ 'Compilation stopped' 0]
____________________________________________________________________________________________

; This proc resolves nested equates. It scans all equates texts for other nested equates
; and unfolds these into a new buffer. It uses a mixture of iteration and "fake recursion".
; It makes a linear scan of the equate list and replaces nested equates with its value. If
; a not yet scanned equate is found (e.g. [B A+1, A 1]), it saves the current scan position
; on the stack and proceeds with the nested equate.
; To reduce size and compilation time expressions (which contain '(..)') are merged finally.

; Possible Optimizations:
; * merge expressions without brackets e.g. EBP+4+4+...+4 -> EBP+020
; * faster execution path for plain number equates (no nesting, no operators)

; Buffer where the substituted equate contents are stored
[EquateSubstitutes: ? EquateSubstitutesPtr: ? EquateSubstitutesLimit: ?]
; Remember in case of relocation
[LastEquateList: ? LastEquateListPtr: ?]

; The proc works in this way:
;
; For each equate e in E
;   For each token t in e
;     If IsEquate(t)
;       If IsResolved(t)
;         Substitute t
;       Else
;         Resolve(t)
;       End
;     End
;   Next
;   Merge(e)
; Next

ResolveEquates:

    [@ProcessedLimit:   D$ ? ; address of the last resolved equate (in the iteration !)
     @IsNested:         B$ ? ; equate contains nested equates and/or must be restored
     @NumBrackets:      B$ ? ; number of bracket levels in expression
     @UnpairedBrackets: B$ ? ; non-zero if brackets are unpaired
     @UnknownSymbols:   B$ ? ; number of unresolved symbols (regs, macro emitted equates)
     @ErrorText:        D$ ?]; points at the appropriate error text in case of resolving problems

    ;call 'Kernel32.OutputDebugStringA' {'ResolveEquates' 0}

  ; Set exception handler
    push @AbortCompilation
    push @AVHandler
    push D$fs:0
    mov D$fs:0 esp

      ; If table was relocated through memory extension the pointers must be altered
        mov eax D$LastEquateList, edx D$EquateList
        If eax <> edx
            sub D$LastEquateListPtr eax
            add D$LastEquateListPtr edx
            mov D$LastEquateList edx
        EndIf

        mov esi D$LastEquateListPtr, edi D$EquateSubstitutesPtr

      ; Empty list marker
        push 0
____________________________________________________________________________________________

@GetNextEquate: ; Search for next equate to process

      ; Continue with skipped equate (if any)
        On D$esp <> 0, pop esi

      ; Already dealt with? > Skip
        While B$esi-1 = 04
            mov B$esi-1 EOI
L0:         inc esi
            cmp B$esi LowSigns | ja L0<
            add esi 11
        EndWhile

        mov D@ProcessedLimit esi

      ; Check for end of list (when we finish the todo-stack has to be empty)
        If D$esi = 02020202
            add esp 4 ; clear list marker
            pop D$fs:0 | add esp 8; Clear exception handler

            mov D$EquateSubstitutesPtr edi
            move D$LastEquateListPtr D$EquateListPtr
            ret
        EndIf
____________________________________________________________________________________________

@EvaluateEquate: ; We start here when a not-yet-processed equate was found

      ; Skip name.
        mov ebx esi
        SkipName ebx

      ; ebx, esi > Address (D), Size (D), Flag (B)
      ; Scan the equate tokens, copy and unfold but only redirect the pointer
      ; when there were really nested equates.
        push esi

            mov D@IsNested 0

          ; esi > equate content,  ecx = size,  edx > substitute
            mov esi D$ebx
            mov ecx D$ebx+4
            mov edx edi

          ; We MUST copy the expression or GetFromQwordCheckSum might fail
          ; when there's no separator between the equate strings.
          ; (e.g. "...SummerWinter...") The expression buffer is abused for this.
            If B$esi+ecx >= ' '
                push ecx
                    mov edi D$ExpressionA
                    rep movsb
                    mov B$edi 0
                    mov esi D$ExpressionA
                pop ecx
                mov edi edx
            EndIf

          ; Copy contents and replace nested equates
            .While ecx > 0

L7:             While B$esi <= LowSigns
                    movsb
                    dec ecx | jz L5>>
                    cmp B$esi-1 TextSign | je L4>
                EndWhile

                mov al B$esi

                cmp al '0' | jb L3> ; ?
                cmp al '9' | jbe L4>

L3:           ; The equate string contains a text token. Check if it is an equate
                call GetFromQwordCheckSum esi, D$EquateList, D$EquateListLimit
                .If eax <> 0

                  ; Was equate already processed? Either it is among the equates resolved
                  ; by linear table processing (indicated by ProcessedLimit) or was tagged
                  ; as being (forward-)resolved with 04.
                    ..If eax >= D@ProcessedLimit
                        If B$eax-1 <> 04
                            mov esi eax
                            mov edi edx
                            call @CheckCyclicDependency
                            jmp @EvaluateEquate ; leave esi on stack so we can later continue with this
                        EndIf
                    ..EndIf

                    mov B@IsNested 1

                  ; Resolved equates contents can be copied.
                    SkipName eax
                    push esi ecx
                        mov esi D$eax
                        mov ecx D$eax+4
                        rep movsb
                    pop ecx esi

                  ; Skip name in the source buffer
                    While B$esi > LowSigns
                        inc esi
                        dec ecx | jz L5>
                    EndWhile
                .EndIf

              ; Copy rest of the token
L4:             While B$esi > LowSigns
                    movsb
                    dec ecx | jz L5>
                EndWhile

            .EndWhile


          ; Finished unfold

L5:       ; Rescan equate contents, count brackets and unresolved symbols.
          ; This is done here to keep the unfold loop simple.
            mov eax edx
            push edx
                mov eax 0
                While edx < edi
                    mov al B$edx
                    If al = openSign
                        inc B@NumBrackets
                        inc B@UnpairedBrackets
                    ElseIf al = closeSign
                        dec B@UnpairedBrackets
                    ElseIf al > '9'
                        On ah < LowSigns,
                            inc B@UnknownSymbols
                    EndIf
                    mov ah al
                    inc edx
                EndWhile
            pop edx

          ; Merge expressions if brackets were found and it is a valid statement
            cmp B@NumBrackets      0 | je L6>
            cmp B@UnpairedBrackets 0 | jne L6>
            cmp B@UnknownSymbols   0 | jne L6>

            push ebx
                movzx ebx B@NumBrackets ; nr of bracket pairs
                ;call OutputExp
                    call @MergeEquate
                ;call OutputExp
            pop ebx
            mov B@IsNested 1

L6:     pop esi

      ; Mark list entry as forward-resolved so it can be skipped later in the linear
      ; processing of the equatelist (the temporary 04 tag is removed then).
        If D$esp <> 0
            mov B$esi-1 04
        EndIf

      ; If the equate contents have been altered (nested substituted, expression merged)
      ; redirect the content pointer, otherwise ignore the copied contents.
        If B@IsNested = 1
            mov D$ebx edx ; redirect
            mov ecx edi
            sub ecx edx
            mov D$ebx+4 ecx
        Else
            mov edi edx ; throw away copied substitute
        EndIf

        mov esi ebx
        add esi 10

    jmp @GetNextEquate
____________________________________________________________________________________________

@AbortCompilation: ; Declaration error, reset old SEH & abort
  ; Reset exception handler
    mov eax D$fs:0
    mov eax D$eax
    mov D$fs:0 eax
  ; Abort
    mov eax D@ErrorText
    mov B$ErrorLevel 13 ; TODO assign meaningful error level
    jmp OutOnError
____________________________________________________________________________________________

; The exception handler deals with buffer overruns due to equate inflations which are most
; likely programming errors. Therefore the compilation is stopped.
; Another possible exception is a stack overflow when an outragous amount of nested equates
; must be resolved.

Proc @AVHandler:
    Arguments @ExceptionRecord, @Error, @ThreadContext

        mov ecx D@ExceptionRecord     ; exception record
        test D$ecx+4 1 | jnz L8>      ; non-continueable exception

      ; Check which type of exception occurred:
      ; We catch access violations that tried to read/write beyond the limit of the
      ; equate substitutes buffer. All other AVs are not dealt with.
        If D$ecx = &EXCEPTION_ACCESS_VIOLATION
            mov eax D$ecx+24
            mov edx D$EquateSubstitutesLimit
            sub eax edx
            cmp eax 01000 | ja L8>
            mov D@ErrorText EquateInflation
            ;call 'User32.MessageBoxA' D$hwnd, EquateInflation, CompilationStopped, &MB_ICONEXCLAMATION

      ; Deal with stack overflows (I've never seen this happening here)
        ElseIf D$ecx = &EXCEPTION_STACK_OVERFLOW
            mov D@ErrorText BackwardNesting
            ;call 'User32.MessageBoxA' D$hwnd, BackwardNesting, CompilationStopped, &MB_ICONEXCLAMATION

      ; Unhandled exceptions are forwarded to the OS
        Else
L8:         mov eax 1 | jmp L9>
        EndIf

      ; Set the instruction pointer to continue with the cleanup routine
        mov ecx D@ThreadContext ; get context record in ecx
        mov edx D@Error         ; get pointer to ERR structure
        mov eax D$edx+8         ; get safe place given in ERR structure
        mov D$ecx+0B8 eax       ; replace instruction pointer

        mov eax 0

L9: mov esp ebp
    pop ebp
ret
____________________________________________________________________________________________

; Check if the referenced equate corresponds to an already listed equate in the
; nesting hierarchy.
; Return address is at [esp], therefore we scan from [esp+4] -> [esp+x]=0

@CheckCyclicDependency:
    mov eax 1
    While D$esp+eax*4 <> 0
        cmp esi D$esp+eax*4 | je L0>
        inc eax
    EndWhile
ret
  ; highlight first equate in the cycle
L0: mov edx D$esp+eax*4, edi edx
    mov ecx 0-1, al EOI
    repne scasb
    mov ebx 0-2 | sub ebx ecx
    call InternSearch
    mov D@ErrorText CyclicDependancy

jmp @AbortCompilation
____________________________________________________________________________________________

; Solve expressions inside an equate and replace with the compressed string.
; All registers must be preserved for the calling routine.
;   edx -> Start of expression
;   edi -> End of expression
;   ebx -> Number of bracket pairs '(...)'
;   (1+((2 shl 3)*0010011))
;   ^                      ^
;  edx     ebx=3          edi

@MergeEquate:
    push eax ecx esi
        push edx
            inc edx
            mov D$StartOfSourceExpression edx
            mov D$StartOfDestinationExpression edi
            mov esi edi
            call ComputeExpression
            mov esi D$ExpressionA
            mov ecx edi
            sub ecx esi
            dec ecx
        pop edx

        mov edi edx
        rep movsb

    pop esi ecx eax
ret
____________________________________________________________________________________________

[SkipName
    S0: inc #1
        cmp B$#1 LowSigns | ja S0<
        inc #1]
____________________________________________________________________________________________

[DebugStr: B$ ? #256]

OutputExp:
    pushad
        mov ecx edi
        sub ecx edx
        mov esi edx
        mov edi DebugStr
        While ecx > 0
            lodsb
            If al = openSign
                mov al '('
            ElseIf al = closeSign
                mov al ')'
            ElseIf al = addSign
                mov al '+'
            ElseIf al = subSign
                mov al '-'
            ElseIf al = divSign
                mov al '/'
            ElseIf al = mulSign
                mov al '*'
            ElseIf al = Space
                mov al ' '
            EndIf
            stosb
            dec ecx
        EndWhile
        mov B$edi 0
        call 'Kernel32.OutputDebugStringA' DebugStr
    popad
ret


TITLE Rsrc

;;
____________________________________________________________________________________________
____________________________________________________________________________________________

       Resources with customized Types and Names and Languages support
       Version 1.0
____________________________________________________________________________________________
____________________________________________________________________________________________
 
 Author name: Diego Fraga
 
 Email: < diegfrag@yahoo.com >
 
 Started: September 2004
 
____________________________________________________________________________________________

;;

; CustomList > Type/Name/Lang/Pointer/Size

[CustomList: ? #MAXRESOURCE]

[RsrcType: 0    RsrcTypeStringLen: 0    RsrcTypeString: B$ 0 #33]
[RsrcName: 0    RsrcNameStringLen: 0    RsrcNameString: B$ 0 #33]
[AviTypeStrLen: 4     AviTypeStr: B$ 'AVI', 0]
[WaveTypeStrLen: 5    WaveTypeStr: B$ 'WAVE', 0]

ClearCustomList:
    mov edi CustomList, eax 0, ecx MAXRESOURCE | rep stosd
ret

ReadRosAsmResources:
    call ClearCustomList

    mov esi D$UserPEStartOfResources

  ; Number of Types in ecx
    mov eax 0 | add esi 12 | lodsw | mov ecx eax | lodsw | add ecx eax

    mov edi CustomList

  ; For each Type
L1: cmp ecx 0 | je L8>>
    lodsd
    mov D$RsrcTypeStringLen 0
    if eax <s 0
        push esi, edi
            mov esi eax, edi RsrcTypeString, ebx RsrcTypeStringLen
            call LoadRsrcIDString
        pop edi, esi
    end_if

L2: push esi
        mov D$RsrcType eax
      ; esi = Type Dir Address:
        lodsd | and eax 07fff_ffff| add eax D$UserPEStartOfResources | mov esi eax

        push ecx
          ; Number of Names in ecx
            mov eax 0 | add esi 12 | lodsw | mov ecx eax | lodsw | add ecx eax

          ; For each Name
L3:         cmp ecx 0 | je L6>>
            push esi
                lodsd
                mov D$RsrcNameStringLen 0
                if eax <s 0
                    push esi, edi
                        mov esi eax, edi RsrcNameString, ebx RsrcNameStringLen
                        call LoadRsrcIDString
                    pop edi, esi
                end_if
                mov D$RsrcName eax
              ; esi = Name Dir Address:
                lodsd | and eax 07fff_ffff | add eax D$UserPEStartOfResources | mov esi eax

                push ecx
                  ; Number of Languages in ecx
                    mov eax 0 | add esi 14 | lodsw | mov ecx eax

                  ; For each Lang
L4:                 cmp ecx 0 | je L5>

                    push eax
                      ; Type/Name:
                        mov eax D$RsrcType | stosd
                        mov eax D$RsrcName | stosd
                    pop eax
                  ; Lang:
                    movsd

                    push esi
                      ; esi = Data Entry Description Address
                        lodsd | add eax D$UserPEStartOfResources | mov esi eax

                        lodsd | sub eax D$ResourcesRVA| add eax D$UserPEStartOfResources
                        push ecx
                            mov ecx D$esi
                            call ReadResource
                        pop ecx
                        ;If B$MissingResource = &FALSE
                          ; Pointer/Size:
                            stosd | movsd
                        ;End_If
                    pop esi | add esi 4
                    dec ecx
                    jmp L4<
L5:             pop ecx
            pop esi | add esi 8
            dec ecx
            jmp l3<<
L6:     pop ecx
    pop esi
L7: add esi 4
    dec ecx
    jmp L1<<
L8:


____________________________________________________________________________________________
; Copy Standard Type resources from CustomList to each list (AviList, BitmapList,MenuList, etc)

;;
WHEN ADDING LANGUAGES TO STANDARD LISTS EACH:
    movsd | lodsd | movsd | movsd
MUST BE REPLACED WITH:
    movsd | movsd | movsd | movsd
;;

[AviTypeDir: 0 WaveTypeDir: 0]

    mov esi CustomList, edi esi, D$AviTypeDir 0, D$WaveTypeDir 0
L1: cmp D$esi 0 | je l5>>
    lodsd
    mov D$RsrcTypeStringLen 0
    test eax 08000_0000 | jz L4>
    push esi, edi
        mov esi eax, edi RsrcTypeString, ebx RsrcTypeStringLen
        call LoadRsrcIDString
    pop edi, esi

    if D$AviTypeDir = 0
        push esi, edi, ecx
            mov esi AviTypeStr, edi RsrcTypeString, ecx D$AviTypeStrLen
            repe cmpsb
        pop ecx, edi, esi
        je L2>
    endif

    if D$WaveTypeDir = 0
        push esi, edi, ecx
            mov esi WaveTypeStr, edi RsrcTypeString, ecx D$WaveTypeStrLen
            repe cmpsb
        pop ecx, edi, esi
        je L3>
    endif

L4: add esi 16 | jmp L1<
L2: mov D$AviTypeDir eax | jmp L4<
L3: mov D$WaveTypeDir eax | jmp L4<
L5:

    mov edi AviList, eax 0, ecx MAXAVI | rep stosd
    mov esi CustomList, edi AviList
    while D$esi <> 0
        lodsd
        if eax = D$AviTypeDir
            movsd | lodsd | movsd | movsd
        else
            add esi 16
        endif
    end_while
    mov D$AviListPtr edi

    mov edi WaveList, eax 0, ecx MAXWAVE | rep stosd
    mov esi CustomList, edi WaveList
    while D$esi <> 0
        lodsd
        if eax = D$WaveTypeDir
            movsd | lodsd | movsd | movsd
        else
            add esi 16
        endif
    end_while
    mov D$WaveListPtr edi

    mov edi CursorList, eax 0, ecx MAXCURSOR | rep stosd
    mov esi CustomList, edi CursorList
    while D$esi <> 0
        lodsd
        if eax = &RT_CURSOR
            movsd | lodsd | movsd | movsd
        else
            add esi 16
        endif
    end_while
    mov D$CursorListPtr edi

    mov edi BitmapList, eax 0, ecx MAXBITMAP | rep stosd
    mov esi CustomList, edi BitmapList
    while D$esi <> 0
        lodsd
        if eax = &RT_BITMAP
            movsd | lodsd | movsd | movsd
        else
            add esi 16
        endif
    end_while
    mov D$BitmapListPtr edi

    mov edi MenuList, eax 0, ecx MAXMENU | rep stosd
    mov esi CustomList, edi MenuList
    while D$esi <> 0
        lodsd
        if eax = &RT_MENU
            movsd | lodsd | movsd | movsd
        else
            add esi 16
        endif
    end_while
    mov D$MenuListPtr edi

    mov edi DialogList, eax 0, ecx MAXDIALOG | rep stosd
    mov esi CustomList, edi DialogList
    while D$esi <> 0
        lodsd
        if eax = &RT_DIALOG
            movsd | lodsd | movsd | movsd
        else
            add esi 16
        endif
    end_while
    mov D$DialogListPtr edi

    mov edi StringsList, eax 0, ecx MAXSTRINGS | rep stosd
    mov esi CustomList, edi StringsList
    while D$esi <> 0
        lodsd
        if eax = &RT_STRING
            movsd | lodsd | movsd | movsd
        else
            add esi 16
        endif
    end_while
    mov D$StringsListPtr edi

    mov edi RCdataList, eax 0, ecx MAXRCDATA | rep stosd
    mov esi CustomList, edi RCdataList
    while D$esi <> 0
        lodsd
        if eax = &RT_RCDATA
            movsd | lodsd | movsd | movsd
        else
            add esi 16
        endif
    end_while
    mov D$RCdataListPtr edi

    mov edi GroupCursorList, eax 0, ecx MAXCURSOR | rep stosd
    mov esi CustomList, edi GroupCursorList
    while D$esi <> 0
        lodsd
        if eax = &RT_GROUP_CURSOR
            movsd | lodsd | movsd | movsd
        else
            add esi 16
        endif
    end_while
    mov D$GroupCursorListPtr edi

    mov edi IconList, eax 0, ecx MAXICON | rep stosd
    mov esi CustomList, edi IconList
    while D$esi <> 0
        lodsd
        if eax = &RT_ICON
            movsd | lodsd | movsd | movsd
        else
            add esi 16
        endif
    end_while
    mov D$IconListPtr edi
  ; Arase the First Icon, Which is the Main One (elsewhere...)
    if D$IconList = 1
        VirtualFree D$IconList+4
        mov esi IconList, edi esi, ecx MAXICON-3 | add esi 12 | rep movsd
        On D$IconListPtr > IconList, sub D$IconListPtr 12
    endif

    mov edi GroupIconList, eax 0, ecx MAXICON | rep stosd
    mov esi CustomList, edi GroupIconList
    while D$esi <> 0
        lodsd
        if eax = &RT_GROUP_ICON
            movsd | lodsd | movsd | movsd
        else
            add esi 16
        endif
    end_while
    mov D$GroupIconListPtr edi
  ; Arase the First GroupIcon, Which is the Main One (elsewhere...)
    if D$GroupIconList = 1
        VirtualFree D$GroupIconList+4
        mov esi GroupIconList, edi esi, ecx MAXICON-3 | add esi 12 | rep movsd
        On D$GroupIconListPtr > GroupIconList, sub D$GroupIconListPtr 12
    endif

____________________________________________________________________________________________
; Remove "standard" resources from CustomList:
    mov esi CustomList, edi esi
L1: cmp D$esi 0 | je L5>>
    lodsd
    mov D$RsrcTypeStringLen 0
    cmp eax 16 | jg L2>
    test eax 08000_0000 | jz L3>

    cmp eax D$AviTypeDir | je L4>
    cmp eax D$WaveTypeDir | je L4>

L2: stosd | movsd | movsd | movsd | movsd | jmp L1<

L3: cmp eax &RT_FONTDIR | je L2<
    cmp eax &RT_FONT | je L2<
    cmp eax &RT_ACCELERATOR | je L2<
    cmp eax &RT_MESSAGETABLE | je L2<
    cmp eax 13 | je L2<
    cmp eax 15 | je L2<
    cmp eax &RT_VERSION | je L2<

L4: add esi 16 | jmp L1<<

L5: mov eax 0, ecx 5 | rep stosd



ret

____________________________________________________________________________________________
LoadRsrcIDString:
; In esi: source Unicode string entry ptr
; In edi: destination ptr
; In ebx: dest String size ptr (including null)

    push eax, ecx
        and esi 07ff_ffff | add esi D$UserPEStartOfResources
        mov eax 0
        lodsw
        mov ecx eax, D$ebx eax | inc D$ebx
L1:     cmp ecx 0 | je L2>
            lodsw | stosb
            dec ecx
        jmp L1<
L2: mov eax &NULL | stosb
    pop ecx, eax

ret

____________________________________________________________________________________________

[MissingResource: ?]

ReadResource:
; In eax: ptr to resource to read
; In ecx: size of data
; Out eax: Pointer to loaded data

    mov B$MissingResource &FALSE


    If eax < D$UserPeStart
        ;mov B$MissingResource &TRUE | ret
        jmp DisFail
    Else_If eax > D$UserPeEnd
        ;mov B$MissingResource &TRUE | ret
        jmp DisFail
    End_If

    push esi, edi
      ; Allocate space for data+id's strings
        push eax
            push ebx, ecx
                add ecx D$RsrcTypeStringLen
                add ecx D$RsrcNameStringLen
                VirtualAlloc TempoMemPointer ecx
            pop ecx, ebx
        pop esi

      ; Copy data
        mov edi D$TempoMemPointer
        push edi, ecx
            rep movsb
        pop ecx, eax

      ; Copy strings
        mov esi RsrcTypeString, ecx D$RsrcTypeStringLen | rep movsb
        mov esi RsrcNameString, ecx D$RsrcNameStringLen | rep movsb
    pop edi, esi

ret

____________________________________________________________________________________________

NewTemporaryFillRsrcList:
  ; All the resources lists are in format Name/Pointer/Size except:
  ; CustomList, wich is Type/Name/Lang/Pointer/Size
  ; Now, we will fill uRsrcList with format Type/Name/Lang/Pointer/Size
  ; and then will sort it.

    mov edi uRsrcList, D$TypeByName 0

    mov esi CustomList
    If D$esi > 0
        While D$esi > 0
        mov ecx 5 | rep movsd
        End_While
    End_If

    mov esi AviList
    If D$esi > 0
        While D$esi > 0
            mov eax RT_AVI | stosd | movsd | mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    mov esi WaveList
    If D$esi > 0
        While D$esi > 0
            mov eax RT_WAVE | stosd | movsd | mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    mov esi CursorList
    If D$esi > 0
        While D$esi > 0
            mov eax &RT_CURSOR | stosd | movsd | mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    mov esi BitMapList
    If D$esi > 0
        While D$esi > 0
            mov eax &RT_BITMAP | stosd | movsd | mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

  ; Store default icon if user didn't edit any (or user defined if any):
    If B$NoMainIcon = &FALSE
        mov eax &RT_ICON | stosd | mov eax ID_Icon | stosd | mov eax Language | stosd
        mov eax uIcon | stosd | mov eax uIconEnd | sub eax uIcon | stosd
    End_If

    mov esi IconList
    If D$esi > 0
        While D$esi > 0
            mov eax &RT_ICON | stosd | movsd | mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    mov esi MenuList
    If D$esi > 0
        While D$esi > 0
            mov eax &RT_MENU | stosd | movsd | mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    mov esi DialogList
    If D$esi > 0
        While D$esi > 0
            mov eax &RT_DIALOG | stosd | movsd | mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    mov esi StringsList
    If D$esi > 0
        While D$esi > 0
            mov eax &RT_STRING | stosd | movsd | mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    mov esi RcDataList
    If D$esi > 0
        While D$esi > 0
            mov eax &RT_RCDATA | stosd | movsd | mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    mov esi GroupCursorList
    If D$esi > 0
        While D$esi > 0
            mov eax &RT_GROUP_CURSOR | stosd | movsd | mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

    If B$NoMainIcon = &FALSE
        mov eax &RT_GROUP_ICON | stosd | mov eax ID_Group_Icon | stosd
        mov eax Language | stosd
        mov eax uGroupIcon | stosd
        mov eax uGroupIconEnd | sub eax uGroupIcon | stosd
    End_If

    mov esi GroupIconList
    If D$esi > 0
        While D$esi > 0
            mov eax &RT_GROUP_ICON | stosd | movsd | mov eax Language | stosd
            movsd | movsd
        End_While
    End_If

  ; Close this List, because, in case user would have deleted some Resources, there
  ; could be old Records here, from a previous [Compile]:
    mov eax 0, ecx 5 | rep stosd | sub edi (5*4)

  ; -4 > ready for backward read
    sub edi 4 | mov D$uRsrcListPtr edi
____________________________________________________________________________________________
; Sort uRsrcList Table by Type, then by name and then by lang:
    mov esi uRsrcList
    push edi, esi

; First, sort by Type:
L0:     mov edx &FALSE
        .While D$esi > 0
            mov eax D$esi | cmp eax D$esi+20 | je L4>>
            test eax BIT31 | jnz L2>
L1:       ; Type's Id by number:
            cmp eax D$esi+20 | jle L4>>
                jmp L3>
L2:       ; Type's Id by string:
            test D$esi+20 BIT31 | jz L4>>
            push esi
                mov eax esi
                if D$eax = RT_AVI
                    mov esi AviTypeStr
                elseif D$eax = RT_WAVE
                    mov esi WaveTypeStr
                else
                    mov esi D$eax+12 | add esi D$eax+16
                endif
                add eax 20
                if D$eax = RT_AVI
                    mov edi AviTypeStr
                elseif D$eax = RT_WAVE
                    mov edi WaveTypeStr
                else
                    mov edi D$eax+12 | add edi D$eax+16
                endif
                mov ecx 32 | repe cmpsb
                mov al B$esi-1
            pop esi
            cmp al B$edi-1 | jbe L4>
L3:       ; Exchage Resource
            if D$esi+20 <> 0
                Exchange D$esi D$esi+20, D$esi+4 D$esi+24, D$esi+8 D$esi+28,
                    D$esi+12 D$esi+32, D$esi+16 D$esi+36
                mov edx &TRUE
            endif
L4:       ; Next Resource
            add esi 20
        .End_While
     pop esi | push esi
        cmp edx &TRUE | je L0<<

; Then sort by name:
L0:     mov edx &FALSE
        .While D$esi > 0
            mov eax D$esi | cmp eax D$esi+20 | jne L4>>
            mov eax D$esi+4 | cmp eax D$esi+24 | je L4>>
            test eax BIT31 | jnz L2>
L1:       ; Name's Id by number:
            cmp eax D$esi+24 | jle L4>>
                jmp L3>
L2:       ; Name's Id by string:
            test D$esi+24 BIT31 | jz L4>>
            push esi
                mov ebx esi, eax 0
                mov esi D$ebx+12 | add esi D$ebx+16
                mov edi D$ebx+32 | add edi D$ebx+36
                if D$ebx+20 <s 0
                    mov ecx 32 | repne scasb | add esi 32 | sub esi ecx
                endif
                mov ecx 32 | repe cmpsb
                mov al B$esi-1
            pop esi
            cmp al B$edi-1 | jbe L4>
L3:       ; Exchage Resource
            if D$esi+20 <> 0
                Exchange D$esi D$esi+20, D$esi+4 D$esi+24, D$esi+8 D$esi+28,
                    D$esi+12 D$esi+32, D$esi+16 D$esi+36
                mov edx &TRUE
            endif
L4:       ; Next Resource
            add esi 20
        .End_While
   pop esi | push esi
        cmp edx &TRUE | je L0<<

; And finally, sort by lang:
L0:     mov edx &FALSE
        .While D$esi > 0
            mov eax D$esi | cmp eax D$esi+20 | jne L1>
            mov eax D$esi+4 | cmp eax D$esi+24 | jne L1>
          ; Lang's Id are always by number, so:
            mov eax d$esi+8 | cmp eax D$esi+28 | jbe L1>
          ; Exchage Resource
            if D$esi+20 <> 0
                Exchange D$esi D$esi+20, D$esi+4 D$esi+24, D$esi+8 D$esi+28,
                    D$esi+12 D$esi+32, D$esi+16 D$esi+36
                mov edx &TRUE
            endif
L1:       ; Next Resource
            add esi 20
        .End_While
    pop esi | push esi
        cmp edx &TRUE | je L0<

    pop esi, edi


ret

____________________________________________________________________________________________
[BIT31 0_8000_0000]
; Resources Head Line Macro. In: #1: Entries by ID, #2: Entries by name
[RsrcHeadLine | add edi 2 | mov eax #1 | stosw | mov eax #2 | stosw
    sub edi 2 | mov eax 0 | stosd | stosd | stosd]

NewBuildResourceTree:
  ; Initialisation of tree pointers:
    mov eax D$CodeListPtr, D$RsrcHeadPtr eax, D$RsrcTypePtr eax,
      D$RsrcLangPtr eax, D$RsrcPtrPtr eax, D$RsrcSectionPtr eax,
      D$RsrcSectionOrigine eax

  ; Search for the tree size (evaluation begins at second record):
    mov ecx 1                            ; how many resources in ecx
    mov edx 1                            ; how many different resources types in edx
    mov ebx 1                            ; how many langage in ebx
    mov esi uRsrcList+20                 ; start comparisons at second record
L0: mov eax D$esi | cmp eax 0 | je L3>
        inc ecx                          ; count resources
        cmp eax D$esi-20 | je L1>
            inc edx                      ; count different types
            inc ebx | jmp L2>            ; if new type >>> count language
L1: mov eax D$esi+4
      On eax <> D$esi-16, inc ebx        ; same type: different name?>>> count language
L2: add esi 20 | jmp L0<
;;
    down > top:
    - as many ptr record as resources records in 'RsrcList' (ecx * 16)
    - as many lang headers as ebx + as many lang records as ptrs ((ebx * 16)+(ecx * 8))
    - as many type headers as edx + as many types records as lang ((edx * 16)+(ebx*8))
    - records in root as types (16 + (edx * 8))
    >>>  (ecx * 16)+(ebx * 16)+(ecx * 8)+(edx * 16)+(ebx*8)+16+(edx * 8)
    >>>  (ecx * (16+8)) + (ebx * (16+8)) + (edx * (16+8)) + 16
    >>>  ((ecx+ebx+edx) * (16+8)) + 16
;;
L3: add ecx ebx | add ecx edx | mov eax ecx | shl eax 4 | shl ecx 3
    add eax ecx | add eax 16

____________________________________________________________________________________________

    mov ebx uRsrcList | add ebx 12 | mov edi D$CodeListPtr

  ; Clear the header (may bee corrupt by previous use of same memory)
    mov ecx eax, al 0 | rep stosb

   push edi

____________________________________________________________________________________________
  ; Strings for Types ID's by Name
    [RsrcAVIString: U$ 3 'AVI' RsrcWAVEString: U$ 4 'WAVE']
    push ebx
      ; Type ID in uRsrcList
        sub ebx 12
        mov edx 0
        .While D$ebx > 0
          ; If bit 31 = 0 skip resource
            test D$ebx BIT31 | jz L4>>
                cmp edx D$ebx | jne L1>
                  ; If same Type by name that last one, Copy RVA
                    move D$ebx D$ebx-20 | jmp L4>>

L1:       ; New type by name
            mov edx D$ebx

          ; Avi Type
            cmp D$ebx RT_AVI | jne L2>
                mov eax edi, esi RsrcAVIString, ecx 8 | rep movsb
              ; Change ID in uRsrcList to RVA and set the 'ID by name' flag:
                sub eax D$RsrcSectionOrigine | or eax BIT31 | mov D$ebx eax
                jmp L4>

          ; Wave Type
L2:         cmp D$ebx RT_WAVE | jne L3>
                mov eax edi, esi RsrcWAVEString, ecx 10 | rep movsb
              ; Change ID in uRsrcList to RVA and set the 'ID by name' flag:
                sub eax D$RsrcSectionOrigine | or eax BIT31 | mov D$ebx eax
                jmp L4>

          ; Custom Type
          ; esi points String in uRsrcList
L3:         mov esi D$ebx+12 | add esi D$ebx+16
          ; skip 'String Size' for now
            push edi | add edi 2
                mov eax 0, ecx 0
              ; Put String in Unicode format
                While B$esi <> 0
                    movsb | stosb
                    inc ecx
                End_While
            pop eax
          ; now put 'String Size'
            mov W$eax cx
          ; Change ID in uRsrcList to RVA and set the 'ID by name' flag:
            sub eax D$RsrcSectionOrigine | or eax BIT31 | mov D$ebx eax

L4:         add ebx 20
        .End_While
    pop ebx

  ; Strings for Name ID's by Name
    push ebx
        sub ebx 8 ; Name ID in uRsrcList
        mov edx 0
        .While D$ebx > 0
            test D$ebx BIT31 | jnz L1>
              ; bit 31 = 0, skip this resource
                mov edx 0 | jmp L4>
          ; Last Type
L1:         mov eax D$ebx-24
          ; If not same Type that last one jump
            cmp D$ebx-4 eax | jne L2>
                cmp edx D$ebx | jne L2>
                  ; If same ID by name that last one, Copy RVA
                    move D$ebx D$ebx-20 | jmp L4>
L2:       ; New id by name
            mov edx D$ebx
          ; esi points String in uRsrcList
            mov esi D$ebx+8 | add esi D$ebx+12
            test D$ebx-4 BIT31 | jz L3>
              ; Type by name, skip Type string:
                xchg edi esi | mov ecx 32 | mov al 0 | repne scasb | xchg edi esi
          ; skip 'String Size' for now
L3:         push edi | add edi 2
                mov eax 0, ecx 0
              ; Put String in Unicode format
                While B$esi <> 0
                    movsb | stosb
                    inc ecx
                End_While
            pop eax
          ; Now put 'String Size'
            mov W$eax cx
          ; Change ID in uRsrcList to RVA and set the 'ID by name' flag:
            sub eax D$RsrcSectionOrigine | or eax BIT31 | mov D$ebx eax
L4:     add ebx 20
        .End_While
    pop ebx

    Align_On 16 edi
____________________________________________________________________________________________
  ; Write all data resources in .rsrc.
  ; Before action, the pointers in 'uRsrcList' point to each resource's raw data in memory
  ; After action, same pointers point to each resource in .rsrc section:
    While D$ebx > 0
      ; This is the ptr
        mov esi D$ebx
        mov eax edi | sub eax D$RsrcSectionOrigine
      ; change Ptrs in uRsrcList to RVA
        add eax D$uBaseOfRsrc | mov D$ebx eax
      ; Size
        mov ecx D$ebx+4
        rep movsb
        mov eax edi | Align_on 010 eax | mov edi eax
        add ebx 20
    End_While

    mov eax edi | sub eax D$RsrcSectionOrigine | mov D$uRsrcSize eax

    mov eax edi | Align_on 0200 eax
    mov D$CodeListPtr eax
    pop edi | sub edi 4

____________________________________________________________________________________________

  ; Write the tree backward:
____________________________________________________________________________________________
  ; Pointers directory:

  ; end of uRsrcList (> size)
    mov esi D$uRsrcListPtr
  ; BackWard
    std
    Do
      ; write ptrs records
        mov eax 0 | stosd | stosd
      ; size / RVA ptr to true data
        movsd | movsd
      ; adress of record start
        mov eax edi | add eax 4
      ; displacement from start of .rsrc
        sub eax D$RsrcSectionOrigine
      ; ptrs-dir pointer in next level up
        mov D$esi+4 eax
        sub esi 12
    Loop_until D$esi = 0

____________________________________________________________________________________________
  ; Language directory

    mov esi D$uRsrcListPtr
  ; Write Languages dirs
    sub esi 4 | mov ecx 0

    Do
      ; pointers to data Ptrs / Lang
        movsd | movsd
      ; Name
        mov ebx D$esi
      ; records counter for lang header
        inc ecx
      ; Check if there are more languages (same type and name that next resource):
      ; Compare Names
        mov eax D$esi | cmp eax D$esi-20 | jne L1>
      ; Compare Types
        mov eax D$esi-4 | cmp eax D$esi-24 | je L2>
      ; If not equal write headLine
L1:     RsrcHeadLine ecx, 0 | mov ecx 0
        mov eax edi | add eax 4
        sub eax D$RsrcSectionOrigine
      ; node flag
        or eax BIT31
      ; ptrs-dir pointer in next level up
        mov D$esi+8 eax
      ; next ptr record in uRsrcList
L2:     sub esi 12
     Loop_until D$esi = 0

____________________________________________________________________________________________
  ; we do not need any more sizes and Lang values. We do not need any more double
  ; records for Languages. So, we rewrite uRsrcList:
    cld
    push edi
        mov esi uRsrcList, edi uRsrcList
        Do
          ; keep Type / keep ID / skip Lang / keep Ptr / skip size
            movsd | movsd | lodsd | movsd | lodsd
        Loop_Until D$esi = 0
        mov D$edi 0, esi uRsrcList, edi esi
      ; type / ID??? / ptr
L0:     movsd | Lodsd | stosd | movsd
      ; Compare Names
L1:     mov eax D$esi-8 | cmp eax D$esi+4 | jne L2>
      ; Compare Types
        mov eax D$esi-12 | cmp eax D$esi | jne L2>
      ; Skip if equal
        add esi 12 | jmp L1<
L2:
        cmp D$esi 0 | jne L0<
      ; > last record ptr
        mov esi edi | sub esi 4
        mov eax 0 | stosd | stosd | stosd
    pop edi

____________________________________________________________________________________________
  ; Types directory
    std
        mov ecx 0, edx 0
      ; Pointer
L1:     movsd
        lodsd
      ; edx = ID by name count; ecx = ID by number count
        test eax BIT31 | jz L2>
            inc edx
            jmp L3>
L2:         inc ecx
      ; Name / Type
L3:     stosd | lodsd
        cmp eax D$esi-8 | je L4>

        RsrcHeadLine ecx edx | mov ecx 0, edx 0
        mov eax edi | add eax 4
        sub eax D$RsrcSectionOrigine
      ; node flag
        or eax BIT31
      ; ptrs-dir pointer in next level up
        mov D$esi+12 eax
L4:     cmp D$esi 0 | jne L1<

  ; We do not need any more ID. So, we rewrite uRsrcList:
    cld
    push edi
        mov esi uRsrcList, edi uRsrcList
      ; keep Type / skip ID / keep Ptr
L0:     movsd | lodsd | movsd
        cmp D$esi 0 | jne L0<
            mov D$edi 0, esi uRsrcList, edi esi
      ; type??? / ptr
L0:     Lodsd | stosd | movsd
L1:     cmp D$esi eax | jne L2>
            add esi 8 | jmp L1<
L2:     cmp D$esi 0 | jne L0<
        mov esi edi | sub esi 4
        mov eax 0 | stosd | stosd
    pop edi

____________________________________________________________________________________________
  ; Root Directory:
    std
        mov ecx 0, edx 0
      ; Ptr
L1:     movsd
        lodsd
      ; edx = ID by name count; ecx = ID by number count
        test eax BIT31 | jz L2>
            inc edx | jmp L3>
L2:         inc ecx
      ; Type
L3:     stosd
        cmp D$esi 0 | jne L1<
        RsrcHeadLine ecx, edx
    cld

ret


____________________________________________________________________________________________
;[NoResources: ?    NoMainIcon: ?]

BuildRsrc:
    mov B$NoResources &FALSE, B$NoMainIcon &FALSE

    .If D$SavingExtension = '.DLL'
        mov B$NoMainIcon &TRUE
    .Else_If D$SavingExtension = '.SYS'
        mov B$NoMainIcon &TRUE
    .Else_If W$SubSystem = 3             ; Console > no Main Icon
        mov B$NoMainIcon &TRUE
    .End_If


  ; THIS LINE SHOULD BE COMMENTED FOR TESTING WITH RsrcSTUB:
    call NewTemporaryFillRsrcList

  ; THIS LINE SHOULD BE UNCOMMENTED FOR TESTING WITH RsrcSTUB:
  ;  mov esi RsrcStub, edi uRsrcList, ecx D$RsrcStubLen | rep movsd | sub edi 4 | mov D$uRsrcListPtr edi


    If D$uRsrcList = 0
        mov B$NoResources &TRUE
    Else
        call NewBuildResourceTree
    End_If
ret


; TESTING STUB
; This will serve until we create a Resources menu item to add Custom Type Resources
[RsrcStub:
;  Type         Name        Lang    Pointer         Size
   BIT31+10     BIT31       02c0a   RsrcData1       4
   BIT31+10     BIT31       040c    RsrcData2       4
   BIT31+10     BIT31+1     02c0a   RsrcData3       4
   BIT31+11     1           0409    RsrcData4       4
   100          BIT31       0409    RsrcData5       4
   100          BIT31+1     0409    RsrcData6       4
   200          1           02c0a   RsrcData7       4
RsrcStubLen: 35]; Resources * 5

[RsrcData1:  D$01111_1111 B$'TypeB' 0 'NameB' 0
 RsrcData2:  D$02222_2222 B$'TypeB' 0 'NameB' 0
 RsrcData3:  D$03333_3333 B$'TypeB' 0 'NameA' 0
 RsrcData4:  D$04444_4444 B$'TypeA' 0
 RsrcData5:  D$05555_5555 B$'NameC' 0
 RsrcData6:  D$06666_6666 B$'Abcd' 0
 RsrcData7:  D$07777_7777]



TITLE CM

;;
  'NewConditionalMacroSubstitution'


  Conditional Macros
  
  'MacroWithIf', is called from the normal 'ReplaceOneMacro' Routine, before calling
  for the 'ReplaceFromMacroData' Routine, that does all of the Macros Replacements
  jobs. If a "#If something" is found out, 'MacroWithIf' runs that Conditional Macros
  Parser
  
  The Conditional macro parser job is a substitution one: It reads the Body Macro
  and modifed it, depending on the Conditionals, on the Parameters states, and so on.
  
  It calls forst to 'ExpandMacroOnParametersLoop', that, as its name says, expands
  the Macro Body accordingly, for example, to the "#+1" key, so that the Conditions
  of each Parameter could be considered.
  
  The, it call for 'ConditionalMacroSubstitution' that does all of the Conditional
  stuff, and finaly to the 'CheckUserDefinedError' stuff, if a user defined error
  must be executed.
  
  For this implementation, a new family of Internal Variables was created. Before,
  we had the "&1,... &99" internal Variables ('MacrosVariablesTable') that are 128
  Bytes Tables, where to store any String. The new family is from "&&0" to "&&99",
  and are a set of 100 dWords Internal Counters ('MacroCounters').
  
  Each Macro Counter may hold any dWord and may be tested as such by the Conditional
  Macros Engine. But, for _writing_, the stored _BYTE_ is considered. This feature
  enable with Chars manipulations, in the Macros buildings, and are particulary usefull
  for defining Local Labels, for example, from I0 to I9, when storing '0' (Ascii 48),
  into an Internal Counter, that can be incremented / decremented, in complex macros
  Sets, for HLL Constructs.
  
  Plus, these Internal Counters, that are now set up by the normal macros, at
  'ReplaceFromMacroData' >>> 'StoreMacroVariableByNumber', can also hold a special
  record, for example, by "&&2=Pos", to the actual Source Pointer, that is used
  by the Errors Manager when pointing out to an error, inside the Source. This
  feature can be used by the Conditional Macros Parser, in case of "User Defined
  Macro Error", so that the Source Pointing Location could be defined at another
  location that the one of the actual error Detection.
  
  This is usefull for unpaired HLL Construct: Instead of pointing to the Statement
  where the error has been detected (say, an "If" / "While"...), it can point to the
  _previous_ "If" / "While", that was the real unpaired Construct.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________


[CmStart: ?    UserMacroEnd: ?]

;;
  Here, we just parse the original macro Body. If some #If construct is found,
  we call for the creation of the Macro Body substitute, depending on the
  matching, between the Conditions and the Macro Statement parameters.
;;

[UserDefinedError: ?   UserMacroLength: ?]

InitMacroWithIf:
  ; '#IF' found. Take a work Copy into Trash1:
    mov D$Trash1 0, D$Trash2 0
    mov D$Trash1ptr, Trash1, D$Trash2Ptr Trash2
    mov esi D$CmStart, edi D$Trash1ptr, ecx D$UserMacroLength
    rep movsb | mov D$edi 0

    mov B$UserDefinedError &FALSE, B$ErrorWhileUnfoldingCM &FALSE
ret

MacroWithIf:
    push esi, edi, ecx

        mov D$CmStart esi | mov D$UserMacroEnd esi | add D$UserMacroEnd ecx
        mov D$UserMacroLength ecx
      ; Cooked '#' ?
L0:     cmp B$esi numSign | jne L1>>
            cmp W$esi+1 'IF' | jne L1>
                cmp B$esi+3 Space | ja L1>
                    call InitMacroWithIf

                    call ExpandMacroOnParametersLoop

                    call ConditionalMacroSubstitution

                    On B$UserDefinedError = &TRUE, call CheckUserDefinedError

                  ; Do the final substitution:
                  ; esi will point to a Trash Table and ecx will be the new length.
                    mov esi D$Trash1Ptr | pop eax, edi, eax | ret

L1:     inc esi | loop L0<
    pop ecx, edi, esi
ret
____________________________________________________________________________________________

;;
  If a Macro ends, for example, with some '#+2' loop, we unfold the Macro Loop to
  reflect the Parameters in the Macro definition, by doing a substitution of the
  Declaration.
  
  Why, is because, if the '#If' are inside a loop, the Parameters checking must
  be made fiting with each case of the Conditional job.
;;

[EvocationParametersNumber: ?    GoExpandLoop: ?    InsideCondition: ?   LoopIndice: ?]

ExpandMacroOnParametersLoop:
    mov B$GoExpandLoop &FALSE, B$InsideCondition &FALSE, D$LoopIndice 0

    call CmParametersCount

    If ecx = 0
        mov D$EvocationParametersNumber 0 | ret
    Else_If ecx > 100
        error TooMuchCMParam
    Else
        mov D$EvocationParametersNumber ecx
        call AnalyzeOfAllParameters
    End_If

    mov esi D$Trash1ptr

  ; Is there any '#+x' Macro Loop?
    .While B$esi <> 0
        ...If B$esi = NumSign
            ..If B$esi+1 = AddSign
                On B$GoExpandLoop = &TRUE, call CMerror D$NestedMacroLoopPtr, esi, D$Trash1ptr
                On B$InsideCondition = &TRUE, call CMerror D$ConditionalLoopPtr, esi, D$Trash1ptr

                mov B$GoExpandLoop &TRUE

                add esi 2 | call GetIndice1_99 | mov ecx ebx
                mov eax D$EvocationParametersNumber
              ; ecx = #+x Num // eax = Number of Parameters in the Macro Evocation
                .If eax > ecx
                  ; Does the number match with the Evocation Number of Parameters?
                    mov edx 0 | div ecx
                    On edx <> 0, call CMerror D$MacParaPtr, esi, D$Trash1ptr

                .Else_If eax < ecx
                    call CMerror D$MacParaPtr, esi, D$Trash1ptr

                .Else
                ; If eax = ecx + End of MacroBody: No neeed to expand, but strip the '#+X'
                    If B$esi = 0
                        While B$esi <> NumSign | dec esi | End_While
                        mov B$esi 0 | ret
                    End_If

                .End_If

            ..Else_If W$esi+1 = 'IF'
                mov B$InsideCondition &TRUE

            ..Else_If D$esi+1 = 'ENDI'
                mov B$InsideCondition &FALSE

            ..End_If
        ...End_If

L5:     inc esi
    .End_While

    mov D$LoopIndice ecx

    ...If B$GoExpandLoop = &TRUE
      ; ecx = Loop Step to be added to the Parameters:
        mov edi D$Trash2ptr

L0:     mov esi D$Trash1ptr

        .While B$esi <> 0
            lodsb
            .If al = NumSign
                If B$esi = AddSign
                  ; #+x found: Add x to the ecx to be add to the expressed Parameters, and loop:
                    inc esi | call GetIndice1_99
                    add ecx ebx | cmp ecx D$EvocationParametersNumber | jbe L0<
                      ; esi >>> Next Char after '#+x'. Remove the remaining '|', if any:
                        On B$esi < Separators, inc esi
                        On B$edi-1 < Separators, dec edi

                Else_If B$esi < '1'
                    stosb

                Else_If B$esi <= '9'
                  ; Write '#':
                    stosb
                  ; Make the (Parameter '#x') Text Number, a Number, in ebx:
                    call GetIndice1_99 | dec esi | mov eax ebx
                    add eax ecx | sub eax D$LoopIndice
                    call WriteEaxDecimal

                Else
                   stosb
                End_If

            .Else
                stosb

            .End_If
        .End_While

        mov D$edi 0

        Exchange D$Trash1ptr D$Trash2ptr
    ...End_If
ret
____________________________________________________________________________________________

WriteEaxDecimal:
    push ecx, edx
        mov dl 0FF | push edx
        mov ecx 10
L0:     mov edx 0
        div ecx | push edx | cmp eax 0 | ja L0<
L2:     pop eax
        cmp al 0FF | je L9>
        add al '0' | stosb | jmp L2<
L9: pop edx, ecx
ret
__________________________________________________________________________________________

[Trash1ptr: ?    Trash2Ptr: ?]

;;
  To parse all of the possible #If Constructs, with possible nested levels, and so on...
  we use _TWO_ Tables. One is the Source, the other the Destination. When one Pass
  is finished, we 'Exchange' the Tables Pointer, and loop it all, until no more '#If'
  could be found out.
;;

ConditionalMacroSubstitution:
    call FlagConditionals
    call ParseTheConditionals
    call Remove0FFs
ret


Remove0FFs:
    mov esi D$Trash1ptr, edi esi

    While B$esi <> 0
        ..If B$esi = 0FF
L0:         inc esi | cmp B$esi 0FF | je L0<
                .If B$esi = 0
                  ; End
                    If edi = D$Trash1ptr
                        mov D$edi 'NOPE', B$edi+4 0, ecx 4 | ret
                    Else
                        On B$edi-1 =< EOI, dec edi
                    End_If
                .Else_If B$edi-1 <= EOI
                  ; Don't output two EOI/meEOI:
                    cmp B$esi EOI | jbe L0<
                .Else_If B$esi > EOI
                  ; Ensure, at least, one meEOI:
                    mov B$edi meEOI | inc edi
                .Else
                    movsb
                .End_If
        ..Else
            movsb
        ..End_If
    End_While

    While B$edi-1 =< EOI | dec edi | End_While

    mov B$edi 0

    mov ecx edi | sub ecx D$Trash1ptr
ret
____________________________________________________________________________________________

[LastIfPos: ?]

Proc ParseOneIf:
    Argument @Base, @Indice
    Uses ecx

      ; esi points  at"#IF ":
        mov esi D@Base | add esi 4

L0:     call GetIfCondition

        mov cl B@Indice

        .If B$CmCondition = &TRUE
          ; Arase the #If Statement:

            mov ebx D@Base
L1:         mov B$ebx 0FF | inc ebx | cmp ebx esi | jb L1<
            dec esi
          ; Keep the wanted Statements:
L2:         inc esi | cmp B$esi IfNumSign | jne L2<
                      If B$esi+1 = IF_FLAG
                          mov eax D@Indice | inc eax
                          call ParseOneIf esi, eax
                      End_If
                      cmp B$esi+2 cl | jne L2<
          ; Arase everything down to the matching #ENDIF:
L3:         mov B$esi 0FF | inc esi
            cmp B$esi ENDIF_FLAG | jne L3<
            cmp B$esi+1 cl | jne L3<
          ; Arase the #ENDIF Statement:
            mov W$esi 0FFFF | add esi 2
L4:         mov B$esi 0FF | inc esi | cmp B$esi EOI | ja L4<


        .Else
          ; Arase the #If Statement:

            mov ebx D@Base
L5:         mov B$ebx 0FF | inc ebx | cmp ebx esi | jb L5<

          ; Arase the whole #IF Block down to the matching #ENDIF // #ELSEIF // #ELSE:
L6:         mov B$esi 0FF | inc esi
            cmp B$esi IfNumSign | jne L6<
            cmp B$esi+2 cl | jne L6<
            If B$esi+1 = ELSEIF_FLAG  ; "#ELSEIF "
                mov D@Base esi | add esi 8 | jmp L0<<
            Else_If B$esi+1 = ELSE_FLAG ; "#ELSE"
                mov ebx esi | add esi 5 | jmp L1<<
            End_If
          ; Arase the #ENDIF Statement:
            mov W$esi 0FFFF | add esi 2
L7:         mov B$esi 0FF | inc esi | cmp B$esi EOI | ja L7<
            mov B$esi 0FF

        .End_If
EndP
____________________________________________________________________________________________

ParseTheConditionals:
    mov esi D$Trash1ptr

    While B$esi <> 0
        ..If B$esi = IfNumSign
            If B$esi+1 = IF_FLAG
                call ParseOneIf esi, 1
            End_If
        ..End_If

        inc esi
    End_While
    mov esi D$Trash1ptr
ret
____________________________________________________________________________________________
;;
  Flaging:
  
  The 'NumSign' Char of #If and friends are replaced by a dedicated 'IfNumSign',
  that makes further parsing easier. The first Char after # is replace by 1, 2,
  3, 4, respectively, for 'IF', 'ELSEIF', 'ELSE' and 'ENDIF, and the third Char
  is replaced by the nesting indice (1,... 0FF).
  
  Example: Level 4 "#IF" >>> Bytes: IfNumSign(01B), IF_FLAG(1), 4
;;

[IF_FLAG 1, ELSEIF_FLAG 2, ELSE_FLAG 3, ENDIF_FLAG 4]

FlagConditionals:
    mov esi D$Trash1ptr, ecx 0

    .While B$esi <> 0
        ...If B$esi = NumSign
            ..If W$esi+1 = 'IF'
                mov B$esi IfNumSign
                inc cl | mov B$esi+1 IF_FLAG, B$esi+2 cl

            ..Else_If D$esi+1 = 'ELSE'
                mov B$esi IfNumSign
                mov B$esi+2 cl
                If B$esi+5 < Separators
                    mov B$esi+1 ELSE_FLAG
                Else
                    mov B$esi+1 ELSEIF_FLAG
                End_If

            ..Else_If D$esi+1 = 'ENDI'
                mov B$esi IfNumSign
                mov B$esi+1 ENDIF_FLAG, B$esi+2 cl | dec cl
                On ecx = 0FF, error D$UnpairedMacroIfPtr

           ..Else_If D$esi+1 = 'ERRO'
                mov B$UserDefinedError &TRUE

            ..End_If

        ...End_If

        inc esi
    .End_While

    On ecx <> 0, error D$UnpairedMacroIfPtr
ret
____________________________________________________________________________________________
;;
  Some '#Error' has been found out inside the initial macro Declaration.
  If it is still in the Conditional substitution, we run the Usr Error Message
;;

[ConditionalErrorString: '#Error Syntax is: #Error "My error message"', 0
 ConditionalErrorPosString: '#Error Syntax is: #Error &&24 "My error message"', 0
 BadStatementCounter: 'Bad Statement Counter in the Macro internal Counter', 0]

[ErrorWhileUnfoldingCM: ?]

CheckUserDefinedError:
    mov esi D$Trash1Ptr

    .While B$esi > 0
        ...If B$esi = numSign
            ..If D$esi+1 = 'ERRO'
                .If D$esi+5 = 'RPOS'
                    While W$esi <> '&&'
                        inc esi
                        On B$esi = TextSign, error ConditionalErrorPosString
                        On B$esi = 0, error ConditionalErrorPosString
                    End_While

                    add esi 2
                    mov ebx 0, eax 0
L0:                 lodsb
                    cmp al '9' | ja L9>
                    cmp al '0' | jb L9>
                    cmp al LowSigns | jb L9>
                        sub al '0'
                        lea ebx D$ebx+ebx*4
                        lea ebx D$eax+ebx*2
                    jmp L0<

                  ; Set in 'SaveStatementCounter':
L9:                ; lea ebx D$MacroCounters+ebx*4

                    If ebx = 0
                        jmp L7>
                    Else_If ebx > 100
                        jmp L7>
                    Else
                        mov ebx D$MacroCounters+ebx*4
                        On ebx < D$StatementsTable, jmp L7>
                        mov eax D$ebx
                    End_If

                    If eax < D$CodeSource
                        jmp L7>
                    Else_If eax > D$SourceEnd
L7:                     error BadStatementCounter
                    Else
                        mov D$StatementsPtr ebx
                    End_If

                .End_If

              ; Scan for first TextSign:
                While B$esi <> TextSign
                    inc esi | On B$esi = 0, error ConditionalErrorString
                End_While
                inc esi | mov edi TrashString

              ; Scan for second TextSign:
                While B$esi <> TextSign
                    movsb | On B$esi = 0, error ConditionalErrorString
                End_While
                mov B$edi 0

                mov B$ErrorWhileUnfoldingCM &TRUE | error TrashString
            ..End_If

        ...End_If

        inc esi
    .End_While
ret
____________________________________________________________________________________________

[CmCondition: ?]

GetIfCondition:
; esi point to the Condition, right after the '#If ". Example: '#1<>', '#N=', '&55=',...

    lodsb
    ...If al = NumSign
        lodsb
        ..If al = 'N'
          ; Found: '#If #N'
            call GetNCondition

        ..Else_If al = 'L'
            ; Found: '#If #L'
                mov ebx D$EvocationParametersNumber | call GetParamCondition

        ..Else_If al = 'F'
                mov ebx 1 | call GetParamCondition

        ..Else_If al >= '1'
            If al =< '9'
              ; Found: '#If #1' ... '#If #99'
                dec esi
                call GetIndice1_99 | call GetParamCondition

            Else
                call CMerror D$BadConditionalmacroPtr, esi, D$Trash1ptr

            End_If

        ..End_If

    ...Else_If al = '&'
        If B$esi = '&'
            inc esi
            call GetIndice0_99 | dec esi
            call GetInternalCounterCondition

        Else
            call GetIndice1_99 | dec esi
            call GetInternalVariableCondition
        End_If

    ...Else
        call CMerror D$BadConditionalmacroPtr, esi, D$Trash1ptr

    ...End_If
ret


GetNCondition:
;;
  '#If #n' found. 'n' means 'Number of Parameters. This Number will be computed by the Macros Parser,
  again, but, as we need to know it now, we compute it 'privately', here, for this specific purpose.
  No matter if stupid: Simpler.
;;
    mov ecx D$EvocationParametersNumber
  ; Parameters Number in ecx. Take the condition Char:
    ;lodsb
    mov ax W$esi | inc esi

    ..If ax = '<='
        inc esi
        call GetIndice0_99
        If ecx <= ebx
            mov B$CmCondition &TRUE
        Else
            mov B$CmCondition &FALSE
        End_If

    ..Else_If ax = '=<'
        inc esi
        call GetIndice0_99
        If ecx =< ebx
            mov B$CmCondition &TRUE
        Else
            mov B$CmCondition &FALSE
        End_If

    ..Else_If ax = '>='
        inc esi
        call GetIndice0_99
        If ecx >= ebx
            mov B$CmCondition &TRUE
        Else
            mov B$CmCondition &FALSE
        End_If

    ..Else_If ax = '=>'
        inc esi
        call GetIndice0_99
        If ecx => ebx
            mov B$CmCondition &TRUE
        Else
            mov B$CmCondition &FALSE
        End_If

    ..Else_If ax = '<>'
        inc esi
        call GetIndice0_99

        If ecx <> ebx
            mov B$CmCondition &TRUE
        Else
            mov B$CmCondition &FALSE
        End_If

    ..Else_If al = '='
      ; compute the expected Decimal into Binary:
        call GetIndice0_99

        If ecx = ebx
            mov B$CmCondition &TRUE
        Else
            mov B$CmCondition &FALSE
        End_If

    ..Else_If al = '<'
        call GetIndice0_99

        If ecx < ebx
            mov B$CmCondition &TRUE
        Else
            mov B$CmCondition &FALSE
        End_If

    ..Else_If al = '>'
        call GetIndice0_99

        If ecx > ebx
            mov B$CmCondition &TRUE
        Else
            mov B$CmCondition &FALSE
        End_If

    ..Else
        call CMerror D$BadConditionalmacroPtr, esi, D$Trash1ptr

    ..End_If
ret
____________________________________________________________________________________________

[Over100CmIndice:
'A Condition is testing a Parameter indice bigger than the parameters Number', 0]

GetParamCondition:
  ; Parameter number in ebx ('AnalyzeOfAllParameters')
    dec ebx
    On ebx > D$EvocationParametersNumber, error Over100CmIndice
    move D$CmParamType D$AllParametersTypesAnsSizes+ebx*8
    move D$CmParamSize D$AllParametersTypesAnsSizes+ebx*8+4
    ;call AnalyzeOfCmParameter

    call AnalyzeOfIfExpectation
  ; >>> ebx = D$CmParamType or D$CmParamSize // eax = 'MEM', 'REG,... , 'D', 'W',...

    .If B$esi-1 = '='
        If eax = ebx
            mov B$CmCondition &TRUE
        Else
            mov B$CmCondition &FALSE
        End_If

    .Else_If W$esi-1 = '<>'
        If eax <> ebx
            mov B$CmCondition &TRUE
        Else
            mov B$CmCondition &FALSE
        End_If

    .End_If

    While B$esi > LowSigns | inc esi | End_While | inc esi
ret
____________________________________________________________________________________________

GetInternalCounterCondition:
  ; Internal Counter Indice in ebx
    On ebx > MACRO_VARIABLES, error D$MacroVariableIndicePtr
    mov ecx D$MacroCounters+ebx*4

    mov B$CmCondition &FALSE

  ; Take the Condition case:
    .If B$esi = '='
        inc esi | mov edx '='
        If B$esi = '<'
            inc esi | mov edx '<='
        Else_If B$esi = '>'
            inc esi | mov edx '>='
        End_If
    .Else_If W$esi = '<>'
        add esi 2 | mov edx '<>'
    .Else_If B$esi = '<'
        inc esi | mov edx '<'
        If B$esi = '='
            inc esi | mov edx '<='
        End_If
    .Else_If B$esi = '>'
        inc esi | mov edx '>'
        If B$esi = '='
            inc esi | mov edx '>='
        End_If
    .Else
        error UnexpectedCondition
    .End_If

    On B$esi = Space, inc esi

  ; Read the Number >>> ebx will be, for example, the "39" in "#If &&1>39":
    push ecx, edx
        If B$esi = TextSign
            inc esi | call GetAttributionChar | inc esi
        Else
          ; The 'GetAttributionNumber' of the old Macro Engine makes stupid use of ecx:
            mov ecx 0FF
            call GetAttributionNumber
        End_If
    pop edx, ecx

  ; Compare. ecx = Internal Counter // ebx = Wished Condition:
    If edx = '='
        On ecx = ebx, mov B$CmCondition &TRUE
    Else_If edx = '<>'
        On ecx <> ebx, mov B$CmCondition &TRUE
    Else_If edx = '<'
        On ecx < ebx, mov B$CmCondition &TRUE
    Else_If edx = '>'
        On ecx > ebx, mov B$CmCondition &TRUE
    Else_If edx = '<='
        On ecx <= ebx, mov B$CmCondition &TRUE
    Else_If edx = '>='

        On ecx >= ebx, mov B$CmCondition &TRUE
    End_If
ret
____________________________________________________________________________________________

[UnexpectedCondition: 'Unexpected Condition in Macro Declaration', 0]

GetInternalVariableCondition:
  ; Internal Variable Indice in ebx
    On ebx > MACRO_VARIABLES, error D$MacroVariableIndicePtr

  ; WriteMacroVariable // MacrosVariablesTable >>> 128 Bytes for each Variable
    shl ebx 7 | add ebx MacrosVariablesTable

    mov B$CmCondition &FALSE

    .If B$esi = '='
        inc esi
        If B$esi = '0'
            On B$ebx = 0, mov B$CmCondition &TRUE
        Else
            error UnexpectedCondition
        End_If

    .Else_If W$esi = '<>'
        add esi 2
        If B$esi = '0'
            On B$ebx <> 0, mov B$CmCondition &TRUE
        Else
            error UnexpectedCondition
        End_If

    .Else
        error UnexpectedCondition

    .End_If
ret
____________________________________________________________________________________________

[CmParamType: ?    CmParamSize: ?]

L7: ;showme D$Trash1ptr
    error BadConditionalmacro

AnalyzeOfCmParameter:
  ; Param Number in ebx
    push esi
    mov esi D$InstructionAptr, ecx 0

L0: inc esi | cmp B$esi EOI | jbe L7<
              cmp B$esi Space | jne L0<
              inc ecx | cmp ecx ebx | jb L0<

    inc esi ; >>> Firt Param Char.

    mov D$CmParamType 0, D$CmParamSize 0
;;
  esi point to the 'ebx' Parameter? What is it?
  register, memory, immediate, WinEquate, Symbol, string
  Byte, Word, dWord, qWord, xWord, FPU4, FPU8, FPU10
;;

    ...If B$esi = TextSign
        mov D$CmParamType 'STR'

    ...Else_If B$esi+1 = memMarker
        mov D$CmParamType 'MEM', al B$esi | and al 00_01111111 | mov B$CmParamSize al

    ...Else
      ; Rip the 'High Bit Done Flag' if any:
        push D$esi, esi
            and B$esi 00_01111111
            call IsItAreg


        ..If ah <> 0
          ; The Parameter is a reg
            mov al B$OneOperandwBit

            .If al = ByteSize
                    mov al 'B'

            .Else_If al = wordSize
                    mov al 'W'

            .Else_If al = doubleSize
                If ah = STreg
                    mov al 'F'
                Else
                    mov al 'D'
                End_If

            .Else_If al = QuadSize
                If al = STreg
                    mov al 'R'
                Else
                    mov al 'Q'
                End_If

            .Else_If al = TenSize
                mov al 'T'

            .Else  ;_If al = Xsize
                mov al 'X'

            .End_If

            mov D$CmParamType 'REG', B$CmParamSize al

        ..Else_If B$esi < '0'
          ; Might be a Win32 Equate or an error
            mov D$CmParamType 'SYM', B$CmParamSize 'D'

        ..Else_If B$esi <= '9'
            mov D$CmParamType 'IMM', B$CmParamSize 'D'

        ..Else
          ; Anything else is condidered a Symbol (Equate, Label, Win32 Equate)
            mov D$CmParamType 'SYM', B$CmParamSize 'D'

        ..End_If

        pop esi, D$esi

    ...End_If

L9: pop esi
ret
____________________________________________________________________________________________

[AllParametersTypesAnsSizes: ? ? #100]

[TooMuchCMParam: 'More than 100 Parameters with this macro Evocation', 0]

AnalyzeOfAllParameters:
    mov edi AllParametersTypesAnsSizes, ebx 1
  ; ecx is previously set by 'CmParametersCount'
L0: push edi, ebx, ecx
        call AnalyzeOfCmParameter
    pop ecx, ebx, edi
    mov eax D$CmParamType | stosd
    mov eax D$CmParamSize | stosd

    inc ebx | loop L0<
ret
____________________________________________________________________________________________

;;
  esi point after '#If #1=' // '#If #L<' // ...
  
  this should be, for example: '#If #1=D' or '#If #1=str'
  
  Here, we do nothing but load, in eax, the #If= Condition. If the Condition is a Type, we
  load the CmParamType, given by the previous call to 'AnalyzeOfCmParameter', in ebx, for
  comparison? If the Consition is a Size, we set ebx to CmParamSize, as well.
;;

AnalyzeOfIfExpectation:
    mov eax D$esi | and eax 0FFFFFF

    .If eax = 'STR'
        mov ebx D$CmParamType
    .Else_If eax = 'MEM'
        mov ebx D$CmParamType
    .Else_If eax = 'REG'
        mov ebx D$CmParamType
    .Else_If eax = 'IMM'
        mov ebx D$CmParamType
    .Else_If eax = 'SYM'
        mov ebx D$CmParamType
    .Else
        On B$esi+1 > EOI, call CMerror, D$BadConditionalmacroPtr, esi, D$Trash1ptr
      ; If ' D', and so on:
        and eax 0FF | movzx ebx B$CmParamSize

        If al = 'D'
        Else_If al = 'W'
        Else_If al = 'B'
        Else_If al = 'Q'
        Else_If al = 'F'
        Else_If al = 'R'
        Else_If al = 'T'
        Else_If al = 'X'
        Else
            call CMerror, D$BadConditionalmacroPtr, esi, D$Trash1ptr
        End_If

    .End_If
ret
____________________________________________________________________________________________

GetIndice1_99:
    On B$esi >= '1', jmp L0>
        call CMerror BadCMIndice, esi, D$Trash1ptr

GetIndice0_99:
    On B$esi < '0', error BadCMIndice
L0: On B$esi > '9', error BadCMIndice

    mov ebx 0, eax 0
L0: lodsb
    cmp al '9' | ja L9>
    cmp al '0' | jb L9>
    cmp al LowSigns | jb L9>
        sub al '0'
        lea ebx D$ebx+ebx*4
        lea ebx D$eax+ebx*2
    jmp L0<

L9: ; Number in ebx
    On ebx > 99, error BadCMIndice
ret
____________________________________________________________________________________________

;;
  How many Parameters in the User Statement (the Macro Evocation), for the '#n=x'
  Condition.
;;

CmParametersCount:
    push esi
        mov esi D$InstructionAptr, ecx 0

L0:     inc esi | mov al B$esi
            cmp al EOI | je L9>
            cmp al meEOI | je L9>
            cmp al Space | jne L0<
                inc ecx | jmp L0<
L9: pop esi
ret
____________________________________________________________________________________________

Proc CMerror:
    Arguments @error, @Source, @Base

        If D@Source <> &NULL
            mov esi D@Source, ebx esi | On esi = D@Base, jmp L2>
            While B$esi > EOI
                dec esi | On esi = D@Base, jmp L2>
            End_While

L2:         While B$ebx > EOI | inc ebx | End_While
            mov B$ebx 0

            error D@Error, esi

        Else
            error D@Error

        End_If
EndP








































































































































TITLE Equal
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 Author name: Scarmatil (Julien OTELE MANDA)

 eMail: < scarmatil@gmail.com>
 
 Last Update: 27-07-2005      
____________________________________________________________________________________________

 ProcessEqual  EqualParser  WriteOperationCode  IntegratedFunctionManagement
 EvalOneEquation   GetStringType  ProcessarrayDestination  ComputeOperationsIn_EPPSourceEquation
 
 
 EPP_All_Data    
 
____________________________________________________________________________________________
HOW TO USE THE EQUAL PREPARSER: 

This pre-parser actually groups three differents parsers :


=> Evaluation parser:  (Expression1 OP Expression2) 

- Expression1 and Expression2 are the two expression you want to compare, 
  SourceExpression can be a single register (Common or FPU), memory data or an equation combining the 
  operators below with any memory data, register or constant.

- OP is the comparison operator, it can be one of the following:  =  <  >

- The whole expression (including the parentheses are replaced by a boolean DWord value containing 
  the result of the evaluation of this expression.


=> String maker:  str(Destination) = Source

- Destination can be a 32 bits register, a Data Label (i.e a constant) or a Memory DWord. 

- Source can be a string, a 32 bits register, a Data Label or a Memory DWord. 
 
- /!\ The destination is a pointer, you have to make sure there is enough space to write the string /!\

- /!\ Each source value is a null-terminated string, make sure that the trailing null character is not missing. /!\ 

example :
[CRLF: W$ 0D0A 0] [strbuf:B$ ? #128] [strbuf2:B$ ? #128]
 > ecx = strbuf2
 > str(ecx) = 'Scarmatil'
 > str(strbuf) = 'hop !' CRLF ecx ' et ' ecx ' sont sur un bateau. ' ecx " tombe a l'eau? " CRLF "Qui reste-t-il ?"
 


=> Equation Parser:   Destination = SourceExpression 

- Destination can be a register (Common or FPU) or memory Data (including array, see below for the syntax).

- SourceExpression can be a single register (Common or FPU), memory data or an equation combining the 
  operators below with any memory data, register or constant.
  It can also be a call, providing that the return value is in EAX.
    
- You can use parentheses with no limit of nesting (except your time while compiling)

- To display the code output by the preparser inside RosAsm, simply double-click on the Destination 
  operand and choose 'unfold' in the menu.

* Operator list : 
    => ^       ; power operator, the first operand has to be strictly positive 
    => * / + - : common operator
    => // **   ; signed operators 

* Available functions : 
  - cos(), sin(), abs(), tan(), sqrt(), ln(), log10(), log2(), exp() and atan().  

* Conversions :
 The parser can perform any conversion as long as they are not impossible (store a DWord in a byte !?):
  > ST0 = (D$a+D$b)/6+(D$c*7)       ; integer result stored in a FPU register
  > Q$MyQValue = B$MyByteVal  
  > ...
    
* Signed operations:
  To force signed integer division and multiplication you can use '//' and '**' operators .
  Notice that if one of the operand is a floating point value (6.2,T$MyVal,...) the operation
  will be signed even with '*' and '/' operators.

* Addressing support
    - X$(expression)  : this will be interpreded as : X$expression (like in basic RosAsm syntax)
    - Without parentheses if the writing is the same that in basic RosAsm syntax when it is possible
      and the operation otherwise.
ex:
(1) - edx = D$(eax+3)     ; mov edx D$eax+3
(2) - edx = (D$eax)+3     ; mov edx D$eax | add edx 3 
(3) - edx = D$eax+3       ; mov edx D$eax+3
(3) - edx = D$eax+D$ebx   ; mov edx D$eax | add edx D$ebx  
(4) - edx = D$(eax+D$ebx) ; add eax D$ebx | mov edx D$eax 

* Array support:    
    - X$Array(index)  : this will be interpreded as : X$Array+index*(X_size)

ex:- [MyTable: D$ 'ZERO' 'ONE ' 'TWO ' 'THRE' 'FOUR' 'FIVE']
     eax = D$MyTable(4)  ; eax = 'FOUR'
                 
                        
* Supported data size (both in source and destination): B$, W$, D$, Q$, F$, R$ and T$    


/!\  No FINIT is written by the parser, write it yourself at the beginning of       /!\
     the code if you use expressions containing reals .
    
examples :

 > eax = 1
 > edx = &TRUE+(2*2)
 > D$Value1 = D$Value2
 > W$Value1+2 = W$Value2+2
 > D$Handle = call 'DLLNAME.DllFunction', Para1, ...    
 > ST2 = (tan(45)/sqrt(3.5+9)-1/T$MyReal)               
 > eax = (D$a+D$b)/6+(D$c*7)
 > D$Val3 = (3 * D$a + 12) / (24 * D$b) - D$c * D$c * 18 / (13 + D$z) 
 > ebx = sin(45) 
 > T$FloatNumber = sqrt(abs(7+-3*ebx)+R$FpVal)
 > eax = F$MyArrayName(eax)
 > D$DestArray(ecx) = W$SourceArray(eax)   

        ____________________________________________________________________________________________
 
  Basically this parser works as follow :
  It first copies the equation into EPP_SourceEquation and the destination operand into 
  EPP_DestOperand 
  Then the equation is formated to ease the parsing.

  The parsing begins and the first closing parenthesis is searched. Each time the parser meets an 
  opening parenthesis, it keeps its position.
  Once the first closing parenthesis is found, the operations in these parentheses are processed
  in this order: ^ then * and / and finally + and - (to keep prority).  
  
  Then each operation type is processed and the corresponding code is written thanks to 
  the macro EPP_Code                                                          
;;
____________________________________________________________________________________________
EqualParser:
    mov esi D$CodeSourceA, edi D$CodeSourceB | mov ecx esi | add ecx D$StripLen
    mov B$ErrorLevel 0, D$bracketCounter 0      ; error0
   ; mov D$StatementsCounter 1, D$InstructionsCounter 0
    move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4

    .While esi < ecx
        ..If B$esi = TextSign
            movsb | While B$esi <> TextSign | movsb | End_While
        ..Else_If_And B$esi+1 = '=', B$esi = Space, B$esi+2 = Space
            call ParseOneEqualLine
        ..Else_If B$esi = openSign
            call EvaluateEquation
        ..End_If

        If B$esi = EOI
            add D$StatementsPtr 4
        Else_If B$esi = OpenBracket
            add D$StatementsPtr 4
        Else_If B$esi = OpenVirtual
            add D$StatementsPtr 4
        End_If

        movsb
    .End_While

; post-parsing optimization :

    jmp L1>
    While ebx <> CODE_NOT_FOUND
        call DeleteFinalCodeLine ebx edi | sub edi eax

L1:     EPP_FindCodePos 'end_equal||' D$CodeSourceB edi
        mov ebx eax
    End_While
    mov B$edi-1 EOI, B$edi 0

L2:
    sub edi D$CodeSourceB | mov D$StripLen edi
    Exchange D$CodeSourceA D$CodeSourceB

ret
____________________________________________________________________________________________
EvaluateEquation:
    ; Look for Equation between parentheses which can be evualuated
    ; There three possibles comparison operators (=,<,>)
    ; ex: (eax*7=F$a/2)  ;  (D$Array(ecx)<exp(ecx))
    mov eax INITIAL_STATE
    lea edx D$esi+1

    While B$edx > EOI
        If_And B$edx = closeSign, eax = FOUND_EQUATION_TEST
            jmp L1>
        End_If
        On B$edx = openSign, inc eax
        On B$edx = closeSign, dec eax

        .If_Or B$edx = '=', B$edx = '<', B$edx = '>'
            If eax = INITIAL_STATE
                mov ebx edx
                mov eax FOUND_EQUATION_TEST
            Else
                mov eax 0 ; unpaired parenthesis
            End_If
        .End_If
        inc edx
    End_While
L1:
    If eax = FOUND_EQUATION_TEST
        call EvalOneEquation esi edx ebx edi
    End_If
ret
____________________________________________________________________________________________
Proc EvalOneEquation:
    ; This routine evaluates each member of the Equation between D@openSign and D@closeSign,
    ; then compare them using de D@CompPos operator (=,<,>) and replace the whole expression
    ; by a boolean value stored in a DWord (&TRUE if the comparison is true &FALSE otherwise)
    Arguments @openSign @closeSign @CompPos @ProducedCode
    Uses ebx, ecx

    ; debug Data
    move D$LastEqualLine   D@ProducedCode

    ; init EPP_Code
    move D$EPP_WrittenCode    D@ProducedCode
    move D$EPP_CodeBegining   D@ProducedCode

    EPP_Code 'PUSH ESI|MOV ESI ESP|'

    push D$EPP_WrittenCode
        mov D$EPP_WrittenCode EPP_DestOperand
        EPP_Code 'T$&8 '
    pop D$EPP_WrittenCode
    EPP_Code 'SUB ESP 0A|{!8 ESI-0A}|'

    mov esi D@openSign | inc esi
    mov edi EPP_SourceEquation
    mov ebx D@CompPos
    While esi < ebx | movsb | End_While | mov B$edi EOI

    push D$EPP_CodeBegining
        move D$EPP_CodeBegining D$EPP_WrittenCode
        call ComputeOperationsIn_EPPSourceEquation &FALSE
        call StoreResultInFirstOperand
        call OptimizeEqualPreparserCode EPP_CODE_BEGIN EPP_CODE_END
        call UpdateLocalDataShift
    pop D$EPP_CodeBegining

    push D$EPP_WrittenCode
        mov D$EPP_WrittenCode EPP_DestOperand
        EPP_Code 'T$&9 '
    pop D$EPP_WrittenCode
    EPP_Code 'SUB ESP 0A|{!9 ESI-014}|'

    mov esi D@CompPos | inc esi
    mov edi EPP_SourceEquation
    mov ebx D@closeSign
    While esi < ebx | movsb | End_While | mov B$edi EOI

    push D$EPP_CodeBegining
        move D$EPP_CodeBegining D$EPP_WrittenCode
        call ComputeOperationsIn_EPPSourceEquation &FALSE
        call StoreResultInFirstOperand
        call OptimizeEqualPreparserCode EPP_CODE_BEGIN EPP_CODE_END
        call UpdateLocalDataShift
    pop D$EPP_CodeBegining

    EPP_Code 'FLD T$!9|FLD T$!8|'

    mov ebx D@CompPos
    If B$ebx = '='
        EPP_Code 'FCOMP ST1|FSTSW AX|AND AX 04400|CMP AX 04000|JNE &1|MOV EAX 1|JMP &3|!1:|MOV EAX 0|!3:|'
    Else_If B$ebx = '<'
        EPP_Code 'FCOMP ST1|FSTSW AX|AND AX 0500|CMP AX 0100|JNE &1|MOV EAX 1|JMP &3|!1:|MOV EAX 0|!3:|'
    Else_If B$ebx = '>'
        EPP_Code 'FCOMP ST1|FSTSW AX|AND AX 04500|TEST AX AX|JNE &1|MOV EAX 1|JMP &3|!1:|MOV EAX 0|!3:|'
    End_If
    EPP_Code 'SUB ESP 04|{?? ESI-000}|MOV D$? EAX|'

    ; Replaces the two expressions and the comparison operator by the DWord result
    mov esi D@openSign | While B$esi > EOI | dec esi | End_While | inc esi
    mov ebx D@openSign
    mov edi D$EPP_WrittenCode
        While esi < ebx | movsb | End_While
    mov D$EPP_WrittenCode edi
    EPP_Code 'D$?'
    mov esi D@closeSign | inc esi |While B$esi > EOI | inc esi | End_While | mov ebx esi
    mov esi D@closeSign | inc esi
    mov edi D$EPP_WrittenCode
        While esi <= ebx | movsb | End_While
    mov D$EPP_WrittenCode edi
    mov B$edi meEOI
    EPP_Code 'MOV ESP ESI|POP ESI||'

    ; remove what was written before D$EPP_CodeBegining (which was initially before the expression)
    mov edi D$EPP_CodeBegining
    mov eax 0
    If B$edi-1 <> EOI
        mov B$edi-1 EOI
        sub edi 2 | While B$edi > EOI | dec edi | End_While | inc edi
        call DeleteFinalCodeLine edi D$EPP_WrittenCode
    End_If

    ; Updates edi
    mov edi D$EPP_WrittenCode | sub edi eax

    call TranslateExpressions
EndP
____________________________________________________________________________________________
ParseOneEqualLine:
    mov ebx esi, edx edi   ; D$esi = ' = '  ; eax = 1  (keep ebx at ' = ')

  ; Go to start of Instruction, and abort if, for example "If eax = 1" is encounted
  ; because of such user Defined Equates. In such Cases, we will have either one more
  ; Space backward, or, maybe, '[', if encounted inside a Declaration:
    While B$esi-1 > EOI
        On B$esi-1 = ColonSign, jmp L2>
        dec esi | dec edi
        .If B$esi <= OpenVirtual
            If B$esi = Space
                jmp L1>
            Else_If B$esi = OpenBracket
                jmp L1>
            Else_If B$esi = OpenVirtual
L1:             mov esi ebx, edi edx | ret
            End_If
        .End_If
    End_While

L2: call ProcessEqual ebx edi

    ;Sets esi (in CodeSourceA) and edi (in CodeSourceB) on the end of Line (EOI)
    mov esi ebx
    While B$esi <> EOI | inc esi | End_While

    mov edi edx
    While B$edi <> EOI | inc edi | End_While
    On B$edi-1 = meEOI, mov B$edi-1 EOI     ;The code mustn't end with 0102 (meEOI,EOI) (or RosAsm hangs when unfolding)
ret
____________________________________________________________________________________________
Proc ProcessEqual:
    ; D@EqualPos is the position of ' = '
    Arguments @EqualPos @ProducedCode
    pushad

    ; debug Data
    move D$LastEqualLine   D@ProducedCode
    On D$FirstEqualLine = &TRUE, move D$FirstEqualLine D@ProducedCode

    ; init EPP_Code
    move D$EPP_WrittenCode D@ProducedCode
    move D$EPP_CodeBegining   D@ProducedCode

    ; copies the Destination operand in EPP_DestOperand
    mov esi D@EqualPos
    While B$esi <> EOI | dec esi | End_While | inc esi
    mov edi EPP_DestOperand
    While B$esi > Space | movsb | End_While | mov B$edi Space

    ; copies the line into EPP_SourceEquation
    mov esi D@EqualPos | add esi 3
    mov edi EPP_SourceEquation
    While B$esi > EOI | movsb | End_While | mov B$edi EOI

    call IsStringMaker | If eax = &TRUE | popad | ExitP | End_If

    call IsItaCall | If eax = &TRUE | popad | ExitP | End_If

    call ReserveGlobalFunctionAdress

    call ComputeOperationsIn_EPPSourceEquation &FALSE

    call ProcessArrayDestination

    call StoreResultInFirstOperand

    EPP_Code 'end_equal||'

    call OptimizeEqualPreparserCode EPP_CODE_BEGIN EPP_CODE_END

    call UpdateLocalDataShift

    call TranslateExpressions

    ;call ShowSource 0 7

    popad
EndP
____________________________________________________________________________________________
IsStringMaker:

    If_Or W$EPP_DestOperand <> 'ST', B$EPP_DestOperand+2 <> 'R', B$EPP_DestOperand+3 <> openSign
        mov eax &FALSE | ret
    End_If

    EPP_Code 'PUSH ESI|PUSH EDI|'

    lea esi D$EPP_DestOperand+4 | mov D$EPP_Operand1 esi
    If_And B$esi+1 = memMarker, B$esi <> 'D'
        error EqualPreparser_InvalidStringDest_Type
    Else_If_And B$esi >= '0', B$esi <= '9'
        error EqualPreparser_InvalidStringDest_Numeric
    End_If

    While B$esi > openSign | inc esi | End_While | mov B$esi Space

    EPP_Code 'MOV EDI #1|'
    mov ecx EPP_SourceEquation
    .While B$ecx > EOI
        If B$ecx = TextSign
            mov D$EPP_TextPointer ecx
            EPP_Code '{&1:B$ #text 0}|MOV ESI !1|&2:|CMP B$ESI 0|JZ &3|MOVSB|JMP !2|!3:|'
            inc ecx | While B$ecx > TextSign | inc ecx | End_While
            On B$ecx = TextSign, inc ecx

        Else
            mov D$EPP_Operand2 ecx
            EPP_Code 'MOV ESI #2|&2:|CMP B$ESI 0|JZ &3|MOVSB|JMP !2|!3:|'
            While B$ecx <> Space | inc ecx | End_While
        End_If
        While B$ecx = Space | inc ecx | End_While
    .End_While

    EPP_Code 'MOV B$EDI 0|POP EDI|POP ESI||'
    mov eax &TRUE

ret
____________________________________________________________________________________________
ReserveGlobalFunctionAdress:
    ; Initialize labels to be used later for global functions declaration and call. (not used)

    call CreateNoMeanlabel
    mov edi EPP_atofAddress | mov B$edi+8 0
    call CreateNoMeanlabel
    mov edi EPP_ftoaAddress | mov B$edi+8 0
ret
____________________________________________________________________________________________
Proc ComputeOperationsIn_EPPSourceEquation:
    ; Writes code from the most nested parenthesis to the least one.
    ; The parser search for the first couple of parentheses with no nested parenthesis inside and then
    ; computes the operations in the operator's priority order.
    ; When an operation immediately computable is found while searching for theses couples of parentheses, this
    ; operation is computed first. (See TestIfThisOperationIsComputable)
    ;
    ; This allows keep the very last results on the top of the FPU Stack, so that no move is needed.
    ; For instance with this equation:
    ; > T$res = (T$a-T$b)*T$e+(T$b+T$c)
    ;
    ; - if the operations between parentheses were computed first this would lead to
    ;       > T$res = ST1*T$e+ST0    ;with ST0=T$b+T$c ; ST1=T$a-T$b
    ;       > T$res = ST2*ST0+ST1    ;with ST0=T$e     ; ST1=T$b+T$c ; ST2=T$a-T$b
    ;   The first operation to compute is ST2*ST0, then ST2 must be copied on TOS with 'FLD ST2'
    ;
    ; - On the other hand, if we compute an operation as soon as is it possible, we have:
    ;       > T$res = ST0*T$e+(T$b+T$c)     ; with ST0=T$a-T$b
    ;       > T$res = ST0+(T$b+T$c)         ; with ST0=(T$a-T$b)*T$e
    ;   Here the '+' operation is not immediately computable, so the parsing continues to
    ;       > T$res = ST1+ST0               ; with ST1=(T$a-T$b)*T$e  ; ST0=T$b+T$c
    ;       > T$res = ST0                   ; with ST0=(T$a-T$b)*T$e+(T$b+T$c)
    ;   All the operations have been made on TOS :)
    Arguments @SecondPass
    Uses esi, edi

    ; add rounding parentheses
    mov edi EPP_SourceEquation
    call ShiftLineRight 1 | mov B$edi openSign
    While B$edi > EOI | inc edi | End_While | mov B$edi closeSign | mov B$edi+1 EOI

    mov eax &FALSE

    ; Checks the parentheses number.
    mov eax 0
    mov esi EPP_SourceEquation
    While B$esi > EOI
        On B$esi = openSign, inc eax
        On B$esi = closeSign, dec eax
        inc esi
    End_While
    On eax <> 0, error Parenthesis

    call FormatEqualLine
    On B$UseCommonAddressingSyntax = &TRUE, call SetCommonAddressingSyntax
    call EqualFirstScan D@SecondPass

    mov D$FPUStackNumber 0
    mov B$ParsingInsideArray &FALSE
    mov esi EPP_SourceEquation
    .While B$esi > EOI
        .If B$esi = openSign
            call CheckIfArray
            mov ebx esi | inc esi

        .Else_If B$esi = closeSign
            call WriteCodeForTheseParentheses ebx
            On eax = &FALSE, error EqualPreparser_UnexpectedError
            call IntegratedFunctionManagement ebx eax
            mov esi EPP_SourceEquation
            mov B$ParsingInsideArray &FALSE

        .Else_If B$esi = Space
            inc esi

        .Else_If_Or B$esi < OperatorSigns, B$esi = SignedMulSign, B$esi = SignedDivSign
            call TestIfThisOperationIsComputable esi
            If eax <> &FALSE
                call GetOperandTypeAndPos esi
                call WriteOperationCode eax ecx
                mov esi EPP_SourceEquation
                mov B$ParsingInsideArray &FALSE

            Else
                inc esi
            End_If
        .Else
            inc esi
        .End_If
    .End_While

EndP
____________________________________________________________________________________________
SetCommonAddressingSyntax:
; Look for memory data followed by an expression which can be an address
; [i.e. : Memory+register(+,*)constant+(register,constant)+constant)  ]
; and surround the expression with parentheses.

    mov esi EPP_SourceEquation
    .While B$esi > EOI
L1:     If_Or B$esi <= LowSigns, B$esi = SignedMulSign, B$esi = SignedDivSign
            inc esi
            jmp L1<
        End_If

        call GetStringType esi
        While B$esi > Space | inc esi | End_While | inc esi
        ...Test_If ax MemoryOperand
            ...If B$esi = addSign
                ..If_And B$esi+2 > LowSigns, B$esi+2 <> SignedMulSign, B$esi+2 <> SignedDivSign
                    add esi 2 | call GetStringType esi
                    ..Test_If ax constantOperand
                        ReplaceByAddressingOperator plusSign   ; Memory+constant

                    ..Test_Else_If ax registerOperand
                        ReplaceByAddressingOperator plusSign   ; Memory+register

                        While B$esi > Space | inc esi | End_While | inc esi
                        .If_Or B$esi = mulSign, B$esi = SignedMulSign
                            add esi 2 | call GetStringType esi
                            .Test_If ax ConstantOperand
                                ReplaceByAddressingOperator addressSign   ; Memory+register*constant

                                While B$esi > Space | inc esi | End_While | inc esi
                                If B$esi = addSign
                                    add esi 2 | call GetStringType esi
                                    Test_If ax ConstantOperand
                                        ReplaceByAddressingOperator plusSign   ; Memory+register*constant+constant
                                    Test_End
                                Else_If B$esi = subSign
                                    add esi 2 | call GetStringType esi
                                    Test_If ax ConstantOperand
                                        ReplaceByAddressingOperator minusSign   ; Memory+register*constant-constant
                                    Test_End
                                End_If
                            .Test_End

                        .Else_If B$esi = addSign
                            add esi 2 | call GetStringType esi
                            Test_If ax ConstantOperand
                                ReplaceByAddressingOperator plusSign    ; Memory+register+constant
                            Test_End
                        .Else_If B$esi = subSign
                            add esi 2 | call GetStringType esi
                            Test_If ax ConstantOperand
                                ReplaceByAddressingOperator minusSign    ; Memory+register-constant
                            Test_End
                        .End_If
                    ..Test_End
                ..End_If
            ...End_If
        ...Test_End
    .End_While

ret
____________________________________________________________________________________________
Proc GetStringType:
    ; D@StringPos points on the string whose type is to be found. (it can be terminated by EOI,meEOI,Space or &NULL)
    Arguments @StringPos
    Uses esi, ecx

    mov esi D@StringPos
    call IsARegister D@StringPos
    ..If eax = &FALSE
        .If B$esi+1 = memMarker
            or ax MemoryOperand
            If B$esi = 'T'
                or ax (FloatingPointOperand or TByteValue)
            Else_If B$esi = 'R'
                or ax (FloatingPointOperand or RealValue)
            Else_If B$esi = 'F'
                or ax (FloatingPointOperand or FloatValue)
            Else_If B$esi = 'Q'
                or ax QWordValue
            Else_If B$esi = 'D'
                or ax DWordValue
            Else_If B$esi = 'W'
                or ax WordValue
            Else_If B$esi = 'B'
                or ax ByteValue
            End_If
        .Else_If_And B$esi >= '0', B$esi <= '9'
            mov ecx esi
            While B$ecx > Space
                If B$ecx = pointSign
                    or ax FloatingPointOperand
                    jmp L1>
                Else
                    inc ecx
                End_If
            End_While
L1:         or ax (ConstantOperand or NumericOperand)
        .Else_If_And B$esi = minusSign, B$esi+1 >= '0', B$esi+1 <= '9'
            or ax (ConstantOperand or NumericOperand)
        .Else
            While B$esi > Space | inc esi | End_While | inc esi
            If B$esi = openSign
                or ax FunctionOperand
            Else
                or ax ConstantOperand
            End_If
        .End_If
    ..End_If

EndP
____________________________________________________________________________________________
Proc ProcessArrayDestination:
    ; If the destination operand is an array (ex: F$Array(ecx+3) ) The current state is saved and
    ; the address of the array is computed and stored in EDI (resp. ECX). Then the state of the current operation is
    ; restored with X$EDI (resp. X$ECX) as new destination operand (with X the size of array's elements)
    Local @AddressRegister

    mov D$DestinationArrayRegister &FALSE
    mov esi EPP_DestOperand
    .While B$esi > Space
        .If B$esi = openSign
            or B$UsedRegisters (EPP_EDI or EPP_ECX)
            call BackupFirstResults

            ; Copy address in EPP_SourceEquation
            mov edi EPP_SourceEquation | mov B$edi openSign | inc edi
            While B$esi > Space | movsb | End_While | mov B$edi closeSign | inc edi
            If B$EPP_DestOperand+2 <> openSign
                mov B$edi mulSign | inc edi | call GetAddressingCoef EPP_DestOperand | mov B$edi al | inc edi
                mov B$edi addSign | inc edi
                lea esi D$EPP_DestOperand+2 | While B$esi <> openSign | movsb | End_While
            End_If
            mov B$edi EOI

            ; defines addressing register
            If_Or W$EPP_SourceEquation_Backup+1 = 'CX', W$EPP_SourceEquation_Backup+1 = 'CH',
                                                        W$EPP_SourceEquation_Backup+1 = 'CL'
                jmp L1>
            Else_If_And W$EPP_SourceEquation_Backup+2 = 'CX', B$EPP_SourceEquation_Backup+1 = 'E'
                jmp L1>
            Else_If_And W$EPP_SourceEquation_Backup+4 = 'CX', B$EPP_SourceEquation_Backup+3 = 'E',
                                                              B$EPP_SourceEquation_Backup+2 = memMarker
L1:             mov D@AddressRegister 'EDI'
                mov D$DestinationArrayRegister EPP_EDI
            Else
                mov D@AddressRegister 'ECX'
                mov D$DestinationArrayRegister EPP_ECX
            End_If
            move D$EPP_DestOperand D@AddressRegister | mov B$EPP_DestOperand+3 Space

            mov al B$UsedRegisters_Backup | mov B$UsedRegisters al
            call WriteRestoringCodeForUsedRegisters

            call ComputeOperationsIn_EPPSourceEquation &TRUE

            ; Stores result in EDI/ECX
            mov D$EPP_LastStorageStatement_InMemory StrNull
            mov D$EPP_LastStorageStatement          StrNull
            mov D$EPP_Operand1 EPP_SourceEquation | inc D$EPP_Operand1
            mov D$EPP_Operand2 EPP_DestOperand
            mov edi EPP_SourceEquation | call StoreIn32BitsRegister
            call ImmediateCodeParser D$EPP_LastStorageStatement_InMemory
            call ImmediateCodeParser D$EPP_LastStorageStatement

            call RestoreFirstResults
            move D$EPP_DestOperand+2 D@AddressRegister | mov B$EPP_DestOperand+5 Space

            ExitP
        .End_If

        inc esi
    .End_While

EndP
____________________________________________________________________________________________
WriteRestoringCodeForUsedRegisters:
    ; This writes the code which restores from the stack the registers which have been used
    ; during the computation of the equation.

    mov cl minusSign
    mov bx '04'

    Test_If B$UsedRegisters EPP_EDI
        EPP_Code 'MOV EDI D$ESI' cl bx '|'
        add bh 4
    Test_End

    Test_If B$UsedRegisters EPP_ECX
        EPP_Code 'MOV ECX D$ESI' cl bx '|'
        add bh 4
    Test_End

    Test_If B$UsedRegisters EPP_EAX
        On bh > '9', add bh 7
        EPP_Code 'MOV EAX D$ESI' cl bx '|'
        add bh 4
    Test_End

    Test_If B$UsedRegisters EPP_EBX
        On bh = 010, mov bl '1', bh '0'
        EPP_Code 'MOV EBX D$ESI' cl bx '|'
        add bh 4
    Test_End

    Test_If B$UsedRegisters EPP_EDX
        On bh = 010, mov bl '1', bh '0'
        On bh > '9', add bh 7
        EPP_Code 'MOV EDX D$ESI' cl bx '|'
    Test_End


ret
____________________________________________________________________________________________
Proc BackupFirstResults:
    Uses esi, edi

    mov esi EPP_DestOperand
    mov edi EPP_DestOperand_Backup
    While B$esi > Space | movsb | End_While

    mov esi EPP_SourceEquation
    mov edi EPP_SourceEquation_Backup
    While B$esi > EOI | movsb | End_While | mov B$edi EOI

    mov al B$UsedRegisters | mov B$UsedRegisters_Backup al
EndP
____________________________________________________________________________________________
Proc RestoreFirstResults:
    Uses esi, edi

    mov esi EPP_DestOperand_Backup
    mov edi EPP_DestOperand
    While B$esi > Space | movsb | End_While

    mov esi EPP_SourceEquation_Backup
    mov edi EPP_SourceEquation
    While B$esi > EOI | movsb | End_While | mov B$edi EOI

    mov al B$UsedRegisters_Backup | mov B$UsedRegisters al
EndP
____________________________________________________________________________________________
Proc CheckIfArray:
    ; Sets B$ParsingInsideArray to &TRUE, if the last parenthesis is after an array.
    Uses esi

    dec esi
    If_And esi <> EPP_SourceEquation, B$esi-1 > openSign
        dec esi | While B$esi > Space | dec esi | End_While
        On B$esi+2 = memMarker, mov B$ParsingInsideArray &TRUE
    End_If

EndP
____________________________________________________________________________________________
Proc TestIfThisOperationIsComputable:
    ; return &FALSE if the operation at D@OperatorPos has NOT the priority to the next one.
    ; otherwise the operator is returned in eax and its sign in ecx.
    ; ex: eax = 8+3*eax+(7-D$a)/2
    ; - if D@OperatorPos points on '*', the function returns '*' (i.e. mulSign) and &FALSE in ecx (unsigned operation)
    ; - if D@OperatorPos points on the first '+', the function returns &FALSE
    ;
    Arguments @OperatorPos
    Uses ebx, esi

    mov esi D@OperatorPos
    call GetSignPriority D$esi | mov bl al

    add esi 2 | While B$esi <> Space | inc esi | End_While | inc esi
    call GetSignPriority D$esi

    mov esi D@OperatorPos
    .If bl >= al
        If B$esi = SignedMulSign
            mov ecx &TRUE
            mov eax mulSign
        Else_If B$esi = SignedDivSign
            mov ecx &TRUE
            mov eax divSign
        Else
            mov ecx &FALSE
            movzx eax B$esi
        End_If
    .Else
        mov eax &FALSE
    .End_If

EndP
____________________________________________________________________________________________
Proc GetSignPriority:
    Argument @Sign

    If B@Sign = closeSign
        mov al 0
    Else_If_Or B@Sign = addSign, B@Sign = subSign
        mov al 1
    Else_If_Or B@Sign = mulSign, B@Sign = divSign, B@Sign = SignedMulSign, B@Sign = SignedDivSign
        mov al 2
    Else_If_Or B@Sign = expSign
        mov al 3
    Else
        mov al 255
    End_If
EndP
____________________________________________________________________________________________
IsItaCall:
; if the equation is a CALL, the result (EAX) is stored in memory and then written in the Destination operand.
    mov esi EPP_SourceEquation
    .If D$esi = 'CALL'
        EPP_Code 'PUSH ESI|MOV ESI ESP|'

        mov edi D$EPP_WrittenCode
        While B$esi > EOI | movsb | End_While | mov B$edi meEOI | inc edi
        mov D$EPP_WrittenCode edi

        EPP_Code 'SUB ESP 04|{?? ESI-04}|MOV D$? EAX|'
        mov B$EPP_SourceEquation Space | mov B$EPP_SourceEquation+1 'D' | mov B$EPP_SourceEquation+2 memMarker
        lea edi D$EPP_SourceEquation+3 | call WriteNoMeanLabel | mov B$edi Space | mov B$edi+1 EOI

        call ProcessArrayDestination
        call StoreResultInFirstOperand

        mov B$UsedRegisters EPP_ESI
        EPP_FindCodePos 'CALL' EPP_CODE_BEGIN EPP_CODE_END
        call OptimizeEqualPreparserCode eax EPP_CODE_END

        call TranslateExpressions
        mov eax &TRUE
    .Else
        mov eax &FALSE
    .End_If
ret
____________________________________________________________________________________________
Proc ImmediateCodeParser:
    ; Writes the given code at edi.
    ; special chars:
    ;  '||'    => EOI
    ;  '??'    => Writes a new meaningless label
    ;  '?'     => Writes the current meaningless label
    ;  '#n'    => Writes the operand n (1 or 2)
    ;  '#atof' => Writes the address of the AsciiToFloat conversion function (not used)
    ;  '#ftoa' => Writes the address of the FloatToAscii conversion function (not used)
    ;  '#text' => Writes the text pointed by D$EPP_TextPointer (D$EPP_TextPointer points on the opening TextSign)
    ;  '&n'    => Writes a new meaningless label and store it the n-th internal variable
    ;             (0 to 7, See EPP_InternalMeaninglessLabels)
    ;             &7 is used for FPU state adresss (See EqualFirstScan)
    ;  '!n'    => Writes the n-th meaningless label
    ;
    ;
    ;  - the character erased by the security-EOI at the end of the string is
    ;    returned in AL (in case it must be rewritten)
    Arguments @Content
    Uses ecx, esi, edi, ebx

    mov esi D@Content
    mov edi D$EPP_WrittenCode
    .While B$esi <> 0
        ...If B$esi = ' '
            mov B$edi Space | inc edi, esi
        ...Else_If W$esi = '||'
            mov B$edi EOI | inc edi | add esi 2
        ...Else_If B$esi = '+'
            mov B$edi plusSign | inc esi,edi
        ...Else_If B$esi = '-'
            mov B$edi minusSign | inc esi,edi
        ...Else_If B$esi = '|'
            mov B$edi meEOI | inc edi, esi
        ...Else_If B$esi = ':'
            mov B$edi colonSign | inc edi, esi
        ...Else_If B$esi = '$'
            mov B$edi memMarker | inc edi, esi
        ...Else_If B$esi = '&'
            call CreateNoMeanLabel
            push edi
                movzx eax B$esi+1 | sub eax '0' | mov ebx 9 | mul ebx
                lea edi D$EPP_InternalMeaninglessLabels+eax
                mov B$edi+8 0
                call WriteNoMeanLabel
            pop edi
            call WriteNoMeanLabel
            add esi 2
        ...Else_If B$esi = '!'
            push esi
                movzx eax B$esi+1 | sub eax '0' | mov ebx 9 | mul ebx
                lea esi D$EPP_InternalMeaninglessLabels+eax
                While B$esi <> 0 | movsb | End_While
            pop esi
            add esi 2
        ...Else_If B$esi = '?'
            If B$esi+1 = '?' | call CreateNoMeanLabel  | inc esi | End_If
            call WriteNoMeanLabel
            inc esi
        ...Else_If B$esi = '#'
            ..If B$esi+1 <> '#'
                .If D$esi+1 <> 'text'
                    If B$esi+1 = '1'
                        mov ecx D$EPP_Operand1 | add esi 2
                    Else_If B$esi+1 = '2'
                        mov ecx D$EPP_Operand2 | add esi 2
                    Else_If D$esi+1 = 'atof'
                        mov ecx D$EPP_atofAddress  | add esi 5
                    Else_If D$esi+1 = 'ftoa'
                        mov ecx D$EPP_ftoaAddress  | add esi 5
                    End_If
                    While B$ecx > Space | mov al B$ecx | mov B$edi al | inc ecx, edi | End_While
                .Else
                    mov ecx D$EPP_TextPointer | mov B$edi TextSign | inc ecx, edi
                    While B$ecx > TextSign | mov al B$ecx | mov B$edi al | inc ecx, edi | End_While
                    mov B$edi TextSign | inc ecx, edi
                    add esi 5
                .End_If
            ..Else
                mov B$edi numSign | inc edi
                add esi 2
            ..End_If
        ...Else
            movsb
        ...End_If
    .End_While

    mov al B$edi
    mov B$edi EOI
    mov D$EPP_WrittenCode edi

EndP
____________________________________________________________________________________________
Proc ReplaceOperand:
    ; Replaces the given operand by
    ;   - the current meaningless label if D@Replacement = 0
    ;   - the content of D@Replacement if D@Replacement <> 0  (a string of 1,2,3 or 4 characters)
    ; When D@Datatype = 'X', the new operand is prefixed by 'X$' (0 for no prefix)
    ; When D@operand = 0, both operands and their operator will be deleted.
    ; If the position of the second operand has changed and if both operands points into EPP_SourceEquation
    ; then D$EPP_Operand2 is updated.
    ;
    ; ex:  - ReplaceOperand 0 'B' 'ECX' ; => replaces both operands by 'B$ECX'
    ;      - ReplaceOperand 1 'W' 0     ; => replaces the first operand by 'W$AAAAAAAA'
    ;      - ReplaceOperand 2 0 'EDI'   ; => replaces the second operand by 'EDI'
    ;
    Arguments  @operand @DataType @Replacement
    Local @UpdateOperand2
    Uses edi, ecx, esi

    .If D@operand = 2
        mov edi D$EPP_Operand2
        mov D@UpdateOperand2 &FALSE
    .Else
        mov edi D$EPP_Operand1
        mov ecx D$EPP_Operand2
        If_Or edi < EPP_SourceEquation, edi > EPP_SourceEquation_End,
              ecx < EPP_SourceEquation, ecx > EPP_SourceEquation_End
            mov D@UpdateOperand2 &FALSE
        Else
            mov D@UpdateOperand2 &TRUE
        End_If
    .End_If

    mov ecx 0
    While B$edi > Space | inc edi, ecx | End_While
    If D@operand = 0
        add edi 3 | add ecx 3
        While B$edi > Space | inc edi, ecx | End_While
    End_If

    call ShiftLineLeft ecx
    sub edi ecx
    On D@UpdateOperand2 = &TRUE, sub D$EPP_Operand2 ecx

    ..If D@Replacement = 0
        If D@DataType <> 0
            On D@UpdateOperand2 = &TRUE, add D$EPP_Operand2 10
            call ShiftLineRight 10
            move D$edi D@DataType | mov B$edi+1 memMarker | add edi 2
            call WriteNoMeanLabel
        Else
            On D@UpdateOperand2 = &TRUE, add D$EPP_Operand2 8
            call ShiftLineRight 8
            call WriteNoMeanLabel
        End_If
    ..Else
        mov ecx 0 | lea esi D@Replacement
        While B$esi <> 0
            On ecx = 4, jmp L1>
            inc ecx, esi
        End_While
L1:     .If D@DataType <> 0
            add ecx 2
            call ShiftLineRight ecx
            On D@UpdateOperand2 = &TRUE, add D$EPP_Operand2 ecx
            mov al B@DataType | mov B$edi al | mov B$edi+1 memMarker | add edi 2
        .Else
            call ShiftLineRight ecx
            On D@UpdateOperand2 = &TRUE, add D$EPP_Operand2 ecx
        .End_If

        lea esi D@Replacement
        mov ecx 0
        While B$esi <> 0
            On ecx = 4, jmp L1>
            movsb | inc ecx
        End_While
L1:
   ..End_If
EndP
____________________________________________________________________________________________
Proc WriteCodeForTheseParentheses:
    ; ^ then is first searched between the parentheses then * and / and finally + and - (to keep priority)
    ; if nothing is found, we check if there is no space between the parentheses (i.e there is either
    ; an equate or an immediate number (integer or not), and when no space is found the
    ; parentheses are removed, otherwise : error)
    Argument @OpeningParenthesis
    Uses ebx

    mov eax 0
    mov ecx D@OpeningParenthesis
    .While B$ecx <> closeSign
        If B$ecx = expSign
            call GetOperandTypeAndPos ecx
            call WriteOperationCode expsign &FALSE
            On eax = &TRUE, call RemoveParentheses
            mov ecx D@OpeningParenthesis
        End_If
        On eax = &TRUE, ExitP
        inc ecx
    .End_While

    mov eax 0
    mov ecx D@OpeningParenthesis
    .While B$ecx <> closeSign
        If B$ecx = mulSign
            mov eax &FALSE
            jmp L1>
        Else_If B$ecx = SignedMulSign
            mov eax &TRUE
L1:         call GetOperandTypeAndPos ecx
            call WriteOperationCode mulSign eax
            On eax = &TRUE, call RemoveParentheses
            mov ecx D@OpeningParenthesis
        Else_If B$ecx = divSign
            mov eax &FALSE
            jmp L1>
        Else_If B$ecx = SignedDivSign
            mov eax &TRUE
L1:         call GetOperandTypeAndPos ecx
            call WriteOperationCode divSign eax
            On eax = &TRUE, call RemoveParentheses
            mov ecx D@OpeningParenthesis
        End_If
        On eax = &TRUE, ExitP
        inc ecx
    .End_While


    mov eax 0
    mov ecx D@OpeningParenthesis
    .While B$ecx <> closeSign
        If B$ecx = addSign
            call GetOperandTypeAndPos ecx
            call WriteOperationCode addsign &FALSE
            On eax = &TRUE, call RemoveParentheses
            mov ecx D@OpeningParenthesis
        Else_If B$ecx = subSign
            call GetOperandTypeAndPos ecx
            call WriteOperationCode subSign &FALSE
            On eax = &TRUE, call RemoveParentheses
            mov ecx D@OpeningParenthesis
        End_If
        On eax = &TRUE, ExitP
        inc ecx
    .End_While


    mov ecx D@OpeningParenthesis | add ecx 2
    mov D$EPP_Operand1 ecx
    mov eax 0

    While B$ecx <> closeSign
        If B$ecx = Space
            On B$ecx+1 <> closeSign, jmp L9>        ; space found => error
        End_If

        On B$ecx = pointSign, mov eax &TRUE       ; Is this a floating point number

        inc ecx
    End_While

    .If eax = &TRUE
        dec D@OpeningParenthesis
        If D@OpeningParenthesis = EPP_SourceEquation  ; saves the FP number in memory only if there is no more operation.
            EPP_Code '{??:R$ #1}|'
            call ReplaceOperand 1 'R' 0
        End_If
    .End_If

    call RemoveParentheses
    If eax = &TRUE
        mov eax EPP_NO_OPERATION
        ExitP
    End_If

L9:
    mov eax &FALSE

EndP
____________________________________________________________________________________________
ShiftLineRight:
    ; shift right the line (until EOI) pointed by edi of X bytes.
    push esi edi ecx
        mov ecx 1
        While B$edi <> EOI | inc edi ecx | End_While
        mov esi edi
        push ecx edi
            add edi D$esp+24
            std
                rep movsb
            cld
        pop edi ecx
        If ecx <= D$esp+16   ; erase the last EOI(s) if it was not previously overwritten by the shift.
            mov esi D$esp+16 | sub esi ecx
            mov ecx 0
            While ecx <= esi | mov B$edi+ecx Space | inc ecx | End_While
        End_If
    pop ecx edi esi
ret 4
____________________________________________________________________________________________
Proc ShiftLineLeft:
    ; shift left the line (until EOI) pointed by edi of D@shift bytes.
    Argument @shift
    Local @EndOfLine
    Uses esi edi ecx

    mov ecx 1
    mov esi edi
    While B$edi <> EOI | inc edi ecx | End_While | mov D@EndOfLine edi
    mov edi esi | sub edi D@shift
    rep movsb

    mov esi D@EndOfLine | sub esi D@shift | inc esi
    While esi <= D@EndOfLine | mov B$esi 0 | inc esi | End_While
EndP
____________________________________________________________________________________________
Proc GetOperandTypeAndPos:
    ;The type of each operand is identified and stored in as flags. (See EPP_Types)
    ;BX contains the type of the first operand and DX contains the type of the second one.
    ;The position of the first character of each operand is stored in D$EPP_Operand1 and D$EPP_Operand1
    Argument @OperatorPos
    Uses eax

    mov ebx 0
    mov edx 0

    mov eax D@OperatorPos | sub eax 2
    While B$eax > Space | dec eax | End_While | inc eax | mov D$EPP_Operand1 eax
    call GetStringType eax
    mov bx ax

    mov eax D@OperatorPos | add eax 2 | mov D$EPP_Operand2 eax
    call GetStringType eax
    mov dx ax

EndP
____________________________________________________________________________________________
Proc WriteOperationCode:
  ; D@OperationType can be divSign,mulSign,addSign or subSign
  ; BX contains the type of the first operand and DX contains the type of the second one. (See GetOperandTypeAndPos)
  ; return &TRUE if code has been written.
  Arguments @OperationType @Signed
  Uses D$DestinationType

    If B$ParsingInsideArray = &TRUE
        mov D$DestinationType (MemoryOperand or DWordValue)
    End_If

    Test_If_And bx NumericOperand, dx NumericOperand
        call ComputeImmediateExpression D@OperationType
        mov eax &FALSE

    Test_Else_If_Not_And bx FloatingPointOperand, dx FloatingPointOperand, D$DestinationType FloatingPointOperand
        call ReplaceIndirectAddressing
        call WriteIntegerOperationCode D@OperationType D@Signed
        mov eax &TRUE

    Test_Else ; at least one operand non-integer
        call ReplaceIndirectAddressing
        call WriteFloatingPointOperationCode D@OperationType
        call StoreFPUResult 0
        mov eax &TRUE

    Test_End

EndP
____________________________________________________________________________________________
Proc StoreFPUResult:
; The result of the FP operation is either left on the FPU Stack or stored in memory.
; In the first case, the operand is replaced by 'st0' (in lowercase so as to be locatable
; afterwards (see incFPUStackNumber)) otherwise it is replaced by a meaningless label.
    Argument @operand

    If D$FPUStackNumber < 6
        call ReplaceOperand D@operand 0 'st0'
    Else
        EPP_Code 'SUB ESP 0A|{?? ESI-000}|FSTP T$?|'

        call ReplaceOperand D@operand 'T' 0
        call decFPUStackNumber
    End_If

EndP
____________________________________________________________________________________________
; As the temporary FP result are stored in the FPU Stack (ST0-ST6), each time a new result is stored the
; last ones are pushed on the stack. Theses two functions update the temporary FP result on the stack
; by incrementing or decrementing the register number.
; The registers to be updated are identified by the 'st' prefix (instead of 'ST').
Proc incFPUStackNumber:
    Uses ecx

    mov ecx EPP_SOURCE_BEGIN
    jmp L1>
    While eax <> CODE_NOT_FOUND
        inc B$eax+2 | lea ecx D$eax+1
L1:     EPP_FindCodePos 'st' ecx EPP_SOURCE_END
    End_While
    inc D$FPUStackNumber

EndP
                            __________________________________________________
Proc decFPUStackNumber:
    Uses ecx

    mov ecx EPP_SOURCE_BEGIN
    jmp L1>
    While eax <> CODE_NOT_FOUND
        dec B$eax+2 | lea ecx D$eax+1
L1:     EPP_FindCodePos 'st' ecx EPP_SOURCE_END
    End_While
    dec D$FPUStackNumber

EndP
____________________________________________________________________________________________
Proc ReplaceIndirectAddressing:
    ; Replaces in EPP_SourceEquation, the operand of this type: 'F$D$AAAAAAA' (which are written when an array is met)
    ; by 'F$ECX' , then the code to move 'MOV ECX D$AAAAAAAA' is written

    call ExtractIndirectAddress 1 EPP_ECX
    If eax = &TRUE
        call ExtractIndirectAddress 2 EPP_EDI
    Else
        call ExtractIndirectAddress 2 EPP_ECX
    End_If

EndP

____________________________________________________________________________________________
Proc ExtractIndirectAddress:
    ; Extracts the address (which is stored in a memory DWord) of the given operand (1 or 2),
    ; move it into the given register and then replace the operand.
    ; D@register can be (EPP_EAX,EPP_EBX,EPP_ECX,EPP_EDX,EPP_ESI,EPP_EDI)
    ;
    ; return &FALSE if no extraction was done on the given operand, &TRUE otherwise.
    Argument @Operand @register
    Uses esi, edi, edx

    If D@Operand = 1
        mov esi D$EPP_Operand1
    Else
        mov esi D$EPP_Operand2
    End_If

    .If_And B$esi+1 = memMarker, B$esi+2 = 'D', B$esi+3 = memMarker
        EPP_Code 'MOV ' | call WriteRegister D@Register | mov edx eax
        push D$EPP_Operand1
            mov D$EPP_Operand1 esi | add D$EPP_Operand1 2
            EPP_Code ' #1|'
        pop D$EPP_Operand1

        call ReplaceOperand D@Operand D$esi edx
        mov eax &TRUE
    .Else
        mov eax &FALSE
    .End_If

EndP
____________________________________________________________________________________________
Proc WriteRegister:
    Argument @register

    If D@register = EPP_EAX
        EPP_CODE 'EAX'
        mov eax 'EAX'
    Else_If D@register = EPP_EBX
        EPP_CODE 'EBX'
        mov eax 'EBX'
    Else_If D@register = EPP_ECX
        EPP_CODE 'ECX'
        mov eax 'ECX'
    Else_If D@register = EPP_EDX
        EPP_CODE 'EDX'
        mov eax 'EDX'
    Else_If D@register = EPP_ESI
        EPP_CODE 'ESI'
        mov eax 'ESI'
    Else_If D@register = EPP_EDI
        EPP_CODE 'EDI'
        mov eax 'EDI'
    End_If
EndP
____________________________________________________________________________________________
Proc WriteAddressingCode:
    ; Writes the code which is before an array. Basically this translate F$Array(6) to F$Array+6*4
    Argument @DataType


    .If B@DataType = 'T'
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EAX #1|MOV EBX 10|MUL EBX|SUB ESP 04|{?? ESI-000}|MOV D$? EAX|'
    .Else_If B@DataType = 'R'
        EPP_Code 'MOV EAX #1|SHL EAX 3|SUB ESP 04|{?? ESI-000}|MOV D$? EAX|'
    .Else_If B@DataType = 'F'
        EPP_Code 'MOV EAX #1|SHL EAX 2|SUB ESP 04|{?? ESI-000}|MOV D$? EAX|'
    .Else_If B@DataType = 'B'
        EPP_Code 'MOV EAX #1|SUB ESP 04|{?? ESI-000}|MOV D$? EAX|'
    .Else_If B@DataType = 'D'
        EPP_Code 'MOV EAX #1|SHL EAX 2|SUB ESP 04|{?? ESI-000}|MOV D$? EAX|'
    .Else_If B@DataType = 'W'
        EPP_Code 'MOV EAX #1|SHL EAX 1|SUB ESP 04|{?? ESI-000}|MOV D$? EAX|'
    .Else_If B@DataType = 'Q'
        EPP_Code 'MOV EAX #1|SHL EAX 3|SUB ESP 04|{?? ESI-000}|MOV D$? EAX|'
    .End_If

    add D$EPP_Operand2 2 | EPP_Code 'ADD D$? #2|' | sub D$EPP_Operand2 2
    call ReplaceOperand 1 'D' 0
EndP
____________________________________________________________________________________________
Proc RemoveParentheses:
    ; Return &TRUE if the two parentheses surrounding EPP_Operand1 have been removed from EPP_SourceEquation,
    ; &FALSE otherwise.
    Uses edi, ecx

    mov eax &FALSE
    mov edi D$EPP_Operand1

    .If B$edi-2 = openSign
        mov ecx 0
        While B$edi+ecx > Space | inc ecx | End_While | dec ecx
        If B$edi+ecx+2 = closeSign
            call ShiftLineLeft 2
            lea edi D$edi+ecx+(3-2)
            call ShiftLineLeft 2
            mov eax &TRUE    ; the parentheses have been removed
        End_If
    .End_If

EndP
____________________________________________________________________________________________
TranslateExpressions:
    ; This part converts characters used by the preparser to RosAsm characters.
    ; It is called once all modifications of the code have been performed.
    mov ecx D$EPP_CodeBegining
    .While B$ecx <> EOI
        If B$ecx = plusSign
            mov B$ecx addSign
        Else_If B$ecx = minusSign
            mov B$ecx subSign
        Else_If B$ecx = pointSign
            mov B$ecx '.'
        Else_If B$ecx =  addressSign
            mov B$ecx mulSign
        Else_If W$ecx = 'st'
            mov W$ecx 'ST'
        Else_If B$ecx = TextSign
            inc ecx | While B$ecx <> TextSign | inc ecx | End_While
        End_If
        inc ecx
    .End_While

ret
____________________________________________________________________________________________
Proc IntegerDivisionCode_DWORD_Destination:
    Arguments @Symb_S @Symb_I

    ; >> DWORD Destination
    or B$UsedRegisters EPP_EDX
    .Test_If_And bx ConstantOperand, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EDX 0|MOV EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And bx ConstantOperand, dx WordValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EDX 0|MOV EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And bx ConstantOperand, dx DWordValue
        EPP_Code 'MOV EDX 0|MOV EAX #1|' D@Symb_I 'DIV #2|'
    .Test_Else_If_And bx Word, dx DWordValue
        EPP_Code 'MOV EDX 0|MOV' D@Symb_S 'X EAX #1|' D@Symb_I 'DIV #2|'
    .Test_Else_If_And bx Word, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EDX 0|MOV' D@Symb_S 'X EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And bx DWord, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EDX 0|MOV EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'

    .Test_Else_If_And bx ByteValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EDX 0|MOV' D@Symb_S 'X EAX #1|MOV EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And bx WordValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EDX 0|MOV' D@Symb_S 'X EAX #1|MOV EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And  bx DWordValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EDX 0|MOV EAX #1|MOV EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And  bx DWordValue, dx Word
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EDX 0|MOV EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And  bx ByteValue, dx Word
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EDX 0|MOV' D@Symb_S 'X EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And  bx ByteValue, dx DWord
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EDX 0|MOV' D@Symb_S 'X EAX #1|' D@Symb_I 'DIV #2|'

    .Test_Else_If_And bx ByteValue, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EDX 0|MOV' D@Symb_S 'X EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And bx WordValue, dx WordValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EDX 0|MOV' D@Symb_S 'X EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'DIV EBX|'
    .Test_Else_If_And bx DWordValue, dx DWordValue
        EPP_Code 'MOV EDX 0|MOV EAX #1|' D@Symb_I 'DIV #2|'
    .Test_End
    mov eax DWordValue
EndP
____________________________________________________________________________________________
Proc IntegerMultiplicationCode_DWORD_Destination:
    Arguments @Symb_S @Symb_I

    ; >> DWORD Destination
    or B$UsedRegisters EPP_EDX
    .Test_If_And bx ConstantOperand, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And bx ConstantOperand, dx WordValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And bx ConstantOperand, dx DWordValue
        EPP_Code 'MOV EAX #1|' D@Symb_I 'MUL #2|'
    .Test_Else_If_And bx Word, dx DWordValue
        EPP_Code 'MOV' D@Symb_S 'X EAX #1|' D@Symb_I 'MUL #2|'
    .Test_Else_If_And bx Word, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV' D@Symb_S 'X EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And bx DWord, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'

    .Test_Else_If_And bx ByteValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV' D@Symb_S 'X EAX #1|MOV EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And bx WordValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV' D@Symb_S 'X EAX #1|MOV EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And  bx DWordValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EAX #1|MOV EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And  bx DWordValue, dx Word
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And  bx ByteValue, dx Word
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV' D@Symb_S 'X EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And  bx ByteValue, dx DWord
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV' D@Symb_S 'X EAX #1|' D@Symb_I 'MUL #2|'

    .Test_Else_If_And bx ByteValue, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV' D@Symb_S 'X EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And bx WordValue, dx WordValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV' D@Symb_S 'X EAX #1|MOV' D@Symb_S 'X EBX #2|' D@Symb_I 'MUL EBX|'
    .Test_Else_If_And bx DWordValue, dx DWordValue
        EPP_Code 'MOV EAX #1|' D@Symb_I 'MUL #2|'
    .Test_End
    mov eax DWordValue
EndP
____________________________________________________________________________________________
Proc IntegerDivisionCode_WORD_Destination:
    Arguments @Symb_S @Symb_I

    ; >> WORD Destination
    .Test_If_And bx ConstantOperand, dx ByteValue
        EPP_Code 'MOV AX #1|' D@Symb_I 'DIV #2|'
        mov eax ByteValue
    .Test_Else_If_And bx ConstantOperand, dx WordValue
        or B$UsedRegisters EPP_EDX
        EPP_Code 'MOV EDX 0|MOV AX #1|' D@Symb_I 'DIV #2|'
        mov eax WordValue
    .Test_Else_If_And bx ConstantOperand, dx DWordValue
        ; error
    .Test_Else_If_And bx Word, dx DWordValue
        ; error
    .Test_Else_If_And bx Word, dx ByteValue
        EPP_Code 'MOV AX #1|' D@Symb_I 'DIV #2|'
        mov eax ByteValue
    .Test_Else_If_And bx DWord, dx ByteValue
        ; error

    .Test_Else_If_And bx ByteValue, dx ConstantOperand
        or B$UsedRegisters (EPP_EBX or EPP_EDX)
        EPP_Code 'MOV EDX 0|MOV' D@Symb_S 'X AX #1|MOV BX #2|' D@Symb_I 'DIV BX|'
        mov eax WordValue
    .Test_Else_If_And bx WordValue, dx ConstantOperand
        or B$UsedRegisters (EPP_EBX or EPP_EDX)
        EPP_Code 'MOV EDX 0|MOV AX #1|MOV BX #2|' D@Symb_I 'DIV BX|'
        mov eax WordValue
    .Test_Else_If_And  bx DWordValue, dx ConstantOperand
        ; error
    .Test_Else_If_And  bx DWordValue, dx Word
        or B$UsedRegisters (EPP_EBX or EPP_EDX)
        EPP_Code 'LEA EAX #1|MOV DX W$EAX+2|MOV AX W$EAX|' D@Symb_I 'DIV #2|'
        mov eax WordValue
    .Test_Else_If_And  bx ByteValue, dx Word
        or B$UsedRegisters EPP_EDX
        EPP_Code 'MOV EDX 0|MOV' D@Symb_S 'X AX #1|' D@Symb_I 'DIV #2|'
        mov eax WordValue
    .Test_Else_If_And  bx ByteValue, dx DWord
        ; error

    .Test_Else_If_And bx ByteValue, dx ByteValue
        EPP_Code 'MOV' D@Symb_S 'X AX #1|' D@Symb_I 'DIV #2|'
        mov eax ByteValue
    .Test_Else_If_And bx WordValue, dx WordValue
        or B$UsedRegisters EPP_EDX
        EPP_Code 'MOV EDX 0|MOV AX #1|' D@Symb_I 'DIV #2|'
        mov eax WordValue
    .Test_Else_If_And bx DWordValue, dx DWordValue
        ; error
    .Test_End

EndP
____________________________________________________________________________________________
Proc IntegerMultiplicationCode_WORD_Destination:
    Arguments @Symb_S @Symb_I

    ; >> WORD Destination
    .Test_If_And bx ConstantOperand, dx ByteValue
        EPP_Code 'MOV AL #1|' D@Symb_I 'MUL #2|'
        mov eax WordValue
    .Test_Else_If_And bx ConstantOperand, dx WordValue
        or B$UsedRegisters EPP_EDX
        EPP_Code 'MOV AX #1|' D@Symb_I 'MUL #2|'
        mov eax WordValue
    .Test_Else_If_And bx ConstantOperand, dx DWordValue
        ; error
    .Test_Else_If_And bx Word, dx DWordValue
        ; error
    .Test_Else_If_And bx Word, dx ByteValue
        or B$UsedRegisters EPP_EDX
        EPP_Code 'MOV' D@Symb_S 'X AX #2|' D@Symb_I 'MUL #1|'
        mov eax WordValue
    .Test_Else_If_And bx DWord, dx ByteValue
        ; error

    .Test_Else_If_And bx ByteValue, dx ConstantOperand
        EPP_Code 'MOV AL #2|' D@Symb_I 'MUL #1|'
        mov eax WordValue
    .Test_Else_If_And bx WordValue, dx ConstantOperand
        or B$UsedRegisters EPP_EDX
        EPP_Code 'MOV AX #2|' D@Symb_I 'MUL #1|'
        mov eax WordValue
    .Test_Else_If_And  bx DWordValue, dx ConstantOperand
        ; error
    .Test_Else_If_And  bx DWordValue, dx Word
        ; error
    .Test_Else_If_And  bx ByteValue, dx Word
        or B$UsedRegisters EPP_EDX
        EPP_Code 'MOV' D@Symb_S 'X AX #1|' D@Symb_I 'MUL #2|'
        mov eax WordValue
    .Test_Else_If_And  bx ByteValue, dx DWord
        ; error

    .Test_Else_If_And bx ByteValue, dx ByteValue
        EPP_Code 'MOV AL #1|' D@Symb_I 'MUL #2|'
        mov eax WordValue
    .Test_Else_If_And bx WordValue, dx WordValue
        or B$UsedRegisters EPP_EDX
        EPP_Code 'MOV AX #1|' D@Symb_I 'MUL #2|'
        mov eax WordValue
    .Test_Else_If_And bx DWordValue, dx DWordValue
        ; error
    .Test_End

EndP
____________________________________________________________________________________________
Proc IntegerDivisionCode_BYTE_Destination:
    Arguments @Symb_S @Symb_I

    ; >> BYTE Destination
    .Test_If_And bx ConstantOperand, dx ByteValue
        EPP_Code 'MOV AX #1|' D@Symb_I 'DIV #2|'
        mov eax ByteValue
    .Test_Else_If_And bx ConstantOperand, dx WordValue
        ; error
    .Test_Else_If_And bx ConstantOperand, dx DWordValue
                                                                                                                                                                                                                                                                                                                                                                                                                                        ; error
    .Test_Else_If_And bx Word, dx DWordValue
        ; error
    .Test_Else_If_And bx Word, dx ByteValue
        EPP_Code 'MOV AX #1|' D@Symb_I 'DIV #2|'
        mov eax ByteValue
    .Test_Else_If_And bx DWord, dx ByteValue
        ; error

    .Test_Else_If_And bx ByteValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV' D@Symb_S 'X AX #1|MOV BL #2|' D@Symb_I 'DIV BL|'
        mov eax ByteValue
    .Test_Else_If_And bx WordValue, dx ConstantOperand
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV AX #1|MOV BL #2|' D@Symb_I 'DIV BL|'
        mov eax ByteValue
    .Test_Else_If_And  bx DWordValue, dx ConstantOperand
        ; error
    .Test_Else_If_And  bx DWordValue, dx Word
        ; error
    .Test_Else_If_And  bx ByteValue, dx Word
        ; error
    .Test_Else_If_And  bx ByteValue, dx DWord
        ; error

    .Test_Else_If_And bx ByteValue, dx ByteValue
        or B$UsedRegisters EPP_EBX
        EPP_Code 'MOV' D@Symb_S 'X AX #1||' D@Symb_I 'DIV #2|'
        mov eax ByteValue
    .Test_Else_If_And bx WordValue, dx WordValue
        ; error '
    .Test_Else_If_And bx DWordValue, dx DWordValue
        ; error
    .Test_End

EndP
____________________________________________________________________________________________
Proc WriteIntegerOperationCode:
    ; BX contains the type of the first operand and DX contains the type of the second one.
    ; D@Symb_I and D@Symb_S contain the letters which changes in mnemonics from a signed to
    ; an unsigned operation. This way, no further test of the sign is needed.
    Arguments @OperationType @Signed
    Local @Symb_I @Symb_S @OperationString
    Uses ecx, esi

    If D@Signed = &TRUE
        mov D@Symb_I 'I'
        mov D@Symb_S 'S'
    Else
        mov D@Symb_I ''
        mov D@Symb_S 'Z'
    End_If

    mov eax 0_FF00_0000 ; error check

    .If D@OperationType = divSign
        or B$UsedRegisters EPP_EAX
        Test_If D$DestinationType DWordValue
            call IntegerDivisionCode_DWORD_Destination D@Symb_S D@Symb_I

        Test_Else_If D$DestinationType WordValue
            call IntegerDivisionCode_WORD_Destination D@Symb_S D@Symb_I

        Test_Else D$DestinationType ByteValue
            call IntegerDivisionCode_BYTE_Destination D@Symb_S D@Symb_I

        Test_End

    ; >> MULTIPLICATION
    .Else_If D@OperationType = mulSign
        or B$UsedRegisters EPP_EAX
        Test_If D$DestinationType DWordValue
            call IntegerMultiplicationCode_DWORD_Destination D@Symb_S D@Symb_I

        Test_Else_If D$DestinationType WordValue
            call IntegerMultiplicationCode_WORD_Destination D@Symb_S D@Symb_I

        Test_Else D$DestinationType ByteValue
            ; error

        Test_End

    ; >> POWER
    .Else_If D@OperationType = expSign
        or B$UsedRegisters (EPP_EAX or EPP_EBX or EPP_ECX)
        mov cx 0 | Test_If_Not_And bx DWordValue, bx ConstantOperand | mov cl B@Symb_S | mov ch 'X' | Test_End
        Test_If dx DWordValue
            mov esi 'ECX'
        Test_Else_If dx WordValue
            mov esi 'CX'
        Test_Else_If dx WordValue
            mov esi 'CL'
        Test_Else ; constant
            mov esi 'ECX'
        Test_End

        EPP_Code 'MOV ECX 0|MOV EAX 1|MOV' cx ' EBX #1|&1:|CMP ' esi ' #2|JE &2|'
        EPP_Code  D@Symb_I 'MUL EBX|INC ECX|JMP !1|!2:|'

        mov eax DWordValue

    ; >> ADDITION AND SUBSTRACTION
    .Else_If_Or D@OperationType = addSign, D@OperationType = subSign
        or B$UsedRegisters EPP_EAX
        If D@OperationType = addSign
            mov D@OperationString 'ADD'
        Else
            mov D@OperationString 'SUB'
        End_If
        mov cx 0
        .Test_If D$DestinationType DWordValue
            Test_If_Not_And bx DWordValue, bx ConstantOperand | mov cl B@Symb_S | mov ch 'X' | Test_End
            EPP_Code 'MOV' cx ' EAX #1|' D@OperationString ' EAX #2|'
            mov eax DWordValue

        .Test_Else_If D$DestinationType WordValue
            Test_If_Not_And  bx WordValue, bx ConstantOperand | mov cl B@Symb_S | mov ch 'X' | Test_End
            EPP_Code 'MOV' cx ' AX #1|' D@OperationString ' AX #2|'
            mov eax WordValue

        .Test_Else_If D$DestinationType ByteValue
            EPP_Code 'MOV AL #1|' D@OperationString ' AL #2|'
            mov eax ByteValue

        .Test_End

    .EndIf

    ; stores result in memory
    .If eax = DWordValue
        EPP_Code 'SUB ESP 04|{?? ESI-000}|MOV D$? EAX|'
        call ReplaceOperand 0 'D' 0
    .Else_If eax = WordValue
        EPP_Code 'SUB ESP 02|{?? ESI-000}|MOV W$? AX|'
        call ReplaceOperand 0 'W' 0
    .Else_If eax = ByteValue
        EPP_Code 'SUB ESP 01|{?? ESI-000}|MOV B$? AL|'
        call ReplaceOperand 0 'B' 0
    .Else
        error EqualPreparser_SourceInvalid
    .End_If

EndP
____________________________________________________________________________________________
Proc WriteFloatingPointOperationCode:
    ; Writing of data loading according to its type.
    ; BX contains the type of the first operand and DX contains the type of the second one.
    Arguments @OperationType

    ; copy integers registers into memory and change the operand type to MemoryOperand
    ..Test_If bx RegisterOperand
        .Test_If_Not bx FloatingPointOperand
            and bx ((not RegisterOperand) and 0_FFFF)
            or bx MemoryOperand
            Test_If_Not bx DWordValue
                call ExtendOperandToDWord 1 MemoryOperand
            Test_Else
                EPP_Code 'SUB ESP 04|{?? ESI-000}|MOV D$? #1|'
                call ReplaceOperand 1 'D' 0
            Test_End
        .Test_End
    ..Test_End

    ..Test_If dx RegisterOperand
        .Test_If_Not dx FloatingPointOperand
            and dx ((not RegisterOperand) and 0_FFFF)
            or dx MemoryOperand
            Test_If_Not dx DWordValue
                call ExtendOperandToDWord 1 MemoryOperand
            Test_Else
                EPP_Code 'SUB ESP 04|{?? ESI-000}|MOV D$? #2|'
                call ReplaceOperand 2 'D' 0
            Test_End
        .Test_End
    ..Test_End


    ...Test_If_Not_And bx FloatingPointOperand, dx FloatingPointOperand
        ; only when the result is FP
        ..Test_If_Not_And bx ConstantOperand, dx ConstantOperand
            EPP_Code 'FILD #1|' | call incFPUStackNumber
            call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_IntegerOperand
        ..Test_Else_If_And bx ConstantOperand, dx ConstantOperand
            EPP_Code '{??:R$ #1}|FLD R$?|{??:R$ #2}|FLD R$?|' | call incFPUStackNumber
            call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST1_ST0
        ..Test_Else_If bx ConstantOperand
            EPP_Code '{??:R$ #1}|FLD R$?|' | call incFPUStackNumber
            call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_IntegerOperand
        ..Test_Else
            EPP_Code '{??:R$ #2}|FLD R$?|' | call incFPUStackNumber
            call WriteFloatingOperationInstruction D@OperationType EqualPreparser_IntegerOperand_ST0
        ..Test_End

    ...Test_Else_If bx ConstantOperand
        ..Test_If dx FloatingPointOperand
            ; #1 constant / #2 Floating Point
            ; ex: ( 51 - R$float1 )
            EPP_Code '{??:R$ #1}|'

            .Test_If dx TByteValue
                Test_If_Not dx RegisterOperand | EPP_Code 'FLD #2|' | Test_End
                call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ConstantOperand_ST0
            .Test_Else
                EPP_Code 'FLD R$?|' | call incFPUStackNumber
                call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_FloatingPointOperand
            .Test_End
        ..Test_Else
            ; #1 constant / #2 integer
            ; ex: ( 7.4 + D$val1 )
            EPP_Code '{??:R$ #1}|FLD R$?|' | call incFPUStackNumber
            call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_IntegerOperand
        ..Test_End

    ...Test_Else_If dx ConstantOperand
        ..Test_If bx FloatingPointOperand
            ; #1 Floating Point / #2 constant
            ; ex: ( T$float2 / 8 )
            EPP_Code '{??:R$ #2}|'

            .Test_If bx TByteValue
                Test_If_Not bx RegisterOperand | EPP_Code 'FLD #1|' | Test_End
                call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_ConstantOperand
            .Test_Else
                EPP_Code 'FLD R$?|' | call incFPUStackNumber
                call WriteFloatingOperationInstruction D@OperationType EqualPreparser_FloatingPointOperand_ST0
            .Test_End
        ..Test_Else
            ; #1 integer / #2 constant
            ; ex: ( D$val1 + 7.4 )
            EPP_Code '{??:R$ #2}|FLD R$?|' | call incFPUStackNumber
            call WriteFloatingOperationInstruction D@OperationType EqualPreparser_IntegerOperand_ST0
        ..Test_End

    ...Test_Else ; Both operand non-constant :
        ..Test_If_Not bx FloatingPointOperand
            ; #1 integer / #2 Floating Point
            ; ex: ( D$val2 * F$float2 )
            Test_If_Not dx RegisterOperand | EPP_Code 'FLD #2|' | call incFPUStackNumber | Test_End
            call WriteFloatingOperationInstruction D@OperationType EqualPreparser_IntegerOperand_ST0

        ..Test_Else_If_Not dx FloatingPointOperand
            ; #1 Floating Point / #2 integer
            ; ex: ( R$float1 - W$val3 )
            Test_If_Not bx RegisterOperand | EPP_Code 'FLD #1|' | call incFPUStackNumber | Test_End
            call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_IntegerOperand

        ..Test_Else
            ; #1 Floating Point / #2 Floating Point
            ; ex: ( R$float2 + F$float5 )

            .Test_If_And bx TByteValue, dx TByteValue
                Test_If_And bx RegisterOperand, dx RegisterOperand
                    call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST1_ST0
                Test_Else_If dx RegisterOperand
                    EPP_Code 'FLD #1|' | call incFPUStackNumber
                    call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_ST1
                Test_Else_If bx RegisterOperand
                    EPP_Code 'FLD #2|' | call incFPUStackNumber
                    call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST1_ST0
                Test_Else
                    EPP_Code 'FLD #1|FLD #2|' | call incFPUStackNumber
                    call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST1_ST0
                Test_End

            .Test_Else_If bx TByteValue
                Test_If_Not bx RegisterOperand | EPP_Code 'FLD #1|' | call incFPUStackNumber | Test_End
                call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_FloatingPointOperand

            .Test_Else_If dx TByteValue
                Test_If_Not dx RegisterOperand | EPP_Code 'FLD #2|' | call incFPUStackNumber | Test_End
                call WriteFloatingOperationInstruction D@OperationType EqualPreparser_FloatingPointOperand_ST0

            .Test_Else
                EPP_Code 'FLD #1|' | call incFPUStackNumber
                call WriteFloatingOperationInstruction D@OperationType EqualPreparser_ST0_FloatingPointOperand

            .Test_End

        ..Test_End
    ...Test_End

EndP
____________________________________________________________________________________________
Proc StoreResultInFirstOperand:
  ; This function store the result of the operations in the destination operand.
    Uses edx, esi, edi

    mov edi EPP_SourceEquation
    mov ebx EPP_DestOperand
    mov D$EPP_Operand1 EPP_SourceEquation | inc D$EPP_Operand1
    mov D$EPP_Operand2 EPP_DestOperand

    If D$DestinationArrayRegister = EPP_ECX
        mov edx EPP_EDI
    Else_If D$DestinationArrayRegister = EPP_EDI
        mov edx EPP_ECX
    Else
        mov edx EPP_EDI
    End_If
    call ExtractIndirectAddress 1 edx
    If eax = &TRUE
        or B$UsedRegisters dl
    End_If

    If_And W$ebx = 'SI', B$ebx+2 < Separators
        mov D$ebx 'W$ES', B$ebx+1 memMarker, B$ebx+4 'I', B$ebx+5 plusSign, B$ebx+6 '4', B$ebx+7 Space
    Else_If_And W$ebx = 'ES', B$ebx+2 = 'I', B$ebx+3 < Separators
        mov D$ebx 'D$ES', B$ebx+1 memMarker, B$ebx+4 'I', B$ebx+5 plusSign, B$ebx+6 '4', B$ebx+7 Space
    End_If

    mov D$EPP_LastStorageStatement_InMemory StrNull
    mov D$EPP_LastStorageStatement          StrNull

    .If B$ebx+1 = memMarker
        call StoreInMemory
    .Else_If B$ebx+2 = Space
        ; 2 characters destination
        If B$ebx+1 = 'H'
            jmp L1>
        Else_If B$ebx+1 = 'L'
L1:         call StoreIn8BitsRegister
        Else
            call StoreIn16BitsRegister
        End_If
        call GetRegister ebx | not al | and B$UsedRegisters al
    .Else_If B$ebx+3 = Space
        ; 3 characters destination
        If B$ebx = 'E'
            call StoreIn32BitsRegister
            call GetRegister ebx | not al | and B$UsedRegisters al
        Else_If W$ebx = 'ST'
            call StoreInFPURegister
        End_If
    .Else
        error EqualPreparser_DestInvalid
    .End_If

    EPP_Code 'POP EDX|POP EBX|POP EAX|POP ECX|POP EDI|'
    call ImmediateCodeParser D$EPP_LastStorageStatement_InMemory
    EPP_Code  'MOV ESP ESI|POP ESI|'
    call ImmediateCodeParser D$EPP_LastStorageStatement
EndP
____________________________________________________________________________________________
Proc GetRegister:
    Argument @RegisterPos
    Uses esi

    mov esi D@RegisterPos
    On B$esi = 'E', inc esi

    If B$esi = 'A'
        mov eax EPP_EAX
    Else_If B$esi = 'B'
        mov eax EPP_EBX
    Else_If B$esi = 'C'
        mov eax EPP_ECX
    Else_If W$esi = 'DI'
        mov eax EPP_EDI
    Else_If W$esi = 'SI'
        mov eax EPP_ESI
    Else_If B$esi = 'D'
        mov eax EPP_EDX
    End_If

EndP
____________________________________________________________________________________________
Proc ExtendOperandToDWord:
    Argument @Operand @type
    or B$UsedRegisters EPP_EAX

    .If D@Operand = 1
        If D@type = MemoryOperand
            EPP_Code 'SUB ESP 04|{?? ESI-000}|MOVZX EAX #1|MOV D$? EAX|'
            call ReplaceOperand 1 'D' 0
        Else
            EPP_Code 'MOVZX EAX #1|' | call ReplaceOperand 1 0 'EAX'
        End_If
    .Else
        If D@type = MemoryOperand
            EPP_Code 'SUB ESP 04|{?? ESI-000}|MOVZX EAX #2|MOV D$? EAX|'
            call ReplaceOperand 2 'D' 0
        Else
            EPP_Code 'MOVZX EAX #2|' | call ReplaceOperand 2 0 'EAX'
        End_If
    .End_If

EndP
____________________________________________________________________________________________
Proc WriteFloatingOperationInstruction:
    Arguments @OperationType @OperandsType

    .Test_If D@OperandsType EqualPreparser_ST1_ST0
        .If D@OperationType = addSign
            EPP_Code 'FADDP ST1 ST0|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FSUBP ST1 ST0|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FMULP ST1 ST0|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FDIVP ST1 ST0|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FXCH|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_ST0_ST1
        .If D@OperationType = addSign
            EPP_Code 'FADDP ST1 ST0|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FSUBRP ST1 ST0|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FMULP ST1 ST0|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FDIVRP ST1 ST0|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_IntegerOperand_ST0
        .If D@OperationType = addSign
            EPP_Code 'FIADD #1|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FISUBR #1|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FIMUL #1|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FIDIVR #1|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FILD #1|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_ST0_IntegerOperand
        .If D@OperationType = addSign
            EPP_Code 'FIADD #2|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FISUB #2|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FIMUL #2|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FIDIV #2|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FILD #2|FXCH|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_FloatingPointOperand_ST0
        .If D@OperationType = addSign
            EPP_Code 'FADD #1|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FSUBR #1|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FMUL #1|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FDIVR #1|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FLD #1|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_ST0_FloatingPointOperand
        .If D@OperationType = addSign
            EPP_Code 'FADD #2|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FSUB #2|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FMUL #2|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FDIV #2|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FLD #2|FXCH|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_ConstantOperand_ST0
        .If D@OperationType = addSign
            EPP_Code 'FADD R$?|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FSUBR R$?|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FMUL R$?|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FDIVR R$?|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FLD R$?|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else_If D@OperandsType EqualPreparser_ST0_ConstantOperand
        .If D@OperationType = addSign
            EPP_Code 'FADD R$?|'
        .Else_If D@OperationType = subSign
            EPP_Code 'FSUB R$?|'
        .Else_If D@OperationType = mulSign
            EPP_Code 'FMUL R$?|'
        .Else_If D@OperationType = divSign
            EPP_Code 'FDIV R$?|'
        .Else_If D@OperationType = expSign
            EPP_Code 'FLD R$?|FXCH|'
            EPP_Code 'FYL2X|FLD ST0|FRNDINT|FSUB ST1 ST0|'
            EPP_Code 'FLD1|FSCALE|FSTP ST1|FXCH|F2XM1|'
            EPP_Code 'FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        .End_If

    .Test_Else
        error EqualPreParser_UnexpectedError
    .Test_End

EndP
____________________________________________________________________________________________
Proc IntegratedFunctionManagement:
    ; This handle Arrays and functions, respectively manged by WriteArrayCode and WriteFunctionCode
    ; At this point, if we have: _FUNCTION_PARAMETER_
    ; D@OpeningParenthesis points on PARAMETER.
    ; #1 is set on PARAMETER and #2 is set on FUNCTION
    Argument @OpeningParenthesis
    Local @FunctionNamePos @ParameterNamePos @FunctionNameLength
    Uses ebx, ecx, edi

    mov ebx D@OpeningParenthesis
    mov D$EPP_Operand1 ebx
    mov D@ParameterNamePos ebx

    dec ebx | On ebx = EPP_SourceEquation, ExitP   ; Exit if no function name in front of the parenthesis
    On B$ebx-1 <= openSign, ExitP                  ;

    mov D@FunctionNameLength 0
    lea ecx D$ebx-1 | While B$ecx > Space | dec ecx | inc D@FunctionNameLength | End_While
    inc ecx | mov D@FunctionNamePos ecx | inc D@FunctionNameLength

    mov D$EPP_Operand2 ecx
    If B$ecx+1 = memMarker ; Arrays
        call WriteArrayCode D@FunctionNamePos D@ParameterNamePos D@FunctionNameLength

    Else ; ex: _COS_F$VAL1_
        call WriteFunctionCode D@FunctionNamePos D@FunctionNameLength

    End_If

EndP
____________________________________________________________________________________________
Proc WriteArrayCode:
    Arguments @ArrayNamePos @ParameterNamePos @FunctionNameLength
    ; we have: _X$ARRAY_PARAMETER_
    ; #1 points on PARAMETER and #2 points on X$ARRAY

    mov ecx D@ArrayNamePos
    mov ebx D@ParameterNamePos

    call GetStringType D$EPP_Operand1
    ..Test_If ax MemoryOperand ; _F$TBL_D$AAAAAAAA_ ;  _F$_D$MyVal
        If_Or B$ebx = 'B', B$ebx = 'W'
            call ExtendOperandToDWord 1 RegisterOperand | jmp L1>
        Else_If B$ebx = 'D'
L1:         On B$ecx+2 <> Space, call WriteAddressingCode D$ecx
            call EraseArrayName D@FunctionNameLength

        Else ; index is not an integer
             error EqualPreparser_InvalidIndex
        End_If

    ..Test_Else_If ax RegisterOperand  ; _F$ARRAY_ECX_
        If B$ecx+2 <> Space ; if not an expression
            On B$ecx = 'T', jmp L1<<
            mov B$ebx-1 plusSign
            Test_If ax DWordValue
                lea edi D$ebx+3 | call shiftLineRight 2         ; _F$ARRAY_ECX_  => _F$ARRAY+ECX*4_
                mov B$ebx+3 addressSign
                call GetAddressingCoef ecx | mov B$ebx+4 al
            Test_Else
                lea edi D$ebx+2 | call shiftLineRight 2         ; _W$ARRAY_CL_   => _W$ARRAY+CL*2_
                mov B$ebx+2 addressSign
                call GetAddressingCoef ecx | mov B$ebx+3 al
            Test_End
        Else ; F$_ECX  ; D$_EDI
            mov edi ebx | call shiftLineLeft 1
        End_If

    ..Test_Else_If ax NumericOperand  ; _F$ARRAY_2_
        .If B$ecx+2 <> Space ; if not an expression
            On B$ecx = 'T', jmp L1<<
            If B$ebx-2 <> plusSign                     ; first step  : _F$ARRAY_13_ => _F$ARRAY+_(_13_*_4_)_
                mov B$ebx-1 plusSign
                mov edi ebx | call shiftLineRight 3
                mov B$ebx Space | mov B$ebx+1 openSign | mov B$ebx+2 Space

                add ebx 3 | While B$ebx > Space | inc ebx | End_While | inc ebx

                mov edi ebx | call shiftLineRight 6

                mov B$ebx mulSign | mov B$ebx+1 Space | call GetAddressingCoef ecx | mov B$ebx+2 al
                mov B$ebx+3 Space | mov B$ebx+4 closeSign | mov B$ebx+5 Space

            Else                                       ; second step : _F$ARRAY+_52_ => _F$ARRAY+52_
                mov edi ebx | call shiftLineLeft 1
            End_If
        .Else ; F$_1  ; D$_2254
            error EqualPreparser_InvalidAddress
        .End_If

    ..Test_Else
        error EqualPreparser_InvalidIndex

    ..Test_End

EndP
____________________________________________________________________________________________
Proc EraseArrayName:
    Argument @FunctionNameLength

    mov edi D$EPP_Operand1
    mov ecx D@FunctionNameLength | sub ecx 2
    call ShiftLineLeft ecx

EndP
____________________________________________________________________________________________
Proc LoadOperandOnTOS:
    ;This writes the code which load the D@Operand (1 or 2) on the Top of the FPU Stack.
    Arguments @Operand
    Uses ebx, ecx

    If D@Operand = 1
        mov ebx D$EPP_Operand1
        mov cx '#1'
    Else
        mov ebx D$EPP_Operand2
        mov cx '#2'
    End_If

    .If B$ebx+1 = memMarker
        If_Or B$ebx = 'T', B$ebx = 'F', B$ebx = 'R'
            EPP_Code 'FLD ' cx '|' | call incFPUStackNumber
        Else_If B$ebx = 'B'
            call ExtendOperandToDWord 1 MemoryOperand
            EPP_Code 'FILD ' cx '|' | call incFPUStackNumber
        Else  ;  others integer
            EPP_Code 'FILD ' cx '|' | call incFPUStackNumber
        End_If
    .Else_If W$ebx = 'st'
        ; result is already on TOS

    .Else ; constant
        call IsARegister ebx
        Test_If ax (ByteValue or WordValue)
            call ExtendOperandToDWord 1 MemoryOperand
            EPP_Code 'FILD ' cx '|'
        Test_Else_If ax DWordValue
            EPP_Code 'SUB ESP 04|{?? ESI-000}|MOV D$? ' cx '|FILD D$?|'
        Test_Else
            EPP_Code '{??:R$ ' cx '}|FLD R$?|' | call incFPUStackNumber
        Test_End

    .End_If

EndP
____________________________________________________________________________________________
Proc IsARegister:
    ; Returns &FALSE if D@pos does NOT points on a register (it can be terminated by EOI,meEOI,Space or &NULL)
    ; Otherwise returns '(RegisterOperand OR SizeOp)' with SizeOp, the size of the register.
    ; (which can be ByteValue,WordValue,DWordValue,FloatingPointOperand+TByteValue)
    Argument @pos
    Uses esi

    mov eax &FALSE
    mov esi D@pos
    ..If B$esi+2 <= Space
        .If_Or B$esi+1 = 'H', B$esi+1 = 'L'
            If_And B$esi >= 'A', B$esi <= 'D'
                mov eax (RegisterOperand or ByteValue)
            End_If

        .Else_If_Or W$esi = 'AX', W$esi = 'BX', W$esi = 'CX', W$esi = 'DX',
                    W$esi = 'BP', W$esi = 'DI', W$esi = 'SI'
            mov eax (RegisterOperand or WordValue)
        .End_If

    ..Else_If B$esi+3 <= Space
        .If B$esi = 'E'
            If_Or W$esi+1 = 'AX', W$esi+1 = 'BX', W$esi+1 = 'CX', W$esi+1 = 'DX',
                  W$esi+1 = 'BP', W$esi+1 = 'DI', W$esi+1 = 'SI'
                mov eax (RegisterOperand or DWordValue)
            End_If
        .Else_If_Or W$esi = 'ST', W$esi = 'st'
            ; 'st' is for temporary results stored on the FPU Stack (See incFPUStackNumber)
            If_And B$esi+2 >= '0', B$esi+2 <= '7'
                mov eax (RegisterOperand or FloatingPointOperand or TByteValue)
            End_If
        .End_If
    ..End_If

EndP
____________________________________________________________________________________________
Proc GetAddressingCoef:
    ; returns in al the corresponding size of D@SizeMarkerPos
    Argument @SizeMarkerPos
    Uses ecx

    mov ecx D@SizeMarkerPos
    .If B$ecx = 'B'
        mov al '1'
    .Else_If B$ecx = 'R'
        mov al '8'
    .Else_If B$ecx = 'F'
        mov al '4'
    .Else_If B$ecx = 'D'
        mov al '4'
    .Else_If B$ecx = 'W'
        mov al '2'
    .Else_If B$ecx = 'Q'
        mov al '8'
    .End_If
EndP
____________________________________________________________________________________________
Proc WriteFunctionCode:
    ;Set the result of the operations on the FPU Stack and compute the function
    ; we have: _FUNCTION_PARAMETER_
    ; #1 points on PARAMETER and #2 points on FUNCTION
    Arguments @FunctionNamePos @FunctionNameLength

    .If_str D@FunctionNamePos = 'COS'
        call LoadOperandOnTOS 1
        EPP_Code 'FCOS|'
        call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'SIN'
        call LoadOperandOnTOS 1
        EPP_Code 'FSIN|'
        call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'TAN'
        call LoadOperandOnTOS 1
        EPP_Code 'FPTAN|FINCSTP|FFREE ST7|'
        call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'ABS'
        call LoadOperandOnTOS 1
        EPP_Code 'FABS|'
        call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'SQRT'
        call LoadOperandOnTOS 1
        EPP_Code 'FSQRT|'
        call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'LOG10'
        EPP_Code 'FLDLG2|' | call incFPUStackNumber
        call LoadOperandOnTOS 1
        EPP_Code 'FYL2X|' | call decFPUStackNumber
        call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'LOG2'
        EPP_Code 'FLD1|' | call incFPUStackNumber
        call LoadOperandOnTOS 1
        EPP_Code 'FYL2X|' | call decFPUStackNumber
        call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'LN'
        EPP_Code 'FLDLN2|' | call incFPUStackNumber
        call LoadOperandOnTOS 1
        EPP_Code 'FYL2X|' | call decFPUStackNumber
        call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'ATAN'
        call LoadOperandOnTOS 1
        EPP_Code 'FLD1|'
        EPP_Code 'FPATAN|'
        call StoreFPUResult 1

    .Else_If_str D@FunctionNamePos = 'EXP'
        call LoadOperandOnTOS 1
        EPP_Code 'FLDL2E|FMULP ST1 ST0|FLD ST0|FRNDINT|FSUB ST1 ST0|FLD1|'
        EPP_Code 'FSCALE|FSTP ST1|FXCH|F2XM1|FLD1|FADDP ST1 ST0|FMULP ST1 ST0|'
        call StoreFPUResult 1

    .Else
        error EqualPreparser_InvalidFunction
    .End_If


    mov edi D$EPP_Operand1 | call ShiftLineLeft D@FunctionNameLength ; erase function name

EndP
____________________________________________________________________________________________
Proc UpdateLocalDataShift:
    Local @LocalDataShift @RegisterLetter

    mov D@LocalDataShift 0
    mov ecx D$EPP_CodeBegining
    mov ebx &FALSE


    EPP_FindCodePos 'MOV ESI ESP'  EPP_CODE_BEGIN EPP_CODE_END
    jmp L1>
    .While eax <> CODE_NOT_FOUND
        add D@LocalDataShift 4 | inc eax

L1:     EPP_FindCodePos 'PUSH' eax EPP_CODE_BEGIN EPP_CODE_END
    .End_While

    jmp L1>>
    .While eax <> CODE_NOT_FOUND
        mov ebx &TRUE
        mov esi D$EPP_SearchedStringAddress
        If B$esi+2 < Separators
            mov al B$esi+1 | sub al '0' | On al > 9 , sub al 7
        Else
            mov al B$esi+1 | sub al '0' | On al > 9 , sub al 7 | shl al 4
            mov ah B$esi+2 | sub ah '0' | On ah > 9 , sub ah 7
            add al ah
        End_If
        movzx edx al | add D@LocalDataShift edx

        EPP_FindCodePos 'ESI-' ecx EPP_CODE_END | add eax 5 | mov ecx eax
        ; We always have 'SUB ESP &0|{&1 ESI-0xx}|'
        If D@LocalDataShift < 010
            mov al B@LocalDataShift | add al '0' | On al > '9', add al 7
            mov B$ecx al
            lea edi D$ecx+2 | call ShiftLineLeft 1
        Else_If D@LocalDataShift > 0FF
            error EqualPreparser_LocalStackOverflow
        Else
            mov al B@LocalDataShift
            mov ah al | and ah 0F | shr al 4
            add ah '0' | On ah > '9', add ah 7 | mov B$ecx+1 ah
            add al '0' | On al > '9', add al 7 | mov B$ecx   al
        End_If


L1:     EPP_FindCodePos 'SUB ESP &0' ecx EPP_CODE_END | mov ecx eax
    .End_While

    .If ebx = &FALSE
        EPP_ReplaceCode 'PUSH ESI|MOV ESI ESP'  0           EPP_CODE_BEGIN EPP_CODE_END
        EPP_ReplaceCode 'MOV ESP ESI|POP ESI'   0           EPP_CODE_BEGIN EPP_CODE_END
        EPP_ReplaceCode 'D$ESI+4'               'ESI'       EPP_CODE_BEGIN EPP_CODE_END
        EPP_ReplaceCode 'MOV &1 D$ESI-??'       0           EPP_CODE_BEGIN EPP_CODE_END

    .End_If

EndP
____________________________________________________________________________________________
Proc ReplaceCodeMacroProc:
    Arguments @CodeToReplace @CodeReplacement @Begin @End
    Uses ebx

    jmp L1>
    While eax <> CODE_NOT_FOUND
        call ReplaceCodeProc eax D@CodeReplacement ebx

L1:     call FindCodePosProc D@CodeToReplace D@Begin D@End
    End_While

EndP
____________________________________________________________________________________________
Proc ReplaceCodeProc:
    ; This procedure replaces the code at D@CodeToReplacePos by D@CodeReplacement.
    ; D@CodeLength is the length of the code to be replaced.
    ; In D@CodeReplacement two specials characters can be used :
    ;   - '!n' which is replaced by the a single characters and '&n' by an instruction/operand
    ;       (with n a digit between 1 and 9)
    ;       See FindCodePosProc for more information about theses internal variables.
    Arguments @CodeToReplacePos @CodeReplacement @CodeLength
    USes esi edi ecx

    mov edi EPP_ReplacementBuffer
    mov esi D@CodeReplacement

    mov ecx 0
    lodsb
    ..While al <> 0
        inc ecx
        .If al = '!'
            movzx edx B$esi | sub edx '0' | inc esi
            mov al B$EPP_SearchedSingleCharacter+edx

        .Else_If al = '&'
            movzx edx B$esi | sub edx '0' | inc esi | shl edx 2
            push esi
                mov esi D$EPP_SearchedStringAddress+edx
                .While B$esi > LowSigns
                    movsb  | inc ecx
                    While B$esi = memMarker | movsb | End_While
                    On B$esi = '}', jmp L2>
                .End_While
                dec ecx
L2:         pop esi
            dec edi | mov al B$edi
        .Else_If al = ' '
            mov al Space
        .Else_If al = '$'
            mov al memMarker
        .Else_If al = '|'
            If B$esi = '|'
                mov al EOI | inc esi
            Else
                mov al meEOI
            End_If
        .End_If
        stosb

        lodsb
    ..End_While
    mov B$edi 0

    On ecx = 0, inc D@CodeLength
    mov edi D@CodeToReplacePos | add edi D@CodeLength
    call ShiftLineLeft D@CodeLength
    mov eax D@CodeLength | sub D$EPP_WrittenCode eax
    mov edi D@CodeToReplacePos
    call ShiftLineRight ecx
    add D$EPP_WrittenCode ecx

    mov esi EPP_ReplacementBuffer
    While B$esi <> 0 | movsb | End_While

EndP
____________________________________________________________________________________________
Proc FindCodePosProc:
    ; Returns: - in eax the position of D@CodeToFind between D@Begin and D@End
    ;          - in ebx the length of the code found.
    ; and CODE_NOT_FOUND otherwise.
    ; In D@CodeToFind the following specials characters are used :
    ;   - '?'  means 'any character'
    ;   - '!n' represents a single character which must be the same each timle it appears.
    ;          (n is a number between 0 and 9)
    ;   - '&n' represents a mnemonic or an operand '}'/Space/meEOI/EOI-terminated which must be the same
    ;          each time it appears. (n is a number between 0 and 9)
    ;   '&n' and '!n' internal variables are re-initialized each time this procedure is called, so that
    ;   they can be used by a call to ReplaceCodeProc right after this procedure.
    ;
    ; - D@Begin can be:
    ;   * EPP_CODE_BEGIN   : to search up from the beginning of the produced code(in one Equal line).
    ;   * EPP_SOURCE_BEGIN : to search up from the beginning of the produced code(in one Equal line).
    ;
    ; - D@End can be:
    ;   * EPP_CODE_END   : to search up to the end of the produced code(in one Equal line).
    ;   * EPP_SOURCE_END : to search up to the end of the produced code(in one Equal line).
    ;
    ; This function must be called BEFORE TranslateExpressions
    Arguments  @CodeToFind @Begin @End
    Local @FirstCharPos @result
    Uses ecx, esi, edi, edx

    On D@Begin = EPP_CODE_BEGIN, move D@Begin D$EPP_CodeBegining
    On D@End   = EPP_CODE_END  , move D@End   D$EPP_WrittenCode
    On D@Begin = EPP_SOURCE_BEGIN, move D@Begin EPP_SourceEquation
    If D@End   = EPP_SOURCE_END
        mov ecx EPP_SourceEquation
        While B$ecx <> EOI | inc ecx | End_While
        mov D@End ecx
    End_If

    mov ecx D@End | sub ecx D@Begin
    Test_If ecx 0_8000_0000  ; (D$EPP_WrittenCode - D@From) < 0   ==>   ExitP
        mov eax CODE_NOT_FOUND
        ExitP
    Test_End

    mov D@FirstCharPos &FALSE
    mov D@result CODE_NOT_FOUND
    mov esi D@CodeToFind
    mov edi D@Begin
    mov ebx 0
    call InitSearchVariables

    ..While ecx >s 0
        lodsb | inc ebx
        ..If al = ' '
            mov al Space
        ..Else_If al = '?'
            mov al B$edi
        ..Else_If al = '$'
            mov al memMarker
        ..Else_If al = ':'
            mov al colonSign
        ..Else_If al = '-'
            mov al minusSign
        ..Else_If al = '+'
            mov al plusSign
        ..Else_If al = '*'
            mov al addressSign
        ..Else_If al = '|'
            If B$esi = '|'
                mov al EOI | inc esi
            Else
                mov al meEOI
            End_If
        ..Else_If al = '!'
            movzx edx B$esi | sub edx '0' | inc esi
            If B$EPP_SearchedSingleCharacter+edx = 0
                mov al B$edi
                mov B$EPP_SearchedSingleCharacter+edx al
            Else
                mov al B$EPP_SearchedSingleCharacter+edx
            End_If
        ..Else_If al = '&'
            movzx edx B$esi | sub edx '0' | inc esi | shl edx 2
            .If D$EPP_SearchedStringAddress+edx = 0
                mov D$EPP_SearchedStringAddress+edx edi
                .While B$edi > LowSigns
                    inc edi | inc ebx
                    While B$edi = memMarker | inc edi | inc ebx | End_While
                    On B$edi = '}', jmp L2>
                .End_While
L2:             dec edi ebx | mov al B$edi
            .Else
                call CompareCode edi D$EPP_SearchedStringAddress+edx
                If eax = &TRUE
                    .While B$edi > LowSigns
                        inc edi | inc ebx
                        While B$edi = memMarker | inc edi | inc ebx | End_While
                        On B$edi = '}', jmp L2>
                    .End_While
L2:                 dec edi ebx | mov al B$edi
                Else
                    mov D@FirstCharPos &TRUE
                    mov al 0
                End_If
            .End_If

        ..Else_If al = 0
            move D@result D@FirstCharPos
            jmp L5>
        ..End_If

        .If D@FirstCharPos <> &FALSE
            If B$edi <> al
                mov D@FirstCharPos &FALSE
                mov esi D@CodeToFind
                call InitSearchVariables
            Else
                inc edi
            End_If
        .Else
            repne scasb
            mov D@FirstCharPos edi | dec D@FirstCharPos
            mov ebx 0
        .End_If

    ..End_While
L5: mov eax D@result

EndP
____________________________________________________________________________________________
Proc CompareCode:
    ; returns &TRUE if D@Code1 and D@Code2 points on identicals mnemonics or operands ('}'/Space/meEOI/EOI-terminated)
    Arguments @Code1 @Code2
    Uses esi edi

    mov esi D@Code1
    mov edi D@Code2

    lodsb
    .While al = B$edi
        inc edi
        .If_And B$esi < LowSigns, B$edi < LowSigns, B$esi <> memMarker, B$edi <> memMarker
            mov eax &TRUE  | ExitP
        .Else_If_And  B$esi = 125 , B$edi = 125 ; 125 = '}'
            mov eax &TRUE | ExitP
        .Else_If_And  B$esi < LowSigns, B$edi = 125, B$esi <> memMarker
            mov eax &TRUE | ExitP
        .Else_If_And  B$edi < LowSigns, B$esi = 125, B$edi <> memMarker
            mov eax &TRUE | ExitP
        .Else_If_Or  B$esi = 125 , B$edi = 125
            mov eax &FALSE | ExitP
        .Else_If_And B$esi < LowSigns, B$esi <> memMarker
            mov eax &FALSE | ExitP
        .Else_If_And  B$edi < LowSigns, B$edi <> memMarker
            mov eax &FALSE | ExitP
        .End_If
        lodsb
    .End_While
    mov eax &FALSE

EndP
____________________________________________________________________________________________
InitSearchVariables:
    push ecx
        mov ecx 0
        While ecx < SEARCH_VARIABLE_NUMBER
            mov B$EPP_SearchedSingleCharacter+ecx 0
            mov D$EPP_SearchedStringAddress+ecx*4   0
            inc ecx
        End_While
    pop ecx
ret
____________________________________________________________________________________________
Proc DeleteCodeLine:
    ; Delete a code line while parsing. (the end of the source is D$EPP_WrittenCode)
    Argument @LinePos
    Uses ecx, edi

    mov edi D$EPP_WrittenCode | inc edi
    call DeleteFinalCodeLine D@LinePos edi | sub edi eax
    mov D$EPP_WrittenCode edi

EndP
____________________________________________________________________________________________
Proc DeleteFinalCodeLine:
    ; LinePos point on the beginning of a code line (after meEOI or EOI)
    ; returns the number of characters deleted.
    Arguments @LinePos @EndOfSource
    Uses ecx, esi, edi

    mov edi D@LinePos
    mov esi D@LinePos | While B$esi > EOI | inc esi | End_While
    mov eax esi | sub eax D@LinePos | inc eax
    mov ecx D@EndOfSource
    If_And B$esi = EOI, B$edi-1 = meEOI
        dec edi | dec ecx
    Else
        inc esi
    End_If
    sub ecx esi
    rep movsb

    ; reset to 0 the end of the source (needed for the macros unfolding)
    mov ecx D@EndOfSource | sub ecx eax
    While ecx < D@EndOfSource | mov B$ecx 0 | inc ecx | End_While

EndP
____________________________________________________________________________________________
Proc OptimizeEqualPreparserCode:
    Arguments @From @To

    Test_If_Not B$UsedRegisters EPP_EAX
        EPP_ReplaceCode 'PUSH EAX' 0 D@From  D@To
        EPP_ReplaceCode 'POP EAX'  0 D@From  D@To
    Test_End

    Test_If_Not B$UsedRegisters EPP_EBX
        EPP_ReplaceCode 'PUSH EBX' 0 D@From  D@To
        EPP_ReplaceCode 'POP EBX'  0 D@From  D@To
    Test_End

    Test_If_Not B$UsedRegisters EPP_ECX
        EPP_ReplaceCode 'PUSH ECX' 0 D@From  D@To
        EPP_ReplaceCode 'POP ECX'  0 D@From  D@To
    Test_End

    Test_If_Not B$UsedRegisters EPP_EDX
        EPP_ReplaceCode 'PUSH EDX' 0 D@From  D@To
        EPP_ReplaceCode 'POP EDX'  0 D@From  D@To
    Test_End

    Test_If_Not B$UsedRegisters EPP_ESI
        EPP_ReplaceCode 'PUSH ESI' 0 D@From  D@To
        EPP_ReplaceCode 'POP ESI'  0 D@From  D@To
    Test_End

    Test_If_Not B$UsedRegisters EPP_EDI
        EPP_ReplaceCode 'PUSH EDI' 0 D@From  D@To
        EPP_ReplaceCode 'POP EDI'  0 D@From  D@To
    Test_End


    EPP_ReplaceCode 'SUB ESP &0|{&1 ESI?&2}|MOV ?$&1 &3|MOV &4 ?$&1',
                    'MOV &4 &3',
                    D@From D@To


    EPP_ReplaceCode 'SUB ESP &0|{&1 ESI?&2}|MOV ?$&1 &3|PUSH ?$&1',
                    'PUSH &3',
                    D@From D@To


    EPP_ReplaceCode 'SUB ESP &0|{&1 ESI-&2}|MOV D$&1 &3|POP &4|MOV &5 D$&1',
                    'MOV &5 &3|POP &4',
                    D@From D@To

    EPP_ReplaceCode 'MOV &1 &1',
                    0,
                    D@From D@To

    EPP_ReplaceCode 'SUB ESP &0|{&1 ESI?&2}|FSTP ?$&1|FLD ?$&1',
                    0,
                    D@From D@To


EndP
____________________________________________________________________________________________
Proc EqualFirstScan:
    ; Replaces each register by a meaningless label and writes the code that copies its value in the memory.
    ; D@SecondPass is true when we are computing the address of an array.
    Argument @SecondPass

    mov B$FPUInSourceExpression &FALSE
    mov B$UsedRegisters  EPP_ESI

    ; identify destination type
    call GetStringType EPP_DestOperand
    mov D$DestinationType eax

    If D@SecondPass = &FALSE
        EPP_Code 'PUSH ESI|MOV ESI ESP|PUSH EDI|PUSH ECX|PUSH EAX|PUSH EBX|PUSH EDX|'
    Else
        ;...
    End_If

    Test_If_And D$DestinationType RegisterOperand, D$DestinationType FloatingPointOperand
        EPP_Code 'SUB ESP 06C|{&7 ESI-000}|FSAVE X$!7|FINIT|'
    Test_End

    mov esi EPP_SourceEquation
    .While B$esi > EOI
        mov D$EPP_Operand1 esi
        call GetStringType esi
        ...Test_If eax RegisterOperand
            ..Test_If_Not D$NoOperation &TRUE
                .Test_If eax ByteValue
                    EPP_Code 'SUB ESP 01|{?? ESI-000}|MOV B$? #1|'
                    call ReplaceOperand 1 'B' 0
                .Test_Else_If eax WordValue
                    If W$esi = 'SI'
                        EPP_Code '{?? ESI}|'
                        call ReplaceOperand 1 'W' 0
                    Else
                        EPP_Code 'SUB ESP 02|{?? ESI-000}|MOV W$? #1|'
                        call ReplaceOperand 1 'W' 0
                    End_If
                .Test_Else_If eax DWordValue
                    If_And W$esi = 'ES', B$esi+2 = 'I'
                        EPP_Code '{?? ESI}|'
                        call ReplaceOperand 1 'D' 0
                    Else
                        EPP_Code 'SUB ESP 04|{?? ESI-000}|MOV D$? #1|'
                        call ReplaceOperand 1 'D' 0
                    End_If
                .Test_End
            ..Test_Else
                Test_If eax FloatingPointOperand
                    EPP_Code 'SUB ESP 0A|{?? ESI-000}|FLD #1|FSTP T$?|'
                    call ReplaceOperand 1 'T' 0
                    mov B$FPUInSourceExpression &TRUE
                Test_End
            ..Test_End
        ...Test_End
        While B$esi > Space | inc esi | End_While | inc esi ; jump to next space
    .End_While


EndP
____________________________________________________________________________________________
FormatEqualLine:
; - Surrounds each parenthesis and operator by two spaces and performs a slight error processing.
; - Minus signs in front of numeric operands are replaced by minusSign
; - When '.' is a floating point (i.e not in a user-label) then it is replaced by pointSign
; - if an operator is doubled (**,//), it is replaced by its signed equivalent (SignedMulSign,SignedDivSign)

    mov B$NoOperation &TRUE
    mov esi EPP_SourceEquation
    .While B$esi > EOI
        ..If B$esi = openSign
            .If B$esi+1 = subSign   ; '(-9', '(-1'   OK
                If_And B$esi+2 >= '0', B$esi+2 <= '9'
                    mov B$esi+1 minusSign
                    call SourroundCurrentSign
                    inc esi
                Else
                    error EqualPreparser_OperatorsInvalid
                End_If
            .Else_If_And B$esi+1 < openSign, B$esi+1 <> Space
                error EqualPreparser_OperatorsInvalid
            .Else
                call SourroundCurrentSign
            .End_If

        ..Else_If B$esi =  closeSign   ; ')+',')/', etc..   OK
            If B$esi+1 > closeSign
                error EqualPreparser_OperatorsInvalid
            Else
                call SourroundCurrentSign
            End_If

        ..Else_If_And B$esi < OperatorSigns, B$esi > Separators
            mov B$NoOperation &FALSE
            mov al B$esi
            .If B$esi+1 = subSign          ; ...  +-7 ...  OK
                If_And B$esi+2 >= '0', B$esi+2 <= '9'
                    mov B$esi+1 minusSign
                    call SourroundCurrentSign
                    inc esi
                Else
                    error EqualPreparser_OperatorsInvalid
                End_If
            .Else_If B$esi+1 = al
                lea edi D$esi+1  | call ShiftLineLeft 1       ; delete the doubled operator
                On al = mulSign, mov B$esi SignedMulSign
                On al = divSign, mov B$esi SignedDivSign
                call SourroundCurrentSign

            .Else_If B$esi+1 < openSign
                error EqualPreparser_OperatorsInvalid
            .Else
                call SourroundCurrentSign
            .End_If

        ..Else_If B$esi = '.'
            If_And B$esi+1 >= '0', B$esi+1 <= '9', B$esi-1 >= '0', B$esi-1 <= '9'
                mov B$esi pointSign
            End_If
            inc esi

        ..Else
            inc esi
        ..End_If
    .End_While

ret
                                                ____________________________
SourroundCurrentSign:
    mov edi esi
    mov al B$esi
    .If B$esi-1 = Space
        If B$esi+1 <> Space     ; adds one space after the operator
            call ShiftLineRight 1
            mov B$esi+1 Space
        End_If
        add esi 2
    .Else_If B$esi+1 = Space    ; adds one space before the operator
        call ShiftLineRight 1
        mov B$esi   Space
        add esi 3
    .Else                       ; adds two spaces
        call ShiftLineRight 2
        mov B$esi     Space
        mov B$esi+1   al
        mov B$esi+2   Space
        add esi 3
    .End_If

ret
____________________________________________________________________________________________
____________________________________________________________________________________________
Proc ComputeImmediateExpression:
; This function computes immediates operations between constants.
; D@OperationType may be one of these (addSign,subSign,mulSign,divSign,expSign)
    Argument @OperationType
    Local @ValueExponent @temp
    Uses ecx, esi, edi
    finit
    call AsciiToFloat D$EPP_Operand1 0    | On eax = &FALSE, error EqualPreparser_InvalidFPValue
    call AsciiToFloat D$EPP_Operand2 0    | On eax = &FALSE, error EqualPreparser_InvalidFPValue

    On D@OperationType = addSign, fadd  ST0 ST1
    On D@OperationType = subSign, fsubr ST0 ST1
    On D@OperationType = mulSign, fmul  ST0 ST1
    On D@OperationType = divSign, fdivr ST0 ST1
    If D@OperationType = expSign
        fxch | fyl2x | fld ST0 | frndint | fsub ST1 ST0
        fld1 | fscale | fstp ST1 | fxch | f2xm1
        fld1 | faddp ST1 ST0 | fmulp ST1 ST0
    End_If

    fstp T$EPP_ImmediateResult
    call FloatToUString EPP_ImmediateResult EPP_ImmediateResultString

    .If_str EPP_ImmediateResultString = 'INF'
        jmp L1>>
    .Else_If_str EPP_ImmediateResultString = 'SNaN'
        jmp L1>>
    .Else_If_str EPP_ImmediateResultString = 'QNaN'
        jmp L1>
    .Else_If_str EPP_ImmediateResultString = '-SNaN'
        jmp L1>
    .Else_If_str EPP_ImmediateResultString = '-QNaN'
        jmp L1>
    .Else_If_str EPP_ImmediateResultString = '-INF'
L1:     error EqualPreparser_InvalidImmVal
    .Else
        mov esi EPP_ImmediateResultString
        mov ecx 0
        While B$esi <> 0
            If B$esi = '.'
                mov B$esi pointSign
            Else_If B$esi = 'e'
                mov B$esi 'E'
            Else_If B$esi = '+'
                mov B$esi plusSign
            Else_If B$esi = '-'
                mov B$esi minusSign
            End_If
            inc esi, ecx
        End_While
        call ReplaceOperand 0 0 ' '
        mov edi D$EPP_Operand1 | inc edi | dec ecx
        call ShiftLineRight ecx
        mov esi EPP_ImmediateResultString
        mov edi D$EPP_Operand1
        While B$esi <> 0 | movsb | End_While
    .End_If

EndP
____________________________________________________________________________________________
StoreInMemory:

    ...If_Or B$ebx = 'T', B$ebx = 'R', B$ebx = 'F'
    ;
    ; -> FIRST OPERAND IS FLOATING POINT (T$,R$ or F$):
    ;
        ..If B$edi+2 = memMarker
        ; second operand is memory data
            .If B$edi+1 = 'B'
                call ExtendOperandToDWord 1 MemoryOperand
                jmp L1>
            .Else_If_Or B$edi+1 = 'D', B$edi+1 = 'Q', B$edi+1 = 'W'
L1:             EPP_Code 'FILD #1|FSTP #2|'

            .Else_If_Or B$edi+1 = 'T', B$edi+1 = 'R', B$edi+1 = 'F'
                EPP_Code 'FLD #1|FSTP #2|'
            .End_If

        ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
            EPP_Code 'FSTP #2|'

        ..Else
        ; second operand is a single register, an integer number or an Equate
            lea eax D$edi+1 | call IsARegister eax
            Test_If ax (ByteValue or WordValue)
                EPP_Code 'SUB ESP 04|{?? ESI-000}|MOVZX EAX #1|MOV D$? EAX|FILD D$?|FSTP #2|'
            Test_Else_If ax DWordValue
                EPP_Code 'SUB ESP 04|{?? ESI-000}|MOV D$? #1|FILD D$?|FSTP #2|'
            Test_Else
                EPP_Code '{??:R$ #1}|FLD R$?|FSTP #2|'
            Test_End
        ..End_If
    ;
    ; -> FIRST OPERAND IS INTEGER :
    ;
    ...Else_If B$ebx = 'B'
    ; BYTE
        ..If B$edi+2 = memMarker
            .If B$edi+1 = 'B'
                EPP_Code 'MOV AL #1|MOV #2 AL|' | or B$UsedRegisters EPP_EAX
            .Else
                error EqualPreparser_SourceInvalid
            .End_If

        ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
            error EqualPreparser_SourceInvalid

        ..Else
        ; second operand is a single register, an integer number or an Equate
            lea eax D$edi+1 | call IsARegister eax
            If ax <> &FALSE
                Test_If_Not ax ByteValue | error EqualPreparser_SourceInvalid | Test_End
            End_If
            EPP_Code 'MOV #2 #1|'
        ..End_If

    ...Else_If B$ebx = 'W'
    ; WORD
        ..If B$edi+2 = memMarker
            .If B$edi+1 = 'B'
                EPP_Code 'MOVZX AX #1|MOV #2 AX|' | or B$UsedRegisters EPP_EAX
            .Else_If B$edi+1 = 'W'
                EPP_Code 'MOV AX #1|MOV #2 AX|' | or B$UsedRegisters EPP_EAX
            .Else_If_Or B$edi+1 = 'T', B$edi+1 = 'R', B$edi+1 = 'F'
                EPP_Code 'FLD #1|FISTP #2|'
            .Else
                error EqualPreparser_SourceInvalid
            .End_If

        ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
            EPP_Code 'FISTP #2|'

        ..Else
        ; second operand is a single register, an integer number or an Equate
            lea eax D$edi+1 | call IsARegister eax
            If ax <> &FALSE
                Test_If_Not ax (ByteValue or WordValue) | error EqualPreparser_SourceInvalid | Test_End
            End_If
            Test_If ax ByteValue
                EPP_Code 'MOVZX #2 #1|'
            Test_Else
                EPP_Code 'MOV #2 #1|'
            Test_End
        ..End_If

    ...Else_If B$ebx = 'Q'
    ; QWORD
        ..If B$edi+2 = memMarker
            .If B$edi+1 = 'Q'
                mov B$edi+1 'D'  ; the QWORD is moved in two steps, DWord by DWord
                mov B$ebx   'D'
                EPP_Code 'PUSH #1|POP #2|PUSH #1+4|POP #2+4|'

            .Else_If_Or B$edi+1 = 'B', B$edi+1 = 'W'
                call ExtendOperandToDWord 1 RegisterOperand
                jmp L1>
            .Else_If B$edi+1 = 'D'
L1:             mov B$ebx 'D'
                EPP_Code 'PUSH #1|POP #2|MOV #2+4 0|'

            .Else_If_Or B$edi+1 = 'T', B$edi+1 = 'R', B$edi+1 = 'F'
                EPP_Code 'FLD #1|FISTP #2|'

            .Else
                error EqualPreparser_SourceInvalid
            .End_If

        ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
            EPP_Code 'FISTP #2|'

        ..Else
        ; second operand is a single register, an integer number or an Equate
            lea eax D$edi+1 | call IsARegister eax
            Test_If ax ByteValue
                mov B$ebx 'B'
            Test_Else_If ax WordValue
                mov B$ebx 'W'
            Test_Else
                mov B$ebx 'D'
            Test_End
            EPP_Code 'MOV #2 #1|MOV #2+4 0|'
        ..End_If

    ...Else_If B$ebx = 'D'
    ; DWORD
        ..If B$edi+2 = memMarker
        ; second operand is memory data
            .If_Or B$edi+1 = 'B', B$edi+1 = 'W'
                call ExtendOperandToDWord 1 RegisterOperand
                jmp L1>
            .Else_If B$edi+1 = 'D'
L1:             EPP_Code 'PUSH #1|POP #2|'
            .Else_If_Or B$edi+1 = 'T', B$edi+1 = 'R', B$edi+1 = 'F'
                EPP_Code 'FLD #1|FISTP #2|'
            .Else
                error EqualPreparser_SourceInvalid
            .End_If

        ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
            EPP_Code 'FISTP #2|'

        ..Else
        ; second operand is a single register, an integer number or an Equate
            lea eax D$edi+1 | call IsARegister eax
            Test_If ax (ByteValue or WordValue)
                EPP_Code 'MOVZX #2 #1|'
            Test_Else
                EPP_Code 'MOV #2 #1|'
            Test_End
        ..End_If

    ...Else
    ; Invalid data identifier
        error EqualPreparser_DestInvalid
    ...End_If

ret
____________________________________________________________________________________________
Proc StoreIn32BitsRegister:

    ..If B$edi+2 = memMarker
        ; second operand is memory data
        .If_Or B$edi+1 = 'B', B$edi+1 = 'W'
            mov D$EPP_LastStorageStatement_InMemory {'MOVZX #2 #1|',0}
        .Else_If B$edi+1 = 'D'
            mov D$EPP_LastStorageStatement_InMemory {'MOV #2 #1|',0}
        .Else_If_Or B$edi+1 = 'F', B$edi+1 = 'R', B$edi+1 = 'T'
            EPP_Code 'SUB ESP 04|{?? ESI-000}|FLD #1|FISTP D$?|'
            mov D$EPP_LastStorageStatement_InMemory {'MOV #2 D$?|',0}
        .Else
            error EqualPreparser_SourceInvalid
        .End_If

    ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
        EPP_Code 'SUB ESP 04|{?? ESI-000}|FISTP D$?|'
        mov D$EPP_LastStorageStatement_InMemory {'MOV #2 D$?|',0}

    ..Else
    ; second operand is an integer number or a register or an equate
        lea eax D$edi+1 | call IsARegister eax
        Test_If ax (ByteValue or WordValue)
            mov D$EPP_LastStorageStatement {'MOVZX #2 #1|',0}
        Test_Else
            mov D$EPP_LastStorageStatement {'MOV #2 #1|',0}
        Test_End
    ..End_If

EndP
____________________________________________________________________________________________
StoreInFPURegister:

    ..If B$edi+2 = memMarker
    ; second operand is memory data
        EPP_Code 'FRSTOR X$!7|'
        .If_Or B$edi+1 = 'B'
            call ExtendOperandToDWord 1 MemoryOperand
            jmp L1>
        .Else_If_Or B$edi+1 = 'W', B$edi+1 = 'D', B$edi+1 = 'Q'
L1:         If W$EPP_DestOperand+1 = 'T7'
                EPP_Code 'FFREE ST7|FILD #1|FINCSTP|'
            Else
                inc B$EPP_DestOperand+2
                EPP_Code 'FILD #1|FSTP #2|'
            End_If
        .Else_If_Or B$edi+1 = 'R', B$edi+1 = 'F', B$edi+1 = 'T'
            If W$EPP_DestOperand+1 = 'T7'
                EPP_Code 'FFREE ST7|FLD #1|FINCSTP|'
            Else
                inc B$EPP_DestOperand+2
                EPP_Code 'FLD #1|FSTP #2|'
            End_If

        .Else
            error EqualPreparser_SourceInvalid
        .End_If

    ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
        EPP_Code 'SUB ESP 0A|{?? ESI-000}|FSTP T$?|'
        call ReplaceOperand 1 'T' 0
        mov D$EPP_Operand2 EPP_DestOperand
        EPP_Code 'FRSTOR X$!7|'
        If W$EPP_DestOperand+1 = 'T7'
            EPP_Code 'FFREE ST7|FLD #1|FINCSTP|'
        Else
            inc B$EPP_DestOperand+2
            EPP_Code 'FLD #1|FSTP #2|'
        End_If

    ..Else
        ; second operand is a register, an integer number or an equate
        EPP_Code 'FRSTOR X$!7|'
        On W$EPP_DestOperand+1 = 'T7', EPP_Code 'FFREE ST7|'
        lea eax D$edi+1 | call IsARegister eax
        Test_If ax (ByteValue or WordValue)
            EPP_Code 'SUB ESP 04|{?? ESI-000}|MOVZX EAX #1|MOV D$? EAX|FILD D$?|'
        Test_Else_If ax DWordValue
            EPP_Code 'SUB ESP 04|{?? ESI-000}|MOV D$? #1|FILD D$?|'
        Test_Else
            EPP_Code '{??:R$ #1}|FLD R$?|'
        Test_End

        If W$EPP_DestOperand+1 = 'T7'
            EPP_Code 'FINCSTP|'
        Else
            inc B$EPP_DestOperand+2
            EPP_Code 'FSTP #2|'
        End_If
    ..End_If

ret
____________________________________________________________________________________________
StoreIn16BitsRegister:

    ..If B$edi+2 = memMarker
    ; second operand is memory data
        .If B$edi+1 = 'B'
            mov D$EPP_LastStorageStatement_InMemory {'MOVZX #2 #1|',0}
        .Else_If B$edi+1 = 'W'
            mov D$EPP_LastStorageStatement_InMemory {'MOV #2 #1|',0}
        .Else_If_Or B$edi+1 = 'F', B$edi+1 = 'R', B$edi+1 = 'T'
            EPP_Code 'SUB ESP 02|{?? ESI-000}|FLD #1|FISTP W$?|'
            mov D$EPP_LastStorageStatement_InMemory {'MOV #2 W$?|',0}
        .Else
            error EqualPreparser_SourceInvalid
        .End_If

    ..Else_If W$edi+1 = 'st'
        ; result on the FPU Stack
        EPP_Code 'SUB ESP 02|{?? ESI-000}|FISTP W$?|'
        mov D$EPP_LastStorageStatement_InMemory {'MOV #2 W$?|',0}

    ..Else
    ; second operand is an integer number, a register or an equate
        lea eax D$edi+1 | call IsARegister eax
        Test_If ax ByteValue
            mov D$EPP_LastStorageStatement {'MOVZX #2 #1|',0}
        Test_Else_If_Not ax DWord
            mov D$EPP_LastStorageStatement {'MOV #2 #1|',0}
        Test_Else
            error EqualPreparser_SourceInvalid
        Test_End
    ..End_If

ret
____________________________________________________________________________________________
StoreIn8BitsRegister:

    .If B$edi+2 = memMarker
    ; second operand is memory data
        If B$edi+1 = 'B'
            mov D$EPP_LastStorageStatement_InMemory {'MOV #2 #1|',0}
        Else
            error EqualPreparser_SourceInvalid
        End_If
    .Else
    ; second operand is an integer number, a register or an equate
        On W$edi+1 = 'st', error EqualPreparser_SourceInvalid
        lea eax D$edi+1 | call IsARegister eax
        If ax <> &FALSE
            Test_If_Not ax ByteValue | error EqualPreparser_SourceInvalid | Test_End
        End_If
        mov D$EPP_LastStorageStatement {'MOV #2 #1|',0}
    .End_If

ret
____________________________________________________________________________________________








____________________________________________________________________________________________
; EPP Macros:
[EPP_Code
#If #1=str
    EPP_CodeDirect #1
#Else_If #1=mem
    EPP_CodePtr #1
#Else_If #1=reg
    #If #1=D
        EPP_CodeReg #1 D
    #Else_If #1=W
        EPP_CodeReg #1 W
    #Else_If #1=B
        EPP_CodeReg #1 B
    #End_If
#End_If
#+1]

[EPP_CodeReg | {&0: 0} | mov #2$&0 #1 | call ImmediateCodeParser &0]
[EPP_CodePtr | lea eax #1 | call ImmediateCodeParser eax]
[EPP_CodeDirect | {&0:B$ #1,0} | call ImmediateCodeParser &0]

; returns in fourth parameter (if it exists) the length of string
[EPP_FindCodePos | {&0:B$ #1,0} | push ebx | call FindCodePosProc &0 #2 #3 | pop ebx ]

[EPP_ReplaceCode | {&0:B$ #2,0} | call ReplaceCodeMacroProc {#1,0} &0 #3 #4 ]

[ReplaceByAddressingOperator
mov B$esi-2 #1
lea edi D$esi   | call ShiftLineLeft 1
lea edi D$esi-2 | call ShiftLineLeft 1
sub esi 2]


[Test_If    |#=2| test #1 #2 | jz T0> ]
[.Test_If   |#=2| test #1 #2 | jz T1>>]
[..Test_If  |#=2| test #1 #2 | jz T2>>]
[...Test_If |#=2| test #1 #2 | jz T3>>]

[Test_If_Not     |#=2| test #1 #2 | jnz T0> ]
[.Test_If_Not    |#=2| test #1 #2 | jnz T1>>]
[..Test_If_Not   |#=2| test #1 #2 | jnz T2>>]
[...Test_If_Not  |#=2| test #1 #2 | jnz T3>>]


[Test_Else    | jmp T5>  | T0: ]
[.Test_Else   | jmp T6>> | T1: ]
[..Test_Else  | jmp T7>> | T2: ]
[...Test_Else | jmp T8>> | T3: ]

[Test_End    | T0: | T5:]
[.Test_End   | T1: | T6:]
[..Test_End  | T2: | T7:]
[...Test_End | T3: | T8:]



[Test_If_And    | Test_If    #1 #2 | #+2]
[.Test_If_And   | .Test_If   #1 #2 | #+2]
[..Test_If_And  | ..Test_If  #1 #2 | #+2]
[...Test_If_And | ...Test_If #1 #2 | #+2]

[Test_If_Not_And    | Test_If_Not    #1 #2 | #+2]
[.Test_If_Not_And   | .Test_If_Not   #1 #2 | #+2]
[..Test_If_Not_And  | ..Test_If_Not  #1 #2 | #+2]
[...Test_If_Not_And | ...Test_If_Not #1 #2 | #+2]


[Test_Else_If    | Test_Else    | Test_If    #1 #2]
[.Test_Else_If   | .Test_Else   | .Test_If   #1 #2]
[..Test_Else_If  | ..Test_Else  | ..Test_If  #1 #2]
[...Test_Else_If | ...Test_Else | ...Test_If #1 #2]

[Test_Else_If_Not    | Test_Else    | Test_If_Not    #1 #2]
[.Test_Else_If_Not   | .Test_Else   | .Test_If_Not   #1 #2]
[..Test_Else_If_Not  | ..Test_Else  | ..Test_If_Not  #1 #2]
[...Test_Else_If_Not | ...Test_Else | ...Test_If_Not #1 #2]


[Test_Else_If_And    | Test_Else    | Test_If_And    #F>L ]
[.Test_Else_If_And   | .Test_Else   | .Test_If_And   #F>L ]
[..Test_Else_If_And  | ..Test_Else  | ..Test_If_And  #F>L ]
[...Test_Else_If_And | ...Test_Else | ...Test_If_And #F>L ]

[Test_Else_If_Not_And    | Test_Else    | Test_If_Not_And    #F>L ]
[.Test_Else_If_Not_And   | .Test_Else   | .Test_If_Not_And   #F>L ]
[..Test_Else_If_Not_And  | ..Test_Else  | ..Test_If_Not_And  #F>L ]
[...Test_Else_If_Not_And | ...Test_Else | ...Test_If_Not_And #F>L ]



[If_Or    | cmp #1 #3 | j#2 O0>  | #+3 | jmp I1>  | O0:]
[.If_Or   | cmp #1 #3 | j#2 O1>> | #+3 | jmp J1>> | O1:]
[..If_Or  | cmp #1 #3 | j#2 O2>> | #+3 | jmp K1>> | O2:]
[...If_Or | cmp #1 #3 | j#2 O3>> | #+3 | jmp Z1>> | O3:]

[Else_If_Or    | Else    | If_Or    #F>L]
[.Else_If_Or   | .Else   | .If_Or   #F>L]
[..Else_If_Or  | ..Else  | ..If_Or  #F>L]
[...Else_If_Or | ...Else | ...If_Or #F>L]


[If_And    | If #1 #2 #3    | #+3]
[.If_And   | .If #1 #2 #3   | #+3]
[..If_And  | ..If #1 #2 #3  | #+3]
[...If_And | ...If #1 #2 #3 | #+3]

[Else_If_And    | Else    | If_And    #F>L]
[.Else_If_And   | .Else   | .If_And   #F>L]
[..Else_If_And  | ..Else  | ..If_And  #F>L]
[...Else_If_And | ...Else | ...If_And #F>L]




; * max string length = 10
; * OK if #3 is included in #1, jump to next 'If' otherwise
;
; ex:
;   If_str eax = 'glouglou'
;       ;...
;   Else
;       ;...
;   End_If

[.If_str | {&0: #3,0} | mov esi &0 | mov edi #1 | mov ecx 10 | repe cmpsb
         On ecx = 0, jmp J1>  | On B$esi-1 <> 0, jmp J1> ]

[.Else_If_str| .Else | .If_str #1 #2 #3]


____________________________________________________________________________________________
EPP_All_Data:
[EPP_SourceEquation: B$ ? #256   EPP_SourceEquation_End: B$ ?]  ; last char is EOI
[EPP_DestOperand: B$? #64]     ; last char is Space

[EPP_SourceEquation_Backup: B$ ? #256 ]
[EPP_DestOperand_Backup: B$? #64]
[EPP_atofAddress: B$ ? #9] ; null-terminated
[EPP_ftoaAddress: B$ ? #9] ; null-terminated
[EPP_ImmediateResultString: B$ ? #32]

[EPP_InternalMeaninglessLabels: B$ ? #(9*10)]   ; 8 and 9 are reserved for Evaluation parser


[EPP_SearchedSingleCharacter: B$ ? #SEARCH_VARIABLE_NUMBER]
[EPP_SearchedStringAddress:   D$ ? #SEARCH_VARIABLE_NUMBER]
[EPP_ReplacementBuffer: B$ ? #128 ]

[EqualPreparser_DestInvalid: B$             'Destination operand is invalid.' 0
 EqualPreparser_SourceInvalid:              'Source expression is invalid.' 0
 EqualPreparser_UnexpectedError:            'Unexpected preparsing error.' 0
 EqualPreparser_InvalidIndex:               'Invalid index type.' 0
 EqualPreparser_InvalidAddress:             'Invalid address.' 0
 EqualPreparser_OperatorsInvalid:           'Two operators are following each other.' 0
 EqualPreparser_ParameterInvalid:           'Invalid integrated function parameter.' 0
 EqualPreparser_InvalidFPValue:             'Invalid floating point value.' 0
 EqualPreparser_OptimisationError:          'Error occurred while optimizing. Please report this error :)' 0
 EqualPreparser_InvalidFunction:            'No such function implemented.' 0
 EqualPreparser_InvalidStringDest_Type:     'A string pointer MUST be a DWord .' 0
 EqualPreparser_InvalidStringDest_Numeric:  'You cannot write at a numeric address.' 0
 EqualPreparser_InvalidStringinSource:      'Invalid string in source operand.'  0
 EqualPreparser_InvalidImmVal:              'Invalid immediate expression.'  0
 EqualPreparser_LocalStackOverflow:         'Local stack overflow !'  0

FPUInSourceExpression: B$ 0   UsedRegisters_Backup: 0   UsedRegisters: 0   NoOperation: 0  ParsingInsideArray: 0
DestinationArrayRegister: 0    UseCommonAddressingSyntax: &TRUE   StrNull: 0]

[EPP_ImmediateResult:T$ ?]

[EPP_CodeBegining: ?   EPP_Operand1: ?     EPP_Operand2: ?  EPP_WrittenCode:  ?  FPUStackNumber: ?
 DestinationType: ?  EPP_TextPointer: ?   EPP_LastStorageStatement: ?   EPP_LastStorageStatement_InMemory: ?]


 [INITIAL_STATE 07FFFFFFF
  FOUND_EQUATION_TEST 0FFFFFF
  SEARCH_VARIABLE_NUMBER  9

  EPP_EAX 00______1
  EPP_EBX 00_____10
  EPP_ECX 00____100
  EPP_EDX 00___1000
  EPP_ESI 00__10000
  EPP_EDI 00_100000

  EPP_NO_OPERATION        2
  CODE_NOT_FOUND          0_FFFF_FFFF
  EPP_CODE_BEGIN              0
  EPP_CODE_END                0
  EPP_SOURCE_BEGIN            1
  EPP_SOURCE_END              1

  SignedMulSign  '*'
  SignedDivSign  '/'

  pointSign      'o'
  concatSign     '&'

  ; +,- and * used for addressing in RosAsm syntax
  minusSign      'm'
  plusSign       'p'
  addressSign    'x'

  ; All data types used in this TITLE are below
  EPP_Types 0

        FunctionOperand      00__0000_1000__0000_0000
        NumericOperand       00__0100_0000__0000_0000
        RegisterOperand      00__0010_0000__0000_0000
        ConstantOperand      00__0001_0000__0000_0000

        MemoryOperand        00__0000_0001__0000_0000
                QWordValue   00_____________0000_1000
                DWordValue   00_____________0000_0100
                WordValue    00_____________0000_0010
                ByteValue    00_____________0000_0001

        FloatingPointOperand 00_____________1000_0000
                  TByteValue 00_____________0001_0000
                  RealValue  00_____________0000_1000
                  FloatValue 00_____________0000_0100





  EqualPreparser_IntegerOperand_ST0            00________1
  EqualPreparser_ST0_IntegerOperand            00_______10
  EqualPreparser_FloatingPointOperand_ST0      00______100
  EqualPreparser_ST0_FloatingPointOperand      00_____1000
  EqualPreparser_ST1_ST0                       00____10000
  EqualPreparser_ST0_ST1                       00___100000
  EqualPreparser_ST0_ConstantOperand           00__1000000
  EqualPreparser_ConstantOperand_ST0           00_10000000]
____________________________________________________________________________________________




____________________________________________________________________________________________
____________________________________________________________________________________________
;DEBUG

[TempSourceBuffer: ? #1024]

[ShowSourceTitle: 'SOURCE ' ]
[ShowSourceTitle_ID: 0 0 0 ]                    ; [<ShowSourceTitle_ID: 0 0 0 ]  disables the breakpoints !!!!!
[FirstEqualLine: &TRUE   LastEqualLine: 0]

; call ShowSource edi 1    ; show from edi and diplay 1 in the title
; call ShowSource 0 7      ; show the whole written code and diplay 7 in the title
; call ShowSource ebx 0    ; show the line where ebx points on
Proc ShowSource:
    Arguments @ShowFrom @Title

    pushad

        mov ebx, D@Title | mov edi ShowSourceTitle_ID | inc edi
        std
            mov ecx, 2
L1:         mov al bl | and al 0F | On al >= 0A, add al 7
            add al, '0' | stosb | shr ebx, 4 | loop L1
        cld

        If D@ShowFrom = 0
            mov esi D$LastEqualLine
            ;While B$esi <> EOI | inc esi | End_While | inc esi  ; shows instruction after the current one
            ;While B$esi <> EOI | dec esi | End_While | dec esi  ; shows instruction before the current one
            ;While B$esi <> EOI | dec esi | End_While | inc esi
            mov edx &TRUE ; only one line is displayed
        Else_If D@Title = 0
            ;While B$esi <> EOI | inc esi | End_While | inc esi  ; shows instruction after the current one
            ;While B$esi <> EOI | dec esi | End_While | dec esi  ; shows instruction before the current one
            mov esi D@ShowFrom
            While B$esi <> EOI | dec esi | End_While | inc esi
            mov edx &FALSE
        Else
            ; shows from pointer
            mov esi D@ShowFrom
            mov edx &TRUE ; only one line is displayed
        End_If

        ;mov ebx D$LastEqualLine | While B$ebx <> EOI | inc ebx | End_While
        ; ebx points on the end of the source currently written

        mov ecx 0
        mov edi TempSourceBuffer

        ; Each charater is replaced by its source equivalent so as to being diplayed.
        ; If a character is neither alphanumeric nor a RosAsm operator, it is replaced by '~' so as to be easily locatable.

L0:     lodsb
        .If al = TextSign
            mov al '"'
        .Else_If al = pointSign
             mov al '.'
        .Else_If al = minusSign
            mov al '-'
        .Else_If al = plusSign
            mov al '+'
        .Else_If al = SignedDivSign
            mov al '/'
        .Else_If al = SignedMulSign
            mov al '*'
        .Else_If al = numSign
            mov al '#'
        .Else_If al = CommaSign
            mov al ','
        .Else_If al = OpenVirtual
            mov al '{'
        .Else_If al = CloseVirtual
            mov al '}'
        .Else_If al = Openbracket
            mov al '['
        .Else_If al = Closebracket
            mov al ']'
        .Else_If al = memMarker
            mov al '$'
        .Else_If al = colonSign
            mov al ':'
        .Else_If al = openSign
            mov al '('
        .Else_If al = closeSign
            mov al ')'
        .Else_If al = addSign
            mov al '+'
        .Else_If al = subSign
            mov al '-'
        .Else_If al = mulSign
            mov al '*'
        .Else_If al = divSign
            mov al '/'
        .Else_If al = expSign
            mov al '^'
        .Else_If al = '{'
            mov al '{'
        .Else_If al = '}'
            mov al '}'
        .Else_If al = '.'
            mov al '.'
        .Else_If al = Space
            mov al '_'
        .Else_If al = 0
            mov al '@'
        .Else_If al = EOI
            mov al '|'
            On edx = &TRUE, jmp L9>
            On esi >= ebx, jmp L9>
            mov ax 0A0D | stosw
            mov al 13 | stosb
            mov al 10
        .Else_If al = meEOI
            mov al 13 | stosb
            mov al 10
        .Else_If al < 48
            mov al '~'
        .Else_If al > 90
            mov al '~'
        .End_If

        stosb
        inc ecx

        jmp L0<<

L9:     mov B$edi 0

        ;call 'USER32.DialogBoxParamA' D$hInstance 23000  &NULL EqualDebugProcProc  &NULL
        call 'USER32.MessageBoxA' D$hwnd, TempSourceBuffer, ShowSourceTitle, &MB_ICONINFORMATION
    popad


EndP
____________________________________________________________________________________________
Proc EqualDebugProcProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    If D@Message = &WM_INITDIALOG
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        mov eax &TRUE
        call 'User32.SetWindowTextA' D@Adressee ShowSourceTitle
        call 'User32.SetDlgItemTextA' D@Adressee 101 TempSourceBuffer

    Else_If D@Message = &WM_CLOSE
        call 'User32.EndDialog' D@Adressee 0


    Else
        popad | mov eax &FALSE | jmp L9>

    End_If

    popad | mov eax &TRUE

L9: EndP

TITLE FPU

;;
  'UsedByTheAssembler' (very old traditional Routines for Ascii to Float on Stack)
  
  'UsedBytheEqualParser' 
  
  'UsedByTheDebugger' (and by the Disassembler for 'FloatToUString')
  
  'UsedForStudy' (Under developements)
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

UsedByTheAssembler:

[Int10: 10   CurrentConvertedDigit: 0   NumberOfDecimalPlaces: 0   FaultCharAndPos: 0]

atof:
    finit | mov D$FaultCharAndPos 0
    push edi, esi
      call convert                  ; convert mantissa (returns with 'E' if exponent present)

      neg edx                                ; save -1 * decimal places
      mov D$NumberOfDecimalPlaces edx

      IF al <> 'E'
        mov B$FaultCharAndPos al             ; faulty char present in mantissa
        pop ecx | mov edi esi | sub edi ecx  ; fault char pos
        fldz                                 ; assume zero exponent
      Else_If al = 'E'
        call convert                         ; convert exponent
        mov B$FaultCharAndPos al      ; Save faulty character present in exponent
        pop ecx | mov edi esi | sub edi ecx  ; fault char pos
      End_If

      fiadd D$NumberOfDecimalPlaces          ; adjust exponent for dec. places in mantissa
      call falog                             ; raise 10 to power
      fmul                                   ; exponent * mantissa

      ; Provide information about faulty character and its position

      mov eax edi                            ; Get possible fault position
      shl eax 8                              ; shift to high word
      or eax D$FaultCharAndPos               ; OR faults togeter
    pop edi
ret                                      ; return ST(0) = result

_________________________________________________________________
;;
 CONVERT:      Called by ATOF to convert ASCII number with possible sign and/or decimal point
 Call with:    ESI = address of string
 Returns:      ST(0) = result
               AL    = first unconvertable character
               EDX    = number of digits after decimal point
               ESI = address+1 of character in AL
 Uses:         AH, CX
;;
_________________________________________________________________        ;

convert:                                ; convert numeric field
    fldz | mov ecx 0, edx 0-1           ; initialize result, sign, decimal count

   lodsb
        cmp al AddSign | je L2>         ; if + sign proceed
        cmp al SubSign | jne L3>        ; is it - sign? no > test if numeric
          dec ecx                       ; yes, set sign flag

L2: lodsb                               ; get next character

L3: cmp al '0' | jb L4>                 ; is character valid?
      cmp al,'9' | ja L4>
        and eax 0f                      ; isolate lower four bits
        mov D$CurrentConvertedDigit eax ; and save digit value
        fimul D$int10                   ; previous value * 10
        fiadd D$CurrentConvertedDigit   ; accumulate new digit

        or edx edx | js L2<             ; past decimal point? no > convert next digit
          inc edx | jmp L2<             ; yes > count digits / convert next digit

L4: cmp al '.' | jne L5>                ; no point > proceed
      inc edx | jmp L2<                 ; indicate decimal found > convert more digits
L5:    jcxz L6>                         ; jump if result pos.
        fchs                            ; make result negative

L6: or edx edx | jns L7>                ; decimal point found? yes > jump
      mov edx 0                         ; no, return zero places

L7: ret                                 ; return ST(0) = result


_____________________________________________________________________________________
;;
-------------------------------------------------------;
 Calculate Common Antilog on 80x87   ;
       ;
 Call  :    st(0)     = logarithm (base 10)  ;
       ;
 Return:    st(0)     = antilog to base 10  ;
       ;
 Coprocessor should be initialised before call  ;
-------------------------------------------------------;
;;
; FWAIT doesn't seam to be of any use (works the same without on my computer).

[FalogOldcw: W$ 0   FalogNewcw: 0]

falog:
        fldl2t                          ; st= log2(10), st(1)=argument
        fmulp   st1 st0                 ; st= log2(10) * argument
        fld     st0                     ; take copy
     ;   fwait
     ;   fstcw   W$Falogoldcw            ; store old control word
     ;   fwait                           ; wait 'till it arrives
     ;   mov     ax W$Falogoldcw         ; Load control word
     ;   and     ax 0f3ff                ; Field to "round down"
     ;   or      ax 0400                 ; Set precision to 53 bit mantissa
     ;   mov     W$Falognewcw ax         ; Got new control word
     ;   fldcw   W$Falognewcw            ; Force rounding mode
        frndint                         ; Round from real to integer
     ;   fldcw   W$Falogoldcw            ; Restore old rounding mode
        fld     st0                     ; take copy
        fxch    st2                     ; Get original product
        fsubrp  st1 st0                 ; Get fractional part
        fld1
        fchs
        fxch    st1                     ; Scale fractional part
        fscale    ;
        fstp    st1                     ; Discard coprocessor junk
        f2xm1                           ; Raise 2 to power-1
        fld1                            ; Push 1 onto stack
        faddp   st1 st0                 ; Correct for the -1
        fmul    st0 st0                 ; Square result
        fscale                          ; Scale by integer part
        fstp    st1                     ; Return with result in st(0)
      ret

____________________________________________________________________________________________
____________________________________________________________________________________________

UsedBytheEqualParser:

Proc FloatToAscii:
;;
  This procedure was written by Raymond Filiatreault, December 2002
  (Modified Betov December 2002). 
  (Slightly modified by Scarmatil to fit upon RosAsm's signs, December 2003) 
  
  This FloatToAscii function converts an 80-bit REAL number (Src) to its
  decimal representation as a zero terminated alphanumeric string which
  is returned at the specified memory destination unless an invalid
  operation is reported by the FPU. The format of the string can be 
  specified as regular, or scientific notation. The number of decimal
  places returned must also be specified but the total number of digits
  must not exceed 18.
  
  The source can be an 80-bit REAL number from the FPU itself or from
  memory. If the source is taken from the FPU, its value will be preserved
  there if no error is reported.
  
  The source is not checked for validity. This is the programmer's
  responsibility.
  
  This procedure is based on using an FPU instruction to convert the
  REAL number into a specific packed decimal format. After unpacking,
  the decimal point is positioned as required.
  
  Only EAX is used to return error or success. All other registers are
  preserved.
____________________________________________________________________________________________

  Calling:     > call FloatToAscii Source, Destination, Decimal, FLAG
  
  Source: Either a Pointer to a Data [T$Source: ...], or &NULL if you 
          "fld F$ / R$ / T$ Source"  before calling.
          
  Destination: Pointer to a Data Buffer for the Ascii (Space-terminated) String 
               (Max Size = 25 Bytes).
  
  Decimal: The Number of wanted decimals (Max = 15).
  
  FLAG (for notation choice): Either SCIENTIFIC or REGULAR.
____________________________________________________________________________________________
;;

; Flags:

[REGULAR 0    SCIENTIFIC 1]

    Arguments @Source, @Destination, @Decimal, @Flag
    Local @temporary, @eSize, @oldcw, @truncw, @stword
    Structure @BCD 12, @bcdstr 0

        fclex                   ;clear exception flags on FPU

      ; Get the specified number of decimals for result (MAX = 15):
        On D@Decimal > 0F, mov D@Decimal 0F

      ; The FPU will be initialized only if the source parameter is not taken
      ; from the FPU itself (D@ Source <> &NULL):
        .If D@Source = &NULL
            fld st0             ;copy it to preserve the original value
        .Else
            mov eax D@Source
            If eax > 0400_000
                finit | fld T$eax
              ; Check first if value on FPU is valid or equal to zero:
                ftst                    ;test value on FPU
                fstsw W@stword          ;get result
                test W@stword 04000     ;check it for zero or NAN
                jz L0>                  ;continue if valid non-zero
                test W@stword 0100      ;now check it for NAN
                jnz L1>                 ;Src is NAN or infinity - cannot convert
                  ; Here: Value to be converted = 0
                    mov eax D@Destination | mov W$eax '0' ; Write '0', 0 szstring
                    mov eax &TRUE | finit | ExitP
            Else
L1:             finit | mov eax &FALSE | ExitP
            End_If
        .End_If

      ; Get the size of the number:
L0:     fld st0                 ;copy it
        fabs                    ;insures a positive value
        fld1 | fldl2t
        fdivp ST1 ST0           ;->1/[log2(10)]
        fxch | fyl2x            ;->[log2(Src)]/[log2(10)] = log10(Src)

        fstcw W@oldcw           ;get current control word
        mov ax W@oldcw
        or ax 0C00              ;code it for truncating
        mov W@truncw ax
        fldcw W@truncw          ;change rounding code of FPU to truncate

        fist D@eSize            ;store characteristic of logarithm
        fldcw W@oldcw           ;load back the former control word

        ftst                    ;test logarithm for its sign
        fstsw W@stword          ;get result
        test W@stword 0100      ;check if negative
        jz L0>
            dec D@eSize

L0:     On D@eSize > 15, mov D@Flag SCIENTIFIC

      ; Multiply the number by a power of 10 to generate a 16-digit integer:
L0:     fstp st0                ;get rid of the logarithm
        mov eax 15
        sub eax D@eSize         ;exponent required to get a 16-digit integer
        jz L0>                  ;no need if already a 16-digit integer
            mov D@temporary eax
            fild D@temporary
            fldl2t | fmulp ST1 ST0       ;->log2(10)*exponent
            fld st0 | frndint | fxch
            fsub st0 st1        ;keeps only the fractional part on the FPU
            f2xm1               ;->2^(fractional part)-1
            fld1
            faddp ST1 ST0       ;add 1 back
            fscale              ;re-adjust the exponent part of the REAL number
            fxch
            fstp st0
            fmulp ST1 ST0       ;->16-digit integer

L0:     fbstp T@bcdstr          ;transfer it as a 16-digit packed decimal
        fstsw W@stword          ;retrieve exception flags from FPU
        test W@stword 1         ;test for invalid operation
        jnz L1<<                ;clean-up and return error

      ; Unpack bcd, the 10 bytes returned by the FPU being in the little-endian style:
        push ecx, esi, edi
            lea esi D@bcdstr+9
            mov edi D@Destination
            mov al B$esi        ;sign byte
            dec esi | dec esi
            If al = 080
                mov al minusSign      ;insert sign if negative number
            Else
                mov al Space      ;insert space if positive number
            End_If
            stosb

            ...If D@Flag = REGULAR
              ; Verify number of decimals required vs maximum allowed:
                mov eax 15 | sub eax D@eSize
                cmp eax D@Decimal | jae L0>
                    mov D@Decimal eax

              ; ;check for integer digits:
L0:             mov ecx D@eSize
                or ecx ecx           ;is it negative
                jns L3>
                  ; Insert required leading 0 before decimal digits:
                    mov ax '0o' | stosw
                    neg ecx
                    cmp ecx D@Decimal | jbe L0>
                        jmp L8>>

L0:                 dec ecx | jz L0>
                        stosb | jmp L0<
L0:
                    mov ecx D@Decimal | inc ecx
                    add ecx D@eSize | jg L4>
                        jmp L8>>

              ; Do integer digits:
L3:             inc ecx
L0:             movzx eax B$esi | dec esi | ror ax 4 | ror ah 4
                add ax '00' | stosw | sub ecx 2 | jg L0<
                jz L0>
                    dec   edi

L0:             cmp D@Decimal 0 | jz L8>>
                    mov al pointSign | stosb
                    If ecx <> 0
                        mov al ah | stosb
                        mov ecx D@Decimal | dec ecx | jz L8>>
                    Else
                        mov ecx D@Decimal
                    End_If

              ; Do decimal digits:
L4:             movzx eax B$esi
                dec esi
                ror ax 4 | ror ah 4 | add ax 03030 | stosw
                sub ecx 2 | jg L4<
                jz L1>
                    dec   edi
L1:             jmp L8>>

          ; scientific notation
            ...Else
                 mov ecx D@Decimal | inc ecx
                movzx eax B$esi | dec esi
                ror ax 4 | ror ah 4 | add ax '00' | stosb
                mov al pointSign | stosb
                mov al ah | stosb
                sub ecx 2 | jz L7>
                jns L0>
                    dec edi | jmp L7>
L0:             movzx eax B$esi
                dec esi
                ror ax 4 | ror ah 4
                add ax '00' | stosw | sub ecx 2 | jg L0<
                jz L7>
                    dec edi

L7:             mov al 'E' | stosb
                mov al plusSign, ecx D@eSize | or ecx ecx | jns L0>
                    mov al minusSign | neg ecx
L0:             stosb
              ; Note: the absolute value of the size could not exceed 4931
                mov eax ecx
                mov cl 100
                div cl          ;->thousands & hundreds in AL, tens & units in AH
                push eax
                    and eax 0FF ;keep only the thousands & hundreds
                    mov cl 10
                    div cl      ;->thousands in AL, hundreds in AH
                    add ax '00' ;convert to characters
                    stosw       ;insert them
                pop eax
                shr eax 8       ;get the tens & units in AL
                div cl          ;tens in AL, units in AH
                add ax '00'     ;convert to characters
                stosw           ;insert them
            ...End_If

L8:         mov B$edi Space         ;string terminating character
        pop edi, esi, ecx

        finit | mov eax D@eSize
EndP
____________________________________________________________________________________________
Proc AsciitoFloat:
;;
  This procedure was written by Raymond Filiatreault, December 2002
  Modified Betov, December 2002
  (Slightly modified by Scarmatil to fit upon RosAsm's signs, December 2003)
  
  This AsciitoFloat function converts a decimal number from a zero terminated
  alphanumeric string format (Src) to an 80-bit REAL number and returns
  the result as an 80-bit REAL number at the specified destination (either
  the FPU top or a memory location), unless an invalid operation is
  reported by the FPU.
 
  The source can be a string in regular numeric format or in scientific
  notation. The number of digits (including leading 0's) must not exceed
  18. If in scientific format, the exponent must be within +/-4931
 
  The source is checked for validity. The procedure returns an error if
  a character other than those acceptable is detected prior to the
  terminating zero or the above limits are exceeded.
 
  This procedure is based on converting the digits into a specific packed
  decimal format which can be used by the FPU and then adjusted for an
  exponent of 10.
 
  Only EAX is used to return error or success. All other registers are
  preserved.
____________________________________________________________________________________________

  Calling:     > call AsciitoFloat Source, Destination
  
  Source: Pointer to a Floating Point String (either regular or scientific 
          notation).
  
  Destination: Either a Pointer to a [T$FPValue: ...] or &NULL.

  In case of &NULL Destination, the result is left on the FPU Stack, and
  you have to you have to pop the result by yourself. Usefull in cases when
  you want Real8 or Real4, or when you want to go on computing with the result.
____________________________________________________________________________________________
;;
    Arguments @lpSrc, @lpDest
    Local @stword, @ten
    Structure @BCD 12, @bcdstr 0
    Uses ebx, ecx, edx, esi, edi

        mov eax 0, ebx 0, edx 0, ecx 19, D@ten 10
        lea edi D@bcdstr | mov D$edi 0, D$edi+4 0, D$edi+8 0 | add edi 8

        mov esi D@lpSrc
        mov al B$esi
        If al = Space       ; string empty?
            jmp E7>>
        Else_If al = minusSign
            mov B$edi+1 080
            inc esi
        End_If

        ; Strip pointless 0
        While B$esi = '0'
            If B$esi+1 = pointSign | inc esi | jmp L2> | End_If
            On B$esi+1 < '0', jmp L2>
            On B$esi+1 > '9', jmp L2>
            inc esi
        End_While

      ; Convert the digits to packed decimal:
L2:     lodsb | On al = 'e', mov al 'E'

      ; bh used to set the decimal point flag (one point only):
        ...If al = pointSign
            If bh = 0
                or bh 1 | jmp L2<
            End_If
        ...Else_If al = 'E'
            On cl < 19, jmp L6>>        ;error if no digit before E
        ...Else_If al = Space
            If cl < 19                  ;error if no digit before terminating Space
                xor al al | rol al 4 | ror ax 4 | mov B$edi al | jmp L5>>
            End_If
        ...Else
            ..If al >= '0'
                .If al <= '9'           ;error if bad Char.
                    dec ecx
                    If ecx > 0          ;error if more than 18 digits in number
                        sub al '0' | On bh = 0, inc bl
                        test ah 040 | jz L1>
                            rol al 4 | ror ax 4 | mov B$edi al | dec edi | xor eax eax  | jmp L2<<
L1:                     mov ah al | or ah 040 | jmp L2<<
                    End_If
                .End_If
            ..End_If
        ...End_If

        jmp E7>>                        ; Error case if falling here.

      ; Output:
L5:     fbld T@bcdstr
        mov eax 18 | sub al bl | sub edx eax | call XexpY edx
        fmulp ST1 ST0
        fstsw W@stword                      ;retrieve exception flags from FPU
        wait | test W@stword 1 | jnz E7>>   ;test for invalid operation
        mov eax D@lpDest
        If D@lpDest <> &NULL
            mov eax D@lpDest |  fstp T$eax      ;store result at specified address
        End_If
        jmp E8>>

      ; Scientific notation (exponent in edx):
L6:     movzx eax B$esi | inc esi
        cmp al plusSign | je L0>
            cmp al minusSign | jne L6>
            stc | rcr eax 1         ;keep sign of exponent in most significant bit of EAX
L0:     lodsb                               ;get next digit after sign

L6:     push eax |
            and eax 0FF | jnz L0>           ;continue if 1st byte of exponent is not terminating 0
L6:             pop eax | jmp E7>>          ;no exponent
L0:         sub al '0' | jc L6<             ;unacceptable character
            cmp al 9 | ja L6<               ;unacceptable character
            push eax
                mov eax edx | mul D@ten | mov edx eax
            pop eax
            add edx eax | cmp edx 4931 | ja L6<     ;exponent too large
            lodsb
            cmp al Space | jne L0<
        pop eax                             ;retrieve exponent sign flag
        rcl eax 1 | jnc L0>                 ;is most significant bit set?
            neg edx
L0:     jmp L5<<

E7:     mov eax &FALSE | finit | jmp E9>
E8:     mov eax &TRUE
E9: EndP


;put 10 to the proper exponent (value in EDX) on the FPU

Proc XexpY:
    Argument @Tempdw

        fild D@tempdw           ;load the exponent
        fldl2t                  ;load log2(10)
        fmulp ST1 ST0           ;->log2(10)*exponent

;at this point, only the log base 2 of the 10^exponent is on the FPU
;the FPU can compute the antilog only with the mantissa
;the characteristic of the logarithm must thus be removed

        fld ST0                 ;copy the logarithm
        frndint                 ;keep only the characteristic
        fsub ST1 ST0            ;keeps only the mantissa
        fxch                    ;get the mantissa on top

        f2xm1                   ;->2^(mantissa)-1
        fld1
        faddp ST1 ST0           ;add 1 back

;the number must now be readjusted for the characteristic of the logarithm

        fscale                  ;scale it with the characteristic

;the characteristic is still on the FPU and must be removed

        fxch                    ;bring it back on top
        fstp ST0                ;clean-up the register
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  Routines for FPU study.
;;

UsedForStudy:
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  Strings Tables used to translate from ST0 to String:

  The effective range of integer Values is for 'Fp.Bit1' (Value 1) considered
  as an implyed 'FPBit0'. The Max Value of the Mantissa (all Bits set on) is:
  Max qWord:      18446744073709551615  (0FFFF_FFFF__FFFF_FFFF) (???....).
;;
 [FPBit64: B$ 0  '18446744073709551616', 0  ; Max + 1 (not used).
  FPBit63: B$ 1   '9223372036854775808', 0  ; <<<<<<<<<<<<<<<<<<< Last high Bit.
  FPBit62: B$ 1   '4611686018427387904', 0
  FPBit61: B$ 1   '2305843009213693952', 0
  FPBit60: B$ 1   '1152921504606846976', 0
  FPBit59: B$ 2    '576460752303423488', 0
  FPBit58: B$ 2    '288230376151711744', 0
  FPBit57: B$ 2    '144115188075855872', 0
  FPBit56: B$ 3     '72057594037927936', 0
  FPBit55: B$ 3     '36028797018963968', 0
  FPBit54: B$ 3     '18014398509481984', 0
  FPBit53: B$ 4      '9007199254740992', 0
  FPBit52: B$ 4      '4503599627370496', 0
  FPBit51: B$ 4      '2251799813685248', 0
  FPBit50: B$ 4      '1125899906842624', 0
  FPBit49: B$ 5       '562949953421312', 0

  FPBit48: B$ 5       '281474976710656', 0
  FPBit47: B$ 5       '140737488355328', 0
  FPBit46: B$ 6        '70368744177664', 0
  FPBit45: B$ 6        '35184372088832', 0
  FPBit44: B$ 6        '17592186044416', 0
  FPBit43: B$ 7         '8796093022208', 0
  FPBit42: B$ 7         '4398046511104', 0
  FPBit41: B$ 7         '2199023255552', 0
  FPBit40: B$ 7         '1099511627776', 0
  FPBit39: B$ 8          '549755813888', 0
  FPBit38: B$ 8          '274877906944', 0
  FPBit37: B$ 8          '137438953472', 0
  FPBit36: B$ 9           '68719476736', 0
  FPBit35: B$ 9           '34359738368', 0
  FPBit34: B$ 9           '17179869184', 0
  FPBit33: B$ 10           '8589934592', 0

  FPBit32: B$ 10           '4294967296', 0
  FPBit31: B$ 10           '2147483648', 0
  FPBit30: B$ 10           '1073741824', 0
  FPBit29: B$ 11            '536870912', 0
  FPBit28: B$ 11            '268435456', 0
  FPBit27: B$ 11            '134217728', 0
  FPBit26: B$ 12             '67108864', 0
  FPBit25: B$ 12             '33554432', 0
  FPBit24: B$ 12             '16777216', 0
  FPBit23: B$ 13              '8388608', 0
  FPBit22: B$ 13              '4194304', 0
  FPBit21: B$ 13              '2097152', 0
  FPBit20: B$ 13              '1048576', 0
  FPBit19: B$ 14               '524288', 0
  FPBit18: B$ 14               '262144', 0
  FPBit17: B$ 14               '131072', 0

  FPBit16: B$ 15                '65536', 0
  FPBit15: B$ 15                '32768', 0
  FPBit14: B$ 15                '16384', 0
  FPBit13: B$ 16                 '8192', 0
  FPBit12: B$ 16                 '4096', 0
  FPBit11: B$ 16                 '2048', 0
  FPBit10: B$ 16                 '1024', 0
  FPBit9:  B$ 17                  '512', 0
  FPBit8:  B$ 17                  '256', 0
  FPBit7:  B$ 17                  '128', 0
  FPBit6:  B$ 18                   '64', 0
  FPBit5:  B$ 18                   '32', 0
  FPBit4:  B$ 18                   '16', 0  ; ...
  FPBit3:  B$ 19                    '8', 0  ; ...
  FPBit2:  B$ 19                    '4', 0  ; Exponent = 2
  FPBit1:  B$ 19                    '2', 0] ; Exponent = 1
;;
  The Strings computations begins at the Label depending on the Exponent, and goes along
  downward, for each Bit set on in the Mantissa.
;;
 [Fp.Bit1:  B$ 19 '1', 0                    ; Exponent = 0
; Position 20 is the Point, in the String.
  Fp.Bit2:  B$ 21 '5', 0                    ; Exponent = -1
  Fp.Bit3:  B$ 21 '25', 0                   ; Exponent = -2
  Fp.Bit4:  B$ 21 '125', 0                  ; ...
  Fp.Bit5:  B$ 22  '625', 0                 ; ...
  Fp.Bit6:  B$ 22  '3125', 0
  Fp.Bit7:  B$ 22  '15625', 0
  Fp.Bit8:  B$ 23   '78125', 0
  Fp.Bit9:  B$ 23   '390625', 0
  Fp.Bit10: B$ 23   '1953125', 0
  Fp.Bit11: B$ 24    '9765625', 0
  Fp.Bit12: B$ 24    '48828125', 0
  Fp.Bit13: B$ 24    '244140625', 0
  Fp.Bit14: B$ 24    '1220703125', 0
  Fp.Bit15: B$ 25     '6103515625', 0
  Fp.Bit16: B$ 25     '30517578125', 0

  Fp.Bit17: B$ 25     '152587890625', 0
  Fp.Bit18: B$ 26      '762939453125', 0
  Fp.Bit19: B$ 26      '3814697265625', 0
  Fp.Bit20: B$ 26      '19073486328125', 0
  Fp.Bit21: B$ 27       '95367431640625', 0
  Fp.Bit22: B$ 27       '476837158203125', 0
  Fp.Bit23: B$ 27       '2384185791015625', 0
  Fp.Bit24: B$ 27       '11920928955078125', 0
  Fp.Bit25: B$ 28        '59604644775390625', 0
  Fp.Bit26: B$ 28        '298023223876953125', 0
  Fp.Bit27: B$ 28        '1490116119384765625', 0
  Fp.Bit28: B$ 29         '7450580596923828125', 0
  Fp.Bit29: B$ 29         '37252902984619140625', 0
  Fp.Bit30: B$ 29         '186264514923095703125', 0
  Fp.Bit31: B$ 30          '931322574615478515625', 0
  Fp.Bit32: B$ 30          '4656612873077392578125', 0

  Fp.Bit33: B$ 30          '23283064365386962890625', 0
  Fp.Bit34: B$ 30          '116415321826934814453125', 0
  Fp.Bit35: B$ 31           '582076609134674072265625', 0
  Fp.Bit36: B$ 31           '2910383045673370361328125', 0
  Fp.Bit37: B$ 31           '14551915228366851806640625', 0
  Fp.Bit38: B$ 32            '72759576141834259033203125', 0
  Fp.Bit39: B$ 32            '363797880709171295166015625', 0
  Fp.Bit40: B$ 32            '1818989403545856475830078125', 0
  Fp.Bit41: B$ 33             '9094947017729282379150390625', 0
  Fp.Bit42: B$ 33             '45474735088646411895751953125', 0
  Fp.Bit43: B$ 33             '227373675443232059478759765625', 0
  Fp.Bit44: B$ 33             '1136868377216160297393798828125', 0
  Fp.Bit45: B$ 34              '5684341886080801486968994140625', 0
  Fp.Bit46: B$ 34              '28421709430404007434844970703125', 0
  Fp.Bit47: B$ 34              '142108547152020037174224853515625', 0
  Fp.Bit48: B$ 35               '710542735760100185871124267578125', 0

  Fp.Bit49: B$ 35               '3552713678800500929355621337890625', 0
  Fp.Bit50: B$ 35               '17763568394002504646778106689453125', 0
  Fp.Bit51: B$ 36                '88817841970012523233890533447265625', 0
  Fp.Bit52: B$ 36                '444089209850062616169452667236328125', 0
  Fp.Bit53: B$ 36                '2220446049250313080847263336181640625', 0
  Fp.Bit54: B$ 36                '11102230246251565404236316680908203125', 0
  Fp.Bit55: B$ 37                 '55511151231257827021181583404541015625', 0
  Fp.Bit56: B$ 37                 '277555756156289135105907917022705078125', 0
  Fp.Bit57: B$ 37                 '1387778780781445675529539585113525390625', 0
  Fp.Bit58: B$ 38                  '6938893903907228377647697925567626953125', 0
  Fp.Bit59: B$ 38                  '34694469519536141888238489627838134765625', 0
  Fp.Bit60: B$ 38                  '173472347597680709441192448139190673828125', 0
  Fp.Bit61: B$ 39                   '867361737988403547205962240695953369140625', 0
  Fp.Bit62: B$ 39                   '4336808689942017736029811203479766845703125', 0
  Fp.Bit63: B$ 39                   '21684043449710088680149056017398834228515625', 0
  Fp.Bit64: B$ 39                   '108420217248550443400745280086994171142578125', 0]
  ;  (???!!!...)  .000000000000000000108420217248550443400745280086994171142578125
  ; Does this mean something, internally ??? I suppose only the very first Char(s)...
  ; If this length is no use, it would be interresting to cut off (speed...).

[FPBits:
 FpBit64, FpBit63, FpBit62, FpBit61
 FpBit60, FpBit59, FpBit58, FpBit57, FpBit56, FpBit55, FpBit54, FpBit53, FpBit52, FpBit51
 FpBit50, FpBit49, FpBit48, FpBit47, FpBit46, FpBit45, FpBit44, FpBit43, FpBit42, FpBit41
 FpBit40, FpBit39, FpBit38, FpBit37, FpBit36, FpBit35, FpBit34, FpBit33, FpBit32, FpBit31
 FpBit30, FpBit29, FpBit28, FpBit27, FpBit26, FpBit25, FpBit24, FpBit23, FpBit22, FpBit21
 FpBit20, FpBit19, FpBit18, FpBit17, FpBit16, FpBit15, FpBit14, FpBit13, FpBit12, FpBit11
 FpBit10,  FpBit9,  FpBit8,  FpBit7,  FpBit6,  FpBit5,  FpBit4,  FpBit3,  FpBit2,  FpBit1

 Fp.Bits:
 Fp.Bit1,  Fp.Bit2,  Fp.Bit3,  Fp.Bit4,  Fp.Bit5,  Fp.Bit6,  Fp.Bit7,  Fp.Bit8,  Fp.Bit9,  Fp.Bit10
 Fp.Bit11, Fp.Bit12, Fp.Bit13, Fp.Bit14, Fp.Bit15, Fp.Bit16, Fp.Bit17, Fp.Bit18, Fp.Bit19, Fp.Bit20
 Fp.Bit21, Fp.Bit22, Fp.Bit23, Fp.Bit24, Fp.Bit25, Fp.Bit26, Fp.Bit27, Fp.Bit28, Fp.Bit29, Fp.Bit30
 Fp.Bit31, Fp.Bit32, Fp.Bit33, Fp.Bit34, Fp.Bit35, Fp.Bit36, Fp.Bit37, Fp.Bit38, Fp.Bit39, Fp.Bit40
 Fp.Bit41, Fp.Bit42, Fp.Bit43, Fp.Bit44, Fp.Bit45, Fp.Bit46, Fp.Bit47, Fp.Bit48, Fp.Bit49, Fp.Bit50
 Fp.Bit51, Fp.Bit52, Fp.Bit53, Fp.Bit54, Fp.Bit55, Fp.Bit56, Fp.Bit57, Fp.Bit58, Fp.Bit59, Fp.Bit60
 Fp.Bit61, Fp.Bit62, Fp.Bit63, LastFPBits: Fp.Bit64]

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  'ST0ToAscii' translates an FP value, provided in ST0, to an Ascii String, in Decimal
  or Scientific notation (depending on the Exponent size).
  
  A Pointer to the output Buffer is expected, when calling.
  
  Also expected, a Value giving the wanted number of Decimals. This number can be from
  1 to 64. 
  
  The Function does not process any rounding (in case of "0001" or "999" endings) and
  chooses by itself if the Scientific Notation is whishable or not.
  
  'ST0ToAscii' does not make any additional use of the FPU Registers for computations
  and relies entirely, for the String building, on Data Check Tables for the translation,
  which is made by direct addition upon the String (a temporary version of the String is 
  build before formating the final output to the caller's Buffer).
  
  So forth, it is not at all designed for speed competition (10 times slower than similar
  Functions, even worse on Numbers with very high and very low Exponents). As opposed to
  the reverse Function ('AsciiToST0', which, being to be used in Encoders, requires the
  higher possible speed), 'ST0ToAscii', being designed for Outputs, does not require a
  great speed, but requires to preserve the FPU Contents (at any time cost).
  
  Note that, the OS may corrupt the Contents of FPU, when runing the GDI Functions. So, 
  for viewing intermediate results, along FP computations (for viewing sub-results), you
  must not output the partial Results on the screen during your Computation, but, instead,
  you must save all of your temporary results in as many Buffers, and output them all after
  your Computations are over.
  
  Usage:
  
> [MyFp: R$ 123.0885]
> [MyFPString: B$ ? #80]
>
> fld R$MyFp
> call ST0ToAscii MyFpString, 4
;;

Proc ST0ToAscii:
    Argument @Destination, @Decimals
    Local @Exponent, @AbortPosition
    Uses esi, edi, ecx, ebx, edx
    [@String: B$ ? #90] [@Real10: T$ ?]

        mov eax @String | add eax 32 | add eax D@Decimals | mov D@AbortPosition eax

      ; Zeroed output String (20 zeros // 1 Point // XXX++ zeros):
        mov edi @String, eax '0000', ecx 23 | rep stosd | mov B@String+20 '.'

      ; Get a copy of ST0:
        fstp T@Real10 | fld T@Real10

      ; If Zero, Write and exit:
        mov eax D@Real10 | or eax D@Real10+4
        If eax = 0
@Zero:      mov edi D@Destination, D$edi '0', D$edi+1 0 | ExitP
        End_If

      ; If negative, write the Sign and adjust the output Pointer to next Pos:
        mov esi @Real10, edi D@Destination
        movzx ebx W$esi+8 | Test ebx 08000 | jz L0>
            mov B$edi '-' | and ebx (not 08000) | inc D@Destination

      ; Biased signed Exponent in ebx:
L0:     On ebx = 0, jmp @Zero

        mov D@Exponent 0

      ; It seems that the Binary exponent = 07FFF means something like "undefined" (...)
      ; and seems to appear when dividing. OK. But:
      ; It also seems that Binary exponent = 0 may be given for a zero value (...).

        If ebx < 03FFF ; Ex: 0.000123456...
            While ebx < 03FFF
                fmul R$TenTable+8
                fstp T@Real10 | fld T@Real10 | dec D@Exponent
                movzx ebx W$@Real10+8 | and ebx (not 08000)
                On ebx = 0, jmp @Zero
            End_While

        Else                                            ; Ex: 123.456...
            While ebx > (03FFF+29)
                fdiv R$TenTable+8
                fstp T@Real10 | fld T@Real10
                movzx ebx W$@Real10+8 | and ebx (not 08000) | inc D@Exponent
                On ebx = 07FFF, jmp @Zero
            End_While

        End_If

L1:     sub ebx 03FFF | mov eax ebx | shl eax 2

      ; 'ebx' will hold the pointer to the Table of Pointers to Decimal Strings.
      ; For example, if eax = 0 (Exponent 0), ebx points to 'Fp.Bit1' Pointer,
      ; in 'FPBits' Table (4 'sub' because dWords Table):
        mov ebx Fp.Bits | sub ebx eax | sub ebx 4

      ; Parse now the Mantissa (64 Bits). Each Bit is a power of 2 figured in the
      ; [FPBit64 // Fp.Bit64] Strings Table:

L1:     mov ecx 32, edx @Real10, edx D$edx+4            ; (High dWord).
L0:     shr edx 1 | jnc L5>
            lea esi D$ebx+ecx*4
            cmp esi FPBits | jb L5>
            cmp esi LastFPBits | ja L6>>
                mov esi D$esi, edi @String, eax 0
                lodsb | add edi eax | cmp edi D@AbortPosition | ja L6>>
                .While B$esi <> 0
                    On B$edi = '.', inc edi
                    cmp edi D@AbortPosition | ja L5>
                    lodsb | sub al '0' | add B$edi al | mov eax 0
                  ; Left reporting, if needed:
                    While B$edi+eax > '9'
                        sub B$edi+eax 10
                        dec eax | On B$edi+eax = '.', dec eax
                        inc B$edi+eax
                    End_While
                    inc edi
                .End_While
L5:     loop L0<

        mov ecx 32, edx @Real10, edx D$edx              ; (Low dWord).
        add ebx 4+(31*4)
L0:     shr edx 1 | jnc L5>
            lea esi D$ebx+ecx*4
            cmp esi FPBits | jb L5>
            cmp esi LastFPBits | ja L6>
                mov esi D$esi, edi @String, eax 0
                lodsb | add edi eax | cmp edi D@AbortPosition | ja L6>
                .While B$esi <> 0
                    On B$edi = '.', inc edi
                    cmp edi D@AbortPosition | ja L5>
                    lodsb | sub al '0' | add B$edi al | mov eax 0
                  ; Left reporting, if needed:
                    While B$edi+eax > '9'
                        sub B$edi+eax 10
                        dec eax | On B$edi+eax = '.', dec eax
                        inc B$edi+eax
                    End_While
                    inc edi
                .End_While
L5:     loop L0<

L6:   ; Now, format the String. First, cut off zeroed tail:
        mov esi @String | add esi 89
        While B$esi = '0' | dec esi | End_While | mov B$esi+1 0

      ; Search for first significant Char:
        mov esi @String | While B$esi = '0' | inc esi | End_While
        On B$esi = '.' dec esi

      ; Copy to caller Destination:
        mov edi D@Destination | While B$esi <> '.' | movsb | End_While
        mov B$edi 0
      ; Copy the Point and the wanted Decimals, if not End_Of_String:
        ...If B$esi+1 <> 0
            movsb                                       ; Point.
            mov ecx D@Decimals
L1:         lodsb | cmp al 0 | je L2>
                .If D$esi = '9999'
                    If D$esi+4 = '9999'
                        inc al | mov B$esi 0
                    End_If
                .End_If
                stosb | loop L1<                        ; Decimals.

L2:         While B$edi-1 = '0' | dec edi | End_While | mov B$edi 0

        ...Else
            While B$edi-1 = '0' | dec edi | inc D@Exponent | End_While

        ...End_If

        On B$edi-1 = '.', dec edi

        While B$edi-1 = '0' | dec edi | inc D@Exponent | End_While

      ; Write Exponent if Needed:
        mov eax D@Exponent

        If eax <> 0
            test eax 08000_0000 | jnz L1>
                mov D$edi ' e+ ' | jmp L2>
L1:             mov D$edi ' e- ' | neg eax
L2:         add edi 3 | mov ecx 10

            mov dl 0FF | push edx                       ; Push stack end mark
            mov ecx 10
L0:         mov edx 0
            div ecx | push edx | cmp eax 0 | ja L0<     ; Push remainders
L2:         pop eax                                     ; Retrieve Backward
            cmp al 0FF | je L9>                         ; Over?
            add al '0' | stosb | jmp L2<                ; Write
        End_If

L9:     mov B$edi 0
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
* 'AsciiToST0' reads the Ascii String expression of a Real Number, and stores it on the
  FPU Stack Top.

* Scientific or Decimal notation.

* 20 or 30% faster than fast Ascii-to-Float Routines. Twice faster than previous RosAsm one.
  
* Uses only one (ST0) FPU Register.

* No 'finit'.
  
* Usage:

>   [SourceString: B$ '12345678.12345', 0]
>
>   call AsciiToST0 SourceString 
>
>   If eax = &NO_ERROR
>       fstp F$MyReal4 // R$MyReal // ...
>   Else_If eax = TOOBIG_INTEGER
>     ; Error Message...
>   Else_If eax = TOOBIG_EXPONENT
>     ; Error Message...
>   End_If

* Eax, on return may hold &NO_ERROR, TOOBIG_INTEGER, or TOOBIG_EXPONENT
;;

[TOOBIG_INTEGER 1    TOOBIG_EXPONENT 2]

[CharAfterFpNumber: ?]

Proc AsciiToST0:
    Argument @String
    Local @Sign, @Digits
    Uses esi, edi, eax, ebx, ecx, edx
    [@Tempo: T$ ?]

        mov esi D@String, D@Sign &FALSE
        While B$esi <= ' ' | inc esi | End_While

        If B$esi = '+'
            inc esi
        Else_If B$esi = '-'
            inc esi | mov D@Sign &TRUE
        End_If

        While B$esi <= ' ' | inc esi | End_While
        While B$esi = '0' | inc esi | End_While

        mov ebx 0, ecx 0, edx 0, eax 0
L0:     lodsb
      ; cmp al '_' | je L0<
        cmp al '9' | ja L1>
        cmp al '0' | jb L1>
            lea ebx D$ebx+ebx*4 | lea ebx D$eax+ebx*2-030   ; ebx = ebx*10 + (al)-'0'
            inc ecx | cmp ecx 10 | jb L0<

L0:     lodsb
      ; cmp al '_' | je L0<
        cmp al '9' | ja L1>
        cmp al '0' | jb L1>
            lea edx D$edx+edx*4 | lea edx D$eax+edx*2-030   ; edx = edx*10 + (al)-'0'
            inc ecx | cmp ecx 18 | jb L0<
                mov eax TOOBIG_INTEGER | ExitP

L1:   ; The Integer part is now in ebx:edx. Write it in ST0:
        mov D@Digits ecx
        mov eax ebx | or eax edx
        .If eax <> 0
            mov D@Tempo ebx | fild D@Tempo
            If ecx > 10
                sub ecx 10 | lea ecx D$TenTable+ecx*8 | fmul R$ecx
                mov D@Tempo edx | fiadd D@Tempo
            End_If
        .Else
            fldz
        .End_If

      _____________________________________________________________________________
      ; Now, parse the Decimals, if any, the same way ( also limited to 18 Digits):

        ...If B$esi-1 = '.'
          ; Pop and save the Integer Part, in order to use only 1 Register:
            fstp R@Tempo

            mov ebx 0, ecx 0, edx 0, eax 0
L0:         lodsb
          ; cmp al '_' | je L0<
            cmp al '9' | ja L1>
            cmp al '0' | jb L1>
                lea ebx D$ebx+ebx*4 | lea ebx D$eax+ebx*2-030    ; ebx = ebx*10 + (al)-'0'
                inc ecx | cmp ecx 10 | jb L0<

L0:         lodsb
          ; cmp al '_' | je L0<
            cmp al '9' | ja L1>
            cmp al '0' | jb L1>
                lea edx D$edx+edx*4 | lea edx D$eax+edx*2-030    ; edx = edx*10 + (al)-'0'
                inc ecx | cmp ecx 18 | jb L0<
                    ; Too much: No Error case for Decimals > cut off.

L1:         mov eax ebx | or eax edx
          ; Decimal in ebx:edx, Write it in ST0:
            .If eax <> 0
                mov D@Tempo ebx | fild D@Tempo
                If ecx > 10
                    sub ecx 10
                        lea ecx D$TenTable+ecx*8 | fmul R$ecx
                        mov D@Tempo edx | fiadd D@Tempo
                    add ecx 10
                End_If
                lea ecx D$TenTable+ecx*8 | fdiv R$ecx
              ; Add the Integer Part previously saved in Memory:
                fadd R@Tempo

            .Else
              ; If Decimal Part = 0, load the previously saved Integer Part:
                fld R@Tempo

            .End_If
        ...End_If
      ; The Complete User Number is now in ST0.
      _____________________________________________________________
      ; Scientific Notation. (The exponent must be within +4932/-4932).
        While B$esi-1 = ' ' | inc esi | End_While

        mov al B$esi-1 | or al 32

        ...If al = 'e'
            mov edx &FALSE
            If B$esi = '-'
                mov edx &TRUE | inc esi
            Else_If B$esi = '+'
                inc esi
            End_If

          ; Compute the Exponent Value:
            mov ebx 0, eax 0, ecx 0
L0:         lodsb
         ;  cmp al '_' | je L0<
            cmp al '9' | ja L1>
            cmp al '0' | jb L1>
                lea ebx D$ebx+ebx*4 | lea ebx D$eax+ebx*2-030    ; ebx = ebx*10 + (al)-'0'
                inc ecx | cmp ecx 10 | jb L0<

L1:         If ebx > 4932
                mov eax TOOBIG_EXPONENT | ExitP
            End_If

          ; Negative Exponent, if edx = &TRUE // Exponent in ebx // User Number in ST0.
          ; No additional use of FPU Registers:
            While ebx > 0
                If ebx > 18
                    mov eax 18
                Else
                    mov eax ebx
                End_If

                If edx = &TRUE
                    fdiv R$TenTable+eax*8
                Else
                    fmul R$TenTable+eax*8
                End_If

                sub ebx eax
            End_While

        ...End_If

        On B@Sign = &TRUE, fchs

        dec esi | mov D$CharAfterFpNumber esi

        mov eax &NO_ERROR
EndP

____________________________________________________________________________________________

; 18 values, not counting '1'.

[ST0TenTable: R$ 1, 10, 100, 1000, 10_000, 100_000, 1000_000, 10_000_000
              100_000_000, 1000_000_000, 10_000_000_000

              100_000_000_000, 1000_000_000_000, 10_000_000_000_000
              100_000_000_000_000, 1000_000_000_000_000
              10_000_000_000_000_000, 100_000_000_000_000_000
              1000_000_000_000_000_000]
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 Last Kenny 'Ascii2Float':
 
 [testfloat: B$'.09e+1' 0]
[maxexp: D$100]
Function Ascii2Float:
local @numneg, @decplace, @expneg, @num, @exp
; IN:  esi = pointer to ascii string (terminated by <= space)
; OUT: st0 = floating point value

    mov D@decplace 0
    mov D@exp 0
    mov D@num 0
L1: cmp B$esi '-' | jne L1>
        mov B@numneg 1
        inc esi
L1: xor ecx ecx
    xor edx edx
L0: lodsb | inc edx
    cmp al '.' | je L1>
    cmp al 'e' | je L2>
    cmp al '9' | ja L8>
    cmp al '0' | jb L8>
    cmp al ' ' | jbe L9>
        sub al '0'                  ; convert Decimal to binary:
        lea ecx D$ecx+ecx*4         ;     ecx = ecx * 5
        lea ecx D$eax+ecx*2         ;     ecx = eax + old ecx * 10       
    jmp L0<
L1: xor edx edx | jmp L0<
L2: mov D@num ecx
    lodsb | cmp al '-' | sete B@expneg
    mov D@decplace edx
    xor ecx ecx
    jmp L0<
L8: ; Error case
L9: cmp B@decplace 0
    cmove ebx edx
    cmovne ebx D@decplace
    dec ebx
   
    xor edx edx
    cmp D@num 0
    cmove eax ecx ; eax = number
    cmovne eax D@num
    cmovne edx ecx
    mov D@num eax
    mov D@exp edx
   
    fld F$f0.1
    fld F$f10.0
   
    fild D@num
    cmp D@decplace 0 | je L2>
   
L1: fmul st2 | dec ebx | jnz L1<
   
L2: cmp edx 0 | je L9>
    cmp edx D$maxexp | cmove edx D$maxexp
    cmp B@expneg 1 | je L2>
L3:     fmul st1 | dec edx | jnz L3<
        jmp L9>
L2:     fmul st2 | dec edx | jnz L2<

L9: On B@numneg = 1, fchs
    fxch st2 | fcompp
   
    int 3
EndF
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

UsedByTheDebugger:

; From FPU to Ascii
;
; Procedures Originaly written by Tim Roberts.

[TempoAsciiFpu: ? #5] [BCDtempo: T$ ?]

[ten: R$ 10.0    ten7: 1.0e6
 ten_1: T$ 1.0e1  ,    1.0e2,    1.0e3,    1.0e4,    1.0e5,    1.0e6,    1.0e7,   1.0e8
           1.0e9,    1.0e10,   1.0e11,   1.0e12,   1.0e13,   1.0e14,   1.0e15
 ten_16:   1.0e16,   1.0e32,   1.0e48,   1.0e64,   1.0e80,   1.0e96,   1.0e112, 1.0e128
           1.0e144,  1.0e160,  1.0e176,  1.0e192,  1.0e208,  1.0e224,  1.0e240
 ten_256:  1.0e256,  1.0e512,  1.0e768,  1.0e1024, 1.0e1280, 1.0e1536, 1.0e1792
           1.0e2048, 1.0e2304, 1.0e2560, 1.0e2816, 1.0e3072, 1.0e3328, 1.0e3584, 1.0e3840
           1.0e4096, 1.0e4352, 1.0e4608, 1.0e4864]

Proc PowerOf10:
    mov ecx, eax
    test eax 0_8000_0000 | jz L1>
        neg eax

L1: fld1

    mov dl al | and edx 0f
    If edx > 0
        lea edx D$edx+edx*4 | fld T$ten_1+edx*2-10 | fmulp st1 st0
    End_If

    mov dl al | shr dl 4 | and edx 0F
    If edx > 0
        lea edx D$edx+edx*4 | fld T$ten_16+edx*2-10 | fmulp st1 st0
    End_If

    mov dl ah | and edx 01F
    If edx > 0
        lea edx D$edx+edx*4 | fld T$ten_256+edx*2-10 | fmulp st1 st0
    End_If

    test ecx 0_8000_0000 | jz L1>
        fdivp st1 st0 | ExitP
L1:     fmulp st1 st0
EndP

Proc FloatToBCD:
    Uses esi, edi, ecx

        fbstp T$BCDtempo

        lea esi D$BCDtempo+8 | mov edi TempoAsciiFpu
        mov ecx, 9

L0:     mov al B$esi | dec esi | rol ax 12 | rol ah 4
        and ax 0f0f | add ax 03030 | stosw | loop L0<
EndP

[NegatedReg: ?]

Proc FloatToUString:
    Arguments @Float80Pointer, @DestinationPointer
    Local @iExp, @ControlWord, @MyControlWord
    Uses esi, edi, edx, ecx

        mov edi D@DestinationPointer, eax D@Float80Pointer

        ..If D$eax = 0
            .If D$eax+4 = 0
                If W$eax+8 = 0
                    mov B$edi '0', B$edi+1 0 | ExitP
                End_If
            .End_If
        ..End_If

        mov B$NegatedReg &FALSE
        Test B$eax+9 0_80| jz L1>
          xor D$eax+9 0_80 | mov B$NegatedReg &TRUE | mov B$edi '-' | inc edi

L1:     ;  _______________________________________________________
        ; |        |                 |             |              |
        ; | Bit 79 | Bit 78 ... 64   | Bit 63      | Bit 62 ... 0 |
        ; | Sign   | Biased Exponent | Integer Bit | Fraction     |
        ; |________|_________________|_____________|______________|
        ;
        ; SNaN  : S=0  E=7FFF  I=1  F=1..3FFF_FFFF_FFFF_FFFF
        ; QNaN  : S=0  E=7FFF  I=1  F=4000_0000_0000_0000..7FFF_FFFF_FFFF_FFFF
        ; INF   : S=0  E=7FFF  I=1  F=0
        ; -SNaN : S=1  E=7FFF  I=1  F=1..3FFF_FFFF_FFFF_FFFF
        ; -QNaN : S=1  E=7FFF  I=1  F=4000_0000_0000_0000..7FFF_FFFF_FFFF_FFFF
        ; -INF  : S=1  E=7FFF  I=1  F=0

        ; Add: Tiny : S=x  E=0     I=0  F<>0


        movzx edx W$eax+8 | and edx 07FFF ; edx = E

        If edx = 07FFF
            On B$NegatedReg = &TRUE, xor B$eax+9 0_80
            ; test lower 32 bits of fraction
            test D$eax 0 | jnz L1>
            ; test upper 31 bits of fraction
            mov edx D$eax+4 | and edx 0_7FFF_FFFF | jnz L1>
            mov D$edi 'INF'
            ExitP

L1:         ; test most significant fraction bit
            test B$eax+7 040 | jz L1>
            mov D$edi 'QNaN', B$edi+4 0
            ExitP

L1:         mov D$edi 'SNaN', B$edi+4 0
            ExitP
        EndIf

        fclex | fstcw W@ControlWord | mov W@MyControlWord 027F | fldcw W@MyControlWord

        fld T$eax | fld st0

        fxtract | fstp st0 | fldlg2 | fmulp st1 st0 | fistp D@iExp

        .If D@iExp L 16
            fld st0 | frndint | fcomp st1 | fstsw ax
            Test ax 040 | jz L1>
                call FloatToBCD

                mov eax 17 | mov ecx D@iExp | sub eax ecx | inc ecx
                lea esi D$TempoAsciiFpu+eax

                If B$esi = '0'
                    inc esi | dec ecx
                End_If

                mov eax 0
                rep movsb | jmp L9>>

        .End_If

L1:     mov eax, 6 | sub eax D@iExp

        call PowerOf10

        fcom Q$ten7 | fstsw ax | Test ah 1 | jz L1>
            fmul Q$ten | dec D@iExp

L1:     call FloatToBCD

        lea esi D$TempoAsciiFpu+11 | mov ecx D@iExp

        If ecx = 0-1
            mov B$edi '0' | inc edi
        End_If

        inc ecx

        If ecx <= 7
            mov eax 0
            rep movsb | mov B$edi '.' | inc edi
            mov ecx 6 | sub ecx D@iExp | rep movsb

            While B$edi-1 = '0' | dec edi | End_While
            On B$edi-1 = '.', dec edi

            jmp L9>>
        Else
            movsb | mov B$edi '.' | inc edi | movsd | movsw

            mov B$edi 'e' | mov eax D@iExp
            mov B$edi+1 '+'
            Test eax 0_8000_0000 | jz L1>
                neg eax | mov B$edi+1 '-'

L1:         mov ecx 10, edx 0 | div ecx | add dl '0' | mov B$edi+4 dl
            mov edx 0 | div ecx | add dl '0' | mov B$edi+3 dl
            mov edx 0 | div ecx | add dl, '0' | mov B$edi+2 dl
            add edi 5
        End_If

L9:     mov B$edi 0 | fldcw W@ControlWord | fwait

        If B$NegatedReg = &TRUE
            mov eax D@Float80Pointer | xor D$eax+9 0_80
        End_If
EndP


[SpecialFPU: ?]

Proc DisassemblerFloatToUString:
    Arguments @Float80Pointer, @DestinationPointer
    Local @iExp, @ControlWord, @MyControlWord
    Uses esi, edi, edx, ecx

        mov B$SpecialFPU &FALSE
        mov edi D@DestinationPointer, eax D@Float80Pointer

        ..If D$eax = 0
            .If D$eax+4 = 0
                If W$eax+8 = 0
                    mov B$edi '0', B$edi+1 0 | ExitP
                End_If
            .End_If
        ..End_If

        mov B$NegatedReg &FALSE
        Test B$eax+9 0_80| jz L1>
          xor D$eax+9 0_80 | mov B$NegatedReg &TRUE | mov B$edi '-' | inc edi

L1:     ;  _______________________________________________________
        ; |        |                 |             |              |
        ; | Bit 79 | Bit 78 ... 64   | Bit 63      | Bit 62 ... 0 |
        ; | Sign   | Biased Exponent | Integer Bit | Fraction     |
        ; |________|_________________|_____________|______________|
        ;
        ; SNaN  : S=0  E=7FFF  I=1  F=1..3FFF_FFFF_FFFF_FFFF
        ; QNaN  : S=0  E=7FFF  I=1  F=4000_0000_0000_0000..7FFF_FFFF_FFFF_FFFF
        ; INF   : S=0  E=7FFF  I=1  F=0
        ; -SNaN : S=1  E=7FFF  I=1  F=1..3FFF_FFFF_FFFF_FFFF
        ; -QNaN : S=1  E=7FFF  I=1  F=4000_0000_0000_0000..7FFF_FFFF_FFFF_FFFF
        ; -INF  : S=1  E=7FFF  I=1  F=0

        ; Add: Tiny : S=x  E=0     I=0  F<>0

        movzx edx W$eax+8 | and edx 07FFF ; edx = E

        If edx = 07FFF
            mov B$SpecialFPU &TRUE | ExitP
        EndIf

        fclex | fstcw W@ControlWord | mov W@MyControlWord 027F | fldcw W@MyControlWord

        fld T$eax | fld st0

        fxtract | fstp st0 | fldlg2 | fmulp st1 st0 | fistp D@iExp

        .If D@iExp L 16
            fld st0 | frndint | fcomp st1 | fstsw ax
            Test ax 040 | jz L1>
                call FloatToBCD

                mov eax 17 | mov ecx D@iExp | sub eax ecx | inc ecx
                lea esi D$TempoAsciiFpu+eax

                If B$esi = '0'
                    inc esi | dec ecx
                End_If

                mov eax 0
                rep movsb | jmp L9>>

        .End_If

L1:     mov eax, 6 | sub eax D@iExp

        call PowerOf10

        fcom Q$ten7 | fstsw ax | Test ah 1 | jz L1>
            fmul Q$ten | dec D@iExp

L1:     call FloatToBCD

        lea esi D$TempoAsciiFpu+11 | mov ecx D@iExp

        If ecx = 0-1
            mov B$edi '0' | inc edi
        End_If

        inc ecx

        If ecx <= 7
            mov eax 0
            rep movsb | mov B$edi '.' | inc edi
            mov ecx 6 | sub ecx D@iExp | rep movsb

            While B$edi-1 = '0' | dec edi | End_While
            On B$edi-1 = '.', dec edi

            jmp L9>>
        Else
            movsb | mov B$edi '.' | inc edi | movsd | movsw

            mov B$edi 'e' | mov eax D@iExp
            mov B$edi+1 '+'
            Test eax 0_8000_0000 | jz L1>
                neg eax | mov B$edi+1 '-'

L1:         mov ecx 10, edx 0 | div ecx | add dl '0' | mov B$edi+4 dl
            mov edx 0 | div ecx | add dl '0' | mov B$edi+3 dl
            mov edx 0 | div ecx | add dl, '0' | mov B$edi+2 dl
            add edi 5
        End_If

L9:     mov B$edi 0 | fldcw W@ControlWord | fwait

        If B$NegatedReg = &TRUE
            mov eax D@Float80Pointer | xor D$eax+9 0_80
        End_If
EndP





TITLE OOA
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 OOA (Object Oriented Assembly) Parser.
 
 Author name: Betov

 eMail: < betov@free.fr >

 Home Page: ( http://betov.free.fr/RosAsm.html >
 
____________________________________________________________________________________________
____________________________________________________________________________________________

Plan for RosAsm Object Oriented Programing. (obsolete and delayed...)
____________________________________________________________________________________________
____________________________________________________________________________________________

Introduction.

I use the OOA formulation because we are talking about one Assembly OOP implementation
(not of OOP generally speacking).

The center of RosAsm OOA is the OOA Memory Manager. This is a robust and fast
Memory Manager, that provides your OOA programing with a 'vTable' holding your
Objects representations in Memory. Before any OOA programing, you have to paste
this Manager (from the [Clip] feature), in your Source. This technical choice tends 
to hide as few things as possible, and allows you to add, modify the default OOA 
Memory Manager Routines, if you want to.

____________________________________________________________________________________

A RosAsm OOA Object is a contiguous range of Memory Chunks, organised under a structured
form, holding a Call-Table (Pointers to Procedures) and Objects "private" Data.

"private", here does of course not mean that you can not access these Data by
hand when you want to. We are in Assembly... This simply means that these Data
are supposed to be accessed only by the Call-Table Procedures. It's on you to
apply this rule (or not...). Same for the polymorphism implementation. It's on 
you to not 'overload' your Call-Table' from your 'normal' Code, and to do it from
inside your OOA Procedures, instead.

Objects are Dynamically created, at run time. That is, they live only in Memory
(in vTable), at Run-Time. Their specifications are defined by the CLASS(es)
Declaration(s).
____________________________________________________________________________________________
____________________________________________________________________________________________

CLASSes are abstract (without existance in the dead File) OOA Structures giving 
informations to the RosAsm CLASS Parser. You may consider them a kind of C abstract
Structures.

CLASS Declaration:

>[CLASS Integer         ; 'Integer' will be the Instances Creator.
>  {PreviousClass}      ; {...} is (are) optional Inheritance from another CLASS.
>   SetValue, Int       ; Call-Table, (Procedures pointers with implicit Parameter(s)).
>   AddValue, Int       ; 
>   ShowValue, Int      ; 
>  {Int: D$ 0}]         ; Whatever Data in usual form, with default intitialisations.

* {Inheritance(s)} are optional and can be multiple and/or nested.

* The CLASS Call-Table is Code Procedures Pointers List defining also the default
Parameters to be silently transmitted to the Procedures. These default Parameters
can only be pointers to the same Object elements (Data Pointers, usually).

* {Data: ...} are in the same syntax as ordinary RosAsm Data Declarations, but enclosed
inside {...}, instead of [...], just the same as when Declaring Data by Macros in the
usual RosAsm Convention.


When encounted by the CLASS Parser, the 'Integer' CLASS is stored like a particular
kind of Macro, generating other Macros, and allowing all downward formulations.

You can define the default Initialisations Values of the Data when declaring the CLASS,
and, of course, with one of the Methods of the Object. Example, for overwriting some
Data Value, after the Object Instance creation:

> Integer i        ; D$i+12 = 0  (the '0' declared in the CLASS).
> i.setValue 1     ; D$i+12 = 1
____________________________________________________________________________________________

The Inheritance Declaration is as simple as can be:

[ClASS X {Integer}]

[ClASS Y {Integer}]

[ClASS LeftTop
 {X}
 {Y}]

[ClASS RightBottom
 {X}
 {Y}]

[ClASS RectPos
 {LeftTop}
 {RightBottom}]
 
________________________________________

Notice carefully the difference between:
            
            "[ClASS X {Integer}]"       ; Case 1.

            and:

            "[ClASS X               
              {Integer}]"               ; Case 2
              
            Case 1 is what OOP theory calls an "ISA" relationship, and Case 1 is an "HASA"
            relationship. (Read "Is a" // "Has a").
            
            Macros Names built by case 1 do not require pasting the original name, whereas
            Case 2 does:
            
            * In case 1, for 'SetValue', you say:  > X.SetValue 32
            
            * In case 2, for 'SetValue', you say:  > X.Integer.SetValue 32
            
            To make it short, in Case 1, 'X' is an 'Alias' of Interger. So, in the upper
            example, you have the shorter form of:
            
            > RectPos.RightBottom.X.SetValue 32
            
            ... and not:
            
            > RectPos.RightBottom.X.Integer.SetValue 32
            
            Notice also that Case 1 can only hold one single inheritance, whereas 
            Case 2 may hold as many as wished. You may consider Case 1 as a simple
            Compile time duplication (a substitute) of an existing CLASS, rather 
            than a real new CLASS creation.
              
            
When encounting {PreviousClass}, the CLASS Parser simply replaces this by the real 
"[CLASS PreviousClass...] Declaration. So... :

> RectPos MyRectanglePos
> ...
> MyRectanglePos.LeftTop.X.SetValue 32
____________________________________________________________________________________________
____________________________________________________________________________________________

The default Parameters purpose is not only to save you from having to write the 
default Parameters expected by a Procedure of the Call-Table. It is also the way
for making your Object little closed boxes with an automatic access of the Object
Procedures to the Data belonging to the object:

>Proc SetValue:
>    arguments @NamePtr, @Value
>    
>        mov esi D@NamePtr, eax D@Value, D$esi eax
>EndP

> i.SetValue 1    ; <<<<<<<<<<

; (Instead of "call D$i.SetValue D$i.Int, 1", or something like this).

____________________________________________________________________________________________
____________________________________________________________________________________________

So, first, you declare a Data Table (or Variable(s)) where to store your Objects
Handles:

[i: ?] ; User-side Objects Variable (= Handle = Pointer to vTable).

An Object Handle is nothing but a simple Pointer to the vTable created at run time, 
in Memory, when the Objects creations statements are executed:

> Integer i ; Produces the Creation and the storage in vTable of an image of the
            ; 'Integer' declared CLASS. The Return Parameter (the Pointer to
            ; Object "i", is filled with the real Pointer to the Object image set
            ; in the vTable. Eax, of course, also holds this same Value.

If "Integer i" was not unfolded by the CLASS Parser, but by yourself, 'by Hand',
it would look like this:

> call GetvTable i, 16                      ; Parameters = ObjectHandleRoom, Size.
> push eax, ebx
>   mov D$eax SetValue                      ; store METHOD
>   lea ebx D$eax+24 | mov D$eax+4 ebx      ; 'Int' Pointer default Parameter
>   mov D$eax+8 AddValue                    ; store METHOD
>   lea ebx D$eax+24 | mov D$eax+12 ebx     ; 'Int' Pointer default Parameter
>   mov D$eax+16 ShowValue                  ; store METHOD
>   lea ebx D$eax+24 | mov D$eax+20 ebx     ; 'Int' Pointer default Parameter
>   mov D$eax+24 0                          ; Store Data initial Value(s).
> pop ebx, eax

"GetvTable" (like "GetMultiplevTable") is a Main Procedure of the OOA Memory Manager. 

Not only the CLASS Parser replaces your "Integer i" statement by the previous Code 
Chunk, but, at the same time, it creates a set of pseudo-Macros, in order to make
your OOP programing friendly. Those Macros could look like this:

> [i.SetValue | mov eax D$i | call D$eax+0 D$eax+4, #1]
> [i.AddValue | mov eax D$i | call D$eax+8 D$eax+12, #1]
> [i.ShowValue | mov eax D$i | call D$eax+16 D$eax+20, #1]

You may consider them usual RosAsm syntax Macros, written for you for free by the
CLASS Parser, and immidiately unfolded by the ClASS Parser *before* all other
downward computations. If an implicit Parameter is to be given in the call to a
"Call-Table-Procedure", you just have to declare it in the CLASS, after the Procedure
Name. The upper Macros examples cover this with "D$eax+4" and friends, what will 
effectively be unfolded under the usual form of a "push D$i+12".

____________________________________________________________________________________

Usage:

> [ClASS Integer
>   SetValue, Int
>   AddValue, Int
>   ShowValue, Int
>  {Int: D$ 0}]
>
> [i: ?]
>
> TestOop:
>    Integer i     ; Object Creation (return: eax = D$i = Pointer to Integer vTable image)
>  ; ...
>    i.SetValue 01 ; D$i+12 = 1
>    i.AddValue 01 ; D$i+12 = 2
>    i.ShowValue   ; "Says 2"
>  ; ...
>    Destroy i     ; Aborts if D$i = 0 // Free the i Object vTable Memory / Set D$i to zero.
> ret


Of course, the example supposes you have 3 Procedures (SetValue, AddValue and ShowValue)
previously written the usual way, the 2 first ones expecting 2 parameters, the last one,
one Parameter.

There is absolutely nothing particular with OOA Procedures. There are nothing but usual
Procedure called in an unusual way, that is, through a Call-Table. Nothing less, 
nothing more:

>Proc SetValue:
>    arguments @NamePtr, @Value
>    
>        mov esi D@NamePtr, eax D@Value, D$esi eax
>EndP

>Proc AddValue:
>    arguments @NamePtr, @Value
>    
>        mov esi D@NamePtr, eax D@Value | add D$esi eax
>EndP

>Proc ShowValue:
>    arguments @NamePtr
>    
>        HexPrint D@NamePtr
>EndP

____________________________________________________________________________________

You can copy an existing Object into a new created one:

> Integer m From i

This formulation allows you to create, for example, a temporary Copy of an Object, 
designed for a temporary Object Data modifications.

Note that this copy does nothing but duplicating the Object: 

If, for example, in "InstanceOne", a Function has been run, in order to allocate some
memory, and to save this memory Pointer into its object Data, the "InstanceTwo" Member
holding this allocated memory Pointer *will* point to the same Memory as the one in
"InstanceOne". If you plan to have different Memories allocated for each Instance,
call the new created one Function for reinitializing the Memory Allocation and its
object Data Pointer. If you plan to have the same dynamic Data (Pointers) in several
Instances, this is the helpfull way. Of course, if your plan is to have two copies
of the Pointed Data, you have to implement a Procedure performing the allocated Data 
Copy from D$PointerOne to D$Pointertwo.

This way for Copying an Object may also be usefull in order to reduce the Code size.
As you may have noticed, each Object Creation adds some real Code in your Application.
This Code Bloat may be reduced by the usage of the "From" Keyword. For example, after
your "Interger i" Statement, instead of:

> Integer j                                 ; what will, again, add to your Code:

> call GetvTable j, 16                      ; Parameters = ObjectHandleRoom, Size.
> push eax, ebx
>   mov D$eax SetValue                      ; store METHOD
>   lea ebx D$eax+24 | mov D$eax+4 ebx      ; 'Int' Pointer default Parameter
>   mov D$eax+8 AddValue                    ; store METHOD
>   lea ebx D$eax+24 | mov D$eax+12 ebx     ; 'Int' Pointer default Parameter
>   mov D$eax+16 ShowValue                  ; store METHOD
>   lea ebx D$eax+24 | mov D$eax+20 ebx     ; 'Int' Pointer default Parameter
>   mov D$eax+24 0                          ; Store Data initial Value(s).
> pop ebx, eax

You can do:

> Integer j From i                   

; That will be unfolded as one single "call" instead of Bloatware:

> call GetvTableFrom D$i, j, 16

As this formulation may save much of Code Bloat, it is silently applied by the CLASS
Parser, when encounting Multiple Declarations:

> Integer i, j, k  ; Will be unfolded by the CLASS parser as:
>
> ; First shot:
> push eax, ebx
>   mov D$eax SetValue                      ; store METHOD
>   lea ebx D$eax+24 | mov D$eax+4 ebx      ; 'Int' Pointer default Parameter
>   mov D$eax+8 AddValue                    ; store METHOD
>   lea ebx D$eax+24 | mov D$eax+12 ebx     ; 'Int' Pointer default Parameter
>   mov D$eax+16 ShowValue                  ; store METHOD
>   lea ebx D$eax+24 | mov D$eax+20 ebx     ; 'Int' Pointer default Parameter
>   mov D$eax+24 0                          ; Store Data initial Value(s).
> pop ebx, eax

>
> ; Next shots:
> call GetvTableFrom D$i, j, 16
> call GetvTableFrom D$i, k, 16

____________________________________________________________________________________

        (> [i.SetValue | mov eax D$i | call D$eax+0 D$eax+12, #1])

Now, let us suppose you want a Table of 200 Integers Objects.

> [IntegersHandleTable: ? #200]
>
> Integer IntegersHandleTable, #200    ; <<< "#200" = "Does this 200 times"

When encounting this '#200' Parameter, the CLASS Parser, instead of creating the
usual macros (IntegersHandleTable.SetValue, IntegersHandleTable.AddValue,
IntegersHandleTable.ShowValue) create the Macros in the form of:
'esi.SetValue', 'esi.AddValue', 'esi.ShowValue'. So, limitation:
In order to not multiply no end the created Macros, only esi can be use as a pointer
to OOA handle Tables.

> [IntegersHandleTable: ? #200]
> ...
> Integer IntegersHandleTable, #200    ; <<< "#200" = "Does this 200 times"
> ...
> lea esi D$IntegershandleTable+(3*4)
> esi.SetValue 012345

Will be unfolded as:

> [IntegersHandleTable: ? #200]
> ...
> call GetvTable IntegersHandleTable, 16
> push eax, ebx
>   mov D$eax SetValue                      ; store METHOD
>   lea ebx D$eax+24 | mov D$eax+4 ebx      ; 'Int' Pointer default Parameter
>   mov D$eax+8 AddValue                    ; store METHOD
>   lea ebx D$eax+24 | mov D$eax+12 ebx     ; 'Int' Pointer default Parameter
>   mov D$eax+16 ShowValue                  ; store METHOD
>   lea ebx D$eax+24 | mov D$eax+20 ebx     ; 'Int' Pointer default Parameter
>   mov D$eax+24 0                          ; Store Data initial Value(s).
> pop ebx, eax
> 
> call GetMultiplevTableFrom D$IntegersHandleTable, IntegersHandleTable, 16, 199
> ...
> lea esi D$IntegershandleTable+(3*4)
> mov eax D$esi
> call D$eax+0 D$eax+4, 012345

____________________________________________________________________________________________
____________________________________________________________________________________________

Polymorphism formulations look like this:

> i.AddValue = SubValue

... of course to be stated *inside* one of the Call-Table Routines. Example:

>Proc SetValue:
>    arguments @NamePtr, @Value
>    
>        mov esi D@NamePtr, eax D@Value, D$esi eax
>
>        If eax > 0FFF
>            i.addValue = SubValue
>        Else_If eax < 0FF
>            i.addValue = AddValue
>        End_If
>EndP


Stating "i.addValue = SubValue" in your "normal" Code, outside the OOA Procedures,
would breack the OOP style programation, just like directely modifying *by hand*
some "private" Data of an Object. To keep it OOP-like *you* have to follow the OOP
way for doing these things. RosAsm OOA organisation does not at all control if you
are following the OOP programing rules or not. It's on your own choice.

Notice also, that, in the upper example,

> i.SubValue 3

is a wrong statement, as long as "SubValue" appears nowhere inside any CLASS
Declaration. The right statement is yet:

> i.AddValue 3

This *is* one aspect of "Polymorphism": You don't have to know and to care about
how the Object "little independant Robot" does the things once you have defined
this inside the Call-Table Routines. At the time your write your 'normal' Source,
you do not have any more to know if the robot will "add" or "sub" your Value, or
anything else. The robot itself chooses if he wants to add or sub. So, the applyed
Names are to be carefully choosen. In the ridiculous upper example, of course,
you should not say "SubValue" / "AddValue", but, "Modify". A simple way for doing
this is to give *two* Names to your default Procedure:

> Proc AddValue: Modify:             ; <<<<<< 2 Names !!!
>     arguments @NamePtr, @Value
>    
>         mov esi D@NamePtr, eax D@Value | add D$esi eax
> EndP

And to provide the general meaning default Name inside the CLASS Declaration:

> [ClASS Integer
>   SetValue, Int
>   Modify, Int      ; <<<< Default AddValue represented by the General Name.
>   ShowValue, Int
>  {Int: D$ 0}]
> ...
> Integer i
> ...
> i.Modify 1

... and go on, without caring if it is an addition or a substraction.

May be you do not see the point of this, at all. So imagine you have a ball
moving on the screen. You want this ball to grow and decrease repeatitly without
taking care of how the Robot "Ball" does this, in your 'normal' Code. Then, it
would be, simply:

> If D@Message = &WM_PAINT
>     ....
>     Ball.Size.Modify 1
>     ...

Instead of (without Polymorphism):

> If D@Message = &WM_PAINT
>     ....
>     Ball.GetSize
>
>     If B$TheBallIsGrowingUpFlag = &TRUE
>         If eax >= MAX
>             Ball.Size.SubValue 1
>             mov B$TheBallIsGrowingUpFlag &FALSE
>         Else
>             Ball.Size.AddValue 1
>         End_If
>
>     Else
>         If eax =< MIN
>             Ball.Size.AddValue 1
>             mov B$TheBallIsGrowingUpFlag &TRUE
>         Else
>             Ball.Size.SubValue 1
>         End_If
>
>     End_If
____________________________________________________________________________________________
____________________________________________________________________________________________
;;

[OOAinside: ?    PreviousSeparator: ?]

[UnfoldedCLASS: ?    TempoUnfoldedCLASS: ?    ClassUnfoldingOver: ?    ClassListPtr: ?]
[OneCLASSname: ? #80] [OneClassNamePtr: ?    OriginalClassDataPointer: ?]

;;
We Search for [CLASS ...., and store all occurence encounted in the Source into
MacroList and MacroData (the same way as for Macros). At the same time we arase
the Declarations in the Source.
;;

ClassParser:
    mov esi D$CodeSourceA, edi D$CodeSourceB | mov ecx esi | add ecx D$StripLen
    mov B$ErrorLevel 11  ; 'error11'

    move D$StatementsPtr D$StatementsTable | sub D$StatementsPtr 4
;;
[CLASS Integer   30 37 31 0D  >>> 0 7 1 ]
 {NestedClass}
 addvalue Data
 subValue Data
 {Data: 0}]      0a 0d 0a04c >>> ':' ] 
;;
    .While esi < ecx
        If B$esi = TextSign
            movsb | While B$esi <> TextSign | movsb | End_While

        Else_If D$esi = 'CLAS'
            cmp B$esi-1 OpenBracket | jne L1>
            cmp B$esi+4 'S' | jne L1>
            cmp B$esi+5 Space | jne L1>
                mov al B$esi-2, B$PreviousSeparator al
              ; Suppress the last written '[':
                dec edi

                call StoreOneCLASS | mov B$OOAinside &TRUE

        End_If

L1:     movsb
    .End_While
;;
If Some CLASS Declaration has been found, we do all the job, CLASS by CLASS:
;;
    .If B$OOAinside = &TRUE
        sub edi D$CodeSourceB | mov D$StripLen edi
        Exchange D$CodeSourceA D$CodeSourceB

        VirtualAlloc UnfoldedCLASS 10_000, TempoUnfoldedCLASS 10_000

        move D$ClassListPtr D$MacroList | add D$ClassListPtr 5

L0:     mov esi D$ClassListPtr, edi OneCLASSname

        If B$esi > 0
            While B$esi > EOI | movsb | End_While | mov B$edi 0     ; Name
            mov D$OneClassNamePtr edi
            inc esi                                                 ; EOI
            mov D$OriginalClassDataPointer esi
            lodsd                                                   ; Pointer to 'MacroData'
            mov ecx D$esi                                           ; Size
            add esi 5                                               ;( + EOI)
            mov D$ClassListPtr esi                                  ; Ready for Next Record.

            mov esi eax, edi D$UnfoldedCLASS | rep movsb | mov B$edi 0

            call UnfoldIncludedCLASSES | call UnfoldMethods
            call UnfoldPrivateData | call UnfoldOneOOA | jmp L0<    ; Loop each CLASS.
        End_If

        VirtualFree D$UnfoldedCLASS, D$TempoUnfoldedCLASS

      ; Restore the Macros Pointers for Normal Macros:
        move D$MacroListPtr D$MacroList | add D$MacroListPtr 5
        move D$MacroDataPtr D$MacroData
    .End_If

ret


StoreOneCLASS:
    push edi, ecx
        mov edi D$MacroListPtr
      ; esi > 'CLASS Name'
        add esi 6

        On B$esi < '.', error D$MissingCLASSnamePtr
      ; Store the Name into MacroList:
        While B$esi > LowSigns | movsb | End_While
        mov B$edi EOI | inc edi | inc esi

      ; Write Pointer to Body Data:
        mov eax D$MacroDataPtr | stosd | mov ebx edi
        mov edi eax
; [CLASS X = Integer]
      ; Now write the Data Body for the instruction > Name i
;;
> [ClASS Integer
>   SetValue, Int
>   AddValue, Int
>   ShowValue, Int
>  {Int: D$ 0}]
>
> [i: ?]
>
> TestOop:
>    Integer i     ; Object Creation (return: eax = D$i = Pointer to Integer vTable image)
>  ; ...
>    i.SetValue 01 ; D$i+12 = 1
>    i.AddValue 01 ; D$i+12 = 2
>    i.ShowValue   ; "Says 2"
>  ; ...
>    Destroy i     ; Aborts id D$i = 0 // Free the i Object vTable Memory / Set D$i to zero.
> ret

If "Integer i" was not unfolded by the CLASS Parser, but by yourself, 'by Hand',
it would look like this:

> call GetvTable i, 16              ; Parameters = ObjectHandleRoom, Size.
> mov D$eax SetValue | add eax 4    ; store METHOD(s).
> mov D$eax AddValue | add eax 4    ; ...
> mov D$eax ShowValue | add eax 4   ; ...
> mov D$eax 0                       ; Store Data initial Value(s).
;;
        mov edx esi, ecx 0

        While B$esi <> CloseBracket
            lodsb
            If al = EOI
                mov al meEOI
            Else_If al = '{' | inc ecx
                mov al OpenVirtual
            Else_If al = '}' | dec ecx
                mov al CloseVirtual
            End_If
            stosb
        End_While
        On ecx <> 0, error D$UnPairedNestedBracketsPtr

        mov D$MacroDataPtr edi

      ; Write size into MacroList:
        mov ecx esi | sub ecx edx
        mov D$ebx ecx | add ebx 4 | mov B$ebx EOI | inc ebx | mov D$MacroListPtr ebx

      ; Adjust Source Pointer:
        inc esi | mov al B$esi
        On al = B$PreviousSeparator, inc esi

    pop ecx, edi
ret


;;
If a CLASS Declaration body (in MacroData) includes a {Inheritance}, we unfold it now.
This is to say, if this is stored:

[CLASS Integer         ; 'Integer' will the Instances Creator.
  ;{PreviousClass}      ; {...} is (are) Inheritance from another CLASS.
   SetValue, Int       ; Call-Table, (Procedures pointers with implicit Parameter(s).
   AddValue, Int       ; 
   ShowValue, Int      ; 
  {Int: D$ 0}]

[ClASS X
 {Integer}]
 
... We turn the this last {Integer] into:

 X.SetValue, X.Int       ; Call-Table, (Procedures pointers with implicit Parameter(s).
 X.AddValue, X.Int       ; 
 X.ShowValue, X.Int      ; 
{X.Int: D$ 0}]
;;


UnfoldIncludedCLASSES:

L0: mov B$ClassUnfoldingOver &TRUE

    mov esi D$UnfoldedCLASS, edi D$TempoUnfoldedCLASS

  ; Case ot [CLASS X ISA Integer]:
  ;  If D$esi = 03415349
  ;      call ClassSubstitute    ; 'ISA ' >>> 03415349
  ;      jmp L0<
  ;  End_If

L1: .While B$esi > 0
        lodsb

        ..If al = OpenVirtual
            mov ebx esi | While B$ebx > LowSigns | inc ebx | End_While

            .If B$ebx = CloseVirtual
              ; Cases of {InHeritance}
                push ebx
                    call AppendThisClassName esi
                    call CopyThisCLASS | mov B$ClassUnfoldingOver &FALSE
                    If B$NestedClassInside = &TRUE
                        While B$esi-1 > 0 | movsb | End_While
                        Exchange D$UnfoldedCLASS D$TempoUnfoldedCLASS
                        pop ebx | jmp L0<<
                    End_If
                    call StripThisClassName
                pop esi
                inc esi

            .Else
              ; If it is not CloseVirtual, it may be a ColonSign >>> Data (the UnPaired '{}'
              ; checked with Data parsing):
L2:             stosb
            .End_If

        ..Else
          ; If not OpenVirtual >>> Call-Table.
            stosb
        ..End_If
    .End_While

    mov B$edi 0 | Exchange D$UnfoldedCLASS D$TempoUnfoldedCLASS

    If B$ClassUnfoldingOver = &FALSE
      ;  call UpdateMacroData |
      jmp L0<<
    End_If
ret

; In Case ot [CLASS NewClassName = ClassName], we do nothing but substitute the MacroList
; Pointer and Size with the ones of the "Mother" CLASS. This is to say that Two entries
; will exist (2 different Names), for the same CLASS Data. The "= ClassName", in MacroData
; is simply lost:

ClassSubstitute:
  ; D$OriginalClassDataPointer yet points to this Class Pointer to macroList.
L0: add esi 4
    call SearchMacroListClassName
  ; >>> eax = Pointer to MacroData // ecx = Size.
;    If D$eax = 03415349   ; 'ISA ' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
;        mov esi eax | jmp L0<
;    Else
;        mov ebx D$OriginalClassDataPointer, D$ebx eax, D$ebx+4 ecx
;        mov esi eax, edi D$UnfoldedCLASS | rep movsb | mov B$edi 0
;    End_If
ret


UpdateMacroData:
    mov esi D$UnfoldedCLASS, edi D$MacroDataPtr, ecx 0
  ; New Pointer to MacroData, in MacroList:
    mov ebx D$OriginalClassDataPointer,  D$ebx edi | add ebx 4
  ; Copy the new Body at end of MacroData:
    While B$esi <> 0 | movsb | inc ecx | End_While
  ; New Body Length in MacroList and adjust the Writing Pointer:
    mov D$ebx ecx, D$MacroDataPtr edi
ret


Proc AppendThisClassName:
    Argument @Source
    Uses esi, edi

        mov esi D@Source, edi D$OneClassNamePtr, B$edi '.' | inc edi
        While B$esi > LowSigns | movsb | End_While | mov B$edi 0
        mov D$OneClassNamePtr edi
EndP


StripThisClassName:
  ;  mov eax D$OneClassNamePtr
  ;  While B$eax <> '.' | dec eax | End_While
  ;  mov B$eax 0, D$OneClassNamePtr eax
    mov eax OneCLASSname
    While B$eax <> '.' | inc eax | End_While
    mov B$eax 0, D$OneClassNamePtr eax
ret


SearchMacroListClassName:
    push edi, esi
        mov edi D$MacroList | add edi 5

L0:     mov edx edi | lodsb
        While al = B$edi
            On al < LowSigns, jmp L1>
            lodsb | inc edi
        End_While

        ..If al < LowSigns
L1:         .If B$edi < Separators
              ; Found:
                inc edi
                mov eax D$edi           ; Pointer to MacroData.
                mov ecx D$edi+4   ; Size.
                jmp L9>

            .Else
L2:             pop esi | push esi

                While B$edi > Separators | inc edi | End_While | add edi 10
                If B$edi = 0
                    mov ebx esi | While B$ebx <> CloseVirtual | inc ebx | End_While
                    mov B$ebx 0 | Error D$NoParentClassPtr
                Else
                    jmp L0<
                End_If
            .End_If
        ..Else
            jmp L2<
        ..End_If

L9: pop esi, edi
ret                 ; eax = Pointer to MacroData // ecx = Size.


[NestedClassInside: ?]

CopyThisCLASS:
    call SearchMacroListClassName
    mov B$NestedClassInside &FALSE
  ; Copy Parent CLASS Body, and add the actual CLASS Name before all Components, but
  ; nested Inheritances:
    push esi
        mov esi eax

L0:     ..If B$esi = OpenVirtual

            Do
                .If B$esi > LowSigns
                    mov ebx esi | While B$ebx > LowSigns | inc ebx | End_While
                  ; Cases of Data Declaration: Add the Actual Class Name:
                    If B$ebx = ColonSign
                        Call CopyActualClassName

                        While B$esi > ColonSign
                            movsb | dec ecx | jz L9>
                        End_While

                    Else
                        mov B$NestedClassInside &TRUE

                    End_If
                .End_If

                movsb | dec ecx | jz L9>
            Loop_Until B$esi = CloseVirtual

            movsb | dec ecx | jz L9>
            jmp L0<

        ..Else
          ; In case the first written element start with a Method Char:
            If B$esi < LowSigns
                movsb | dec ecx | jz L9>
                jmp L0<

            Else
                call CopyActualClassName

                While B$esi > Space
                    movsb | dec ecx | jz L9>
                End_While
                movsb | dec ecx | jz L9>
                jmp L0<<

            End_If

        ..End_If

L9: pop esi
ret

CopyActualClassName:
    push esi
        mov esi OneCLASSname
        While B$esi > 0 | movsb | End_While | mov al '.' | stosb
    pop esi
ret


UnfoldMethods:

ret


UnfoldPrivateData:

ret


UnfoldOneOOA:

ret





TITLE IncInc

;;
  Purpose: Modifying at once a TITLE for several RosAsm PEs. This Title must have
  an identical .inc Version on the Disk. Modifying the File.inc will automatically
  modify the Title(s) in all concerned PEs when re-Compiling them.

  When reading:

  >PREPARSE IncInclude

  the Parser parses, for example, the:

  >INCINCLUDE E:\RosAsm\Macros.inc

  Statement, opens the indicated File and compares it with the actual
  
  TITLE Macros

  If identical, it does nothing. If different, it replaces the concerned Title, both
  in the user Source, and in the actually computed 'Cooked Source'.
;;


;;
    Added by /\\o//\(Half). updated 01/10
    
    Add resource 10, a dialog, that shows all includes, as a checklist for inclusion
    (if incincludes are present)
    
    Wanted really a CHECKLIST instead of a ListBox, 
    but added a list box, and fills it with yes no, when clicked instead.
    --Plus one list saying MOD for the files that differs from current source
    A button toggles between yes and no to include everything.
    
;;

[IncludeListBox                     101
 IncludeCheckListBox                102
 IncludeChangedCheckListBox         103
 SelectAllButton                    10
 id_IncludeListCompilationDialog    30]

[IncludeUncheckedString:"No  " 0
 IncludeCheckedString:  "Yes " 0
 IncludeChangedString:  "Mod" 0
 IncludeUnChangedString:" " 0]

[IncInc_MaxFiles 100]

[IncludeListCompilationDialog.Handle:  ?

 Incinc.FileList:                       ?
;;
   The file list is formated as :
   Count, SizeString1, String1, SizeString2, String2 ....ect... (Temp virtual mem)
   where SizeString is a "packed" dword, where the upper word is 0FF00 before
   the dialog is shown, to indicate MODIFIED titles. And it is 0FFFF on exit
   to tell which file has been selected. The lower word is the Length of the
   string.
;;

 EnableSubstitution:                    ?
;;
 This is a boolean variable that when TRUE, will include changed files and when 
 false will only evaluate state.
;;

 IncInc.TitleChanged:                   ?
 ; Set to true per file, when the file differs from source

 IncInc.SomeTitleHasChanged:            ?]
;;
    Set to true if ANY of the titles has changed
    and skips showing the dialog if no titles 
    changed.
;;

;;
   Uses the Incinc.FileList memory
   to display 3 lists [FILENAME, SELECTSTATUS, CHANGEDSTATUS]
;;
FillIncludeListBox:
    mov ebx D$Incinc.FileList
    mov edx D$Incinc.FileList
    push D$edx
        add ebx 4
      L0:
        add ebx 4
        push ebx edx
            push ebx
                mov eax D$ebx-4
                movzx eax ax
                add ebx eax
                while b$ebx <> '\' | dec ebx | end_while
                call 'user32.SendDlgItemMessageA',
                    D$IncludeListCompilationDialog.Handle,
                    IncludeListBox,
                    &LB_ADDSTRING,
                    0,
                    ebx
                call 'user32.SendDlgItemMessageA',
                    D$IncludeListCompilationDialog.Handle,
                    IncludeCheckListBox,
                    &LB_ADDSTRING,
                    0,
                    IncludeUncheckedString
            pop ebx
            mov eax D$ebx-4 | shr eax 16 | cmp ax 0ff00 | jne L1>
                call 'user32.SendDlgItemMessageA',
                    D$IncludeListCompilationDialog.Handle,
                    IncludeChangedCheckListBox,
                    &LB_ADDSTRING,
                    0,
                    IncludeChangedString

                jmp L2>
            L1:
                call 'user32.SendDlgItemMessageA',
                    D$IncludeListCompilationDialog.Handle,
                    IncludeChangedCheckListBox,
                    &LB_ADDSTRING,
                    0,
                    IncludeUnChangedString
            L2:
        pop edx ebx
        mov eax D$ebx-4





        movzx eax ax
        add ebx eax
        dec D$edx | jnz L0<<
    pop D$edx

ret

[SelItem: ?]

;;
   Retrive the current selected listbox item, 
   and mark the corresponding file as selected in the Incinc.FileList
;;

ToggleIncludeFileList:
  call 'user32.SendDlgItemMessageA',
    D$IncludeListCompilationDialog.Handle,
    IncludeListBox,
    &LB_GETCURSEL,
    0,
    0

  mov D$SelItem eax

  ;*bininc.filename* is available, because we will rewrite it later, so we borrow it
  call 'user32.SendDlgItemMessageA',
        D$IncludeListCompilationDialog.Handle,
        IncludeCheckListBox,
        &LB_GETTEXT,
        eax,
        bininc.Filename

  mov ebx bininc.Filename

  cmp D$ebx 'Yes ' | je L0>
    call SetIncludeCheckList IncludeCheckedString
    jmp L1>
  L0:
    call SetIncludeCheckList IncludeUnCheckedString
  L1:

ret

;;
    Marks the selected file as included, exludes and
    updates the list. 
;;

Proc SetIncludeCheckList:
Argument @Value

  mov ecx D$SelItem
  mov edx D$Incinc.FileList
  add edx 4
  while ecx > 0
      mov eax D$edx
      and eax 0_FFFF
      add edx eax
      add edx 4
      dec ecx
  end_while

  if D@Value = IncludeCheckedString
    or D$edx 0_FFFF_0000
  else
    and D$edx 0_FFFF
  end_if

  call 'user32.SendDlgItemMessageA' D$IncludeListCompilationDialog.Handle,

                                    IncludeCheckListBox, &LB_INSERTSTRING D$SelItem, D@Value
  inc D$SelItem
  call 'user32.SendDlgItemMessageA' D$IncludeListCompilationDialog.Handle,

                                    IncludeCheckListBox, &LB_DELETESTRING D$SelItem, 0
EndP

;;
    Tests the first listbox item and sets all item to the oposite value
;;
ToggleAll:
  call 'user32.SendDlgItemMessageA' D$IncludeListCompilationDialog.Handle,
                                      IncludeCheckListBox, &LB_GETTEXT 0, bininc.Filename
  mov ebx bininc.Filename
  cmp D$ebx 'Yes ' | je L0>

  call 'user32.SendDlgItemMessageA' D$IncludeListCompilationDialog.Handle,
                                    IncludeCheckListBox, &LB_GETCOUNT 0, 0
  mov D$SelItem 0
  While D$SelItem < eax
     push eax | call SetIncludeCheckList IncludeCheckedString | pop eax
  End_While
ret
  L0:

  call 'user32.SendDlgItemMessageA' D$IncludeListCompilationDialog.Handle,
                                    IncludeCheckListBox, &LB_GETCOUNT 0, 0
  mov D$SelItem 0
  While D$SelItem < eax
     push eax | call SetIncludeCheckList IncludeUnCheckedString | pop eax
  End_While
ret

;;
    Callback for the dialog.
;;
Proc IncludeListCompilationDialogCallBack:
    Arguments @Adressee, @Message, @wParam, @lParam

        pushad

        mov eax &FALSE
        ..If D@Message = &WM_COMMAND
            mov eax D@wParam
            If D@wParam = &IDCANCEL
                call 'USER32.EndDialog' D@Adressee, 0
            else_if,
               ax = IncludeListBox
               shr eax 16
               cmp ax &LBN_DBLCLK | jne L0>
                  call ToggleIncludeFileList
               L0:
            else_if,
               ax = SelectAllButton
                  call ToggleAll
            End_If

            On D@wParam = &IDOK, call 'USER32.EndDialog',
                                      D$IncludeListCompilationDialog.Handle,
                                      1



        ..Else_If D@Message = &WM_INITDIALOG
            mov eax D@Adressee | mov D$IncludeListCompilationDialog.Handle eax
            call FillIncludeListBox

        ..Else

            popad | mov     eax &FALSE | ExitP
        ..End_if

        popad | mov eax &TRUE
EndP


;;
    called to display the dialog
    the  Incinc.FileList must be initialized.
;;
DisplayIncludeListCompilationDialog:
  call 'USER32.DialogBoxParamA',
   D$hInstance,
   id_IncludeListCompilationDialog ,
   0,
   IncludeListCompilationDialogCallBack,
   0
ret
____________________________________________________________________________________________

[incinc.errornotfound: B$ 'IncIncluder: File not found!' 0
 incinc.errorsize: B$ 'IncIncluder: File size is greater than 1MB!' 0
 incinc.errorSyntax: B$ 'Bad INCINCLUDE syntax', 0]


;;
    This is the original code. Basically locates and
    compares the TITLE in this app, against the loaded title
    (loaded at D$bininc.mem)
    
    
    My additions is just to compile a list of the changed and unchanged files
    and show to the user so he can select the once to update.
;;

IncParser: UpdateTitlesFromIncludeFiles:
    mov D$OldStackPointer esp

    call GetResourcesSize
    add eax D$SourceLen | add eax 1_000_000 | add eax D$MemReservation
    mov D$AsmTablesLength eax
    VirtualAlloc CodeSourceA eax | add D$CodeSourceA 010
    call NewCopyToCodeSourceA D$CodeSource, D$SourceLen

    call CheckTextDelimitersPairing
    call KillMultiLineComments ; and Comments
   ; call KillSingleLineComments
    call NewKillVirtualCRLF
    call KillMeaninglessCommas
    call CheckandKillPreParsers


    mov B$ErrorLevel 9
    mov D$IncInc.SomeTitleHasChanged &FALSE
    mov D$EnableSubstitution &FALSE
    VirtualAlloc Incinc.FileList (&MAXPATH*IncInc_MaxFiles)

    mov esi D$CodeSourceA
    mov ecx esi | add ecx D$StripLen | mov D$EcxSave ecx

    .While esi < D$EcxSave
        cmp D$esi   'INCI' | jne L8>>
        cmp D$esi+4 'NCLU' | jne L8>>
        cmp W$esi+8 'DE'   | jne L8>>
        cmp B$esi-1 LF | jne L8>>
        cmp B$esi+10 ' ' | ja L8>>

        add esi 10
L3:     inc esi | cmp B$esi ' ' | jbe L3<

        mov edx bininc.filename
L3:         mov al B$esi | mov B$edx al
            inc esi | inc edx
        cmp B$esi ' ' | ja L3<
        mov B$edx 0

      ; Clear the 'INCLUDE xxxxxxx' Statement:
        mov ebx esi | While D$esi <> 'INCI' | dec esi | End_While
        While esi < ebx | mov B$esi ' ' | inc esi | End_While

____________________________________________________________________________________________
;;
    Generate a file list, and show to user before including any of those
;;
        mov ebx D$Incinc.FileList | inc D$ebx | add ebx 4

        While D$ebx <> 0
            mov eax D$ebx | and eax 0_FFFF
            add ebx eax | add ebx 4 |
        End_While

        add ebx 4
        mov edx bininc.filename
        push ebx
            While b$edx <> 0
                push w$edx | pop w$ebx
                cmp b$edx+1 0 | add edx 2
                add ebx 2 | je L0> |
            End_While
            inc ebx
            jmp L1>
            L0:

            L1:
        pop ecx
____________________________________________________________________________________________

        pushad
            call ReadIncFile
            If eax = &TRUE
                mov D$IncInc.TitleChanged &FALSE
                call CompareIncToTitle
                VirtualFree D$bininc.mem
            Else
            End_If
        popad
____________________________________________________________________________________________

        sub ebx ecx | xchg ebx ecx
        mov D$ebx-4 ecx
        if D$IncInc.TitleChanged = &TRUE
           or D$ebx-4 0_ff00_0000
           mov D$IncInc.SomeTitleHasChanged &TRUE
        end_if


L8:     inc esi
    .End_While

    mov edx D$Incinc.FileList
    cmp D$edx 0 | je L9>>


    cmp D$IncInc.SomeTitleHasChanged &TRUE | jne L9>>

    call DisplayIncludeListCompilationDialog

    ..if eax = &IDOK


       mov edx D$Incinc.FileList
       mov ecx D$edx
       add edx 4
       .while ecx > 0
            mov eax d$edx
            and D$edx 0_FFFF
            shr eax 16
            add edx 4
            .If ax = 0FFFF
              pushad
                mov edi bininc.filename
                mov ecx &MAXPATH | mov eax 0 | shr ecx 2 | rep stosd
                mov eax bininc.filename
                while b$edx <> 0
                      push w$edx | pop w$eax
                      cmp b$edx+1 0 | je L0>
                      add edx 2 | add eax 2
                End_While
                L0:
                call ReadIncFile
                If eax = &TRUE
                    mov D$EnableSubstitution &TRUE
                    mov D$IncInc.TitleChanged &FALSE
                    call CompareIncToTitle
                    VirtualFree D$bininc.mem
                Else
                End_If
              popad

            .End_if
            add edx D$edx-4
            dec ecx
       .end_while




    ..End_If


  L9:
    VirtualFree D$Incinc.FileList
    VirtualFree D$CodeSourceA | mov D$CodeSourceA 0
ret

ClearIncludeStateMentsFromSource:
 mov esi D$CodeSourceA
 mov ecx esi | add ecx D$StripLen | mov D$EcxSave ecx
 .While esi < D$EcxSave
        cmp D$esi   'INCI' | jne L8>>
        cmp D$esi+4 'NCLU' | jne L8>>
        cmp W$esi+8 'DE'   | jne L8>>

        add esi 10

L3:     inc esi | cmp B$esi ' ' | jbe L3<

        mov edx bininc.filename
L3:         mov al B$esi | mov B$edx al
            inc esi | inc edx
        cmp B$esi ' ' | ja L3<
        mov B$edx 0

        mov ebx esi | While D$esi <> 'INCI' | dec esi | End_While
        While esi < ebx | mov B$esi ' ' | inc esi | End_While

L8:     inc esi
 .End_While


ret
____________________________________________________________________________________________

ReadIncFile:
    pushad
        call 'KERNEL32.CreateFileA' bininc.filename,
                                    &GENERIC_READ,
                                    &FILE_SHARE_READ__&FILE_SHARE_WRITE,
                                    &NULL,
                                    &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL,
                                    &NULL
        mov D$bininc.filehandle eax

        .If eax = &INVALID_HANDLE_VALUE
            mov eax incinc.errornotfound | call MessageBox
            popad
            mov eax &FALSE | ret
        .End_If

        call 'KERNEL32.GetFileSize' eax, 0 | mov D$bininc.filesize eax | add eax 4
;;
        .If eax > (1024*1024*2) ; 1MB
            mov eax incinc.errorsize | call MessageBox
            call 'KERNEL32.CloseHandle' D$bininc.filehandle
            popad
            jmp L8>>
        .End_If
;;
        VirtualAlloc bininc.mem eax
        mov ebx D$bininc.mem, D$ebx CRLF2 | add D$bininc.mem 4

        call 'KERNEL32.ReadFile' D$bininc.filehandle, D$bininc.mem, D$bininc.filesize,
                                 NumberOfReadBytes, 0
        call 'KERNEL32.CloseHandle' D$bininc.filehandle
    popad

    mov eax &TRUE
ret
____________________________________________________________________________________________

[INcSuccess: ?    IncTitleName: ?    StartOfChunk: ?    EndOfChunk: ?]

CompareIncToTitle:
    mov B$IncSuccess &FALSE

    call CoolParsersOnInc

    mov edi bininc.filename
    While B$edi <> 0 | inc edi | End_While
    While B$edi <> '\'
        dec edi | On edi = bininc.filename, jmp L1>
        On B$edi = '.', mov B$edi 0
    End_While
    inc edi

L1: mov D$IncTitleName edi

L1: mov esi D$CodeSourceA, edx D$StripLen | add edx esi

    .While esi < edx
        ...If B$esi = '"'
            Do | inc esi | Loop_Until B$esi = '"'
        ...Else_If B$esi = "'"
            Do | inc esi | Loop_Until B$esi = "'"
        ...Else_If D$esi = 'TITL'
            ..If B$esi-1 = LF
                On W$esi+4 <> 'E ', jmp L0>>
                    mov D$StartOfChunk esi | add esi 5
                    While B$esi = ' ' | inc esi | End_While
                    push edi
                        mov ecx 0FF | repe cmpsb
                        .If B$edi-1 = 0
                            push esi, edi
                                mov edi D$bininc.mem,  ecx D$bininc.filesize
                                While D$esi <> 'TITL' | dec esi | End_While

                                L5: repe cmpsb
                                cmp b$esi-1 '$' | je L5<

                                While D$esi  <> 'TITL'
                                    On esi = edx, jmp L1>
                                    On B$esi > ' ', inc ecx
                                    inc esi
                                End_While
L1:                             mov D$EndOfChunk esi
                            pop edi, esi

ininc_ChangesBegin:
______________________________________________
                            If ecx <> 0
;;
  This was used as a small security against overwriting NEW code
  earlier. It still works, but isnt needed.
  
  
                                push ecx
                                  call 'USER32.MessageBoxA' 0, D$IncTitleName,
                                  IncDoneTitle, 
                                  &MB_SYSTEMMODAL + &MB_YESNOCANCEL + &MB_ICONQUESTION
                                pop ecx
                                cmp eax &IDYES|jne @SkipIncludingFile
                                cmp eax &IDCANCEL|jne @IncludeIt

                                mov B$INcSuccess &FALSE| pop edi | jmp L9>
;;
                               @IncludeIt:
                                mov D$IncInc.TitleChanged &TRUE
                                cmp D$EnableSubstitution &TRUE | jne @SkipIncludingFile
                                call SubstituteTitleByCookedInc
                                call SubstituteUserTitleByInc
                                mov esi D$IncTitleName, edi IncDoneTitle | add edi 22
                                While B$esi <> 0 | movsb | End_While | mov B$edi 0


                            End_If
 ______________________________________________


                            @SkipIncludingFile:

                            mov B$INcSuccess &TRUE| pop edi | jmp L9>


                        .End_If
                    pop edi
            ..End_If
        ...End_If

L0:     inc esi
    .End_While


[NoIncTitle: B$ 'Include File.inc without the required TITLE                           ', 0]
[IncDoneTitle: B$ "You current include file is diffrent from shared source." ,
                  " Overwrite current TITLE ???? " , 0]

L9: If B$INcSuccess = &FALSE
        mov esi D$IncTitleName, edi NoIncTitle | add edi 44
        While B$esi <> 0 | movsb | End_While | mov B$edi 0

        error NoIncTitle
    End_If
ret
____________________________________________________________________________________________

[ModifiedSourceSize: ?]

SubstituteTitleByCookedInc:  ; ControlD asmmain
    mov ebx D$CodeSourceA | add ebx D$StripLen
    mov edx D$CodeSourceA | add edx D$SourceLen | add edx 1_000_000
    mov ecx D$bininc.mem | add ecx D$bininc.filesize

    mov eax D$EndOfChunk | sub eax D$StartOfChunk
    sub eax ecx | add eax D$bininc.mem
    neg eax | mov D$ModifiedSourceSize eax

    call ChunkReplace D$StartOfChunk, D$EndOfChunk, ebx, edx, D$bininc.mem, ecx

    mov eax D$ModifiedSourceSize | add D$StripLen eax
ret


SubstituteUserTitleByInc:
    VirtualFree D$bininc.mem

  ; Restore the File.inc extension:
    mov esi bininc.filename | While B$esi <> 0 | inc esi | End_While | mov B$esi '.'
    call ReadIncFile

    mov eax D$bininc.mem | add eax D$bininc.filesize | mov ecx eax

    mov eax D$StartOfChunk | sub eax D$CodeSourceA | add eax D$CodeSource
    mov D$StartOfChunk eax

    mov ebx D$EndOfChunk | sub ebx D$CodeSourceA | add ebx D$CodeSource
    mov D$EndOfChunk ebx

    call ChunkReplace D$StartOfChunk, D$EndOfChunk, D$SourceEnd, D$EndOfSourceMemory,
                      D$bininc.mem, ecx

    mov eax D$ModifiedSourceSize | add D$SourceEnd eax | add D$SourceLen eax

    mov edi D$SourceEnd, D$edi CRLF2
ret









TITLE BinInc


;;
____________________________________________________________________________________________
____________________________________________________________________________________________

                    Binary File Includer. Author: Kenny.
                    
____________________________________________________________________________________________

I did several minor modification to the original version:

* Write the Bytes Values in Hexa Format (faster than Decimal).

* Replace the Equate form for the Data Length by a usual 'len' in Data.

This small Pre-Parser seems to me a good idea. Something like RcData, directely into
.Data section, and, so forth more flexible, and without the .rsrc size problem and
usual complications.


Betov.
____________________________________________________________________________________________
____________________________________________________________________________________________

This is a preparser that adds a file to the source at compile time. The syntax is as follows

PREPARSE BinIncluder ; <- this enables the preparser to look for the keyword 'bininclude'
[bininclude myfile.xxx:] ; <- this tells the parser what file to include...

the preparser opens the file, and inputs the file as binary into the data section by creating
something that looks like this:

   [myfile.xxx: B$ 01E 026 085 ... 05 028 08F ... myfile.xxx_Len: len]

You will never actually see the above, but you can use it like it's there:

 > mov al B$myfile.xxx      ; al = 010
 > mov eax myfile.xxx       ; eax = pointer to the file contents
 > mov eax myfile.xxx_len   ; eax = size of file

Enjoy!...
;;

[bininc.filename: B$ ? #&MAX_PATH]
[bininc.filehandle: D$ ?   bininc.filesize: D$ ?   bininc.mem: D$ ?   EcxSave: ?]
[bininc.errornotfound: B$ 'BinIncluder: File not found!', 0
 bininc.errorsize: B$ 'BinIncluder: File size is greater than 1MB!', 0
 bininc.errorSyntax: B$ 'Bad BININCLUDE syntax', 0]

BinIncluderParser:
    call ExtendMemForBinIncluder

    mov esi D$CodeSourceA, edi D$CodeSourceB
    mov ecx esi | add ecx D$StripLen | mov D$EcxSave ecx


    .While esi < D$EcxSave
        cmp D$esi   'BINI' | jne L8>>
        cmp D$esi+4 'NCLU' | jne L8>>
        cmp W$esi+8 'DE'   | jne L8>>
        cmp B$esi-1 Openbracket | jne L8>>

        add esi 10
L3:     inc esi | cmp B$esi ' ' | jbe L3<

        mov edx bininc.filename
L3:         mov al B$esi | mov B$edx al
            inc esi | inc edx
        cmp B$esi ' ' | ja L3<
        mov B$edx 0

        pushad
            call 'KERNEL32.CreateFileA' bininc.filename,
                                        &GENERIC_READ,
                                        &FILE_SHARE_READ__&FILE_SHARE_WRITE,
                                        &NULL,
                                        &OPEN_EXISTING,
                                        &FILE_ATTRIBUTE_NORMAL,
                                        &NULL
            mov D$bininc.filehandle eax

            call 'KERNEL32.GetFileSize' eax, 0 | mov D$bininc.filesize eax

            VirtualAlloc bininc.mem eax

            call 'KERNEL32.ReadFile' D$bininc.filehandle, eax, D$bininc.filesize,
                                     NumberOfReadBytes 0
            call 'KERNEL32.CloseHandle' D$bininc.filehandle
        popad

        push esi
            mov esi bininc.filename
L3:         movsb | cmp D$esi 0 | jne L3<
        pop esi

        movsb ; store the colonsign

        mov al 'B' | stosb | mov al memMarker | stosb

        push esi
            mov esi D$bininc.mem
            mov ecx D$bininc.filesize
L3:         movzx eax B$esi | inc esi | call WriteEax
            mov al Space | stosb | loop L3<

            mov esi bininc.filename
            While B$esi > 0 | movsb | End_While
            mov D$edi 'LEN:' | mov B$edi+3 ColonSign | add edi 4
            mov D$edi 'LEN]' | add edi 3

            push edi
                VirtualFree D$bininc.mem
            pop edi
        pop esi

L8:     movsb
    .End_While

    sub edi D$CodeSourceB | mov D$StripLen edi
    Exchange D$CodeSourceA D$CodeSourceB
ret


[InIncludeSize: ?    CopyOfCodeSourceA: ? CopyOfCodeSourceB: ?]

ExtendMemForBinIncluder:
    mov B$ErrorLevel 9
    mov esi D$CodeSourceA, D$InIncludeSize 0
    mov ecx esi | add ecx D$StripLen | mov D$EcxSave ecx

    .While esi < D$EcxSave
        cmp D$esi   'BINI' | jne L8>>
        cmp D$esi+4 'NCLU' | jne L8>>
        cmp W$esi+8 'DE'   | jne L8>>
        cmp B$esi-1 Openbracket | jne L8>>

        add esi 10
L3:     inc esi | cmp B$esi ' ' | jbe L3<

        mov edx bininc.filename
L3:         mov al B$esi | mov B$edx al
            inc esi | inc edx
        cmp B$esi ' ' | ja L3<
        mov B$edx 0

        If B$esi <> ColonSign
            error bininc.errorSyntax
        Else_If B$esi+1 <> CloseBracket
            error bininc.errorSyntax
        End_If

        pushad
            call 'KERNEL32.CreateFileA' bininc.filename,
                                        &GENERIC_READ,
                                        &FILE_SHARE_READ__&FILE_SHARE_WRITE,
                                        &NULL,
                                        &OPEN_EXISTING,
                                        &FILE_ATTRIBUTE_NORMAL,
                                        &NULL
                mov D$bininc.filehandle eax

            On eax = &INVALID_HANDLE_VALUE, error bininc.errornotfound

            call 'KERNEL32.GetFileSize' eax, 0 | add D$InIncludeSize eax

            call 'KERNEL32.CloseHandle' D$bininc.filehandle
        popad

L8:     inc esi
    .End_While

  ; Fo 1 Byte from File we will have, at most 0FF + Space > 4 Bytes added in Source:
    shl D$InIncludeSize 2

    .If D$InIncludeSize > 500_000
        mov eax D$SourceLen | add eax 1_000_000 | add eax D$InIncludeSize
        push eax
            VirtualAlloc CopyOfCodeSourceA eax | add D$CopyOfCodeSourceA 010
        pop eax
        VirtualAlloc CopyOfCodeSourceB eax | add D$CopyOfCodeSourceB 010

        mov ecx D$SourceLen | Align_On 4 ecx | shr ecx 2
        push ecx
            mov esi D$CodeSourceA, edi D$CopyOfCodeSourceA | rep movsd
        pop ecx
        mov esi D$CodeSourceB, edi D$CopyOfCodeSourceB | rep movsd

        Exchange D$CodeSourceA D$CopyOfCodeSourceA, D$CodeSourceB D$CopyOfCodeSourceB

        VirtualFree D$CopyOfCodeSourceA, D$CopyOfCodeSourceB
    .End_If
ret








TITLE NewParser

____________________________________________________________________________________________
____________________________________________________________________________________________
;;

 If you want to write a new RosAsm Pre-Parser, this is the room where to start:

 Author name: ...

 eMail: ...

 Home Page, if any: ...
____________________________________________________________________________________________

 Description (Purpose / Syntaxe(s) / ...).
 
    This has to be a text, ready to be included inside the B_U_Asm File, and you should
    first write this before writing any Instruction. If you are not able to provide the
    user Manual, at least partially and temporary, *before* writing the Implementation,
    you have a real problem...
    
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 This is the room where volunteers will start the developement of a new PREPARSE Parser.
 Everything is ready to run. If you write a Source with:
 
 > PREPARSE New
 
 at the Top of Source, 'NewParser', down there, will be run.
 
 'New' is the temporary name of your new Pre-Parser (i will update it when ready for
 release).
 
 The job of a Pre-Parser is nothing but the front-end job of any Compiler, wich is
 nothing but replacing a Statement by another one, or by a flow of other ones, and
 ready to be assembled the regular way. So, this all should remain a "simple" (...)
 substitutions work.
 
 ____________________________________________________________________________________________

 Here is now what you have to know, in order to implement a New Pre-Parser:
 
 At this level of the Compile Process, the user Source, that you read from 'CodeSourceA'
 and have to rewrite into 'CodeSourceB', is no longer simple Ascii, but, instead a
 'coocked Ascii' Source.
 
 Before coming here, the Compile Process has already run the 'SourceCleaner', which does
 a lot of clean-up and replacements works. Generaly speacking, all of the particular
 Chars that we have to take care of -when parsing a Source-, have been replaced by lower
 Ascii Chars. To see this list of 'particular' Char, Right-Click upon 'MyAsciiTable' 
 and/or the upper 'LowSigns' Table.
 
 The Source you will have to work with has the following characteristics:
 
 * All is upper case
 * ' ' is turned 'Space'
 * '|' and CR/LF are turned 'EOI'
 * ',' are stripped of, as well as the next CR/LF if any,... and so on.
 
 Try to memorise all of these substitutions, first, as, for example, you will search
 in vain for any ':' inside the Source (as it now is 'ColonSign' -Ascii 14-...).

____________________________________________________________________________________________

 One important thing to know and respect:
 
 In order to keep track of the real user Source Instructions, all along the Compilation
 processes (up to the Debugger run time stage -!!!...-), when adding new instructions 
 with your new Parser, you have to add a new Separator. The normal separator, inside the 
 'coocked' Source is 'EOI' (Ascii 2), which replaces '|' and CR/LF). When you have
 to introduce a new added intruction (an Instruction that is *not* inside the real user
 Source), you have to add a new separator. This new separator is *not* 'EOI' (Ascii 2), 
 but 'meEOI' (Ascii 1). If this rule is broken, the error manager will point to the wrong
 statement, in the user Source, in error case, in all downward computations (!!!...).
 
____________________________________________________________________________________________
 
 If you need to insert some Labels of yours when Parsing, you may :
 
 > call CreateNoMeanLabel
 > call WriteNoMeanLabel
 
 Then, at 'NoMeanLabel', you have a String that you may copy in your output. In case
 of problem, first see how they are used in 'ParaMacrosParser', for example...
 
 The Data Declarations Separators, in that case, are neither 'OpenBracket', 'Closebracket',
 'OpenVirtual', 'CloseVirtual', but simply: '{' and '}'. These Chars are translated into
 the required LowSigns by the donward Computations of the Macros Parser.
 
 Not respecting this point, and the EOI vs meEOI thingies, will foolish the Error
 Manager. To verify that your work respect these constraints, when you have finished
 a working Pre-Parser, just test some Statement(s) making use of it, and, on the next 
 Instruction, produce some on-purpose error. If the error Manager wrongly points to
 a downward Statement, this is because you did an error when insterting a Separator.
 
____________________________________________________________________________________________

  If your Pre-Parser is simple enough, you do not need any Error Management. If something
  is wrong is encounted along your own computation, just abort, and let it go. Downward
  Computations will point out the error and will save you of this complication. If your
  Parser is complex enough and absolutely requires an Errors management, ask me, and i
  will write your Errors Management. (I don't release this, here, by default, in order to
  incitate you to do without, as long as possible).
 
____________________________________________________________________________________________

 Good work. Betov.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________


; Your new Pre-Parser Squeleton:

NewParser: RET  ; <<<<<<<<<<<<<<<<<!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    mov esi D$CodeSourceA, edi D$CodeSourceB | mov ecx esi | add ecx D$StripLen

    .While esi < ecx
        ;
        ; Your job...
        ;

        movsb

    .End_While

    sub edi D$CodeSourceB | mov D$StripLen edi
    Exchange D$CodeSourceA D$CodeSourceB
ret




























TITLE Encoder
 _______________________________________________________________________________________
;;
 After prefix(es), encoding opcode, modR/M byte.
 
 SIB, displacement and immediate temporary stored before in parameters analyzes
 will be written after returning from here.

 This might be the more surprising part of RosAsm: The Assembler is *not* Table(s)
 driven (zero Table). More Code / Less Data. But also, much much faster, because
 all this no end Cases selection works in fact a bit like a tree search. Some Cases
 have their specific treatements. The first Checking apply upon the number of Chars.
 After this, the chars Cases parsing works like a Tree.

 This organisation advantages, once the killing typing work is done, are: Speed,
 flexibility in holding any weird coding case, ease of maintainance, even with
 few knowledge.
;;
 _______________________________________________________________________________________


[Absolute | test #1 0_8000_0000 | jz M0> | neg #1 | M0:]


Encode:
    mov eax D$imm32, D$ABSimm32 eax ;| Absolute eax | mov D$ABSimm32 eax
; sIm
    and eax 0_FFFF_FF80
    If eax = 0_FFFF_FF80
        and D$ABSimm32 0_FF | mov B$SignedImm8 &TRUE
    Else_If D$imm32 < 080
        mov B$SignedImm8 &TRUE
    Else
        mov B$SignedImm8 &FALSE
    End_If

    mov esi D$LineStart,  edi D$CodeListPtr

    call Store8cars

    ; First, check for special encodings (send down here)

    On ah = 'J',  jmp Letter_J

    On B$esi+3 = '_', jmp J_Branching

    ifnot op1 'M',  L1>
      ifnot op2 'O', L1>
        ifnot op3 'V', L1>
          jmp MOVinstructions

L1: ifnot op1 'S', L1>
      ifnot op2 'E', L1>
        ifnot op3 'T',  L1>
          jmp SETinstructions

L1: ifnot op1 'C', L1>>
      ifnot op2 'M', L1>>
        ifnot op3 'O', L3>
          ifnot op4 'V', L1>
            jmp CMOVinstructions

L3:     cmp op6 Separators | jb L1>   ; CMPXCHG / CMPXCHG8B

        On op4 = 'X', jmp L1>

        Ifnot op3 'P', L1>
          ifnot op4 'P', L4>
            ifnot op5 'S', L5>        ; CMPPS... with given Condition (ex: CMP_SS_LT)
              jmp XMMcomparePS
L5:         ifnot op5 'D', L1>        ; CMPPD...
              jmp XMMcomparePD
L4:       ifnot op4 'S', L4>
            ifnot op5 'S', L5>        ; CMPSS...
              jmp XMMcompareSS
L5:         ifnot op5 'D', L1>        ; CMPSD...
              jmp XMMcompareSD        ; CMPSD with trailing imm is hold by (REP) CMPSD

L4:       ifnot op4 'E', L4>
            jmp TrySSE2
L4:       ifnot op4 'L', L4>
            jmp TrySSE2
L4:       ifnot op4 'N', L4>
            jmp TrySSE2
L4:       ifnot op4 'O', L4>
            jmp TrySSE2
L4:       ifnot op4 'U', L1>
            jmp TrySSE2


L1: ifnot op1 'F', L1>
      jmp Math

L1:    On op3 > Separators,  jmp TreeLetters

L1: ; Two Letters mnemonics:

      ifnot op1 'B', L1>
        ifnot op2 'T', L2>                       ; BT
          mov op1 001111
          ifnot B$Operands ImmToReg, L3>
            mov op2 00_1011_1010,  op3 00_1110_0000 | jmp op_op_reg1_imm8
L3:       ifnot B$Operands ImmToMem, L3>
            mov op2 00_1011_1010,  op3 00_0010_0000 | jmp op_op_modRm_imm8
L3:       ifnot B$Operands RegToReg, L3>
            mov op2 00_1010_0011,  op3 00_1100_0000 | jmp op_op_reg2reg1
L3:       ifnot B$Operands RegToMem, L3>
            mov op2 00_1010_0011 | jmp op_op_modReg2Rm
L3:       BadOperand
L2:     BadMnemonic
L1:   ifnot op1 'I', L1>
        ifnot op2 'N', L2>                        ; IN
          ifnot B$FirstGender reg, L4>
            ifnot B$FirstReg 0, L4>           ; reg = 0  for eax, ax, al
          ifnot B$SecondGender imm, L3>
            mov op1 00_1110_0100 | jmp w_imm8
L3:       ifnot B$SecondGender reg, L4>
            ifnot B$SecondReg RegDX, L4>
              ifnot B$SecondOperandwBit WordSize, L4>
                If B$FirstOperandwBit = ByteSize
                    LastOpCode 0EC
                Else                 ; Direct output because of "in al/eax DX".
                    LastOpcode 0ED
                End_If
L4:       BadOperand
L2:     BadMnemonic
L1:   ifnot op1 'O', L1>>
        ifnot op2 'R', L2>>                                 ; OR
          ifnot B$Operands RegToReg, L3>
            mov op1 00_1010,  op2 00_1100_0000 | jmp w_reg1reg2
L3:       ifnot B$Operands MemToReg, L3>
            mov op1 00_1010 | jmp w_modReg1Rm
L3:       ifnot B$Operands RegToMem, L3>
            mov op1 00_1000 | jmp w_modReg2Rm
L3:       ifnot B$Operands ImmToReg, L3>
            ifnot B$FirstReg RegEAX, L4>
              If B$FirstOperandwBit > ByteSize
                cmp B$LabelInside &TRUE | je L5>
                cmp B$SignedImm8 &TRUE | je L4>
                ;cmp D$ABSimm32 080 | jb L4>
              End_If
L5:           mov op1 00_1100 | jmp w_imm
L4:         mov op1 00_1000_0000,  op2 00_1100_1000 | jmp sw_reg1_imm
L3:       ifnot B$Operands ImmToMem, L3>
            mov op1 00_1000_0000,  op2 00_1000 | jmp sw_modRm_imm
L3:       BadOperand
L2:     ;BadMnemonic
L1:   BadMnemonic

TreeLetters:  On op4 > Separators,  jmp FourLetters

        ifnot op1 'A', L1>>
          ifnot op2 'A', L2>>
            ifnot op3 'A', L3>
              mov op1 0011_0111 | jmp OP                             ; AAA
L3:         ifnot op3 'D', L3>
                mov op1 00_1101_0101
                If B$ParametersNumber = 1
                    jmp Op_imm8
                Else
                    mov op2 00_1010 | jmp OP_OP    ; AAD
                End_If
L3:         ifnot op3 'M', L3>
                mov op1 00_1101_0100
                If B$ParametersNumber = 1
                    jmp Op_imm8
                Else
                    mov op2 00_1010 | jmp OP_OP    ; AAM
                End_If
L3:         ifnot op3 'S', L3>
               mov op1 0011_1111 | jmp OP                            ; AAS
L3:         BadMnemonic
L2:       ifnot op2 'D', L2>>
            ifnot op3 'C', L3>>  ; >                                  ; ADC
              ifnot B$Operands RegToReg, L4>
                mov op1 0001_0010,  op2 00_1100_0000 | jmp w_reg1reg2
L4:           ifnot B$Operands MemToReg, L4>
                mov op1 0001_0010 | jmp w_modReg1Rm
L4:           ifnot B$Operands RegToMem, L4>
                mov op1 0001_0000 | jmp w_modReg2Rm
L4:           ifnot B$Operands ImmToReg, L4>
                ifnot B$FirstReg RegEAX, L5>
                  If B$FirstOperandwBit > ByteSize
                    cmp B$LabelInside &TRUE | je L6>
                    cmp B$SignedImm8 &TRUE | je L5>
                    ;cmp D$ABSimm32 080 | jb L5>
                  End_If
L6:               mov op1 0001_0100 | jmp w_imm
L5:             mov op1 00_1000_0000,  op2 00_1101_0000 | jmp sw_reg1_imm
L4:           ifnot B$Operands ImmToMem, L4>
                mov op1 00_1000_0000,  op2 0001_0000 | jmp sw_modRm_imm
L4:           BadOperand

L3:         ifnot op3 'D', L3>>                               ; ADD  ; sub
              ifnot B$Operands RegToReg, L4>
                mov op1 0010,  op2 00_1100_0000 | jmp w_reg1reg2
L4:           ifnot B$Operands MemToReg, L4>
                mov op1 0010 | jmp w_modReg1Rm
L4:           ifnot B$Operands RegToMem, L4>
                mov op1 0 | jmp w_modReg2Rm
L4:           ifnot B$Operands ImmToReg, L4>
                ifnot B$FirstReg RegEAX, L5>
                  If B$FirstOperandwBit > ByteSize
                    cmp B$LabelInside &TRUE | je L6>
                    cmp B$SignedImm8 &TRUE | je L5>
                    ;cmp D$ABSimm32 080 | jb L5>
                  End_If
L6:               mov op1 00_0100 | jmp w_imm

L5:             mov op1 00_1000_0000,  op2 00_1100_0000 | jmp sw_reg1_imm

L4:           ifnot B$Operands ImmToMem, L4>
                mov op1 00_1000_0000,  op2 0 | jmp sw_modRm_imm
L4:           BadOperand
L3:         BadMnemonic
L2:       ifnot op2 'N', L2>>
            ifnot op3 'D', L3>>                        ; AND
              ifnot B$Operands RegToReg, L4>
                mov op1 0010_0010,  op2 00_1100_0000 | jmp w_reg1reg2
L4:           ifnot B$Operands MemToReg, L4>
                mov op1 0010_0010 | jmp w_modReg1Rm
L4:           ifnot B$Operands RegToMem, L4>
                mov op1 0010_0000 | jmp w_modReg2Rm
L4:           ifnot B$Operands ImmToReg, L4>
                ifnot B$FirstReg RegEAX, L5>
                  If B$FirstOperandwBit > ByteSize
                    cmp B$LabelInside &TRUE | je L6>
                    cmp B$SignedImm8 &TRUE | je L5>
                    ;cmp D$ABSimm32 080 | jb L5>
                  End_If
L6:               mov op1 0010_0100 | jmp w_imm
                ; immToreg missing in intel doc > verify:
L5:             mov op1 00_1000_0000,  op2 00_1110_0000 | jmp sw_Reg1_imm
L4:           ifnot B$Operands ImmToMem, L4>
                mov op1 00_1000_0000,  op2 0010_0000 | jmp sw_modRm_imm
L4:           BadOperand
L3:         BadMnemonic
L2:       BadMnemonic

L1:     ifnot op1 'B', L1>>
          ifnot op2 'S', L2>>
            ifnot op3 'F', L3>                         ; BSF
              ifnot B$Operands RegToReg, L4>
                mov op1 00_1111,  op2 00_1011_1100,  op3 00_1100_0000
                jmp op_op_reg1reg2                         ; intel doc: reverse order (???)
L4:           ifnot B$Operands MemToReg, L4>
                mov op1 00_1111,  op2 00_1011_1100 | jmp op_op_modreg1Rm
L4:           BadOperand
L3:         ifnot op3 'R', L3>                                     ; BSR
              ifnot B$Operands RegToreg, L4>
                mov op1 00_1111,  op2 00_1011_1101,  op3 00_1100_0000
                jmp op_op_reg1reg2                         ; intel doc: reverse order (???)
L4:           ifnot B$Operands MemToreg, L4>
                mov op1 00_1111,  op2 00_1011_1101 | jmp op_op_modReg1Rm
L4:           BadOperand
L3:         BadMnemonic
L2:       ifnot op2 'T', L2>>
            ifnot op3 'C', L3>                          ; BTC
              mov op1 00_1111,  op2 00_1011_1010
              ifnot B$Operands ImmToReg, L4>
                mov op3 00_1111_1000 | jmp op_op_reg1_imm8
L4:           ifnot B$Operands ImmToMem, L4>
                mov op3 0011_1000 | jmp op_op_modRm_imm8
L4:           mov op2 00_1011_1011
              ifnot B$Operands RegToreg, L4>
                mov op3 00_1100_0000 | jmp op_op_reg2reg1
L4:           ifnot B$Operands RegToMem, L4>
                jmp op_op_modReg2Rm
L4:           BadOperand
L3:         ifnot op3 'R', L3>                          ; BTR
              mov op1 00_1111
              ifnot B$Operands ImmToreg, L4>
                mov op2 00_1011_1010,  op3 00_1111_0000 | jmp op_op_reg1_imm8
L4:           ifnot B$Operands ImmToMem, L4>
                mov op2 00_1011_1010,  op3 0011_0000 | jmp op_op_modRm_imm8
L4:           ifnot B$Operands RegToreg, L4>
                mov op2 00_1011_0011,  op3 00_1100_0000 | jmp op_op_reg2reg1
L4:           ifnot B$Operands RegToMem, L4>
                mov op2 00_1011_0011 | jmp op_op_modReg2Rm
L4:           BadOperand
L3:         ifnot op3 'S', L3>                          ; BTS
              mov op1 00_1111
              ifnot B$Operands ImmToreg, L4>
                mov op2 00_1011_1010,  op3 00_1110_1000 | jmp op_op_reg1_imm8
L4:           ifnot B$Operands ImmToMem, L4>
                mov op2 00_1011_1010,  op3 0010_1000 | jmp op_op_modRm_imm8
L4:           ifnot B$Operands RegToreg, L4>
                mov op2 00_1010_1011,  op3 00_1100_0000 | jmp op_op_reg2reg1
L4:           ifnot B$Operands RegToMem, L4>
                mov op2 00_1010_1011 | jmp op_op_modReg2Rm
L4:           BadOperand
L3:         ;BadMnemonic
L2:       BadMnemonic

L1:     ifnot op1 'C', L1>>
          ifnot op2 'B', L2>
            ifnot op3 'W', L3>                 ; CBW
              mov op1 066,  op2 00_1001_1000 | jmp op_op
L3:         BadMnemonic
L2:       ifnot op2 'D', L2>
            ifnot op3 'Q', L3>                 ; CDQ
              mov op1 00_1001_1001 | jmp op
L3:         BadMnemonic
L2:       ifnot op2 'L', L2>
            ifnot op3 'C', L3>                 ; CLC
              mov op1 00_1111_1000 | jmp op
L3:         ifnot op3 'D',  L3>                 ; CLD
              mov op1 00_1111_1100 | jmp op
L3:         ifnot op3 'I', L3>                 ; CLI
              mov op1 00_1111_1010 | jmp op
L3:         BadMnemonic
L2:       ifnot op2 'M', L2>>
            ifnot op3 'C', L3>                 ; CMC
              mov op1 00_1111_0101 | jmp op
L3:         ifnot op3 'P',  L3>>                 ; CMP
              ifnot B$Operands RegToReg, L4>
                mov op1 0011_1010,  op2 00_1100_0000 | jmp w_reg1reg2
L4:           ifnot B$Operands MemToReg, L4>
                mov op1 0011_1010 | jmp w_modReg1Rm
L4:           ifnot B$Operands RegToMem, L4>
                mov op1 0011_1000 | jmp w_modReg2Rm
L4:           ifnot B$Operands ImmToReg, L4>

                ifnot B$FirstReg RegEAX, L5>
                  If B$FirstOperandwBit = ByteSize
                     mov op1 03C
                  Else
                      cmp B$LabelInside &TRUE | je L6>
                      cmp B$SignedImm8 &TRUE | je L5>
                      ;cmp D$ABSimm32 080 | jb L5>
L6:                   mov op1 03D
                  End_If
                  jmp w_imm

L5:             mov op1 00_1000_0000,  op2 00_1111_1000 | jmp sw_reg1_imm
L4:           ifnot B$Operands ImmToMem, L4>
                mov op1 00_1000_0000,  op2 0011_1000 | jmp sw_modRm_imm
L4:           BadOperand
L3:         BadMnemonic
L2:       ifnot op2 'W', L2>
            ifnot op3 'D', L3>                ; CWD
              mov op1 066,  op2 00_1001_1001 | jmp op_op
L3:         ;BadMnemonic
L2:       BadMnemonic
L1:     ifnot op1 'D', L1>>
          ifnot op2 'A', L2>
            ifnot op3 'A', L3>               ; DAA
              mov op1 0010_0111 | jmp op
L3:         ifnot op3 'S', L3>
              mov op1 0010_1111 | jmp op
L3:         BadMnemonic
L2:     ifnot op2 'E', L2>
          ifnot op3 'C', L3>                  ; DEC
            ifnot B$FirstGender reg, L4>
              cmp B$wBit ByteSize | jne L5>
              mov op1 00_1111_1110,  op2 00_1100_1000 | jmp w_reg1    ; alternate shorter >
L5:           mov op1 0_0100_1000 | jmp reg1_in_op                     ; only full size
L4:         ifnot B$FirstGender mem, L4>
              mov op1 00_1111_1110,  op2 00_1000 | jmp w_modRm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'I', L2>
          ifnot op3 'V', L3>                  ; DIV
            mov op1 00_1111_0110
            ifnot B$FirstGender reg, L4>
              mov op2 00_1111_0000 | jmp w_reg1
L4:         ifnot B$FirstGender mem, L4>
              mov op2 0011_0000 | jmp w_modRm
L4:         BadOperand
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'H', L1>
        ifnot op2 'L', L2>
          ifnot op3 'T', L3>                  ; HLT
            mov op1 00_1111_0100 | jmp op
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'I', L1>
        ifnot op2 'N', L2>
          ifnot op3 'C', L3>                 ; INC
            ifnot B$FirstGender Reg, L4>
              cmp B$wBit ByteSize | jne L5>
              mov op1 00_1111_1110 | mov op2 00_1100_0000 | jmp w_reg1 ; alternate shorter >
L5:           mov op1 0_0100_0000 | jmp reg1_in_op                      ; only full size
L4:         ifnot B$FirstGender mem, L4>
              mov op1 00_1111_1110 | mov op2 0 | jmp w_modRm
L4:         BadOperand
;L3:       ifnot op3 'S', L3>                  ; INS
;            mov op1 00_0110_1100 | jmp OPw
L3:       ifnot op3 'T', L3>                  ; INT
            ifnot D$imm32 3, L4>
              mov B$immInside &False
              mov op1 00_1100_1100 | jmp op_P1          ; INT 3
L4:         mov op1 00_1100_1101 | jmp op_imm8     ; INT n
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'L', L1>>
        ifnot op2 'A', L2>
          ifnot op3 'R', L3>                  ; LAR
            mov op1 00_1111,  op2 0010
            ifnot B$Operands RegToReg, L4>
              mov op3 00_1100_0000 | jmp op_op_reg1reg2
L4:         ifnot B$Operands MemToreg, L4>
              jmp op_op_modReg1Rm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'D', L2>
          ifnot op3 'S', L3>                     ; LDS
            ifnot B$Operands MemToReg, L4>
              mov op1 00_1100_0101 | jmp op_modReg1Rm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'E', L2>
          ifnot op3 'A', L3>                       ; LEA
            ifnot B$Operands MemToReg, L4>
            On B$FirstOperandwBit = ByteSize, error D$LeaSizePtr
              mov op1 00_1000_1101 | jmp op_modReg1Rm
L4:         Error D$LeaTypesPtr
L3:       ifnot op3 'S', L3>                       ; LES
            ifnot B$Operands MemToReg, L4>
              mov op1 00_1100_0100 | jmp op_modReg1Rm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'F', L2>
          ifnot op3 'S', L3>                       ; LFS
            ifnot B$Operands MemToReg, L4>
              mov op1 00_1111
               mov op2 00_1011_0100 | jmp op_op_modReg1Rm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'G', L2>
          ifnot op3 'S', L3>                       ; LGS
            ifnot B$Operands MemToReg, L4>
              mov op1 00_1111
               mov op2 00_1011_0101 | jmp op_op_modReg1Rm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'S', L2>
          ifnot op3 'L', L3>
            mov op1 00_1111,  op2 0011
            ifnot B$Operands RegToReg, L4>             ; LSL
              mov op3 00_1100_0000 | jmp op_op_reg1reg2
L4:         ifnot B$Operands MemToReg, L4>
              jmp op_op_modreg1Rm
L4:         BadOperand
L3:       ifnot op3 'S', L3>                          ; LSS
            ifnot B$Operands MemToReg, L4>
            mov op1 00_1111, op2 00_1011_0010 | jmp op_op_modReg1Rm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'T', L2>
          ifnot op3 'R', L3>                        ; LTR
            mov op1 00_1111,  op2 0
            ifnot B$FirstGender reg, L4>
              mov op3 00_1101_1000 | jmp op_op_reg16
L4:         ifnot B$FirstGender mem, L4>
              mov op3 0001_1000 | jmp op_op_modRm16
L4:         BadOperand
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'M', L1>
        ifnot op2 'U', L2>
          ifnot op3 'L', L3>                     ; MUL
            mov op1 00_1111_0110
            ifnot B$FirstGender reg, L4>
              mov op2 00_1110_0000 | jmp w_reg1
L4:         ifnot B$FirstGender mem, L4>
              mov op2 0010_0000 | jmp w_modRm
L4:         BadOperand
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'N', L1>>
        ifnot op2 'E', L2>
          ifnot op3 'G', L3>                   ; NEG
            mov op1 00_1111_0110
            ifnot B$FirstGender reg, L4>
              mov op2 00_1101_1000 | jmp w_reg1
L4:         ifnot B$FirstGender mem, L4>
              mov op2 0001_1000 | jmp w_modRm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'O', L2>
          ifnot op3 'P', L3>                   ; NOP
            mov op1 00_1001_0000 | jmp op
L3:       ifnot op3 'T', L3>                   ; NOT
            mov op1 00_1111_0110
            ifnot B$FirstGender reg, L4>
              mov op2 00_1101_0000 | jmp w_reg1
L4:         ifnot B$FirstGender mem, L4>
              mov op2 0001_0000 | jmp w_modRm
L4:         BadOperand
L3:       ;BadMnemonic
L2:     BadMnemonic

L1:   ifnot op1 'O', L1>
        ifnot op2 'U', L2>
          ifnot op3 'T', L3>                   ; OUT
            ifnot B$Operands RegToImm, L4>
              mov op1 0E6
              If B$SecondOperandwBit > ByteSize
                inc op1
                On B$SecondOperandwBit = WordSize, ToOpcode 066
              End_If
              jmp w_imm8
L4:         ifnot B$Operands RegToReg, L4>
              Ifnot B$secondReg RegEax, L5>
              Ifnot B$FirstReg RegDx, L5>
              mov op1 0EE
              If B$SecondOperandwBit > ByteSize
                inc op1
                On B$SecondOperandwBit = WordSize, ToOpcode 066
              End_If
              jmp w_P2
L5:
L4:         BadOperand
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'P', L1>>
        ifnot op2 'O', L2>
          ifnot op3 'P', L3>                     ; POP
            ifnot B$FirstGender reg, L4>
              On B$wBit = ByteSize, BadOperand
              ifnot B$FirstRegGender sReg, L5>             ; max. G.P.regs = 00111
                cmp B$FirstReg 0010_0000 | jae L6>         ; regFS is 00100000; GS, 00101000
                  mov op1 00_0111 | jmp sReg2                         ; CS / DS / ES / SS
L6:             mov op1 00_1111, op2 00_1000_0001 | jmp op_sreg3      ; FS / GS
L5:          ; mov op1 00_1000_1111,  op2 00_1100_0000 | jmp op_reg1   ; G.P.
              mov op1 0_0101_1000 | jmp reg1_in_op                      ; register alternate
L4:         ifnot B$FirstGender mem, L4>
              On B$wBit = ByteSize, BadOperand
              mov op1 00_1000_1111,  op2 0 | jmp op_modRm
L4:         BadOperand
L3:       ifnot op3 'R', L3>                       ; POR - Bitwise Or N N N Y
              mov op1 00_1110_1011 | jmp OQRegMemToReg
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'R', L1>>
        ifnot op2 'C', L2>>
          ifnot op3 'L', L3>>                      ; RCL
              ifnot B$Operands RegToReg, L4>
                ifnot B$SecondReg RegCL, L5>
                  mov op1 00_1101_0010,  op2 00_1101_0000 | jmp w_reg1_P2cl
L4:           ifnot B$Operands RegToMem, L4>
                ifnot B$SecondReg RegCL, L5>
                  mov op1 00_1101_0010,  op2 0001_0000 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender imm, L4>
              ifnot D$imm32 1, L5>
                ifnot B$Operands ImmToReg, L6>
                  mov op1 00_1101_0000, op2 00_1101_0000 | jmp w_reg1_P2
L6:             ifnot B$Operands ImmToMem, L6>
                  mov op1 00_1101_0000, op2 0001_0000 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands ImmToReg, L5>
                mov op1 00_1100_0000, op2 00_1101_0000 | jmp w_reg1_imm8
L5:           ifnot B$Operands ImmToMem, L5>
                mov op1 00_1100_0000,  op2 0001_0000 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand

L3:       ifnot op3 'R', L3>>                            ; RCR
              ifnot B$Operands RegToReg, L4>
                ifnot B$SecondReg RegCL, L5>
                  mov op1 00_1101_0010,  op2 00_1101_1000 | jmp w_reg1_P2cl
L4:           ifnot B$Operands RegToMem, L4>
                ifnot B$SecondReg RegCL, L5>
                  mov op1 00_1101_0010,  op2 0001_1000 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender imm, L4>
              ifnot D$imm32 1, L5>
                ifnot B$Operands ImmToReg, L6>
                  mov op1 00_1101_0000,  op2 00_1101_1000 | jmp w_reg1_P2
L6:             ifnot B$Operands ImmToMem, L6>
                  mov op1 00_1101_0000,  op2 0001_1000 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands ImmToReg, L5>
                mov op1 00_1100_0000,  op2 00_1101_1000 | jmp w_reg1_imm8
L5:           ifnot B$Operands ImmToMem, L5>
                mov op1 00_1100_0000,  op2 0001_1000 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'E', L2>
          ifnot op3 'T', L3>                    ; RET same segment only
            ifnot B$ParametersNumber 0, L5>
L6:           mov op1 00_1100_0011 | jmp op
L5:         ifnot B$FirstGender imm, L4>
              If D$imm32 = 0
                  mov B$DisInside &False
                  mov B$ParametersNumber 0
                  mov B$immInside &FALSE | jmp L6<
              End_If
              mov op1 00_1100_0010 | jmp op_imm16
L4:         BadOperand
L3:       BadMnemonic

L2:     ifnot op2 'O', L2>>
          ifnot op3 'L', L3>>                    ; ROL
              ifnot B$Operands RegToReg, L4>
                ifnot B$SecondReg RegCL, L5>
                  mov op1 00_1101_0010,  op2 00_1100_0000 | jmp w_reg1_P2cl
L4:           ifnot B$Operands RegToMem, L4>
                ifnot B$SecondReg RegCL, L5>
                  mov op1 00_1101_0010,  op2 0 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender imm, L4>
              ifnot B$imm32 1,  L5>
                ifnot B$Operands ImmToReg, L6>
                  mov op1 00_1101_0000,  op2 00_1100_0000 | jmp w_reg1_P2
L6:             ifnot B$Operands ImmToMem, L6>
                  mov op1 00_1101_0000,  op2 0 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands ImmToReg, L5>
                mov op1 00_1100_0000,  op2 00_1100_0000 | jmp w_reg1_imm8
L5:           ifnot B$Operands ImmToMem, L5>
                mov op1 00_1100_0000,  op2 0 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand


L3:       ifnot op3 'R', L3>>                   ; ROR
              ifnot B$Operands RegToReg, L4>
                ifnot B$SecondReg RegCL, L5>
                  mov op1 00_1101_0010,  op2 00_1100_1000 | jmp w_reg1_P2cl
L4:           ifnot B$Operands RegToMem, L4>
                ifnot B$SecondReg RegCL, L5>
                  mov op1 00_1101_0010,  op2 00_1000 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender imm, L4>
              ifnot D$imm32 1, L5>
                ifnot B$Operands ImmToReg, L6>
                  mov op1 00_1101_0000,  op2 00_1100_1000 | jmp w_reg1_P2
L6:             ifnot B$Operands ImmToMem, L6>
                  mov op1 00_1101_0000,  op2 00_1000 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands ImmToReg, L5>
                mov op1 00_1100_0000, op2 00_1100_1000 | jmp w_reg1_imm8
L5:           ifnot B$Operands ImmToMem, L5>
                mov op1 00_1100_0000,  op2 00_1000 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'S', L2>
          ifnot op3 'M', L3>                         ; RSM
            mov op1 00_1111,  op2 00_1010_1010 | jmp op_op
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'S', L1>>
        ifnot op2 'A', L2>>
          ifnot op3 'L', L3>
            mov op2 'H'
               jmp SHL2              ; SAL same instruction as SHL
L3:       ifnot op3 'R', L3>>                ; SAR
              ifnot B$Operands RegToReg L4>
                ifnot B$SecondReg RegCL, L5>
                  mov op1 00_1101_0010,  op2 00_1111_1000 | jmp w_reg1_P2cl
L4:           ifnot B$Operands RegToMem, L4>
                ifnot B$SecondReg RegCL, L5>
                  mov op1 00_1101_0010, op2 0011_1000 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender imm, L4>
              ifnot D$imm32 1, L5>
                ifnot B$Operands ImmToReg, L6>
                  mov op1 00_1101_0000,  op2 00_1111_1000 | jmp w_reg1_P2
L6:             ifnot B$Operands ImmToMem, L6>
                  mov op1 00_1101_0000,  op2 0011_1000 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands ImmToReg, L5>
                mov op1 00_1100_0000,  op2 00_1111_1000 | jmp w_reg1_imm8
L5:           ifnot B$Operands ImmToMem, L5>
                mov op1 00_1100_0000,  op2 0011_1000 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'B', L2>>
          ifnot op3 'B', L3>>             ; SBB
            ifnot B$Operands RegToReg, L4>
              mov op1 0001_1010,  op2 00_1100_0000 | jmp w_Reg1Reg2
L4:         ifnot B$Operands MemToReg, L4>
              mov op1 0001_1010 | jmp w_modReg1Rm
L4:         ifnot B$Operands RegToMem, L4>
              mov op1 0001_1000 | jmp w_modReg2Rm
L4:         ifnot B$Operands ImmToReg, L4>
              ifnot B$FirstReg RegEAX, L5>
                If B$FirstOperandwBit > ByteSize
                    cmp D$ABSimm32 080 | jb L5>
                End_If
                mov op1 0001_1100 | jmp w_imm
L5:           mov op1 00_1000_0000,  op2 00_1101_1000 | jmp sw_reg1_imm
L4:         ifnot B$Operands ImmToMem, L4>
              mov op1 00_1000_0000,  op2 0001_1000 | jmp sw_modRm_imm
L4:         BadOperand
L3:       BadMnemonic

L2:     ifnot op2 'H', L2>>
          ifnot op3 'L', L3>>                             ; SHL/SAL
SHL2:         ifnot B$Operands RegToReg, L4>
                ifnot B$SecondReg RegCL, L5>
                  mov op1 00_1101_0010,  op2 00_1110_0000 | jmp w_reg1_P2cl
L4:           ifnot B$Operands RegToMem, L4>
                ifnot B$SecondReg RegCL, L5>
                  mov op1 00_1101_0010,  op2 0010_0000 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender imm, L4>
              ifnot D$imm32 1, L5>
                ifnot B$Operands ImmToReg, L6>
                  mov op1 00_1101_0000,  op2 00_1110_0000 | jmp w_reg1_P2
L6:             ifnot B$Operands ImmToMem, L6>
                  mov op1 00_1101_0000,  op2 0010_0000 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands ImmToReg, L5>
                mov op1 00_1100_0000,  op2 00_1110_0000 | jmp w_reg1_imm8
L5:           ifnot B$Operands ImmToMem, L5>
                mov op1 00_1100_0000,  op2 0010_0000 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand
L3:       ifnot op3 'R', L3>>                                 ; SHR
            ifnot B$Operands RegToReg, L4>
              ifnot B$SecondReg RegCL, L5>
                mov op1 00_1101_0010,  op2 00_1110_1000 | jmp w_reg1_P2cl
L4:         ifnot B$Operands RegToMem, L4>
              ifnot B$SecondReg RegCL, L5>
                mov op1 00_1101_0010,  op2 0010_1000 | jmp w_modRm_P2cl
L5:           BadOperand
L4:         ifnot B$SecondGender imm, L4>
              ifnot B$imm32 1, L5>
                ifnot B$Operands ImmToReg, L6>
                  mov op1 00_1101_0000,  op2 00_1110_1000 | jmp w_reg1_P2
L6:             ifnot B$Operands ImmToMem,  L6>
                  mov op1 00_1101_0000,  op2 0010_1000 | jmp w_modRm_P2
L6:             BadOperand
L5:           ifnot B$Operands ImmToReg, L5>
                mov op1 00_1100_0000,  op2 00_1110_1000 | jmp w_reg1_imm8
L5:           ifnot B$Operands ImmToMem, L5>
                mov op1 00_1100_0000,  op2 0010_1000 | jmp w_modRm_imm8
L5:           ;BadOperand
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'T', L2>
          ifnot op3 'C', L3>              ; STC
            mov op1 00_1111_1001 | jmp op
L3:       ifnot op3 'D', L3>              ; STD
            mov op1 00_1111_1101 | jmp op
L3:       ifnot op3 'I', L3>              ; STI
            mov op1 00_1111_1011 | jmp op
L3:       ifnot op3 'R', L3>              ; STR ("ax" or "W$edi")
              dec edi ; Because there is no need of 066 override here
              On B$FirstOperandwbit <> WordSize, BadOperandSize
              mov op1 0F, Op2 0
            ifnot B$FirstGender reg, L4>
              mov op3 00_1100_1000 | jmp op_op_reg1
L4:         ifnot B$FirstGender mem, L4>
              mov op3 00_1000 | jmp op_op_modRm
L4:         BadOperand
L3:       BadMnemonic
L2:     ifnot op2 'U', L2>>
          ifnot op3 'B', L3>>                         ; SUB
            ifnot B$Operands RegToReg, L4>
              mov op1 0010_1010,  op2 00_1100_0000 | jmp w_reg1reg2
L4:         ifnot B$Operands MemToReg, L4>
              mov op1 0010_1010 | jmp w_modReg1Rm
L4:         ifnot B$Operands RegToMem, L4>
              mov op1 0010_1000 | jmp w_modReg2Rm
L4:         ifnot B$Operands ImmToReg, L4>
              ifnot B$FirstReg RegEAX, L5>
                If B$FirstOperandwBit > ByteSize
                    cmp D$ABSimm32 080 | jb L5>
                End_If
                mov op1 0010_1100 | jmp w_imm
L5:           mov op1 00_1000_0000,  op2 00_1110_1000 | jmp sw_reg1_imm
L4:         ifnot B$Operands ImmtoMem, L4>
              mov op1 00_1000_0000,  op2 0010_1000 | jmp sw_modRm_imm
L4:         BadOperand
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'U', L1>
        ifnot op2 'D', L2>
          ifnot op3 '2', L3>           ; UD2 ;;; may add UD0 / UD1 (???....)
            mov op1 0F,  op2 0B | jmp op_op
               ;UD2 – Undefined instruction 0000 FFFF : 0000 1011
               ; used for sofware tests: generates opcode exception
L3:       ;BadMnemonic
L2:     BadMnemonic
L1:   ifnot op1 'X', L1>>
        ifnot op2 'O', L2>>
          ifnot op3 'R', L3>>             ; XOR
            ifnot B$Operands RegToreg, L4>
              mov op1 0011_0010,  op2 00_1100_0000 | jmp w_reg1reg2
L4:         ifnot B$Operands MemToReg, L4>
              mov op1 0011_0010 | jmp w_modReg1Rm
L4:         ifnot B$Operands RegToMem, L4>
              mov op1 0011_0000 | jmp w_modReg2Rm
L4:         ifnot B$Operands ImmToReg, L4>
              ifnot B$FirstReg RegEAX, L5>
                If B$FirstOperandwBit > ByteSize
                    cmp D$ABSimm32 080 | jb L5>
                End_If
                mov op1 0011_0100 | jmp w_imm
L5:           mov op1 00_1000_0000
                    mov op2 00_1111_0000 | jmp sw_reg1_imm
L4:         ifnot B$Operands ImmToMem, L4>
              mov op1 00_1000_0000,  op2 0011_0000 | jmp sw_modRm_imm
L4:         BadOperand
L3:       ;BadMnemonic
L2:     ;BadMnemonic
L1:   BadMnemonic

 ______________________________________________________________________________________

FourLetters:    On op5 > Separators,  jmp FiveLetters

        ifnot op1 'A', L1>
          ifnot op2 'R', L2>
            ifnot op3 'P', L3>
              ifnot op4 'L', L4>          ; ARPL  ; BadOperandSize
                On B$FirstOperandwbit <> WordSize, BadOperandSize
               ; dec edi ; Kill 066 or not ??? Should work the same in both cases...
                mov op1 00_0110_0011
                ifnot B$Operands RegToreg, L5>
                  mov op2 00_1100_0000 | jmp op_reg2reg1
L5:             ifnot B$Operands regToMem, L5>
                  jmp op_modReg2Rm
L5:             BadOperand
L4:           ;BadMnemonic
L3:         ;BadMnemonic
L2:       BadMnemonic

L1:     ifnot op1 'C', L1>>
          ifnot op2 'A', L2>
            ifnot op3 'L', L3>
              ifnot op4 'L', L4>           ; CALL
                ifnot B$FirstGender dis, L5>
                  On B$LocalSize <> 0, error D$NoLocalCallPtr
                  mov D$Relative RelativeFlag
                  mov op1 00_1110_1000
                  jmp op_dis
L5:             ifnot B$FirstGender Reg, L5>
                  mov op1 00_1111_1111,  op2 00_1101_0000 | jmp op_reg1
L5:             ifnot B$FirstGender mem, L5>
                  mov op1 00_1111_1111,  op2 0001_0000 | jmp op_modRm
                                         ; 015 > 10101
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic

     ;CALL   Call Procedure (in other segment)
     ;direct                1001 1010 : unsigned full offset, selector
     ;indirect              1111 1111 : mod 011 r/m


L2:       ifnot op2 'L', L2>
            ifnot op3 'T', L3>
              ifnot op4 'S', L4>                    ; CLTS
                mov op1 00_1111,  op2 00_0110 | jmp op_op
L4:           ;BadMnemonic
L3:         BadMnemonic

L2:       ifnot op2 'M', L2>
            ifnot op3 'P', L3>
              ifnot op4 'S', L4>                     ; CMPS
                ; CMPS – Compare String B[Operands]   1010 011w
                error D$NotYetMnemoPtr
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'W', L2>
            ifnot op3 'D', L3>
              ifnot op4 'E', L4>                     ; CWDE
                mov op1 00_1001_1000 | jmp op
L4:           ;BadMnemonic
L3:         ;BadMnemonic
L2:       BadMnemonic

L1:     ifnot op1 'E', L1>
          ifnot op2 'M', L2>
            ifnot op3 'M', L3>
              ifnot op4 'S', L4>                    ; EMMS
                cmp B$ParametersNumber 0 | jne L5>
                  mov op1 00_1111, op2 00_01110111 | jmp op_op
L5:             BadOperand
L4:           ;BadMnemonic
L3:         ;BadMnemonic
L2:       BadMnemonic

L1:     ifnot op1 'I', L1>>
          ifnot op2 'D', L2>
            ifnot op3 'I', L3>
              ifnot op4 'V', L4>               ; IDIV
                mov op1 00_1111_0110
                ifnot B$FirstGender reg, L5>
                  mov op2 00_1111_1000 | jmp w_reg1
L5:             ifnot B$FirstGender mem, L5>
                  mov op2 0011_1000 | jmp w_modRm
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic

L2:       ifnot op2 'M', L2>>
            ifnot op3 'U', L3>>
              ifnot op4 'L', L4>>                  ; IMUL
                cmp B$ParametersNumber 2 | je L6>
                cmp B$ParametersNumber 3 | je L7>

                  ifnot B$FirstGender reg, L5>
                    mov op1 00_1111_0110,  op2 00_0111_01000 | jmp w_reg1
L5:               ifnot B$FirstGender mem, L5>
                    mov op1 00_1111_0110,  op2 0010_1000 | jmp w_modRm
L5:               BadOperand

L6:             cmp B$wBit ByteSize | je L5>
                ifnot B$Operands RegToReg, L6>
                    mov op1 00_1111,  op2 00_1010_1111,  op3 00_1100_0000 | jmp op_op_reg1reg2
; 3 Parameters:
L7:             On B$ThirdGender <> imm, jmp L5>
                cmp B$wBit ByteSize | je L5>
                IfNot B$Operands RegToReg, L6> ; imul eax ebx 0-1
L8:               mov op1 00_0110_1001,  op2 00_1100_0000 | jmp s_reg1reg2_imm
L6:             ifnot B$Operands MemToReg, L6>

                  cmp B$immInside &TRUE | je L7>
                  mov op1 00_1111,  op2 00_1010_1111 | jmp op_op_modReg1Rm
                  ; 069 (ou 06B)
L7:               mov op1 00_0110_1001 | jmp s_modReg1Rm_imm
L6:             ifnot B$Operands ImmToReg, L6>
                  mov B$ParametersNumber 3
                  mov dh, B$FirstReg, B$SecondReg dh | jmp L8<  ; add: "> imul eax 213"
L6:             ;BadOperand
L5:           BadOperand
L4:         ;BadMnemonic
L3:       BadMnemonic

L2:     ifnot op2 'N', L2>
          ifnot op3 'T', L3>
            ifnot op4 '3', L4>
                LastOpcode 0CC          ; INT3

L4:         ifnot op4 '4', L4> ; INT4
                LastOpcode 0CC ; INT3 substitution (user really wrote 'int3' _by hand_)

L4:         ifnot op4 'O', L4>            ; INTO
              mov op1 00_1100_1110 | jmp op

L4:         BadMnemonic

L3:       ifnot op3 'S', L3>
            ifnot op4 'B', L4>                  ; INSB
              LastOpcode 00_0110_1100
L4:         ifnot op4 'W', L4>                  ; INSW
              ToOpcode 066
              LastOpcode 0011_01101
L4:         ifnot op4 'D', L4>                  ; INSD
              LastOpcode 00_0110_1101

L4:         BadMnemonic

L3:       ifnot op3 'V', L3>
            ifnot op4 'D', L4>            ; INVD
              mov op1 00_1111,  op2 00_1000 | jmp op_op
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'R', L2>
          ifnot op3 'E', L3>
            ifnot op4 'T', L4>            ; IRET
              mov op1 00_1100_1111 | jmp op
L4:         ;BadMnemonic
L3:       ;BadMnemonic
L2:     BadMnemonic

L1:     ifnot op1 'L', L1>>
          ifnot op2 'A', L2>
            ifnot op3 'H', L3>
              ifnot op4 'F', L4>                ; LAHF
                mov op1 00_1001_1111 | jmp op
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'G', L2>
            ifnot op3 'D', L3>
              ifnot op4 'T', L4>                 ; LGDT
                ifnot B$FirstGender mem, L5>
                  mov op1 00_1111,  op2 1,  op3 0001_0000 | jmp op_op_modRm
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'I', L2>
            ifnot op3 'D', L3>
              ifnot op4 'T', L4>                       ; LIDT
                ifnot B$FirstGender mem, L5>
                mov op1 00_1111,  op2 1,  op3 0001_1000 | jmp op_op_modRm
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'L', L2>
            ifnot op3 'D', L3>
              ifnot op4 'T', L4>                      ; LLDT
                ifnot B$FirstGender mem, L4>
                mov op1 00_1111,  op2 0,  op3 0001_0000 | jmp op_op_modRm16
L4:             ifnot B$FirstGender reg, L5>
                mov op1 00_1111,  op2 0,  op3 001101_0000 | jmp op_op_reg16
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'D', L2>
            ifnot op3 'T', L3>
              ifnot op4 'R', L4>                      ; LDTR
                ifnot B$FirstGender reg, L5>
                  mov op1 00_1111,  op2 0,  op3 00_1101_0000 | jmp op_op_reg16
L5:              ifnot B$FirstGender mem, L5>
                  mov op1 00_1111,  op2 0,  op3 0001_0000 | jmp op_op_modRm16
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'M', L2>
            ifnot op3 'S', L3>
              ifnot op4 'W',  L4>
                ifnot B$FirstGender Reg, L5>               ; LMSW
                  mov op1 00_1111,  op2 1,  op3 00_1111_0000 | jmp op_op_reg1
L5:             ifnot B$FirstGender mem, L5>
                  mov op1 00_1111,  op2 1,  op3 0011_0000 | jmp op_op_modRm
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'O', L4>
            ifnot op3 'D', L3>
              ifnot op4 'S', L4>
                ; LODS   Load String Operand  1010 110w    ??????????????????
                error D$NotYetMnemoPtr
L4:           BadMnemonic
L3:         ifnot op3 'O', L3>
              ifnot op4 'P', L4>                     ; LOOP
                On B$LocalSize <> UpShort, error D$NoPlainLabelForLoopPtr
                mov op1 00_1110_0010 | jmp op_dis8
L4:           ;BadMnemonic
L3:         ;BadMnemonic
L2:       BadMnemonic

L1:     ifnot op1 'N', L1>                           ; NOPE
          ifnot op2 'O', L4>
            ifnot op3 'P', L4>
              ifnot op4 'E', L4>                     ; Empty Macro trick.
                mov B$SIBinside &FALSE, B$DisInside &FALSE, B$DummyDis &FALSE,
                    B$immInside &FALSE, B$PossibleFirstImmLabel &FALSE,
                    B$PossibleImmLabel &FALSE, B$mm3Dsuffix 0
                ret

L1:     ifnot op1 'O', L1>
          ifnot op2 'U', L2>
            ifnot op3 'T', L3>
              ifnot op4 'S', L4>                     ; OUTS
                error D$NotYetMnemoPtr
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'R', L2>
            ifnot op3 'P', L3>
              ifnot op4 'D', L4>                     ; ORPD
                 ToOpcode 001100110 | jmp L5>
L4:           ifnot op4 'S', L4>                     ; ORPS
L5:              mov op1 001010110 | jmp XMMmemXMM
L4:           ;BadMnemonic
L3:         ;BadMnemonic
L2:       BadMnemonic
L1:     ifnot op1 'P', L1>>
          ifnot op2 'A', L2>
            ifnot op3 'D', L3>
              ifnot op4 'D', L4>                   ; PADD > PADDB
                mov cl 'B' | mov op1 00_11111100
                    jmp gg2
L4:           BadMnemonic
L3:        ifnot op3 'N', L3>
              ifnot op4 'D', L4>                   ; PAND
                mov op1 00_11011011
                If B$FirstRegGender = XmmReg
                    ToOpcode 066 | jmp XmmMemXmm
                Else_If B$FirstRegGender = mmReg
                    jmp mmTwo
                End_If
                BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic

L2:       ifnot op2 'S', L2>>
            ifnot op3 'L', L3>
              ifnot op4 'L', L4>                            ; PSLL
                mov cl 'W' | mov op1 00_11110000, op2 0011_110_000 | jmp gg3
L4:           BadMnemonic
L3:         ifnot op3 'R', L3>
              ifnot op4 'A', L4>                            ; PSRA
                mov cl 'W' | mov op1 00_11100000, op2 0011_100_000 | jmp gg3
L4:           ifnot op4 'L', L4>                            ; PSRL
                mov cl, 'W' | mov op1 00_11010000, op2 0011_010_000 | jmp gg3
L4:           BadMnemonic
L3:         ifnot op3 'U', L3>
              ifnot op4 'B', L4>                            ; PSUB
                mov cl 'B' | mov op1 00_11111000 | jmp gg2
L4:           BadMnemonic
L3:         BadMnemonic

L2:       ifnot op2 'O', L2>
            ifnot op3 'P', L3>
              ifnot op4 'A', L4>                       ; POPA
                mov op1 00_0110_0001 | jmp op
L4:           ifnot op4 'F', L4>                       ; POPF
                mov op1 00_1001_1101 | jmp op
L4:           ;BadMnemonic
L3:         BadMnemonic

L2:       ifnot op2 'U', L2>>
            ifnot op3 'S', L3>>
              ifnot op4 'H', L4>>                         ; PUSH
                ifnot B$FirstGender reg, L5>
                  On B$wBit = ByteSize, BadOperand
                  ifnot B$FirstRegGender sReg, L6>       ; max. G.P.regs = 00111
                    cmp B$FirstReg 0010_0000 | jae L7>   ; regFS is 00100000; GS, 00101000
                      mov op1 00_0110 | jmp sReg2                        ; CS / DS / ES / SS
L7:                 mov op1 00_1111,  op2 00_1000_0000 | jmp op_sreg3    ; FS / GS
L6:              ;mov op1 00_1111_1111,  op2 00_1111_0000 | jmp op_reg1  ; G.P.
                  mov op1 0_0101_0000 | jmp reg1_in_op                    ; register alternate
L5:             ifnot B$FirstGender mem, L5>
                  On B$wBit = ByteSize, BadOperand
                    mov op1 00_1111_1111,  op2 0011_0000 | jmp op_modRm
L5:             ifnot B$FirstGender imm, L5>
                  mov op1 00_0110_1000 | jmp s_imm
L5:             ifnot B$FirstGender dis, L5>
                   mov op1 00_0110_1000 | jmp op_P1
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'X', L2>
            ifnot op3 'O', L3>
              ifnot op4 'R', L4>                       ; PXOR
                mov op1 00_11101111 | jmp OQregMemToReg
L4:           BadMnemonic
L3:         BadMnemonic
L2:       BadMnemonic
L1:     ifnot op1 'S', L1>>
          ifnot op2 'A', L2>
            ifnot op3 'H', L3>
              ifnot op4 'F', L4>               ; SAHF
                mov op1 00_1001_1110 | jmp op
L4:           BadMnemonic
L3:         ifnot op3 'L', L3>
              ifnot op4 'C', L4>               ; SALC
                mov op1 0D6 | jmp op
L4:           BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'C', L2>
            ifnot op3 'A', L3>
              ifnot op4 'S', L4>               ; SCAS
                error D$NotYetMnemoPtr
                ; SCAS – Scan String 1101 111w
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'G', L2>
            ifnot op3 'D', L3>
              ifnot op4 'T', L4>                ; SGDT
                ifnot B$FirstGender mem, L5>
                  mov op1 00_1111,  op2 1,  op3 0 | jmp op_op_modRm
L5:             BadOperand
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:       ifnot op2 'H', L2>>
            mov op1 00_1111
            cmp op3 'L' | je L7>
            cmp op3 'R' | je L6>
L9:           BadMnemonic
L7:           mov op2 00_1010_0100 | jmp L5>
L6:           mov op2 00_1010_1100
L5:           ifnot op4 'D', L9<                 ; SHLD / SHRD
                ifnot B$Operands RegToReg, L3>
                  mov op3 00_1100_0000
                  ifnot B$ThirdGender imm, L4>
                    jmp op_op_reg2reg1_imm8
L4:               ifnot B$ThirdGender Reg, L9<
                    ifnot B$ThirdReg RegCl, L9<
                      or op2 1 | jmp op_op_reg2reg1_cl
L3:             ifnot B$Operands RegToMem, L9<
                  ifnot B$ThirdGender imm, L4>
                    jmp op_op_ModReg2Rm_imm8
L4:               ifnot B$ThirdGender Reg, L9<
                    ifnot B$ThirdReg RegCl, L9<
                    or op2 1 | jmp op_op_modReg2Rm_cl

L2:      ifnot op2 'I', L2>
           ifnot op3 'D', L3>
             ifnot op4 'T', L4>                      ; SIDT
               ifnot B$FirstGender mem, L5>
                 mov op1 00_1111,  op2 1, op3 00_1_000 | jmp op_op_modRm
L5:            BadOperand
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'L', L2>
           ifnot op3 'D', L3>
             ifnot op4 'T', L4>                      ; SLDT
               mov op1 00_1111,  op2 0
               ifnot B$FirstGender reg, L5>
                 mov op3 00_1100_0000 | jmp op_op_reg1
L5:            ifnot B$FirstGender mem, L5>
                 mov op3 0 | jmp op_op_modRm
L5:            ;BadOperand
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'M', L2>
           ifnot op3 'S', L3>
             ifnot op4 'W', L4>                 ; SMSW
               mov op1 00_1111,  op2 1
               ifnot B$FirstGender Reg, L5>
                 mov op3 00_1110_0000 | jmp op_op_reg1
L5:            ifnot B$FirstGender mem, L5>
                 mov op3 0010_0000 | jmp op_op_modRm
L5:            BadOperand
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'T', L2>
           ifnot op3 'O', L3>
             ifnot op4 'S', L4>
               error D$NotYetMnemoPtr
               ; STOS – Store String Data 1010 101w
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'T', L1>
         ifnot op2 'E', L2>
           ifnot op3 'S', L3>
             ifnot op4 'T', L4>                      ; TEST
               ifnot B$Operands RegToReg, L5>
                 mov op1 00_1000_0100,  op2 00_1100_0000 | jmp w_reg2reg1
L5:            ifnot B$Operands memToReg, L5>
                 mov op1 00_1000_0100 | jmp w_modReg1Rm
L5:            ifnot B$Operands RegToMem, L5>
                 mov op1 00_1000_0100 | jmp w_modReg2Rm
L5:            ifnot B$Operands immToReg, L5>
                 ifnot B$FirstReg RegEax, L6>
                   mov op1 00_1010_1000 | jmp w_imm
L6:                mov op1 00_1111_0110,  op2 00_1100_0000 | jmp w_reg1_imm
L5:            ifnot B$Operands immToMem, L5>
                   mov op1 00_1111_0110,  op2 0 | jmp w_modRm_imm
L5:            BadOperand
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'V', L1>
         ifnot op2 'E', L2>
           ifnot op3 'R', L3>
             ifnot op4 'R', L4>                    ; VERR
               mov op1 00_1111,  op2 0
               ifnot B$FirstGender reg, L5>
                 mov op3 00_1110_0000 | jmp op_op_reg16
L5:            ifnot B$FirstGender mem, L5>
                 mov op3 0010_0000 | jmp op_op_modRm16
L5:            BadOperand
L4:          ifnot op4 'W', L4>                     ; VERW
               mov op1 00_1111,  al 0
               ifnot B$FirstGender reg, L5>
                 mov op3 00_1110_1000 | jmp op_op_reg16
L5:            ifnot B$FirstGender mem, L5>
                 mov op3 0010_1000 | jmp op_op_modRm16
L5:            BadOperand
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'W', L1>
         ifnot op2 'A', L2>
           ifnot op3 'I', L3>
             ifnot op4 'T', L4>                      ; WAIT
               mov op1 00_1001_1011 | jmp op
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'X', L1>>
         ifnot op2 'A', L2>
           ifnot op3 'D', L3>
             ifnot op4 'D', L4>                        ; XADD
               mov op1 00_1111,  op2 00_1100_0000
               ifnot B$Operands RegToReg, L5>
                 mov op3 00_1100_0000 | jmp op_w_reg2reg1
L5:            ifnot B$Operands RegToMem, L5>
                 jmp op_w_modReg2Rm
L5:            BadOperand
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'C', L2>>
           ifnot op3 'H', L3>>
             ifnot op4 'G', L4>>                   ; XCHG
               ifnot B$Operands RegToReg, L5>
                 ifnot B$FirstReg RegEax, L6>
                   mov op2 B$FirstReg,  op1 B$SecondReg
                   mov B$FirstReg op1,  B$SecondReg op2  ; exchange the regs order
L6:              ifnot B$SecondReg RegEax, L6>
                   cmp B$SecondOperandwBit ByteSize | jne L7>
                      mov op1 086, op2 00_11_000_000 | jmp op_reg2reg1
L7:                mov op1 00_1001_0000 | jmp XOPreg1
L6:                mov op1 00_1000_0110,  op2 00_1100_0000 | jmp w_reg1reg2
L5:            ifnot B$Operands MemToReg, L5>
                   mov op1 00_1000_0110 | jmp w_modReg1Rm
L5:            ifnot B$Operands RegToMem, L5>
                   mov op1 00_1000_0110 | jmp w_modReg2Rm
L5:            BadOperand
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'L', L2>
           ifnot op3 'A', L3>
             ifnot op4 'T', L4>                   ; XLAT
               mov op1 00_1101_0111 | jmp op
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ;BadMnemonic
L1:    BadMnemonic

 _______________________________________________________________________________________


FiveLetters:     On op6 > Separators,  jmp SixLetters



; Align: One imm parameter. Here, i just fill with NOPs up to whished adress.
; I disagree with alignment use. Do what you want here, according your own
; whishes:

       Ifnot op1 'A', L1>>
         ifnot op2 'L', L2>>
           ifnot op3 'I', L3>>
             ifnot op4 'G', L3>>
               ifnot op5 'N', L3>>                    ; ALIGN
                 cmp B$ParametersNumber 1 | jne L6>
                 cmp B$FirstGender imm | jne L6>
                    cmp D$imm32 4 | jl L6>
                    cmp D$imm32 0100 | ja L6>
                    mov ecx D$imm32 | bsr eax ecx | bsf ebx ecx
                    On eax <> ebx, error D$BadAlignPtr
                    dec ecx | test edi ecx | jz L9>
                    mov eax edi | and eax ecx | sub ecx eax | inc ecx
                    cmp ecx 5 | jb L7>
                    mov al 0EB | stosb | mov al cl | sub al 2 | stosb
                    sub ecx 2
L7:                 mov al 090 | rep stosb
                    call SetAlignFlag
L9:                 mov D$imm32 0, B$immInside &FALSE
                 ret
L6:              BadOperand
L3:        BadMnemonic
L2:      ifnot op2 'D', L2>
           ifnot op3 'D', L3>
             ifnot op4 'P', L4>
               ifnot op5 'D', L5>                    ; ADDPD
                  ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                    ; ADDPS
L6:               mov op1 001011000 | jmp XMMmemXMM
L5:            BadMnemonic
L4:          ifnot op4 'S', L4>
               ifnot op5 'D', L5>                    ; ADDSD
                  ToOpcode 0011110010 | jmp L6>
L5:            ifnot op5 'S', L5>                    ; ADDSS
                  ToOpcode 0011110011                ; additional frefix for ADDSS
L6:               mov op1 001011000 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'N', L2>
           ifnot op3 'D', L3>
             ifnot op4 'P', L4>
               ifnot op5 'D', L5>                    ; ANDPD
                  ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                    ; ANDPS
L6:               mov op1 001010100 | jmp XMMmemXMM
L5:            BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'B', L1>
         ifnot op2 'O', L2>
           ifnot op3 'U', L3>
             ifnot op4 'N', L4>
               ifnot op5 'D', L5>                     ; BOUND
                 ifnot B$Operands memToreg, L6>
                   mov op1 00_0110_0010 | jmp op_modReg1Rm
L6:              BadOperand
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'S', L2>
           ifnot op3 'W', L3>
             ifnot op4 'A', L4>
               ifnot op5 'P', L5>                        ; BSWAP
                 ifnot B$FirstGender reg, L6>
                   mov op1 00_1111,  op2 00_1100_1000 | jmp op_reg1
L6:              BadOperand
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'C', L1>>
         ifnot op2 'M', L2>>
           ifnot op3 'P', L3>
             ifnot op4 'P', L4>
               ifnot op5 'D', L5>                 ; CMPPD SSE2
                  ToOpcode 066 | mov op1 0C2 | jmp XmmMemXmmImm7
L5:            ifnot op5 'S', L5>                 ; CMPPS SSE2
                 mov op1 0011000010 | jmp XmmMemXmmImm7
L5:            BadMnemonic
L4:          ifnot op4 'S', L4>
               ifnot op5 'B', L5>                 ; CMPSB / W / D
                 mov op1 00_1010_0110 | jmp op
L5:            ifnot op5 'W', L5>
                 ToOpcode 066
                 mov op1 00_1010_0111 | jmp op
L5:            ifnot op5 'D', L5>
                 If B$FirstRegGender = XmmReg     ; CMPSD SSE2
                    ; Alternate
                    ToOpcode 0011110010 | mov op1 0011000010 | jmp XmmMemXmmImm7
                 End_If
                 mov op1 00_1010_0111 | jmp op

L5:            ifnot op5 'S', L5>                  ; CMPSS SSE2
                 ToOpcode 0F3 | mov op1 0011000010 | jmp XmmMemXmmImm7

L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'P', L2>
           ifnot op3 'U', L3>
             ifnot op4 'I', L4>
               ifnot op5 'D', L5>                    ; CPUID
                 mov op1 00_1111,  op2 00_1010_0010 | jmp op_op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'D', L1>>
         ifnot op2 'I', L2>>
           ifnot op3 'V', L3>>
             ifnot op4 'P', L4>>
               ifnot op5 'D', L5>>                        ; DIVPD
                 ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>>                        ; DIVPS
L6:              mov op1 001011110 | jmp XMMmemXMM
L5:            BadMnemonic
L4:          ifnot op4 'S', L4>>
               ifnot op5 'D', L5>>                        ;DIVSD
                   ToOpcode 0011110010 | jmp L6>
L5:            ifnot op5 'S', L5>>                        ;DIVSS
                   ToOpcode 0011110011
L6:                mov op1 001011110 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'E', L1>>
         ifnot op2 'N', L2>>
           ifnot op3 'T', L3>>
             ifnot op4 'E', L4>>
               ifnot op5 'R', L5>>                        ; ENTER

                ToOpcode 0C8

                mov esi D$LineStart
L6:             lodsb
                    If al be EOI
                        mov eax NotEnough | jmp EnterError
                    End_If
                    ifnot al Space,  L6<

                    call TranslateAny

                    If eax > 0FFFC
                        mov eax EnterStack | jmp EnterError
                    End_If
                    test eax 0011 | jz S0>
                        mov eax EnterStack | jmp EnterError

S0:                 ToOpcode al, ah        ; 16-bit >>> displacement

                    .If B$esi-1 = Space
                        call TranslateAny   ; test both numbers at once
                        If eax > 31
                            mov eax EnterLevel | jmp EnterError    ; 8-bit level (L)
                        End_If
                        ToOpcode al
                    .Else
                        ToOpcode  0
                    .End_If

                    mov esi D$LineStart
                    While B$esi > EOI
                        mov B$esi 0 | inc esi
                    End_While

                    ret

EnterError: mov esi D$LineStart
            While B$esi > EOI
                mov B$esi 0 | inc esi
            End_While
            jmp OutOnError

L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'I', L1>
         ifnot op2 'R', L2>
           ifnot op3 'E', L3>
             ifnot op4 'T', L4>
               ifnot op5 'D', L5>               ; IRETD
                 mov op1 00_1100_1111 | jmp op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'L', L1>>
         ifnot op2 'D', L2>
           ifnot op3 'D', L3>
             ifnot op4 'Q', L4>
               ifnot op5 'U', L5>       ; LDDQU
                IfNot B$Operands MemToReg, L6>
                ToOpcode 0F2 | mov Op1 0F0 | jmp MMXmemXMM
L6: BadOperand
L2:      ifnot op2 'E', L2>
           ifnot op3 'A', L3>
             ifnot op4 'V', L4>
               ifnot op5 'E', L5>
                 mov op1 00_1100_1001 | jmp op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'O', L2>
           ifnot op3 'D', L3>
             ifnot op4 'S', L4>
               ifnot op5 'B', L5>              ; LODSB  /  W /  D
                 mov op1 00_0101_01100 | jmp op
L5:            ifnot op5 'W', L5>
                 ToOpcode 066
                 mov op1 00_1010_1101 | jmp op
L5:            ifnot op5 'D', L5>
                 mov op1 00_1010_1101 | jmp op
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'O', L3>
             ifnot op4 'P', L4>
               ifnot op5 'Z', L6>                 ; LOOPZ  /  E
L5:              On B$LocalSize <> UpShort, error D$NoPlainLabelForLoopPtr
                 mov op1 00_1110_0001 | jmp op_dis8
L6:            cmp op5, 'E' | je L5<
               BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'M', L1>>
         ifnot op2 'A', L2>
           ifnot op3 'X', L3>
             ifnot op4 'S', L4>
               ifnot op5 'S', L5>                 ; MAXSS
                 ToOpcode 0F3 | jmp L6>
L5:            ifnot op5 'D', L5>                 ; MAXSD
                 ToOpcode 0F2
L6:              mov op1 05F | jmp XMMmemXMM
L5:            BadMnemonic
L4:          ifnot op4 'P', L4>
               ifnot op5 'D', L5>                 ; MAXPD
                   ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                 ; MAXPS
L6:                mov op1 001011111 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ifnot op2 'I', L2>
           ifnot op3 'N', L3>
             ifnot op4 'S', L4>
               ifnot op5 'D', L5>                  ; MINSD
                   ToOpcode 0011110010 | jmp L6>
L5:            ifnot op5 'S', L5>                  ; MINSS
                 ToOpcode 0011110011 | jmp L6>
L5:            BadMnemonic
L4:          ifnot op4 'P', L4>
               ifnot op5 'D', L5>                 ; MINPD
                   ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                 ; MINPS
L6:                mov op1 001011101 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'U', L2>
           ifnot op3 'L', L3>
             ifnot op4 'S', L4>
               ifnot op5 'D', L5>                 ; MULSD
                 ToOpcode 0011110010 | jmp L6>
L5:            ifnot op5 'S', L5>                 ; MULSS
                 ToOpcode 0011110011 | jmp L6>
L5:            BadMnemonic
L4:          ifnot op4 'P', L4>
               ifnot op5 'D', L5>                 ; MULPD
                   ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                 ; MULPS
L6:                mov op1 001011001 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'W', L2>
           ifnot op3 'A', L3>
             ifnot op4 'I', L4>
               ifnot op5 'T', L5>                 ; MWAIT
                 ToOpcode 0F, 01, 0C9 | ret
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'O', L1>>
         ifnot op2 'U', L2>
           ifnot op3 'T', L3>
             ifnot op4 'S', L4>
               ifnot op5 'B', L5>                ; OUTSB  /  W  /  D
                 mov op1 00_0110_1110 | jmp op
L5:            ifnot op5 'W', L5>
                 ToOpcode 066
                 mov op1 00_0110_1111 | jmp op
L5:            ifnot op5 'D', L5>
                 mov op1 00_0110_1111 | jmp op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'P', L1>>
         ifnot op2 'A', L2>>
           ifnot op3 'D', L3>>
             ifnot op4 'D', L4>>
               cmp op5 'B' | je L6>
               cmp op5 'W' | je L6>
               cmp op5 'D' | jne L5>                         ; PADDB/W/D
L6:              mov cl op5 | mov op1 00_11111100
                     jmp gg2
L5:            ifnot op5 'Q', L5>                            ; PADDQ
                     mov op1 0011010100 | jmp OQRegMemToReg
L5:            ifnot op5 'S', L5>                            ; PADDS
                 mov cl 'B' | mov op1 00_11101100
                    jmp gg2
L5:          ;  BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'N', L3>
             ifnot op4 'D', L4>                      ; PANDB
               ifnot op5 'Q', L5>
                 mov op1 00_11011011 | jmp mmTwo
L5:            ifnot op5 'N', L5>                    ; PANDN
                 mov op1 00_11011111 | jmp OQRegMemToReg
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'U', L3>
             ifnot op4 'S', L4>                      ; PAUSE
               ifnot op5 'E', L5>
                   ToOpcode 0011110011 | LastOpcode 0010010000
L3:        ifnot op3 'V', L3>
             ifnot op4 'G', L4>
               ifnot op5  'B', L5>                   ; PAVGB
                 mov op1 0E0 | jmp OQregMemToReg
L5:            ifnot op5 'W', L5>>                   ; PAVGW
                 mov op1 0E3 | jmp OQregMemToReg
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'F', L2>>
           Ifnot op3 '2', L3>
             ifnot op4 'I', L4>
               ifnot op5 'D', L5>               ; PF2ID
                   mov op1 01D | jmp mm3D
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        Ifnot op3 'A', L3>
             ifnot op4 'C', L4>
               ifnot op5 'C', L5>               ; PFACC
                   mov op1 0AE | jmp mm3D
L5:            BadMnemonic
L4:          ifnot op4 'D', L4>
               ifnot op5 'D', L5>               ; PFADD
                   mov op1 09E | jmp mm3D
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        Ifnot op3 'M', L3>
             ifnot op4 'A', L4>
               ifnot op5 'X', L5>               ; PFMAX
                   mov op1 0A4 | jmp mm3D
L5:            BadMnemonic
L4:          ifnot op4 'I', L4>
               ifnot op5 'N', L5>               ; PFMIN
                   mov op1 094 | jmp mm3D
L5:            BadMnemonic
L4:          ifnot op4 'U', L4>
               ifnot op5 'L', L5>               ; PFMUL
                   mov op1 0B4 | jmp mm3D
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        Ifnot op3 'R', L3>
             ifnot op4 'C', L4>
               ifnot op5 'P', L5>               ; PFRCP
                   mov op1 096 | jmp mm3D
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        Ifnot op3 'S', L3>
             ifnot op4 'U', L4>
               ifnot op5 'B', L5>               ; PFSUB
                   mov op1 09A | jmp mm3D
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'I', L2>
           Ifnot op3 '2', L3>
             ifnot op4 'F', L4>
               ifnot op5 'D', L5>               ; PI2FD
                   mov op1 0D | jmp mm3D
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'M', L2>
           Ifnot op3 'A', L3>
             ifnot op4 'D', L4>
               ifnot op5 'D', L5>               ; PMADD
                 mov op1 00_11110101 | jmp OQRegMemToReg
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'U', L3>
             ifnot op4 'L', L4>
               ifnot op5 'H', L5>                  ; PMULH
                 mov op1 00_11100101 | jmp OQRegMemToReg
L5:            ifnot op5 'L', L5>                  ; PMULL
                 mov op1 00_11010101 | jmp OQRegMemToReg
L5:            ifnot op5 'W', L5>                  ; PMULW
                 mov op1 0D5 | jmp OQRegMemToReg
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'O', L2>>
           ifnot op3 'P', L3>
             ifnot op4 'A', L4>
               ifnot op5 'D', L5>                 ; POPAD
                 mov op1 00_0110_0001 | jmp op
L5:             ifnot op5 'W', L5>                 ; POPAW
                 ToOpcode 066 | mov op1 00_0110_0001 | jmp op
L5:            BadMnemonic
L4:          ifnot op4 'F', L4>
               ifnot op5 'D',L5>                 ; POPFD
                 mov op1 00_1001_1101 | jmp op
L5:            ifnot op5 'W',L5>                 ; POPFW
                 ToOpcode 066 | mov op1 00_1001_1101 | jmp op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:       ifnot op2 'S', L2>>
            ifnot op3 'L', L3>
              ifnot op4 'L', L4>                  ; PSLLW/D/Q
                cmp op5 'W' | je L6>
                cmp op5 'D' | je L6>
                cmp op5 'Q' | jne L5>
L6:               mov cl op5 |  mov op1 00_11110000, op2 0011_110_000 | jmp gg3
L5:             ;BadMnemonic
L4:           BadMnemonic
L3:         ifnot op3 'R', L3>
              ifnot op4 'A', L4>
                cmp op5 'W' | je L6>
                cmp op5 'D' | jne L5>                             ; PSRAW/D
L6:               mov cl op5 |  mov op1 00_11100000, op2 0011_100_000 | jmp gg3
L5:             BadMnemonic
L4:           ifnot op4 'L', L4>
                cmp op5 'W' | je L6>
                cmp op5 'D' | je L6>
                cmp op5 'Q' | jne L5>                          ; PSRLW/D/Q
L6:               mov cl op5 | mov op1 00_11010000, op2 0011_010_000 | jmp gg3
L5:             BadMnemonic
L4:           BadMnemonic
L3:         ifnot op3 'U', L3>
              ifnot op4 'B', L4>
                cmp op5 'B' | je L6>
                cmp op5 'W' | je L6>
                cmp op5 'D' | jne L5>                           ; PSUBB/W/D
L6:               mov cl op5 | mov op1 00_11111000 | jmp gg2
L5:             cmp op5 'Q' | jne L5>                           ; PSUBQ
                  mov op1 0011111011 | jmp OQregMemToReg
L5:            ifnot op5 'S', L5>                               ; PSUBS
                 mov cl 'B' | mov op1 00_11101000 | jmp gg2
L5:             ;BadMnemonic
L4:           ;BadMnemonic
L3:         BadMnemonic
L2:      ifnot op2 'U', L2>
           ifnot op3 'S', L3>
             ifnot op4 'H', L4>
               ifnot op5 'A', L5>                 ; PUSHA
                 mov op1 00_0110_0000 | jmp op
L5:            ifnot op5 'F', L5>                 ; PUSHF
                 mov op1 00_0100_11100 | jmp op
L5:            ifnot op5 'W', L5>                 ; PUSHW
                  ifnot B$FirstGender imm, L6>
                    mov op1 00_0110_1000 | jmp s_imm16
L6:               BadOperand
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'R', L1>>
         ifnot op2 'C', L2>
           ifnot op3 'P', L3>
             ifnot op4 'S', L4>
               ToOpcode 0011110011 | jmp L5>           ; RCPSS
L4:          ifnot op4 'P', L4>
L5:            ifnot op5 'S', L5>                      ; RCPPS
                 mov op1 001010011 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'D', L2>
           ifnot op3 'M', L3>
             ifnot op4 'S', L4>
               ifnot op5 'R', L5>                      ; RDMSR
                 mov op1 00_1111,  op2 0011_0010 | jmp op_op
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'P', L3>
             ifnot op4 'M', L4>
               ifnot op5 'C', L5>                      ; RDPMC
                 mov op1 00_1111,  op2 0011_0011 | jmp op_op
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'T', L3>
             ifnot op4 'S', L4>
               ifnot op5 'C', L5>                      ; RDTSC
                 mov op1 00_1111,  op2 0011_0001 | jmp op_op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemnonic
L2:      BadMnemonic
L1:    ifnot op1 'S', L1>>
         ifnot op2 'C', L2>
           ifnot op3 'A', L3>
             ifnot op4 'S', L4>
               ifnot op5 'B', L5>                 ; SCASB / W / D
                 mov op1 00_1010_1110    ; 011011110B mistake in intel doc
                    jmp op
L5:            ifnot op5 'W', L5>
                 ToOpcode 066
                 mov op1 00_1010_1111     ; 011011111B
                   jmp op
L5:            ifnot op5 'D', L5>
                 mov op1 00_1010_1111     ; 011011111B
                     jmp op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'T', L2>
           ifnot op3 'O', L3>
             ifnot op4 'S', L4>
               ifnot op5 'B', L5>                     ; STOSB / W / D
                 mov op1 00_1010_1010 | jmp op
L5:            ifnot op5 'W', L5>
                 ToOpcode 066
                 mov op1 00_1010_1011 | jmp op
L5:            ifnot op5 'D', L5>
                 mov op1 00_1010_1011 | jmp op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'U', L2>
           ifnot op3 'B', L3>
             ifnot op4 'S', L4>
               ifnot op5 'D', L5>                     ; SUBSD
                   ToOpcode 0011110010 | jmp L6>
L5:            ifnot op5 'S', L5>                     ; SUBSS
                   ToOpcode 0011110011 | jmp L6>
L5:            BadMnemonic
L4:          ifnot op4 'P', L4>
               ifnot op5 'D', L5>                     ; SUBPD
                   ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                     ; SUBPS
L6:                mov op1 001011100 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'W', L1>
         ifnot op2 'R', L2>
           ifnot op3 'M', L3>
             ifnot op4 'S', L4>
               ifnot op5 'R', L5>                             ; WRMSR
                 mov op1 00_1111,  op2 0011_0000 | jmp op_op
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'X', L1>
         ifnot op2 'L', L2>
           ifnot op3 'A', L3>
             ifnot op4 'T', L4>
               ifnot op5 'B', L5>                            ; XLATB
                 mov op1 00_1101_0111 | jmp op              ; XLATB 11   >>>  XLAT  ???
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'O', L2>
           ifnot op3 'R', L3>
             ifnot op4 'P', L4>
               ifnot op5 'D', L5>                            ; XORPD
                   ToOpcode 001100110 | jmp L6>
L5:            ifnot op5 'S', L5>                            ; XORPS
L6:                mov op1 001010111 | jmp XMMmemXMM
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ;BadMnemonic
L1:    BadMnemonic

 _______________________________________________________________________________________

SixLetters:     On op7 > Separators,  jmp SevenLetters

       ifnot op1 'A', L1>
         ifnot op2 'N', L2>
           ifnot op3 'D', L3>
             ifnot op4 'N', L4>
               ifnot op5 'P', L5>
                 ifnot op6 'D', L6>                      ; ANDNPD
                   ToOpcode 001100110 | jmp L7>
L6:              ifnot op6 'S', L6>                      ; ANDNPS
L7:                mov op1 001010101 | jmp XMMmemXMM
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic

L1:    ifnot op1 'C', L1>
         ifnot op2 'O', L2>
           ifnot op3 'M', L3>
             ifnot op4 'I', L4>
               ifnot op5 'S', L5>
                 ifnot op6 'S', L6>                      ; COMISS
                   mov op1 00101111 | jmp XMMmemXMM
L6:              ifnot op6 'D', L6>                      ; COMISD
                   ToOpcode 001100110 | mov op1 02F | jmp XMMmemXMM  ; 66 0F 2F xx
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'H', L1>
         ifnot op2 'A', L2>
           ifnot op3 'D', L3>
             ifnot op4 'D', L4>
               ifnot op5 'P', L5>
                 ifnot op6 'D', L6>         ; HADDPD 66,0F,7C,/r HADDPD xmm1, xmm2/m128
                   ToOpcode 066 | mov Op1 07C | jmp XmmMemXmm
L6:              ifnot op6 'S', L6>         ; HADDPS F2,0F,7C,/r HADDPS xmm1, xmm2/m128
                   ToOpcode 0F2 | mov Op1 07C | jmp XmmMemXmm
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'S', L2>
           ifnot op3 'U', L3>
             ifnot op4 'B', L4>
               ifnot op5 'P', L5>
                 ifnot op6 'D', L6>         ; HSUBPD 66,0F,7D,/r HSUBPD xmm1, xmm2/m128
                   ToOpcode 066 | mov Op1 07D | jmp XmmMemXmm
L6:              ifnot op6 'S', L6>         ; HSUBPS F2,0F,7D,/r HSUBPS xmm1, xmm2/m128
                   ToOpcode 0F2 | mov Op1 07D | jmp XmmMemXmm
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'I', L1>
         ifnot op2 'N', L2>
           ifnot op3 'V', L3>
             ifnot op4 'L', L4>
               ifnot op5 'P', L5>
                 ifnot op6 'G', L6>     ; INVLPG
                   ifnot B$FirstGender mem, L7>
                     mov op1 00_1111,  op2 1,  op3 00_111_000 | jmp op_op_modRm
L7:                BadOperand
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'L', L1>
         ifnot op2 'F', L2>
           ifnot op3 'E', L3>
             ifnot op4 'N', L4>
               ifnot op5 'C', L5>
                 ifnot op6 'E', L6>                 ; LFENCE
                     ToOpcode 00001111, 0010101110 | LastOpcode 0011101000
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'O', L2>
           ifnot op3 'O', L3>
             ifnot op4 'P', L4>
               ifnot op5 'N', L5>
                 ifnot op6 'Z', L6>                 ; LOOPNZ /  E
L7:                On B$LocalSize <> UpShort, error D$NoPlainLabelForLoopPtr
                   mov op1 00_1110_0000 | jmp op_dis8
L6:              cmp op6 'E' | je L7<
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'M', L1>
         ifnot op2 'F', L2>
           ifnot op3 'E', L3>
             ifnot op4 'N', L4>
               ifnot op5 'C', L5>
                 Ifnot op6 'E', L6>                         ; MFENCE
                     ToOpcode 00001111, 0010101110 | LastOpcode 0011110000
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'P', L1>>
         ifnot op2 'A', L2>>
           ifnot op3 'D', L3>>
             ifnot op4 'D', L4>>
               ifnot op5 'S', L5>
                 cmp op6 'B' | je L7>
                 cmp op6 'W' | jne L6>                         ; PADDSB/W
L7:                mov cl op6 | mov op1 00_11101100  ; = 0EC
                      jmp gg2
L6:              BadMnemonic
L5:            ifnot op5 'U', L5>
                 ifnot op6 'S', L6>                            ; PADDUS
                   mov cl, 'B' | mov op1 00_11011100
                       jmp gg2
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          BadMnemonic
L2:        ifnot op2 'C', L2>
             ifnot op3 'M', L3>
               ifnot op4 'P', L4>
                 ifnot op5 'E', L5>
                   ifnot op6 'Q', L6>                          ; PCMPEQ
                     mov cl 'B' | mov op1 00_01110100
                         jmp gg2
L6:                BadMnemonic
L5:              ifnot op5 'G', L5>
                   ifnot op6 'T', L6>                          ; PCMPGT
                     mov cl 'B' | mov op1 00_01100100
                         jmp gg2
L6:                ;BadMnemonic
L5:              ;BadMnemonic
L4:            ;BadMnemonic
L3:          BadMnemonic
L2:      ifnot op2 'E', L2>
           ifnot op3 'X', L3>
             ifnot op4 'T', L4>
               ifnot op5 'R', L5>
                 ifnot op6 'W', L6>                             ; PEXTRW
                     mov op1 0011000101 | jmp OQregRegImm8
L6:                ;BadMnemonic
L5:              ;BadMnemonic
L4:            ;BadMnemonic
L3:          BadMnemonic
L2:      ifnot op2 'I', L2>
           ifnot op3 'N', L3>
             ifnot op4 'S', L4>
               ifnot op5 'R', L5>
                 ifnot op6 'W', L6>                              ; PINSRW
                     mov op1 0011000100 | jmp OQregmemImm8
L6:                ;BadMnemonic
L5:              ;BadMnemonic
L4:            ;BadMnemonic
L3:          BadMnemonic
L2:      ifnot op2 'F', L2>
           ifnot op3 'S', L3>
             ifnot op4 'U', L4>
               ifnot op5 'B', L5>
                 ifnot op6 'R', L6>            ; PFSUBR
                     mov op1 0AA | jmp mm3D
L6:                ;BadMnemonic
L5:              ;BadMnemonic
L4:            ;BadMnemonic
L3:          BadMnemonic
L2:      ifnot op2 'M', L2>>
           ifnot op3 'A', L3>
             ifnot op4 'X', L4>
               ifnot op5 'S', L5>
                 ifnot op6 'W', L6>                         ; PMAXSW
                    mov op1 0011101110 | jmp OQregMemToReg
L6:                BadMnemonic
L5:            ifnot op5 'U', L5>
                 ifnot op6 'B', L6>                         ; PMAXUB
                    mov op1 0011011110 | jmp OQregMemToReg
L5:             ;BadMnemonic
L4:            ;BadMnemonic
L3:        ifnot op3 'I', L3>
             ifnot op4 'N', L4>
               ifnot op5 'S', L5>
                 ifnot op6 'W', L6>                         ; PMINSW
                    mov op1 0011101010 | jmp OQregMemToReg
L6:                BadMnemonic
L5:            ifnot op5 'U', L5>
                 ifnot op6 'B', L6>                         ; PMINUB
                    mov op1 0011011010 | jmp OQregMemToReg
L5:              ;BadMnemonic
L4:            ;BadMnemonic
L3:        ifnot op3 'U', L3>
             ifnot op4 'L', L4>
               ifnot op5 'H', L5>
                 ifnot op6 'W', L6>                         ; PMULHW
                    mov op1 0E5 | jmp OQregMemToReg
L6:                ;BadMnemonic

L5:            ifnot op5 'L', L5>
                 ifnot op6 'W', L6>                     ; PMULLW
                   mov op1 0D5 | jmp OQRegMemToReg

L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'S', L2>>
           ifnot op3 'A', L3>
             ifnot op4 'D', L4>
               ifnot op5 'B', L5>
                 ifnot op6 'W', L6>                         ; PSADBW
                     mov op1 0011110110 | jmp OQregMemToReg
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'H', L3>
             ifnot op4 'U', L4>
               ifnot op5 'F', L5>
                 ifnot op6 'D', L6>                         ; PSHUFD
                    ToOpcode 001100110 | mov op1 001110000 | jmp XmmMemXmmImm8
L6:              ifnot op6 'W', L6>                         ; PSHUFW
                     mov op1 001110000 | jmp mmTwoImm8
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'L', L3>
             ifnot op4 'L', L4>>
               ifnot op5 'D', L5>>
                 ifnot op6 'Q', L6>>                         ; PSLLDQ
                     If B$ImmInside = &FALSE
                        error D$MissingOperandPtr
                     Else_If B$FirstRegGender <> XmmReg
                        BadOperand
                     End_If
                     Imm8Size
                     ToOpcode 001100110, 00001111, 001110011
                     mov op1 0011111000 | or op1 B$FirstReg | LastOpcode op1
L3:        ifnot op3 'R', L3>
             ifnot op4 'L', L4>
               ifnot op5 'D', L5>
                 ifnot op6 'Q', L6>                         ; PSRLDQ
                     ToOpcode 001100110, 00001111, 001110011
                     On B$Operands <> ImmToReg, jmp L7>
                     On B$FirstRegGender <> XmmReg, jmp L7>
                     Imm8Size
                         mov op1 0011_011_000 | or op1 B$FirstReg | LastOpcode op1
L7:                  BadOperand
L3:        ifnot op3 'U', L3>
             ifnot op4 'B', L4>
               ifnot op5 'S', L5>
                 cmp op6 'B' | je L7>
                 cmp op6 'W' | jne L6>                         ; PSUBSB/W
L7:                mov cl op6 | mov op1 00_11101000 | jmp gg2
L6:              ;BadMnemonic
L5:            ifnot op5 'U', L5>
                 ifnot op6 'S', L6>                            ; PSUBUS
                   mov cl 'B' | mov op1 00_11011000 | jmp gg2
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'U', L2>
           ifnot op3 'S', L3>
             ifnot op4 'H', L4>
               ifnot op5 'A', L5>
                 ifnot op6 'D', L6>                             ; PUSHAD
                   mov op1 00_0110_0000 | jmp op
L6:             ifnot op6 'W', L6>                             ; PUSHAW
                   ToOpcode 066 | mov op1 00_0110_0000 | jmp op
L6:              BadMnemonic
L5:            ifnot op5 'F', L5>                               ; PUSHFD
                 ifnot op6 'D', L6>
                   mov op1 00_1001_1100 | jmp op
L6:              ifnot op6 'W', L6>                             ; PUSHFW
                   ToOpcode 066 | mov op1 00_1001_1100 | jmp op
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'S', L1>>
         ifnot op2 'F', L2>
           ifnot op3 'E', L3>
             ifnot op4 'N', L4>
               ifnot op5 'C', L5>
                 ifnot op6 'E', L6>                           ; SFENCE
                    ToOpcode 00001111, 0010101110, 0011111000 | ret
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'H', L2>
           ifnot op3 'U', L3>
             ifnot op4 'F', L4>
               ifnot op5 'P', L5>
                 ifnot op6 'D', L6>                           ; SHUFPD
                 ;   01100110:00001111:11000110:11 xmmreg1 xmmreg2:imm8 (0/255)
                    ToOpcode 001100110 | mov op1 0011000110 | jmp XMMmemXMMimm3
L6:              ifnot op6 'S', L6>                           ; SHUFPS
                   mov op1 0011000110 | jmp XMMmemXMMimmFF
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'Q', L2>
           ifnot op3 'R', L3>
             ifnot op4 'T', L4>
               ifnot op5 'S', L5>
                 ifnot op6 'D', L6>                       ; SQRTSD
                     ToOpcode 0011110010 | jmp L7>
L6:              IfNot op6 'S', L6>                       ; SQRTSS
                     ToOpcode 0F3 | jmp L7>
L6:              BadMnemonic
L5:            ifnot op5 'P', L5>
                 ifnot op6 'D', L6>                       ; SQRTPD
                     ToOpcode 001100110 | jmp L7>
L6:              ifnot op6 'S', L6>                       ; SQRTPS
L7:                  mov op1 001010001 | jmp XMMmemXMM
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'W', L1>
         ifnot op2 'B', L2>
           ifnot op3 'I', L3>
             ifnot op4 'N', L4>
               ifnot op5 'V', L5>
                 ifnot op6 'D', L6>                           ; WBINVD
                   mov op1 00_1111,  op2 00_1001 | jmp op_op
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ;BadMnemonic
L1:    BadMnemonic
 ________________________________________________________________________________________

SevenLetters:        On op8 > Separators,  jmp heightLetters
       ifnot op1 'C', L1>>
         ifnot op2 'L', L2>
           ifnot op3 'F', L3>
             ifnot op4 'L', L4>
               ifnot op5 'U', L5>
                 ifnot op6 'S', L6>
                   ifnot op7 'H', L7>                      ; CLFLUSH
                       Parms 1
                       On B$FirstGender <> mem, BadOperand
                       On B$FirstOperandwbit <> ByteSize, BadOperandSize
                       ToOpcode 00001111 | mov op1 0010101110, op2 00_111_000 | jmp op_modRm

; CLFLUSH: intel doc says one time "00001111:10101110:mod r/m"
; and another time: 0F AE /7 mem8

L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic

L2:      ifnot op2 'M', L2>
           ifnot op3 'P', L3>
             ifnot op4 'X', L4>
               ifnot op5 'C', L5>
                 ifnot op6 'H', L6>
                   ifnot op7 'G', L7>                      ; CMPXCHG
                     mov op1 00_1111,  op2 00_1011_0000
                 ;    cmp B$SecondReg RegEax | jne L0         ; ???????????????
                 ;    cmp B$SecondOperandWbit DoubleSize
                  ;          jne CMPXCHG8  ; ???????????????????
                       ifnot B$Operands RegToReg, L0>
                         mov op3 00_1100_0000 | jmp op_w_reg2reg1
L0:                    ifnot B$Operands RegToMem, L9>
                         jmp op_w_modReg2Rm
L9:                    ifnot B$Operands MemToReg, L8>    ; ???????
                         jmp op_w_modReg1Rm
L8:                  BadOperand
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'L', L1>
         ifnot op2 'D', L2>
           ifnot op3 'M', L3>
             ifnot op4 'X', L4>
               ifnot op5 'C', L5>
                 ifnot op6 'S', L6>
                   ifnot op7 'R', L7>                               ; LDMXCSR
                     ifnot B$FirstGender mem, L8>
                       ifnot B$FirstOperandwbit DoubleSize, L9>
                         ToOpcode 0F | mov op1 0AE, op2 00_010_000 | jmp op_ModRm
L9:                    error D$OperandSizePtr
L8:                  BadOperand
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:       BadMnemonic
L1:    ifnot op1 'M', L1>
         ifnot op2 'O', L2>
           ifnot op3 'N', L3>
             ifnot op4 'I', L4>
               ifnot op5 'T', L5>
                 ifnot op6 'O', L6>
                   ifnot op7 'R', L7>                   ; MONITOR
                     ToOpcode 0F, 01, 0C8 | ret
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:       BadMnemonic
L1:    ifnot op1 'P', L1>>
         ifnot op2 'A', L2>
           ifnot op3 'D', L3>
             ifnot op4 'D', L4>
               ifnot op5 'U', L5>
                 ifnot op6 'S', L6>
                   cmp op7 'B' | je L8>
                   cmp op7 'W' | jne L7>                ; PADDUSB/W
L8:                  mov cl op7 | mov op1 00_11011100
                        jmp gg2
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          BadMnemonic
L3:        ifnot op3 'V', L3>
             ifnot op4 'G', L4>
               ifnot op5 'U', L5>
                 ifnot op6 'S', L6>
                   ifnot op7 'B', L7>                   ; PAVGUSB
                       mov op1 0BF | jmp mm3D
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:        ifnot op2 'C', L2>>
             ifnot op3 'M', L3>>
               ifnot op4 'P', L4>>
                 ifnot op5 'E', L5>
                   ifnot op6 'Q', L6>
                     cmp op7 'B' | je L8>
                     cmp op7 'W' | je L8>
                     cmp op7 'D' | jne L7>                     ; PCMPEQB/W/D
L8:                    mov cl op7 | mov op1 00_01110100
                         jmp gg2
L7:                  ;BadMnemonic
L6:                ;BadMnemonic
L5:                ifnot op5 'G', L5>
                     ifnot op6 'T', L6>
                       cmp op7 'B' | je L8>
                       cmp op7 'W' | je L8>
                       cmp op7 'D' | jne L7>                    ; PCMPGTB/W/D
L8:                      mov cl op7 | mov op1 00_01100100
                             jmp gg2
L7:                    ;BadMnemonic
L6:                  ;BadMnemonic
L5:               ;BadMnemonic
L4:             ;BadMnemonic
L3:          BadMnemonic
L2:        ifnot op2 'F', L2>
             ifnot op3 'C', L3>
               ifnot op4 'M', L4>
                 ifnot op5 'P', L5>
                   ifnot op6 'E', L6>
                     ifnot op7 'Q', L7>    ; PFCMPEQ
                         mov op1 0B0 | jmp mm3D
L7:                  BadMnemonic
L6:                ifnot op6 'G', L6>
                     ifnot op7 'E', L7>    ; PFCMPGE
                         mov op1 090 | jmp mm3D
L7:                  ifnot op7 'T', L7>    ; PFCMPGT
                         mov op1 0A0 | jmp mm3D
L5:               ;BadMnemonic
L4:             BadMnemonic
L3:          ifnot op3 'R', L3>
               ifnot op4 'S', L4>
                 ifnot op5 'Q', L5>
                   ifnot op6 'R', L6>
                     ifnot op7 'T', L7>    ; PFRSQRT
                         mov op1 097 | jmp mm3D
L7:
L6:
L5:
L4:
L3:          BadMnemonic
L2:        ifnot op2 'M', L2>>
             ifnot op3 'A', L3>
               ifnot op4 'D', L4>
                 ifnot op5 'D', L5>
                   ifnot op6 'W', L6>
                     ifnot op7 'D', L7>                      ; PMADDWD
                        mov op1 0F5
                        If B$FirstRegGender = XmmReg
                            ToOpcode 066 | jmp XmmMemXmm
                        Else_If B$FirstRegGender = mmReg
                            jmp mmTwo
                        End_If
L7: BadMnemonic
L6:
L5:
L4:
L3:          ifnot op3 'U', L3>
               ifnot op4 'L', L4>
                 ifnot op5 'H', L5>
                   ifnot op6 'R', L6>
                     ifnot op7 'W', L7>                      ; PMULHRW
                         mov op1 0B7 | jmp mm3D
L7: BadMnemonic
L6:                ifnot op6 'U', L6>
                     ifnot op7 'W', L7>                      ; PMULHUW
                         mov op1 0011100100 | jmp OQregMemToReg
L6:     ;BadMnemonic
L7: BadMnemonic
L5:              ifnot op5 'U', L5>
                   ifnot op6 'D', L6>
                     ifnot op7 'Q', L7>                      ; PMULUDQ
                         mov op1 0F4 | jmp OQRegMemToReg
L7:
L6:
L5:
L4:
L3:          BadMnemonic
L2:        ifnot op2 'S', L2>
             ifnot op3 'H', L3>
               ifnot op4 'U', L4>
                 ifnot op5 'F', L5>
                      cmp op7 'W' | jne L7>                      ; PSHUFLW
                   If op6 = 'H'                      ; PSHUFHW
                       ToOpcode 0011110011 | jmp P0>
                   End_If
                   ifnot op6 'L', L6>
                       ToOpcode 0011110010
P0:                    mov op1 001110000 | jmp XmmMemXmmImm3
L3:          ifnot op3 'U', L3>
               ifnot op4 'B', L4>
                 ifnot op5 'U', L5>
                   ifnot op6 'S', L6>
                     cmp op7 'B' | je L8>
                     cmp op7 'W' | jne L7>                      ; PSUBUSB/W
L8:                    mov cl op7 | mov op1 00_11011000 | jmp gg2
L7:                  ;BadMnemonic
L6:                ;BadMnemonic
L5:              ;BadMnemonic
L4:            ;BadMnemonic
L3:          BadMnemonic
L2:         ifnot op2 'U', L2>
              ifnot op3 'N', L3>
                ifnot op4 'P', L4>
                  ifnot op5 'C', L5>
                    ifnot op6 'K', L6>
                      ifnot op7 'H', L7>                        ; PUNPCKH/L
                        mov cl, 'B' | mov op1 00_01101000 | jmp gg2
L7:                   ifnot op7 'L', L7>
                        mov cl, 'B' | mov op1 00_01100000 | jmp gg2
L7:                   ;BadMnemonic
L6:                 ;BadMnemonic
L5:               ;BadMnemonic
L4:             ;BadMnemonic
L3:           ;BadMnemonic
L2:       BadMnemonic
L1:    ifnot op1 'R', L1>
         ifnot op2 'S', L2>
           ifnot op3 'Q', L3>
             ifnot op4 'R', L4>
               ifnot op5 'T', L5>
                 ifnot op6 'S', L6>
                   ToOpcode 0011110011 | jmp L7>     ; RSQRTSS
L6:              ifnot op6 'P', L6>
L7:                ifnot op7 'S', L7>                ; RSQRTPS
                      mov op1 001010010 | jmp XMMmemXMM
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'S', L1>>
         ifnot op2 'Y', L2>
           ifnot op3 'S', L3>
             ifnot op4 'E', L4>
               ifnot op5 'X', L5>
                 ifnot op6 'I', L6>
                   ifnot op7 'T', L7>                ;  SYSEXIT (no use in win Apps)
                       parms 0
                       mov al 0F | stosb | mov al 035 | stosb | ret
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:      ifnot op2 'T', L2>
           ifnot op3 'M', L3>
             ifnot op4 'X', L4>
               ifnot op5 'C', L5>
                 ifnot op6 'S', L6>
                   ifnot op7 'R', L7>                ;  STMXCSR
                       parms 1
                       On B$FirstGender <> mem, BadOperand  ; xmmmemxmm
                       On B$FirstOperandWbit <> DoubleSize, BadOperandSize
                       ToOpcode 0F, 0AE
                       mov al 00_011_000 | or al B$ModBits | or al B$RmBits | LastOpcode al
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ;BadMnemonic
L1:    ifnot op1 'U', L1>
         ifnot op2 'C', L2>
           ifnot op3 'O', L3>
             ifnot op4 'M', L4>
               ifnot op5 'I', L5>
                 ifnot op6 'S', L6>
                   ifnot op7 'D', L7>                ;  UCOMISD
                       ToOpcode 001100110 | jmp L8>
L7:                ifnot op7 'S', L7>                ;  UCOMISS
L8:                   mov op1 00101110 | jmp XMMmemXMM
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ;BadMnemonic
L1:    BadMnemonic


 _________________________________________________________________________________________


heightLetters:        On B$esi+8 > Separators,  jmp NineLetters

L1:  ifnot op1 'A', L1>>
       ifnot op2 'D', L2>>
         ifnot op3 'D', L3>>
           ifnot op4 'S', L4>>
             ifnot op5 'U', L5>
               ifnot op6 'B', L6>
                 ifnot op7 'P', L7>
                   ifnot op8 'D', L8>   ; ADDSUBPD 66,0F,D0,/r ADDSUBPS xmm1, xmm2/m128
                     ToOpcode 066 | mov Op1 0D0 | jmp XmmMemXmm
L8:                ifnot op8 'S', L8>   ; ADDSUBPS F2,0F,D0,/r ADDSUBPD xmm1, xmm2/m128
                     ToOpcode 0F2 | mov Op1 0D0 | jmp XmmMemXmm
L8:                ;BadMnemonic
L8:              ;BadMnemonic
L7:            ;BadMnemonic
L6:          ;BadMnemonic
L5:        ;BadMnemonic
L4:      ;BadMnemonic
L3:    ;BadMnemonic
L2:   BadMnemonic
L1:  ifnot op1 'C', L1>>
       ifnot op2 'V', L2>>
         ifnot op3 'T', L3>>
           ifnot op4 'D', L4>>
             ifnot op5 'Q', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'P', L7>
                   ifnot op8 'D', L8>                 ; CVTDQ2PD
                     ToOpcode 0011110011 | mov op1 0011100110 | jmp XMMmemXMM
L8:                ifnot op8 'S', L8>                 ; CVTDQ2PS
                     mov op1 001011011 | jmp XMMmemXMM
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            ;BadMnemonic
L5:          BadMnemonic
L4:        ifnot op4 'P', L4>>
             ifnot op5 'D', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'D', L7>
                   ifnot op8 'Q', L8>                 ; CVTPD2DQ
                     ToOpcode 0011110010 | mov op1 0011100110 | jmp XMMmemXMM
L8:                BadMnemonic
L7:              ifnot op7 'P', L7>
                   ifnot op8 'I', L8>                 ; CVTPD2PI
                     ToOpcode 001100110 | mov op1 00101101 | jmp MMXmemXMM
L8:                ifnot op8 'S', L8>                 ; CVTPD2PS
                     ToOpcode 001100110 | mov op1 001011010 | jmp MMXmemXMM
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            BadMnemonic
L5:          ifnot op5 'I', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'P', L7>
                   ifnot op8 'D', L8>                 ; CVTPI2PD
                       ToOpcode 001100110 | jmp L9>
L8:                ifnot op8 'S', L8>                 ;  CVTPI2PS
L9:                    mov op1  00101010 | jmp XMMmemXMM
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            BadMnemonic
L5:          ifnot op5 'S', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'D', L7>
                   ifnot op8 'Q', L8>                 ;  CVTPS2DQ
                     ToOpcode 066 | mov op1 05B | jmp XMMmemXMM
L8:                BadMnemonic
L7:              ifnot op7 'P', L7>
                   ifnot op8 'D', L8>                 ;  CVTPS2PD
                      mov op1 001011010 | jmp XMMmemXMM
L8:                ifnot op8 'I', L8>                 ;  CVTPS2PI
                       mov op1  00101101 | jmp MMXmemXMM
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            ;BadMnemonic
L5:          BadMnemonic
L4:        ifnot op4 'S', L4>>
             ifnot op5 'D', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'S', L7>
                   ifnot op8 'S', L8>                 ;  CVTSD2SS
                       ToOpcode 0011110010 | mov op1 001011010 | jmp XMMmemXMM
L8:                ifnot op8 'I', L8>                 ;  CVTSD2SI
                       mov op1 02D | jmp LowXMMtoDwordWithF2
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            BadMnemonic
L5:          ifnot op5 'I', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'S', L7>
                   ifnot op8 'D', L8>                 ;  CVTSI2SD
                       mov op1 02A | jmp DwordToLowXMMWithF2
L8:                ifnot op8 'S', L8>                 ;  CVTSI2SS
L9:                    mov op1 00101010 | jmp DwordToLowXMM
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            BadMnemonic
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            BadMnemonic
L5:          ifnot op5 'S', L5>
               ifnot op6 '2', L6>
                 ifnot op7 'S', L7>
                   ifnot op8 'D', L8>                 ;  CVTSS2SD
                       ToOpcode 0011110011 | mov op1 001011010 | jmp XMMmemXMM
L8:                ifnot op8 'I', L8>                 ;  CVTSS2SI
L9:                    mov op1 00101101 | jmp LowXMMtoDword
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            ;BadMnemonic
L5:          ;BadMnemonic
L4:       ;BadMnemonic
L3:     ;BadMnemonic
L2:   BadMnemonic
L1:  ifnot op1 'M', L1>
       ifnot op2 'A', L2>
         ifnot op3 'S', L3>
           ifnot op4 'K', L4>
             ifnot op5 'M', L5>
               ifnot op6 'O', L6>
                 ifnot op7 'V', L7>
                   ifnot op8 'Q', L8>                 ; MASKMOVQ
                       mov op1 0011110111 | jmp mmOne
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            ;BadMnemonic
L5:          ;BadMnemonic
L4:       ;BadMnemonic
L3:     ;BadMnemonic
L2:   BadMnemonic
L1:  ifnot op1 'P', L1>>
       ifnot op2 'A', L2>>
         ifnot op3 'C', L3>>
           ifnot op4 'K', L4>>
             ifnot op5 'S', L5>>
               ifnot op6 'S', L6>>
                 ifnot op7 'D', L7>
                   ifnot op8 'W', L8>                 ; PACKSSDW
                       .If B$FirstRegGender = XmmReg
                           ToOpcode 001100110 | mov B$FirstRegGender mmReg
                           If B$Operands = RegToReg
                               On B$SecondRegGender = XmmReg, mov B$SecondRegGender mmReg
                           End_If
                       .End_If
                       mov op1 00_01101011 | jmp mmTwo
L8:                BadMnemonic
L7:              ifnot op7 'W', L7>
                   ifnot op8 'B', L8>                 ; PACKSSWB
                       .If B$FirstRegGender = XmmReg
                           ToOpcode 001100110 | mov B$FirstRegGender mmReg
                           If B$Operands = RegToReg
                               On B$SecondRegGender = XmmReg, mov B$SecondRegGender mmReg
                           End_If
                       .End_If
                     mov op1 00_01100011 | jmp mmTwo
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            BadMnemonic
L5:          ifnot op5 'U', L5>
               ifnot op6 'S', L6>
                 ifnot op7 'W', L7>
                   ifnot op8 'B', L8>                 ; PACKUSWB
                       .If B$FirstRegGender = XmmReg
                           ToOpcode 001100110 | mov B$FirstRegGender mmReg
                           If B$Operands = RegToReg
                               On B$SecondRegGender = XmmReg, mov B$SecondRegGender mmReg
                           End_If
                       .End_If
                       mov op1 00_01100111 | jmp mmTwo
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            ;BadMnemonic
L5:          ;BadMnemonic
L4:        ;BadMnemonic
L3:      BadMnemonic
L2:      ifnot op2 'M', L2>
           ifnot op3 'O', L3>
             ifnot op4 'V', L4>
               ifnot op5 'M', L4>
                 ifnot op6 'S', L4>
                   ifnot op7 'K', L4>
                     ifnot op8 'B', L4>                   ; PMOVMSKB
                         mov op1 0D7 | jmp OQreg32Reg
L4: BadMnemonic
L3:        ifnot op3 'U', L3>
             ifnot op4 'L', L4>>
               ifnot op5 'L', L4>>
                 ifnot op6 'U', L4>>
                   ifnot op7 'D', L4>>
                     ifnot op8 'Q', L4>>                   ; PMULLUDQ
                         mov op1 0011110100 | jmp OQregMemToReg
L3: BadMnemonic
L2:      ifnot op2 'R', L2>
           ifnot op3 'E', L3>
             ifnot op4 'F', L4>
               ifnot op5 'E', L5>
                 ifnot op6 'T', L6>
                   ifnot op7 'C', L7>
                     ifnot op8 'H', L8>                   ; PREFETCH (AMD).
                         cmp B$ParametersNumber 1 | jne L9>
                         cmp B$FirstGender mem | jne L9>
                         cmp B$FirstOperandwBit ByteSize | jne L9>
                       ;  cmp B$SIBinside &TRUE | je L9>
                       ;  cmp B$EregInside &TRUE | je L9>
                             mov al 0F | stosb | mov al 0D | stosb
                             mov al B$ModBits | or al B$RmBits | stosb | ret
L9: error D$PrefetchMemPtr
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:            ;BadMnemonic
L5:          ;BadMnemonic
L4:        ;BadMnemonic
L3: BadMnemonic
L2:    ifnot op2 'U', L2>
         ifnot op3 'N', L3>
           ifnot op4 'P', L4>
             ifnot op5 'C', L5>
               ifnot op6 'K', L6>
                 ifnot op7 'H', L7>
                   cmp op8 'B' | je L9>
                   cmp op8 'W' | je L9>
                   cmp op8 'D' | jne L8>                         ; PUNPCKHB/W/D
PUNPCKH_one:
L9:                  mov cl op8
                     mov op1 00_01101000 | jmp gg2
L8:                BadMnemonic
L7:              ifnot op7 'L', L7>
                   cmp op8 'B' | je L9>
                   cmp op8 'W' | je L9>
                   cmp op8 'D' | jne L8>                         ; PUNPCKLB/W/
PUNPCKL_one:
L9:                  mov cl op8
                     mov op1 00_01100000 | jmp gg2
L8:                ;BadMnemonic
L7:              ;BadMnemonic
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:    ifnot op2 'F', L2>
         ifnot op3 'R', L3>
           ifnot op4 'C', L4>
             ifnot op5 'P', L5>
               ifnot op6 'I', L6>
                 ifnot op7 'T', L7>
                   ifnot op8 '1', L8>           ; PFRCPIT1
                       mov op1 0A6 | jmp mm3D
L8:                ifnot op8 '2', L8>           ; PFRCPIT2
                       mov op1 0B6 | jmp mm3D
L8:                  ;BadMnemonic
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:           BadMnemonic
L4:        ifnot op4 'S', L4>
             ifnot op5 'Q', L5>
               ifnot op6 'I', L6>
                 ifnot op7 'T', L7>
                   ifnot op8 '1', L8>           ; PFRSQIT1
                       mov op1 0A7 | jmp mm3D
L8:                  ;BadMnemonic
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'U', L1>
         ifnot op2 'N', L2>
           ifnot op3 'P', L3>
             ifnot op4 'C', L4>
               ifnot op5 'K', L5>
                 ifnot op6 'H', L6>
                   ifnot op7 'P', L7>
                     ifnot op8 'D', L8>                             ; UNPCKHPD
                         ToOpcode 001100110 | jmp L9>
L8:                  ifnot op8 'S', L8>                             ; UNPCKHPS
L9:                      mov op1 0010101 | jmp XMMmemXMM
L8:                  ;BadMnemonic
L7:                BadMnemonic
L6:              ifnot op6 'L', L6>
                   ifnot op7 'P', L7>
                     ifnot op8 'D', L8>                             ; UNPCKLPD
                         ToOpcode 001100110 | jmp L9>
L8:                  ifnot op8 'S', L8>                             ; UNPCKLPS
L9:                      mov op1 0010100 | jmp XMMmemXMM
L8:                  ;BadMnemonic
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      BadMnemonic
L1:    ifnot op1 'S', L1>
         ifnot op2 'Y', L2>
           ifnot op3 'S', L3>
             ifnot op4 'E', L4>
               ifnot op5 'N', L5>
                 ifnot op6 'T', L6>
                   IFNOT op7 'E', L7>
                     ifnot op8 'R', L8>                             ; SYSENTER
                       parms 0
                       mov al 0F | stosb | mov al 034 | stosb | ret
L8:                  ;BadMnemonic
L7:                ;BadMnemonic
L6:              ;BadMnemonic
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:      ;BadMnemonic
L1:    BadMnemonic

____________________________________________________________________________________________


NineLetters:   cmp B$esi+9 Separators | ja TenLetters

       ifnot op1 'C', L1>>
         ifnot op2 'M', L2>
           ifnot op3 'P', L3>>
             ifnot op4 'X', L3>>
               ifnot op5 'C', L3>>
                 ifnot op6 'H', L3>>
                   ifnot op7 'G', L3>>
                     ifnot op8 '8', L3>>
                       ifnot B$esi+8 'B', L3>>             ; CMPXCHG8B
                         On B$FirstOperandwbit <> QuadSize, error D$OperandSizePtr
                         mov op1 0F, op2 0C7, op3 00_001_000
                         jmp Op_Op_ModRm

L0:                        BadOperand
; ...............
L2:      ifnot op2 'V', L2>
           ifnot op3 'T', L3>
             ifnot op4 'T', L3>
               ifnot op5 'P', L5>
                 ifnot op6 'D', L6>
                   ifnot op7 '2', L3>
                     ifnot op8 'D', L8>
                       ifnot B$esi+8 'Q', L3>             ; CVTTPD2DQ
                           ToOpcode 001100110 | mov op1 0011100110 | jmp XMMmemXMM
L3:                    ifnot B$esi+8 'I', L3>             ; CVTTPD2PI
                          ToOpcode 066 | mov op1 02C | jmp MMXmemXMM
L6:              ifnot op6 'S', L3>
                   ifnot op7 '2', L3>
                     ifnot op8 'D', L8>
                       ifnot B$esi+8 'Q', L3>             ; CVTTPS2DQ
                           ToOpcode 0011110011 | mov op1 001011011 | jmp XMMmemXMM
L8:                  ifnot op8 'P', L3>
                       ifnot B$esi+8 'I', L3>             ; CVTTPS2PI
C1:                      mov op1 00101100 | jmp MMXmemXMM
L2:
L3: BadMnemonic

L5:            ifnot op5 'P', L5>
                 ifnot op6 'S', L3>
                   ifnot op7 '2', L3>
                     ifnot op8 'P', L3>
                       ifnot B$esi+8 'I', L3>             ; CVTTPS2SI
C1:                       mov op1 00101100 | jmp LowXMMtoDword
L5:            ifnot op5 'S', L3>
                 ifnot op6 'D', L5>
                   ifnot op7 '2', L3>
                     ifnot op8 'S', L3>
                       ifnot B$esi+8 'I', L3>             ; CVTTSD2SI
                           mov op1 02C | jmp LowXMMtoDwordWithF2
L5:              ifnot op6 'S', L3>
                   ifnot op7 '2', L3>
                     ifnot op8 'S', L3>
                       ifnot B$esi+8 'I', L3>             ; CVTTSS2SI r32, xmm/m32
                           mov op1 02C | jmp LowXMMtoDword

L3: BadMnemonic

L1:    ifnot op1 'P', L3>>
         ifnot op2 'R', L2>>
           ifnot op3 'E', L3>>
             ifnot op4 'F', L3>>
               ifnot op5 'E', L3>>
                 ifnot op6 'T', L3>>
                   ifnot op7 'C', L3>>
                     ifnot op8 'H', L3>>                   ; PREFETCH0/1/2 (Intel).
                       If B$esi+8 = 'W'
                        ; AMD PREFETCHW:
                          mov al 0F | stosb | mov al 0D | stosb
                          mov al 00_001_000 | or al B$ModBits | or al B$RmBits | stosb | ret
                       End_If
                       mov bl B$esi+8                     ; 'W/0/1/2'
                       inc bl | sub bl '0'                ;    1/2/3
                       cmp bl 3 | ja L3>>                 ; Same as PREFETCHT0/1/2 (alternate).
                       cmp bl 0 | je L3>>
                       cmp B$ParametersNumber 1 | jne L1>
                         cmp B$FirstGender mem | jne L1>
                         cmp B$FirstOperandwBit ByteSize | jne L1>
                       ;  cmp B$SIBinside &TRUE | je L1>
                       ;  cmp B$EregInside &TRUE | je L1>
                             mov al 0F | stosb
                             mov al 018                ; INTEL (0/1/2)
                             stosb
                             mov al bl | shl al 3
                             or al B$ModBits | or al B$RmBits | stosb | ret
L1: error D$PrefetchMemPtr

; PUNPCKH.. / PUNPCKL.. are send to PUNPCKH / L .

L2:     ifnot op2 'U', L3>>
           ifnot op3 'N', L3>>
             ifnot op4 'P', L3>>
               ifnot op5 'C', L3>>
                 ifnot op6 'K', L3>>
                   ifnot op7 'L', L7>
                     If W$esi+7 = 'BW'            ; PUNPCKLBW
                         jmp PUNPCKL_one
                     Else_If W$esi+7 = 'WD'       ; PUNPCKLWD
                         jmp PUNPCKL_one
                     Else_If W$esi+7 = 'DQ'       ; PUNPCKLDQ
                         jmp PUNPCKL_one
                     End_If
                     BadMnemonic
L7:               ifnot op7 'H', L3>
                     If W$esi+7 = 'BW'            ; PUNPCKLBW
                         jmp PUNPCKH_one
                     Else_If W$esi+7 = 'WD'       ; PUNPCKLWD
                         jmp PUNPCKH_one
                     Else_If W$esi+7 = 'DQ'       ; PUNPCKLDQ
                         jmp PUNPCKH_one
                     End_If
L3: BadMnemonic

TenLetters: cmp B$esi+10 Separators | ja ElevenLetters
       ifnot op1 'M', L1>>
         ifnot op2 'A', L3>>
           ifnot op3 'S', L3>>
             ifnot op4 'K', L3>>
               ifnot op5 'M', L3>>
                 ifnot op6 'O', L3>>
                   ifnot op7 'V', L3>>
                     ifnot op8 'D', L3>>
                       ifnot B$esi+8 'Q', L3>>
                         ifnot B$esi+9 'U', L3>>   ; MASKMOVDQU
                             ToOpcode 001100110 | mov op1 0011110111 | jmp XmmXmm
L3: BadMnemonic

L1:    ifnot op1 'P', L3>>
         ifnot op2 'R', L2>>
           ifnot op3 'E', L3>>
             ifnot op4 'F', L3>>
               ifnot op5 'E', L3>>
                 ifnot op6 'T', L3>>
                   ifnot op7 'C', L3>>
                     ifnot op8 'H', L3>>                   ; PREFETCHT0/1/2 (Intel).
                       ifnot B$esi+8 'T', L3>>            ; Same as PREFETCH0/1/2
                       mov bl B$esi+9                     ; 'W/0/1/2'
                       inc bl | sub bl '0'                ;    1/2/3
                       cmp bl 3 | ja L3>>
                       cmp bl 0 | je L3>>
                       cmp B$ParametersNumber 1 | jne L1>
                         cmp B$FirstGender mem | jne L1>
                         cmp B$FirstOperandwBit ByteSize | jne L1>
                       ;  cmp B$SIBinside &TRUE | je L1>
                       ;  cmp B$EregInside &TRUE | je L1>
                             mov al 0F | stosb
                             mov al 018                ; INTEL (0/1/2)
                             stosb
                             mov al bl | shl al 3
                             or al B$ModBits | or al B$RmBits | stosb | ret
L1: error D$PrefetchMemPtr

L2:      ifnot op2 'U', L3>>
           ifnot op3 'N', L3>>
             ifnot op4 'P', L3>>
               ifnot op5 'C', L3>>
                 ifnot op6 'K', L3>>
                   ifnot op7 'H', L7>>
                     mov op1 0001101101
L8:                  ifnot op8 'Q', L3>>
                       ifnot B$esi+8 'D', L3>>
                         ifnot B$esi+9 'Q', L3>>  ; PUNPCKHQDQ
                             ToOpcode 066 | jmp XmmMemXmm
L7: mov op1 001101100 | jmp L8<                    ; PUNPCKLQDQ

L3: BadMnemonic

ElevenLetters: cmp B$esi+11 Separators | ja TwelveLetters

L1:    ifnot op1 'P', L3>>
         ifnot op2 'R', L3>>
           ifnot op3 'E', L3>>
             ifnot op4 'F', L3>>
               ifnot op5 'E', L3>>
                 ifnot op6 'T', L3>>
                   ifnot op7 'C', L3>>
                     ifnot op8 'H', L3>>                   ; PREFETCHNTA
                       ifnot B$esi+8 'N', L3>>
                         ifnot B$esi+9 'T', L3>>
                           ifnot B$esi+10 'A', L3>>
                             cmp B$ParametersNumber 1 | jne L1>
                               cmp B$FirstGender mem | jne L1>
                               cmp B$FirstOperandwBit ByteSize | jne L1>
                             ;  cmp B$SIBinside &TRUE | je L1>
                             ;  cmp B$EregInside &TRUE | je L1>
                                   mov al 0F | stosb | mov al 018 | stosb
                                   mov al 0
                                   or al B$ModBits | or al B$RmBits | stosb | ret
L1: error D$PrefetchMemPtr
L3: BadMnemonic


TwelveLetters: BadMnemonic
 _________________________________________________________________________________________

; 'J'  >>>  all 'J'  first letter here
;
;  Special treatment for all 'tttn' opcodes and all '.MOV...' instructions
 _________________________________________________________________________________________


J_Branching:
    If op1 = 'U'
        ToOpcode 02E
    Else_If op1 = 'L'
        ToOpcode 03E
    End_If
    add esi 4 | call Store8cars

Letter_J:        On op2 = 'M',  jmp JMPmnemo

         ifnot op2 'C', L2>
           ifnot op3 'X', L1>
             ifnot op4 'Z', L1>                     ; JCXZ
               cmp op5 Separators | ja L1>
                 ToOpcode 067 | jmp X0>

L2:      ifnot op2 'E', L1>
           ifnot op3 'C', L1>
             ifnot op4 'X', L1>
               ifnot op5 'Z', L1>                   ; JECXZ
                 cmp op6 Separators | ja L1>
X0:                cmp B$LocalSize DownShort | je R1>
                   cmp B$LocalSize UpShort | jne R0>
R1:                  mov op1 00_1110_0011 | jmp op_dis8
R0:                error D$NoPlainLabelForJECXPtr


L1:      push esi
           inc esi
           call SearchFortttnBits
         pop esi
      ;   call Store8Cars

; JCC:
    On B$FirstGender <> Dis, BadOperand

    cmp B$LocalSize DownShort | je L1>
    cmp B$LocalSize UpShort | jne L2>
L1:   mov op1 00_0111_0000 | or op1 B$tttnBits | jmp op_dis8
L2: cmp B$LocalSize DownLong | je L3>
    cmp B$LocalSize Uplong | jne L4>
L3:   mov D$Relative RelativeFlag
      On B$ShortenJumpsWanted = &TRUE, call SetShortenJmpFlag
      mov op1 00_1111,  op2 00_1000_0000 | or op2 B$tttnBits | jmp op_op_dis
L4: cmp B$LabelInside &TRUE | je L3<

    BadOperand


JMPmnemo:
            ifnot op3 'P', L9>>
              cmp op4 Separators | ja L9>>
              mov D$Relative RelativeFlag
              cmp B$LocalSize DownShort | Je L4>
              cmp B$LocalSize UpShort | jne L5>

              ;On B$ShortenJumpsWanted = &TRUE, call SetShortenJmpFlag

L4:           mov op1 00_1110_1011 | jmp op_dis8     ; Short
L5:           cmp B$FirstGender dis | jne L6>        ; Long
                cmp B$LocalSize DownLong | je K0>
                cmp B$LocalSize UpLong | jne K1>
K0:                  On B$ShortenJumpsWanted = &TRUE, call SetJMPShortenJmpFlag
K1:                  mov op1 00_1110_1001 | jmp op_dis
L6:           cmp B$FirstGender Reg | jne L7>
                mov op1 00_1111_1111,  op2 00_11_100_000 | jmp op_reg1
L7:           ifnot B$FirstGender mem, L8>
                mov D$Relative 0
                mov op1 00_1111_1111,  op2 00_100_000 | jmp op_modRm
L8:           BadOperand
L9:    BadMnemonic

 ________________________________________________________________________________________

; MOVs
 ________________________________________________________________________________________

; (segments registers are over 00111)

MOVinstructions:                                        ; killing exceptions !!!
                 On op4 <> Space,  jmp MOVsMnemo

      ifnot B$Operands RegToreg, L1>>
        ifnot B$SecondRegGender sReg, L2>               ; general purpose? yes > L2
          On B$FirstRegGender <> Reg,  error D$GPregisterPtr
          GPreg1
          mov op1 00_1000_1100,  op2 00_1100_0000
          or op2 B$SecondReg | or op2 B$FirstReg | jmp op_op_P2     ; reg2 is an sreg
L2:     ifnot B$FirstRegGender sReg, L2>               ; general purpose? yes > L2
          GPreg2
          ifnot B$FirstReg RegSS, L3>
            mov op1 00_1000_1110,  op2 00_1100_0000           ; reg1 is an RegSS
            or op2 B$FirstReg | or op2 B$SecondReg | jmp op_op_P2
L3:       mov op1 00_1000_1110,  op2 00_1100_0000             ; reg1 is an sreg
          or op2 B$FirstReg | or op2 B$SecondReg | jmp op_op_P2

L2:   ifnot B$SecondRegGender dReg, L2>               ; Debug Register2?
        On B$FirstRegGender <> Reg,  error D$GPregisterPtr
        GPreg1
        ToOpcode 0F, 0010_0001  ; 0000 1111 : 0010 0001 : 11 eee reg
        mov al B$SecondReg | shl al 3 | or al B$FirstReg | or al 0011_000_000
        LastOpcode al

L2:   ifnot B$FirstRegGender dReg, L2>               ; Debug Register1?
        GPreg2
        ToOpcode 0F, 0010_0011  ; 0000 1111 : 0010 0011 : 11 eee reg
        mov al B$FirstReg | shl al 3 | or al B$SecondReg | or al 0011_000_000
        LastOpcode al

L2:   ifnot B$SecondRegGender cReg, L2>               ; Control Register2?
        On B$FirstRegGender <> Reg,  error D$GPregisterPtr
        GPreg1
        ToOpcode 0F, 0010_0000  ; 0000 1111 : 0010 0000 : 11 eee reg
        mov al B$SecondReg | shl al 3 | or al B$FirstReg | or al 0011_000_000
        LastOpcode al

L2:   ifnot B$FirstRegGender cReg, L2>               ; Control Register1?
        GPreg2
        ToOpcode 0F, 0010_0010  ; 0000 1111 : 0010 0010 : 11 eee reg
        mov al B$FirstReg | shl al 3 | or al B$SecondReg | or al 0011_000_000
        LastOpcode al

L2:     mov op1 00_1000_1010,  op2 00_1100_0000 | jmp w_reg1reg2 ; 1/2 general P.

L1:   ifnot B$Operands MemToReg, L1>
        ifnot B$FirstRegGender sReg, L2>
          ifnot B$FirstReg RegSS, L3>
            mov op1 00_1000_1110
              mov op2 B$FirstReg | jmp op_modRm_P2
L3:       mov op1 00_1000_1110,  op2 B$FirstReg | jmp op_modRm_P2
L2:     GPreg1
        cmp B$FirstReg RegEAX | jne L3>
          cmp B$ModBits 0 | jne L3>
            cmp B$RmBits 00101 | jne L3>
              mov op1 00_1010_0000 | jmp w_dis  ;!!!!!!!!! simple label only !!!!!!!!

L3:     mov op1 00_1000_1010 | jmp w_modReg1Rm

L1:   ifnot B$Operands RegToMem, L1>
        ifnot B$SecondRegGender sReg, L2>
          mov op1 00_1000_1100,  op2 B$SecondReg | jmp op_modRm_P2
L2:    GPreg2
       cmp B$SecondReg RegEAX | jne L3>
          cmp B$ModBits 0 | jne L3>
            cmp B$RmBits 00101 | jne L3>
               mov op1 00_1010_0010 | jmp w_dis  ;!!!!!!!!! simple label only !!!!!!!!

L3:     mov op1 00_1000_1000 | jmp w_modreg2Rm

L1:  ifnot B$Operands ImmToreg, L1>
       ;mov op1 00_1100_0110,  op2 00_1100_0000 | jmp w_reg1_imm ; alternate shorter >
        mov op1 B$wBit | shl op1 3 | or op1 00_1011_0000 | jmp reg_in_op_imm
L1:  ifnot B$Operands ImmToMem, L1>
        On B$FirstOperandwbit >= QuadSize, jmp L1>

        mov op1 00_1100_0110,  op2 0 | jmp w_modRm_imm

L1:  BadOperand


;MOV – Move to/from Control Registers
;CR0 from register               0000 1111 : 0010 0010 : 11 000 reg
;CR2 from register               0000 1111 : 0010 0010 : 11 010 reg
;CR3 from register               0000 1111 : 0010 0010 : 11 011 reg
;CR4 from register               0000 1111 : 0010 0010 : 11 100 reg
;register from CR0-CR4           0000 1111 : 0010 0000 : 11 eee reg

;MOV – Move to/from Debug Registers
;DR0-DR3 from register           0000 1111 : 0010 0011 : 11 eee reg
;DR4-DR5 from register           0000 1111 : 0010 0011 : 11 eee reg
;DR6-DR7 from register           0000 1111 : 0010 0011 : 11 eee reg
;register from DR6-DR7           0000 1111 : 0010 0001 : 11 eee reg
;register from DR4-DR5           0000 1111 : 0010 0001 : 11 eee reg
;register from DR0-DR3           0000 1111 : 0010 0001 : 11 eee reg


MOVsMnemo:
    On op5 > Separators, jmp L0>>
      ifnot op4 'D', L4>                                ; MOVD
        If B$FirstGender = mem
            On B$FirstOperandwBit <> DoubleSize, BadOperandSize
        Else_If B$SecondGender = mem
            On B$SecondOperandwBit <> DoubleSize, BadOperandSize
        End_If
          mov op1 00_01101110
          cmp B$FirstRegGender XmmReg | je XmmFour
          cmp B$SecondRegGender XmmReg | je XmmFour
          jmp mmFour
L4:   ifnot op4 'Q', L4>                                ; MOVQ ; THE HELL!!!!!!!!!!!!!!
         If B$FirstRegGender = XmmReg
             ToOpcode 0F3 | mov op1 07E | jmp MovqXMMmemXMMmem ;XMMtoFromMem ; MovqXMMmemXMMmem
         Else_If B$SecondRegGender = XmmReg
             ToOpcode 066 | mov op1 0C6 | jmp MovqXMMmemXMMmem; XMMtoFromMem ; MovqXMMmemXMMmem
           ; This 0C6 will be 0D6 by the xor in the 'MovqXMMmemXMMmem' Routine.
           ; This encodage is not fully sure. May be an error in Intel Doc. Not
           ; implemented in NASM...
         Else_If B$Operands = RegToMem
            mov op1 07F | jmp MMregToMem ;mmTwo ;mmFour
         Else
            mov op1 06F | jmp mmTwo ;mmFour
         End_If

L4:   On op4 = 'S',  error D$NotYetMnemoPtr       ; MOVS  (???)

BadMnemonic

L0: On op6 > Separators,  jmp MovSixLetters


L4:   ifnot op4 'S', L4>>
        ifnot op5 'B', L5>                  ; MOVSB
          mov op1 00_1010_0100 | jmp op
L5:     ifnot op5 'W', L5>                  ; MOVSW
          ToOpcode 066
          mov op1 00_1010_0101 | jmp op
L5:     ifnot op5 'D', L5>                  ; MOVSD
          If B$FirstRegGender = XmmReg
            ; down there
          Else_If B$SecondRegGender = XmmReg
            ; down there
          Else
              mov op1 00_0101_00101 | jmp op
          End_If

          ToOpcode 0011110010 | mov op1 00010000 | jmp XMMmemXMMmem

L5:     ifnot op5 'S', L5>                      ; MOVSS (SSE SIMD)
          ToOpcode 0011110011
          mov op1 010 | jmp XMMmem32XMMmem32
L5:     ifnot op5 'X', L5>
          mov op1 00_1111,  op2 00_1011_1110    ; MOVSX
          ifnot B$Operands RegToreg, L6>
            mov op3 00_1100_0000 | jmp op_w_reg1reg2X
L6:       ifnot B$Operands MemToreg, L6>
            jmp op_w_modReg1RmX
L6:       ;BadOperand
L5:     BadMnemonic
L4:     ifnot op4 'Z', L4>                      ; MOVZX
          ifnot op5 'X', L4>
            mov op1 00_1111
            mov op2 00_1011_0110
            ifnot B$Operands RegToReg, L7>
              mov op3 00_1100_0000 | jmp op_w_reg1reg2X
L7:         ifnot B$Operands MemToReg, L7>
              jmp op_w_modReg1RmX
L7:         BadOperand
L6:       ;BadMnemonic
L5:     ;BadMnemonic
L4:   BadMnemonic


MovSixLetters:  On op7 > Separators, jmp MovSevenLetter

      ifnot op4 'A', L4>
        ifnot op5 'P', L5>
          ifnot op6 'D', L6>      ; MOVAPD
              ToOpcode 001100110 | mov op1 00101000 | jmp XMMmemXMMmem
L6:       ifnot op6 'S', L6>      ; MOVAPS
            mov op1 00101000 | jmp XMMmemXMMmem
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'D', L4>
        ifnot op5 'Q', L5>
          ifnot op6 'A', L6>      ; MOVDQA
              ToOpcode 001100110 | mov op1 06F | jmp MovqXMMmemXMMmem
L6:       ifnot op6 'U', L6>      ; MOVDQU
              ToOpcode 0011110011 | mov op1 001101111 | jmp MovqXMMmemXMMmem
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'H', L4>
        ifnot op5 'P', L5>
          ifnot op6 'D', L6>      ; MOVHPD
              ToOpcode 001100110 | mov op1 00010110 | jmp XMMtoFromMem
L6:       ifnot op6 'S', L6>      ; MOVHPS
            mov op1 0010110 | jmp XMMTOFromMem
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'L', L4>
        ifnot op5 'P', L5>
          ifnot op6 'D', L6>      ; MOVLPD
              ToOpcode 001100110 | jmp L7>
L6:       ifnot op6 'S', L6>      ; MOVLPS
L7:           mov op1 0010010 | jmp XMMTOFromMem
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:         ifnot op4 'N', L4>
               ifnot op5 'T', L5>
                 Ifnot op6 'I', L6>                         ; MOVNTI
                     ToOpcode 0F
                     mov op1 0011000011 | jmp op_modReg2Rm
L6:              Ifnot op6 'Q', L6>                         ; MOVNTQ
                     mov op1 0011100111 | jmp MMregToMem
L6:              ;BadMnemonic
L5:            BadMnemonic
L4:   ifnot op4 'U', L4>
        ifnot op5 'P', L5>
          ifnot op6 'D', L6>      ; MOVUPD
            ToOpcode 001100110 | jmp L7>
L6:       ifnot op6 'S', L6>      ; MOVUPS
L7:         mov op1 0010000 | jmp XMMmemXMMmem
L6:       ;BadMnemonic
L5:     ;BadMnemonic
L4:   BadMnemonic


MovSevenLetter: On op8 > Separators, jmp MovHeightLetters
      ifnot op4 'D', L4>
        ifnot op5 'Q', L5>
          ifnot op6 '2', L6>
            ifnot op7 'Q', L7>                   ; MOVDQ2Q
                ToOpcode 0011110010 | mov op1 0011010110 | jmp mmXmm
L7:         ;BadMnemonic
L6:       BadMnemonic
L5:     ifnot op5 'D', L5>
          ifnot op6 'U', L6>
            ifnot op7 'P', L7>                   ; MOVDDUP F2,0F,12,/r MOVDDUP xmm1, xmm2/m64
              ToOPcode 0F2 | mov Op1 012 | jmp XmmMemXmm
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'H', L4>
        ifnot op5 'L', L5>
          ifnot op6 'P', L6>
            ifnot op7 'S', L7>                   ; MOVHLPS
              mov op1 0010010 | jmp XMMXMM
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'L', L4>
        ifnot op5 'H', L5>
          ifnot op6 'P', L6>
            ifnot op7 'S', L7>                   ; MOVLHPS
              mov op1 0010110 | jmp XMMXMM
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'N', L4>
        ifnot op5 'T', L5>
          ifnot op6 'D', L6>
            ifnot op7 'Q', L7>                               ; MOVNTDQ
                ToOpcode 001100110 | mov op1 0011100111 | jmp XMMtoMem
L7:         BadMnemonic
L6:       ifnot op6 'P', L6>
            ifnot op7 'D', L7>                               ; MOVNTPD
                ToOpcode 001100110 | jmp L8>
L7:         ifnot op7 'S', L7>                               ; MOVNTPS
L8:             mov op1 00101011 | jmp XMMtoMem
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     BadMnemonic
L4:   ifnot op4 'Q', L4>
        ifnot op5 '2', L5>
          ifnot op6 'D', L6>
            ifnot op7 'Q', L7>                   ; MOVQ2DQ
                ToOpcode 0011110011 | mov op1 0011010110 | jmp Xmmmm ;XmmXmm mmXmm
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     ;BadMnemonic
L4:   BadMnemonic



MovHeightLetters: On B$esi+8 > Separators, BadMnemonic
      ifnot op4 'M', L4>
        ifnot op5 'S', L5>
          ifnot op6 'K', L6>
            ifnot op7 'P', L7>
              ifnot op8 'D', L8>                     ; MOVMSKPD
                ; 01100110:00001111:01010000:11 r32 xmmreg
                ToOpcode 001100110 | jmp L9>
L8:           ifnot op8 'S', L8>                     ; MOVMSKPS
                ; 00001111:01010000:11 r32 xmmreg    ; (unique)
L9:             ToOpcode 001111, 001010000
                cmp B$Operands RegToReg | jne L9>
                cmp B$FirstRegGender Reg | jne L9>>
                cmp B$SecondRegGender XMMreg | jne L9>>
                On B$FirstOperandwBit <> DoubleSize, BadOperandSize
                mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                LastOpcode al
L9:             BadOperand
L8:           ;BadMnemonic
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     ;BadMnemonic
L4:   ifnot op4 'S', L4>
        ifnot op5 'H', L5>
          ifnot op6 'D', L6>
            ifnot op7 'U', L7>
              ifnot op8 'P', L8>    ; MOVSHDUP: F3,0F,16,/r MOVSHDUP xmm1, xmm2/m128
                ToOpcode 0F3 | mov Op1 016 | jmp XmmMemXmm
L8:           ;BadMnemonic
L7:         ;BadMnemonic
L6:       BadMnemonic
L5:     ifnot op5 'L', L5>
          ifnot op6 'D', L6>
            ifnot op7 'U', L7>
              ifnot op8 'P', L8>    ; MOVSLDUP: F3,0F,12,/r MOVSLDUP xmm1, xmm2/m128
                ToOpcode 0F3 | mov Op1 012 | jmp XmmMemXmm
L8:           ;BadMnemonic
L7:         ;BadMnemonic
L6:       ;BadMnemonic
L5:     ;BadMnemonic
L4:   BadMnemonic



SETinstructions:

    push esi
      add esi 3 | call SearchFortttnBits
    pop esi

    mov op1 00_1111,  op2 00_1001_0000 | or op2 B$tttnBits
    On B$FirstOperandWbit <> 0,  error D$NeedByteSizePtr
    ifnot B$FirstGender Reg, L1>
      mov op3 00_1100_0000 | jmp op_op_reg1
L1: ifnot B$FirstGender mem, L2>
     mov op3 0 | jmp op_op_modRm
L2: BadOperand



CMOVinstructions:                      ; CMOVcc

    push esi
      add esi 4 | call SearchFortttnBits
    pop esi

    mov op1 00_1111,  op2 00_0100_0000 | or op2 B$tttnBits

    ifnot B$Operands RegToReg, L1>
      mov op3 00_1100_0000 | jmp op_op_reg1reg2
L1: ifnot B$Operands MemToreg, L2>
      jmp op_op_modReg1Rm                           ; Intel doc says: ModMemRm (???!!!)
L2: BadOperand

____________________________________________________________________________________________
; XMM comparisons:
;
; the notation i choose is, for example, CMP_PS_AE.
; Setting the conditions a end simplify analyzes.
;
; Encodage is ended by a 8 bit imm (from 0 to 7) specifying the comparison mode.

XMMcomparePS: ; CMPPS... encounted.
    mov B$imm32 0FF, B$immInside &TRUE, B$TrueSize ByteSize

    ...If B$esi+7 < Separators             ; B$esi+7 = op8 > 7 Chars mnemonic
        ..If op6 = 'E'
            If op7 = 'A'
                mov B$imm32 0                   ; =  EA
            End_If
        ..Else_If op6 = 'L'
            If op7 = 'T'
                mov B$imm32 1                   ; <  LT
            Else_If op7 = 'E'
                mov B$imm32 2                   ; <= LE
            End_If
        ..End_If

    ...Else_If B$esi+8 < Separators        ; > 8 Chars
        ..If op6 = 'N'
            .If op7 = 'E'
                If op8 = 'Q'
                    mov B$imm32 4               ; <> NEQ
                End_If
            .Else_If op7 = 'L'
                If op8 = 'T'
                    mov B$imm32 5               ; NLT  (not <)
                Else_If op8 > 'E'
                    mov B$imm32 6               ; NLE  (not <=)
                End_If
            .End_If
        ..Else_If op6 = 'O'
            .If op7 = 'R'
                If op8 = 'D'
                    mov B$imm32 7               ; Ordonated
                End_If
            .end_If
        ..End_If

    ...Else_If B$esi+10 < Separators
        .If D$esi+5 = 'UNOR'
            If B$esi+9 = 'D'                    ; CMPPSUNORD
                mov B$imm32 3                   ; UnOrdonated.... oughhhh!!!!!!!!!
            End_If
        .End_If

    ...End_If

    On B$imm32 = 0FF, BadMnemonic

    mov op1 0011000010 | jmp XMMmemXMM

_________________________________________________________________

; Turn, for example,
; 'CMP_UNORD_SD'
;             ^edi  ('SD' in eax)
;          ^esi
; 'CMP_SD_UNORD':

TrySSE2:
    push esi, edi
        lea ebx D$esi+2
        While B$esi > Separators | inc esi | End_While | dec esi
        mov ax W$esi-1
        mov edi esi | sub esi 2
        std
            while esi <> ebx | movsb | End_While
        cld
        dec edi | stosw
    pop edi esi

    call Store8cars

    ifnot op4 'P', L4>
        ifnot op5 'S', L5>      ; CMPPS... with given Condition (ex: CMP_SS_LT)
            jmp XMMcomparePS
L5:     ifnot op5 'D', L1>      ; CMPPD...
            jmp XMMcomparePD
L4: ifnot op4 'S', L1>
        ifnot op5 'S', L5>      ; CMPSS...
            jmp XMMcompareSS
L5:     ifnot op5 'D', L1>      ; CMPSD...
            jmp XMMcompareSD

L1: BadMnemonic
ret


XMMcompareSS: ; CMPSS... encounted.
    ToOpcode 0011110011 | jmp XMMcomparePS ; (Prefix + same encodage).

XMMcompareSD: ; CMPSS... encounted.
    ToOpcode 0011110010 | jmp XMMcomparePS ; (Prefix + same encodage).

XMMcomparePD: ; CMPSS... encounted.
    ToOpcode 0001100110 | jmp XMMcomparePS ; (Prefix + same encodage).

 _________________________________________________________________________________________

; all math mnemonics begin by 'F'.

; as FPU instructions operands are either memory or ST regs, no control is done here
; for other operands than 'mem' (if not mem >>> reg supposed). All needed controls are
; done in destination 'reg's routines. See down there 'op_STreg:' for exemple.


Math:

    On op4 > Separators, jmp M4>>
      ifnot op2 'L', L2>
        ifnot op3 'D', L3>                      ; FLD – Load Real
          ifnot B$FirstGender mem, L4>
            ifnot B$FirstOperandWbit DoubleSize, L5>
              mov op1 00_11011_001, op2 0 | jmp op_ModRm
L5:         ifnot B$FirstOperandWbit QuadSize, L5>
              mov op1 00_11011_101, op2 0 | jmp op_ModRm
L5:         ifnot B$FirstOperandWbit TenSize, L5>
              mov op1 00_11011_011, op2 00101_000 | jmp op_ModRm
L5:         BadOperandSize
L4:       mov op1 00_1101_1001, op2 00_11000_000 | jmp op_STregP1
L3:     BadMnemonic
L2:   ifnot op2 'S', L2>
        ifnot op3 'T', L3>                        ; FST – Store Real
          ifnot B$FirstGender mem, L4>
            ifnot B$FirstOperandWbit DoubleSize, L5>
              mov op1 00_11011_001, op2 00010_000 | jmp op_ModRm
L5:         ifnot B$FirstOperandWbit QuadSize, L5>
              mov op1 00_11011_101, op2 00010_000 | jmp op_ModRm
L5:         BadOperandSize
L4:       mov op1 00_11011_101, op2 00_11010_000 | jmp op_STregP1
L3:     ;BadMnemonic
L2:   BadMnemonic
 ____________________________________

M4: On op5 > Separators, jmp M5>>
      ifnot op2 'A', L2>
        ifnot op3 'B', L3>
          ifnot op4 'S', L4>                    ; FABS – Absolute Value
            mov op1 00_1101_1001, op2 00_1110_0001 | jmp op_op
L4:       BadMnemonic
L3:     ifnot op3 'D', L3>
          ifnot op4 'D', L4>                    ; FADD – Add
            ifnot B$FirstGender mem, L5>
              ifnot B$FirstOperandWbit DoubleSize, L6>
                mov op1 00_11011_000, op2 0 | jmp op_ModRm
L6:           ifnot B$FirstOperandWbit QuadSize, L6>
                mov op1 00_11011_100, op2 0 | jmp op_ModRm
L6:           BadOperandSize
L5:         mov op1 0011011_000, op2 00_11_000_000 | jmp d_STreg
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'B', L2>
          ifnot op3 'L', L3>
            ifnot op4 'D', L4>                     ; FBLD – Load Binary Coded Decimal
              ifnot B$FirstGender mem, L5>
                  ifnot B$FirstOperandwbit TenSize, L6>
                  mov op1 0DF, op2 00_100_000 | jmp op_modRm
L6:             BadOperandSize
L5:           BadOperand
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'C', L2>>
          ifnot op3 'H', L3>
            ifnot op4 'S', L4>                     ; FCHS – Change Sign
              mov op1 00_11011_001, op2 00_1110_0000 | jmp op_op
L4:         BadMnemonic
L3:       ifnot op3 'O', L3>
            ifnot op4 'M', L4>                     ; FCOM – Compare Real
L5:           ifnot B$FirstGender mem, L5>
                ifnot B$FirstOperandWbit DoubleSize, L6>
                  mov op1 00_11011_000, op2 00_010_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit QuadSize, L6>
                  mov op1 00_11011_100, op2 00_010_000 | jmp op_ModRM
L6:             BadOperandSize
L5:           mov op1 00_11011_000, op2 00_11_010_000 | jmp op_STreg
L4:         ifnot op4 'S', L4>                     ; FCOS – Cosine of ST(0)
              mov op1 00_11011_001, op2 00_1111_1111 | jmp op_op
L4:         BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'D', L2>
          ifnot op3 'I', L3>
            ifnot op4 'V', L4>
              ifnot B$FirstGender mem, L5>                 ; FDIV – Divide
                ifnot B$FirstOperandWbit DoubleSize, L6>
                  mov op1 00_11011_000, op2 00_110_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit QuadSize, L6>
                  mov op1 00_11011_100, op2 00_110_000 | jmp op_ModRm
L6:             BadOperandSize
L5:           mov op1 00_11011_000, op2 00_1111_0_000 | jmp d_RSTreg
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'I', L2>>
          ifnot op3 'L', L3>
            ifnot op4 'D', L4>                ; FILD – Load Integer
              ifnot B$FirstGender mem, L5>
                ifnot B$FirstOperandWbit WordSize, L6>
                  mov op1 00_11011_111, op2 0 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit DoubleSize, L6>
                  mov op1 00_11011_011, op2 0 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit QuadSize, L6>
                  mov op1 00_11011_111, op2 00_101_000 | jmp op_ModRm
L6:             BadOperandSize
L5:           BadOperand
L4:         BadMnemonic
L3:       ifnot op3 'S', L3>
            ifnot op4 'T', L4>
              ifnot B$FirstGender mem, L5>               ; FIST – Store Integer
                ifnot B$FirstOperandWbit WordSize, L6>
                  mov op1 00_11011_111, op2 00_010_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit DoubleSize, L6>
                  mov op1  00_11011_011, op2 00_010_000 | jmp op_ModRm
L6:             BadOperandSize
L5:           BadOperand
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'L', L2>
          ifnot op3 'D', L3>
            ifnot op4 '1', L4>                             ; FLD1 – Load +1.0 into ST(0)
              mov op1 00_11011_001, op2 00_1110_1000 | jmp op_op
L4:         ifnot op4 'Z', L4>                             ; FLDZ – Load +0.0 into ST(0)
              mov op1 00_11011_001, op2 00_1110_1110 | jmp op_op
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'M', L2>
          ifnot op3 'U', L3>
            ifnot op4 'L', L4>
              ifnot B$FirstGender mem, L5>              ; FMUL – Multiply
                ifnot B$FirstOperandWbit DoubleSize, L6>
                  mov op1 00_11011_000, op2 00_001_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit QuadSize, L6>
                  mov op1 00_11011_100, op2 00_001_000 | jmp op_ModRm
L6:             BadOperandSize
L5:           mov op1 00_11011_000, op2 00_1100_1_000 | jmp d_STreg
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'N', L2>
          ifnot op3 'O', L3>
            ifnot op4 'P', L4>                ; FNOP – No Operation
              mov op1 00_11011_001, op2 00_1101_0000 | jmp op_op
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'S', L2>>
          ifnot op3 'I', L3>
            ifnot op4 'N', L4>                 ; FSIN – Sine
              mov op1 00_11011_001, op2 00_1111_1110 | jmp op_op
L4:         BadMnemonic
L3:       ifnot op3 'T', L3>>
            ifnot op4 'P', L4>                 ; FSTP – Store Real and Pop
              ifnot B$FirstGender mem, L5>
                ifnot B$FirstOperandWbit DoubleSize, L6>
                  mov op1 00_11011_001, op2 00_011_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit QuadSize, L6>
                  mov op1 00_11011_101, op2 00_011_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit TenSize, L6>
                  mov op1 00_11011_011, op2 00_111_000 | jmp op_ModRm
L6:             BadOperandSize
L5:           mov op1 00_11°11_101, op2 00_11__011_000 | jmp op_STregP1
L4:         BadMnemonic
L3:       ifnot op3 'U', L3>
            ifnot op4 'B', L4>                          ; FSUB – Subtract
              ifnot B$FirstGender mem, L5>
                ifnot B$FirstOperandWbit DoubleSize, L6>
                  mov op1 00_11011_000, op2 00_100_000 | jmp op_ModRm
L6:             ifnot B$FirstOperandWbit QuadSize, L6>
                  mov op1 00_11011_100, op2 00_100_000 | jmp op_ModRm
L6:             BadOperandSize
L5:           mov op1 00_11011_000, op2 00_1110_0_000 | jmp d_RSTreg ; d_STreg
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'T', L2>
          ifnot op3 'S', L3>
            ifnot op4 'T', L4>                         ; FTST – Test
              mov op1 00_11011_001, op2 00_1110_0100 | jmp op_op
L4:         ;BadMnemonic
L3:       BadMnemonic
L2:     ifnot op2 'X', L2>
          ifnot op3 'A', L3>
            ifnot op4 'M', L4>                          ; FXAM – Examine
              mov op1 00_11011_001, op2 00_1110_0101 | jmp op_op
L4:         BadMnemonic
L3:       ifnot op3 'C', L3>
            ifnot op4 'H', L4>                         ; FXCH – Exchange ST(0) and ST(i)
               mov op1 00_11011_001, op2 00_1100_1_000 | jmp op_STreg
L4:          ;BadMnemonic
L3:        ;BadMnemonic
L2:     BadMnemonic

 ____________________________________

M5: On op6 > Separators, jmp M6>>

      ifnot op2 '2', L2>
        ifnot op3 'X', L3>
          ifnot op4 'M', L4>
            ifnot op5 '1', L5>                     ;F2XM1 – Compute 2 ST(0) – 1
              mov op1 00_11011_001, op2 00_11110000 | jmp op_op
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'A', L2>
        ifnot op3 'D', L3>
          ifnot op4 'D', L4>
            ifnot op5 'P', L5>                    ; FADDP – Add and Pop ST(0) ¬ ST(0) + ST(i)
              On B$ParametersNumber <> 2, NoFpAssume
              On B$SecondReg <> 0, error D$FADDPreg0Ptr
              mov op1 00_11011_110, op2 00_11_000_000 | jmp op_STreg
L5:         ;BadMnemonic
L4:       ;BadMemonic
L3:     BadMnemonic
L2:   ifnot op2 'B', L2>
        ifnot op3 'S', L3>
          ifnot op4 'T', L4>
            ifnot op5 'P', L5>             ; FBSTP – Store Binary Coded Decimal and Pop
              ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandwbit TenSize, L7>
                mov op1 0DF, op2 00_110_000 | jmp op_modRm
L7:             BadOperandSize
L6:           BadOperand
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'C', L2>
        ifnot op3 'L', L3>
          ifnot op4 'E', L4>
            ifnot op5 'X', L5>              ; FCLEX – Clear Exceptions
              ToOpcode 09B, 0DB | LastOpCode 0E2
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'O', L3>
          ifnot op4 'M', L4>
            ifnot op5 'P', L5>              ; FCOMP – Compare Real and Pop
              ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandWbit DoubleSize, L7>
                  mov op1 00_11011_000, op2 00_011_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit QuadSize, L7>
                  mov op1 00_11011_100, op2 00_011_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           mov op1 00_11011_000, op2 00_11_011_000 | jmp op_STreg
L5:         ifnot op5 'I', L5>                 ; FCOMI – Compare Real and Set EFLAGS
              mov op1 00_11011_011, op2 00_11_110_000 | jmp op_STreg
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'D', L2>
        ifnot op3 'I', L3>
          ifnot op4 'V', L4>
            ifnot op5 'P', L5>                    ; FDIVP – Divide and Pop
              On B$ParametersNumber <> 2, NoFpAssume
              mov op1 00_11011_110, op2 00_1111_1_000 | jmp opSTreg
L5:         ifnot op5 'R', L5>                    ; FDIVR – Reverse Divide
              ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandWbit DoubleSize, L7>
                  mov op1 00_11011_000, op2 00_111_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit QuadSize, L7>
                  mov op1 00_11011_100, op2 00_111_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           mov op1 00_11011_000, op2 00_1111_1_000 | jmp d_RSTreg
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:      ifnot op2 'E', L2>
           ifnot op3 'M', L3>
             ifnot op4 'M', L4>
               ifnot op5 'S', L5>               ; FEMMS (not an FPU -3DNaow!-)
                   mov al 0F | stosb | mov al 0E | stosb | ret
L5:            ;BadMnemonic
L4:          ;BadMnemonic
L3:        BadMnemonic
L2:   ifnot op2 'F', L2>
        ifnot op3 'R', L3>
          ifnot op4 'E', L4>
            ifnot op5 'E', L5>                       ; FFREE – Free ST(i) Register
              mov op1 00_11011_101, op2 00_1100_0_000 | jmp op_STregP1
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'I', L2>>
        ifnot op3 'A', L3>
          ifnot op4 'D', L4>
            ifnot op5 'D', L5>                      ; FIADD – Add Integer
              ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandWbit WordSize, L7>
                  mov op1 00_11011_110, op2 0 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit DoubleSize, L7>
                  mov op1 00_11011_010, op2 0 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'C', L3>
          ifnot op4 'O', L4>
            ifnot op5 'M', L5>               ; FICOM – Compare Integer
              ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandWbit WordSize, L7>
                  mov op1 00_11011_110, op2 00_010_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit DoubleSize, L7>
                  mov op1 00_11011_010, op2 00_010_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'D', L3>
          ifnot op4 'I', L4>
            ifnot op5 'V', L5>                               ; FIDIV
              ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandWbit WordSize, L7>
                  mov op1 00_11011_110, op2 00_110_000 | jmp op_modRm
L7:             ifnot B$FirstOperandWbit DoubleSize, L7>
                  mov op1 00_11011_010, op2 00_110_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'M', L3>
          ifnot op4 'U', L4>
            ifnot op5 'L', L5>                              ; FIMUL
              ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandWbit WordSize, L7>
                  mov op1 00_11011_110, op2 00_001_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit DoubleSize, L7>
                  mov op1 00_11011_010, op2 00_001_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           Badoperand
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'N', L3>
          ifnot op4 'I', L4>
            ifnot op5 'T', L5>                      ; FINIT – Initialize Floating-Point Unit
              toOpcode 09B, 0DB | LastOpcode 0E3
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'S', L3>>
          ifnot op4 'T', L4>
            ifnot op5 'P', L5>                         ; FISTP – Store Integer and Pop
              ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandWbit WordSize, L7>
                  mov op1 00_11011_111, op2 00_011_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit DoubleSize, L7>
                  mov op1 00_11011_011, op2 00_011_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit QuadSize, L7>
                  mov op1 00_11011_111, op2 00_111_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         BadMnemonic
L4:       ifnot op4 'U', L4>
            ifnot op5 'B', L5>                         ; FISUB
              ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandWbit WordSize, L7>
                  dec edi       ; No need 066 here.
                  mov op1 00_11011_110, op2 00_100_000 | jmp op_ModRm
L7:             ifnot B$FirstOperandWbit DoubleSize, L7>
                  mov op1 00_11011_010, op2 00_100_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'L', L2>
        ifnot op3 'D', L3>
          ifnot op4 'C', L4>
            ifnot op5 'W', L5>                      ; FLDCW – Load Control Word
              ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandWbit WordSize, L7>
                  dec edi                             ; scratch 066 prefix (no use)
                  mov op1 00_11011_001, op2 00_101_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         BadMnemonic
L4:       ifnot op4 'P', L4>
            ifnot op5 'I', L5>                         ; FLDPI – Load p into ST(0)
              mov op1 00_11011_001, op2 00_11101011 | jmp op_op
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'M', L2>
        ifnot op3 'U', L3>
          ifnot op4 'L', L4>
            ifnot op5 'P', L5>                     ; FMULP – Multiply
              On B$ParametersNumber <> 2, NoFpAssume
              mov op1 00_11011_110, op2 00_1100_1_000 | jmp op_STreg
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'P', L2>
        ifnot op3 'R', L3>
          ifnot op4 'E', L4>
            ifnot op5 'M', L5>                       ; FPREM – Partial Remainder
              mov op1 00_11011_001, op2 00_1111_1000 | jmp op_op
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'T', L3>
          ifnot op4 'A', L4>
            ifnot op5 'N', L5>                       ; FPTAN – Partial Tangent
              mov op1 00_11011_001, op2 00_1111_0010 | jmp op_op
L5:         BadMnemonic
L4:       BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'S', L2>>
        ifnot op3 'A', L3>
          ifnot op4 'V', L4>
            ifnot op5 'E', L5>                  ; FSAVE – Store FPU State 108 Bytes
              ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandWbit xSize, L7>
                  ToOpcode 09B
                  mov op1 00_11011_101, op2 00_110_000 | jmp op_ModRm
L7:             error D$XmarkerPtr
L6:           BadOperand
L5:         BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'Q', L3>
          ifnot op4 'R', L4>
            ifnot op5 'T', L5>                  ; FSQRT – Square Root
              mov op1 00_11011_001, op2 00_1111_1010 | jmp op_op
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:  ifnot op3 'T', L3>>
          ifnot op4 'C', L4>
            ifnot op5 'W', L5>                  ; FSTCW – Store Control Word
              ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandWbit WordSize, L7>
                  dec edi                               ; scratch 066 prefix (no use here)
                  ToOpcode 09B
                  mov op1 00_11011_001, op2 00_111_000 | jmp op_ModRm
L7:             BadOperandSize
L6:           BadOperand
L5:         BadMnemonic
L4:     ifnot op4 'S', L4>
           ifnot op5 'W', L5>                  ; FSTSW – Store Status Word into AX or mem
             dec edi                               ; scratch 066 prefix (no use here)
             ToOpcode 09B
             ifnot B$FirstGender mem, L6>
                ifnot B$FirstOperandWbit WordSize, L7>
                  mov op1 0DD, op2 00_111_000 | jmp op_ModRm
L7:             BadOperandSize
L6:          ifnot B$FirstGender reg, L6>
               ifnot B$FirstOperandWbit WordSize, L7>
                 ifnot B$FirstReg regAX, L6>
                   mov op1 0DF, op2 00_11100000 | jmp op_op_P1
L7:            BadOperandSize
L6:          BadOperand
L5:        BadMnemonic
L4:      BadMnemonic
L3:    ifnot op3 'U', L3>
         ifnot op4 'B', L4>
           ifnot op5 'P', L5>                   ; FSUBP – Subtract and Pop
             On B$ParametersNumber <> 2, NoFpAssume
             On B$SecondReg <> RegSt0, error D$FSUBPreg0Ptr  ; FADDPreg0
             mov op1 00_11011_110, op2 00_1110_1_000 | jmp d_STreg  ;;;op_STreg
L5:        ifnot op5 'R', L5>                   ; FSUBR – Reverse Subtract
             ifnot B$FirstGender mem, L6>
               ifnot B$FirstOperandWbit DoubleSize, L7>
                 mov op1 00_11011_000, op2 00_101_000 | jmp op_ModRm
L7:            ifnot B$FirstOperandWbit QuadSize, L7>
                 mov op1 00_11011_100, op2 00_101_000 | jmp op_ModRm
L7:            BadOperandSize
L6:          mov op1 00_11011_000, op2 00_1110_1_000 | jmp d_RSTreg
L5:        ;BadMnemonic
L4:      ;BadMnemonic
L3:    BadMnemonic
L2:  ifnot op2 'U', L2>
       ifnot op3 'C', L3>
         ifnot op4 'O', L4>
           ifnot op5 'M', L5>              ; FUCOM – Unordered Compare Real
             mov op1 00_11011_101, op2 00_1110_0_000 | jmp op_STreg
L5:        ;BadMnemonic
L4:      ;BadMnemonic
L3:    BadMnemonic
L2:  ifnot op2 'Y', L2>
       ifnot op3 'L', L3>
         ifnot op4 '2', L4>
           ifnot op5 'X', L5>              ; FYL2X – ST(1) ´ log 2 (ST(0))
             mov op1 00_11011_001, op2 00_1111_0001 | jmp op_op
L5:        ;BadMnemonic
L4:      ;BadMnemonic
L3:    BadMnemonic
L2:  ifnot op2 'W', L2>
       ifnot op3 'A', L3>
         ifnot op4 'I', L4>
           ifnot op5 'T', L5>                   ; FWAIT – Wait until FPU Ready
             mov op1 00_1001_1011 | jmp op
L5:        ;BadMnemonic
L4:      ;BadMnemonic
L3:    ;BadMnemonic
L2:  BadMnemonic

 ____________________________________

M6: On op7 > Separators, jmp M7>>

      ifnot op2 'C', L2>
        ifnot op3 'O', L3>
          ifnot op4 'M', L4>
            ifnot op5 'P', L5>
              ifnot op6 'P', L6>          ; FCOMPP – Compare Real and Pop Twice
                mov op1 00_11011_110, op2 00_11_011_001 | jmp op_op
L6:           BadMnemonic
L5:         ifnot op5 'I', L5>
              ifnot op6 'P', L6>          ; FCOMIP – Compare Real, Set EFLAGS, and Pop
                mov op1 00_11011_111, op2 00_11_110_000 | jmp op_STreg
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       BadMnemonic
 ________________________________

L3:     On op3 = 'M', jmp FCMOVcc        ; >>>>>>>>>> down there
 ________________________________

L2:   ifnot op2 'D', L2>
        ifnot op3 'I', L3>
          ifnot op4 'V', L4>
            ifnot op5 'R', L5>
              ifnot op6 'P', L6>              ; FDIVRP – Reverse Divide and Pop
                On B$ParametersNumber <> 2, NoFpAssume
                mov op1 00_11011_110, op2 00_1111_0_000 | jmp op_STreg
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'F', L2>
        ifnot op3 'R', L3>
          ifnot op4 'E', L4>
            ifnot op5 'E', L5>                       ; FFREEP   Free ST(i) Register and pop
              ifnot op6 'P', L6>
              mov op1 0DF, op2 0C0 | jmp op_STregP1
L6:
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'I', L2>>
        ifnot op3 'C', L3>
          ifnot op4 'O', L4>
            ifnot op5 'M', L5>
              ifnot op6 'P', L6>           ; FICOMP – Compare Integer and Pop
                ifnot B$FirstGender mem, L7>
                  ifnot B$FirstOperandWbit WordSize, L8>
                    mov op1 00_11011_110, op2 00_011_000 | jmp op_ModRm
L8:               ifnot B$FirstOperandWbit DoubleSize, L8>
                    mov op1 00_11011_010, op2 00_011_000 | jmp op_ModRm
L8:               BadOperandSize
L7:             BadOperand
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'D', L3>
          ifnot op4 'I', L4>
            ifnot op5 'V', L5>
              ifnot op6, 'R', L6>                           ; FIDIVR
                ifnot B$FirstGender mem, L7>
                  ifnot B$FirstOperandWbit WordSize, L8>
                    mov op1 00_11011_110, op2 00_111_000 | jmp op_ModRm
L8:               ifnot B$FirstOperandWbit DoubleSize, L8>
                    mov op1 00_11011_010, op2 00_111_000 | jmp op_ModRm
L8:               BadOperandSize
L7:             BadOperand
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       BadMnemonic
L3:     ifnot op3 'S', L3>>
          ifnot op4 'T', L4>
            ifnot op5 'T', L5>>
              ifnot op6 'P', L6>>       ; FISTTP
                ifnot B$FirstGender mem, L7>
                If B$FirstOperandWbit = WordSize
                    mov op1 0DF
                Else_If B$FirstOperandWbit = doubleSize
                    mov op1 0DB
                Else_If B$FirstOperandWbit = QuadSize
                    mov op1 0DD
                Else
                    BadOperand
                End_If
                mov op2 00_001_000 | jmp op_ModRm

L4:       ifnot op4 'U', L4>
            ifnot op5 'B', L5>
              ifnot op6 'R', L6>                       ; FISUBR
                ifnot B$FirstGender mem, L7>
                  ifnot B$FirstOperandWbit WordSize, L8>
                    dec edi         ; No need of 066 here.
                    mov op1 00_11011_110, op2 00_101_000 | jmp op_ModRm
L8:               ifnot B$FirstOperandWbit DoubleSize, L8>
                    mov op1 00_11011_010, op2 00_101_000 | jmp op_ModRm
L8:               BadOperandSize
L7:             BadOperand
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:      BadMnemonic
L2:    ifnot op2 'L', L2>>
         ifnot op3 'D', L3>>
           ifnot op4 'E', L4>
             ifnot op5 'N', L5>
               ifnot op6 'V', L6>                ; FLDENV – Load FPU Environment
                 ifnot B$FirstGender mem, L7>
                   ifnot B$FirstOperandWbit xSize, L8>
                     mov op1 00_11011_001, op2 00_100_000 | jmp op_ModRm  ;  m28 bytes
L8:                error D$XmarkerPtr
L7:              BadOperand
L6:           ;BadMnemonic
L5:         BadMnemonic
L4:       ifnot op4 'L', L4>
            ifnot op5 '2', L5>
              ifnot op6 'E', L6>           ; FLDL2E – Load log 2 (e) into ST(0)
                mov op1 00_11011_001, op2 00_1110_1010 | jmp op_op
L6:           ifnot op6 'T', L6>           ; FLDL2T – Load log 2 (10) into ST(0)
                mov op1 00_11011_001, op2 00_1110_1001 | jmp op_op
L6:           BadMnemonic
L5:         ifnot op5 'G', L5>
              ifnot op6 '2', L6>            ; FLDLG2 – Load log 10 (2) into ST(0)
                mov op1 00_11011_001, op2 00_1110_1100 | jmp op_op
L6:           BadMnemonic
L5:         ifnot op5 'N', L5>
              ifnot op6 '2', L6>           ; FLDLN2 – Load log = (2) into ST(0)
                mov op1 00_11011_001, op2 00_1110_1101 | jmp op_op
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'N', L2>>
        ifnot op3 'C', L3>
           ifnot op4 'L', L4>
             ifnot op5 'E', L5>
               ifnot op6 'X', L6>                      ; FNCLEX
                  ToOpcode 0DB | LastOpcode 0E2
L6:         ;BadMnemonic
L5:       ;BadMnemonic
L4:     BadMnemonic
L3:      ifnot op3 'I', L3>
           ifnot op4 'N', L4>
             ifnot op5 'I', L5>
               ifnot op6 'T', L6>                      ; FNINIT*
                  ToOpcode 0DB | LastOpcode 0E3
L6:         ;BadMnemonic
L5:       ;BadMnemonic
L4:     BadMnemonic
L3:     ifnot op3 'S', L3>>
          ifnot op4 'A', L4>
            ifnot op5 'V', L5>                  ; FNSAVE – Store FPU Environ. 108 Bytes
              ifnot op6 'E', L6>
                ifnot B$FirstGender mem, L7>
                  ifnot B$FirstOperandWbit xSize, L8>
                    mov op1 0D9, op2 00_111_000 | jmp op_ModRm
L8:               error D$XmarkerPtr
L7:           BadOperand
L6:         ;BadMnemonic
L5:       BadMnemonic
L4:       ifnot op4 'T', L4>>
            ifnot op5 'C', L5>                  ; FNSTCW  ; 'FSTCW'
              ifnot op6 'W', L6>
                ifnot B$FirstGender mem, L7>
                  ifnot B$FirstOperandWbit wordSize, L8>
                    dec edi                             ; scratch 066 prefix (no use here)
                    mov op1 00_11011_001, op2 00_111_000 | jmp op_ModRm
                    ;mov op1 00_11011_101, op2 00_110_000 | jmp op_ModRm
L8:               BadOperandSize
L7:           BadOperand
L6:         BadMnemonic
L5:         ifnot op5 'S', L5>                  ; FNSTSW
              ifnot op6 'W', L6>
                dec edi ; No need of 066 here.
                ifnot B$FirstGender mem, L7>
                  ifnot B$FirstOperandWbit wordSize, L8>
                    mov op1 0DD, op2 00_111_000 | jmp op_ModRm
L7:             ifnot B$FirstGender reg, L7>
                  ifnot B$FirstOperandWbit wordSize, L8>
                    ifnot B$FirstReg regAX, L7>
                      mov op1 0DF, op2 0E0 | jmp op_op_P1
L8:               BadOperandSize
L7:           BadOperand
L6:         ;BadMnemonic
L5:       ;BadMnemonic
L4:     ;BadMnemonic
L3:   BadMnemonic
L2:   ifnot op2 'P', L2>
        ifnot op3 'A', L3>
          ifnot op4 'T', L4>
            ifnot op5 'A', L5>
              ifnot op6 'N', L6>            ; FPATAN – Partial Arctangent
                mov op1 00_11011_001, op2 00_1111_0011 | jmp op_op
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       BadMnemonic
L3:     ifnot op3 'R', L3>
          ifnot op4 'E', L4>
            ifnot op5 'M', L5>
              ifnot op6 '1', L6>            ; FPREM1 – Partial Remainder (IEEE)
                mov op1 00_11011_001, op2 00_1111_0101 | jmp op_op
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'R', L2>
        ifnot op3 'S', L3>
          ifnot op4 'T', L4>
            ifnot op5 'O', L5>
              ifnot op6 'R', L6>            ; FRSTOR – Restore FPU State
                 ifnot B$FirstGender mem, L7>
                   ifnot B$FirstOperandWbit xSize, L8>
                     mov op1 00_11011_101, op2 00_100_000 | jmp op_ModRm ; 180 bytes
L8:                error D$XmarkerPtr
L7:              BadOperand
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'S', L2>>
        ifnot op3 'C', L3>
          ifnot op4 'A', L4>
            ifnot op5 'L', L5>
              ifnot op6 'E', L6>           ; FSCALE – Scale
                mov op1 0D9, op2 0FD | jmp op_op
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       BadMnemonic
L3:     ifnot op3 'T', L3>
          ifnot op4 'E', L4>
            ifnot op5 'N', L5>
              ifnot op6 'V', L6>            ; FSTENV – Store FPU Environment
                ifnot B$FirstGender mem, L7>
                  ifnot B$FirstOperandWbit xSize, L8>
                    mov op1 00_11011_001, op2 00_110_000 | jmp op_ModRm  ; 28 bytes
L8:               error D$XmarkerPtr
L7:             BadOperand
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       BadMnemonic
L3:     ifnot op3 'U', L3>
          ifnot op4 'B', L4>
            ifnot op5 'R', L5>
              ifnot op6 'P', L6>            ; FSUBRP – Reverse Subtract and Pop
                On B$ParametersNumber <> 2, NoFpAssume
                mov op1 00_11011_110, op2 0E0 ;00_1110_0_00 |
                jmp op_STreg
L6:           ;BadMnemonic
L5:         ;Badmnemonic
L4:       ;BadMnemonic
L3:     BadMnemonic
L2:   ifnot op2 'U', L2>
        ifnot op3 'C', L3>
          ifnot op4 'O', L4>
            ifnot op5 'M', L5>
              ifnot op6 'P', L6>       ; FUCOMP – Unordered Compare Real and Pop
                mov op1 00_11011_101, op2 00_1110_1_000 | jmp op_STreg
L6:           ifnot op6 'I', L6>       ; FUCOMI – Unorderd Compare Real and Set EFLAGS
                mov op1 00_11011_011, op2 00_11_101_000 | jmp op_STreg
L6:          ;BadMnemonic
L5:        ;Badmnemonic
L4:      ;BadMnemonic
L3:   BadMnemonic
L2:   ifnot op2 'X', L2>
        ifnot op3 'S', L3>
          ifnot op4 'A', L4>
            ifnot op5 'V', L5>
              ifnot op6 'E', L6>                      ; FXSAVE
                ifnot B$FirstGender mem, L7>
                  ifnot B$FirstOperandwbit XSize, L7>
                      mov al 0F | stosb | mov op1 0AE, op2 0 | jmp op_ModRm
L7:               error D$XmarkerPtr
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       ;BadMnemonic
L3:     ;BadMnemonic
L2:   BadMnemonic


 ____________________________________

M7: On op8 > Separators, jmp M8>>

      On op2 = 'C', jmp FCMOVcc       ;  >>>>>>>>>>>>>  Down there

      ifnot op2 'D', L2>
        ifnot op3 'E', L7>
          ifnot op4 'C', L7>
            ifnot op5 'S', L7>
              ifnot op6 'T', L7>
                ifnot op7 'P', L7>         ; FDECSTP – Decrement Stack-Top Pointer
                  mov op1 00_11011_001, op2 00_1111_0110 | jmp op_op
L7:     BadMnemonic
L2:   ifnot op2 'I', L2>
        ifnot op3 'N', L7>
          ifnot op4 'C', L7>
            ifnot op5 'S', L7>
              ifnot op6 'T', L7>
                ifnot op7 'P', L7>         ; FINCSTP – Increment Stack Pointer
                  mov op1 00_11011_001, op2 00_1111_0111 | jmp op_op
L7:     BadMnemonic
L2:   ifnot op2 'N', L2>
        ifnot op3 'S', L7>
          ifnot op4 'T', L7>
            ifnot op5 'E', L7>
              ifnot op6 'N', L7>
                ifnot op7 'V', L7>         ; FNSTENV
                  ifnot B$FirstOperandwbit XSize, L8>
                    mov op1 0D9, op2 00_110_000 | jmp op_ModRm
L8:               error D$XmarkerPtr
L7:     BadMnemonic
L2:   ifnot op2 'R', L2>
        ifnot op3 'N', L7>
          ifnot op4 'D', L7>
            ifnot op5 'I', L7>
              ifnot op6 'N', L7>
                ifnot op7 'T', L7>         ; FRNDINT – Round to Integer
                  mov op1 00_11011_001, op2 00_1111_1100 | jmp op_op
L7:     BadMnemonic
L2:   ifnot op2 'S', L2>
        ifnot op3 'I', L7>
          ifnot op4 'N', L7>
            ifnot op5 'C', L7>
              ifnot op6 'O', L7>
                ifnot op7 'S', L7>         ; FSINCOS – Sine and Cosine
                  mov op1 00_11011_001, op2 00_1111_1011 | jmp op_op
L7:     BadMnemonic
L2:   ifnot op2 'U', L2>
        ifnot op3 'C', L3>
          ifnot op4 'O', L4>
            ifnot op5 'M', L5>
              ifnot op6 'P', L6>
                ifnot op7 'P', L7>      ; FUCOMPP – Unordered Compare Real and Pop Twice
                  mov op1 00_11011_010, op2 00_1110_1001 | jmp op_op
L7:             BadMnemonic
L6:           ifnot op6 'I', L6>
                ifnot op7 'P', L7>  ; FUCOMIP – Unorderd Compare Real, Set EFLAGS, and Pop
                  mov op1 00_11011_111, op2 00_11_101_000 | jmp op_STreg
L7:             ;BadMnemnoic
L6:           ;BadMnemonic
L5:         ;BadMnemonic
L4:       ;BadMnemnonic
L3:     BadMnemonic
L2:   ifnot op2 'X', L2>
        ifnot op3 'R', L3>
          ifnot op4 'S', L7>
            ifnot op5 'T', L7>
              ifnot op6 'O', L7>
                ifnot op7 'R', L7>       ; FXRSTOR
                  ifnot B$FirstGender mem, L8>
                     ifnot B$FirstOperandwbit XSize, L8>
                         ToOpcode 0F | mov op1 0AE, op2 00_001_000 | jmp op_ModRm
L8:                  error D$XmarkerPtr
L7:     BadMnemonic
L3: ifnot op3 'T', L7>
          ifnot op4 'R', L7>
            ifnot op5 'A', L7>
              ifnot op6 'C', L7>
                ifnot op7 'T', L7>       ; FXTRACT – Extract Exponent and Significand
                  mov op1 00_11011_001, op2 00_1111_0100 | jmp op_op
L7:     BadMnemonic
L2:   ifnot op2 'Y', L2>
        ifnot op3 'L', L7>
          ifnot op4 '2', L7>
            ifnot op5 'X', L7>
              ifnot op6 'P', L7>
                ifnot op7 '1', L7>     ; FYL2XP1 – ST(1) ´ log 2 (ST(0) + 1.0)
                  mov op1 00_11011_001, op2 00_1111_1001 | jmp op_op
L7:     ;BadMnemonic
L2:   ;BadMnemonic

M8: On D$esi = 'FCMO', jmp FCMOVcc
    BadMnemonic

 ______________________________________________________________________________________

FCMOVcc:                       ; Conditional Move on EFLAG
      ifnot op3 'M', L8>>
        ifnot op4 'O', L8>>
          ifnot op5 'V', L8>>
            On op7 > Separators, jmp L2>
              ifnot op6 'E', L1>
                mov op1 00_11011_010, op2 00_11_001_000 | jmp op_STreg  ; e
L1:           ifnot op6 'B', L1>
                mov op1 00_11011_010, op2 00_11_000_000 | jmp op_STreg  ; b
L1:           ifnot op6 'U', L1>
                mov op1 00_11011_010, op2 00_11_011_000 | jmp op_STreg  ; u
L1:           ifnot op6 'A', L7>>
E0:             mov op1 00_11011_011, op2 00_11_010_000 | jmp op_STreg  ; a nbe
L2:         On op8 > Separators, jmp L3>
              ifnot op6 'N', L4>
                ifnot op7 'E', L5>
Z0:               mov op1 00_11011_011, op2 00_11_001_000 | jmp op_STreg ; <> nz
L5:             ifnot op7 'A', L5>
B0:               mov op1 00_11011_010, op2 00_11_010_000 | jmp op_STreg ; na be
L5:             ifnot op7 'B', L5>
A0:               mov op1 00_11011_011, op2 00_11_000_000 | jmp op_STreg ; nb ae
L5:             ifnot op7 'U', L5>
                  mov op1 00_11011_011, op2 00_11_011_000 | jmp op_STreg ; nu
L5:             ifnot op7 'Z', L7>
                  jmp Z0<
L4:           ifnot op7 'E', L7>
                ifnot op6 'B', L5>
                  jmp B0<
L5:             ifnot op6 'A', L7>
                  jmp A0<
L3:         On B$esi+9 > Separators, jmp L7>
              ifnot op6 'N', L7>
                ifnot op7 'B', L7>
                  ifnot op8 'E', L7>
                    jmp E0<<
L7:    error D$BadFPUcondPtr
L8:  BadMnemonic

 _________________________________________________________________________________________
 _________________________________________________________________________________________
;;
 End codage control and write routines. Jump from 'Encode' > RET > return to 'EncodeLines'

 'imm' and 'dis' are written after by 'EncodeLine'

 all the '......_P2' routines are for bit instruction that are two parameters when
 written in mnemonics, but only one when written in opCode. exemple:
                             shl eax, 1
 the immediate 1 doesn't appear in code flow but is given by the code instruction itself.
;;
 ___________________________________________________________________________________________

; macros and subs used down there:

[ToOpcode | mov B$edi #1 | inc edi | #+1]

[LastOpcode | mov B$edi #1 | inc edi | ret]       ; this RET is the true Encode job return

Params:
  On B$wBitDisagree = &TRUE,  error D$MixTypePtr
ParamsAny:
  On B$ParametersNumber < cl,  Error D$NotEnoughPtr
  On B$ParametersNumber > cl,  Error D$TooMuchPtr
ret


[Parms | mov cl, #1 | call Params]

[ParmsAny | mov cl, #1 | call ParamsAny]

Xparams:                                         ; used by for MOVSX / MOVZX
    call ParamsAny

    cmp B$FirstOperandWbit WordSize | jne L8>
      ToOpcode 066
      On B$SecondOperandWbit = WordSize,  error D$MixTypePtr

L8: On B$FirstOperandWbit = ByteSize,  error D$MixTypePtr
    On B$SecondOperandWbit = DoubleSize,  error D$MixTypePtr
    mov dl B$SecondOperandWbit | and dl 1 | mov B$wBit dl
    ret

[Xparms | mov cl, #1 | call Xparams]

im8Size:
    On B$ImmInside = &False, BadOperand
    On D$imm32 > 0FF,  error D$OverBytePtr
    mov B$TrueSize ByteSize     ; for 'StoreImm' in case of bigger sized first parameter
  ret

[imm8Size | call im8Size]

im16Size:
    On D$imm32 >= 010000,  error D$OverBytePtr
    mov B$TrueSize WordSize
  ret

[imm16Size | call im16Size]

ds8Size:
    On D$dis32 >= 0100,  error D$OverBytePtr
    cmp B$LocalSize DownLong | je L1>
    cmp B$LocalSize UpLong | jne L2>
L1:   error D$LongDisPtr
L2: mov B$LongRelative &FALSE,  D$Relative RelativeFlag
    ret

[dis8Size | call ds8Size]

GPrg1:                                    ; test a reg to be a general purpose
  On B$FirstReg > 00_0111,  error D$GPregisterPtr
  On B$FirstRegGender > reg,  error D$GPregisterPtr
ret

GPrg2:
  On B$SecondReg > 00_0111,  error D$GPregisterPtr
  On B$SecondRegGender > reg,  error D$GPregisterPtr
ret

GPrg1_2:
  call GPrg1
  call GPrg2
ret

[GPreg1 | call GPrg1]     [GPreg2 | call GPrg2]     [GPreg1_2 | call GPrg1_2]

[LastSbitEdi: 0]

; The OpCodes concerned by Sign Extensions are: adc, add, and, cmp, imul, or, push, sbb,
; sub, xor.

sIm:
    cmp B$immInside &TRUE | jne L9>
    push eax
        mov eax D$imm32
        If eax <= 07F
L1:         mov B$sBit 0010
        Else
            and eax 0_FFFF_FF80
            On eax = 0_FFFF_FF80, mov B$sBit 0010
        End_If

        On B$sBit = 0010, call CkeckPossibleImmLabel
    pop eax
    If B$sBit = 0010
        mov B$TrueSize ByteSize | and D$imm32 0FF | mov B$immSign &FALSE
      ; &FALSE, because we will not check the dWord High Bit in StoreImm
    End_If
L9: ret


; This is a simplified version of 'First / SecondParameterLabel'. In case of something
; remaining in the line, we abort the sBit encodage.

CkeckPossibleImmLabel:
    push esi
        mov esi D$LineStart
L0:     lodsb | cmp al Space | jne L0<
L0:     lodsb
            cmp al EOI | je L9>>
            cmp al meEOI | je L9>>   ; and not "cmp al EOI | JBE L9>>" because zeros inside...
            cmp al 'A' | jb L0<
            cmp al, 'Z' | ja L0<
            cmp al 'E' | jne L1>
            push eax
                call IsItAnEreg              ; usefull only in case of mem adressing
            pop eax
            IfEregNotFound L1>
            add esi 2 | jmp L0<
L1:     mov B$sBit 0
L9: pop esi
ret


[signImm | call sIm]


STrg12: On B$SecondRegGender <> STreg, error D$STwishedPtr
STrg1: On B$FirstRegGender <> STreg, error D$STwishedPtr  | ret

[STregs1_2 | Call STrg12]

[StReg1 | call STrg1]
 ________________________________________________________________________________________
 ________________________________________________________________________________________
;;
 FPU job:

 each time it is possible, syntax is free. Good and equivalent, for exemple:

                FDIV = FDIV ST1 = FDIV ST0 ST1
                       FDIV ST2 = FDIV ST0 ST2
;;

op_STregP1:
    On B$ParametersNumber > 1, error D$TooMuchPtr
    ifnot B$ParametersNumber 0,  L1>
      ToOpcode op1 | LastOpcode op2
op_STreg:
    ifnot B$ParametersNumber 0,  L1>
      ToOpcode op1 | inc op2 | LastOpcode op2
L1: ifnot B$ParametersNumber 1,  L2>
      STreg1 | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2
L2: ifnot B$ParametersNumber 2,  L3>
 ;    ;;; On B$FirstReg <> RegST0, error ST0wished
 ;     On B$SecondReg <> RegST0, error ST0wished
 ;   ;;STregs1_2 | ToOpcode op1 | or op2 B$SecondReg | LastOpcode op2
 ;     STregs1_2 | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

 ; Last choice > more flexibility:

        STregs1_2 | ToOpcode op1
        If B$FirstReg = RegST0
            or op2 B$SecondReg
        Else_If B$SecondReg = RegST0
            or op2 B$FirstReg
        Else
            error D$ST0wishedPtr
        End_If

        LastOpcode op2

L3: Error D$TooMuchPtr

d_STreg:
    ifnot B$ParametersNumber 0,  L1>
      ToOpcode op1 | inc op2 | LastOpcode op2
L1: ifnot B$ParametersNumber 1,  L2>
      STreg1 | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2
L2: ifnot B$ParametersNumber 2, L8>
      STregs1_2 | cmp B$FirstReg RegST0 | jne L3>
        or op2 B$SecondReg | ToOpcode op1 | LastOpcode op2
L3:   On B$SecondReg <> RegST0, error D$ST0wishedPtr
        or op1 00_100 | ToOpcode op1                        ; 00_100 = direction bit
        or op2 B$FirstReg | LastOpcode op2
L8: Error D$TooMuchPtr

; for FDIV / FDIVR // FSUB / FSUBR, R bit (second byte: 0000x000) XORed for reversed forms:
; R bit set by caller (jumper) to 0 for FDIV / FSUB,  to 1 for FDIVR / FSUBR

d_RSTreg:
    ifnot B$ParametersNumber 0,  L1>
      ToOpcode op1 | inc op2 | LastOpcode op2
L1: ifnot B$ParametersNumber 1,  L2>
      STreg1 | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2
L2: ifnot B$ParametersNumber 2,  L8<
    STregs1_2 | cmp B$FirstReg RegST0 | jne L1>
L0:   or op2 B$SecondReg | ToOpcode op1 | LastOpcode op2
L1: On B$SecondReg <> RegST0, error D$ST0wishedPtr
      or op1 00_0100 | ToOpcode op1                          ; 00_0100 = direction bit
      xor op2 00_1000 | or op2 B$FirstReg | LastOpcode op2   ; 00_1000 = Reverse bit

 ________________________________________________________________________________________
 ________________________________________________________________________________________
;;
 MMX job:

 As MMX coding is much more regular than it is for interger, less work is done in the
 'text routing' level and more work is done here. op1 is in fact the second opcode
 (00_1111 is always store at first here). All cases are covered by 4 routines, mm4,
 mm2, gg2, gg3.

 'gg_value' routine inputs granularity (Byte, Word, Dword or Qword) as a letter
 (B, W, D or Q) set in CL reg ( validity test done by mnemonics parser). Instead of
 4 different cases holding, we add 2 to ascii value and keep last two bits. Trick:

 cl = 'B' = 00_01000010 + 0010 = 00_01000100 >>> and 0011 >>> 00_00  >>>  gg_Byte
 cl = 'W' = 00_01010111 + 0010 = 00_01011001 >>> and 0011 >>> 00_01  >>>  gg_Word
 cl = 'D' = 00_01000100 + 0010 = 00_01000110 >>> and 0011 >>> 00_10  >>>  gg_dWord
 cl = 'Q' = 00_01010011 + 0010 = 00_01010011 >>> and 0011 >>> 00_11  >>>  gg_qWord
;;

[gg_value | add cl 2 | and cl 00_11 | or op1 cl]

;;
 Exemple for mm4:      MOVD - Move doubleword N N Y N

   reg to mmreg    00001111:01101110: 11 mmxreg1 reg2   ; movd MM0 eax
   reg from mmxreg 00001111:01111110: 11 mmxreg2 reg1   ; movd eax MM0
   mem to mmxreg   00001111:01101110: mod mmxreg1 r/m   ; movd MM0 D$val
   mem from mmxreg 00001111:01111110: mod mmxreg2 r/m   ; movd D$val MM0

 2 mnemonics only for mm4. In both cases op1 (true second opcode) is the same for the
 4 cases, but with 00_10000 add in cases 2 and 4.
;;

mmFour: ParmsAny 2 | ToOpcode 00_1111
     cmp B$Operands RegToReg | jne L1>
      cmp B$FirstRegGender mmReg | jne L2>
        ToOpcode op1                                                 ; case 1
        GPreg2 | mov op1 B$FirstReg | shl op1 3 | or op1 B$SecondReg
        or op1 00_11000000 | LastOpcode op1
L2:   cmp B$SecondRegGender mmReg | jne L2>
        or op1 00_10000 | toOpcode op1                               ; case 2
        GPreg1 | mov op1 B$SecondReg | shl op1 3 | or op1 B$FirstReg
        or op1 00_11000000 | LastOpcode op1
L2:   BadOperand
L1: cmp B$Operands MemToReg | jne L1>
      ToOpcode op1 | mov op1 B$ModBits | or op1 B$RmBits             ; case 3
      On B$FirstRegGender <> mmReg, error D$OperandsTypesPtr
      mov op2 B$FirstReg | shl op2 3 | or op1 op2 | LastOpcode op1
L1: cmp B$Operands RegToMem | jne L1>
      or op1 00_10000 | ToOpcode op1                                 ; case 4
      mov op1 B$ModBits | or op1 B$RmBits
      On B$SecondRegGender <> mmReg, error D$OperandsTypesPtr
      mov op2 B$SecondReg | shl op2 3 | or op1 op2 | LastOpcode op1
L1: BadOperand



; Exemple for gg2:       PADD - Add with wrap-around Y Y Y N
;   mmxreg2 to mmxreg1 0000 1111: 111111gg: 11 mmxreg1 mmxreg2    ; padd MM0 MM1
;   memory to mmxreg   0000 1111: 111111gg: mod mmxreg r/m        ; padd MM0 B$Val

gg2: gg_Value    ; >>> mm2:

    .If B$FirstRegGender = XmmReg
        ToOpcode 066 | mov B$FirstRegGender mmReg
        If B$SecondRegGender = XmmReg
            mov B$SecondRegGender mmReg
        End_If
    .End_If

; Exemple for mm2:       PAND - Bitwise And N N N Y
;   mmxreg2 to mmxreg1 0000 1111:11011011: 11 mmxreg1 mmxreg2   ; pand MM0 MM1
;   memory to mmxreg   0000 1111:11011011: mod mmxreg r/m       ; pand MM0 Q$Val

mmTwo:

ParmsAny 2 | ToOpcode 00_1111, op1
L0: cmp B$Operands RegToReg | jne L1>
      cmp B$FirstRegGender  mmReg | jne L8>
      cmp B$SecondRegGender mmReg | jne L8>
        mov op1 B$FirstReg | shl op1 3 | or op1 B$SecondReg
        or op1 00_11000000 | LastOpcode op1
L1: mov op1 B$ModBits | or op1 B$RmBits
    cmp B$Operands MemToReg | jne L8>
      cmp B$FirstRegGender mmReg | jne L8>
      mov op2 B$FirstReg | shl op2 3 | or op1 op2 | LastOpcode op1
L8: BadOperand

mmTwoImm8:
    ParmsAny 3 | ToOpcode 00_1111, op1
    On B$immInside = &FALSE, error D$EndingImmPtr
    On D$imm32 > 0FF, BadOperandSize
        mov B$TrueSize ByteSize                 ; to ajust imm size to 8 bits storage
        jmp L0<<

mmOne:
    ParmsAny 2
    cmp B$Operands RegToReg | jne L9>
        cmp B$FirstRegGender MMreg | jne L9>
            cmp B$SecondRegGender MMreg | jne L9>
                ToOpcode 0F, op1
                mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                LastOpcode al

L9: BadOperand


; Used only with movntq and one of movq:

MMregToMem:
    ParmsAny 2
    cmp B$Operands RegToMem | jne L9>
        cmp B$SecondRegGender mmReg | jne L9>
            cmp B$FirstOperandWbit Xsize | je L7>
            cmp B$FirstOperandWbit QuadSize | jne L8>
L7:             ToOpcode 0F, op1
                mov al B$SecondReg | shl al 3 | or al B$ModBits | or al B$RmBits
                LastOpcode al
L8: BadOperandSize
L9: BadOperand

;;
 Exemple for gg3:       PSLL  - Packed shift left logical N Y Y Y
   mmxreg1 by mmxreg2  00001111:111100gg: 11 mmxreg1 mmxreg2        ; psll MM0 MM1
   mmxreg by memory    00001111:111100gg: mod mmxreg r/m            ; psll MM0 D$val
   mmxreg by immediate 00001111:011100gg: 11 110 mmxreg: imm8 data  ; psll MM1 28
                                             ^^^ /n is here (op2)
 3 mnemonic for gg3. For all, case 1 and 2 have the same op1 code.
 For all, case 3 is 011100gg. (070 + gg)
;;

gg3:
    .If B$FirstRegGender = XmmReg
        ToOpcode 066 | mov B$FirstRegGender mmReg
        If B$SecondRegGender = XmmReg
            mov B$SecondRegGender mmReg
        End_If
    .End_If

    push ecx
        ParmsAny 2 | ToOpcode 00_1111
    pop ecx
    cmp B$Operands RegToReg | jne L1>
      cmp B$FirstRegGender  mmReg | jne L8>>
      cmp B$SecondRegGender mmReg | jne L8>>
        gg_Value | ToOpcode op1                                 ; case 1
        mov op1 B$FirstReg | shl op1 3 | or op1 B$SecondReg
        or op1 00_11000000 | LastOpcode op1
L1: cmp B$Operands MemToReg | jne L1>
      cmp B$FirstRegGender mmReg | jne L8>
        gg_Value | ToOpcode op1                                 ; case 2
        mov op1 B$ModBits | or op1 B$RmBits
        mov op2 B$FirstReg | shl op2 3 | or op1 op2 | LastOpcode op1
L1: cmp B$Operands immToReg | jne L8>
      cmp B$FirstRegGender mmReg | jne L8>
      ; xor op1 00_010_000_000 (???!!!...)
       mov op1 070 | gg_Value | ToOpcode op1         ; case 3
        imm8Size | or op2 B$FirstReg | LastOpcode op2
L8: BadOperand
____________________________________________________________________________________________
____________________________________________________________________________________________

; XMM job:

; example: ADDPS XMM1 XMM2
;          ADDPS XMM5 X$MyPackedData   ; (X$ or O$) (Sib allowed)

XMMXMM:
    ParmsAny 2
    ToOpcode 0F, op1
    cmp B$Operands RegToReg | jne L8>
        cmp B$FirstRegGender  XmmReg | jne L8>>
        cmp B$SecondRegGender XmmReg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al
L8: BadOperand


XmmMemXmmImm7:
ParmsAny 3
    On B$immInside = &FALSE, error D$EndingImmPtr
    On D$imm32 > 00111, BadOperandSize
        mov B$TrueSize ByteSize                 ; to ajust imm size to 8 bits storage
        jmp L0>>


XmmMemXmmImm8:
ParmsAny 3
    On B$immInside = &FALSE, error D$EndingImmPtr
    On D$imm32 > 0FF, BadOperandSize
        mov B$TrueSize ByteSize                 ; to ajust imm size to 8 bits storage
        jmp L0>

XmmMemXmmImm3:
ParmsAny 3
    On B$immInside = &FALSE, error D$EndingImmPtr
    On D$imm32 > 0011, BadOperandSize
        mov B$TrueSize ByteSize                 ; to ajust imm size to 8 bits storage
        jmp L0>

XmmMemXmmImmFF:
ParmsAny 3
    On B$immInside = &FALSE, error D$EndingImmPtr
        mov B$TrueSize ByteSize                 ; to ajust imm size to 8 bits storage
        jmp L0>


;Xmmgg2:  gg_Value >>> now gg2 extended

XMMmemXMM:
    ParmsAny 2
L0: ToOpcode 0F, op1
    cmp B$Operands RegToReg | jne L2>
        cmp B$FirstRegGender  XmmReg | jne L8>>
        cmp B$SecondRegGender XmmReg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MemToReg | jne L8>
        cmp B$SecondOperandwbit xSize | je L1>
        cmp B$SecondOperandwbit OctoSize | jne L7>
L1:     cmp B$FirstRegGender XmmReg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


MMXmemXMM:
    ParmsAny 2
L0: ToOpcode 0F, op1
    cmp B$Operands RegToReg | jne L2>
        cmp B$FirstRegGender  mmReg | jne L8>>
        cmp B$SecondRegGender XmmReg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MemToReg | jne L8>
        cmp B$SecondOperandwbit xSize | je L1>
        cmp B$SecondOperandwbit OctoSize | jne L7>
L1:     cmp B$FirstRegGender mmReg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


mmXmm:
    ParmsAny 2
L0: ToOpcode 0F, op1
    cmp B$Operands RegToReg | jne L8>
        cmp B$FirstRegGender  mmReg | jne L8>>
        cmp B$SecondRegGender XmmReg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


Xmmmm:
    ParmsAny 2
L0: ToOpcode 0F, op1
    cmp B$Operands RegToReg | jne L8>
        cmp B$FirstRegGender  XmmReg | jne L8>>
        cmp B$SecondRegGender mmReg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


; Example CVTSI2SS xmm1 eax
;         CVTSI2SS xmm D$memory

DwordToLowXMM:
    ParmsAny 2
    ToOpcode 00_11110011, 001111, op1
    cmp B$Operands RegToReg | jne L2>
        cmp B$FirstRegGender  XmmReg | jne L8>>
        cmp B$SecondRegGender Reg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MemToReg | jne L8>
        cmp B$SecondOperandwbit doubleSize | jne L7>
        cmp B$FirstRegGender XmmReg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


DwordToLowXMMWithF2:
    ParmsAny 2
    ToOpcode 00_11110010, 001111, op1
    cmp B$Operands RegToReg | jne L2>
        cmp B$FirstRegGender  XmmReg | jne L8>>
        cmp B$SecondRegGender Reg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MemToReg | jne L8>
        cmp B$SecondOperandwbit doubleSize | jne L7>
        cmp B$FirstRegGender XmmReg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


; Example: CVTTPS2SI ebx xmm3
;          CVTTPS2SI edx O$memory

LowXMMtoDword:
    ParmsAny 2
    ToOpcode 00_11110011, 001111, op1
    cmp B$Operands RegToReg | jne L2>
        cmp B$FirstRegGender  Reg | jne L8>>
        cmp B$SecondRegGender XmmReg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MemToReg | jne L8>
        cmp B$SecondOperandwbit OctoSize | je L1>
        cmp B$SecondOperandwbit XSize | jne L7>
L1:     cmp B$FirstRegGender Reg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


LowXMMtoDwordWithF2:
    ParmsAny 2
    ToOpcode 00_11110010, 001111, op1
    cmp B$Operands RegToReg | jne L2>
        cmp B$FirstRegGender  Reg | jne L8>>
        cmp B$SecondRegGender XmmReg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MemToReg | jne L8>
        cmp B$SecondOperandwbit OctoSize | je L1>
        cmp B$SecondOperandwbit XSize | jne L7>
L1:     cmp B$FirstRegGender Reg | jne L8>>
            mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


XMMmemXMMmem:
    ParmsAny 2
    ToOpcode 0F
    cmp B$Operands RegToReg | jne L2>
        cmp B$FirstRegGender  XmmReg | jne L8>>
        cmp B$SecondRegGender XmmReg | jne L8>>
            ToOpcode op1
            mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MemToReg | jne L2>
        cmp B$SecondOperandwbit xSize | je L1>
        cmp B$SecondOperandwbit OctoSize | jne L7>
L1:     cmp B$FirstRegGender XmmReg | jne L8>>
            ToOpcode op1
            mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L2: cmp B$Operands RegToMem | jne L8>
        cmp B$FirstOperandwbit xSize | je L1>
        cmp B$FirstOperandwbit OctoSize | jne L7>
L1:     cmp B$SecondRegGender XmmReg | jne L8>>
            or op1 1 | ToOpcode op1
            mov al B$SecondReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


; Special for MOVSS, that deals with one F$ mem:

XMMmem32XMMmem32:
    ParmsAny 2
    ToOpcode 0F
    cmp B$Operands RegToReg | jne L2>
        cmp B$FirstRegGender  XmmReg | jne L8>>
        cmp B$SecondRegGender XmmReg | jne L8>>
            ToOpcode op1
            mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MemToReg | jne L2>
        cmp B$SecondOperandwbit doubleSize | je L1>
        cmp B$SecondOperandwbit xSize | je L1>
        cmp B$SecondOperandwbit OctoSize | jne L7>
L1:     cmp B$FirstRegGender XmmReg | jne L8>>
            ToOpcode op1
            mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L2: cmp B$Operands RegToMem | jne L8>
        cmp B$FirstOperandwbit doubleSize | je L1>
        cmp B$FirstOperandwbit xSize | je L1>
        cmp B$FirstOperandwbit OctoSize | jne L7>
L1:     cmp B$SecondRegGender XmmReg | jne L8>>
            or op1 1 | ToOpcode op1
            mov al B$SecondReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


; Same as uper but with "xor op1 0010000" (instead of "or 1").
; For MOVQ/MOVDQA/MOVDQU only.

MovqXMMmemXMMmem:
    ParmsAny 2
    ToOpcode 0F
    cmp B$Operands RegToReg | jne L2>
        cmp B$FirstRegGender  XmmReg | jne L8>>
        cmp B$SecondRegGender XmmReg | jne L8>>
            ToOpcode op1
            mov al B$FirstReg | shl al 3 | or al 00_11_000_000 | or al B$SecondReg
            LastOpcode al

L2: cmp B$Operands MemToReg | jne L2>
        cmp B$SecondOperandwbit xSize | je L1>
        cmp B$SecondOperandwbit QuadSize | jne L7>
L1:     cmp B$FirstRegGender XmmReg | jne L8>>
            ToOpcode op1
            mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L2: cmp B$Operands RegToMem | jne L8>
        cmp B$FirstOperandwbit xSize | je L1>
        cmp B$FirstOperandwbit QuadSize | jne L7>
L1:     cmp B$SecondRegGender XmmReg | jne L8>>
            xor op1 0010000 | ToOpcode op1
            mov al B$SecondReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


XMMtoFromMem:
    ParmsAny 2
    ToOpcode 0F

    cmp B$Operands MemToReg | jne L2>
        cmp B$SecondOperandwbit xSize | je L1>
        cmp B$SecondOperandwbit OctoSize | jne L7>
L1:     cmp B$FirstRegGender XmmReg | jne L8>>
            ToOpcode op1
            mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L2: cmp B$Operands RegToMem | jne L8>
        cmp B$FirstOperandwbit xSize | je L1>
        cmp B$FirstOperandwbit OctoSize | jne L7>
L1:     cmp B$SecondRegGender XmmReg | jne L8>
            or op1 1 | ToOpcode op1
            mov al B$SecondReg | shl al 3 | or al B$ModBits | or al B$RmBits
            LastOpcode al

L7: BadOperandSize
L8: BadOperand


XMMtoMem:
    ParmsAny 2
    ToOpcode 0F | jmp L2<
;;
 Exemple for Xmm4:      MOVD - Move doubleword N N Y N

   reg to Xmmreg    0000 1111:01101110: 11 Xmmreg1 reg2   ; movd XMM0 eax
   reg from Xmmxreg 0000 1111:01111110: 11 Xmmreg2 reg1   ; movd eax XMM0
   mem to Xmmxreg   0000 1111:01101110: mod Xmmreg1 r/m   ; movd XMM0 D$val
   mem from Xmmxreg 0000 1111:01111110: mod Xmmreg2 r/m   ; movd D$val XMM0

 2 mnemonics only for mm4. In both cases op1 (true second opcode) is the same for the
 4 cases, but with 00_10000 add in cases 2 and 4.

 This is exactely the same encoding as for mmFour, but with an added 066 prefix. So:
;;

XmmFour:
    ToOpcode 066
    cmp B$FirstRegGender XmmReg | jne L1>
        mov B$FirstRegGender mmReg | jmp mmFour
L1: cmp B$SecondRegGender XmmReg | jne L1>
        mov B$SecondRegGender mmReg | jmp mmFour
L1: BadOperand


____________________________________
; These Routines are for 066 prefixed for SSE SIMD Integer Instructions.

; Example: PAVGB mm1,  mm2/m64    (0F E0 /r)
;          PAVGB xmm1, xmm2/m128  (66 0F E0, /r)

OQregMemToReg:
    ParmsAny 2
    ..If B$Operands = RegToReg
        .If B$FirstRegGender = MMreg
            If B$SecondRegGender = MMreg
                ToOpcode 0F, op1
                mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                LastOpcode al
            End_If
            BadOperand

        .Else_If B$FirstRegGender = XMMreg
            If B$SecondRegGender = XMMreg
                ToOpcode 066, 0F, op1
                mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                LastOpcode al
            End_If
            BadOperand

        .End_If
        BadOperand

    ..Else_If B$Operands = MemToReg
        On B$SecondOperandwbit = xSize, mov B$SecondOperandwbit Octosize
        .If B$FirstRegGender = MMreg
            If B$SecondOperandwbit = QuadSize
                ToOpcode 0F, op1
                mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
                LastOpcode al
            End_If
            BadOperandSize
        .Else_If B$FirstRegGender = XMMreg
            If B$SecondOperandwbit = OctoSize
                ToOpcode 066, 0F, op1
                mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
                LastOpcode al
            End_If
            BadOperandSize

        .End_If
        BadOperand
    ..End_If
    BadOperand

;;
 Example: PEXTRW r32,  mm, imm8  (0F C5 /r ib)
          PEXTRW r32, xmm, imm8  (66 0F C5 /r ib) (Actually used only for PEXTRW)

 Note: Encodage of Registers fields are given in reverse of usual order in Intel Doc.
 Don't know if it is an error or not. I set here the record as given > to be controled.
 (same for PINSRW).
 
 'Werewolf' says it should be reversed. Therefore the replacement.
;;

OQregRegImm8:
    ParmsAny 3
    On B$immInside = &FALSE, error D$EndingImmPtr
    cmp B$Operands RegToReg | jne L9>
        cmp B$FirstRegGender reg | jne L9>
            mov B$TrueSize ByteSize                 ; to ajust imm size to 8 bits storage
            cmp B$SecondRegGender XMMreg | jne L1>
                cmp D$Imm32, 00111 | ja L8>
                ToOpcode 066 | jmp L2>
L1:         cmp B$SecondRegGender MMreg | jne L9>
                cmp D$Imm32, 0011 | ja L8>
L2:                 ToOpcode 0F, op1
                    ;mov al B$SecondReg | shl al 3 | or al 0011_000_000 | or al B$FirstReg ;!!!!
                    mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                    LastOpcode al

L8: BadOperandSize
L9: BadOperand


; Example: PINSRW  mm, r32/mem16, imm8 ; <<<< this one in reserse order too !!!!!!!!!!!!!!!!
;          PINSRW xmm, r32/mem16, imm8
;
; in all case mm (xmm) apear as regBits.

OQregMemImm8:
    ParmsAny 3
    On B$immInside = &FALSE, error D$EndingImmPtr
    mov B$TrueSize ByteSize                 ; to ajust imm size to 8 bits storage
    ..If B$Operands = RegToReg
        .If B$FirstRegGender = MMreg
            If B$SecondRegGender = reg
                cmp D$Imm32, 0011 | ja L8>>
                ToOpcode 0F, op1
                mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                LastOpcode al
            End_If
            BadOperand

        .Else_If B$FirstRegGender = XMMreg
            If B$SecondRegGender = reg
                cmp D$Imm32, 00111 | ja L8>>
                ToOpcode 066, 0F, op1
                mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg
                LastOpcode al
            End_If
            BadOperand

        .End_If
        BadOperand


    ..Else_If B$Operands = MemToReg
        cmp B$SecondOperandwbit Wordsize | jne L8>>
        .If B$FirstRegGender = MMreg
                cmp D$Imm32, 0011 | ja L8>>
                ToOpcode 0F, op1
                mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
                LastOpcode al
        .Else_If B$FirstRegGender = XMMreg
                cmp D$Imm32, 00111 | ja L8>>
                ToOpcode 066, 0F, op1
                mov al B$FirstReg | shl al 3 | or al B$ModBits | or al B$RmBits
                LastOpcode al
        .End_If
        BadOperand
    ..End_If

    BadOperand
L8: BadOperandSize


; Example: MOVMSKB reg32  mmreg
;          MOVMSKB reg32 Xmmreg   ; here also dest at last

OQReg32Reg:
    ParmsAny 2
    cmp B$Operands RegToReg | jne L9>
        cmp B$FirstRegGender reg | jne L9>
            cmp B$SecondRegGender XMMreg | jne L1>
                ToOpcode 066 | jmp L2>
L1:         cmp B$SecondRegGender MMreg | jne L9>
L2:             ToOpcode 0F, op1
                mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$secondReg
                LastOpcode al

L9: BadOperand

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
 3D Now: out of FEMMS and PREFETCH/W, all 3D Now instructions aply on

 mmReg1, mmReg2/mm64

 and all start with 0F 0F, and end with the true opcode (suffix) written at last by
 EncodeLines
;;

[mm3Dsuffix: 0]

mm3D:
    ParmsAny 2 | ToOpcode 0F, 0F | mov B$mm3Dsuffix op1
    cmp B$FirstRegGender mmReg | jne L8>>
    cmp B$Operands RegToReg | jne L1>
        cmp B$SecondRegGender mmReg | jne L8>>
            mov op1 B$FirstReg | shl op1 3 | or op1 B$SecondReg
            or op1 00_11_000_000 | LastOpcode op1
L1: cmp B$Operands MemToReg | jne L8>
        On B$SecondOperandwBit <> QuadSize, error D$Mem3DPtr
        mov op1 B$FirstReg | shl op1 3 | or op1 B$ModBits | or op1 B$RmBits | LastOpcode op1
L8: BadOperand

 ________________________________________________________________________________________


op: Parms 0 | LastOpcode op1

op_P1: Parms 1 | LastOpcode op1

op_imm8: Parms 1 | imm8Size | LastOpcode op1

op_imm16: Parms 1 | imm16Size | LastOpcode op1

reg_in_op_imm: Parms 2 | GPreg1 | or op1 B$FirstReg | LastOpcode op1 ; for mov reg imm (alternate)

reg1_in_op: GPreg1 | or op1 B$FirstReg                       ; for dec / inc
op_dis: Parms 1 | lastOpcode op1

op_dis8: Parms 1 | dis8Size | LastOpcode op1

op_reg1: Parms 1 | GPreg1 | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

  ; This is only for push/pop sreg when reg is FS or GS. We overwrite the no use 066h
  ; previously written because of size:
op_sreg3: Parms 1 | dec edi | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

op_modRm: Parms 1 | ToOpcode op1 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

op_modRm_P2: Parms 2 | ToOpcode op1 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

op_reg2reg1:
  Parms 2 | GPreg1_2 | ToOpcode op1
  mov op1 B$SecondReg | shl op1 3 | or op1 B$FirstReg | or op2 op1 | LastOpcode op2

op_w_modReg1Rm:
  Parms 2 | GPreg1 | ToOpcode op1
  or op2 B$wBit | ToOpcode op2
  mov op3 B$FirstReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_w_modReg1RmX:
  XParms 2 | GPreg1 | ToOpcode op1
  or op2 B$wBit | ToOpcode op2
  mov op3 B$FirstReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_w_modreg2Rm:
  Parms 2 | GPreg2 | ToOpcode op1
  or op2 B$wBit | ToOpcode op2
  mov op3 B$SecondReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_w_reg2reg1:
  Parms 2 | GPreg1_2 | ToOpcode op1
  or op2 B$wBit | ToOpcode op2
  mov op1 B$SecondReg | shl op1 3 | or op3 op1 | or op3 B$FirstReg | LastOpcode op3

op_w_reg1reg2X:                ; special for B$wBit]s disagree in MOVSX / MOVZX
  XParms 2 | GPreg1_2 | ToOpcode op1
  or op2 B$wBit | ToOpcode op2
;  mov op1 B$SecondReg | shl op1 3 | or op3 op1 | or op3 B$FirstReg | LastOpcode op3
  mov op1 B$FirstReg | shl op1 3 | or op3 op1 | or op3 B$SecondReg | LastOpcode op3

op_modReg1Rm:
  Parms 2 | GPreg1 | ToOpcode op1
  mov op2 B$FirstReg | shl op2 3 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

op_modReg2Rm:
  Parms 2 | GPreg2 | ToOpcode op1
  mov op2 B$SecondReg | shl op2 3 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2
 ______________________________________________________________________________________

op_op: Parms 0 | ToOpcode op1 | LastOpcode op2

op_op_P1: Parms 1 | ToOpcode op1 | LastOpcode op2

op_op_P2: ParmsAny 2 | ToOpcode op1 | LastOpcode op2

op_op_dis: Parms 1 | ToOpcode op1 | LastOpcode op2

op_op_reg1:
  Parms 1 | GPreg1 | ToOpcode op1, op2
  or op3 B$FirstReg | LastOpcode op3

op_op_reg16:
  Parms 1 | GPreg1 | On B$FirstOperandWbit <> WordSize,  error D$VERRwordPtr
  ToOpcode op1, op2 | or op3 B$FirstReg | LastOpcode op3

op_op_reg1reg2:
  Parms 2 | GPreg1_2 | ToOpcode op1, op2
  mov op1 B$FirstReg | shl op1 3 | or op3 op1 | or op3 B$SecondReg | LastOpcode op3

op_op_reg1_imm8:
  Parms 2 | GPreg1 | imm8Size | ToOpcode op1, op2 | or op3 B$FirstReg | LastOpcode op3

op_op_reg2reg1:
  Parms 2 | GPreg1_2 | ToOpcode op1, op2
  mov op1 B$SecondReg | shl op1 3 | or op3 op1 | or op3 B$FirstReg | LastOpcode op3

op_op_reg2reg1_cl:
  Parms 3 | GPreg1_2
  On B$ThirdOperandWbit <> ByteSize,  error D$NeedByteSizePtr
  ToOpcode op1, op2
  mov op1 B$SecondReg | shl op1 3 | or op3 op1 | or op3 B$FirstReg | LastOpcode op3

op_op_reg2reg1_imm8:
  Parms 3 | imm8Size | GPreg1_2 | ToOpcode op1, op2
  mov op1 B$SecondReg | shl op1 3 | or op3 op1 | or op3 B$FirstReg | LastOpcode op3

op_op_modRm:
  Parms 1 | ToOpcode op1, op2 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_op_modRm16:
  Parms 1
  On B$FirstOperandWbit <> WordSize,  error D$VERRwordPtr
  ToOpcode op1 | ToOpcode op2 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3


op_op_modRm_imm8:
  Parms 2 | imm8Size | ToOpcode op1, op2
  or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_op_modReg2Rm:
  Parms 2 | GPreg2 | ToOpcode op1, op2
  mov op3 B$SecondReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_op_modReg2Rm_cl:
  Parms 3 | GPreg2 | ToOpcode op1, op2
  On B$ThirdOperandWbit <> ByteSize,  error D$NeedByteSizePtr
  mov op3 B$SecondReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_op_modReg2Rm_imm8:
  Parms 3 | GPreg2 | imm8Size | ToOpcode op1, op2
  mov op3 B$SecondReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

op_op_modReg1Rm:
  Parms 2 | GPreg1 | ToOpcode op1, op2
  mov op3 B$FirstReg | shl op3 3 | or op3 B$ModBits | or op3 B$RmBits | LastOpcode op3

 ________________________________________________________________________________________

OPw: Parms 0 | or op1 B$wBit | LastOpcode op1

w_P2: ParmsAny 2 | or op1 B$wBit | LastOpcode op1

w_imm8:
  Parms 2 | imm8Size | On B$SecondReg <> RegEax,  error D$OnlyAccPtr
  or op1 B$wBit | LastOpcode op1

w_imm: Parms 2 | or op1 B$wBit | lastOpcode op1

; w_dis is used only by MOV mem to accum.   or  accum. to mem.:

w_dis: Parms 2 | or op1 B$wBit | LastOpcode op1

w_reg1:
  Parms 1 | GPreg1 | or op1 B$wBit | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

w_reg1_P2:
  Parms 2 | imm8Size | GPreg1
  mov B$immInside &FALSE         ; exemple: SHL eax, 1  >>> no more imm
  or op1 B$wBit | ToOpcode op1
  or op2 B$FirstReg | LastOpcode op2

w_reg1_P2cl:
    ParmsAny 2 | GPreg1
    cmp B$SecondReg RegCL | jne L1>
    cmp B$SecondOperandWbit ByteSize | je L2>
L1:   error D$MixTypePtr
L2: or op1 B$FirstOperandWbit | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

w_reg1reg2:
  Parms 2 | GPreg1_2 | or op1 B$wBit | ToOpcode op1
  mov op1 B$FirstReg | shl op1 3 | or op2 op1 | or op2 B$SecondReg | LastOpcode op2

w_reg2reg1:
  Parms 2 | GPreg1_2 | or op1 B$wBit | ToOpcode op1
  mov op1 B$SecondReg | shl op1 3 | or op2 op1 | or op2 B$FirstReg | LastOpcode op2

w_reg1_imm8:
  Parms 2 | GPreg1 | imm8Size
  or op1 B$wBit | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

w_reg1_imm:
  Parms 2 | GPreg1 | or op1 B$wBit | ToOpcode op1 | or op2 B$FirstReg | LastOpcode op2

w_modRm:
  Parms 1 | or op1 B$wBit | ToOpcode op1
  or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

w_modRm_P2:
  Parms 2 | mov B$immInside &FALSE         ; exemple: SHL eax, 1  >>> no more imm
  or op1 B$wBit | ToOpcode op1
  or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

w_modRm_P2cl:
    ParmsAny 2
    On B$FirstOperandWbit = WordSize, ToOpcode 066
    cmp B$SecondReg RegCL | jne L1>
    cmp B$SecondOperandWbit ByteSize | je L2>
L1:   error D$MixTypePtr
L2: or op1 B$FirstOperandWbit | ToOpcode op1
    or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

w_modReg1Rm:
  Parms 2 | GPreg1 | or op1 B$wBit | ToOpcode op1
  mov op2 B$FirstReg | shl op2 3 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

w_modReg2Rm:
  Parms 2 | GPreg2 | or op1 B$wBit | ToOpcode op1
  mov op2 B$SecondReg | shl op2 3 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

w_modRm_imm8:
  Parms 2 | imm8Size | or op1 B$wBit | ToOpcode op1
  or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

w_modRm_imm:
  Parms 2 | or op1 B$wBit | ToOpcode op1
  or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

 _______________________________________________________________________________________


sw_reg1_imm:
  Parms 2 | GPreg1 | signImm
 ; On B$wBitDisagr&TRUEee = , or op1 B$sBit
  On B$FirstOperandWbit <> ByteSize,  or op1 B$sBit
  or op1 B$wBit | ToOpcode op1
  or op2 B$FirstReg | LastOpcode op2

sw_modRm_imm:
  Parms 2 | signImm
  ;On B$wBitDisagree = &TRUE,  or op1 B$sBit
  On B$FirstOperandWbit <> ByteSize,  or op1 B$sBit
  or op1 B$wBit | ToOpcode op1
  or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

 ________________________________________________________________________________________

s_reg1reg2_imm:      ; imul only: pb: can be 8 or 16 or 32 bits imm >>> sbts (?)
  Parms 3 | signImm | GPreg1_2
 ; On B$wBitDisagree = &TRUE,  or op1 B$sBit
 ;  On B$FirstOperandWbit <> ByteSize,  or op1 B$sBit     ; supposed of no use...
  or op1 B$sBit | ToOpcode op1
  mov op1 B$FirstReg | shl op1 3 | or op2 op1 | or op2 B$SecondReg | LastOpcode op2

s_modReg1Rm_imm:     ; idem
  Parms 3 | signImm | GPreg1
  ; On B$wBitDisagree = &TRUE, ...   ; supposed of no use...
  or op1 B$sBit | ToOpcode op1
  mov op2 B$FirstReg | shl op2 3 | or op2 B$ModBits | or op2 B$RmBits | LastOpcode op2

 ; used by 'push imm' only:
s_imm: Parms 1 | mov B$TrueSize DoubleSize | signImm | or op1 B$sBit | LastOpcode op1

s_imm16: Parms 1 | ToOpcode 066 | mov B$TrueSize wordSize | signImm | or op1 B$sBit
         LastOpcode op1

 _________________________________________________________________________________________

sReg2:    ; for POP only. Nothing special here because segment regs are greater code
          ; than 0111B
          ;
          ; a 066h prefix have been written because of size. This is no use for this:
  dec edi
  Parms 1 | or op1 B$FirstReg | LastOpcode op1

 _________________________________________________________________________________________

 ; Only for XCHG with EAX as second register:

XOPreg1: Parms 2 | or op1 B$FirstReg | LastOpcode op1













TITLE Error
 _________________________________________________________________________________________
 _________________________________________________________________________________________
;;
 'error' deal. 'OutOnError'

 how it works:

 Because of the structure of RosAsm (multiple passes with source transformations), pointing
 a bad statement, in true source file is a real head break. I thaught of two solutions:
 line numbers, that would allowed jumping from one state to a previous one, and error
 level flag that would allowed jumping to specific error check routines level-dependant.
 i choose the second solution. Heavy, but it works,... as far as i can know. Sometimes
 dirty; always difficult to understand. Sorry; after 3 writings from scratch, i think it
 can't be really simple anyway.

 In this version, 2 main routines (+ others...) are used, depending on the fact that the 
 error occurred inside EOIs (|...|) or inside brackets ([...]). Some ajustements are made:
 
- when a statement is the result of macro expending (doesn't exist in first source text),
 it is inside 'meEOIs' (Macro expension End Of Instruction) so that they are not counted
 in 'StatementCounter'.
 
- when error occur in data storing work any 'non data' bracket must be added to
 'bracketCounter'
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[OldStackPointer: ?]

[bracketCounter: ?  StatementsCounter: ?  ErrorLevel: ?  InsideBracket: ?
 InsideComment: ?   InsideMLC: ?]

[Error | pushad | CookedError #2>L | popad | mov eax, #1 | jmp OutOnError]

[CookedError | mov esi #1 | call ViewCookedError]
 ________________________________________________________________________________________

[LinesCounter: ?    DontCountNext: ?    EndingComma: ?
 StatementsTable: ?    StatementsTable2: ?    StatementsPtr: ?    StatementsPtr2: ?]

TestStatementsTable:
    mov ecx 25, esi D$StatementsTable

L0: lodsd

    If eax = 0
        hexprint 0 | jmp L9>
    Else_If eax < D$CodeSource
        hexprint 0
    Else_If eax > D$SourceEnd
        Hexprint 0-1
    Else
        mov ebx eax | add ebx 3
        mov dl B$ebx, B$OldChar dl, B$ebx 0, D$OldCharPos ebx

        pushad
            mov esi eax
            call SetDebuggeeText
            call AskForRedrawNow
        popad
        hexprint eax ; for viewing the source.
    End_If
  ; Uses '25',for partial testing of big Files:
  ; loop L0<
    jmp L0<

L9: ret
_____________________________________________________________________________________

; final error prompting:

[ErrorMessagePtr: ?]

ShowError:
; First, we make the MessageBox a little wider if the title is longer than the Message.
; Win set the Box width on the Message (not on the Title).
    pushad
        mov ecx 10, edx 0
        While B$eax > 0
            inc eax | inc ecx        ; > lenght of Title
        End_While
        mov edi Trash2
        While B$esi <> 0FF
            movsb | inc edx          ; lenght of Message Text
        End_While

        If edx < ecx
            sub ecx edx
            shl ecx 1
            mov al ' ' | rep stosb   ; ajusts text widht around the title width
        End_If
;;
  If CookedErrorMessage Buffer is not empty, this is because Errror Macro has been
  evocated with two Parameters 1) Error Title 2) Pointer to the internal Member of
  the Instruction that produced the error. If two Parameters, we add this Member
  under the Statement viewed in the Dialog Box. 'CookedErrorMessage' has been "Un-Cooked"
  by 'ViewCookedError'.
;;
        If D$CookedErrorMessage = 0
            mov al 0 | stosb
        Else
            mov W$edi CRLF, W$edi+2 CRLF | add edi 2 ;4
            mov D$edi '>>> ' | add edi 4
            mov esi CookedErrorMessage

            While B$esi <> 0
                movsb | On esi = EndOfCookedErrorMessage, jmp L1>
            End_While
L1:         mov B$edi 0

        End_If

        mov esi D$OldCharPos, al B$OldChar, B$esi al
        dec esi | mov D$BlockEndTextPtr esi
    popad
    pushad
      ;call ErrorMessageBox Trash2, eax
      call ReleaseAsmTables
    popad

    call SetDebuggeeText

    call ErrorMessageBox Trash2, D$ErrorMessagePtr
ret


SetDebuggeeText:
    mov D$BlockStartTextPtr esi, D$UpperLine esi, D$CurrentWritingPos esi

    call TryToMove

    mov ebx 0, esi D$UpperLine               ; Where is the block at screen?
L0: lodsb | On al = LF, inc ebx
    cmp esi D$BlockStartTextPtr | jb L0<

    mov ecx D$LineNumber | shr ecx 1         ; if higher than half screen,
    shr ecx 1
    .If ebx < ecx                             ; scroll to half screen.
        sub ecx ebx                           ; if down, we are at end of source...

      ; Also, don't move, for error pointing, upper than possible:
        If D$ActualTitle <> 0
            mov edx D$ActualTitle
        Else
            mov edx D$CodeSource
        End_If

L2:     cmp D$UpperLine edx | jbe L3>
        call UpOneLine | loop L2<
   .End_If

L3: mov B$blockInside &TRUE

    mov esi D$OldCharPos, al B$OldChar, B$esi al

    call SearchForEndOfErrorBlock
    call SetCaret D$BlockEndTextPtr

  ; Clear possible previous ShiftPos, in case user first hit [Shift] right after
  ; the error isq pointed out:
    move D$ShiftBlockCol D$CaretRow, D$ShiftBlockLine D$CaretLine

    call AskForRedrawNow
ret


[LastErrorBlockPipe: ?]

SearchForEndOfErrorBlock:
    mov esi D$BlockStartTextPtr, ecx 0, D$LastErrorBlockPipe 0
    On B$esi = '[', jmp SearchForEndOfErrorBracketBlock

L0: lodsb | On esi = D$SourceEnd, jmp L2>>

    If al = "'"
        While B$esi <> "'" | inc esi | On esi = D$SourceEnd, jmp L2>>
        End_While | inc esi
        mov ecx 0
    Else_If al = '"'
        While B$esi <> '"' | inc esi | On esi = D$SourceEnd, jmp L2>
        End_While | inc esi
        mov ecx 0
    Else_If al = ';'
        On ecx = 0, jmp L2>
        While B$esi >= ' ' | inc esi | On esi = D$SourceEnd, jmp L2>
        End_While | add esi 2
    Else_If al = ','
        mov ecx 1
    Else_If al = '|'
        On D$LastErrorBlockPipe = 0, mov D$LastErrorBlockPipe, esi
    Else_If al < ' '
        On ecx = 0, jmp L2>
    Else_If al = ' '

    Else
        mov ecx 0
    End_If
    jmp L0<<

L2: sub esi 2 | mov D$BlockEndTextPtr esi
    If D$LastErrorBlockPipe <> 0
        mov eax D$LastErrorBlockPipe | sub eax 2 | mov D$BlockEndTextPtr eax
    End_If

    move D$CurrentWritingPos D$BlockEndTextPtr
ret


SearchForEndOfErrorBracketBlock:
L0: lodsb | On esi = D$SourceEnd, jmp L2>

    If al = "'"
        While B$esi <> "'" | inc esi | End_While | inc esi
    Else_If al = '"'
        While B$esi <> '"' | inc esi | End_While | inc esi
    Else_If al = ';'
        While B$esi >= ' ' | inc esi | End_While | add esi 2
    Else_If al = ']'
        jmp L2>
    End_If
    jmp L0<

L2: mov D$BlockEndTextPtr esi
ret

 _________________________________________________________________________________________

[CompileErrorHappend: B$ ?    FirstPass: ?]

OutOnError:
    mov D$ErrorMessagePtr eax

    mov B$CompileErrorHappend &TRUE, D$NextSearchPos 0

    On B$WeAreChecking = &TRUE, ret
    On B$WeAreUnfolding = &TRUE, jmp UnfoldingError
   ; Error in the second part of the Encode-DecodeBox 'B$Errorlevel 7'
    On B$Errorlevel = 7,  jmp EncodeError
    On B$WeAreInTheCodeBox = &TRUE, jmp EncodeBoxError

    cld
L0: mov esp D$OldStackPointer               ; restor stack (...comming from anywhere)

L1: pushad________________________________________________________________________________________________________________________________________________________________________________________


       call CloseProgressBar
    popad

    On B$Errorlevel = 0,  jmp Error0        ; open text error in 'SourceCleaner'
    On B$Errorlevel = 1,  jmp Error1        ; error inside square bracket
    On B$Errorlevel = 2,  jmp Error2        ; error in statements
    On B$Errorlevel = 3,  jmp Error3        ; error inside     ;;;;;;;;;;;;StoreDatas
    On B$Errorlevel = 4,  jmp Error4        ; error in DLL name ; mov B$Errorlevel 1
    On B$Errorlevel = 5,  jmp Error5        ; error in api name  ; mov B$Errorlevel 5
    On B$Errorlevel = 6,  jmp Error6        ; error in the form of api call
  ; Error7 is reserved for the Encode-Decode Box.
    On B$Errorlevel = 8,  jmp Error8        ; error in Win Equate Name
    On B$Errorlevel = 11,  jmp Error11      ; error in ClASSes
   ; On B$Errorlevel = 12,  jmp Error12      ; Short Displacement error

  ; Error9 (or none) falls there:
    call AskForRedrawNow

    If D$CookedErrorMessage <> 0
        call ErrorMessageBox CookedErrorMessage, D$ErrorMessagePtr
    Else
        call ErrorMessageBox 0, D$ErrorMessagePtr
    End_If

    call ReleaseAsmTables

    ret ; for 'no search' errors (esi known) or 'Main:' missing

____________________________________________________________________________________________

[DashLine: '___________________', 0]

;;
  To YeoH: '.zh' should be the extension of your 'RosAsmStrings' File.
  
  I hope you will succeed to make this "...If D$StringsLanguage = '.zh'" work... ;)
  As, off course, as you may guess, i cannot see anything on my Computer...
;;

Proc ErrorMessageBox:
    Arguments @Text1, @Text2

        ...If D$StringsLanguage = '.zh'
          ; Unicode:
            mov esi D@Text1, edi Trash1, ecx 0
            If esi <> 0
                While W$esi > 0
                    movsw | inc ecx | cmp ecx 400 | ja L1>
                End_While
            End_If
L1:         mov W$edi 0

            .If D@Text2 <> 0
                mov esi D@Text2, edi Trash2, ecx 0
                If esi <> 0
                    While W$esi > 0
                        movsw | inc ecx | cmp ecx 400 | ja L1>
                    End_While
                End_If
L1:             mov W$edi 0
            .Else
                mov W$Trash2 0
            .End_If

          ; Tag Dialog 10

            call 'USER32.DialogBoxIndirectParamW' D$hinstance, ErrorUnicodeDialog,
                                                  &NULL, ErrorMessageProcW, &NULL

        ...Else
          ; Ascii:
            If D@Text1 <> 0
                mov esi D@Text1, edi Trash1, ecx 0 | mov D$edi CRLF | add edi 2
                While B$esi > 0
                    movsb | inc ecx | cmp ecx 400 | ja L1>
                End_While
            End_If
L1:         mov B$edi 0

            .If D@Text2 <> 0
                mov esi D@Text2, edi Trash2, ecx 0 | mov D$edi CRLF | add edi 2
                If esi <> 0
                    While B$esi > 0
                        movsb | inc ecx | cmp ecx 400 | ja L1>
                    End_While
                End_If
L1:             mov B$edi 0
            .Else
                mov B$Trash2 0
            .End_If

            mov al B$Trash1+2 | or al B$Trash2
          ; Tag Dialog 10
            On al <> 0,
            call 'USER32.DialogBoxParamA' D$hinstance, 10, D$hWnd, ErrorMessageProcA, &NULL

        ...End_If
EndP


[SongFontHandle: ?]

[ErrorUnicodeDialog: D$ 090CC08C2 0        ; Style
 U$ 03 0 0 0DC 065             ; Dim
 0                             ;      no Menu
 '' 0                          ; Class
 '' 0                          ; Title
 12 'SimSun' 0]                ; Font  MS Song // SimSun  //   'MS Song', 0] ;

[Control0000: D$ 050800004 0      ; Style
 U$ 0 01 0DC 028               ; Dim
 0A                            ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

[Control0001: D$ 050800004 0      ; Style
 U$ 0 02A 0DC 028              ; Dim
 014                           ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

[Control0002: D$ 050000000 0      ; Style
 U$ 050 054 037 010            ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data


[uError: U$ 'Error', 0]

; Tag Dialog 10

Proc ErrorMessageProcW:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_INITDIALOG
        call 'USER32.SetClassLongW' D@Adressee, &GCL_HICON, D$wc_hIcon

        call 'User32.SendDlgItemMessageW' D@Adressee, 10, &WM_SETFONT,
                                              D$Font1Handle, &FALSE

        On D$NationalFontHandle <> 0,
            call 'User32.SendDlgItemMessageW' D@Adressee, 20, &WM_SETFONT,
                                              D$NationalFontHandle, &FALSE

        call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &EM_SETMARGINS,
                                          &EC_LEFTMARGIN__&EC_RIGHTMARGIN, 10
        call 'USER32.SendDlgItemMessageW' D@Adressee, 20, &EM_SETMARGINS,
                                          &EC_LEFTMARGIN__&EC_RIGHTMARGIN, 10

        call 'USER32.SendMessageW' D@Adressee, &WM_SETTEXT, &NULL, uError
                                   ;D$ErrorMessageTitlePtr

        call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &WM_SETTEXT, 0, Trash1

        On B$trash2 <> 0,
        call 'USER32.SendDlgItemMessageW' D@Adressee, 20, &WM_SETTEXT, 0, Trash2

        call 'User32.GetDlgItem' D@Adressee, 1
        call 'USER32.SetFocus' eax

        jmp L8>>
;;
    ...Else_If D@Message = &WM_SETFONT
        If D$NationalFontHandle <> 0
            popad | mov eax D$NationalFontHandle | ExitP
        End_If
;;
    ...Else_If D@Message = &WM_COMMAND
        mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        If D@wParam = &IDCANCEL
            call 'USER32.EndDialog' D@Adressee, &NULL

        Else_If D@wParam = &IDOK
            call 'USER32.EndDialog' D@Adressee, &NULL

        End_If

    ...Else_If D@Message = &WM_CTLCOLOREDIT
        call 'USER32.SendMessageW' D@lParam, &EM_SETSEL, 0-1, 0
        call 'GDI32.SetBkColor' D@wParam, D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | ExitP

    ...Else
L8:     popad | mov eax &FALSE | ExitP

    ...End_If

    popad | mov eax &TRUE
EndP


Proc ErrorMessageProcA:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_INITDIALOG
        call 'USER32.SetClassLongA' D@Adressee, &GCL_HICON, D$wc_hIcon

        call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &EM_SETMARGINS,
                                        &EC_LEFTMARGIN__&EC_RIGHTMARGIN, 10

        call 'USER32.SendMessageA' D@Adressee, &WM_SETTEXT, &NULL,
                                   D$ErrorMessageTitlePtr

        call 'USER32.SendDlgItemMessageA' D@Adressee, 20, &EM_SETMARGINS,
                                        &EC_LEFTMARGIN__&EC_RIGHTMARGIN, 10


        call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &WM_SETTEXT, 0, Trash1

        On D$NationalFontHandle <> 0,
            call 'User32.SendDlgItemMessageA' D@Adressee, 20, &WM_SETFONT,
                                              D$NationalFontHandle, &FALSE

        call 'User32.SendDlgItemMessageW' D@Adressee, 10, &WM_SETFONT,
                                              D$Font1Handle, &FALSE

        On B$trash2 <> 0,
            call 'USER32.SendDlgItemMessageA' D@Adressee, 20, &WM_SETTEXT, 0, Trash2

        call 'User32.GetDlgItem' D@Adressee, 1
        call 'USER32.SetFocus' eax

        jmp L8>>

    ...Else_If D@Message = &WM_COMMAND

        If W@wParam = &IDCANCEL
            call 'USER32.EndDialog' D@Adressee, &NULL
        Else_If W@wParam = &IDOK
            call 'USER32.EndDialog' D@Adressee, &NULL
        End_If

    ...Else_If D@Message = &WM_CTLCOLOREDIT
        call 'USER32.SendMessageA' D@lParam, &EM_SETSEL, 0-1, 0
        call 'GDI32.SetBkColor' D@wParam, D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | ExitP

    ...Else
L8:     popad | mov eax &FALSE | ExitP

    ...End_If

    popad | mov eax &TRUE
EndP


____________________________________________________________________________________________

[CookedErrorMessage: ? #20] [EndOfCookedErrorMessage: ? ?]

;;
  This shows the internal Source of error. Can't work actually as i don't know how to
  to make sure that esi points to something inside the Assembler Tables Memory, and i
  don't find any function that would say if the pointer is valid or not. Nothing like
  'ReadProcessmemory' in the Debugger. There is 'KERNEL32.SetErrorMode', but i don't
  know if it works or not for x86, and what Message is suppose to be sent back.
  
  Would probably require SEH...
;;

ViewCookedError:
    pushad
        While B$esi > EOI | dec esi | End_While | inc esi

        mov edi CookedErrorMessage

L0:     lodsb
        .If al = TextSign
            mov al '"'
        .Else_If al = numSign
            mov al '#'
        .Else_If al = CommaSign
            mov al ','
        .Else_If al = OpenVirtual
            mov al '{'
        .Else_If al = CloseVirtual
            mov al '}'
        .Else_If al = Openbracket
            mov al '['
        .Else_If al = Closebracket
            mov al ']'
        .Else_If al = memMarker
            mov al '$'
        .Else_If al = colonSign
            mov al ':'
        .Else_If al = openSign
            mov al '('
        .Else_If al = closeSign
            mov al ')'
        .Else_If al = addSign
            mov al '+'
        .Else_If al = subSign
            mov al '-'
        .Else_If al = mulSign
            mov al '*'
        .Else_If al = divSign
            mov al '/'
        .Else_If al = expSign
            mov al '^'
        .Else_If al = Space
            mov al ' '
        .Else_If al = EOI
            mov al '|' | jmp L9>
        .Else_If al = meEOI
            mov al '|'
        .End_If

        stosb

        On edi < EndOfCookedErrorMessage, jmp L0<<

L9:     mov B$edi 0

    popad
ret

 _________________________________________________________________________________________

; open text error in 'SourceCleaner'

[OldChar: ?    OldCharPos: ?]

SetEndOfErrorText:

    mov esi D$StatementsPtr, esi D$esi

    .If esi < D$CodeSource
        mov esi D$CodeSource

    .Else_If esi > D$SourceEnd
        mov esi D$SourceEnd | std
L0:     lodsb
        If al = LF
            inc esi ; stop
        Else_If al = '|'
            inc esi ; stop
        Else_If al = '['
                    ; stop
        Else_If esi > D$CodeSource
                    ; stop
        Else
            jmp L0<
        End_If
        cld
    .End_If

DirectSourcePointing:
    mov ecx 200
    push esi, eax
L0:     lodsb
        If al <= CR
            dec esi ; stop
        Else_If al = '|'
            dec esi ; stop
        Else_If al = ']'
                    ; stop
        Else_If esi > D$SourceEnd
                    ; stop
        Else
            loop L0<
        End_If
        mov al B$esi, B$OldChar al, B$esi 0FF, D$OldCharPos esi
        dec esi | mov D$BlockEndTextPtr esi  ;, D$CurrentWritingPos esi ; ?Case of Bad Pos?
    pop eax esi

    call VerifyNotOneChar
ret


; Because Blocks of one char was not outputed, in older version of the Editor.
; Should be of no more use now:

VerifyNotOneChar:
    push esi, eax
        mov eax D$BlockEndTextPtr
        cmp eax D$BlockStartTextPtr | ja L9>
            inc D$BlockEndTextPtr
            mov eax D$BlockEndTextPtr, al B$eax
                On al = CR, inc D$BlockEndTextPtr
                mov esi D$OldCharPos, al B$OldChar, B$esi al
                mov esi D$BlockEndTextPtr | inc esi
                mov al B$esi, B$OldChar al, B$esi 0FF, D$OldCharPos esi
L9: pop eax, esi
ret


Error0:

    call SetEndOfErrorText

    jmp ShowError
 _________________________________________________________________________________________

; error inside square bracket: we search [bracketCounter] square bracket number

Error1:
    push eax
      mov esi, D$CodeSource | mov ecx, 0
L1:   lodsb | cmp al '"' | jne L3>
L2:   lodsb | cmp al '"' | jne L2<         ; strip "text"
        jmp L1<
L3:   cmp al "'" | jne L5>
L4:   lodsb | cmp al "'" | jne L4<         ; strip 'text'
        jmp L1<


L5: cmp al ';' | jne L7>                     ; jmp over comments
        If D$esi-2 = MLC   ; (LF ; ; CR)
            Do
                inc esi | cmp esi D$SourceEnd | jae L9>
            Loop_Until D$esi = MLC
            add esi 3 | cmp esi D$SourceEnd | jae L9>
        Else
L6:         lodsb | cmp al LF | jne L6<
        End_If
        jmp L1<

;L5:   cmp al ';' | jne L7>
;L6:   lodsb | cmp al LF | jne L6<          ; strip comments
;        jmp L1<

L7:   cmp al '[' | jne L1<
        inc ecx | cmp ecx D$bracketCounter | jb L1<

      push esi
L8:     lodsb | cmp al ']' | jne L8<
          mov al B$esi, B$esi 0FF, B$OldChar al, D$OldCharPos esi
      pop esi
L9: pop eax

    dec esi | jmp ShowError
 _________________________________________________________________________________________

; error in statements. We search D$StatementsCounter '|' number
; Nothing but a modified version of text cleaner first part.

Error2:
    mov esi D$StatementsCounter
 ; showme eax
    push esi, eax
L0:     lodsb
        If al = CR
            dec esi ; stop
        Else_If al = '|'
            dec esi ; stop
        Else_If al = ']'
                    ; stop
        Else_If esi > D$SourceEnd
                    ; stop
        Else
            jmp L0<
        End_If

    mov al B$esi, B$OldChar al, D$OldCharPos esi, B$esi 0FF

    pop eax esi

    jmp ShowError

 ________________________________________________________________________________________
;;
 error inside ReplaceEquate in brackets statements or...
 error inside StoreData: value in [bracketCounter] did not count equates and macros
 so that we have to do a new count in ecx before jumping to error1 bracket research.
;;

Error3:
;;
 now: ecx = lenght, esi > start of bad Name in Data.
 Used now only by 'SearchRegularLabel' when filling Data symbols evocations. At this
 time, we do not have any more the source Data pointers available in "StatementsTable".
;;
    pushad

    While B$esi-1 > LowSigns | dec esi | End_While

    push esi
        mov ecx 1
        While B$esi > LowSigns | inc esi | inc ecx | End_While
    pop esi

    dec ecx | mov D$LenOfSearchedString ecx

    mov edi SearchString | rep movsb | mov al 0 | stosb

    push D$DownSearch, D$CaseSearch, D$WholeWordSearch, D$CurrentWritingPos
        mov B$DownSearch &TRUE, B$CaseSearch &FALSE, B$WholeWordSearch &TRUE
        move D$CurrentWritingPos D$CodeSource

        mov D$Trash2 0

        push D$NextSearchPos
            mov D$NextSearchPos 0
L0:         call StringSearch | On B$BlockInside = &FALSE, jmp L7>>

          ; just in case the searched word is too inside a comment:
            mov esi D$BlockStartTextPtr | dec esi
            .While B$esi > LF
                If B$esi = '"'
                    dec esi
                    While B$esi <> '"'
                        dec esi
                    End_While
                Else_If B$esi = "'"
                    dec esi
                    While B$esi <> "'"
                        dec esi
                    End_While
                Else_If B$esi = ';'
                    jmp L0<
                End_If
                dec esi
            .End_While

            mov esi D$BlockStartTextPtr, edi Trash2, ecx D$BlockEndTextPtr
            sub ecx D$BlockStartTextPtr | inc ecx | rep movsb | mov al 0 | stosb

L7: pop D$NextSearchPos
    pop D$CurrentWritingPos, D$WholeWordSearch, D$CaseSearch, D$DownSearch
    popad
    pushad
        call AskForRedrawNow

        If D$Trash2 <> 0
            call ErrorMessageBox Trash2, D$ErrorMessagePtr
        Else
            call ErrorMessageBox esi, D$ErrorMessagePtr
        End_If
        call ReleaseAsmTables
    popad
ret

_________________________________________________________________________________________

; Error in DLL name:

Error4:
    mov B$CompileErrorHappend &TRUE

    push esi

;L9: pushad
;        ;call 'USER32.MessageBoxA' D$hwnd, esi, eax, &MB_SYSTEMMODAL
;        call AskForRedrawNow
;
;        call ErrorMessageBox esi, D$ErrorMessagePtr
;    popad

    mov edi SearchString, B$DownSearch &TRUE, B$WholeWordSearch &FALSE
    move D$CurrentWritingPos D$CodeSource
    mov ecx 0

L0: inc ecx | lodsb | stosb | cmp al 0 | jne L0<
    dec edi | mov al '.' | stosb | mov D$LenOfSearchedString ecx

    call  StringSearch

    call AskForRedrawNow

    pop esi

    call ErrorMessageBox esi, D$ErrorMessagePtr

    call ReleaseAsmTables
ret


; error in function name:

Error5:
    mov B$CompileErrorHappend &TRUE

    ;push esi

    cld

;L9: ;call 'USER32.MessageBoxA' D$hwnd, esi, eax, &MB_SYSTEMMODAL
;    call ErrorMessageBox esi, D$ErrorMessagePtr

    mov edi SearchString, B$DownSearch &TRUE, B$WholeWordSearch &FALSE, B$CaseSearch &FALSE
    move D$CurrentWritingPos D$CodeSource

    mov esi D$StartOfFunctionName, ecx 0

L0: inc ecx | lodsb | stosb | cmp al 0 | jne L0<
    dec ecx
    mov D$LenOfSearchedString ecx

    call  StringSearch

    call AskForRedrawNow

    ;pop esi

    call ErrorMessageBox D$StartOfFunctionName, D$ErrorMessagePtr

    call ReleaseAsmTables
ret


; for bad api call formulation:

Error6: ; mov B$ErrorLevel 6
    push esi
    mov B$CompileErrorHappend &TRUE

L9: ;pushad
      ;call 'USER32.MessageBoxA' D$hwnd, esi, eax, &MB_SYSTEMMODAL
    ;  call ErrorMessageBox esi, D$ErrorMessagePtr
    ;popad

    mov edi SearchString, B$DownSearch &TRUE, B$WholeWordSearch &FALSE
    move D$CurrentWritingPos D$CodeSource
    mov ecx 0

L0: inc ecx | lodsb | stosb | cmp al 0 | jne L0<
    dec ecx | mov D$LenOfSearchedString ecx

    call StringSearch

    call AskForRedrawNow

    pop esi

    call ErrorMessageBox esi, D$ErrorMessagePtr

    call ReleaseAsmTables
ret


; For Bad Win32 Equate Name:

Error8:
    mov B$CompileErrorHappend &TRUE

    push esi

;;;    mov B$esi 0
;;;    While B$esi <> '&' | dec esi | End_While

   ; pushad
   ;   ;call 'USER32.MessageBoxA' D$hwnd, esi, eax, &MB_SYSTEMMODAL
   ;   call ErrorMessageBox esi, D$ErrorMessagePtr
   ; popad

    push D$DownSearch, D$WholeWordSearch
        mov edi SearchString, B$DownSearch &TRUE, B$WholeWordSearch &FALSE
        move D$CurrentWritingPos D$CodeSource
        mov ecx 0

L0:     inc ecx | lodsb | stosb | cmp al 0 | jne L0<
        dec ecx | mov D$LenOfSearchedString ecx


L1:     call StringSearch | cmp B$StringFound &FALSE | je L2>
        mov esi D$BlockEndTextPtr | mov al B$esi+1

      ; Next Char Must be some separator, or some '_':
        If al = '_'
            ; OK
        Else
            call WordEdge | On B$Edge = &FALSE, jmp L1<
        End_If

L2:     call ReleaseAsmTables
    pop D$WholeWordSearch, D$DownSearch

    pop esi

    call AskForRedrawNow

    call ErrorMessageBox esi, D$ErrorMessagePtr
ret


Error9:
    call DirectSourcePointing | jmp ShowError
ret


Error11:
    mov B$CompileErrorHappend &TRUE

    push esi

L9: ;pushad
    ;  ;call 'USER32.MessageBoxA' D$hwnd, esi, eax, &MB_SYSTEMMODAL
    ;  call ErrorMessageBox esi, D$ErrorMessagePtr
    ;popad

    mov edi SearchString, B$DownSearch &TRUE, B$WholeWordSearch &FALSE
    move D$CurrentWritingPos D$CodeSource
    mov esi OneCLASSname, ecx 0

L0: inc ecx | lodsb | stosb | cmp al 0 | jne L0<
    dec ecx | mov D$LenOfSearchedString ecx

L1: call StringSearch
    mov esi D$BlockStartTextPtr | dec esi
    While B$esi = ' ' | dec esi | End_While
    mov eax D$esi-4 | and eax (not 020202020)

  ;  On eax <> 'CLAS', jmp L1<
  ;  On B$esi-5 <> '5', jmp L1<

    sub esi 5 | mov D$BlockStartTextPtr esi

    While B$esi <> ']' | inc esi | End_While
    mov D$BlockEndTextPtr esi

    call ReleaseAsmTables
    call AskforRedraw

    pop esi

    call ErrorMessageBox esi, D$ErrorMessagePtr
ret

;;
Error12:
    push eax
      ; Write the Number out out of range Bytes at 'TooLongOf'
        mov edi D$TooLongOfPtr, D$edi '    ' | mov eax ebx | call WriteEax

      ; Kill the Line Break between 'ShortDis' and 'TooLongOf'
        mov esi D$TooLongOfPtr | dec esi
        While B$esi >= ' ' | mov B$esi ' ' | dec esi | End_While
        While B$esi < ' ' | mov B$esi ' ' | dec esi | End_While
    pop eax
    
    jmp Error2
ret
;;




TITLE Profiler

____________________________________________________________________________________________
____________________________________________________________________________________________


ProfileComments:
;;

____________________________________________________________________________________________

  ________
  Routines:
  
  From the Menu 'M00_Profile', call to the Main Routine: 'Profiler'.
  
  From 'AsmMain':
  
  * 'InjectedCopyToCodeSourceA' injects additional Coding in the Timed App,
    instead of the normal 'NewCopyToCodeSourceA'. (Materials at 'InjectedTIME_COUNT')
    
  * In 'HotParsers', after the call to 'StripUnderscore', turn the '.' of
    'InjectedTIME_COUNT' into '_', to build unique Symbols, by calling to
    'InjectDashLines'.
  
  * After execution of 'EncodeLines', call to 'CreateProfilerTables'
  
  * 'FillCodeSymbols' takes in charge the filling of the Relays Table and
    does the substitutions. >>> 'TimingCalls'
  
  ______
  Plan_2:
  
  All calls are turned "Call Time_Count" So, we need a Table for storing the
  real calls Addresses. Same size as the CodeList Buffer. In 'FillCodeSymbols',
  "If B$ProfilerFlag = &TRUE", we do the substitution and save the Original Call
  Address in the Parallel Table.
  
  Inserted Routins, in the compiled Applicatinon, at 'InjectedTIME_COUNT'.
  There, the real call will be in the form of "call D$Address_Relay", which
  Variable will hold the Table Assress.
  
  This Table is created On RosAsm Side: Call for 'CreateMemoryMapFile'. This
  sould be done after the call to EncodeLines, in 'AsmMain', by 'CreateProfilerTables'
  
  The 'Time_Count' inserted Routine must write the Timing in a second Table
  dedicated to these recordings.
  
  How to record the Timings?
  
  We need a qWords Table where what will be stored will be the difference
  between rdtsc, before and after the real call.
  
  Note: I do not see any Function associted to 'CreateFileMapping' that could
  tell the size of the File (?...). For now, simpler is to store this size in
  a Variable of 'InjectedTIME_COUNT'.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[TimingMapName: 'TestMem.tst', 0]

[HandleOfTimingMapFile: ?  OrigineOfTimingMap: ?]

Proc CreateMemoryMapFile:
    Argument @Size
        call 'KERNEL32.CreateFileMappingA' 0-1, &NULL, &PAGE_READWRITE,
                                        0, D@Size, TimingMapName
        mov D$HandleOfTimingMapFile eax

        call 'KERNEL32.MapViewOfFile' D$HandleofTimingMapFile, &FILE_MAP_ALL_ACCESS,
                                      0, 0, D@Size
        mov D$OrigineOfTimingMap eax
ret


ReadMemoryMapFile:
    mov esi D$OrigineOfTimingMap, eax D$esi
    ;hexprint eax
ret


DeleteMemoryMapFile:
    call 'KERNEL32.UnmapViewOfFile' D$OrigineOfTimingMap
    call 'KERNEL32.CloseHandle' D$HandleOfTimingMapFile
ret


OpenMemoryMapFile:
    call 'KERNEL32.CreateFileMappingA' 0-1, &NULL, &PAGE_READWRITE,
                                       0, 100, TimingMapName
    mov D$HandleOfTimingMapFile eax

    call 'KERNEL32.MapViewOfFile' D$HandleofTimingMapFile, &FILE_MAP_ALL_ACCESS,
                                  0, 0, 100
    mov D$OrigineOfTimingMap eax
ret


WriteMemoryMapFile:
    mov esi D$OrigineOfTimingMap

    mov D$esi 012345678
ret


CloseMemoryMapFile:
    call 'KERNEL32.UnmapViewOfFile' D$OrigineOfTimingMap
    call 'KERNEL32.CloseHandle' D$HandleOfTimingMapFile
ret

____________________________________________________________________________________________


[ProfileTable: ?   ProfilerFlag: ?]

; ProfileComments

Profiler:
    mov B$ProfilerFlag &TRUE
    mov D$AddressOfTimeCount 0

    mov B$ShowStats &FALSE | call AsmMain | mov B$ShowStats &TRUE
    mov D$OldStackPointer 0
  ; Main Call >>> 'CreateProfilerTables'

  ret


    On B$CompileErrorHappend = &TRUE, ret

  ; Similar to 'ScanShortenJmpsTable'
    mov ebx D$CodeRef | add ebx 5

  ; Case of Api Calls: ...|0FF dWordCodeAddress|:
  ;                   ....|.....|
    While B$ebx = 0FF | add ebx 6 | End_While

    mov D$CodeRefScan ebx

    mov B$ProfilerFlag &FALSE
ret


[ProfilerOriginalCalls: ?  ProfilerNumberOfCalls: ?]

CreateProfilerTables:
;;
 What Table do we need in the MapFile?
 
 - Storing the Real Calls Addresses. Same size as the real Code.
 - Storing the Number of calls. Same size as the real Code.
 - Storing the Timings on the calls Rooms. One qWord each. Double Size.
 
;;
  ; (Size of Code) * 4:
    mov ecx D$CodeListPtr | sub ecx D$CodeOrigine | shl ecx 2

    call CreateMemoryMapFile ecx

  ; The Timed App needs to know of the Displacement...
  ; .. and 'FillCodeSymbols' must fill the proper Displacements...
ret


ReleaseProfilerTables:
    VirtualFree D$ProfilerOriginalCalls, D$ProfilerNumberOfCalls
ret

____________________________________________________________________________________________

[AddressOfTimeCount: ?]
[ModelOfTimeCount: B$ 'TIME_COUNT', 0]

SetAddressOfTimeCount:
    pushad
      ; 'FillCodeSymbols'
        call GetFromQwordCheckSum ModelOfTimeCount, D$LabelList, D$LabelListLimit
        While B$eax > LowSigns | inc eax | inc esi | End_While | inc eax | inc esi
        mov edi eax, ecx 0
    popad
ret

[InjectedTIME_COUNT: B$ "
Time.Count:
  ; The 'Call' Return Address is at D$esp
    pop D$ReturnAddressOfTimeCount

        push eax, ebx, ecx, edx
            cpuid | rdtsc
            sub D$Duration eax | sbb D$Duration+4 edx
        pop edx, ecx, ebx, eax

        call D$CallAddress

        push eax, ebx, ecx, edx
            cpuid | rdtsc
            add D$Duration eax | adc D$Duration+4 edx
        pop edx, ecx, ebx, eax

        hexprint D$Duration+4, D$Duration

    push D$ReturnAddressOfTimeCount
ret

; To be paste here: 'OpenMemoryMapFile', 'WriteMemoryMapFile', 'CloseMemoryMapFile'.

", InjectedTIME_COUNT_Len: Len]


; Called from 'HotParsers': ; CoolParsers

InjectDashLines:
    mov esi D$CodeSourceA, ecx 1
  ; ecx = Hard code number of '.' in 'InjectedTIME_COUNT'.
L0: If B$esi = '.'
        mov B$esi '_' | loop L0<
    Else
        jmp L0<
    End_If
ret


[CallByte: 0E8]

Profile:
    call 'KERNEL32.GetStartupInfoA' STARTUPINFO
    call 'KERNEL32.CreateProcessA' DestinationFile, &NULL, &NULL, &NULL, &FALSE,
                                   &DEBUG_PROCESS__&DEBUG_ONLY_THIS_PROCESS,
                                   &NULL, &NULL, STARTUPINFO, PROCESS_INFORMATION

    .While eax = &TRUE
L0:     call 'KERNEL32.WaitForDebugEvent' DEBUG_EVENT, &INFINITE

        .If D$DE.dwDebugEventCode = &EXIT_PROCESS_DEBUG_EVENT
            jmp L9>>

        .Else_If D$DE.dwDebugEventCode = &EXCEPTION_DEBUG_EVENT
            If D$E.ExceptionCode = &EXCEPTION_BREAKPOINT

                ; Debugger_OnException
                mov D$C.ContextFlags &CONTEXT_FULL
                call 'KERNEL32.GetThreadContext' D$PI.hThread, CONTEXT
                ;mov ebx D$C.regEip

           ;     mov D$C.ContextFlags &CONTEXT_CONTROL
           ;     call 'KERNEL32.GetThreadContext' D$PI.hThread, CONTEXT
           ;     or D$C.regFlag 0100
           ;     call 'KERNEL32.SetThreadContext' D$PI.hThread, CONTEXT
;call 'KERNEL32.ReadProcessMemory' D$PI.hProcess, D$E.ExceptionAddress, Trash, 1, &NULL
;hexprint D$Trash
                ;call 'KERNEL32.WriteProcessMemory' D$PI.hProcess, D$E.ExceptionAddress,
                ;                                   CallByte, 1, &NULL

                call 'KERNEL32.ReadProcessMemory' D$PI.hProcess, D$C.regEip, Trash, 5

                mov eax Trash | ;int3
;hexprint D$E.ExceptionAddress
                call 'KERNEL32.ContinueDebugEvent' D$DE.dwProcessId, D$DE.dwThreadId,
                                                   &DBG_CONTINUE
              jmp L0<<

           ; Elseif D$E.ExceptionCode = &EXCEPTION_SINGLE_STEP
           ;     call 'KERNEL32.GetThreadContext' D$PI.hThread, CONTEXT
           ;     or D$C.regFlag 0100
           ;     call 'KERNEL32.SetThreadContext' D$PI.hThread, CONTEXT
           ;     call 'KERNEL32.ContinueDebugEvent' D$DE.dwProcessId, D$DE.dwThreadId,
           ;                                        &DBG_CONTINUE
           ;   jmp L0<<

            End_If
        .End_If

        call 'KERNEL32.ContinueDebugEvent' D$DE.dwProcessId, D$DE.dwThreadId,
                                           &DBG_EXCEPTION_NOT_HANDLED
    .End_While

L9: call 'Kernel32.CloseHandle' D$PI.hProcess
    call 'Kernel32.CloseHandle' D$PI.hThread
ret


ShowProfilerStats:
   ; call 'USER32.MessageBoxA' 0, {'Hi', 0}, {'Hi', 0}, 0
ret


; Called from 'FillCodeSymbols':

TimingCalls:
  ; eax+4 = Original Displacement.

    On B$edi+1 <> 0E8, ret

    On D$AddressOfTimeCount = 0, call SetAddressOfTimeCount
ret



























TITLE UnusedSymbols
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
writer :  /\\o//\      - December the 31, 2004 -

 'LabelList'
 'SearchSortedRegularLabel'
 'LowSigns'
 'DoneFlag'
 'BuildPlainLabelList'

;;
____________________________________________________________________________________________

____________________________________________________________________________________________
____________________________________________________________________________________________

RemoveLocalLabels:
    VirtualFree D$PlainLabelList

    mov eax D$LabelList, eax D$eax | inc eax

    VirtualAlloc PlainLabelList eax

    mov edx D$LabelList | add edx D$edx
    mov edi D$PlainLabelList | add edi 5
    mov esi D$LabelList | add esi 5

    .While esi < edx
        cmp B$esi+2 EOI | jne L1>
            cmp B$esi 'A' | jb L1>
            cmp B$esi 'Z' | ja L1>
                cmp B$esi+1 '0' | jb L1>
                cmp B$esi+1 '9' | ja L1>
                  ; |L0|dWord Byte| >>> 9
                    add esi 9 | jmp L2>

L1:     While B$esi <> EOI
            movsb
        End_While
        movsb   ; |
        movsd   ; Ptr
        movsb   ; Flag
        movsb   ; |
L2: .End_While

    mov eax edi | mov D$EndOfPlainLabelList eax | sub eax D$PlainLabelList
    mov edi D$PlainLabelList | stosd | mov al EOI | stosb
ret
____________________________________________________________________________________________

[WorkBuffer: ? #256]

[CodeLabelNameList: ?
 CodeLabelNameList.Current: ?
 DataLabelNameList: ?
 DataLabelNameList.Current: ?
 UnusedCodeAndDataDialogHandle: ?
 RecompileWanted: ?
 NumberOfUnusedDataLabels: ?
 NumberOfUnusedCodeLabels: ?]


;Task : Seperate CodeLabels from DataLabel, (Put into a list of their own)
Proc DisplayUnusedSymbolsDialog:
    Argument @Adressee
        call RemoveLocalLabels
        mov eax D$PlainLabelList | mov eax D$eax
        push eax
            VirtualAlloc CodeLabelNameList eax
        pop eax
            VirtualAlloc DataLabelNameList eax

        mov edi D$CodeLabelNameList, D$CodeLabelNameList.Current edi
        mov edi D$DataLabelNameList, D$DataLabelNameList.Current edi

        mov ecx D$PlainLabelList | add ecx D$ecx
        mov esi D$PlainLabelList | add esi 5
        mov edi WorkBuffer
        mov D$NumberOfUnusedCodeLabels 0, D$NumberOfUnusedDataLabels 0

        .While esi < ecx
L1:         While B$esi <> EOI
                movsb
            End_While

            Test B$esi+5 DoneFlag | jnz L1>>

            mov B$edi 0 | inc edi

            Test B$esi+5 CodeLabelFlag | jz L2>
                push esi
                    mov edi D$CodeLabelNameList.Current
                    mov esi WorkBuffer
                    While B$esi <> 0 | movsb | End_While
                    mov B$edi 0 | inc edi
                    mov D$CodeLabelNameList.Current edi
                    inc D$NumberOfUnusedCodeLabels
                pop esi
            jmp L1>

            L2: Test B$esi+5 DataLabelFlag | jz L1>
                push esi
                    mov edi D$DataLabelNameList.Current esi WorkBuffer
                    While B$esi <> 0 | movsb | End_While
                    mov B$edi 0 | inc edi
                    mov D$DataLabelNameList.Current edi
                    inc D$NumberOfUnusedDataLabels
                pop esi
            Jmp L1>
L1:         add esi 7
            mov edi WorkBuffer
L2:     .End_While
; Tag Dialog 4
        call 'USER32.EndDialog' D@Adressee, 0
        call 'USER32.DialogBoxParamA' D$hInstance, 4, 0, UnusedCodeAndDataDialogCallBack, 0

        VirtualFree D$CodeLabelNameList
        VirtualFree D$DataLabelNameList
EndP
____________________________________________________________________________________________

[CodeListBox 101
 DataListbox 102
 UnUsedSymbolsEditBox 111
 FindDeclaration 4
 FreeSearchCheckBox 5
 UnusedSymbolHelpbutton 9]

[TextToRetrive: B$ ? #256]
[FocusedChild: D$ ?
CurrentListBox: ?

CodeListBox.Handle: ?
DataListBox.Handle: ?
UnUsedSymbolsEditBox.Handle: ?
FindDeclaration.Handle: ?
FreeSearchCheckBox.Handle: ?
UnusedSymbolHelpbutton.Handle: ?]
DataAndCodeLabelListBoxNotification:
   movzx ebx ax | mov D$CurrentListBox ebx
   shr eax 16
   If ax = &LBN_DBLCLK
      call 'user32.SendDlgItemMessageA' D$UnusedCodeAndDataDialogHandle, D$CurrentListBox,
                                        &LB_GETCARETINDEX 0 0
      call 'user32.SendDlgItemMessageA' D$UnusedCodeAndDataDialogHandle, D$CurrentListBox,
                                        &LB_GETTEXT eax TextToRetrive
      call 'user32.SetDlgItemTextA' D$UnusedCodeAndDataDialogHandle, UnUsedSymbolsEditBox,
                                    TextToRetrive
      call SearchForUnusedSymbol
   Else_If ax = &LBN_SETFOCUS
        move D$FocusedChild D$CurrentListBox
   End_If
ret

[EM_SETFOCUS 0100]
UnUsedSymbolsEditBoxNotification:
   shr eax 16
   If ax = EM_SETFOCUS
        mov D$FocusedChild UnUsedSymbolsEditBox
   End_If
ret

[CharDistance 020]
SearchForTheSymbolInUnUsedSymbolsEditBox:
   call 'user32.SendDlgItemMessageA' D$UnusedCodeAndDataDialogHandle, UnUsedSymbolsEditBox,
                                        &WM_GETTEXTLENGTH 0 0
   inc eax
   mov D$LenOfSearchedString eax



   call 'user32.SendDlgItemMessageA' D$UnusedCodeAndDataDialogHandle, UnUsedSymbolsEditBox,
                                        &WM_GETTEXT eax TextToRetrive


   mov eax TextToRetrive

   While B$eax <> 0
      cmp B$eax 'Z' | jbe L0>
      cmp B$eax 'A' | ja L0>
      sub B$eax CharDistance
     L0:
     inc eax
   End_While

    mov eax TextToRetrive
    mov ecx D$LenOfSearchedString


    mov esi TextToRetrive, edi ControlString | rep movsb
    mov esi TextToRetrive, edi SearchString ecx D$LenOfSearchedString | rep movsb

    dec D$LenOfSearchedString
    push D$DownSearch, D$WholeWordSearch, D$SkipDashLines
        mov B$DownSearch &TRUE, B$WholeWordSearch &FALSE, B$SkipDashLines &TRUE
        mov D$NextSearchPos 0
        On B$RealSourceRestored = &FALSE, call RestoreRealSource
            move D$CurrentWritingPos D$CodeSource
            call StringSearch
            push D$CodeSourceA D$CodeSourceB
                mov esi D$CurrentWritingPos | sub esi 2 | call InternalRightClick
            pop D$CodeSourceB D$CodeSourceA
            mov B$FinfOrReplace &FALSE
        call SetPartialEditionFromPos
    pop D$SkipDashLines, D$WholeWordSearch, D$DownSearch
    On B$StringFound = &FALSE, call 'USER32.SetForegroundWindow' D$UnusedCodeAndDataDialogHandle


ret



____________________________________________________________________________________________

[FreeSearchActive: &FALSE]
SearchForUnusedSymbol:
    mov eax TextToRetrive, ecx 0

    While b$eax <> 0
        inc ecx | inc eax
    End_While
    inc ecx

    push eax ecx
        call 'USER32.SendDlgItemMessageA' D$UnusedCodeAndDataDialogHandle, FreeSearchCheckBox,
                                     &BM_GETCHECK, 0, 0

        mov D$FreeSearchActive eax
        cmp eax &TRUE
    pop ecx eax | je L0>

            mov B$eax ':', B$eax + 1 0 | inc ecx
    L0:
    mov D$LenOfSearchedString ecx

    mov eax TextToRetrive
    While B$eax <> 0
        cmp B$eax 'Z' | jbe L0>
        cmp B$eax 'A' | ja L0>
        sub B$eax CharDistance
     L0:
        inc eax
    End_While


PerformSearch:

    mov esi TextToRetrive, edi ControlString | rep movsb
    mov esi TextToRetrive, edi SearchString ecx D$LenOfSearchedString | rep movsb

    dec D$LenOfSearchedString
    push D$DownSearch, D$WholeWordSearch, D$SkipDashLines
        mov eax D$FreeSearchActive | sub eax 1 | neg eax
        mov B$DownSearch &TRUE, B$WholeWordSearch al, B$SkipDashLines &TRUE
        mov D$NextSearchPos 0
        On B$RealSourceRestored = &FALSE, call RestoreRealSource
            move D$CurrentWritingPos D$CodeSource
            call StringSearch
            push D$CodeSourceA D$CodeSourceB
                mov esi D$CurrentWritingPos | sub esi 2 | call InternalRightClick
            pop D$CodeSourceB D$CodeSourceA
            mov B$FinfOrReplace &FALSE
        call SetPartialEditionFromPos

    pop D$SkipDashLines, D$WholeWordSearch, D$DownSearch

    On B$StringFound = &FALSE, call 'USER32.SetForegroundWindow' D$UnusedCodeAndDataDialogHandle
ret


DesideSearchForUnusedSymbols:
  If D$FocusedChild = UnUsedSymbolsEditBox
      call SearchForTheSymbolInUnUsedSymbolsEditBox
  Else
     mov ax &LBN_DBLCLK | shl eax 16 | mov ax w$FocusedChild | call DataAndCodeLabelListBoxNotification
  End_If

  On B$StringFound = &FALSE, call 'USER32.SetForegroundWindow' D$UnusedCodeAndDataDialogHandle
ret
____________________________________________________________________________________________

[NoteForWorkerBee:"You can press F5 to compile, without losing this list" 0]

; Tag Dialog 4


[OldUnusedSymbolDialogSubClassProc:  ?
 OldUnusedSymbolDialogSubClassProc1: ?
 OldUnusedSymbolDialogSubClassProc2: ?
 OldUnusedSymbolDialogSubClassProc3: ?
 OldUnusedSymbolDialogSubClassProc4: ?
 OldUnusedSymbolDialogSubClassProc5: ?
 OldUnusedSymbolDialogSubClassProc6: ?]

Proc UnusedSymbolDialogSubClassProc:
Arguments @Adressee, @Message, @wParam, @lParam

    .if D@Message = &WM_KEYDOWN
        if D@Wparam = &VK_F5
            mov B$RecompileWanted &TRUE
            mov B$ShowStats &FALSE
            call SaveUnusedIndex
            push D$UnusedCodeAndDataDialogHandle
                mov D$UnusedCodeAndDataDialogHandle 0
                mov B$UnusedSymbolsWanted &TRUE
            pop eax
            call 'USER32.EndDialog' eax, 0
            ExitP
        end_if
    .end_if


   @DefaultProcessing:
   mov eax D@Adressee
   .if eax = D$CodeListBox.Handle
       call D$OldUnusedSymbolDialogSubClassProc1 D@Adressee, D@Message, D@wParam, D@lParam
   .else_if eax = D$DataListBox.Handle
       call D$OldUnusedSymbolDialogSubClassProc2 D@Adressee, D@Message, D@wParam, D@lParam
   .else_if eax = D$UnUsedSymbolsEditBox.Handle
       call D$OldUnusedSymbolDialogSubClassProc3 D@Adressee, D@Message, D@wParam, D@lParam
   .else_if eax = D$FindDeclaration.Handle
       call D$OldUnusedSymbolDialogSubClassProc4 D@Adressee, D@Message, D@wParam, D@lParam
   .else_if eax = D$UnusedSymbolHelpbutton.Handle
       call D$OldUnusedSymbolDialogSubClassProc5 D@Adressee, D@Message, D@wParam, D@lParam
   .else
       call D$OldUnusedSymbolDialogSubClassProc6 D@Adressee, D@Message, D@wParam, D@lParam
   .end_if
EndP

Proc InstallSubClassCallbacks:
Argument @Adressee
            call 'USER32.GetDlgItem' D@Adressee CodeListBox
            if eax <> 0
                mov D$CodeListBox.Handle eax
                call 'USER32.SetWindowLongA' eax &GWL_WNDPROC UnusedSymbolDialogSubClassProc
                mov D$OldUnusedSymbolDialogSubClassProc1 eax
            end_if

            call 'USER32.GetDlgItem' D@Adressee DataListbox
            if eax <> 0
                mov D$DataListBox.Handle eax
                call 'USER32.SetWindowLongA' eax &GWL_WNDPROC UnusedSymbolDialogSubClassProc
                mov D$OldUnusedSymbolDialogSubClassProc2 eax
            end_if

            call 'USER32.GetDlgItem' D@Adressee UnUsedSymbolsEditBox
            if eax <> 0
                mov D$UnUsedSymbolsEditBox.Handle eax
                call 'USER32.SetWindowLongA' eax &GWL_WNDPROC UnusedSymbolDialogSubClassProc
                mov D$OldUnusedSymbolDialogSubClassProc3 eax
            end_if

            call 'USER32.GetDlgItem' D@Adressee FindDeclaration
            if eax <> 0
                mov D$FindDeclaration.Handle eax
                call 'USER32.SetWindowLongA' eax &GWL_WNDPROC UnusedSymbolDialogSubClassProc
                mov D$OldUnusedSymbolDialogSubClassProc4 eax
            end_if
            mov D$FindDeclaration.Handle eax

            call 'USER32.GetDlgItem' D@Adressee UnusedSymbolHelpbutton
            if eax <> 0
                mov D$UnusedSymbolHelpbutton.Handle eax
                call 'USER32.SetWindowLongA' eax &GWL_WNDPROC UnusedSymbolDialogSubClassProc
                mov D$OldUnusedSymbolDialogSubClassProc5 eax
            end_if

            call 'USER32.GetDlgItem' D@Adressee FreeSearchCheckBox
            if eax <> 0
                call 'USER32.SetWindowLongA' eax &GWL_WNDPROC UnusedSymbolDialogSubClassProc
                mov D$OldUnusedSymbolDialogSubClassProc6 eax
            end_if
EndP

Proc UnusedCodeAndDataDialogCallBack:
    Arguments @Adressee, @Message, @wParam, @lParam

       pushad

        mov eax &FALSE
        ..If D@Message = &WM_COMMAND
            If D@wParam = &IDHELP
                call Help, B_U_AsmName, UnusedSymbolsHelp, ContextHlpMessage
            End_if

            mov B$StringFound &TRUE
            mov eax D@wParam

            If ax = CodeListBox
                call DataAndCodeLabelListBoxNotification

            Else_If ax = DataListBox
                call DataAndCodeLabelListBoxNotification

            Else_If ax = FindDeclaration
                shr eax 16
                cmp ax &BN_CLICKED | jne L0>
                    call DesideSearchForUnusedSymbols
                L0:
            Else_If ax = &IDOK
                  call DesideSearchForUnusedSymbols

            Else_If ax = &IDCANCEL
                    mov B$UnusedSymbolsWanted &FALSE
                    mov D$UnusedSymbolsDialogWanted &FALSE
                    mov D$UnusedCodeAndDataDialogHandle 0
                    call 'USER32.EndDialog' D@Adressee, 0

            Else_If ax = UnUsedSymbolsEditBox

                call UnUsedSymbolsEditBoxNotification
            End_If

        ..Else_If D@Message = &WM_MOUSEMOVE

        ..Else_If D@Message = &WM_HELP
             call Help B_U_AsmName, UnusedSymbolsHelp, ContextHlpMessage

        ..Else_If D@Message = &WM_KEYDOWN
             call Help, B_U_AsmName, UnusedSymbolsHelp, ContextHlpMessage

        ..Else_If D@Message = &WM_INITDIALOG
            Call InstallSubClassCallbacks D@Adressee

            mov eax D@Adressee
            mov D$UnusedCodeAndDataDialogHandle eax
            call SetUnusedDialogPos D@Adressee
            mov ecx D$NumberOfUnusedCodeLabels | jecxz L9>
            mov eax D$CodeLabelNameList

L0:         push eax ecx
                push eax
                    While B$eax <> 0
                        cmp B$eax '@' | je L1>
                        inc eax
                    End_While
                pop eax
                push eax
                    call 'user32.SendDlgItemMessageA' D$UnusedCodeAndDataDialogHandle,
                                                      CodeListBox, &LB_ADDSTRING, 0, eax
L1:             pop eax
            pop ecx eax
            While B$eax <> 0 | inc eax | End_While
            inc eax | dec ecx | jnz L0<

L9:         mov ecx D$NumberOfUnusedDataLabels | jecxz L9>
            mov eax D$DataLabelNameList

L0:         push eax ecx
                push eax
                    While B$eax <> 0
                        cmp B$eax '@' | je L1>
                        inc eax
                    End_While
                pop eax
                push eax
                    call 'user32.SendDlgItemMessageA' D$UnusedCodeAndDataDialogHandle,
                                                      DataListbox, &LB_ADDSTRING, 0, eax
L1:             pop eax
            pop ecx eax
            While B$eax <> 0 | inc eax | End_While
            inc eax | dec ecx | jnz L0<

L9:         call 'user32.SetDlgItemTextA' D$UnusedCodeAndDataDialogHandle,
                                          UnUsedSymbolsEditBox, NoteForWorkerBee

            mov eax D$UnusedCodeIndex | or eax D$UnusedDataIndex
            On eax <> 0 call RestoreUnusedIndex

        ..Else
            popad | mov eax &FALSE | ExitP

        ..End_If

        popad | mov eax &TRUE
EndP
____________________________________________________________________________________________

[UnusedCodeIndex: ?   UnusedDataIndex: ?]

SaveUnusedIndex:
    call 'USER32.SendDlgItemMessageA' D$UnusedCodeAndDataDialogHandle, CODELISTBOX,
                                      &LB_GETTOPINDEX, 0, 0
    mov D$UnusedCodeIndex eax

    call 'USER32.SendDlgItemMessageA' D$UnusedCodeAndDataDialogHandle, DATALISTBOX,
                                      &LB_GETTOPINDEX, 0, 0
    mov D$UnusedDataIndex eax
ret

RestoreUnusedIndex:
    call 'USER32.SendDlgItemMessageA' D$UnusedCodeAndDataDialogHandle, CODELISTBOX,
                                      &LB_SETTOPINDEX, D$UnusedCodeIndex, 0

    call 'USER32.SendDlgItemMessageA' D$UnusedCodeAndDataDialogHandle, DATALISTBOX,
                                      &LB_SETTOPINDEX, D$UnusedDataIndex, 0
ret
____________________________________________________________________________________________

Proc SetUnusedDialogPos:
    Argument @Handle
    Structure @WINDOWPLACEMENT 44,
              WINDOWPLACEMENT.iLengthDis 0,
              WINDOWPLACEMENT.flagsDis 4,
              WINDOWPLACEMENT.showCmdDis 8,
              WINDOWPLACEMENT.ptMinPosition.xDis 12,
              WINDOWPLACEMENT.ptMinPosition.yDis 16,
              WINDOWPLACEMENT.ptMaxPosition.xDis 20,
              WINDOWPLACEMENT.ptMaxPosition.yDis 24,
              WINDOWPLACEMENT.rcNormalPosition.leftDis 28,
              WINDOWPLACEMENT.rcNormalPosition.topDis 32,
              WINDOWPLACEMENT.rcNormalPosition.rightDis 36,
              WINDOWPLACEMENT.rcNormalPosition.bottomDis 40

        mov D$WINDOWPLACEMENT.iLengthDis 44

        call 'USER32.GetWindowPlacement' D$UnusedCodeAndDataDialogHandle, D@WINDOWPLACEMENT

        call 'USER32.GetSystemMetrics' &SM_CXSCREEN | sub eax 5
        mov ecx D$WINDOWPLACEMENT.rcNormalPosition.rightDis
        sub ecx D$WINDOWPLACEMENT.rcNormalPosition.leftDis
        mov D$WINDOWPLACEMENT.rcNormalPosition.rightDis eax
        sub eax ecx | mov D$WINDOWPLACEMENT.rcNormalPosition.leftDis eax

        call 'USER32.GetSystemMetrics' &SM_CYSCREEN | sub eax 30
        mov ecx D$WINDOWPLACEMENT.rcNormalPosition.bottomDis
        sub ecx D$WINDOWPLACEMENT.rcNormalPosition.topDis
        mov D$WINDOWPLACEMENT.rcNormalPosition.bottomDis eax
        sub eax ecx | mov D$WINDOWPLACEMENT.rcNormalPosition.topDis eax

        call 'USER32.SetWindowPlacement' D$UnusedCodeAndDataDialogHandle, D@WINDOWPLACEMENT
EndP

____________________________________________________________________________________________

ReInitUnusedDialog:
    call SaveUnusedIndex
    call 'USER32.EndDialog' D$UnusedCodeAndDataDialogHandle, 0
    mov D$UnusedCodeAndDataDialogHandle 0
    mov B$UnusedSymbolsWanted &TRUE
    mov B$RecompileWanted &TRUE
    mov B$ShowStats &FALSE
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
TITLE Includes
____________________________________________________________________________________________
____________________________________________________________________________________________
;;

'BuildEquatesTables' 'GetEquates' 
 
 
Win Equates: How it works.

The Equates.equ Files expected by the Parsers is in the form of:

A0_REG 010
A1_REG 011
A2_REG 012
A3_REG 013
A4_REG 014
A5_REG 015
AADBE_ADD_ENTRY 01
AADBE_DEL_ENTRY 02
... and so on.

That is:

* Zero blank Line.
* One line is: NAME / Space / HEXA / CR-LF
* File CR-LF ended.

Zero flexibility. Simply have 2 spaces instead of one, or a space after the Hexa, will
make it fail.

At launch time, RosAsm attempts to open "Equates.equ". If not found, it sends a 
Message telling the user to provide the path for that file.

After having open "Equates.equ", RosAsm also opens all other '*.equ" Files encounted
aside "Equates.equ", loads all of these Data and compiles them.

Compiling the Win Equates:

The Equates Names and Values are stored into two different parallel Tables, one for
the Names, one for the Values. The names are computed into encoded dWords (a kind
of CheckSum), so that the two Tables are the same size.


The NamesTable begins by a Header of dWords Pointers: In fact, not only the Equates
are encoded, but they also are divided in 'First-Char's Chunks and each Chunk is sorted
in numerical order. When searching for an Equate Value, RosAsm first re-encodes the
Name into the CheckSum, condiders the First Equate Char, read the according Pointer
in the NameTable Header (and also the next Pointer to get the size by substraction),
and begins searching in the proper Chunk only. This final search, for recovering a
Value from a given Name, is done by a fast 2n Search Algo.

____________________________________________________________________________________________
____________________________________________________________________________________________


 Reading the "Include" Files: At least: Equates.equ / Functions.api / Structures.str,
 which are the required ones for Win32. RosAsm does not run without ( > Run Help File
 if not found / Load them if found).

 All other .equ Files found in the same Directory add pasted to the same Memory Tables
 for Equates.

 Functions.api is a single File (Right-Click / Disassembly).

 .str Files will be available trough [Struc] main menu option. If several .str Files
 are found > build a child menu with an Item for each, and branch the sub Menu to
 [Struc].
;;
____________________________________________________________________________________________

[IncludeFileName: B$ ? #&MAX_PATH]

; Called with '.ext' in eax:

Proc SetAllIncludeFilesExtension:
    Argument @Extension

    mov esi EquatesName, edi IncludeFileName

    While B$esi <> 0 | movsb | End_While
    dec edi
    While B$edi <> '.' | dec edi | End_While

L0: dec edi | cmp B$edi '\' | je L1>
              cmp B$edi ':' | je L1>
              cmp edi IncludeFileName | ja L0<
                jmp L2>
L1: inc edi
L2: mov B$edi '*' | inc edi | mov eax D@Extension | stosd | mov B$edi 0
EndP

____________________________________________________________________________________________

[StructuresIncFileSize: ?    StructPopUpHandle: ?    StructuresFileOK: ?]
[StrucPopMenu: 'Struct', 0]

[StructuresItem: 'Structures', 0]

PrepareStructuresFiles:
    call SetAllIncludeFilesExtension '.str'
    call 'KERNEL32.FindFirstFileA' IncludeFileName FIND_EQU | call SetFullName

    ..If eax = &INVALID_HANDLE_VALUE
        mov B$StructuresFileOK &FALSE
        ret
      ; Better let it run without Structures and Api Files if user wants to...
      ; May be temporary...

        call Help, B_U_AsmName, IncludeFilesHelp, ContextHlpMessage

        mov B$IncludesOK &FALSE

    ..Else  ; 'AddUserMenu'
        mov D$FindIncHandle eax
      ; Copy first the first File Path and Name in case there is only one:
        mov B$StructuresFileOK &TRUE
        mov esi FullName, edi MenuItemString, ecx &MAX_PATH | rep movsb

      ; Is there more than one File.str?
        call 'KERNEL32.FindNextFileA' D$FindIncHandle FIND_EQU

;mov eax &FALSE ; <<<<<<<<<<<<<<<< Temporary... (ToDo List...).

        .If eax = &TRUE
            call 'KERNEL32.FindClose' D$FindIncHandle

            mov D$StructureMenuID 4000, B$SeveralStructuresFiles &TRUE

            call 'USER32.CreatePopupMenu' | mov D$StructPopUpHandle eax

            call 'KERNEL32.FindFirstFileA' IncludeFileName FIND_EQU
            mov D$FindIncHandle eax

            Do
                call SetStructuresMenuItem
                call 'KERNEL32.FindNextFileA' D$FindIncHandle FIND_EQU
            Loop_Until eax = &FALSE



            call 'USER32.InsertMenuA' D$MenuHandle, M00_Structures,
                                  &MF_BYCOMMAND__&MF_POPUP__&MF_STRING,
                                  D$StructPopUpHandle, StructuresItem

            call 'USER32.DeleteMenu' D$MenuHandle, M00_Structures, &MF_BYCOMMAND


          ;  call 'USER32.DeleteMenu' D$MenuHandle 8 &MF_BYPOSITION
          ;  call 'USER32.InsertMenuA' D$MenuHandle 8 &MF_BYPOSITION__&MF_STRING__&MF_POPUP,
          ;                    D$StructPopUpHandle  StrucPopMenu
        .Else
          ; Else, there is only one .str File.
            mov B$SeveralStructuresFiles &FALSE

        .End_If

        call 'KERNEL32.FindClose' D$FindIncHandle

    ..End_If
ret

[StructureMenuID: ?]

; Builds the added PopUp Menu under [Struct] main Option:
; (We have a: > mov D$StructureMenuID 4000 in caller ('OpenStructuresFiles').

SetStructuresMenuItem:
    mov esi FIND_EQU_cFileName
    While B$esi <> 0 | inc esi | End_While
    dec esi
    While B$esi <> '.' | dec esi | End_While
    mov B$esi 0
L0: dec esi | cmp B$esi '\' | je L1>
              cmp B$esi ':' | je L1>
              cmp esi FIND_EQU_cFileName | ja L0<

L1: call 'USER32.AppendMenuA' D$StructPopUpHandle &MF_STRING D$StructureMenuID esi
    inc D$StructureMenuID
ret

 ________________________________________________________________________________________
 _________________________________________________________________________________________
;;
 15948 Win Equates are stored in 2 tables of dWords: The first one for the Names
 (stored as one dWord per name after string coding) and the second one for the
 relative Values. The routine for coding the names i used when building these tables
 is the same as the one use here for the Win Equates Search (see down there).

 The storage (and search) algorithm is NOT univoque. It simply revealed efficient
 upon this list (without any double values -same value for 2 names- encounted).

 The Data for OS Equates are now outside RosAsm, and computed at launch time.
;;
____________________________________________________________________________________________





[EquatesCurrentDirectory: B$ ? #&MAX_PATH]

;;
  In case user did not re-define the 'Equates.equ' Path, but set the 'Equates.equ' aside
  RosAsm, if he changes the Current Directory when working, and then run, for example [Struct]
  Menu Item, RosAsm would hang when expecting to find out 'Structures.str' in the new Current
  Path. So, we complete the Path here, if needed.
;;

AppendToCurrentDirectory:
    call 'KERNEL32.GetCurrentDirectoryA' &MAX_PATH, EquatesCurrentDirectory
    If eax <> 0
        mov edi EquatesCurrentDirectory | add edi eax
        mov al '\'
        On B$edi-1 <> al, stosb
        mov esi EquatesName | While B$esi <> 0 | movsb | End_While

        mov esi EquatesCurrentDirectory, edi EquatesName
        While B$esi <> 0 | movsb | End_While
    End_If
ret
____________________________________________________________________________________________

[EquatesInFileTitle: 'Number of Encoded Equates:', 0]

[EquatesIncFileSize: ?    EquateIncMemory: ?    EquateIncMemoryPointer: ?]

[FindIncHandle: ?]

[FIND_EQU:
 FIND_EQU_dwFileAttributes: D$ 0
 FIND_EQU_ftCreationTime.dwLowDateTime: D$ 0
 FIND_EQU_ftCreationTime.dwHighDateTime: D$ 0
 FIND_EQU_ftLastAccessTime.dwLowDateTime: D$ 0
 FIND_EQU_ftLastAccessTime.dwHighDateTime: D$ 0
 FIND_EQU_ftLastWriteTime.dwLowDateTime: D$ 0
 FIND_EQU_ftLastWriteTime.dwHighDateTime: D$ 0
 FIND_EQU_nFileSizeHigh: D$ 0
 FIND_EQU_nFileSizeLow: D$ 0
 FIND_EQU_dwReserved0: D$ 0
 FIND_EQU_dwReserved1: D$ 0]
[FIND_EQU_cFileName: B$ 0 #&MAX_PATH]
[FIND_EQU_cAlternate: B$ 0 #14]

[FullName: ? #&MAX_PATH]

SetFullName:
    pushad
        mov esi IncludeFileName, edi FullName
        While W$esi <> '*.' | movsb | End_While
        mov esi FIND_EQU_cFileName
        While B$esi <> 0 | movsb | End_While | movsb
    popad
ret
____________________________________________________________________________________________

OpenEquFiles:
    call IsEquatesEquThere

    If B$IncludesOK = &TRUE
        call GetEquFilesMemory
        call ReadEquatesEqu
        call ReadOtherEquFiles
        call CleanEquateIncMemory
    End_If
ret


[EquatesEquFileName: 'Equates.equ', 0]

SetEquatesEquFileName:
    mov esi EquatesName, edi IncludeFileName

    While B$esi <> 0 | movsb | End_While
    dec edi
    While B$edi <> '.' | dec edi | End_While

L0: dec edi | cmp B$edi '\' | je L1>
              cmp B$edi ':' | je L1>
              cmp edi IncludeFileName | ja L0<
                jmp L2>
L1: inc edi
L2: mov esi EquatesEquFileName
    While B$esi <> 0 | movsb | End_While | movsb
ret


IsEquatesEquThere:
    call SetEquatesEquFileName

    call 'KERNEL32.FindFirstFileA' IncludeFileName FIND_EQU

    .If eax = &INVALID_HANDLE_VALUE
        mov B$IncludesOK &FALSE
        call Help B_U_AsmName, IncludeFilesHelp, RosAsmHlpMessage

    .Else
        mov B$IncludesOK &TRUE
    .End_If
ret


GetEquFilesMemory:
    call SetAllIncludeFilesExtension '.equ'

    call 'KERNEL32.FindFirstFileA' IncludeFileName FIND_EQU | call SetFullName

    mov D$FindIncHandle eax, D$EquatesIncFileSize 0

L0:     mov eax D$FIND_EQU_nFileSizeLow | add D$EquatesIncFileSize eax

        call 'KERNEL32.FindNextFileA' D$FindIncHandle FIND_EQU
        call SetFullName | On eax = &TRUE, jmp L0<

    VirtualAlloc EquateIncMemory D$EquatesIncFileSize

L9: call 'KERNEL32.FindClose' D$FindIncHandle
ret


ReadEquatesEqu:
    call SetEquatesEquFileName
    call 'KERNEL32.CreateFileA' IncludeFileName &GENERIC_READ, &FILE_SHARE_READ, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0

    mov D$NumberOfReadBytes 0
    push eax
        push eax
            call 'KERNEL32.GetFileSize' eax, 0 | mov ecx eax
            If ecx = 0
                pop eax | jmp L9>
            End_If
            add eax D$EquateIncMemory | mov D$EquateIncMemoryPointer eax
        pop eax
        call 'KERNEL32.ReadFile' eax, D$EquateIncMemory, ecx, NumberOfReadBytes, 0
    pop eax

L9: call 'KERNEL32.CloseHandle' eax
ret


IsItEquatesEqu:
    mov esi FIND_EQU_cFileName, edi EquatesEquFileName
L0: mov al B$esi, bl B$edi | inc edi | inc esi
    If al = 0
        cmp bl 0
    Else
        or al 020 | or bl 020 | cmp al bl | je L0<
    End_If
ret


ReadOtherEquFiles:
    call SetAllIncludeFilesExtension '.equ'

    call 'KERNEL32.FindFirstFileA' IncludeFileName FIND_EQU | call SetFullName

        push 0-1

        mov D$FindIncHandle eax

L0:     call IsItEquatesEqu | je L1>
        mov eax D$FIND_EQU_nFileSizeLow
        push eax
            call 'KERNEL32.CreateFileA' FullName &GENERIC_READ, &FILE_SHARE_READ, 0,
                                        &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
        push eax

L1:     call 'KERNEL32.FindNextFileA' D$FindIncHandle FIND_EQU
        call SetFullName | On eax = &TRUE, jmp L0<

        mov D$NumberOfReadBytes 0
        mov edi D$EquateIncMemoryPointer
L0:     pop eax                     ; Handle
        On eax = 0-1, jmp L9>
        pop ecx                     ; Size
        push edi, ecx, eax
            call 'KERNEL32.ReadFile' eax, edi, ecx, NumberOfReadBytes, 0
        pop eax, ecx, edi

        add edi ecx

        On W$edi-2 <> 0A0D, jmp BadEquatesFileEnd
        On W$edi-4 = 0A0D, jmp BadEquatesFileEnd

        push edi | call 'KERNEL32.CloseHandle' eax | pop edi | jmp L0<

L9:     call 'KERNEL32.FindClose' D$FindIncHandle
ret


CleanEquateIncMemory:
    mov esi D$EquateIncMemory, edi esi, edx esi | add edx D$EquatesIncFileSize

    While esi < edx
        On B$esi = Tab, mov B$esi ' '
        inc esi
    End_While

    mov esi edi

    .While esi < edx
        lodsb | stosb
        If al = ' '
            While B$esi = ' '
                inc esi | dec D$EquatesIncFileSize
            End_While
        End_If
    .End_While
ret

____________________________________________________________________________________________

[NumberOfEquates: ?]

; In factn ot only 'Count Equates', but also verify integrity of File syntax:
; One Symbol UpperCase / One space / One Hexa in RosAsm syntax / One CR/LF.

CountEquates:
    mov edx D$EquateIncMemory | add edx D$EquatesIncFileSize

    On W$edx-2 <> 0A0D, jmp BadEquatesFileEnd
    On W$edx-4 = 0A0D, jmp BadEquatesFileEnd

    mov esi D$EquateIncMemory, ecx 0

    .While esi < edx
        mov ebx esi

        While B$esi > ' ' | inc esi | End_While         ; Read Symbol.

        On B$esi <> ' ', jmp BadEquatesFile             ; One single space.

        inc esi | On B$esi <> '0', jmp BadEquatesFile

        While B$esi > ' ' | inc esi | End_While         ; One RosAsm syntax Hexa number.

        On W$esi <> 0A0D, jmp BadEquatesFile  ; CR/LF

        add esi 2 | inc ecx
    .End_While

    mov D$NumberOfEquates ecx
ret

____________________________________________________________________________________________

[BadEquatesFileTitle: 'Bad Equates File', 0]
[BadEquatesFileMessage: ? #10]
[BadEquatesFileEndMessage: 'The Equates File must be ended by *one* CR/FL', 0]

BadEquatesFile:
    mov esi ebx, edi BadEquatesFileMessage
    While B$esi > ' ' | movsb | End_While
    mov D$edi '...', B$edi+4 0


    call 'USER32.MessageBoxA' 0, BadEquatesFileMessage, BadEquatesFileTitle, 0
    call 'KERNEL32.ExitProcess', 0


BadEquatesFileEnd:

    call 'USER32.MessageBoxA' 0, BadEquatesFileEndMessage, BadEquatesFileTitle, 0
    call 'KERNEL32.ExitProcess', 0


[EquatesNumber: ?     WinEquTableLenght: ?
 NamesTable: ?    ValuesTable: ?
 SortedNamesTable: ?    SortedValuesTable: ?]

[SizeByFirstChar: ? #256] ; 26 Length (Length for Equates beginning by 'A, by 'B',... 'Z'.
; plus '[/]^_', just to have '_' >>> 31 records.
[ApiChunksPointers: ? #256] ; Used to follow up when filling the Api List Chunks.


 ________________________________________________________________________________________









TITLE Functions

[Win32ApiList: ?]

;;
  Tghis List of Functions must be sorted in Alphabetic order. If one Item is
  wrong, all of the downward Item will be ignored, by the scanner.
  
  A simple way to sort a List of Lines, is to use "Ultra-Edit" / [File] / [Sort]
  (using current Option).
;;
[Win32Functions:
"ADVANCEDSETUPDIALOG
ADsBuildEnumerator
ADsEnumerateNext
ADsFreeEnumerator
ADsGetLastError
ADsGetObject
ADsOpenObject
ADsSetLastError
AMGetErrorTextA
AMGetWideString
AMovieDllRegisterServer
AMovieDllRegisterServer2
AMovieDllUnregisterServer
AMovieSetupRegisterFilter
AMovieSetupRegisterFilter2
AMovieSetupRegisterServer
AMovieSetupUnregisterServer
AVIBuildFilterA
AVIClearClipboard
AVIFileAddRef
AVIFileCreateStreamA
AVIFileEndRecord
AVIFileExit
AVIFileGetStream
AVIFileInfoA
AVIFileInit
AVIFileOpenA
AVIFileReadData
AVIFileRelease
AVIFileWriteData
AVIGetFromClipboard
AVIMakeCompressedStream
AVIMakeFileFromStreams
AVIMakeStreamFromClipboard
AVIPutFileOnClipboard
AVISaveOptions
AVISaveOptionsFree
AVISaveVA
AVIStreamAddRef
AVIStreamBeginStreaming
AVIStreamCreate
AVIStreamEndStreaming
AVIStreamFindSample
AVIStreamGetFrame
AVIStreamGetFrameClose
AVIStreamGetFrameOpen
AVIStreamInfoA
AVIStreamLength
AVIStreamOpenFromFileA
AVIStreamRead
AVIStreamReadData
AVIStreamReadFormat
AVIStreamRelease
AVIStreamSampleToTime
AVIStreamSetFormat
AVIStreamStart
AVIStreamTimeToSample
AVIStreamWrite
AVIStreamWriteData
AbortDoc
AbortPath
AbortPrinter
AbortRun
AbortSystemShutdownA
AcceptEx
AccessCheck
AccessCheckAndAuditAlarmA
AccessCheckByType
AccessCheckByTypeAndAuditAlarmA
AccessCheckByTypeResultList
AccessCheckByTypeResultListAndAuditAlarmA
AccessNtmsLibraryDoor
AccessibleChildren
AccessibleObjectFromEvent
AccessibleObjectFromPoint
AccessibleObjectFromWindow
AcquireSCMLock
AcsLan
ActivateKeyboardLayout
AddAccessAllowedAce
AddAccessAllowedAceEx
AddAccessAllowedObjectAce
AddAccessDeniedAce
AddAccessDeniedAceEx
AddAccessDeniedObjectAce
AddAce
AddAtomA
AddAuditAccessAce
AddAuditAccessAceEx
AddAuditAccessObjectAce
AddClusterResourceDependency
AddClusterResourceNode
AddConsoleAliasA
AddFontMemResourceEx
AddFontResourceA
AddFontResourceExA
AddFormA
AddInksetInterval
AddJobA
AddMIMEFileTypesPS
AddMiniIconToList
AddMonitorA
AddPenDataHRC
AddPenInputHRC
AddPerMachineConnectionA
AddPointsPenData
AddPortA
AddPortExA
AddPrintProcessorA
AddPrintProvidorA
AddPrinterA
AddPrinterConnectionA
AddPrinterConnectionUI
AddPrinterDriverA
AddPrinterDriverExA
AddTagToGroupOrderListEntry
AddWordsHWL
AdjustTokenGroups
AdjustTokenPrivileges
AdjustWindowRect
AdjustWindowRectEx
AdsBuildVarArrayInt
AdsBuildVarArrayStr
AdsEncodeBinaryData
AdsFreeAdsValues
AdsTypeToPropVariant
AdvancedDocumentPropertiesA
AdvancedSetupDialog
AllocADsMem
AllocADsStr
AllocConsole
AllocateAndInitializeSid
AllocateLocallyUniqueId
AllocateMemory
AllocateNtmsMedia
AllocateZeroedMemory
AlphaBlend
AmpFactorToDB
AngleArc
AnimatePalette
AnimateWindow
AnyPopup
AppCleanup
AppendMenuA
AppendStringToMultiSz
Arc
ArcTo
AreAllAccessesGranted
AreAnyAccessesGranted
AreFileApisANSI
Arith_Close
Arith_Decode_Bits
Arith_Init
ArrangeIconicWindows
AssertFail
AssignProcessToJobObject
AssociateColorProfileWithDeviceA
AttachThreadInput
BSTR_UserFree
BSTR_UserMarshal
BSTR_UserSize
BSTR_UserUnmarshal
BackupEventLogA
BackupRead
BackupSeek
BackupWrite
BaseAttachCompleteThunk
Beep
BeginDeferWindowPos
BeginPaint
BeginPath
BeginUpdateResourceA
BindAsyncMoniker
BindIFilterFromStorage
BindIFilterFromStream
BindImage
BindImageEx
BindMoniker
BitBlt
BlockInput
BoundingRectFromPoints
BringWindowToTop
BroadcastSystemMessageA
BstrFromVector
BuildCommDCBA
BuildCommDCBAndTimeoutsA
BuildDisplayTable
BuildExplicitAccessWithNameA
BuildImpersonateExplicitAccessWithNameA
BuildImpersonateTrusteeA
BuildSecurityDescriptorA
BuildTrusteeWithNameA
BuildTrusteeWithSidA
CElapsed
CIBuildQueryNode
CIBuildQueryTree
CICreateCommand
CIMakeICommand
CIRestrictionToFullTree
CITextToFullTree
CITextToSelectTree
CLIENT_ALLOC
CLIENT_FREE
CLIPFORMAT_UserFree
CLIPFORMAT_UserMarshal
CLIPFORMAT_UserSize
CLIPFORMAT_UserUnmarshal
CLSIDFromProgID
CLSIDFromString
CSUMCompute
CStdStubBuffer_AddRef
CStdStubBuffer_Connect
CStdStubBuffer_CountRefs
CStdStubBuffer_DebugServerQueryInterface
CStdStubBuffer_DebugServerRelease
CStdStubBuffer_Disconnect
CStdStubBuffer_Invoke
CStdStubBuffer_IsIIDSupported
CStdStubBuffer_QueryInterface
CallMsgFilterA
CallNamedPipeA
CallNextHookEx
CallWindowProcA
Callback12
Callback16
Callback20
Callback24
Callback28
Callback32
Callback36
Callback4
Callback40
Callback44
Callback48
Callback52
Callback56
Callback60
Callback64
Callback8
CanResourceBeDependent
CancelDC
CancelIo
CancelNtmsLibraryRequest
CancelNtmsOperatorRequest
CancelOverlappedAccess
CancelWaitableTimer
CaptureAndConvertAnsiArg
CaptureStringArg
CascadeChildWindows
CascadeWindows
CbOfEncoded
CchOfEncoding
CenterDialog
CenterWindowRelativeToParent
CertAddCRLContextToStore
CertAddCTLContextToStore
CertAddCertificateContextToStore
CertAddEncodedCRLToStore
CertAddEncodedCTLToStore
CertAddEncodedCertificateToStore
CertAddEncodedCertificateToSystemStoreA
CertAddEnhancedKeyUsageIdentifier
CertAddSerializedElementToStore
CertAlgIdToOID
CertCloseStore
CertCompareCertificate
CertCompareCertificateName
CertCompareIntegerBlob
CertComparePublicKeyInfo
CertCreateCRLContext
CertCreateCTLContext
CertCreateCertificateContext
CertDeleteCRLFromStore
CertDeleteCTLFromStore
CertDeleteCertificateFromStore
CertDuplicateCRLContext
CertDuplicateCTLContext
CertDuplicateCertificateContext
CertDuplicateStore
CertEnumCRLContextProperties
CertEnumCTLContextProperties
CertEnumCTLsInStore
CertEnumCertificateContextProperties
CertEnumCertificatesInStore
CertFindAttribute
CertFindCTLInStore
CertFindCertificateInStore
CertFindExtension
CertFindRDNAttr
CertFindSubjectInCTL
CertFreeCRLContext
CertFreeCTLContext
CertFreeCertificateContext
CertGetCRLContextProperty
CertGetCRLFromStore
CertGetCTLContextProperty
CertGetCertificateContextProperty
CertGetEnhancedKeyUsage
CertGetIntendedKeyUsage
CertGetIssuerCertificateFromStore
CertGetSubjectCertificateFromStore
CertIsRDNAttrsInCertificateName
CertNameToStrA
CertOIDToAlgId
CertOpenStore
CertOpenSystemStoreA
CertRDNValueToStrA
CertRemoveEnhancedKeyUsageIdentifier
CertSaveStore
CertSerializeCRLStoreElement
CertSerializeCTLStoreElement
CertSerializeCertificateStoreElement
CertSetCRLContextProperty
CertSetCTLContextProperty
CertSetCertificateContextProperty
CertSetEnhancedKeyUsage
CertStrToNameA
CertVerifyCRLRevocation
CertVerifyCRLTimeValidity
CertVerifyCTLUsage
CertVerifyRevocation
CertVerifySubjectCertificateContext
CertVerifyTimeValidity
CertVerifyValidityNesting
ChangeClipboardChain
ChangeClusterResourceGroup
ChangeDisplaySettingsA
ChangeDisplaySettingsExA
ChangeIdleRoutine
ChangeMenuA
ChangeServiceConfig2A
ChangeServiceConfigA
ChangeSupervisorPassword
CharLowerA
CharLowerBuffA
CharNextA
CharNextExA
CharPrevA
CharPrevExA
CharToOemA
CharToOemBuffA
CharUpperA
CharUpperBuffA
CharacterToSymbol
CheckBitmapBits
CheckColors
CheckColorsInGamut
CheckDlgButton
CheckEscapesA
CheckMenuItem
CheckMenuRadioItem
CheckRadioButton
CheckSumMappedFile
ChildWindowFromPoint
ChildWindowFromPointEx
ChooseColorA
ChooseFontA
ChoosePixelFormat
Chord
ChrCmpIA
CleanNtmsDrive
CleanUp
ClearCommBreak
ClearCommError
ClearCustData
ClearEventLogA
ClientToScreen
ClipCursor
CloseClipboard
CloseCluster
CloseClusterGroup
CloseClusterNetInterface
CloseClusterNetwork
CloseClusterNode
CloseClusterNotifyPort
CloseClusterResource
CloseColorProfile
CloseConsoleHandle
CloseDesktop
CloseDriver
CloseEnhMetaFile
CloseEventLog
CloseFigure
CloseHandle
CloseIMsgSession
CloseMetaFile
CloseNtmsNotification
CloseNtmsSession
ClosePrinter
CloseProfileUserMapping
CloseRaw
CloseServiceHandle
CloseWindow
CloseWindowStation
ClusWorkerCheckTerminate
ClusWorkerCreate
ClusWorkerStart
ClusWorkerTerminate
ClusterCloseEnum
ClusterEnum
ClusterGroupCloseEnum
ClusterGroupControl
ClusterGroupEnum
ClusterGroupOpenEnum
ClusterNetInterfaceControl
ClusterNetworkCloseEnum
ClusterNetworkControl
ClusterNetworkEnum
ClusterNetworkOpenEnum
ClusterNodeCloseEnum
ClusterNodeControl
ClusterNodeEnum
ClusterNodeOpenEnum
ClusterOpenEnum
ClusterRegCloseKey
ClusterRegCreateKey
ClusterRegDeleteKey
ClusterRegDeleteValue
ClusterRegEnumKey
ClusterRegEnumValue
ClusterRegGetKeySecurity
ClusterRegOpenKey
ClusterRegQueryInfoKey
ClusterRegQueryValue
ClusterRegSetKeySecurity
ClusterRegSetValue
ClusterResourceCloseEnum
ClusterResourceControl
ClusterResourceEnum
ClusterResourceOpenEnum
ClusterResourceTypeControl
ClusterSplClose
ClusterSplIsAlive
ClusterSplOpen
CmdBatNotification
CoAddRefServerProcess
CoBuildVersion
CoCancelCall
CoCopyProxy
CoCreateFreeThreadedMarshaler
CoCreateGuid
CoCreateInstance
CoCreateInstanceEx
CoDisconnectObject
CoDosDateTimeToFileTime
CoFileTimeNow
CoFileTimeToDosDateTime
CoFreeAllLibraries
CoFreeLibrary
CoFreeUnusedLibraries
CoGetCallContext
CoGetCallerTID
CoGetCancelObject
CoGetClassAccess
CoGetClassInfo
CoGetClassObject
CoGetClassObjectFromURL
CoGetCurrentLogicalThreadId
CoGetCurrentProcess
CoGetInstanceFromFile
CoGetInstanceFromIStorage
CoGetInterfaceAndReleaseStream
CoGetMalloc
CoGetMarshalSizeMax
CoGetObject
CoGetPSClsid
CoGetPublishedAppInfo
CoGetStandardMarshal
CoGetState
CoGetStaticMarshal
CoGetStaticObjectPacket
CoGetStdMarshalEx
CoGetTIDFromIPID
CoGetTreatAsClass
CoImpersonateClient
CoInitialize
CoInitializeEx
CoInitializeSecurity
CoInstall
CoInternetCombineUrl
CoInternetCompareUrl
CoInternetCreateSecurityManager
CoInternetCreateZoneManager
CoInternetGetProtocolFlags
CoInternetGetSecurityUrl
CoInternetGetSession
CoInternetParseUrl
CoInternetQueryInfo
CoIsHandlerConnected
CoIsOle1Class
CoLoadLibrary
CoLockObjectExternal
CoMarshalHresult
CoMarshalInterThreadInterfaceInStream
CoMarshalInterface
CoQueryAuthenticationServices
CoQueryClientBlanket
CoQueryProxyBlanket
CoQueryReleaseObject
CoRegisterChannelHook
CoRegisterClassObject
CoRegisterMallocSpy
CoRegisterMessageFilter
CoRegisterPSClsid
CoRegisterSurrogate
CoReleaseMarshalData
CoReleaseServerProcess
CoResumeClassObjects
CoRevertToSelf
CoRevokeClassObject
CoRevokeMallocSpy
CoSetCancelObject
CoSetProxyBlanket
CoSetState
CoSuspendClassObjects
CoSwitchCallContext
CoTaskMemAlloc
CoTaskMemFree
CoTaskMemRealloc
CoTestCancel
CoTreatAsClass
CoUninitialize
CoUnmarshalHresult
CoUnmarshalInterface
ColorCorrectPalette
ColorMatchToTarget
CombineRgn
CombineTransform
CommConfigDialogA
CommDlgExtendedError
CommitUrlCacheEntryA
CompareFileTime
CompareStringA
ComponentFromIndex
CompressPenData
ConcatenatePaths
ConfigHREC
ConfigurePortA
ConnectNamedPipe
ConnectToPrinterDlg
ConsoleMenuControl
ContainsPalette
ContinueDebugEvent
ControlService
ConvertAccessToSecurityDescriptorA
ConvertAnsiDevModeToUnicodeDevmode
ConvertDefaultLocale
ConvertSecurityDescriptorToAccessA
ConvertSecurityDescriptorToAccessNamedA
ConvertThreadToFiber
ConvertToAutoInheritPrivateObjectSecurity
ConvertUnicodeDevModeToAnsiDevmode
CopyAcceleratorTableA
CopyBindInfo
CopyEnhMetaFileA
CopyFileA
CopyFileExA
CopyIcon
CopyImage
CopyLZFile
CopyMetaFileA
CopyPdb
CopyRect
CopySid
CopyStgMedium
CorrectWriting
CountClipboardFormats
CreateAcceleratorTableA
CreateAntiMoniker
CreateAsyncBindCtx
CreateAsyncBindCtxEx
CreateAudioMediaType
CreateBindCtx
CreateBindProtocol
CreateBitmap
CreateBitmapIndirect
CreateBrushIndirect
CreateCIPalette
CreateCaret
CreateClassMoniker
CreateClusterGroup
CreateClusterNotifyPort
CreateClusterResource
CreateClusterResourceType
CreateColorSpaceA
CreateColorTransformA
CreateCompatibleBitmap
CreateCompatibleDC
CreateCompatibleHRC
CreateConsoleScreenBuffer
CreateCursor
CreateDCA
CreateDIBPatternBrush
CreateDIBPatternBrushPt
CreateDIBSection
CreateDIBitmap
CreateDataAdviseHolder
CreateDataCache
CreateDesktopA
CreateDeviceLinkProfile
CreateDialogIndirectParamA
CreateDialogParamA
CreateDirectoryA
CreateDirectoryExA
CreateDiscardableBitmap
CreateDispTypeInfo
CreateEditableStream
CreateEllipticRgn
CreateEllipticRgnIndirect
CreateEnhMetaFileA
CreateErrorInfo
CreateEventA
CreateFiber
CreateFileA
CreateFileMappingA
CreateFileMoniker
CreateFileU
CreateFontA
CreateFontIndirectA
CreateFontIndirectExA
CreateFormatEnumerator
CreateGenericComposite
CreateHWL
CreateHalftonePalette
CreateHardLinkA
CreateHatchBrush
CreateICA
CreateILockBytesOnHGlobal
CreateIProp
CreateIcon
CreateIconFromResource
CreateIconFromResourceEx
CreateIconIndirect
CreateInkset
CreateInksetHRCRESULT
CreateIoCompletionPort
CreateItemMoniker
CreateJobObjectA
CreateMDIWindowA
CreateMailslotA
CreateMappedBitmap
CreateMemoryAllocator
CreateMenu
CreateMetaFileA
CreateMultiProfileTransform
CreateMutexA
CreateNamedPipeA
CreateNtmsMediaPoolA
CreateOleAdviseHolder
CreatePalette
CreatePatternBrush
CreatePen
CreatePenDataEx
CreatePenDataHRC
CreatePenDataRegion
CreatePenIndirect
CreatePipe
CreatePointerMoniker
CreatePolyPolygonRgn
CreatePolygonRgn
CreatePopupMenu
CreatePosPassThru
CreatePrinterIC
CreatePrivateObjectSecurity
CreatePrivateObjectSecurityEx
CreateProcessA
CreateProcessAsUserA
CreateProfileFromLogColorSpaceA
CreatePropertySheetPageA
CreateRGBPalette
CreateRectRgn
CreateRectRgnIndirect
CreateRemoteThread
CreateRestrictedToken
CreateRoundRectRgn
CreateScalableFontResourceA
CreateSemaphoreA
CreateServiceA
CreateSocketPort
CreateSolidBrush
CreateStatusWindowA
CreateStdAccessibleObject
CreateStdDispaôch
CreateStdProgressIndicator
CreateStreamOnHGlobal
CreateTable
CreateTapePartition
CreateTestList
CreateThread
CreateToolbar
CreateToolbarEx
CreateToolhelp32Snapshot
CreateTypeLib
CreateTypeLib2
CreateURLMoniker
CreateUpDownControl
CreateUrlCacheContainerA
CreateUrlCacheEntryA
CreateUrlCacheGroup
CreateVirtualBuffer
CreateWaitableTimerA
CreateWindowExA
CreateWindowStationA
CryptAcquireContextA
CryptAcquireContextU
CryptContextAddRef
CryptCreateHash
CryptDecodeMessage
CryptDecodeObject
CryptDecrypt
CryptDecryptAndVerifyMessageSignature
CryptDecryptMessage
CryptDeriveKey
CryptDestroyHash
CryptDestroyKey
CryptDuplicateHash
CryptDuplicateKey
CryptEncodeObject
CryptEncrypt
CryptEncryptMessage
CryptEnumOIDFunction
CryptEnumProviderTypesA
CryptEnumProvidersA
CryptExportKey
CryptExportPublicKeyInfo
CryptExportPublicKeyInfoEx
CryptFormatObject
CryptFreeOIDFunctionAddress
CryptGenKey
CryptGenRandom
CryptGetDefaultOIDDllList
CryptGetDefaultOIDFunctionAddress
CryptGetDefaultProviderA
CryptGetHashParam
CryptGetKeyParam
CryptGetMessageCertificates
CryptGetMessageSignerCount
CryptGetOIDFunctionAddress
CryptGetOIDFunctionValue
CryptGetProvParam
CryptGetUserKey
CryptHashCertificate
CryptHashData
CryptHashMessage
CryptHashPublicKeyInfo
CryptHashSessionKey
CryptHashToBeSigned
CryptImportKey
CryptImportPublicKeyInfo
CryptImportPublicKeyInfoEx
CryptInitOIDFunctionSet
CryptInstallOIDFunctionAddress
CryptLoadSip
CryptMsgCalculateEncodedLength
CryptMsgClose
CryptMsgControl
CryptMsgCountersign
CryptMsgCountersignEncoded
CryptMsgEncodeAndSignCTL
CryptMsgGetAndVerifySigner
CryptMsgGetParam
CryptMsgOpenToDecode
CryptMsgOpenToEncode
CryptMsgSignCTL
CryptMsgUpdate
CryptMsgVerifyCountersignatureEncoded
CryptRegisterDefaultOIDFunction
CryptRegisterOIDFunction
CryptReleaseContext
CryptSIPRetrieveSubjectGuid
CryptSetHashParam
CryptSetKeyParam
CryptSetOIDFunctionValue
CryptSetProvParam
CryptSetProviderA
CryptSetProviderExA
CryptSetProviderU
CryptSignAndEncodeCertificate
CryptSignAndEncryptMessage
CryptSignCertificate
CryptSignHashA
CryptSignHashU
CryptSignMessage
CryptSignMessageWithKey
CryptUnregisterDefaultOIDFunction
CryptUnregisterOIDFunction
CryptVerifyCertificateSignature
CryptVerifyDetachedMessageHash
CryptVerifyDetachedMessageSignature
CryptVerifyMessageHash
CryptVerifyMessageSignature
CryptVerifyMessageSignatureWithKey
CryptVerifySignatureA
CryptVerifySignatureU
CursorLibTransact
D3DRMColorGetAlpha
D3DRMColorGetBlue
D3DRMColorGetGreen
D3DRMColorGetRed
D3DRMCreateColorRGBA
D3DRMMatrixFromQuaternion
D3DRMQuaternionFromRotation
D3DRMQuaternionMultiply
D3DRMQuaternionSlerp
D3DRMVectorAdd
D3DRMVectorCrossProduct
D3DRMVectorDotProduct
D3DRMVectorModulus
D3DRMVectorNormalize
D3DRMVectorRandom
D3DRMVectorReflect
D3DRMVectorRotate
D3DRMVectorScale
D3DRMVectorSubtract
DBToAmpFactor
DComp_Close
DComp_DecompressBlock
DComp_Init
DComp_Reset
DComp_Ring_Close
DComp_Ring_Init
DComp_Ring_Load
DComp_Ring_Reset
DDHAL32_VidMemAlloc
DDHAL32_VidMemFree
DDInternalLock
DDInternalUnlock
DDMGetPhonebookInfo
DEVICECAPABILITIES
DEVICEMODE
DLLInit
DPtoLP
DPtoTP
DSoundHelp
DceErrorInqTextA
DdeAbandonTransaction
DdeAccessData
DdeAddData
DdeClientTransaction
DdeCmpStringHandles
DdeConnect
DdeConnectList
DdeCreateDataHandle
DdeCreateStringHandleA
DdeDisconnect
DdeDisconnectList
DdeEnableCallback
DdeFreeDataHandle
DdeFreeStringHandle
DdeGetData
DdeGetLastError
DdeGetQualityOfService
DdeImpersonateClient
DdeInitializeA
DdeKeepStringHandle
DdeNameService
DdePostAdvise
DdeQueryConvInfo
DdeQueryNextServer
DdeQueryStringA
DdeReconnect
DdeSetQualityOfService
DdeSetUserHandle
DdeUnaccessData
DdeUninitialize
DeallocateNtmsMedia
DebugActiveProcess
DebugBreak
DecommissionNtmsMedia
DecryptFileA
DefDlgProcA
DefDriverProc
DefFrameProcA
DefMDIChildProcA
DefScreenSaverProc
DefWindowProcA
DefaultHandleExpose
DefaultHandleReshape
DeferWindowPos
DefineDosDeviceA
DeinitMapiUtil
DelayPaletteRealization
DelayedMove
DeleteAce
DeleteAtom
DeleteClusterGroup
DeleteClusterResource
DeleteClusterResourceType
DeleteColorSpace
DeleteColorTransform
DeleteCriticalSection
DeleteDC
DeleteEnhMetaFile
DeleteFiber
DeleteFileA
DeleteFormA
DeleteIE3Cache
DeleteMenu
DeleteMetaFile
DeleteMonitorA
DeleteNtmsLibrary
DeleteNtmsMedia
DeleteNtmsMediaPool
DeleteObject
DeletePerMachineConnectionA
DeletePortA
DeletePrintProcessorA
DeletePrintProvidorA
DeletePrinter
DeletePrinterConnectionA
DeletePrinterDataA
DeletePrinterDataExA
DeletePrinterDriverA
DeletePrinterDriverExA
DeletePrinterIC
DeletePrinterKeyA
DeleteService
DeleteSocketPort
DeleteUrlCacheContainerA
DeleteUrlCacheEntry
DeleteUrlCacheGroup
DelimStringToMultiSz
DeregisterEventSource
DeregisterIdleRoutine
DescribePixelFormat
DestroyAcceleratorTable
DestroyCaret
DestroyCursor
DestroyHRC
DestroyHRCRESULT
DestroyHWL
DestroyIcon
DestroyInkset
DestroyMenu
DestroyPenData
DestroyPrivateObjectSecurity
DestroyPropertySheetPage
DestroyTextFileReadBuffer
DestroyThisWindow
DestroyWindow
DevQueryPrint
DevQueryPrintEx
DeviceCapabilitiesA
DeviceCapabilitiesExA
DeviceIoControl
DeviceMode
DevicePropertySheets
DialogBoxIndirectParamA
DialogBoxParamA
DibNumColors
Direct3DRMCreate
DirectDrawCreate
DirectDrawCreateClipper
DirectDrawCreateFromDevice
DirectDrawCreateFromDeviceEx
DirectDrawEnumerateA
DirectInputCreateA
DirectPlayCreate
DirectPlayEnumerateA
DirectPlayLobbyCreateA
DirectSoundCaptureCreate
DirectSoundCaptureEnumerateA
DirectSoundCreate
DirectSoundEnumerateA
DirectXDeviceDriverSetupA
DirectXLoadString
DirectXRegisterApplicationA
DirectXSetupA
DirectXSetupCallback
DirectXSetupGetVersion
DirectXSetupIsJapan
DirectXSetupIsJapanNec
DirectXSetupSetCallback
DirectXUnRegisterApplication
DisableNtmsObject
DisableThreadLibraryCalls
DisassociateColorProfileFromDeviceA
DisconnectNamedPipe
DismountNtmsDrive
DismountNtmsMedia
DispCallFunc
DispGetIDsOfNames
DispGetParam
DispInvoke
DispatchMessageA
DlcCallDriver
DlgDirListA
DlgDirListComboBoxA
DlgDirSelectComboBoxExA
DlgDirSelectExA
DllCanUnloadNow
DllDebugObjectRPCHook
DllEntryPoint
DllGetClassObject
DllInitialize
DoChangePw
DoConfigBox
DoDefaultPenInput
DoDragDrop
DoEnvironmentSubstA
DoInstallActionWithParams
DoPasswordCheck
DoSaverPreview
DoScreenSave
DocumentEvent
DocumentPropertiesA
DocumentPropertySheets
DoesUserHavePrivilege
DosDateTimeToFileTime
DosDateTimeToVariantTime
DragAcceptFiles
DragDetect
DragFinish
DragObject
DragQueryFileA
DragQueryPoint
DrawAnimatedRects
DrawBitmap
DrawCaption
DrawDibBegin
DrawDibChangePalette
DrawDibClose
DrawDibDraw
DrawDibEnd
DrawDibGetBuffer
DrawDibGetPalette
DrawDibOpen
DrawDibProfileDisplay
DrawDibRealize
DrawDibSetPalette
DrawDibStart
DrawDibStop
DrawDibTime
DrawEdge
DrawEscape
DrawFocusRect
DrawFrame
DrawFrameControl
DrawIcon
DrawIconEx
DrawInsert
DrawMenuBar
DrawPenDataEx
DrawStateA
DrawStatusTextA
DrawTextA
DrawTextExA
DriverCallback
DrvGetModuleHandle
DsGetDcClose
DsGetDcNameA
DsGetDcNext
DsGetDcOpen
DsGetSiteNameA
DsValidateSubnetNameA
DummyEntry
DuplicateConsoleHandle
DuplicateHandle
DuplicateIcon
DuplicatePenData
DuplicateString
DuplicateToken
DuplicateTokenEx
EXTDEVICEMODE
EditStreamClone
EditStreamCopy
EditStreamCut
EditStreamPaste
EditStreamSetInfoA
EditStreamSetNameA
EditWndProc
EjectNtmsCleaner
EjectNtmsMedia
ElfBackupEventLogFileA
ElfChangeNotify
ElfClearEventLogFileA
ElfCloseEventLog
ElfDeregisterEventSource
ElfNumberOfRecords
ElfOldestRecord
ElfOpenBackupEventLogA
ElfOpenEventLogA
ElfReadEventLogA
ElfRegisterEventSourceA
ElfReportEventA
EliminateSubKey
Ellipse
EmptyClipboard
EnableEUDC
EnableGestureSetHRC
EnableHookObject
EnableIdleRoutine
EnableMenuItem
EnableNtmsObject
EnablePrivilege
EnableScrollBar
EnableSystemDictionaryHRC
EnableWindow
EncodeID
EncryptFileA
EndDeferWindowPos
EndDialog
EndDoc
EndDocPrinter
EndMenu
EndPage
EndPagePrinter
EndPaint
EndPath
EndPenInputHRC
EndUpdateResourceA
EnterCriticalSection
EnumCalendarInfoA
EnumCalendarInfoExA
EnumChildWindows
EnumClipboardFormats
EnumColorProfilesA
EnumDateFormatsA
EnumDateFormatsExA
EnumDependentServicesA
EnumDesktopWindows
EnumDesktopsA
EnumDisplayMonitors
EnumDisplaySettingsA
EnumDisplaySettingsExA
EnumEnhMetaFile
EnumFontFamiliesA
EnumFontFamiliesExA
EnumFontsA
EnumFormsA
EnumICMProfilesA
EnumJobsA
EnumMetaFile
EnumMonitorsA
EnumObjects
EnumPerMachineConnectionsA
EnumPortsA
EnumPrintProcessorDatatypesA
EnumPrintProcessorsA
EnumPrinterDataA
EnumPrinterDataExA
EnumPrinterDriversA
EnumPrinterKeyA
EnumPrinterPropertySheets
EnumPrintersA
EnumPropsA
EnumPropsExA
EnumProtocolsA
EnumResourceLanguagesA
EnumResourceNamesA
EnumResourceTypesA
EnumServicesStatusA
EnumSystemCodePagesA
EnumSystemLocalesA
EnumThreadWindows
EnumTimeFormatsA
EnumWindowStationsA
EnumWindows
EnumerateLoadedModules
EnumerateMonitors
EnumerateNtmsObject
EqualPrefixSid
EqualRect
EqualRgn
EqualSid
EraseTape
ErfSetCodes
Escape
EscapeCommFunction
EvictClusterNode
ExcludeClipRect
ExcludeUpdateRgn
ExitProcess
ExitThread
ExitVDM
ExitWindowsEx
ExpandEnvironmentStringsA
ExportNtmsDatabase
ExpungeConsoleCommandHistoryA
ExtCreatePen
ExtCreateRegion
ExtDeviceMode
ExtEscape
ExtFloodFill
ExtSelectClipRgn
ExtTextOutA
ExtendVirtualBuffer
ExtensionPropSheetPageProc
Extract
ExtractAssociatedIconA
ExtractAssociatedIconExA
ExtractIconA
ExtractIconExA
ExtractIconResInfoA
ExtractPenDataPoints
ExtractPenDataStrokes
FAbortCheck
FBadColumnSet
FBadEntryList
FBadProp
FBadPropTag
FBadRestriction
FBadRglpNameID
FBadRglpszA
FBadRow
FBadRowSet
FBadSortOrderSet
FBinFromHex
FDIGetDataBlock
FDIGetFile
FDIReadCFDATAEntry
FDIReadCFFILEEntry
FDIReadPSZ
FDecodeID
FEqualNames
FORWARD_FUNCTION
FPropCompareProp
FPropContainsProp
FPropExists
FailClusterResource
FatalAppExitA
FatalExit
FileExists
FileTimeToDosDateTime
FileTimeToLocalFileTime
FileTimeToSystemTime
FillConsoleOutputAttribute
FillConsoleOutputCharacterA
FillPath
FillRect
FillRgbPaletteEntries
FillRgn
FindAtomA
FindBestPixelFormat
FindClose
FindCloseChangeNotification
FindClosePrinterChangeNotification
FindCloseUrlCache
FindDebugInfoFile
FindExactPixelFormat
FindExeDlgProc
FindExecutableA
FindExecutableImage
FindFileDir
FindFirstChangeNotificationA
FindFirstFileA
FindFirstFileExA
FindFirstFreeAce
FindFirstPrinterChangeNotification
FindFirstUrlCacheContainerA
FindFirstUrlCacheEntryA
FindFirstUrlCacheEntryExA
FindMediaType
FindMediaTypeClass
FindMimeFromData
FindNextChangeNotification
FindNextFileA
FindNextPrinterChangeNotification
FindNextUrlCacheContainerA
FindNextUrlCacheEntryA
FindNextUrlCacheEntryExA
FindPixelFormat
FindResourceA
FindResourceExA
FindTextA
FindWindowA
FindWindowExA
FixBrushOrgEx
FlashWindow
FlatSB_EnableScrollBar
FlatSB_GetScrollInfo
FlatSB_GetScrollPos
FlatSB_GetScrollProp
FlatSB_GetScrollRange
FlatSB_SetScrollInfo
FlatSB_SetScrollPos
FlatSB_SetScrollProp
FlatSB_SetScrollRange
FlatSB_ShowScrollBar
FlattenPath
FloodFill
FlushConsoleInputBuffer
FlushFileBuffers
FlushInstructionCache
FlushPalette
FlushViewOfFile
FmtIdToPropStgName
FoldStringA
ForceRedraw
FormatCharDlgProc
FormatMessageA
FrameRect
FrameRgn
FreeADsMem
FreeADsStr
FreeBSTR
FreeConsole
FreeDDElParam
FreeEnvironmentStringsA
FreeIconList
FreeLibrary
FreeLibraryAndExitThread
FreeMemory
FreePadrlist
FreePrinterNotifyInfo
FreePropVariantArray
FreeProws
FreeResource
FreeSid
FreeStringArray
FreeUrlCacheSpaceA
FreeVirtualBuffer
FtAdcFt
FtAddFt
FtDivFtBogus
FtMulDw
FtMulDwDw
FtNegFt
FtSubFt
FtgRegisterIdleRoutine
FtpCreateDirectoryA
FtpDeleteFileA
FtpFindFirstFileA
FtpGetCurrentDirectoryA
FtpGetFileA
FtpOpenFileA
FtpPutFileA
FtpRemoveDirectoryA
FtpRenameFileA
FtpSetCurrentDirectoryA
FwBindFwInterfaceToAdapter
FwConnectionRequestFailed
FwCreateInterface
FwDeleteInterface
FwDisableFwInterface
FwEnableFwInterface
FwGetInterface
FwGetNotificationResult
FwGetStaticNetbiosNames
FwNotifyConnectionRequest
FwSetInterface
FwSetStaticNetbiosNames
FwStart
FwStop
FwUnbindFwInterfaceFromAdapter
FwUpdateRouteTable
GdiComment
GdiDeleteSpoolFileHandle
GdiEndDocEMF
GdiEndPageEMF
GdiFlush
GdiGetBatchLimit
GdiGetDC
GdiGetDevmodeForPage
GdiGetPageCount
GdiGetPageHandle
GdiGetSpoolFileHandle
GdiPlayDCScript
GdiPlayEMF
GdiPlayJournal
GdiPlayPageEMF
GdiPlayPrivatePageEMF
GdiPlayScript
GdiResetDCEMF
GdiSetBatchLimit
GdiStartDocEMF
GdiStartPageEMF
GenerateConsoleCtrlEvent
GenerateCopyFilePaths
GetACP
GetAcceptExSockaddrs
GetAccessPermissionsForObjectA
GetAce
GetAclInformation
GetActiveObject
GetActiveWindow
GetAddressByNameA
GetAlphabetHRC
GetAlphabetPriorityHRC
GetAltMonthNames
GetAltTabInfoA
GetAlternateWordsHRCRESULT
GetAncestor
GetArcDirection
GetAspectRatioFilterEx
GetAsyncKeyState
GetAtomNameA
GetAttribIMsgOnIStg
GetAuditedPermissionsFromAclA
GetAutoTests
GetBinaryTypeA
GetBitCount
GetBitmapBits
GetBitmapDimensionEx
GetBitmapFormatSize
GetBitmapPalette
GetBitmapSize
GetBitmapSubtype
GetBkColor
GetBkMode
GetBoundsRect
GetBoxMappingHRCRESULT
GetBoxResultsHRC
GetBrushOrgEx
GetCMMInfo
GetCPInfo
GetCPInfoExA
GetCapture
GetCaretBlinkTime
GetCaretPos
GetCharABCWidthsA
GetCharABCWidthsFloatA
GetCharABCWidthsI
GetCharWidth32A
GetCharWidthA
GetCharWidthFloatA
GetCharWidthI
GetCharacterPlacementA
GetClassFile
GetClassFileOrMime
GetClassInfoA
GetClassInfoExA
GetClassLongA
GetClassNameA
GetClassURL
GetClassWord
GetClientRect
GetClipBox
GetClipCursor
GetClipRgn
GetClipboardData
GetClipboardFormatNameA
GetClipboardOwner
GetClipboardSequenceNumber
GetClipboardViewer
GetClusterGroupKey
GetClusterGroupState
GetClusterInformation
GetClusterKey
GetClusterNetInterface
GetClusterNetInterfaceKey
GetClusterNetInterfaceState
GetClusterNetworkId
GetClusterNetworkKey
GetClusterNetworkState
GetClusterNodeId
GetClusterNodeKey
GetClusterNodeState
GetClusterNotify
GetClusterQuorumResource
GetClusterResourceKey
GetClusterResourceNetworkName
GetClusterResourceState
GetClusterResourceTypeKey
GetColorAdjustment
GetColorDirectoryA
GetColorProfileElement
GetColorProfileElementTag
GetColorProfileFromHandle
GetColorProfileHeader
GetColorSpace
GetComboBoxInfo
GetCommConfig
GetCommMask
GetCommModemStatus
GetCommProperties
GetCommState
GetCommTimeouts
GetCommandLineA
GetCompressedFileSizeA
GetComputerNameA
GetConsoleAliasA
GetConsoleAliasExesA
GetConsoleAliasExesLengthA
GetConsoleAliasesA
GetConsoleAliasesLengthA
GetConsoleCP
GetConsoleCommandHistoryA
GetConsoleCommandHistoryLengthA
GetConsoleCursorInfo
GetConsoleDisplayMode
GetConsoleFontInfo
GetConsoleFontSize
GetConsoleHardwareState
GetConsoleInputExeNameA
GetConsoleInputWaitHandle
GetConsoleKeyboardLayoutNameA
GetConsoleMode
GetConsoleOutputCP
GetConsoleScreenBufferInfo
GetConsoleTitleA
GetConsoleWindow
GetConvertStg
GetCount
GetCountColorProfileElements
GetCurrencyFormatA
GetCurrentConsoleFont
GetCurrentDirectoryA
GetCurrentHwProfileA
GetCurrentObject
GetCurrentPositionEx
GetCurrentProcess
GetCurrentProcessId
GetCurrentThread
GetCurrentThreadId
GetCursor
GetCursorInfo
GetCursorPos
GetDC
GetDCBrushColor
GetDCEx
GetDCOrgEx
GetDCPenColor
GetDIBColorTable
GetDIBits
GetDateFormatA
GetDefaultCommConfigA
GetDefaultPrinterA
GetDesktopWindow
GetDeviceCaps
GetDeviceGammaRamp
GetDevicePowerState
GetDialogBaseUnits
GetDiskFreeSpaceA
GetDiskFreeSpaceExA
GetDlgCtrlID
GetDlgItem
GetDlgItemInt
GetDlgItemTextA
GetDocumentBitStg
GetDoubleClickTime
GetDriveTypeA
GetDriverModuleHandle
GetEffectiveClientRect
GetEffectiveRightsFromAclA
GetElapsedTime
GetEnhMetaFileA
GetEnhMetaFileBits
GetEnhMetaFileDescriptionA
GetEnhMetaFileHeader
GetEnhMetaFilePaletteEntries
GetEnhMetaFilePixelFormat
GetEnvironmentStringsA
GetEnvironmentVariableA
GetErrorInfo
GetExitCodeProcess
GetExitCodeThread
GetExpandedNameA
GetExplicitEntriesFromAclA
GetFileAttributesA
GetFileAttributesExA
GetFileInformationByHandle
GetFileSecurityA
GetFileSize
GetFileTime
GetFileTitleA
GetFileType
GetFileVersionInfoA
GetFileVersionInfoSizeA
GetFilters
GetFocus
GetFontAssocStatus
GetFontData
GetFontLanguageInfo
GetFontUnicodeRanges
GetForegroundWindow
GetFormA
GetFullPathNameA
GetGUIThreadInfo
GetGlyphIndicesA
GetGlyphOutlineA
GetGraphicsMode
GetGuiResources
GetGuideHRC
GetHGlobalFromILockBytes
GetHGlobalFromStream
GetHRECFromHRC
GetHandleInformation
GetHookInterface
GetHotspotsHRCRESULT
GetICMProfileA
GetIconInfo
GetImageConfigInformation
GetImageUnusedHeaderBytes
GetIniNameUsage
GetInksetInterval
GetInksetIntervalCount
GetInputDesktop
GetInputState
GetInterface
GetInternationalHRC
GetJobA
GetKBCodePage
GetKernelObjectSecurity
GetKerningPairsA
GetKeyNameTextA
GetKeyState
GetKeyboardLayout
GetKeyboardLayoutList
GetKeyboardLayoutNameA
GetKeyboardState
GetKeyboardType
GetLargestConsoleWindowSize
GetLastActivePopup
GetLastError
GetLastInputInfo
GetLengthSid
GetListBoxInfo
GetLocalTime
GetLocaleInfoA
GetLogColorSpaceA
GetLogFile
GetLogicalDriveStringsA
GetLogicalDrives
GetLongPathNameA
GetMailslotInfo
GetMapMode
GetMaxResultsHRC
GetMenu
GetMenuBarInfo
GetMenuCheckMarkDimensions
GetMenuContextHelpId
GetMenuDefaultItem
GetMenuInfo
GetMenuItemCount
GetMenuItemID
GetMenuItemInfoA
GetMenuItemRect
GetMenuPosFromID
GetMenuState
GetMenuStringA
GetMessageA
GetMessageExtraInfo
GetMessagePos
GetMessageTime
GetMetaFileA
GetMetaFileBitsEx
GetMetaRgn
GetMiterLimit
GetModuleFileNameA
GetModuleHandleA
GetMonitorInfoA
GetMouseMovePoints
GetMultipleTrusteeA
GetMultipleTrusteeOperationA
GetNameByTypeA
GetNamedPipeHandleStateA
GetNamedPipeInfo
GetNamedSecurityInfoA
GetNamedSecurityInfoExA
GetNearestColor
GetNearestPaletteIndex
GetNewInfName
GetNextDlgGroupItem
GetNextDlgTabItem
GetNextVDMCommand
GetNtmsMediaPoolNameA
GetNtmsObjectAttributeA
GetNtmsObjectInformationA
GetNtmsObjectSecurity
GetNumberFormatA
GetNumberOfConsoleFonts
GetNumberOfConsoleInputEvents
GetNumberOfConsoleMouseButtons
GetNumberOfEventLogRecords
GetOEMCP
GetObjectA
GetObjectType
GetOldestEventLogRecord
GetOpenCardNameA
GetOpenClipboardWindow
GetOpenFileNameA
GetOpenFileNamePreviewA
GetOutlineTextMetricsA
GetOverlappedAccessResults
GetOverlappedResult
GetPS2ColorRenderingDictionary
GetPS2ColorRenderingIntent
GetPS2ColorSpaceArray
GetPaletteEntries
GetParent
GetPath
GetPenAppFlags
GetPenAsyncState
GetPenDataAttributes
GetPenDataInfo
GetPenInput
GetPenMiscInfo
GetPixel
GetPixelFormat
GetPointsFromPenData
GetPolyFillMode
GetPrintProcessorDirectoryA
GetPrinterA
GetPrinterDataA
GetPrinterDataExA
GetPrinterDriverA
GetPrinterDriverDirectoryA
GetPrinterHTMLViewA
GetPrinterWebInformation
GetPriorityClass
GetPriorityClipboardFormat
GetPrivateObjectSecurity
GetPrivateProfileIntA
GetPrivateProfileSectionA
GetPrivateProfileSectionNamesA
GetPrivateProfileStringA
GetPrivateProfileStructA
GetProcAddress
GetProcessAffinityMask
GetProcessHeap
GetProcessHeaps
GetProcessPriorityBoost
GetProcessShutdownParameters
GetProcessTimes
GetProcessVersion
GetProcessWindowStation
GetProcessWorkingSetSize
GetProfileIntA
GetProfileSectionA
GetProfileStringA
GetPropA
GetQueueStatus
GetQueuedCompletionStatus
GetRCString
GetROP2
GetRandomRgn
GetRasDialOutProtocols
GetRasterizerCaps
GetRecordInfoFromGuids
GetRecordInfoFromTypeInfo
GetRegionData
GetRegistrySysColors
GetRelAbs
GetResultsHRC
GetRgnBox
GetRoleTextA
GetRunningObjectTable
GetSaveFileNameA
GetSaveFileNamePreviewA
GetScrollBarInfo
GetScrollInfo
GetScrollPos
GetScrollRange
GetSecurityDescriptorControl
GetSecurityDescriptorDacl
GetSecurityDescriptorGroup
GetSecurityDescriptorLength
GetSecurityDescriptorOwner
GetSecurityDescriptorSacl
GetSecurityInfo
GetSecurityInfoExA
GetServiceA
GetServiceDisplayNameA
GetServiceKeyNameA
GetSetFileTimestamp
GetSetLastRunInfo
GetShellWindow
GetShortPathNameA
GetSidIdentifierAuthority
GetSidLengthRequired
GetSidSubAuthority
GetSidSubAuthorityCount
GetSoftwareUpdateInfo
GetStandardColorSpaceProfileA
GetStartupInfoA
GetStateTextA
GetStdHandle
GetStockObject
GetStretchBltMode
GetStringTypeA
GetStringTypeExA
GetStrokeAttributes
GetStrokeTableAttributes
GetSubMenu
GetSubtypeName
GetSurfaceFromDC
GetSymbolCountHRCRESULT
GetSymbolsHRCRESULT
GetSysColor
GetSysColorBrush
GetSystemDefaultLCID
GetSystemDefaultLangID
GetSystemDirectoryA
GetSystemInfo
GetSystemMenu
GetSystemMetrics
GetSystemPaletteEntries
GetSystemPaletteUse
GetSystemPowerStatus
GetSystemTime
GetSystemTimeAdjustment
GetSystemTimeAsFileTime
GetTabbedTextExtentA
GetTapeParameters
GetTapePosition
GetTapeStatus
GetTempFileNameA
GetTempPathA
GetTestCases
GetTestGroups
GetTextAlign
GetTextCharacterExtra
GetTextCharset
GetTextCharsetInfo
GetTextColor
GetTextExtentExPointA
GetTextExtentExPointI
GetTextExtentPoint32A
GetTextExtentPointA
GetTextExtentPointI
GetTextFaceA
GetTextMetricsA
GetTheFunctionPtr
GetThreadContext
GetThreadDesktop
GetThreadLocale
GetThreadPriority
GetThreadPriorityBoost
GetThreadSelectorEntry
GetThreadTimes
GetTickCount
GetTimeFormatA
GetTimeZoneInformation
GetTimestampForLoadedLibrary
GetTitleBarInfo
GetTnefStreamCodepage
GetTokenInformation
GetTopWindow
GetTrueColorType
GetTrusteeNameA
GetTrusteeTypeA
GetTypeByNameA
GetUpdateRect
GetUpdateRgn
GetUrlCacheConfigInfoA
GetUrlCacheEntryInfoA
GetUrlCacheEntryInfoExA
GetUrlCacheHeaderData
GetUserDefaultLCID
GetUserDefaultLangID
GetUserNameA
GetUserObjectInformationA
GetUserObjectSecurity
GetVDMCurrentDirectories
GetVersion
GetVersionExA
GetVersionInfoFromImage
GetVersionPenWin
GetViewportExtEx
GetViewportOrgEx
GetVolumeInformationA
GetWinMetaFileBits
GetWindow
GetWindowContextHelpId
GetWindowDC
GetWindowExtEx
GetWindowInfo
GetWindowLongA
GetWindowModuleFileNameA
GetWindowOrgEx
GetWindowPlacement
GetWindowRect
GetWindowRgn
GetWindowTextA
GetWindowTextLengthA
GetWindowThreadProcessId
GetWindowWord
GetWindowsDirectoryA
GetWordlistCoercionHRC
GetWordlistHRC
GetWorldTransform
GlmfBeginGlsBlock
GlmfCloseMetaFile
GlmfEndGlsBlock
GlmfEndPlayback
GlmfInitPlayback
GlmfPlayGlsRecord
GlobalAddAtomA
GlobalAlloc
GlobalCompact
GlobalDeleteAtom
GlobalFindAtomA
GlobalFix
GlobalFlags
GlobalFree
GlobalGetAtomNameA
GlobalHandle
GlobalLock
GlobalMemoryStatus
GlobalMemoryStatusVlm
GlobalMutexClear
GlobalMutexRequest
GlobalReAlloc
GlobalSize
GlobalUnWire
GlobalUnfix
GlobalUnlock
GlobalWire
GopherCreateLocatorA
GopherFindFirstFileA
GopherGetAttributeA
GopherGetLocatorTypeA
GopherOpenFileA
GrabStaticEntries
GradientFill
GrayStringA
HACCEL_UserFree
HACCEL_UserMarshal
HACCEL_UserSize
HACCEL_UserUnmarshal
HBITMAP_UserFree
HBITMAP_UserMarshal
HBITMAP_UserSize
HBITMAP_UserUnmarshal
HBRUSH_UserFree
HBRUSH_UserMarshal
HBRUSH_UserSize
HBRUSH_UserUnmarshal
HENHMETAFILE_UserFree
HENHMETAFILE_UserMarshal
HENHMETAFILE_UserSize
HENHMETAFILE_UserUnmarshal
HGLOBAL_UserFree
HGLOBAL_UserMarshal
HGLOBAL_UserSize
HGLOBAL_UserUnmarshal
HMENU_UserFree
HMENU_UserMarshal
HMENU_UserSize
HMENU_UserUnmarshal
HMETAFILEPICT_UserFree
HMETAFILEPICT_UserMarshal
HMETAFILEPICT_UserSize
HMETAFILEPICT_UserUnmarshal
HMETAFILE_UserFree
HMETAFILE_UserMarshal
HMETAFILE_UserSize
HMETAFILE_UserUnmarshal
HPALETTE_UserFree
HPALETTE_UserMarshal
HPALETTE_UserSize
HPALETTE_UserUnmarshal
HWND_UserFree
HWND_UserMarshal
HWND_UserSize
HWND_UserUnmarshal
HashData
Heap32First
Heap32ListFirst
Heap32ListNext
Heap32Next
HeapAlloc
HeapCompact
HeapCreate
HeapDestroy
HeapExtend
HeapFree
HeapLock
HeapReAlloc
HeapSize
HeapSummary
HeapUnlock
HeapUsage
HeapValidate
HeapVidMemAllocAligned
HeapWalk
HexFromBin
HideCaret
HiliteMenuItem
HitTestPenData
HkOleRegisterObject
HlinkClone
HlinkCreateBrowseContext
HlinkCreateExtensionServices
HlinkCreateFromData
HlinkCreateFromMoniker
HlinkCreateFromString
HlinkCreateShortcut
HlinkCreateShortcutFromMoniker
HlinkCreateShortcutFromString
HlinkGetSpecialReference
HlinkGetValueFromParams
HlinkGoBack
HlinkGoForward
HlinkIsShortcut
HlinkNavigate
HlinkNavigateMoniker
HlinkNavigateString
HlinkNavigateToStringReference
HlinkOnNavigate
HlinkOnRenameDocument
HlinkParseDisplayName
HlinkPreprocessMoniker
HlinkQueryCreateFromData
HlinkResolveMonikerForData
HlinkResolveShortcut
HlinkResolveShortcutToMoniker
HlinkResolveShortcutToString
HlinkResolveStringForData
HlinkSetSpecialReference
HlinkSimpleNavigateToMoniker
HlinkSimpleNavigateToString
HlinkTranslateURL
HlinkUpdateStackItem
HogMachine
HrAddColumns
HrAddColumnsEx
HrAllocAdviseSink
HrComposeEID
HrComposeMsgID
HrDecomposeEID
HrDecomposeMsgID
HrDispatchNotifications
HrEntryIDFromSz
HrGetOneProp
HrIStorageFromStream
HrQueryAllRows
HrSetOneProp
HrSzFromEntryID
HrThisThreadAdviseSink
HrValidateIPMSubtree
HrValidateParameters
HttpAddRequestHeadersA
HttpEndRequestA
HttpOpenRequestA
HttpQueryInfoA
HttpSendRequestA
HttpSendRequestExA
HuftBuild
ICClose
ICCompressorChoose
ICCompressorFree
ICGetDisplayFormat
ICGetInfo
ICImageCompress
ICImageDecompress
ICInfo
ICInstall
ICLocate
ICMThunk32
ICOpen
ICOpenFunction
ICRemove
ICSendMessage
ICSeqCompressFrame
ICSeqCompressFrameEnd
ICSeqCompressFrameStart
IF_CALLBACK_FN
IIDFromString
IMPGetIMEA
IMPQueryIMEA
IMPSetIMEA
IUnknown_AddRef_Proxy
IUnknown_QueryInterface_Proxy
IUnknown_Release_Proxy
I_BrowserDebugCall
I_BrowserDebugTrace
I_BrowserQueryEmulatedDomains
I_BrowserQueryOtherDomains
I_BrowserQueryStatistics
I_BrowserResetNetlogonState
I_BrowserResetStatistics
I_BrowserServerEnum
I_BrowserSetNetlogonState
I_CryptAllocTls
I_CryptDetachTls
I_CryptGetOssGlobal
I_CryptGetTls
I_CryptInstallOssGlobal
I_CryptSetTls
I_GetDefaultEntrySyntax
I_MprSaveConn
I_NetAccountDeltas
I_NetAccountSync
I_NetDatabaseDeltas
I_NetDatabaseRedo
I_NetDatabaseSync
I_NetDatabaseSync2
I_NetDfsCreateExitPoint
I_NetDfsCreateLocalPartition
I_NetDfsDeleteExitPoint
I_NetDfsDeleteLocalPartition
I_NetDfsFixLocalVolume
I_NetDfsGetFtServers
I_NetDfsGetVersion
I_NetDfsIsThisADomainName
I_NetDfsModifyPrefix
I_NetDfsSetLocalVolumeState
I_NetDfsSetServerInfo
I_NetGetDCList
I_NetListCanonicalize
I_NetListTraverse
I_NetLogonControl
I_NetLogonControl2
I_NetLogonGetDomainInfo
I_NetLogonSamLogoff
I_NetLogonSamLogon
I_NetLogonUasLogoff
I_NetLogonUasLogon
I_NetNameCanonicalize
I_NetNameCompare
I_NetNameValidate
I_NetPathCanonicalize
I_NetPathCompare
I_NetPathType
I_NetServerAuthenticate
I_NetServerAuthenticate2
I_NetServerAuthenticate3
I_NetServerPasswordSet
I_NetServerPasswordSet2
I_NetServerReqChallenge
I_NetServerSetServiceBits
I_NetServerSetServiceBitsEx
I_NetlogonComputeClientDigest
I_NetlogonComputeServerDigest
I_NetlogonGetTrustRid
I_RpcAbortAsyncCall
I_RpcAllocate
I_RpcAsyncAbortCall
I_RpcAsyncSendReceive
I_RpcAsyncSetHandle
I_RpcBindingCopy
I_RpcBindingInqDynamicEndpointA
I_RpcBindingInqTransportType
I_RpcBindingIsClientLocal
I_RpcBindingSetAsync
I_RpcClearMutex
I_RpcConnectionInqSockBuffSize
I_RpcConnectionSetSockBuffSize
I_RpcDeleteMutex
I_RpcFree
I_RpcFreeBuffer
I_RpcFreePipeBuffer
I_RpcGetAssociationContext
I_RpcGetBuffer
I_RpcGetCurrentCallHandle
I_RpcGetServerContextList
I_RpcGetThreadWindowHandle
I_RpcIfInqTransferSyntaxes
I_RpcMapWin32Status
I_RpcMonitorAssociation
I_RpcNsBindingSetEntryNameA
I_RpcNsGetBuffer
I_RpcNsRaiseException
I_RpcNsSendReceive
I_RpcParseSecurity
I_RpcPauseExecution
I_RpcReBindBuffer
I_RpcReallocPipeBuffer
I_RpcReceive
I_RpcRequestMutex
I_RpcSend
I_RpcSendReceive
I_RpcServerAllocateIpPort
I_RpcServerInqTransportType
I_RpcServerRegisterForwardFunction
I_RpcServerStartListening
I_RpcServerStopListening
I_RpcSetAsyncHandle
I_RpcSetServerContextList
I_RpcSetWMsgEndpoint
I_RpcSsDontSerializeContext
I_RpcStopMonitorAssociation
I_RpcTransConnectionAllocatePacket
I_RpcTransConnectionFreePacket
I_RpcTransConnectionReallocPacket
I_RpcTransDatagramAllocate
I_RpcTransDatagramAllocate2
I_RpcTransDatagramFree
I_RpcTransGetReadEvent
I_RpcTransGetWriteEvent
I_RpcTransIoCancelled
I_RpcTransPingServer
I_RpcTransProtectThread
I_RpcTransServerAllocatePacket
I_RpcTransServerFreePacket
I_RpcTransServerNewConnection
I_RpcTransServerReallocPacket
I_RpcTransUnprotectThread
I_RpcWindowProc
I_ScSetServiceBitsA
I_UuidCreate
ImageAddCertificate
ImageDirectoryEntryToData
ImageEnumerateCertificates
ImageGetCertificateData
ImageGetCertificateHeader
ImageGetDigestStream
ImageList_Add
ImageList_AddIcon
ImageList_AddMasked
ImageList_BeginDrag
ImageList_Copy
ImageList_Create
ImageList_Destroy
ImageList_DragEnter
ImageList_DragLeave
ImageList_DragMove
ImageList_DragShowNolock
ImageList_Draw
ImageList_DrawEx
ImageList_DrawIndirect
ImageList_Duplicate
ImageList_EndDrag
ImageList_GetBkColor
ImageList_GetDragImage
ImageList_GetIcon
ImageList_GetIconSize
ImageList_GetImageCount
ImageList_GetImageInfo
ImageList_GetImageRect
ImageList_LoadImageA
ImageList_Merge
ImageList_Read
ImageList_Remove
ImageList_Replace
ImageList_ReplaceIcon
ImageList_SetBkColor
ImageList_SetDragCursorImage
ImageList_SetFilter
ImageList_SetIconSize
ImageList_SetImageCount
ImageList_SetOverlayImage
ImageList_Write
ImageLoad
ImageNtHeader
ImageRemoveCertificate
ImageRvaToSection
ImageRvaToVa
ImageUnload
ImagehlpApiVersion
ImagehlpApiVersionEx
ImmAssociateContext
ImmAssociateContextEx
ImmConfigureIMEA
ImmCreateContext
ImmCreateIMCC
ImmCreateSoftKeyboard
ImmDestroyContext
ImmDestroyIMCC
ImmDestroySoftKeyboard
ImmDisableIME
ImmEnumRegisterWordA
ImmEscapeA
ImmGenerateMessage
ImmGetCandidateListA
ImmGetCandidateListCountA
ImmGetCandidateWindow
ImmGetCompositionFontA
ImmGetCompositionStringA
ImmGetCompositionWindow
ImmGetContext
ImmGetConversionListA
ImmGetConversionStatus
ImmGetDefaultIMEWnd
ImmGetDescriptionA
ImmGetGuideLineA
ImmGetHotKey
ImmGetIMCCLockCount
ImmGetIMCCSize
ImmGetIMCLockCount
ImmGetIMEFileNameA
ImmGetImeMenuItemsA
ImmGetOpenStatus
ImmGetProperty
ImmGetRegisterWordStyleA
ImmGetStatusWindowPos
ImmGetVirtualKey
ImmInstallIMEA
ImmIsIME
ImmIsUIMessageA
ImmLockIMC
ImmLockIMCC
ImmNotifyIME
ImmReSizeIMCC
ImmRegisterWordA
ImmReleaseContext
ImmRequestMessageA
ImmSetCandidateWindow
ImmSetCompositionFontA
ImmSetCompositionStringA
ImmSetCompositionWindow
ImmSetConversionStatus
ImmSetHotKey
ImmSetOpenStatus
ImmSetStatusWindowPos
ImmShowSoftKeyboard
ImmSimulateHotKey
ImmUnlockIMC
ImmUnlockIMCC
ImmUnregisterWordA
ImpersonateDdeClientWindow
ImpersonateLoggedOnUser
ImpersonateNamedPipeClient
ImpersonateSelf
ImportNtmsDatabase
InSendMessage
InSendMessageEx
IncrementUrlCacheHeaderData
InetIsOffline
InfIsFromOemLocation
InflateBlock
InflateCodes
InflateDynamic
InflateFixed
InflateRect
InflateStored
InitAtomTable
InitCommonControls
InitCommonControlsEx
InitFixed
InitFolder
InitRealScreenSave
InitializeAcl
InitializeCriticalSection
InitializeCriticalSectionAndSpinCount
InitializeDll
InitializeFlatSB
InitializePrintMonitor
InitializePrintProvidor
InitializeSecurityDescriptor
InitializeSid
InitiateSystemShutdownA
InjectNtmsCleaner
InjectNtmsMedia
InsertMenuA
InsertMenuItemA
InsertPenData
InsertPenDataPoints
InsertPenDataStroke
InstallColorProfileA
InstallFilterHook
InstallHinfSectionA
InstallRecognizer
InstallStop
InterlockedCompareExchange
InterlockedDecrement
InterlockedExchange
InterlockedExchangeAdd
InterlockedIncrement
InternalExtractIconListA
Internal_Literal
Internal_Match
InternetAttemptConnect
InternetAutodial
InternetAutodialCallback
InternetAutodialHangup
InternetCanonicalizeUrlA
InternetCheckConnectionA
InternetCloseHandle
InternetCombineUrlA
InternetConfirmZoneCrossing
InternetConnectA
InternetCrackUrlA
InternetCreateUrlA
InternetDebugGetLocalTime
InternetDial
InternetErrorDlg
InternetFindNextFileA
InternetGetCertByURL
InternetGetConnectedState
InternetGetCookieA
InternetGetLastResponseInfoA
InternetGoOnline
InternetHangUp
InternetLockRequestFile
InternetOpenA
InternetOpenUrlA
InternetQueryDataAvailable
InternetQueryOptionA
InternetReadFile
InternetReadFileExA
InternetSetCookieA
InternetSetDialState
InternetSetFilePointer
InternetSetOptionA
InternetSetOptionExA
InternetSetStatusCallback
InternetShowSecurityInfoByURL
InternetTimeFromSystemTime
InternetTimeToSystemTime
InternetUnlockRequestFile
InternetWriteFile
InternetWriteFileExA
IntersectClipRect
IntersectRect
IntlStrEqWorkerA
IntroDialogProc
InvalidateConsoleDIBits
InvalidateRect
InvalidateRgn
InventoryNtmsLibrary
InvertRect
InvertRgn
IpxAdjustIoCompletionParams
IpxCreateAdapterConfigurationPort
IpxDeleteAdapterConfigurationPort
IpxGetOverlappedResult
IpxGetQueuedAdapterConfigurationStatus
IpxGetQueuedCompletionStatus
IpxPostQueuedCompletionStatus
IpxRecvPacket
IpxSendPacket
IpxWanCreateAdapterConfigurationPort
IpxWanQueryInactivityTimer
IpxWanSetAdapterConfiguration
IsAccelerator
IsAsyncMoniker
IsBadBoundedStringPtr
IsBadCodePtr
IsBadHugeReadPtr
IsBadHugeWritePtr
IsBadReadPtr
IsBadStringPtrA
IsBadWritePtr
IsCharAlphaA
IsCharAlphaNumericA
IsCharLowerA
IsCharUpperA
IsChicago
IsChild
IsClipboardFormatAvailable
IsColorProfileTagPresent
IsColorProfileValid
IsDBCSLeadByte
IsDBCSLeadByteEx
IsDebuggerPresent
IsDialogMessageA
IsDlgButtonChecked
IsEqualGUID
IsHostInProxyBypassList
IsIconic
IsLoggingEnabledA
IsMenu
IsPenEvent
IsPixelFormatValid
IsProcessorFeaturePresent
IsRectEmpty
IsTextUnicode
IsTokenRestricted
IsUserAdmin
IsValidAcl
IsValidCodePage
IsValidIid
IsValidInterface
IsValidLocale
IsValidPtrIn
IsValidPtrOut
IsValidSecurityDescriptor
IsValidSid
IsValidURL
IsWindow
IsWindowEnabled
IsWindowUnicode
IsWindowVisible
IsZoomed
K32Thk1632Epilog
K32Thk1632Prolog
KeyDown
KillSystemTimer
KillTimer
LBItemFromPt
LCMapStringA
LHashValOfNameSysA
LPSAFEARRAY_Marshal
LPSAFEARRAY_Size
LPSAFEARRAY_Unmarshal
LPSAFEARRAY_UserFree
LPSAFEARRAY_UserMarshal
LPSAFEARRAY_UserSize
LPSAFEARRAY_UserUnmarshal
LPropCompareProp
LPtoDP
LSEnumProviders
LSFreeHandle
LSGetMessage
LSInstall
LSLicenseUnitsGet
LSLicenseUnitsSet
LSQuery
LSRelease
LSRequest
LSUpdate
LZClose
LZCopy
LZDone
LZInit
LZOpenFileA
LZRead
LZSeek
LZStart
LateAllocateSurfaceMem
LaunchWizard
LdapDllInit
LeaveCriticalSection
LibMain
LineDDA
LineTo
LoadAcceleratorsA
LoadAlterBitmap
LoadBitmapA
LoadCursorA
LoadCursorFromFileA
LoadIFilter
LoadIconA
LoadImageA
LoadKeyboardLayoutA
LoadLibraryA
LoadLibraryExA
LoadMenuA
LoadMenuIndirectA
LoadModule
LoadPerfCounterTextStringsA
LoadPrinterDriver
LoadPwdDLL
LoadRegTypeLib
LoadResource
LoadStringA
LoadTypeLib
LoadTypeLibEx
LoadUrlCacheContent
LocalAlloc
LocalCompact
LocalFileTimeToFileTime
LocalFlags
LocalFree
LocalHandle
LocalLock
LocalReAlloc
LocalShrink
LocalSize
LocalUnlock
LocateCatalogsA
LockFile
LockFileEx
LockResource
LockServiceDatabase
LockWindowUpdate
LockWorkStation
LogErrorA
LogEventA
LoginCabinet
LogonUserA
LookUpStringInTable
LookupAccountNameA
LookupAccountSidA
LookupIconIdFromDirectory
LookupIconIdFromDirectoryEx
LookupPrivilegeDisplayNameA
LookupPrivilegeNameA
LookupPrivilegeValueA
LookupSecurityDescriptorPartsA
LpValFindProp
LresultFromObject
LsaAddAccountRights
LsaAddPrivilegesToAccount
LsaClearAuditLog
LsaClose
LsaCreateAccount
LsaCreateSecret
LsaCreateTrustedDomain
LsaCreateTrustedDomainEx
LsaDelete
LsaDeleteTrustedDomain
LsaEnumerateAccountRights
LsaEnumerateAccounts
LsaEnumerateAccountsWithUserRight
LsaEnumeratePrivileges
LsaEnumeratePrivilegesOfAccount
LsaEnumerateTrustedDomains
LsaEnumerateTrustedDomainsEx
LsaFreeMemory
LsaGetQuotasForAccount
LsaGetSystemAccessAccount
LsaGetUserName
LsaICLookupNames
LsaICLookupSids
LsaIGetTrustedDomainAuthInfoBlobs
LsaISetTrustedDomainAuthInfoBlobs
LsaLookupNames
LsaLookupPrivilegeDisplayName
LsaLookupPrivilegeName
LsaLookupPrivilegeValue
LsaLookupSids
LsaNtStatusToWinError
LsaOpenAccount
LsaOpenPolicy
LsaOpenSecret
LsaOpenTrustedDomain
LsaQueryDomainInformationPolicy
LsaQueryInfoTrustedDomain
LsaQueryInformationPolicy
LsaQueryLocalInformationPolicy
LsaQuerySecret
LsaQuerySecurityObject
LsaQueryTrustedDomainInfo
LsaQueryTrustedDomainInfoByName
LsaRemoveAccountRights
LsaRemovePrivilegesFromAccount
LsaRetrievePrivateData
LsaSetDomainInformationPolicy
LsaSetInformationPolicy
LsaSetInformationTrustedDomain
LsaSetLocalInformationPolicy
LsaSetQuotasForAccount
LsaSetSecret
LsaSetSecurityObject
LsaSetSystemAccessAccount
LsaSetTrustedDomainInfoByName
LsaSetTrustedDomainInformation
LsaStorePrivateData
Lz_Bump
Lz_Close
Lz_Init
Lz_NextToken
MAPIAdminProfiles
MAPIAllocateBuffer
MAPIAllocateMore
MAPIDeinitIdle
MAPIFreeBuffer
MAPIGetDefaultMalloc
MAPIInitIdle
MAPIInitialize
MAPILogonEx
MAPIOpenFormMgr
MAPIOpenLocalFormContainer
MAPIUninitialize
MDICreateDecompressionGlobal
MDIDecompressGlobal
MDIDestroyDecompressionGlobal
MDIResetDecompressionGlobal
MIDL_user_allocate
MIDL_wchar_strcpy
MIDL_wchar_strlen
MIMEAssociationDialogA
MMCFreeNotifyHandle
MMCIsMTNodeValid
MMCPropPageCallback
MMCPropertyChangeNotify
MNLS_MultiByteToWideChar
MNLS_WideCharToMultiByte
MQBeginTransaction
MQCloseCursor
MQCloseQueue
MQCreateCursor
MQCreateInternalCert
MQCreateQueue
MQDeleteInternalCert
MQDeleteQueue
MQFreeMemory
MQFreeSecurityContext
MQGetInternalCert
MQGetInternalCertificate
MQGetMachineProperties
MQGetQueueProperties
MQGetQueueSecurity
MQGetSecurityContext
MQGetUserCerts
MQHandleToFormatName
MQInstanceToFormatName
MQLocateBegin
MQLocateEnd
MQLocateNext
MQOpenQueue
MQPathNameToFormatName
MQPurgeQueue
MQReceiveMessage
MQRegisterUserCert
MQRemoveUserCert
MQSendMessage
MQSetQueueProperties
MQSetQueueSecurity
MTSCreateActivity
MakeAbsoluteSD
MakeDragList
MakeSelfRelativeSD
MakeSureDirectoryPathExists
ManageGroups
ManageSources
ManageTests
MapAndLoad
MapDebugInformation
MapDialogRect
MapFileAndCheckSumA
MapGenericMask
MapLS
MapSL
MapSLFix
MapStorageSCode
MapViewOfFile
MapViewOfFileEx
MapViewOfFileVlm
MapVirtualKeyA
MapVirtualKeyExA
MapWindowPoints
MarkImageAsRunFromSwap
MaskBlt
MemoryInitialize
MenuHelp
MenuItemFromPoint
MesBufferHandleReset
MesDecodeBufferHandleCreate
MesDecodeIncrementalHandleCreate
MesEncodeDynBufferHandleCreate
MesEncodeFixedBufferHandleCreate
MesEncodeIncrementalHandleCreate
MesHandleFree
MesIncrementalHandleReset
MesInqProcEncodingId
MessageBeep
MessageBoxA
MessageBoxExA
MessageBoxIndirectA
MetricScalePenData
MigrateAllDrivers
MigrateMidiUser
MigrateSoundEvents
MigrateWinsockConfiguration
MkParseDisplayName
MkParseDisplayNameEx
ModifyMenuA
ModifyWorldTransform
Module32First
Module32Next
MonikerCommonPrefixWith
MonikerRelativePathTo
MonitorFromPoint
MonitorFromRect
MonitorFromWindow
MountNtmsMedia
MouseDown
MouseLoc
MouseUp
MoveClusterGroup
MoveFileA
MoveFileExA
MoveFileWithProgressA
MoveToEx
MoveToNtmsMediaPool
MoveWindow
MprAdminBufferFree
MprAdminConnectionClearStats
MprAdminConnectionEnum
MprAdminConnectionGetInfo
MprAdminGetErrorString
MprAdminGetPDCServer
MprAdminInterfaceConnect
MprAdminInterfaceCreate
MprAdminInterfaceDelete
MprAdminInterfaceDisconnect
MprAdminInterfaceEnum
MprAdminInterfaceGetCredentials
MprAdminInterfaceGetHandle
MprAdminInterfaceGetInfo
MprAdminInterfaceQueryUpdateResult
MprAdminInterfaceSetCredentials
MprAdminInterfaceSetInfo
MprAdminInterfaceTransportAdd
MprAdminInterfaceTransportGetInfo
MprAdminInterfaceTransportRemove
MprAdminInterfaceTransportSetInfo
MprAdminInterfaceUpdatePhonebookInfo
MprAdminInterfaceUpdateRoutes
MprAdminIsServiceRunning
MprAdminMIBBufferFree
MprAdminMIBEntryCreate
MprAdminMIBEntryDelete
MprAdminMIBEntryGet
MprAdminMIBEntryGetFirst
MprAdminMIBEntryGetNext
MprAdminMIBEntrySet
MprAdminMIBServerConnect
MprAdminMIBServerDisconnect
MprAdminPortClearStats
MprAdminPortDisconnect
MprAdminPortEnum
MprAdminPortGetInfo
MprAdminPortReset
MprAdminServerConnect
MprAdminServerDisconnect
MprAdminServerGetInfo
MprAdminTransportGetInfo
MprAdminTransportSetInfo
MprAdminUserGetInfo
MprAdminUserSetInfo
MprConfigBufferFree
MprConfigInterfaceCreate
MprConfigInterfaceDelete
MprConfigInterfaceEnum
MprConfigInterfaceGetHandle
MprConfigInterfaceGetInfo
MprConfigInterfaceSetInfo
MprConfigInterfaceTransportAdd
MprConfigInterfaceTransportEnum
MprConfigInterfaceTransportGetHandle
MprConfigInterfaceTransportGetInfo
MprConfigInterfaceTransportRemove
MprConfigInterfaceTransportSetInfo
MprConfigServerBackup
MprConfigServerConnect
MprConfigServerDisconnect
MprConfigServerGetInfo
MprConfigServerRestore
MprConfigTransportCreate
MprConfigTransportDelete
MprConfigTransportEnum
MprConfigTransportGetHandle
MprConfigTransportGetInfo
MprConfigTransportSetInfo
MprInfoBlockAdd
MprInfoBlockFind
MprInfoBlockRemove
MprInfoBlockSet
MprInfoCreate
MprInfoDelete
MprInfoDuplicate
MprInfoRemoveAll
MprSetupProtocolEnum
MprSetupProtocolFree
MsgWaitForMultipleObjects
MsgWaitForMultipleObjectsEx
Msr_Control
Msr_Dump
Msr_DumpStats
Msr_Init
Msr_Integer
Msr_Note
Msr_Register
Msr_Reset
Msr_Start
Msr_Stop
Msr_Terminate
MulDiv
MultiByteToUnicode
MultiByteToWideChar
MultiSzFromSearchControl
MultinetGetConnectionPerformanceA
MultinetGetErrorTextA
MyFree
MyGetFileTitle
MyMalloc
MyRealloc
NDRCContextBinding
NDRCContextMarshall
NDRCContextUnmarshall
NDRSContextMarshall
NDRSContextMarshallEx
NDRSContextUnmarshall
NDRSContextUnmarshallEx
NDRcopy
NDdeGetErrorStringA
NDdeGetShareSecurityA
NDdeGetTrustedShareA
NDdeIsValidAppTopicListA
NDdeIsValidShareNameA
NDdeSetShareSecurityA
NDdeSetTrustedShareA
NDdeShareAddA
NDdeShareDelA
NDdeShareEnumA
NDdeShareGetInfoA
NDdeShareSetInfoA
NDdeSpecialCommandA
NDdeTrustedShareEnumA
NFMDestroyContext
NFMInitializeContext
NFM_Decompress
NFM_Prepare
NPLoadNameSpaces
NdrAllocate
NdrAsyncServerCall
NdrAsyncStubCall
NdrByteCountPointerBufferSize
NdrByteCountPointerFree
NdrByteCountPointerMarshall
NdrByteCountPointerUnmarshall
NdrCStdStubBuffer2_Release
NdrCStdStubBuffer_Release
NdrClearOutParameters
NdrClientContextMarshall
NdrClientContextUnmarshall
NdrClientInitialize
NdrClientInitializeNew
NdrComplexArrayBufferSize
NdrComplexArrayFree
NdrComplexArrayMarshall
NdrComplexArrayMemorySize
NdrComplexArrayUnmarshall
NdrComplexStructBufferSize
NdrComplexStructFree
NdrComplexStructMarshall
NdrComplexStructMemorySize
NdrComplexStructUnmarshall
NdrConformantArrayBufferSize
NdrConformantArrayFree
NdrConformantArrayMarshall
NdrConformantArrayMemorySize
NdrConformantArrayUnmarshall
NdrConformantStringBufferSize
NdrConformantStringMarshall
NdrConformantStringMemorySize
NdrConformantStringUnmarshall
NdrConformantStructBufferSize
NdrConformantStructFree
NdrConformantStructMarshall
NdrConformantStructMemorySize
NdrConformantStructUnmarshall
NdrConformantVaryingArrayBufferSize
NdrConformantVaryingArrayFree
NdrConformantVaryingArrayMarshall
NdrConformantVaryingArrayMemorySize
NdrConformantVaryingArrayUnmarshall
NdrConformantVaryingStructBufferSize
NdrConformantVaryingStructFree
NdrConformantVaryingStructMarshall
NdrConformantVaryingStructMemorySize
NdrConformantVaryingStructUnmarshall
NdrContextHandleSize
NdrConvert
NdrConvert2
NdrDllCanUnloadNow
NdrDllGetClassObject
NdrDllRegisterProxy
NdrDllUnregisterProxy
NdrEncapsulatedUnionBufferSize
NdrEncapsulatedUnionFree
NdrEncapsulatedUnionMarshall
NdrEncapsulatedUnionMemorySize
NdrEncapsulatedUnionUnmarshall
NdrFixedArrayBufferSize
NdrFixedArrayFree
NdrFixedArrayMarshall
NdrFixedArrayMemorySize
NdrFixedArrayUnmarshall
NdrFreeBuffer
NdrFullPointerFree
NdrFullPointerInsertRefId
NdrFullPointerQueryPointer
NdrFullPointerQueryRefId
NdrFullPointerXlatFree
NdrFullPointerXlatInit
NdrGetBuffer
NdrGetDcomProtocolVersion
NdrGetPartialBuffer
NdrGetPipeBuffer
NdrHardStructBufferSize
NdrHardStructFree
NdrHardStructMarshall
NdrHardStructMemorySize
NdrHardStructUnmarshall
NdrInterfacePointerBufferSize
NdrInterfacePointerFree
NdrInterfacePointerMarshall
NdrInterfacePointerMemorySize
NdrInterfacePointerUnmarshall
NdrIsAppDoneWithPipes
NdrMapCommAndFaultStatus
NdrMarkNextActivePipe
NdrMesSimpleTypeAlignSize
NdrMesSimpleTypeDecode
NdrMesSimpleTypeEncode
NdrMesTypeAlignSize
NdrMesTypeDecode
NdrMesTypeEncode
NdrNonConformantStringBufferSize
NdrNonConformantStringMarshall
NdrNonConformantStringMemorySize
NdrNonConformantStringUnmarshall
NdrNonEncapsulatedUnionBufferSize
NdrNonEncapsulatedUnionFree
NdrNonEncapsulatedUnionMarshall
NdrNonEncapsulatedUnionMemorySize
NdrNonEncapsulatedUnionUnmarshall
NdrNsGetBuffer
NdrNsSendReceive
NdrOleAllocate
NdrOleFree
NdrPipePull
NdrPipePush
NdrPipeSendReceive
NdrPipesDone
NdrPipesInitialize
NdrPointerBufferSize
NdrPointerFree
NdrPointerMarshall
NdrPointerMemorySize
NdrPointerUnmarshall
NdrProxyErrorHandler
NdrProxyFreeBuffer
NdrProxyGetBuffer
NdrProxyInitialize
NdrProxySendReceive
NdrRpcSmClientAllocate
NdrRpcSmClientFree
NdrRpcSmSetClientToOsf
NdrRpcSsDefaultAllocate
NdrRpcSsDefaultFree
NdrRpcSsDisableAllocate
NdrRpcSsEnableAllocate
NdrSendReceive
NdrServerCall
NdrServerCall2
NdrServerContextMarshall
NdrServerContextUnmarshall
NdrServerInitialize
NdrServerInitializeMarshall
NdrServerInitializeNew
NdrServerInitializePartial
NdrServerInitializeUnmarshall
NdrServerMarshall
NdrServerUnmarshall
NdrSimpleStructBufferSize
NdrSimpleStructFree
NdrSimpleStructMarshall
NdrSimpleStructMemorySize
NdrSimpleStructUnmarshall
NdrSimpleTypeMarshall
NdrSimpleTypeUnmarshall
NdrStubCall
NdrStubCall2
NdrStubForwardingFunction
NdrStubGetBuffer
NdrStubInitialize
NdrStubInitializeMarshall
NdrUserMarshalBufferSize
NdrUserMarshalFree
NdrUserMarshalMarshall
NdrUserMarshalMemorySize
NdrUserMarshalSimpleTypeConvert
NdrUserMarshalUnmarshall
NdrVaryingArrayBufferSize
NdrVaryingArrayFree
NdrVaryingArrayMarshall
NdrVaryingArrayMemorySize
NdrVaryingArrayUnmarshall
NdrXmitOrRepAsBufferSize
NdrXmitOrRepAsFree
NdrXmitOrRepAsMarshall
NdrXmitOrRepAsMemorySize
NdrXmitOrRepAsUnmarshall
NdrpSetRpcSsDefaults
NetAccessAdd
NetAccessCheck
NetAccessDel
NetAccessEnum
NetAccessGetInfo
NetAccessGetUserPerms
NetAccessSetInfo
NetAlertRaise
NetAlertRaiseEx
NetApiBufferAllocate
NetApiBufferFree
NetApiBufferReallocate
NetApiBufferSize
NetAuditClear
NetAuditRead
NetAuditWrite
NetBrowserStatisticsGet
NetConfigGet
NetConfigGetAll
NetConfigSet
NetConnectionEnum
NetDfsAdd
NetDfsEnum
NetDfsGetInfo
NetDfsManagerGetConfigInfo
NetDfsMove
NetDfsRemove
NetDfsRename
NetDfsSetInfo
NetEnumerateTrustedDomains
NetErrorLogClear
NetErrorLogRead
NetErrorLogWrite
NetFileClose
NetFileClose2
NetFileEnum
NetFileGetInfo
NetGetAnyDCName
NetGetDCName
NetGetDisplayInformationIndex
NetGroupAdd
NetGroupAddUser
NetGroupDel
NetGroupDelUser
NetGroupEnum
NetGroupGetInfo
NetGroupGetUsers
NetGroupSetInfo
NetGroupSetUsers
NetLocalGroupAdd
NetLocalGroupAddMember
NetLocalGroupAddMembers
NetLocalGroupDel
NetLocalGroupDelMember
NetLocalGroupDelMembers
NetLocalGroupEnum
NetLocalGroupGetInfo
NetLocalGroupGetMembers
NetLocalGroupSetInfo
NetLocalGroupSetMembers
NetLogonSetServiceBits
NetMessageBufferSend
NetMessageNameAdd
NetMessageNameDel
NetMessageNameEnum
NetMessageNameGetInfo
NetQueryDisplayInformation
NetRemoteComputerSupports
NetRemoteTOD
NetReplExportDirAdd
NetReplExportDirDel
NetReplExportDirEnum
NetReplExportDirGetInfo
NetReplExportDirLock
NetReplExportDirSetInfo
NetReplExportDirUnlock
NetReplGetInfo
NetReplImportDirAdd
NetReplImportDirDel
NetReplImportDirEnum
NetReplImportDirGetInfo
NetReplImportDirLock
NetReplImportDirUnlock
NetReplSetInfo
NetScheduleJobAdd
NetScheduleJobDel
NetScheduleJobEnum
NetScheduleJobGetInfo
NetSecurityGetInfo
NetServerComputerNameAdd
NetServerComputerNameDel
NetServerDiskEnum
NetServerEnum
NetServerEnumEx
NetServerGetInfo
NetServerSetInfo
NetServerTransportAdd
NetServerTransportAddEx
NetServerTransportDel
NetServerTransportEnum
NetServiceControl
NetServiceEnum
NetServiceGetInfo
NetServiceInstall
NetSessionDel
NetSessionEnum
NetSessionGetInfo
NetShareAdd
NetShareCheck
NetShareDel
NetShareDelSticky
NetShareEnum
NetShareEnumSticky
NetShareGetInfo
NetShareSetInfo
NetStatisticsGet
NetUseAdd
NetUseDel
NetUseEnum
NetUseGetInfo
NetUserAdd
NetUserChangePassword
NetUserDel
NetUserEnum
NetUserGetGroups
NetUserGetInfo
NetUserGetLocalGroups
NetUserModalsGet
NetUserModalsSet
NetUserSetGroups
NetUserSetInfo
NetWkstaGetInfo
NetWkstaSetInfo
NetWkstaTransportAdd
NetWkstaTransportDel
NetWkstaTransportEnum
NetWkstaUserEnum
NetWkstaUserGetInfo
NetWkstaUserSetInfo
NetapipBufferAllocate
Netbios
NetpAccessCheck
NetpAccessCheckAndAudit
NetpAllocConfigName
NetpAllocStrFromStr
NetpAllocStrFromWStr
NetpAllocTStrFromString
NetpAllocWStrFromStr
NetpAllocWStrFromWStr
NetpApiStatusToNtStatus
NetpAssertFailed
NetpCloseConfigData
NetpCopyStringToBuffer
NetpCreateSecurityObject
NetpDbgDisplayServerInfo
NetpDeleteSecurityObject
NetpGetComputerName
NetpGetConfigBool
NetpGetConfigDword
NetpGetConfigTStrArray
NetpGetConfigValue
NetpGetDomainName
NetpGetFileSecurity
NetpGetPrivilege
NetpHexDump
NetpInitOemString
NetpIsRemote
NetpIsUncComputerNameValid
NetpLocalTimeZoneOffset
NetpLogonPutUnicodeString
NetpNetBiosAddName
NetpNetBiosCall
NetpNetBiosDelName
NetpNetBiosGetAdapterNumbers
NetpNetBiosHangup
NetpNetBiosReceive
NetpNetBiosReset
NetpNetBiosSend
NetpNetBiosStatusToApiStatus
NetpNtStatusToApiStatus
NetpOpenConfigData
NetpPackString
NetpReleasePrivilege
NetpSetConfigBool
NetpSetConfigDword
NetpSetConfigTStrArray
NetpSetFileSecurity
NetpSmbCheck
NetpStringToNetBiosName
NetpTStrArrayEntryCount
NetpwNameCanonicalize
NetpwNameCompare
NetpwNameValidate
NetpwPathCanonicalize
NetpwPathCompare
NetpwPathType
NlBindingAddServerToCache
NlBindingRemoveServerFromCache
NotfDeliverNotification
NotifyBootConfigStatus
NotifyCallbackData
NotifyChangeEventLog
NotifyWinEvent
NtAcsLan
OACreateTypeLib2
OBJECT_INQ_FN
OaBuildVersion
ObjectCloseAuditAlarmA
ObjectDeleteAuditAlarmA
ObjectFromLresult
ObjectOpenAuditAlarmA
ObjectPrivilegeAuditAlarmA
ObtainUserAgentString
OemKeyScan
OemToCharA
OemToCharBuffA
OfflineClusterGroup
OfflineClusterResource
OffsetClipRgn
OffsetPenData
OffsetRect
OffsetRgn
OffsetViewportOrgEx
OffsetWindowOrgEx
OleBuildVersion
OleConvertIStorageToOLESTREAM
OleConvertIStorageToOLESTREAMEx
OleConvertOLESTREAMToIStorage
OleConvertOLESTREAMToIStorageEx
OleCreate
OleCreateDefaultHandler
OleCreateEmbeddingHelper
OleCreateEx
OleCreateFontIndirect
OleCreateFromData
OleCreateFromDataEx
OleCreateFromFile
OleCreateFromFileEx
OleCreateLink
OleCreateLinkEx
OleCreateLinkFromData
OleCreateLinkFromDataEx
OleCreateLinkToFile
OleCreateLinkToFileEx
OleCreateMenuDescriptor
OleCreatePictureIndirect
OleCreatePropertyFrame
OleCreatePropertyFrameIndirect
OleCreateStaticFromData
OleDestroyMenuDescriptor
OleDoAutoConvert
OleDraw
OleDuplicateData
OleFlushClipboard
OleGetAutoConvert
OleGetClipboard
OleGetIconOfClass
OleGetIconOfFile
OleIconToCursor
OleInitialize
OleIsCurrentClipboard
OleIsRunning
OleLoad
OleLoadFromStream
OleLoadPicture
OleLoadPictureEx
OleLoadPictureFile
OleLoadPictureFileEx
OleLoadPicturePath
OleLockRunning
OleMetafilePictFromIconAndLabel
OleNoteObjectVisible
OleQueryCreateFromData
OleQueryLinkFromData
OleRegEnumFormatEtc
OleRegEnumVerbs
OleRegGetMiscStatus
OleRegGetUserType
OleRun
OleSave
OleSavePictureFile
OleSaveToStream
OleSaveToStreamEx
OleSetAutoConvert
OleSetClipboard
OleSetContainedObject
OleSetMenuDescriptor
OleTranslateAccelerator
OleTranslateColor
OleUIAddVerbMenu
OleUIAddVerbMenuA
OleUIBusy
OleUIBusyA
OleUICanConvertOrActivateAs
OleUIChangeIcon
OleUIChangeIconA
OleUIChangeSourceA
OleUIConvert
OleUIConvertA
OleUIEditLinks
OleUIEditLinksA
OleUIInsertObject
OleUIInsertObjectA
OleUIObjectPropertiesA
OleUIPasteSpecial
OleUIPasteSpecialA
OleUIUpdateLinks
OleUIUpdateLinksA
OleUninitialize
OnlineClusterGroup
OnlineClusterResource
OpenAndMapFileForRead
OpenBackupEventLogA
OpenClipboard
OpenCluster
OpenClusterGroup
OpenClusterNetInterface
OpenClusterNetwork
OpenClusterNode
OpenClusterResource
OpenColorProfileA
OpenDesktopA
OpenDriver
OpenEventA
OpenEventLogA
OpenFile
OpenFileMappingA
OpenIMsgOnIStg
OpenIMsgSession
OpenIcon
OpenInputDesktop
OpenJobObjectA
OpenMutexA
OpenNtmsNotification
OpenNtmsSessionA
OpenOrCreateStream
OpenPrinterA
OpenProcess
OpenProcessToken
OpenProfileUserMapping
OpenRawA
OpenSCManagerA
OpenSemaphoreA
OpenServiceA
OpenStream
OpenStreamOnFile
OpenThreadToken
OpenTnefStream
OpenTnefStreamEx
OpenWaitableTimerA
OpenWindowStationA
OssX509SpcIndirectDataContentDecode
OssX509SpcIndirectDataContentEncode
OutOfMemory
OutputDebugStringA
PackDDElParam
PageSetupDlgA
PaintDesktop
PaintRgn
ParseX509EncodedCertificateForListBoxEntry
PatBlt
PathAddBackslashA
PathAddExtensionA
PathAppendA
PathBuildRootA
PathCanonicalizeA
PathCombineA
PathCommonPrefixA
PathCompactPathA
PathCompactPathExA
PathCreateFromUrlA
PathFileExistsA
PathFindExtensionA
PathFindFileNameA
PathFindNextComponentA
PathFindOnPathA
PathGetArgsA
PathGetCharTypeA
PathGetDriveNumberA
PathIsContentTypeA
PathIsDirectoryA
PathIsFileSpecA
PathIsPrefixA
PathIsRelativeA
PathIsRootA
PathIsSameRootA
PathIsSystemFolderA
PathIsUNCA
PathIsUNCServerA
PathIsUNCServerShareA
PathIsURLA
PathMakePrettyA
PathMakeSystemFolderA
PathMatchSpecA
PathParseIconLocationA
PathQuoteSpacesA
PathRelativePathToA
PathRemoveArgsA
PathRemoveBackslashA
PathRemoveBlanksA
PathRemoveExtensionA
PathRemoveFileSpecA
PathRenameExtensionA
PathSearchAndQualifyA
PathSetDlgItemPathA
PathSkipRootA
PathStripPathA
PathStripToRootA
PathToRegion
PathUnmakeSystemFolderA
PathUnquoteSpacesA
PauseClusterNode
PdhAddCounterA
PdhBrowseCountersA
PdhCalculateCounterFromRawValue
PdhCloseLog
PdhCloseQuery
PdhCollectQueryData
PdhCollectQueryDataEx
PdhComputeCounterStatistics
PdhConnectMachineA
PdhDecodeWmiPathA
PdhEncodeWmiPathA
PdhEnumMachinesA
PdhEnumObjectItemsA
PdhEnumObjectsA
PdhExpandCounterPathA
PdhFormatFromRawValue
PdhGetCounterInfoA
PdhGetCounterTimeBase
PdhGetDataSourceTimeRangeA
PdhGetDefaultPerfCounterA
PdhGetDefaultPerfObjectA
PdhGetDllVersion
PdhGetFormattedCounterArrayA
PdhGetFormattedCounterValue
PdhGetLogFileSize
PdhGetRawCounterArrayA
PdhGetRawCounterValue
PdhIsRealTimeQuery
PdhLogServiceCommandA
PdhLogServiceControlA
PdhLookupPerfIndexByNameA
PdhLookupPerfNameByIndexA
PdhMakeCounterPathA
PdhOpenLogA
PdhOpenQueryA
PdhParseCounterPathA
PdhParseInstanceNameA
PdhReadRawLogRecord
PdhRemoveCounter
PdhSelectDataSourceA
PdhSetCounterScaleFactor
PdhSetQueryTimeRange
PdhUpdateLogA
PdhValidatePathA
PdhVbAddCounter
PdhVbCreateCounterPathList
PdhVbGetCounterPathElements
PdhVbGetCounterPathFromList
PdhVbGetDoubleCounterValue
PdhVbGetOneCounterPath
PdhVbIsGoodStatus
PdhVbOpenQuery
PeekConsoleInputA
PeekMessageA
PeekNamedPipe
PeekPenInput
PenDataFromBuffer
PenDataToBuffer
Pie
PixelFormatDescriptorFromDc
PlayEnhMetaFile
PlayEnhMetaFileRecord
PlayGdiScriptOnPrinterIC
PlayMetaFile
PlayMetaFileRecord
PlaySoundA
PlgBlt
PolyBezier
PolyBezierTo
PolyDraw
PolyPatBlt
PolyPolygon
PolyPolyline
PolyTextOutA
Polygon
Polyline
PolylineTo
PostComponentError
PostMessageA
PostODBCComponentError
PostODBCError
PostQueuedCompletionStatus
PostQuitMessage
PostThreadMessageA
PpropFindProp
PrepareTape
PrintDlgA
PrinterMessageBoxA
PrinterProperties
PrivilegeCheck
PrivilegedServiceAuditAlarmA
Process32First
Process32Next
ProcessHRC
ProgIDFromCLSID
PropCopyMore
PropStgNameToFmtId
PropSysAllocString
PropSysFreeString
PropVariantClear
PropVariantCopy
PropVariantToAdsType
PropertySheetA
PtInRect
PtInRegion
PtVisible
PulseEvent
PurgeComm
QueryDosDeviceA
QueryInformationJobObject
QueryMultiSzValueToArray
QueryPathOfRegTypeLib
QueryPerformanceCounter
QueryPerformanceFrequency
QueryRecoveryAgentsA
QueryRegistryValue
QueryRemoteFonts
QueryServiceConfig2A
QueryServiceConfigA
QueryServiceLockStatusA
QueryServiceObjectSecurity
QueryServiceStatus
QuerySpoolMode
QueryWin31IniFilesMappedToRegistry
QueryWindows31FilesMigration
QueueUserAPC
QueueWorkItem
ROUTINE
RTFSync
RaiseException
RasAdminCompressPhoneNumber
RasAdminDLLInit
RasAdminFreeBuffer
RasAdminGetErrorString
RasAdminGetUserAccountServer
RasAdminGetUserParms
RasAdminPortClearStatistics
RasAdminPortDisconnect
RasAdminPortEnum
RasAdminPortGetInfo
RasAdminServerGetInfo
RasAdminSetUserParms
RasAdminUserGetInfo
RasAdminUserSetInfo
RasAutodialAddressToNetwork
RasAutodialDisableDlgA
RasAutodialEntryToNetwork
RasAutodialQueryDlgA
RasConnectionNotificationA
RasCreatePhonebookEntryA
RasDeleteEntryA
RasDialA
RasDialDlgA
RasDialWow
RasEditPhonebookEntryA
RasEntryDlgA
RasEnumAutodialAddressesA
RasEnumConnectionsA
RasEnumConnectionsWow
RasEnumDevicesA
RasEnumEntriesA
RasEnumEntriesWow
RasGetAutodialAddressA
RasGetAutodialEnableA
RasGetAutodialParamA
RasGetConnectResponse
RasGetConnectStatusA
RasGetConnectStatusWow
RasGetCountryInfoA
RasGetCredentialsA
RasGetEntryDialParamsA
RasGetEntryPropertiesA
RasGetErrorStringA
RasGetErrorStringWow
RasGetHport
RasGetProjectionInfoA
RasGetSubEntryHandleA
RasGetSubEntryPropertiesA
RasHangUpA
RasHangUpWow
RasIsRouterConnection
RasMonitorDlgA
RasPhonebookDlgA
RasRenameEntryA
RasSetAutodialAddressA
RasSetAutodialEnableA
RasSetAutodialParamA
RasSetCredentialsA
RasSetEntryDialParamsA
RasSetEntryPropertiesA
RasSetOldPassword
RasSetSubEntryPropertiesA
RasValidateEntryNameA
RatingAccessDeniedDialog
RatingAccessDeniedDialog2
RatingAddPropertyPages
RatingCheckUserAccess
RatingEnable
RatingEnabledQuery
RatingFreeDetails
RatingInit
RatingObtainCancel
RatingObtainQuery
RatingSetupUI
RawImageClose
RawImageGetData
RawImageGetRow
ReBaseImage
ReadAsciiOrUnicodeTextFile
ReadClassStg
ReadClassStm
ReadConsoleA
ReadConsoleInputA
ReadConsoleInputExA
ReadConsoleOutputA
ReadConsoleOutputAttribute
ReadConsoleOutputCharacterA
ReadEventLogA
ReadFile
ReadFileEx
ReadFileScatter
ReadFileVlm
ReadFmtUserTypeStg
ReadHWL
ReadInt
ReadOleStg
ReadPrinter
ReadProcessMemory
ReadProcessMemoryVlm
ReadRaw
ReadStringStream
ReadUrlCacheEntryStream
RealChildWindowFromPoint
RealGetWindowClassA
RealScreenSaverProc
RealShellExecuteA
RealShellExecuteExA
RealizePalette
RealizePaletteNow
ReallocADsMem
ReallocADsStr
RectInRegion
RectVisible
Rectangle
RedisplayPenData
RedrawWindow
RefreshInstalledTestList
RegCloseKey
RegConnectRegistryA
RegCreateKeyA
RegCreateKeyExA
RegCreateKeyExU
RegDeleteKeyA
RegDeleteValueA
RegDeleteValueU
RegEnumKeyA
RegEnumKeyExA
RegEnumValueA
RegEnumValueU
RegFlushKey
RegGetKeySecurity
RegLoadKeyA
RegNotifyChangeKeyValue
RegOpenKeyA
RegOpenKeyExA
RegOverridePredefKey
RegQueryInfoKeyA
RegQueryInfoKeyU
RegQueryMultipleValuesA
RegQueryValueA
RegQueryValueExA
RegQueryValueExU
RegReplaceKeyA
RegRestoreKeyA
RegSaveKeyA
RegSetKeySecurity
RegSetValueA
RegSetValueExA
RegSetValueExU
RegUnLoadKeyA
RegenerateUserEnvironment
RegisterActiveObject
RegisterAllServers
RegisterBindStatusCallback
RegisterCMMA
RegisterClassA
RegisterClassExA
RegisterClipboardFormatA
RegisterClusterNotify
RegisterConsoleVDM
RegisterDeviceNotificationA
RegisterDialogClasses
RegisterDragDrop
RegisterEventSourceA
RegisterFormatEnumerator
RegisterHotKey
RegisterMediaTypeClass
RegisterMediaTypes
RegisterServiceCtrlHandlerA
RegisterTypeLib
RegisterWaitForInputIdle
RegisterWindowMessageA
RegisterWowBaseHandlers
RegisterWowExec
RegistryDelnode
ReleaseBindInfo
ReleaseCapture
ReleaseDC
ReleaseMutex
ReleaseNtmsCleanerSlot
ReleaseSemaphore
ReleaseStaticEntries
ReleaseStgMedium
RemoveClusterResourceDependency
RemoveClusterResourceNode
RemoveDirectoryA
RemoveFontMemResourceEx
RemoveFontResourceA
RemoveFontResourceExA
RemoveMenu
RemovePenDataStrokes
RemovePrivateCvSymbolic
RemovePrivateCvSymbolicEx
RemovePropA
RemoveRelocations
Remove_Symbol
ReplaceTextA
ReplyMessage
ReportEventA
RequestWakeupLatency
ResUtilAddUnknownProperties
ResUtilDoIoctl
ResUtilDupParameterBlock
ResUtilDupString
ResUtilEnumPrivateProperties
ResUtilEnumProperties
ResUtilEnumResources
ResUtilFindDwordProperty
ResUtilFindSzProperty
ResUtilFreeParameterBlock
ResUtilGetAllProperties
ResUtilGetBinaryProperty
ResUtilGetBinaryValue
ResUtilGetDwordProperty
ResUtilGetDwordValue
ResUtilGetEnvironmentWithNetName
ResUtilGetMultiSzProperty
ResUtilGetPrivateProperties
ResUtilGetProperties
ResUtilGetPropertiesToParameterBlock
ResUtilGetProperty
ResUtilGetPropertySize
ResUtilGetResourceDependency
ResUtilGetResourceNameDependency
ResUtilGetSzProperty
ResUtilGetSzValue
ResUtilIsPathValid
ResUtilOpenDriver
ResUtilPropertyListFromParameterBlock
ResUtilResourceTypesEqual
ResUtilResourcesEqual
ResUtilSetBinaryValue
ResUtilSetDwordValue
ResUtilSetExpandSzValue
ResUtilSetMultiSzValue
ResUtilSetPrivatePropertyList
ResUtilSetPropertyParameterBlock
ResUtilSetPropertyTable
ResUtilSetSzValue
ResUtilStartResourceService
ResUtilStopResourceService
ResUtilStopService
ResUtilVerifyPrivatePropertyList
ResUtilVerifyPropertyTable
ResUtilVerifyResourceService
ResUtilVerifyService
ReserveNtmsCleanerSlot
ResetDCA
ResetEvent
ResetForRunList
ResetPrinterA
ResizePalette
ResizePenData
RestoreConnectionA0
RestoreDC
ResumeClusterNode
ResumeThread
RetreiveFileSecurity
RetrieveServiceConfig
RetrieveUrlCacheEntryFileA
RetrieveUrlCacheEntryStreamA
ReuseDDElParam
RevertToSelf 
RevokeActiveObject
RevokeBindStatusCallback
RevokeDragDrop
RevokeFormatEnumerator
Ring_Literal
Ring_Match
RoundRect
RouterAssert
RouterEntryDlgA
RouterGetErrorStringA
RouterLogDeregisterA
RouterLogEventA
RouterLogEventDataA
RouterLogEventStringA
RouterLogRegisterA
RpcAbortAsyncCall
RpcAsyncAbortCall
RpcAsyncCancelCall
RpcAsyncCompleteCall
RpcAsyncGetCallStatus
RpcAsyncInitializeHandle
RpcAsyncRegisterInfo
RpcBindingCopy
RpcBindingFree
RpcBindingFromStringBindingA
RpcBindingInqAuthClientA
RpcBindingInqAuthInfoA
RpcBindingInqAuthInfoExA
RpcBindingInqObject
RpcBindingInqOption
RpcBindingReset
RpcBindingServerFromClient
RpcBindingSetAuthInfoA
RpcBindingSetAuthInfoExA
RpcBindingSetObject
RpcBindingSetOption
RpcBindingToStringBindingA
RpcBindingVectorFree
RpcCancelAsyncCall
RpcCancelThread
RpcCompleteAsyncCall
RpcEpRegisterA
RpcEpRegisterNoReplaceA
RpcEpResolveBinding
RpcEpUnregister
RpcGetAsyncCallStatus
RpcIfIdVectorFree
RpcIfInqId
RpcImpersonateClient
RpcInitializeAsyncHandle
RpcMgmtBindingInqParameter
RpcMgmtBindingSetParameter
RpcMgmtEnableIdleCleanup
RpcMgmtEpEltInqBegin
RpcMgmtEpEltInqDone
RpcMgmtEpEltInqNextA
RpcMgmtEpUnregister
RpcMgmtInqComTimeout
RpcMgmtInqDefaultProtectLevel
RpcMgmtInqIfIds
RpcMgmtInqParameter
RpcMgmtInqServerPrincNameA
RpcMgmtInqStats
RpcMgmtIsServerListening
RpcMgmtSetAuthorizationFn
RpcMgmtSetCancelTimeout
RpcMgmtSetComTimeout
RpcMgmtSetParameter
RpcMgmtSetServerStackSize
RpcMgmtStatsVectorFree
RpcMgmtStopServerListening
RpcMgmtWaitServerListen
RpcNetworkInqProtseqsA
RpcNetworkIsProtseqValidA
RpcNsBindingExportA
RpcNsBindingImportBeginA
RpcNsBindingImportDone
RpcNsBindingImportNext
RpcNsBindingInqEntryNameA
RpcNsBindingLookupBeginA
RpcNsBindingLookupDone
RpcNsBindingLookupNext
RpcNsBindingSelect
RpcNsBindingUnexportA
RpcNsEntryExpandNameA
RpcNsEntryObjectInqBeginA
RpcNsEntryObjectInqDone
RpcNsEntryObjectInqNext
RpcNsGroupDeleteA
RpcNsGroupMbrAddA
RpcNsGroupMbrInqBeginA
RpcNsGroupMbrInqDone
RpcNsGroupMbrInqNextA
RpcNsGroupMbrRemoveA
RpcNsMgmtBindingUnexportA
RpcNsMgmtEntryCreateA
RpcNsMgmtEntryDeleteA
RpcNsMgmtEntryInqIfIdsA
RpcNsMgmtHandleSetExpAge
RpcNsMgmtInqExpAge
RpcNsMgmtSetExpAge
RpcNsProfileDeleteA
RpcNsProfileEltAddA
RpcNsProfileEltInqBeginA
RpcNsProfileEltInqDone
RpcNsProfileEltInqNextA
RpcNsProfileEltRemoveA
RpcObjectInqType
RpcObjectSetInqFn
RpcObjectSetType
RpcProtseqVectorFreeA
RpcRaiseException
RpcRegisterAsyncInfo
RpcRevertToSelf
RpcRevertToSelfEx
RpcServerInqBindings
RpcServerInqDefaultPrincNameA
RpcServerInqIf
RpcServerListen
RpcServerRegisterAuthInfoA
RpcServerRegisterIf
RpcServerRegisterIfEx
RpcServerTestCancel
RpcServerUnregisterIf
RpcServerUseAllProtseqs
RpcServerUseAllProtseqsEx
RpcServerUseAllProtseqsIf
RpcServerUseAllProtseqsIfEx
RpcServerUseProtseqA
RpcServerUseProtseqEpA
RpcServerUseProtseqEpExA
RpcServerUseProtseqExA
RpcServerUseProtseqIfA
RpcServerUseProtseqIfExA
RpcSmAllocate
RpcSmClientFree
RpcSmDestroyClientContext
RpcSmDisableAllocate
RpcSmEnableAllocate
RpcSmFree
RpcSmGetThreadHandle
RpcSmSetClientAllocFree
RpcSmSetThreadHandle
RpcSmSwapClientAllocFree
RpcSsAllocate
RpcSsDestroyClientContext
RpcSsDisableAllocate
RpcSsDontSerializeContext
RpcSsEnableAllocate
RpcSsFree
RpcSsGetThreadHandle
RpcSsSetClientAllocFree
RpcSsSetThreadHandle
RpcSsSwapClientAllocFree
RpcStringBindingComposeA
RpcStringBindingParseA
RpcStringFreeA
RpcTestCancel
RtlFillMemory
RtlMoveMemory
RtlUnwind
RtlZeroMemory
Rtl_Free
Rtl_Malloc
RtmAddRoute
RtmBlockConvertRoutesToStatic
RtmBlockDeleteRoutes
RtmBlockSetRouteEnable
RtmCloseEnumerationHandle
RtmCreateEnumerationHandle
RtmCreateRouteTable
RtmDeleteRoute
RtmDeleteRouteTable
RtmDequeueRouteChangeMessage
RtmDeregisterClient
RtmEnumerateGetNextRoute
RtmGetFirstRoute
RtmGetNetworkCount
RtmGetNextRoute
RtmGetRouteAge
RtmIsRoute
RtmRegisterClient
RunAutoTest
RunOnceUrlCache
RxNetAccessAdd
RxNetAccessDel
RxNetAccessEnum
RxNetAccessGetInfo
RxNetAccessGetUserPerms
RxNetAccessSetInfo
RxNetServerEnum
RxNetUserPasswordSet
SCardAddReaderToGroupA
SCardBeginTransaction
SCardCancel
SCardConnectA
SCardControl
SCardDisconnect
SCardDlgExtendedError
SCardEndTransaction
SCardEstablishContext
SCardForgetCardTypeA
SCardForgetReaderA
SCardForgetReaderGroupA
SCardFreeMemory
SCardGetAttrib
SCardGetProviderIdA
SCardGetStatusChangeA
SCardIntroduceCardTypeA
SCardIntroduceReaderA
SCardIntroduceReaderGroupA
SCardListCardsA
SCardListInterfacesA
SCardListReaderGroupsA
SCardListReadersA
SCardLocateCardsA
SCardReconnect
SCardReleaseContext
SCardRemoveReaderFromGroupA
SCardSetAttrib
SCardState
SCardStatusA
SCardTransmit
SHAddToRecentDocs
SHAppBarMessage
SHBrowseForFolderA
SHChangeNotify
SHCreateShellPalette
SHDeleteEmptyKeyA
SHDeleteKeyA
SHDeleteOrphanKeyA
SHDeleteValueA
SHEmptyRecycleBinA
SHEnumKeyExA
SHEnumValueA
SHFileOperationA
SHFormatDrive
SHFreeNameMappings
SHGetDataFromIDListA
SHGetDesktopFolder
SHGetDiskFreeSpaceA
SHGetFileInfoA
SHGetInstanceExplorer
SHGetInverseCMAP
SHGetMalloc
SHGetNewLinkInfo
SHGetPathFromIDListA
SHGetSettings
SHGetSpecialFolderLocation
SHGetSpecialFolderPathA
SHGetValueA
SHInvokePrinterCommandA
SHIsLowMemoryMachine
SHLoadInProc
SHOpenRegStreamA
SHQueryInfoKeyA
SHQueryRecycleBinA
SHQueryValueExA
SHRegCloseUSKey
SHRegCreateUSKeyA
SHRegDeleteEmptyUSKeyA
SHRegDeleteUSValueA
SHRegEnumUSKeyA
SHRegEnumUSValueA
SHRegGetBoolUSValueA
SHRegGetUSValueA
SHRegOpenUSKeyA
SHRegQueryInfoUSKeyA
SHRegQueryUSValueA
SHRegSetUSValueA
SHRegWriteUSValueA
SHSetValueA
SHUpdateRecycleBinIcon
SNB_UserFree
SNB_UserMarshal
SNB_UserSize
SNB_UserUnmarshal
SQLAllocConnect
SQLAllocEnv
SQLAllocHandle
SQLAllocHandleStd
SQLAllocStmt
SQLBindCol
SQLBindParam
SQLBindParameter
SQLBrowseConnectA
SQLBulkOperations
SQLCancel
SQLCloseCursor
SQLColAttributeA
SQLColAttributesA
SQLColumnPrivilegesA
SQLColumnsA
SQLConfigDataSource
SQLConfigDriver
SQLConnectA
SQLCopyDesc
SQLCreateDataSource
SQLDataSourcesA
SQLDescribeColA
SQLDescribeParam
SQLDisconnect
SQLDriverConnectA
SQLDriversA
SQLEndTran
SQLErrorA
SQLExecDirectA
SQLExecute
SQLExtendedFetch
SQLFetch
SQLFetchScroll
SQLForeignKeysA
SQLFreeConnect
SQLFreeEnv
SQLFreeHandle
SQLFreeStmt
SQLGetAvailableDrivers
SQLGetConfigMode
SQLGetConnectAttrA
SQLGetConnectOptionA
SQLGetCursorNameA
SQLGetData
SQLGetDescFieldA
SQLGetDescRecA
SQLGetDiagFieldA
SQLGetDiagRecA
SQLGetEnvAttr
SQLGetFunctions
SQLGetInfoA
SQLGetInstalledDrivers
SQLGetPrivateProfileString
SQLGetStmtAttrA
SQLGetStmtOption
SQLGetTranslator
SQLGetTypeInfoA
SQLInstallDriver
SQLInstallDriverEx
SQLInstallDriverManager
SQLInstallODBC
SQLInstallTranslator
SQLInstallTranslatorEx
SQLInstallerError
SQLManageDataSources
SQLMoreResults
SQLNativeSqlA
SQLNumParams
SQLNumResultCols
SQLParamData
SQLParamOptions
SQLPostInstallerError
SQLPrepareA
SQLPrimaryKeysA
SQLProcedureColumnsA
SQLProceduresA
SQLPutData
SQLReadFileDSN
SQLRemoveDSNFromIni
SQLRemoveDefaultDataSource
SQLRemoveDriver
SQLRemoveDriverManager
SQLRemoveTranslator
SQLRowCount
SQLSetConfigMode
SQLSetConnectAttrA
SQLSetConnectOptionA
SQLSetCursorNameA
SQLSetDescFieldA
SQLSetDescRec
SQLSetEnvAttr
SQLSetParam
SQLSetPos
SQLSetScrollOptions
SQLSetStmtAttrA
SQLSetStmtOption
SQLSpecialColumnsA
SQLStatisticsA
SQLTablePrivilegesA
SQLTablesA
SQLTransact
SQLValidDSN
SQLWriteDSNToIni
SQLWriteFileDSN
SQLWritePrivateProfileString
STGMEDIUM_UserFree
STGMEDIUM_UserMarshal
STGMEDIUM_UserSize
STGMEDIUM_UserUnmarshal
SafeArrayAccessData
SafeArrayAllocData
SafeArrayAllocDescriptor
SafeArrayAllocDescriptorEx
SafeArrayCopy
SafeArrayCopyData
SafeArrayCreate
SafeArrayCreateEx
SafeArrayCreateVector
SafeArrayCreateVectorEx
SafeArrayDestroy
SafeArrayDestroyData
SafeArrayDestroyDescriptor
SafeArrayGetDim
SafeArrayGetElement
SafeArrayGetElemsize
SafeArrayGetIID
SafeArrayGetLBound
SafeArrayGetRecordInfo
SafeArrayGetUBound
SafeArrayGetVartype
SafeArrayLock
SafeArrayPtrOfIndex
SafeArrayPutElement
SafeArrayRedim
SafeArraySetIID
SafeArraySetRecordInfo
SafeArrayUnaccessData
SafeArrayUnlock
SatisfyNtmsOperatorRequest
SaveDC
ScBinFromHexBounded
ScCopyNotifications
ScCopyProps
ScCountNotifications
ScCountProps
ScCreateConversationIndex
ScDupPropset
ScGenerateMuid
ScInitMapiUtil
ScLocalPathFromUNC
ScRelocNotifications
ScRelocProps
ScUNCFromLocalPath
ScaleViewportExtEx
ScaleWindowExtEx
ScheduleJob
ScreenSaverChangePassword
ScreenSaverConfigureDialog
ScreenSaverProc
ScreenToClient
ScrollChildren
ScrollConsoleScreenBufferA
ScrollDC
ScrollWindow
ScrollWindowEx
SearchForInfFile
SearchPathA
SearchStatusCode
SearchTreeForFile
SeekFolder
SeekPrinter
SelectBrushLocal
SelectCMM
SelectClipPath
SelectClipRgn
SelectFontLocal
SelectObject
SelectPalette
SendDlgItemMessageA
SendDriverMessage
SendIMEMessageExA
SendInput
SendMessageA
SendMessageCallbackA
SendMessageTimeoutA
SendNotifyMessageA
ServiceHandler
ServiceMain
SetAbortProc
SetAclInformation
SetActiveWindow
SetAllocFailCount
SetAlphabetHRC
SetAlphabetPriorityHRC
SetArcDirection
SetArrayToMultiSzValue
SetAttribIMsgOnIStg
SetBitmapBits
SetBitmapDimensionEx
SetBkColor
SetBkMode
SetBoundsRect
SetBoxAlphabetHRC
SetBrushOrgEx
SetCapture
SetCaretBlinkTime
SetCaretPos
SetClassLongA
SetClassWord
SetClipboardData
SetClipboardViewer
SetClusterGroupName
SetClusterGroupNodeList
SetClusterName
SetClusterNetworkName
SetClusterNetworkPriorityOrder
SetClusterQuorumResource
SetClusterResourceName
SetColorAdjustment
SetColorProfileElement
SetColorProfileElementReference
SetColorProfileElementSize
SetColorProfileHeader
SetColorSpace
SetCommBreak
SetCommConfig
SetCommMask
SetCommState
SetCommTimeouts
SetComputerNameA
SetConsoleActiveScreenBuffer
SetConsoleCP
SetConsoleCommandHistoryMode
SetConsoleCtrlHandler
SetConsoleCursor
SetConsoleCursorInfo
SetConsoleCursorPosition
SetConsoleDisplayMode
SetConsoleFont
SetConsoleHardwareState
SetConsoleIcon
SetConsoleInputExeNameA
SetConsoleKeyShortcuts
SetConsoleMaximumWindowSize
SetConsoleMenuClose
SetConsoleMode
SetConsoleNumberOfCommandsA
SetConsoleOutputCP
SetConsolePalette
SetConsoleScreenBufferSize
SetConsoleTextAttribute
SetConsoleTitleA
SetConsoleWindowInfo
SetConvertStg
SetCriticalSectionSpinCount
SetCurrentDirectoryA
SetCursor
SetCursorPos
SetDCBrushColor
SetDCPenColor
SetDIBColorTable
SetDIBits
SetDIBitsToDevice
SetDebugErrorLevel
SetDecompressionType
SetDefaultCommConfigA
SetDefaultPrinterA
SetDeskWallpaper
SetDeviceGammaRamp
SetDlgItemInt
SetDlgItemTextA
SetDocumentBitStg
SetDoubleClickTime
SetEndOfFile
SetEnhMetaFileBits
SetEntriesInAccessListA
SetEntriesInAclA
SetEntriesInAuditListA
SetEnvironmentVariableA
SetErrorInfo
SetErrorMode
SetEvent
SetFileApisToANSI
SetFileApisToOEM
SetFileAttributesA
SetFilePointer
SetFileSecurityA
SetFileTime
SetFilters
SetFocus
SetFontEnumeration
SetForegroundWindow
SetFormA
SetGraphicsMode
SetGuideHRC
SetHandleCount
SetHandleInformation
SetICMMode
SetICMProfileA
SetImageConfigInformation
SetInformationJobObject
SetInternationalHRC
SetIoCompletionProc
SetJobA
SetKernelObjectSecurity
SetKeyboardState
SetLastConsoleEventActive
SetLastError
SetLastErrorEx
SetLocalTime
SetLocaleInfoA
SetMagicColors
SetMailslotInfo
SetMapMode
SetMapperFlags
SetMaxResultsHRC
SetMenu
SetMenuContextHelpId
SetMenuDefaultItem
SetMenuInfo
SetMenuItemBitmaps
SetMenuItemInfoA
SetMessageExtraInfo
SetMessageQueue
SetMetaFileBitsEx
SetMetaRgn
SetMiterLimit
SetNamedPipeHandleState
SetNamedSecurityInfoA
SetNamedSecurityInfoExA
SetNtmsMediaComplete
SetNtmsObjectAttributeA
SetNtmsObjectInformationA
SetNtmsObjectSecurity
SetPaletteEntries
SetParent
SetPenAppFlags
SetPenMiscInfo
SetPixel
SetPixelFormat
SetPixelV
SetPolyFillMode
SetPortA
SetPrinterA
SetPrinterDataA
SetPrinterDataExA
SetPrinterHTMLViewA
SetPriorityClass
SetPrivateObjectSecurity
SetPrivateObjectSecurityEx
SetProcessAffinityMask
SetProcessPriorityBoost
SetProcessShutdownParameters
SetProcessWindowStation
SetProcessWorkingSetSize
SetPropA
SetROP2
SetRect
SetRectEmpty
SetRectRgn
SetRelAbs
SetResultsHookHREC
SetScrollInfo
SetScrollPos
SetScrollRange
SetSecurityDescriptorControl
SetSecurityDescriptorDacl
SetSecurityDescriptorGroup
SetSecurityDescriptorOwner
SetSecurityDescriptorSacl
SetSecurityInfo
SetSecurityInfoExA
SetServiceA
SetServiceBits
SetServiceObjectSecurity
SetServiceStatus
SetShellWindow
SetSoftwareUpdateAdvertisementState
SetStandardColorSpaceProfileA
SetStdHandle
SetStretchBltMode
SetStrokeAttributes
SetStrokeTableAttributes
SetSysColors
SetSystemCursor
SetSystemMenu
SetSystemPaletteUse
SetSystemPowerState
SetSystemTime
SetSystemTimeAdjustment
SetSystemTimer
SetTapeParameters
SetTapePosition
SetTextAlign
SetTextCharacterExtra
SetTextColor
SetTextJustification
SetThreadAffinityMask
SetThreadContext
SetThreadDesktop
SetThreadExecutionState
SetThreadIdealProcessor
SetThreadLocale
SetThreadPriority
SetThreadPriorityBoost
SetThreadToken
SetTimeZoneInformation
SetTimer
SetTokenInformation
SetUnhandledExceptionFilter
SetUrlCacheConfigInfoA
SetUrlCacheEntryGroup
SetUrlCacheEntryInfoA
SetUrlCacheHeaderData
SetUserObjectInformationA
SetUserObjectSecurity
SetVDMCurrentDirectories
SetViewportExtEx
SetViewportOrgEx
SetVolumeLabelA
SetWaitableTimer
SetWinEventHook
SetWinMetaFileBits
SetWindowContextHelpId
SetWindowExtEx
SetWindowLongA
SetWindowOrgEx
SetWindowPlacement
SetWindowPos
SetWindowRgn
SetWindowTextA
SetWindowWord
SetWindowsHookA
SetWindowsHookExA
SetWordlistCoercionHRC
SetWordlistHRC
SetWorldTransform
SetupAddInstallSectionToDiskSpaceListA
SetupAddSectionToDiskSpaceListA
SetupAddToDiskSpaceListA
SetupAddToSourceListA
SetupAdjustDiskSpaceListA
SetupCancelTemporarySourceList
SetupCloseFileQueue
SetupCloseInfFile
SetupCloseLog
SetupColorMatchingA
SetupComm
SetupCommitFileQueueA
SetupCopyErrorA
SetupCopyOEMInfA
SetupCreateDiskSpaceListA
SetupDecompressOrCopyFileA
SetupDefaultQueueCallbackA
SetupDeleteErrorA
SetupDestroyDiskSpaceList
SetupDiAskForOEMDisk
SetupDiBuildClassInfoList
SetupDiBuildClassInfoListExA
SetupDiBuildDriverInfoList
SetupDiCallClassInstaller
SetupDiCancelDriverInfoSearch
SetupDiChangeState
SetupDiClassGuidsFromNameA
SetupDiClassGuidsFromNameExA
SetupDiClassNameFromGuidA
SetupDiClassNameFromGuidExA
SetupDiCreateDevRegKeyA
SetupDiCreateDeviceInfoA
SetupDiCreateDeviceInfoList
SetupDiCreateDeviceInfoListExA
SetupDiCreateDeviceInterfaceA
SetupDiCreateDeviceInterfaceRegKeyA
SetupDiDeleteDevRegKey
SetupDiDeleteDeviceInfo
SetupDiDeleteDeviceInterfaceData
SetupDiDeleteDeviceInterfaceRegKey
SetupDiDestroyClassImageList
SetupDiDestroyDeviceInfoList
SetupDiDestroyDriverInfoList
SetupDiDrawMiniIcon
SetupDiEnumDeviceInfo
SetupDiEnumDeviceInterfaces
SetupDiEnumDriverInfoA
SetupDiGetActualSectionToInstallA
SetupDiGetClassBitmapIndex
SetupDiGetClassDescriptionA
SetupDiGetClassDescriptionExA
SetupDiGetClassDevPropertySheetsA
SetupDiGetClassDevsA
SetupDiGetClassDevsExA
SetupDiGetClassImageIndex
SetupDiGetClassImageList
SetupDiGetClassImageListExA
SetupDiGetClassInstallParamsA
SetupDiGetDeviceInfoListClass
SetupDiGetDeviceInfoListDetailA
SetupDiGetDeviceInstallParamsA
SetupDiGetDeviceInstanceIdA
SetupDiGetDeviceInterfaceAlias
SetupDiGetDeviceInterfaceDetailA
SetupDiGetDeviceRegistryPropertyA
SetupDiGetDriverInfoDetailA
SetupDiGetDriverInstallParamsA
SetupDiGetHwProfileFriendlyNameA
SetupDiGetHwProfileFriendlyNameExA
SetupDiGetHwProfileList
SetupDiGetHwProfileListExA
SetupDiGetINFClassA
SetupDiGetSelectedDevice
SetupDiGetSelectedDriverA
SetupDiGetWizardPage
SetupDiInstallClassA
SetupDiInstallClassExA
SetupDiInstallDevice
SetupDiInstallDeviceInterfaces
SetupDiInstallDriverFiles
SetupDiLoadClassIcon
SetupDiMoveDuplicateDevice
SetupDiOpenClassRegKey
SetupDiOpenClassRegKeyExA
SetupDiOpenDevRegKey
SetupDiOpenDeviceInfoA
SetupDiOpenDeviceInterfaceA
SetupDiOpenDeviceInterfaceRegKey
SetupDiRegisterCoDeviceInstallers
SetupDiRegisterDeviceInfo
SetupDiRemoveDevice
SetupDiRemoveDeviceInterface
SetupDiSelectBestCompatDrv
SetupDiSelectDevice
SetupDiSelectOEMDrv
SetupDiSetClassInstallParamsA
SetupDiSetDeviceInstallParamsA
SetupDiSetDeviceRegistryPropertyA
SetupDiSetDriverInstallParamsA
SetupDiSetSelectedDevice
SetupDiSetSelectedDriverA
SetupDiUnremoveDevice
SetupDuplicateDiskSpaceListA
SetupFileInfo
SetupFindFirstLineA
SetupFindNextLine
SetupFindNextMatchLineA
SetupFreeSourceListA
SetupGetBinaryField
SetupGetFieldCount
SetupGetFileCompressionInfoA
SetupGetInfFileListA
SetupGetInfInformationA
SetupGetInfSections
SetupGetIntField
SetupGetLineByIndexA
SetupGetLineCountA
SetupGetLineTextA
SetupGetMultiSzFieldA
SetupGetSourceFileLocationA
SetupGetSourceFileSizeA
SetupGetSourceInfoA
SetupGetStringFieldA
SetupGetTargetPathA
SetupInitDefaultQueueCallback
SetupInitDefaultQueueCallbackEx
SetupInitializeFileLogA
SetupInstallFileA
SetupInstallFileExA
SetupInstallFilesFromInfSectionA
SetupInstallFromInfSectionA
SetupInstallServicesFromInfSectionA
SetupInstallServicesFromInfSectionExA
SetupIterateCabinetA
SetupLogErrorA
SetupLogFileA
SetupOpenAppendInfFileA
SetupOpenFileQueue
SetupOpenInfFileA
SetupOpenLog
SetupOpenMasterInf
SetupPromptForDiskA
SetupPromptReboot
SetupQueryDrivesInDiskSpaceListA
SetupQueryFileLogA
SetupQueryInfFileInformationA
SetupQueryInfVersionInformationA
SetupQuerySourceListA
SetupQuerySpaceRequiredOnDriveA
SetupQueueCopyA
SetupQueueCopySectionA
SetupQueueDefaultCopyA
SetupQueueDeleteA
SetupQueueDeleteSectionA
SetupQueueRenameA
SetupQueueRenameSectionA
SetupRemoveFileLogEntryA
SetupRemoveFromDiskSpaceListA
SetupRemoveFromSourceListA
SetupRemoveInstallSectionFromDiskSpaceListA
SetupRemoveSectionFromDiskSpaceListA
SetupRenameErrorA
SetupScanFileQueueA
SetupSetDirectoryIdA
SetupSetDirectoryIdExA
SetupSetPlatformPathOverrideA
SetupSetSourceListA
SetupTermDefaultQueueCallback
SetupTerminateFileLog
SheChangeDirA
SheChangeDirExA
SheFullPathA
SheGetCurDrive
SheGetDirA
SheRemoveQuotesA
SheSetCurDrive
SheShortenPathA
ShellAboutA
ShellExecuteA
ShellExecuteExA
ShellHookProc
Shell_NotifyIconA
ShouldDeviceBeExcluded
ShowCaret
ShowClientAuthCerts
ShowConsoleCursor
ShowCursor
ShowHideMenuCtl
ShowOwnedPopups
ShowScrollBar
ShowSecurityInfo
ShowWindow
ShowWindowAsync
ShowX509EncodedCertificate
SignalObjectAndWait
SizeofResource
Sleep
SleepEx
SnmpCleanup
SnmpClose
SnmpContextToStr
SnmpCountVbl
SnmpCreatePdu
SnmpCreateSession
SnmpCreateVbl
SnmpDecodeMsg
SnmpDeleteVb
SnmpDuplicatePdu
SnmpDuplicateVbl
SnmpEncodeMsg
SnmpEntityToStr
SnmpFreeContext
SnmpFreeDescriptor
SnmpFreeEntity
SnmpFreePdu
SnmpFreeVbl
SnmpGetLastError
SnmpGetPduData
SnmpGetRetransmitMode
SnmpGetRetry
SnmpGetTimeout
SnmpGetTranslateMode
SnmpGetVb
SnmpListen
SnmpMgrClose
SnmpMgrGetTrap
SnmpMgrGetTrapEx
SnmpMgrMIB2Disk
SnmpMgrOidToStr
SnmpMgrOpen
SnmpMgrRequest
SnmpMgrStrToOid
SnmpMgrTrapListen
SnmpOidCompare
SnmpOidCopy
SnmpOidToStr
SnmpOpen
SnmpRecvMsg
SnmpRegister
SnmpSendMsg
SnmpSetPduData
SnmpSetPort
SnmpSetRetransmitMode
SnmpSetRetry
SnmpSetTimeout
SnmpSetTranslateMode
SnmpSetVb
SnmpStartup
SnmpStrToContext
SnmpStrToEntity
SnmpStrToOid
SnmpSvcAddrIsIpx
SnmpSvcAddrToSocket
SnmpSvcGetEnterpriseOID
SnmpSvcGetUptime
SnmpSvcInitUptime
SnmpSvcSetLogLevel
SnmpSvcSetLogType
SnmpUtilAsnAnyCpy
SnmpUtilAsnAnyFree
SnmpUtilIdsToA
SnmpUtilMemAlloc
SnmpUtilMemFree
SnmpUtilMemReAlloc
SnmpUtilOctetsCmp
SnmpUtilOctetsCpy
SnmpUtilOctetsFree
SnmpUtilOctetsNCmp
SnmpUtilOidAppend
SnmpUtilOidCmp
SnmpUtilOidCpy
SnmpUtilOidFree
SnmpUtilOidNCmp
SnmpUtilOidToA
SnmpUtilPrintAsnAny
SnmpUtilPrintOid
SnmpUtilVarBindCpy
SnmpUtilVarBindFree
SnmpUtilVarBindListCpy
SnmpUtilVarBindListFree
SplitSymbols
SpoolerCopyFileEvent
SpoolerInit
SpoolerPrinterEvent
StackWalk
StampFileSecurity
StartDocA
StartDocDlgA
StartDocPrinterA
StartInking
StartPage
StartPagePrinter
StartPenInput
StartServiceA
StartServiceCtrlDispatcherA
StgCreateDocfile
StgCreateDocfileOnILockBytes
StgCreatePropSetStg
StgCreatePropStg
StgCreateStorageEx
StgGetIFillLockBytesOnFile
StgGetIFillLockBytesOnILockBytes
StgIsStorageFile
StgIsStorageILockBytes
StgOpenAsyncDocfileOnIFillLockBytes
StgOpenLayoutDocfile
StgOpenPropStg
StgOpenStorage
StgOpenStorageEx
StgOpenStorageOnILockBytes
StgSetTimes
StopInking
StopPenInput
StrCSpnA
StrCSpnIA
StrChrA
StrChrIA
StrCmpNA
StrCmpNIA
StrCpyNA
StrDupA
StrFormatByteSizeA
StrFromTimeIntervalA
StrIsIntlEqualA
StrNCatA
StrNCmpA
StrNCmpIA
StrNCpyA
StrPBrkA
StrRChrA
StrRChrIA
StrRStrA
StrRStrIA
StrSpnA
StrStrA
StrStrIA
StrToIntA
StrToIntExA
StrTrimA
StretchBlt
StretchDIB
StretchDIBits
StringFromCLSID
StringFromGUID2
StringFromIID
StringTableAddString
StringTableAddStringEx
StringTableDestroy
StringTableDuplicate
StringTableEnum
StringTableGetExtraData
StringTableInitialize
StringTableInitializeEx
StringTableLookUpString
StringTableLookUpStringEx
StringTableSetExtraData
StringTableStringFromId
StringTableTrim
StrokeAndFillPath
StrokePath
SubmitNtmsOperatorRequestA
SubtractRect
SuspendThread
SwapBuffers
SwapMouseButton
SwapNtmsMedia
SwapPlong
SwapPword
SwitchDesktop
SwitchToFiber
SwitchToNewCab
SwitchToThread
SymCleanup
SymEnumerateModules
SymEnumerateSymbols
SymFunctionTableAccess
SymGetLineFromAddr
SymGetLineFromName
SymGetLineNext
SymGetLinePrev
SymGetModuleBase
SymGetModuleInfo
SymGetOptions
SymGetSearchPath
SymGetSymFromAddr
SymGetSymFromName
SymGetSymNext
SymGetSymPrev
SymInitialize
SymLoadModule
SymMatchFileName
SymRegisterCallback
SymSetOptions
SymSetSearchPath
SymUnDName
SymUnloadModule
SymbolToCharacter
SynchronizeWindows31FilesAndWindowsNTRegistry
SysAllocString
SysAllocStringByteLen
SysAllocStringLen
SysFreeString
SysReAllocString
SysReAllocStringLen
SysStringByteLen
SysStringLen
SystemFunction001
SystemFunction002
SystemFunction003
SystemFunction004
SystemFunction005
SystemFunction006
SystemFunction007
SystemFunction008
SystemFunction009
SystemFunction010
SystemFunction011
SystemFunction012
SystemFunction013
SystemFunction014
SystemFunction015
SystemFunction016
SystemFunction017
SystemFunction018
SystemFunction019
SystemFunction020
SystemFunction021
SystemFunction022
SystemFunction023
SystemFunction024
SystemFunction025
SystemFunction026
SystemFunction027
SystemFunction028
SystemFunction029
SystemFunction030
SystemFunction031
SystemFunction032
SystemFunction033
SystemParametersInfoA
SystemTimeToFileTime
SystemTimeToTzSpecificLocalTime
SystemTimeToVariantTime
SzFindCh
SzFindLastCh
SzFindSz
TPtoDP
TabbedTextOutA
TakeOwnershipOfFile
TargetPoints
TerminateJobObject
TerminateProcess
TerminateThread
TestProc
TextOutA
Thread32First
Thread32Next
ThunkConnect32
TileChildWindows
TileWindows
TlsAlloc
TlsFree
TlsGetValue
TlsSetValue
ToAscii
ToAsciiEx
ToUnicode
ToUnicodeEx
Toolhelp32ReadProcessMemory
TouchFileTimes
TowerConstruct
TowerExplode
TraceDeregisterA
TraceDeregisterExA
TraceDumpExA
TraceGetConsoleA
TracePutsExA
TraceRegisterExA
TraceVprintfExA
TrackMouseEvent
TrackPopupMenu
TrackPopupMenuEx
TrainHREC
TransactNamedPipe
TranslateAcceleratorA
TranslateBitmapBits
TranslateCharsetInfo
TranslateColors
TranslateMDISysAccel
TranslateMessage
TranslateURLA
TransmitCommChar
TransmitFile
TransparentBlt
TrimPenData
TrimVirtualBuffer
TrusteeAccessToObjectA
TryEnterCriticalSection
UFromSz
UNKOBJ_COFree
UNKOBJ_Free
UNKOBJ_FreeRows
UNKOBJ_ScAllocate
UNKOBJ_ScAllocateMore
UNKOBJ_ScCOAllocate
UNKOBJ_ScCOReallocate
UNKOBJ_ScSzFromIdsAlloc
URLAssociationDialogA
URLDownloadA
URLDownloadToCacheFileA
URLDownloadToFileA
URLOpenBlockingStreamA
URLOpenPullStreamA
URLOpenStreamA
UlAddRef
UlFromSzHex
UlPropSize
UlRelease
UnDecorateSymbolName
UnMapAndLoad
UnMapLS
UnMapSLFixArray
UnRegisterTypeLib
UnhandledExceptionFilter
UnhookResultsHookHREC
UnhookWinEvent
UnhookWindowsHook
UnhookWindowsHookEx
UnicodeToMultiByte
UninitializeFlatSB
UninstallColorProfileA
UninstallRecognizer
UnionRect
UnloadKeyboardLayout
UnloadPerfCounterTextStringsA
UnloadPwdDLL
UnlockFile
UnlockFileEx
UnlockServiceDatabase
UnlockUrlCacheEntryFile
UnlockUrlCacheEntryStream
UnmapAndCloseFile
UnmapDebugInformation
UnmapViewOfFile
UnmapViewOfFileVlm
UnpackDDElParam
UnrealizeObject
UnregisterCMMA
UnregisterClassA
UnregisterDeviceNotification
UnregisterHotKey
UpdateClassStoreSettings
UpdateColors
UpdateDCOMSettings
UpdateDebugInfoFile
UpdateDebugInfoFileEx
UpdateICMRegKeyA
UpdateNtmsOmidInfo
UpdateResourceA
UpdateStaticMapping
UpdateUrlCacheContentPath
UpdateWindow
UrlApplySchemeA
UrlCanonicalizeA
UrlCombineA
UrlCompareA
UrlCreateFromPathA
UrlEscapeA
UrlGetLocationA
UrlGetPartA
UrlHashA
UrlIsA
UrlIsNoHistoryA
UrlIsOpaqueA
UrlMkBuildVersion
UrlMkGetSessionOption
UrlMkSetSessionOption
UrlUnescapeA
UserBSTR_free_inst
UserBSTR_free_local
UserBSTR_from_local
UserBSTR_to_local
UserEXCEPINFO_free_inst
UserEXCEPINFO_free_local
UserEXCEPINFO_from_local
UserEXCEPINFO_to_local
UserHWND_free_inst
UserHWND_free_local
UserHWND_from_local
UserHWND_to_local
UserHandleGrantAccess
UserMSG_free_inst
UserMSG_free_local
UserMSG_from_local
UserMSG_to_local
UserVARIANT_free_inst
UserVARIANT_free_local
UserVARIANT_from_local
UserVARIANT_to_local
UtConvertDvtd16toDvtd32
UtConvertDvtd32toDvtd16
UtGetDvtd16Info
UtGetDvtd32Info
UuidCompare
UuidCreate
UuidCreateNil
UuidEqual
UuidFromStringA
UuidHash
UuidIsNil
UuidToStringA
VARIANT_UserFree
VARIANT_UserMarshal
VARIANT_UserSize
VARIANT_UserUnmarshal
VDMBreakThread
VDMConsoleOperation
VDMEnumTaskWOWEx
VDMGetAddrExpression
VDMGetContext
VDMGetDbgFlags
VDMGetModuleSelector
VDMGetPointer
VDMGetSegmentInfo
VDMGetSegtablePointer
VDMGetSelectorModule
VDMGetSymbol
VDMGetThreadContext
VDMGetThreadSelectorEntry
VDMGlobalFirst
VDMGlobalNext
VDMIsModuleLoaded
VDMModuleFirst
VDMModuleNext
VDMOperationStarted
VDMProcessException
VDMSetContext
VDMSetDbgFlags
VDMSetThreadContext
VFreeErrors
VRetrieveDriverErrorsRowCol
ValidateErrorQueue
ValidateRect
ValidateRgn
VarAbs
VarAdd
VarAnd
VarBoolFromCy
VarBoolFromDate
VarBoolFromDec
VarBoolFromDisp
VarBoolFromI1
VarBoolFromI2
VarBoolFromI4
VarBoolFromR4
VarBoolFromR8
VarBoolFromStr
VarBoolFromUI1
VarBoolFromUI2
VarBoolFromUI4
VarBstrCat
VarBstrCmp
VarBstrFromBool
VarBstrFromCy
VarBstrFromDate
VarBstrFromDec
VarBstrFromDisp
VarBstrFromI1
VarBstrFromI2
VarBstrFromI4
VarBstrFromR4
VarBstrFromR8
VarBstrFromUI1
VarBstrFromUI2
VarBstrFromUI4
VarCat
VarCmp
VarCyAbs
VarCyAdd
VarCyCmp
VarCyCmpR8
VarCyFix
VarCyFromBool
VarCyFromDate
VarCyFromDec
VarCyFromDisp
VarCyFromI1
VarCyFromI2
VarCyFromI4
VarCyFromR4
VarCyFromR8
VarCyFromStr
VarCyFromUI1
VarCyFromUI2
VarCyFromUI4
VarCyInt
VarCyMul
VarCyMulI4
VarCyNeg
VarCyRound
VarCySub
VarDateFromBool
VarDateFromCy
VarDateFromDec
VarDateFromDisp
VarDateFromI1
VarDateFromI2
VarDateFromI4
VarDateFromR4
VarDateFromR8
VarDateFromStr
VarDateFromUI1
VarDateFromUI2
VarDateFromUI4
VarDateFromUdate
VarDecAbs
VarDecAdd
VarDecCmp
VarDecCmpR8
VarDecDiv
VarDecFix
VarDecFromBool
VarDecFromCy
VarDecFromDate
VarDecFromDisp
VarDecFromI1
VarDecFromI2
VarDecFromI4
VarDecFromR4
VarDecFromR8
VarDecFromStr
VarDecFromUI1
VarDecFromUI2
VarDecFromUI4
VarDecInt
VarDecMul
VarDecNeg
VarDecRound
VarDecSub
VarDiv
VarEqv
VarFix
VarFormat
VarFormatCurrency
VarFormatDateTime
VarFormatFromTokens
VarFormatNumber
VarFormatPercent
VarI1FromBool
VarI1FromCy
VarI1FromDate
VarI1FromDec
VarI1FromDisp
VarI1FromI2
VarI1FromI4
VarI1FromR4
VarI1FromR8
VarI1FromStr
VarI1FromUI1
VarI1FromUI2
VarI1FromUI4
VarI2FromBool
VarI2FromCy
VarI2FromDate
VarI2FromDec
VarI2FromDisp
VarI2FromI1
VarI2FromI4
VarI2FromR4
VarI2FromR8
VarI2FromStr
VarI2FromUI1
VarI2FromUI2
VarI2FromUI4
VarI4FromBool
VarI4FromCy
VarI4FromDate
VarI4FromDec
VarI4FromDisp
VarI4FromI1
VarI4FromI2
VarI4FromR4
VarI4FromR8
VarI4FromStr
VarI4FromUI1
VarI4FromUI2
VarI4FromUI4
VarIdiv
VarImp
VarInt
VarMod
VarMonthName
VarMul
VarNeg
VarNot
VarNumFromParseNum
VarOr
VarParseNumFromStr
VarPow
VarR4CmpR8
VarR4FromBool
VarR4FromCy
VarR4FromDate
VarR4FromDec
VarR4FromDisp
VarR4FromI1
VarR4FromI2
VarR4FromI4
VarR4FromR8
VarR4FromStr
VarR4FromUI1
VarR4FromUI2
VarR4FromUI4
VarR8FromBool
VarR8FromCy
VarR8FromDate
VarR8FromDec
VarR8FromDisp
VarR8FromI1
VarR8FromI2
VarR8FromI4
VarR8FromR4
VarR8FromStr
VarR8FromUI1
VarR8FromUI2
VarR8FromUI4
VarR8Pow
VarR8Round
VarRound
VarSub
VarTokenizeFormatString
VarUI1FromBool
VarUI1FromCy
VarUI1FromDate
VarUI1FromDec
VarUI1FromDisp
VarUI1FromI1
VarUI1FromI2
VarUI1FromI4
VarUI1FromR4
VarUI1FromR8
VarUI1FromStr
VarUI1FromUI2
VarUI1FromUI4
VarUI2FromBool
VarUI2FromCy
VarUI2FromDate
VarUI2FromDec
VarUI2FromDisp
VarUI2FromI1
VarUI2FromI2
VarUI2FromI4
VarUI2FromR4
VarUI2FromR8
VarUI2FromStr
VarUI2FromUI1
VarUI2FromUI4
VarUI4FromBool
VarUI4FromCy
VarUI4FromDate
VarUI4FromDec
VarUI4FromDisp
VarUI4FromI1
VarUI4FromI2
VarUI4FromI4
VarUI4FromR4
VarUI4FromR8
VarUI4FromStr
VarUI4FromUI1
VarUI4FromUI2
VarUdateFromDate
VarWeekdayName
VarXor
VariantChangeType
VariantChangeTypeEx
VariantClear
VariantCopy
VariantCopyInd
VariantInit
VariantTimeToDosDateTime
VariantTimeToSystemTime
VectorFromBstr
VerFindFileA
VerInstallFileA
VerLanguageNameA
VerQueryValueA
VerQueryValueIndexA
VerifyConsoleIoHandle
VerifySupervisorPassword
VerifyTestCaseCount
VidMemAlloc
VidMemAmountFree
VidMemFini
VidMemFree
VidMemInit
VidMemLargestFree
VideoForWindowsVersion
VirtualAlloc
VirtualAllocEx
VirtualAllocVlm
VirtualBufferExceptionHandler
VirtualFree
VirtualFreeEx
VirtualFreeVlm
VirtualLock
VirtualProtect
VirtualProtectEx
VirtualProtectVlm
VirtualQuery
VirtualQueryEx
VirtualQueryVlm
VirtualUnlock
VkKeyScanA
VkKeyScanExA
WEP
WINNLSEnableIME
WINNLSGetEnableStatus
WINNLSGetIMEHotkey
WNetAddConnection2A
WNetAddConnection3A
WNetAddConnectionA
WNetCancelConnection2A
WNetCancelConnectionA
WNetClearConnections
WNetCloseEnum
WNetConnectionDialog
WNetConnectionDialog1A
WNetConnectionDialog2
WNetDirectoryNotifyA
WNetDisconnectDialog
WNetDisconnectDialog1A
WNetDisconnectDialog2
WNetEnumResourceA
WNetFMXEditPerm
WNetFMXGetPermCaps
WNetFMXGetPermHelp
WNetFormatNetworkNameA
WNetGetConnection2A
WNetGetConnection3A
WNetGetConnectionA
WNetGetDirectoryTypeA
WNetGetLastErrorA
WNetGetNetworkInformationA
WNetGetPropertyTextA
WNetGetProviderNameA
WNetGetProviderTypeA
WNetGetResourceInformationA
WNetGetResourceParentA
WNetGetSearchDialog
WNetGetUniversalNameA
WNetGetUserA
WNetLogonNotify
WNetOpenEnumA
WNetPasswordChangeNotify
WNetPropertyDialogA
WNetSetConnectionA
WNetSetLastErrorA
WNetSupportGlobalEnum
WNetUseConnectionA
WOW32DriverCallback
WOW32ResolveMultiMediaHandle
WOWAppExit
WOWCallback16
WOWCallback16Ex
WOWDirectedYield16
WOWGetDescriptor
WOWGetVDMPointer
WOWGetVDMPointerFix
WOWGetVDMPointerUnfix
WOWGlobalAlloc16
WOWGlobalAllocLock16
WOWGlobalFree16
WOWGlobalLock16
WOWGlobalLockSize16
WOWGlobalUnlock16
WOWGlobalUnlockFree16
WOWHandle16
WOWHandle32
WOWShellExecute
WOWYield16
WPUCompleteOverlappedRequest
WSAAccept
WSAAddressToStringA
WSAAsyncGetHostByAddr
WSAAsyncGetHostByName
WSAAsyncGetProtoByName
WSAAsyncGetProtoByNumber
WSAAsyncGetServByName
WSAAsyncGetServByPort
WSAAsyncSelect
WSACancelAsyncRequest
WSACancelBlockingCall
WSACleanup
WSACloseEvent
WSAConnect
WSACreateEvent
WSADuplicateSocketA
WSAEnumNameSpaceProvidersA
WSAEnumNetworkEvents
WSAEnumProtocolsA
WSAEventSelect
WSAGetLastError
WSAGetOverlappedResult
WSAGetQOSByName
WSAGetServiceClassInfoA
WSAGetServiceClassNameByClassIdA
WSAHtonl
WSAHtons
WSAInstallServiceClassA
WSAIoctl
WSAIsBlocking
WSAJoinLeaf
WSALookupServiceBeginA
WSALookupServiceEnd
WSALookupServiceNextA
WSANtohl
WSANtohs
WSAProviderConfigChange
WSARecv
WSARecvDisconnect
WSARecvEx
WSARecvFrom
WSARemoveServiceClass
WSAResetEvent
WSASend
WSASendDisconnect
WSASendTo
WSASetBlockingHook
WSASetEvent
WSASetLastError
WSASetServiceA
WSASocketA
WSAStartup
WSAStringToAddressA
WSAUnhookBlockingHook
WSAWaitForMultipleEvents
WSCDeinstallProvider
WSCEnableNSProvider
WSCEnumProtocols
WSCGetProviderPath
WSCInstallNameSpace
WSCInstallProvider
WSCUnInstallNameSpace
WSCWriteProviderOrder
WaitCommEvent
WaitForDebugEvent
WaitForInputIdle
WaitForMultipleObjects
WaitForMultipleObjectsEx
WaitForNtmsNotification
WaitForNtmsOperatorRequest
WaitForPrinterChange
WaitForSingleObject
WaitForSingleObjectEx
WaitMessage
WaitNamedPipeA
WantArrows
WideCharToMultiByte
WidenPath
WinExec
WinHelpA
WinLoadTrustProvider
WinMain
WinMainN
WinSubmitCertificate
WinTrustProviderClientInitialize
WinVerifyTrust
WindowFromAccessibleObject
WindowFromDC
WindowFromPoint
WpBindToSiteA
WpCreateSiteA
WpDeleteSiteA
WpDoesSiteExistA
WpEnumProvidersA
WpGetErrorStringA
WpListSitesA
WpPostA
WrapCompressedRTFStream
WrapProgress
WrapStoreEntryID
WriteBSTR
WriteClassStg
WriteClassStm
WriteConsoleA
WriteConsoleInputA
WriteConsoleInputVDMA
WriteConsoleOutputA
WriteConsoleOutputAttribute
WriteConsoleOutputCharacterA
WriteFile
WriteFileEx
WriteFileGather
WriteFileVlm
WriteFmtUserTypeStg
WriteHWL
WriteHitLogging
WriteInt
WriteOleStg
WritePrinter
WritePrivateProfileSectionA
WritePrivateProfileStringA
WritePrivateProfileStructA
WriteProcessMemory
WriteProcessMemoryVlm
WriteProfileSectionA
WriteProfileStringA
WriteRaw
WriteStringStream
WriteTapemark
XRegThunkEntry
_TrackMouseEvent
__CPPValidateParameters
__ValidateParameters
__WSAFDIsSet
_hread
_hwrite
_lclose
_lcreat
_llseek
_lopen
_lread
_lwrite
accept
acmDriverAddA
acmDriverClose
acmDriverDetailsA
acmDriverEnum
acmDriverID
acmDriverMessage
acmDriverOpen
acmDriverPriority
acmDriverRemove
acmFilterChooseA
acmFilterDetailsA
acmFilterEnumA
acmFilterTagDetailsA
acmFilterTagEnumA
acmFormatChooseA
acmFormatDetailsA
acmFormatEnumA
acmFormatSuggest
acmFormatTagDetailsA
acmFormatTagEnumA
acmGetVersion
acmMessage32
acmMetrics
acmStreamClose
acmStreamConvert
acmStreamMessage
acmStreamOpen
acmStreamPrepareHeader
acmStreamReset
acmStreamSize
acmStreamUnprepareHeader
add3
atoui
aux32Message
auxCloseWindow
auxCreateFont
auxDIBImageLoadA
auxDrawStrA
auxExposeFunc
auxGetColorMapSize
auxGetDevCapsA
auxGetDisplayMode
auxGetDisplayModeID
auxGetDisplayModePolicy
auxGetHDC
auxGetHGLRC
auxGetHWND
auxGetMouseLoc
auxGetNumDevs
auxGetVolume
auxIdleFunc
auxInitDisplayMode
auxInitDisplayModeID
auxInitDisplayModePolicy
auxInitPosition
auxInitWindowA
auxKeyFunc
auxMainLoop
auxMouseFunc
auxOutMessage
auxQuit
auxRGBImageLoadA
auxReshapeFunc
auxSetFogRamp
auxSetGreyRamp
auxSetOneColor
auxSetRGBMap
auxSetVolume
auxSolidBox
auxSolidCone
auxSolidCube
auxSolidCylinder
auxSolidDodecahedron
auxSolidIcosahedron
auxSolidOctahedron
auxSolidSphere
auxSolidTeapot
auxSolidTetrahedron
auxSolidTorus
auxSwapBuffers
auxWireBox
auxWireCone
auxWireCube
auxWireCylinder
auxWireDodecahedron
auxWireIcosahedron
auxWireOctahedron
auxWireSphere
auxWireTeapot
auxWireTetrahedron
auxWireTorus
bind
capCreateCaptureWindowA
capGetDriverDescriptionA
char_array_from_ndr
char_from_ndr
closesocket
compareParams
connect
copy3
copymat3
crossprod
data_from_ndr
data_into_ndr
data_size_ndr
diff3
dist3
dn_expand
doCabinetInfoNotify
dodecahedron
dot3
double_array_from_ndr
double_from_ndr
doughnut
drawbox
drawtriangle
dwLBSubclass
dwOKSubclass
enum_from_ndr
error
findList
float_array_from_ndr
float_from_ndr
gdiPlaySpoolStream
gethostbyaddr
gethostbyname
gethostname
getmsg
getnetbyname
getpeername
getprotobyname
getprotobynumber
getservbyname
getservbyport
getsockname
getsockopt
glAccum
glAlphaFunc
glAreTexturesResident
glArrayElement
glBegin
glBindTexture
glBitmap
glBlendFunc
glCallList
glCallLists
glClear
glClearAccum
glClearColor
glClearDepth
glClearIndex
glClearStencil
glClipPlane
glColor3b
glColor3bv
glColor3d
glColor3dv
glColor3f
glColor3fv
glColor3i
glColor3iv
glColor3s
glColor3sv
glColor3ub
glColor3ubv
glColor3ui
glColor3uiv
glColor3us
glColor3usv
glColor4b
glColor4bv
glColor4d
glColor4dv
glColor4f
glColor4fv
glColor4i
glColor4iv
glColor4s
glColor4sv
glColor4ub
glColor4ubv
glColor4ui
glColor4uiv
glColor4us
glColor4usv
glColorMask
glColorMaterial
glColorPointer
glCopyPixels
glCopyTexImage1D
glCopyTexImage2D
glCopyTexSubImage1D
glCopyTexSubImage2D
glCullFace
glDebugEntry
glDeleteLists
glDeleteTextures
glDepthFunc
glDepthMask
glDepthRange
glDisable
glDisableClientState
glDrawArrays
glDrawBuffer
glDrawElements
glDrawPixels
glEdgeFlag
glEdgeFlagPointer
glEdgeFlagv
glEnable
glEnableClientState
glEnd
glEndList
glEvalCoord1d
glEvalCoord1dv
glEvalCoord1f
glEvalCoord1fv
glEvalCoord2d
glEvalCoord2dv
glEvalCoord2f
glEvalCoord2fv
glEvalMesh1
glEvalMesh2
glEvalPoint1
glEvalPoint2
glFeedbackBuffer
glFinish
glFlush
glFogf
glFogfv
glFogi
glFogiv
glFrontFace
glFrustum
glGenLists
glGenTextures
glGetBooleanv
glGetClipPlane
glGetDoublev
glGetError
glGetFloatv
glGetIntegerv
glGetLightfv
glGetLightiv
glGetMapdv
glGetMapfv
glGetMapiv
glGetMaterialfv
glGetMaterialiv
glGetPixelMapfv
glGetPixelMapuiv
glGetPixelMapusv
glGetPointerv
glGetPolygonStipple
glGetString
glGetTexEnvfv
glGetTexEnviv
glGetTexGendv
glGetTexGenfv
glGetTexGeniv
glGetTexImage
glGetTexLevelParameterfv
glGetTexLevelParameteriv
glGetTexParameterfv
glGetTexParameteriv
glHint
glIndexMask
glIndexPointer
glIndexd
glIndexdv
glIndexf
glIndexfv
glIndexi
glIndexiv
glIndexs
glIndexsv
glIndexub
glIndexubv
glInitNames
glInterleavedArrays
glIsEnabled
glIsList
glIsTexture
glLightModelf
glLightModelfv
glLightModeli
glLightModeliv
glLightf
glLightfv
glLighti
glLightiv
glLineStipple
glLineWidth
glListBase
glLoadIdentity
glLoadMatrixd
glLoadMatrixf
glLoadName
glLogicOp
glMap1d
glMap1f
glMap2d
glMap2f
glMapGrid1d
glMapGrid1f
glMapGrid2d
glMapGrid2f
glMaterialf
glMaterialfv
glMateriali
glMaterialiv
glMatrixMode
glMultMatrixd
glMultMatrixf
glNewList
glNormal3b
glNormal3bv
glNormal3d
glNormal3dv
glNormal3f
glNormal3fv
glNormal3i
glNormal3iv
glNormal3s
glNormal3sv
glNormalPointer
glOrtho
glPassThrough
glPixelMapfv
glPixelMapuiv
glPixelMapusv
glPixelStoref
glPixelStorei
glPixelTransferf
glPixelTransferi
glPixelZoom
glPointSize
glPolygonMode
glPolygonOffset
glPolygonStipple
glPopAttrib
glPopClientAttrib
glPopMatrix
glPopName
glPrioritizeTextures
glPushAttrib
glPushClientAttrib
glPushMatrix
glPushName
glRasterPos2d
glRasterPos2dv
glRasterPos2f
glRasterPos2fv
glRasterPos2i
glRasterPos2iv
glRasterPos2s
glRasterPos2sv
glRasterPos3d
glRasterPos3dv
glRasterPos3f
glRasterPos3fv
glRasterPos3i
glRasterPos3iv
glRasterPos3s
glRasterPos3sv
glRasterPos4d
glRasterPos4dv
glRasterPos4f
glRasterPos4fv
glRasterPos4i
glRasterPos4iv
glRasterPos4s
glRasterPos4sv
glReadBuffer
glReadPixels
glRectd
glRectdv
glRectf
glRectfv
glRecti
glRectiv
glRects
glRectsv
glRenderMode
glRotated
glRotatef
glScaled
glScalef
glScissor
glSelectBuffer
glShadeModel
glStencilFunc
glStencilMask
glStencilOp
glTexCoord1d
glTexCoord1dv
glTexCoord1f
glTexCoord1fv
glTexCoord1i
glTexCoord1iv
glTexCoord1s
glTexCoord1sv
glTexCoord2d
glTexCoord2dv
glTexCoord2f
glTexCoord2fv
glTexCoord2i
glTexCoord2iv
glTexCoord2s
glTexCoord2sv
glTexCoord3d
glTexCoord3dv
glTexCoord3f
glTexCoord3fv
glTexCoord3i
glTexCoord3iv
glTexCoord3s
glTexCoord3sv
glTexCoord4d
glTexCoord4dv
glTexCoord4f
glTexCoord4fv
glTexCoord4i
glTexCoord4iv
glTexCoord4s
glTexCoord4sv
glTexCoordPointer
glTexEnvf
glTexEnvfv
glTexEnvi
glTexEnviv
glTexGend
glTexGendv
glTexGenf
glTexGenfv
glTexGeni
glTexGeniv
glTexImage1D
glTexImage2D
glTexParameterf
glTexParameterfv
glTexParameteri
glTexParameteriv
glTexSubImage1D
glTexSubImage2D
glTranslated
glTranslatef
glVertex2d
glVertex2dv
glVertex2f
glVertex2fv
glVertex2i
glVertex2iv
glVertex2s
glVertex2sv
glVertex3d
glVertex3dv
glVertex3f
glVertex3fv
glVertex3i
glVertex3iv
glVertex3s
glVertex3sv
glVertex4d
glVertex4dv
glVertex4f
glVertex4fv
glVertex4i
glVertex4iv
glVertex4s
glVertex4sv
glVertexPointer
glViewport
gluBeginCurve
gluBeginPolygon
gluBeginSurface
gluBeginTrim
gluBuild1DMipmaps
gluBuild2DMipmaps
gluCylinder
gluDeleteNurbsRenderer
gluDeleteQuadric
gluDeleteTess
gluDisk
gluEndCurve
gluEndPolygon
gluEndSurface
gluEndTrim
gluErrorString
gluErrorUnicodeStringEXT
gluGetNurbsProperty
gluGetString
gluGetTessProperty
gluLoadSamplingMatrices
gluLookAt
gluNewNurbsRenderer
gluNewQuadric
gluNewTess
gluNextContour
gluNurbsCallback
gluNurbsCurve
gluNurbsProperty
gluNurbsSurface
gluOrtho2D
gluPartialDisk
gluPerspective
gluPickMatrix
gluProject
gluPwlCurve
gluQuadricCallback
gluQuadricDrawStyle
gluQuadricNormals
gluQuadricOrientation
gluQuadricTexture
gluScaleImage
gluSphere
gluTessBeginContour
gluTessBeginPolygon
gluTessCallback
gluTessEndContour
gluTessEndPolygon
gluTessNormal
gluTessProperty
gluTessVertex
gluUnProject
htonl
htons
icosahedron
identifymat3
inet_addr
inet_network
inet_ntoa
initdodec
ioctlsocket
joy32Message
joyConfigChanged
joyGetDevCapsA
joyGetNumDevs
joyGetPos
joyGetPosEx
joyGetThreshold
joyReleaseCapture
joySetCapture
joySetThreshold
keybd_event
length3
lineAccept
lineAddProviderA
lineAddToConference
lineAgentSpecific
lineAnswer
lineBlindTransferA
lineClose
lineCompleteCall
lineCompleteTransfer
lineConfigDialogA
lineConfigDialogEditA
lineConfigProvider
lineDeallocateCall
lineDevSpecific
lineDevSpecificFeature
lineDialA
lineDrop
lineForwardA
lineGatherDigitsA
lineGenerateDigitsA
lineGenerateTone
lineGetAddressCapsA
lineGetAddressIDA
lineGetAddressStatusA
lineGetAgentActivityListA
lineGetAgentCapsA
lineGetAgentGroupListA
lineGetAgentStatusA
lineGetAppPriorityA
lineGetCallInfoA
lineGetCallStatus
lineGetConfRelatedCalls
lineGetCountryA
lineGetDevCapsA
lineGetDevConfigA
lineGetIDA
lineGetIconA
lineGetLineDevStatusA
lineGetMessage
lineGetNewCalls
lineGetNumRings
lineGetProviderListA
lineGetRequestA
lineGetStatusMessages
lineGetTranslateCapsA
lineHandoffA
lineHold
lineInitialize
lineInitializeExA
lineMakeCallA
lineMonitorDigits
lineMonitorMedia
lineMonitorTones
lineNegotiateAPIVersion
lineNegotiateExtVersion
lineOpenA
lineParkA
linePickupA
linePrepareAddToConferenceA
lineProxyMessage
lineProxyResponse
lineRedirectA
lineRegisterRequestRecipient
lineReleaseUserUserInfo
lineRemoveFromConference
lineRemoveProvider
lineSecureCall
lineSendUserUserInfo
lineSetAgentActivity
lineSetAgentGroup
lineSetAgentState
lineSetAppPriorityA
lineSetAppSpecific
lineSetCallData
lineSetCallParams
lineSetCallPrivilege
lineSetCallQualityOfService
lineSetCallTreatment
lineSetCurrentLocation
lineSetDevConfigA
lineSetLineDevStatus
lineSetMediaControl
lineSetMediaMode
lineSetNumRings
lineSetStatusMessages
lineSetTerminal
lineSetTollListA
lineSetupConferenceA
lineSetupTransferA
lineShutdown
lineSwapHold
lineTranslateAddressA
lineTranslateDialogA
lineUncompleteCall
lineUnhold
lineUnparkA
listen
long_array_from_ndr
long_from_ndr
long_from_ndr_temp
lstrcatA
lstrcmpA
lstrcmpiA
lstrcpyA
lstrcpynA
lstrlenA
m_popmatrix
m_pushmatrix
m_scale
m_translate
m_xformpt
m_xformptonly
makeModelPtr
mci32Message
mciDriverNotify
mciDriverYield
mciExecute
mciFreeCommandResource
mciGetCreatorTask
mciGetDeviceIDA
mciGetDeviceIDFromElementIDA
mciGetDriverData
mciGetErrorStringA
mciGetYieldProc
mciLoadCommandResource
mciSendCommandA
mciSendStringA
mciSetDriverData
mciSetYieldProc
memmoveInternal
mid32Message
midiConnect
midiDisconnect
midiInAddBuffer
midiInClose
midiInGetDevCapsA
midiInGetErrorTextA
midiInGetID
midiInGetNumDevs
midiInMessage
midiInOpen
midiInPrepareHeader
midiInReset
midiInStart
midiInStop
midiInUnprepareHeader
midiOutCacheDrumPatches
midiOutCachePatches
midiOutClose
midiOutGetDevCapsA
midiOutGetErrorTextA
midiOutGetID
midiOutGetNumDevs
midiOutGetVolume
midiOutLongMsg
midiOutMessage
midiOutOpen
midiOutPrepareHeader
midiOutReset
midiOutSetVolume
midiOutShortMsg
midiOutUnprepareHeader
midiStreamClose
midiStreamOpen
midiStreamOut
midiStreamPause
midiStreamPosition
midiStreamProperty
midiStreamRestart
midiStreamStop
midl_allocate
mixerClose
mixerGetControlDetailsA
mixerGetDevCapsA
mixerGetID
mixerGetLineControlsA
mixerGetLineInfoA
mixerGetNumDevs
mixerMessage
mixerOpen
mixerSetControlDetails
mmDrvInstall
mmGetCurrentTask
mmTaskBlock
mmTaskCreate
mmTaskSignal
mmTaskYield
mmioAdvance
mmioAscend
mmioClose
mmioCreateChunk
mmioDescend
mmioFlush
mmioGetInfo
mmioInstallIOProcA
mmioOpenA
mmioRead
mmioRenameA
mmioSeek
mmioSendMessage
mmioSetBuffer
mmioSetInfo
mmioStringToFOURCCA
mmioWrite
mmsystemGetVersion
mod32Message
mouse_event
mxd32Message
normalize
ntohl
ntohs
octahedron
pSetupDiGetDeviceInfoContext
pSetupDiSetDeviceInfoContext
pSetupDirectoryIdToPath
pSetupGetField
pSetupGetOsLoaderDriveAndPath
pSetupGetVersionDatum
pSetupGuidFromString
pSetupIsGuidNull
pSetupMakeSurePathExists
pSetupSetSystemSourcePath
pSetupStringFromGuid
pentagon
perpnorm
phoneClose
phoneConfigDialogA
phoneDevSpecific
phoneGetButtonInfoA
phoneGetData
phoneGetDevCapsA
phoneGetDisplay
phoneGetGain
phoneGetHookSwitch
phoneGetIDA
phoneGetIconA
phoneGetLamp
phoneGetMessage
phoneGetRing
phoneGetStatusA
phoneGetStatusMessages
phoneGetVolume
phoneInitialize
phoneInitializeExA
phoneNegotiateAPIVersion
phoneNegotiateExtVersion
phoneOpen
phoneSetButtonInfoA
phoneSetData
phoneSetDisplay
phoneSetGain
phoneSetHookSwitch
phoneSetLamp
phoneSetRing
phoneSetStatusMessages
phoneSetVolume
phoneShutdown
poll
putmsg
rcmd
recorditem
recv
recvfrom
rexec
rresvport
s_ioctl
s_open
s_perror
samepoint
scalarmult
select
send
sendto
serverTrapThread
seterrorfunc
sethostname
setsockopt
short_array_from_ndr
short_from_ndr
short_from_ndr_temp
shutdown
sndPlaySoundA
socket
solidTeapot
sqlite3_aggregate_context
sqlite3_aggregate_count
sqlite3_bind_blob
sqlite3_bind_double
sqlite3_bind_int
sqlite3_bind_int64
sqlite3_bind_null
sqlite3_bind_text
sqlite3_bind_text16
sqlite3_busy_handler
sqlite3_busy_timeout
sqlite3_close
sqlite3_column_blob
sqlite3_column_bytes
sqlite3_column_bytes16
sqlite3_column_count
sqlite3_column_decltype
sqlite3_column_decltype16
sqlite3_column_double
sqlite3_column_int
sqlite3_column_int64
sqlite3_column_name
sqlite3_column_name16
sqlite3_column_text
sqlite3_column_text16
sqlite3_column_type
sqlite3_complete
sqlite3_complete16
sqlite3_create_function
sqlite3_create_function16
sqlite3_errcode
sqlite3_errmsg
sqlite3_errmsg16
sqlite3_finalize
sqlite3_free
sqlite3_interrupt
sqlite3_last_insert_rowid
sqlite3_mprintf
sqlite3_open
sqlite3_open16
sqlite3_prepare
sqlite3_prepare16
sqlite3_reset
sqlite3_result_blob
sqlite3_result_double
sqlite3_result_error
sqlite3_result_error16
sqlite3_result_int
sqlite3_result_int64
sqlite3_result_null
sqlite3_result_text
sqlite3_result_text16
sqlite3_result_value
sqlite3_set_authorizer
sqlite3_step
sqlite3_user_data
sqlite3_value_blob
sqlite3_value_bytes
sqlite3_value_bytes16
sqlite3_value_double
sqlite3_value_int
sqlite3_value_int64
sqlite3_value_text
sqlite3_value_text16
sqlite3_value_type
sqlite3_vmprintf
subdivide
tapiGetLocationInfoA
tapiPlaySound
tapiRequestDrop
tapiRequestMakeCallA
tapiRequestMediaCallA
tetrahedron
tid32Message
timeBeginPeriod
timeEndPeriod
timeGetDevCaps
timeGetSystemTime
timeGetTime
timeKillEvent
timeSetEvent
tkCloseWindow
tkCreateBitmapFont
tkCreateFilledFont
tkCreateOutlineFont
tkCreateStrokeFont
tkDIBImageLoad
tkDisplayFunc
tkDrawStr
tkErrorPopups
tkExec
tkExposeFunc
tkGetColorMapSize
tkGetDisplayMode
tkGetDisplayModeID
tkGetDisplayModePolicy
tkGetHDC
tkGetHRC
tkGetHWND
tkGetMouseLoc
tkIdleFunc
tkInitDisplayMode
tkInitDisplayModeID
tkInitDisplayModePolicy
tkInitPosition
tkInitWindow
tkKeyDownFunc
tkMouseDownFunc
tkMouseMoveFunc
tkMouseUpFunc
tkQuit
tkRGBImageLoad
tkReshapeFunc
tkSetFogRamp
tkSetGreyRamp
tkSetOneColor
tkSetRGBMap
tkSwapBuffers
tkWndProc
tree_into_ndr
tree_peek_ndr
tree_size_ndr
videoThunk32
waveInAddBuffer
waveInClose
waveInGetDevCapsA
waveInGetErrorTextA
waveInGetID
waveInGetNumDevs
waveInGetPosition
waveInMessage
waveInOpen
waveInPrepareHeader
waveInReset
waveInStart
waveInStop
waveInUnprepareHeader
waveOutBreakLoop
waveOutClose
waveOutGetDevCapsA
waveOutGetErrorTextA
waveOutGetID
waveOutGetNumDevs
waveOutGetPitch
waveOutGetPlaybackRate
waveOutGetPosition
waveOutGetVolume
waveOutMessage
waveOutOpen
waveOutPause
waveOutPrepareHeader
waveOutReset
waveOutRestart
waveOutSetPitch
waveOutSetPlaybackRate
waveOutSetVolume
waveOutUnprepareHeader
waveOutWrite
wglChoosePixelFormat
wglCopyContext
wglCreateContext
wglCreateLayerContext
wglDeleteContext
wglDescribeLayerPlane
wglDescribePixelFormat
wglGetCurrentContext
wglGetCurrentDC
wglGetDefaultProcAddress
wglGetLayerPaletteEntries
wglGetPixelFormat
wglGetProcAddress
wglMakeCurrent
wglRealizeLayerPalette
wglSetLayerPaletteEntries
wglSetPixelFormat
wglShareLists
wglSwapBuffers
wglSwapLayerBuffers
wglSwapMultipleBuffers
wglUseFontBitmapsA
wglUseFontOutlinesA
wid32Message
winmmSetDebugLevel
wireTeapot
wod32Message
wvsprintfA
xformvec3
", EndOfFunctionsList: 0]
____________________________________________________________________________________________
____________________________________________________________________________________________

[OneApiInfo: ? #2000] [ApiComment: 0    ApiCommentMax: 0]
[NotYetApiInfo: "
 Not yet. Under developement.
 
 Only the usual Functions are available, actually.", 0]

; In: edx = start of possible Api call (DLL or Function)

WinApiFirstPass:
    dec edx | mov esi edx

    While B$esi-1 <> '.'
        inc esi
        If B$esi = "'"
            ret
        Else_If B$esi = '"'
            ret
        End_If
    End_While

    mov edi Win32Functions, ecx 0

    .While edi < EndOfFunctionsList
        mov al B$esi+ecx

        ..If al > B$edi+ecx
            While B$edi <> LF | inc edi | End_While | inc edi | mov ecx 0

        ..Else_If al < B$edi+ecx
            ret

        ..Else
            inc ecx
            .If B$edi+ecx = CR
              ; Name in List shorter than Source one:
                add edi ecx | add edi 2 | mov ecx 0
            .Else
                If B$esi+ecx+1 = '"'
                    call SearchInFunctionsFile
                    VirtualFree D$Win32ApiList
                Else_If B$esi+ecx+1 = "'"
                    call SearchInFunctionsFile
                    VirtualFree D$Win32ApiList
                End_If
            .End_If

        ..End_If
    .End_While
ret


SearchInFunctionsFile:
    mov edx esi | call OpenApiFunctionsFile | On B$ApiFileOK = &FALSE, ret

DirectSearchInFunctionsFile:
    mov edi D$Win32ApiList

L1: mov esi edx, ecx D$ApiFileSize | sub ecx edi | add ecx D$Win32ApiList

    mov al '.' | repne scasb
    repe cmpsb
    ...If B$esi-1 = "'"
L2:     ..If B$edi-1 = '('
            sub edi 2
            While B$edi <> CR
               dec edi
            End_While
            mov esi edi, edi OneApiInfo, ecx 800
            movsw
            mov eax 'call' | stosd |  mov ax " '" | stosw
L5:         lodsb
            .If al = '('
                mov al "'" | stosb
                If B$esi <> CR
                    mov al 0 | stosb | jmp L8>>
                End_If
                mov al ','
            .End_If
            stosb | cmp al LF | jne L5<

          ; Compute the Max Pos of Comments, for aligned presentation:
            push esi
                mov D$ApiComment 0, D$ApiCommentMax 0
                While B$esi <> ')'
                    lodsb | inc D$ApiComment
                    If al = ';'
                        mov eax D$ApiCommentMax
                        On D$ApiComment > eax, move D$ApiCommentMax D$ApiComment
                    Else_If al = LF
                        mov D$ApiComment 0
                    End_If
                End_While
            pop esi

            mov eax '    ' | stosd | mov D$ApiComment 0 | add D$ApiCommentMax 8
L5:         lodsb | stosb | inc D$ApiComment
            If al = LF
                mov eax '    ' | stosd | mov D$ApiComment 0
            Else_If al = ';'
                dec edi
                mov ecx D$ApiCommentMax | sub ecx D$ApiComment
                mov al ' ' | rep stosb
                mov al ';' | stosb
            End_If
            cmp al ')' | jne L5<
            mov B$edi 0, B$edi-1 ' '
L8:         call 'USER32.DialogBoxParamA' D$hInstance 1000  &NULL ShowApiInfo &NULL
            ret
        ..End_If
    ...Else_If B$esi-1 = '"'
        jmp L2<<
    ...Else_If B$esi-1 = 'A'
L3:     On B$esi = "'", jmp L2<<
        On B$esi = '"', jmp L2<<
    ...Else_If B$esi-1 = 'W'
        jmp L3<
    ...End_If
    mov al ')' | repne scasb | cmp B$edi 0 | je L9>
    add esi 2                                          ; +2 for CR/LF
        jmp L1<<
L9:ret


[ApiFileSize: ?    ApiFileHandle: ?    ApiFileOK: ?]

OpenApiFunctionsFile:  ; Like 'OpenStructureFile'
    pushad
        mov esi EquatesName, edi IncludeFileName
        While B$esi <> 0 | movsb | End_While
        dec edi
        While B$edi <> '.' | dec edi | End_While

L0:     dec edi | cmp B$edi '\' | je L1>
                  cmp B$edi ':' | je L1>
                  cmp edi IncludeFileName | ja L0<
                    jmp L2>
L1:     inc edi
L2:     mov D$edi 'Func', D$edi+4 'tion', D$edi+8 's.ap', B$edi+12 'i', B$edi+13 0

        call 'KERNEL32.CreateFileA' IncludeFileName &GENERIC_READ, &FILE_SHARE_READ, 0,
                                    &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0

        .If eax = &INVALID_HANDLE_VALUE
            call Help B_U_AsmName, IncludeFilesHelp, RosAsmHlpMessage

            mov B$ApiFileOK &FALSE

        .Else
            mov D$ApiFileHandle eax

            call 'KERNEL32.GetFileSize' eax 0 | mov D$ApiFileSize eax
            VirtualAlloc Win32ApiList eax

            mov D$NumberOfReadBytes 0
            call 'KERNEL32.ReadFile' D$ApiFileHandle, D$Win32ApiList,
                                     D$ApiFileSize, NumberOfReadBytes, 0
            mov B$ApiFileOK &TRUE

            call 'KERNEL32.CloseHandle' D$ApiFileHandle
        .End_If
    popad
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

ViewApiList:
    call OpenApiFunctionsFile

    If B$ApiFileOK = &TRUE
        call 'USER32.DialogBoxParamA' D$hInstance, 30_000, &NULL, ApiChoice, &NULL
    End_If
ret


[ShowApiDialogHandle: ?]

Proc ApiChoice:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    .If D@Message = &WM_COMMAND
         If D@wParam = &IDCANCEL
            mov D$ShowApiDialogHandle 0
            VirtualFree D$Win32ApiList
            call 'User32.EndDialog' D@Adressee, 0
         End_If

         shr D@wParam 16

         On D@wParam = &CBN_SELCHANGE, call ViewOneApiInfos

    .Else_If D@Message = &WM_INITDIALOG
        move D$ShowApiDialogHandle D@Adressee
        call 'USER32.SetClassLongA' D@Adressee, &GCL_HICON, D$wc_hIcon

        call InitApiList

    .Else_If D@Message = &WM_CTLCOLOREDIT
        If B$FirstCTLCOLOREDIT = &TRUE
            call 'USER32.SendMessageA' D@lParam, &EM_SETSEL, 0, 0
            mov B$FirstCTLCOLOREDIT &FALSE
        End_If
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    .Else
        popad | mov eax &FALSE | jmp L9>

    .End_If

    popad | mov eax &TRUE

L9: EndP



InitApiList:
    mov esi Win32Functions

    .While esi < EndOfFunctionsList
        mov eax esi
        While B$eax <> CR | inc eax | End_While | mov B$eax 0

        push esi, eax
            call 'USER32.SendDlgItemMessageA' D$ShowApiDialogHandle, 10, &CB_ADDSTRING, 0, esi
        pop eax, esi

        mov B$eax CR | add eax 2 | mov esi eax
    .End_While
ret


[ApiItem: ? #10]

ViewOneApiInfos:
    call 'USER32.SendDlgItemMessageA' D$ShowApiDialogHandle 10 &CB_GETCURSEL  0 0
    call 'USER32.SendDlgItemMessageA' D$ShowApiDialogHandle 10 &CB_GETLBTEXT eax ApiItem
    mov edx ApiItem
    mov edi D$Win32ApiList

L1: mov esi ApiItem, ecx D$ApiFileSize | sub ecx edi | add ecx D$Win32ApiList
    On ecx = 0, jmp L9>> ;ret

    mov al '.' | repne scasb | On ecx = 0, ret

    repe cmpsb
    ...If ecx = 0
        ret
    ...Else_If B$esi-1 = 0
L2:     ..If B$edi-1 = '('
            sub edi 2
            While B$edi <> CR
               dec edi
            End_While
            mov esi edi, edi OneApiInfo, ecx 800
            movsw
            mov eax 'call' | stosd |  mov ax " '" | stosw
L5:         lodsb
            .If al = '('
                mov al "'" | stosb
                If B$esi <> CR
                    mov al 0 | stosb | jmp L8>>
                End_If
                mov al ','
            .End_If
            stosb | cmp al LF | jne L5<

; Compute the Max Pos of Comments, for aligned presentation:
            push esi
                mov D$ApiComment 0, D$ApiCommentMax 0
                While B$esi <> ')'
                    lodsb | inc D$ApiComment
                    If al = ';'
                        mov eax D$ApiCommentMax
                        On D$ApiComment > eax, move D$ApiCommentMax D$ApiComment
                    Else_If al = LF
                        mov D$ApiComment 0
                    End_If
                End_While
            pop esi

            mov eax '    ' | stosd | mov D$ApiComment 0 | add D$ApiCommentMax 8
L5:         lodsb | stosb | inc D$ApiComment
            If al = LF
                mov eax '    ' | stosd | mov D$ApiComment 0
            Else_If al = ';'
                dec edi
                mov ecx D$ApiCommentMax | sub ecx D$ApiComment
                mov al ' ' | rep stosb
                mov al ';' | stosb
            End_If
            cmp al ')' | jne L5<
            mov B$edi 0, B$edi-1 ' '
L8:         call 'USER32.SendDlgItemMessageA' D$ShowApiDialogHandle, 11, &WM_SETTEXT,
                                              0, OneApiInfo
            ret
        ..End_If

    ...Else_If B$esi-1 = 'A'
L3:     On B$esi = 0, jmp L2<<

    ...Else_If B$esi-1 = 'W'
        jmp L3<
    ...End_If
    mov al ')' | repne scasb | On B$edi = 0, jmp L9>
    On ecx = 0, jmp L9> ;ret
    add edi 2 | jmp L1<<                                       ; +2 for CR/LF

L9: call 'USER32.SendDlgItemMessageA' D$ShowApiDialogHandle, 11, &WM_SETTEXT,
                                      0, NotYetApiInfo
ret



TITLE MainProc

 ______________________________________________________________________________________
 ______________________________________________________________________________________

; Equates given by the Menu Editor:

; Tag Menu 1000

[M00_Menu  1000                  M00_Open  1001                  M00_New  1002
 M00_New_Model  1003             M00_Paste_at_Pos  1004          M00_Change_Compile_Name  1005
 M00_Open_Source_Only  1006      M00_Replace_Source_Only  1007   M00_Save_Source_Only  1008
 M00_Print  1009                 M00_Output  1010                M00_Exit  1011
 M00_Tree  1012                  M00_Import  1013                M00_Export  1014
 M00_Find  1015                  M00_Replace  1016               M00_Undo  1017
 M00_Redo  1018                  M00_Copy  1019                  M00_Paste  1020
 M00_Delete  1021                M00_Cut  1022                   M00_Compile  1023
 M00_Run  1024                   M00_Optimize_Jumps_Sizes  1025  M00_Calc  1026
 M00_Ascii_Table  1027           M00_Show_RosAsm_Mems  1028      M00_Show_Symbols_Repartition  1029
 M00_Local_mem_Tests  1030       M00_Serial_Compilations  1031   M00_Data_to_Equates  1032
 M00_Encoding  1033              M00_DLLs_Scanner  1034          M00_Libs_Scanner  1035
 M00_Configuration  1036         M00_Create_Config_bin  1037     M00_Main_Icon  1038
 M00_Load_Icon  1039             M00_Delete_Icon  1040           M00_Icon_IDs  1041
 M00_Save_Icon  1042             M00_Load_BitMap  1043           M00_Delete_BitMap  1044
 M00_BitMaps_IDs  1045           M00_Save_BitMap  1046           M00_Load_Cursor  1047
 M00_Delete_Cursor  1048         M00_Cursors_IDs  1049           M00_Save_Cursor  1050
 M00_Load_Wave  1051             M00_Delete_Wave  1052           M00_Waves_IDs  1053
 M00_Save_Wave  1054             M00_Load_Avi  1055              M00_Delete_Avi  1056
 M00_Avi_IDs  1057               M00_Save_Avi  1058              M00_Load_RC  1059
 M00_Delete_RC  1060             M00_RCs_IDs  1061               M00_Save_RC  1062
 M00_New_Dialog  1063            M00_Load_from_Resources  1064   M00_Load_from_ClipBoard  1065
 M00_Load_from_File  1066        M00_Save_to_Binary_File  1067   M00_Load_from_Binary_File  1068
 M00_Replace_from_Binary_File  1069                              M00_Delete_Resources_Dialog  1070
 M00_Strings  1071               M00_New_Menu  1072              M00_Existing_Menu  1073
 M00_Delete_a_Menu  1074         M00_Save_to_Binary_Menu_File  1075
 M00_Load_Binary_Menu_File  1076 M00_Replace_from_Binary_Menu_File  1077
 M00_Clip_File  1078             M00_Structures  1079            M00_Api_Functions  1080
 M00_Sys_Resources  1081         M00_GUIDs  1082                 M00_Win32_Equates  1083
 M00_Win32_Data_Types  1084      M00_Wizards  1085               M00_B_U_Asm  1086
 M00_Sources_Editor  1087        M00_Visual_Tuts  1088           M00_Win32_hlp  1089
 M00_Mmedia_hlp  1090            M00_OpenGl_hlp  1091            M00_WinSock_hlp  1092
 M00_Dx_hlp  1093                M00_SDL  1094                   M00_sqlite  1095
 M00_DevIl  1096                 M00_About  1097                 M00_GPL_License  1098
 M00_RosAsm_License  1099        M00_<<<<  1100                  M00_>>>>  1101]

[M00_About_ToolBar 1200]
____________________________________________________________________________________________

[redrawFlag: 0, ReadyToRun: 0, ShowStats: &TRUE, UnusedSymbolsDialogWanted: &FALSE]

[NotReadyToRun L7>>    NoClient L8>>]

[CloseDebuggerOrIgnore
    If D$DebugDialogHandle <> 0
        call KillDebugger | On eax = &IDNO, jmp L9>>
    End_If]

; buffer for returned filename:
[lpszFile: B$ 0 #&MAXPATH]

; size of buffer for filename:
[cch: D$ &MAXPATH]

Proc MainWindowProc:
;;
    At the attention of all RosAsm contributors ---> 'Rules'
    
  'CreateTitleTab'
    
  'NewReplaceMacAndEqu', 'GetFileNameFromPath'
  
  'CheckMRUFile', 'RightClick', 'WheelMsg'
  'ShowUnfoldMacro', 'UnfoldMacro', 'ShowUnfoldDialog'
  'StructDialog'; 'NewFileNameDialog'
  'EncodeLines', 'StoreFlatData', 'UpdateTitlesFromIncludeFiles'
  
  'Main', 'AsmMain, 'checksum64' 'OutOnError'
  
  'ReplaceMacAndEqu'
  
  'KillTrailingSpaces', 'NewFileNameDialog', 'DataToStructureProc'
;;

    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    If D@Message = &WM_CREATE
        call 'SHELL32.DragAcceptFiles' D@Adressee, &TRUE | jmp L9>>

    Else_If D@Message = &WM_DROPFILES
        call 'SHELL32.DragQueryFile' D@wParam, 0, lpszFile, D$cch
        mov esi lpszFile, edi SaveFilter
        while B$esi <> 0 | movsb | End_While | movsb
        call DirectLoad
        call StartEdition
        call ReInitUndo
        call SetPartialEditionFromPos
        call EnableMenutems
        call LoadBookMarks
        call AskForRedraw
    End_If

    mov eax D@Adressee

    .If eax = D$hwnd
        ; OK
    .Else_If eax = D$EditWindowHandle
        mov eax D$wc_hCursor
        If D$ActualCursor <> eax
            mov D$ActualCursor eax
            call 'USER32.SetClassLongA' D$EditWindowHandle, &GCL_HCURSOR, eax
        End_If
    .Else_If eax = D$ScrollWindowHandle
        ; OK
    .Else_If eax = D$BpWindowHandle
        mov eax D$Bp_hCursor
        If D$ActualCursor <> eax
            mov D$ActualCursor eax
            call 'USER32.SetClassLongA' D$BpWindowHandle, &GCL_HCURSOR, eax
        End_If
    .Else
        jmp NoClient
    .End_If
  ; Yes, this may happend when [Run]ing. And this works because we do not hold anything
  ; at creation time.
 ____________________________________


; General purpose Callback:

    mov eax D@Message

    ...If eax = &WM_KEYDOWN
        .If B$SourceReady = &TRUE
            movzx eax B@Wparam | mov B$Keys+eax 1

            call KeyMessage ; CharMessage

            On B$BlinkingCaretWanted = &TRUE, call ResetBlinkCursor
            If B$KeyHasModifedSource = &TRUE

                mov B$SourceHasChanged &TRUE
                call AskForRedraw |
              jmp NotReadyToRun
           ; Else_If B$KeyHasMovedCaret = &TRUE
           ;     call AskForRedraw
            End_If

        .Else_If D@wParam = &VK_F1
            call RosAsmHelp

        .Else_If D@wParam = &VK_F2
            call F2Help

        .End_If

    ...Else_If eax = &WM_KEYUP
        movzx eax B@Wparam | mov B$Keys+eax 0
        On eax = &VK_MENU, mov B$keys+&VK_CONTROL &FALSE

    ...Else_If eax = &WM_CLOSE
        CloseDebuggerOrIgnore

        On B$OnDialogEdition = &TRUE, call CloseDialogEdition

        call Security | On eax = &IDCANCEL, jmp L9>>

        If B$SaveMainPosFlag = &TRUE
            call 'USER32.ShowWindow' D$hwnd, &SW_RESTORE
            call 'USER32.GetWindowRect' D$hwnd, WindowX
            mov eax D$WindowX | sub D$WindowW eax
            mov eax D$WindowY | sub D$WindowH eax
            call UpdateRegistry
        End_If

        On B$ToolBarChange = &TRUE, call SaveToolBar

        call LeftButtonUp                            ; ensure no confined mouse
        call CloseHelp

        On D$EditedDialogHandle <> 0, call 'User32.DestroyWindow' D$EditedDialogHandle
        On D$DialogEditorHandle <> 0 call 'User32.EndDialog' D$DialogEditorHandle

        call 'USER32.DestroyWindow' D$hwnd | jmp L9>> ; works too with 'jmp NoClient'

    ...Else_If eax = &WM_GETMINMAXINFO
        mov eax D@lParam
        mov D$eax+24 500, D$eax+28 300
        popad | mov eax &FALSE | ExitP

    ...Else_If eax = &WM_SIZE
        On D$TitleWindowHandle > 0, call KillTitleTab

        call MainResize

    ...Else_If eax = &WM_MOVING
        On D$TitleWindowHandle <> 0, call KillTitleTab

    ...Else_If eax = &WM_DESTROY
        On B$OnDialogEdition = &TRUE, call CloseDialogEdition
        call DeleteUndoFiles | call KillUndo
        call ReleaseResourceMemory
        call 'User32.PostQuitMessage' 0 | jmp L9>>

    ...Else_If D@Message = &WM_NOTIFY
        call KillCompletionList
      ; ebx > NMHDR // eax > hwndFrom.
        mov ebx D@lParam, eax D$ebx
      ; ToolBar Messages:
        .If D$ebx+TOOLTIPTEXT_NMHDR_code = &TTN_NEEDTEXT
            mov eax D$ebx+TOOLTIPTEXT_NMHDR_idfrom
          ; Pointing with esi to the Buttons List IDs:
            lea esi D$ToolBarButtons+4
            mov ecx 0
            While D$esi <> eax
                add esi 20 | inc ecx | On ecx > TOOLBUTTONS_NUMBER, ExitP
            End_While
            mov eax D$PointersToToolTipsStrings+ecx*4
            mov D$ebx+TOOLTIPTEXT_lpszText eax

        .Else_If D$ebx+TOOLTIPTEXT_NMHDR_code = &TBN_QUERYINSERT ; May be inserted ?
            popad | mov eax &TRUE | ExitP                   ; > yes for all.

        .Else_If D$ebx+TOOLTIPTEXT_NMHDR_code = &TBN_QUERYDELETE ; May be deleted?
                        popad | mov eax &TRUE | ExitP                   ; > yes for all.

        .Else_If D$ebx+TOOLTIPTEXT_NMHDR_code = &TBN_FIRST  ; = &TBN_GETBUTTONINFO (missing?)
            mov ecx D$ebx+TB_NOTIFY_Item, edx ecx
            If ecx a TOOLBUTTONS_NUMBER
                popad | mov eax &FALSE | ExitP
            End_If
            lea ecx D$ecx*4+ecx | shl ecx 2                 ; ecx = ecx * 20 >>>
            add ecx ToolBarButtons                          ; Pointer to whished Button Data
            move D$ebx+TB_NOTIFY_TBBUTTON_iBitmap D$ecx
            move D$ebx+TB_NOTIFY_TBBUTTON_idCommand  D$ecx+4
            move D$ebx+TB_NOTIFY_TBBUTTON_fsState D$ecx+8
            move D$ebx+TB_NOTIFY_TBBUTTON_dwData D$ecx+12
            move D$ebx+TB_NOTIFY_TBBUTTON_iString D$ecx+16
            mov edi D$ebx+TB_NOTIFY_TextPtr
            mov edx D$ebx+TB_NOTIFY_Item | shl edx 2        ; Displacement to pointers
            mov eax PointersToToolTipsStrings | add eax edx ; Pointer
            mov esi D$eax                                   ; Source
            mov ecx 0-1                                     ; Counter for Non-zero-ended text
            Do
                lodsb | stosb | inc ecx
            Loop_Until al = 0
            mov D$ebx+TB_NOTIFY_CharCount ecx               ; Lenght of String    (+36)
            popad | mov eax &TRUE | ExitP

        .Else_If D$ebx+TOOLTIPTEXT_NMHDR_code = &TBN_TOOLBARCHANGE
            mov B$ToolBarChange &TRUE                       ; For Saving at Exit if TRUE.

            ; Next instruction of no use usually, but, under some unknown circumstances
            ; the Buttons Size may be changed (Win98 without IE). So, as it can't hurt:
            call 'USER32.SendMessageA' D$ToolBarHandle, &TB_SETBUTTONSIZE, 0, 014_0014

        .Else_If D$ebx+TOOLTIPTEXT_NMHDR_code = &TBN_RESET
            call 'USER32.SendMessageA' D$ToolBarHandle, &TB_SAVERESTORE, &FALSE,
                                    TOOLBAR_REGISTRY        ; FALSE > restore

        .Else_If D$ebx+TOOLTIPTEXT_NMHDR_code = &TBN_CUSTHELP
            call 'USER32.MessageBoxA' D$hwnd, HelpToolBar, HelpToolBarTitle,
                                    &MB_OK__&MB_SYSTEMMODAL
        .End_If


 ____________________________________

; Main window CallBack: User choices open-file independant:

    ...Else_If eax = &WM_COMMAND
        call KillCompletionList

        mov eax D@wParam | and eax 0FFFF

        If B$IncludesOK = &FALSE
            call Configuration | call 'User32.SendMessageA' D$hwnd &WM_CLOSE 0 0
        End_If

        ..If eax = M00_Open
            CloseDebuggerOrIgnore

            call Security | On eax = &IDCANCEL, jmp L9>>

            call OpenRosAsmPE

            call UpdateTitlesFromIncludeFiles

            If D$SaveFilter <> 0
                call ReInitUndo
                call SetPartialEditionFromPos | call EnableMenutems
                call LoadBookMarks
            End_If

        ..Else_If eax = M00_Open_Source_Only
            CloseDebuggerOrIgnore

            call Security | On eax = &IDCANCEL, jmp L9>>

            call LooseResources
            .If B$KeepResources = &FALSE
                call ReInitUndo | call OpenSourceOnly
                call UpdateTitlesFromIncludeFiles
                If D$SourceLen > 0
                    call SetPartialEditionFromPos | call EnableMenutems
                    call LoadBookMarks
                End_If
            .End_If

        ..Else_If eax = M00_Exit
            call 'User32.SendMessageA' D$hwnd &WM_CLOSE 0 0

        ..Else_If eax = M00_Sources_Editor
            call Help, B_U_AsmName, SourceEditor, ContextHlpMessage

        ..Else_If eax = M00_Main_Icon
            CloseDebuggerOrIgnore
            call IconEdition | jmp NotReadyToRun

        ..Else_If eax = M00_New_Menu
            CloseDebuggerOrIgnore
            call NewMenu | mov D$ActualMenutestID 0 | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Existing_Menu
            CloseDebuggerOrIgnore
            call ExistingMenu | mov D$ActualMenutestID 0 | jmp NotReadyToRun

        ..Else_If eax = M00_Delete_a_Menu
            CloseDebuggerOrIgnore
            call DeleteMenu | mov D$ActualMenutestID 0 | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Save_to_Binary_Menu_File
            CloseDebuggerOrIgnore
            call SaveMenuBinaryFile

        ..Else_If eax = M00_Load_Binary_Menu_File
            CloseDebuggerOrIgnore
            call LoadMenuBinaryFile | jmp NotReadyToRun

        ..Else_If eax = M00_Replace_from_Binary_Menu_File
            CloseDebuggerOrIgnore
            call ReplaceMenuBinaryFile | jmp NotReadyToRun

        ..Else_If eax = M00_About | call AboutBox

        ..Else_If eax = M00_About_ToolBar | call About_ToolBar

        ..Else_If eax = M00_GPL_License | call GPLView

        ..Else_If eax = M00_RosAsm_License | call LicenseView

        ..Else_If eax = M00_B_U_Asm | call RosAsmHelp

        ..Else_If eax = M00_Configuration | call Configuration

        ..Else_If eax = M00_Create_Config_bin | call Create_Config_bin

        ..Else_If eax = M00_Api_Functions | call ViewApiList

        ..Else_If eax = M00_New
            CloseDebuggerOrIgnore
            call Security | On eax = &IDCANCEL, jmp L9>>
            call AutoNew
            call ChangeName
            call StartNewFile

        ..Else_If eax = M00_New_Model
            CloseDebuggerOrIgnore
            call Security | On eax = &IDCANCEL, jmp L9>>
            call NewFileNameDialog

        ..Else_If eax = M00_Change_Compile_Name | call ChangeName

        ..Else_If eax = M00_Calc | call Calc

        ..Else_If eax = M00_DLLs_Scanner | call ExportScanner

        ..Else_If eax = M00_Libs_Scanner | call LibScanner

        ..Else_If eax = M00_New_Dialog
            CloseDebuggerOrIgnore
            If B$OnDialogEdition = &FALSE
                mov B$SameIdAllowed &FALSE
                On B$BlinkingCaretWanted = &TRUE, call KillBlinkCursor
                    call InitDialogEdition | call ReleaseDialogMemories
                On B$BlinkingCaretWanted = &TRUE, call ResetBlinkCursor
                call EnableMenutems | jmp NotReadyToRun
            End_If

        ..Else_If eax = M00_Load_from_ClipBoard
            CloseDebuggerOrIgnore
            If B$OnDialogEdition = &FALSE
                mov B$SameIdAllowed &FALSE
                On B$BlinkingCaretWanted = &TRUE, call KillBlinkCursor
                    call ReleaseDialogMemories | call LoadDialogFromClipBoard
                On B$BlinkingCaretWanted = &TRUE, call ResetBlinkCursor
                call EnableMenutems | jmp NotReadyToRun
            End_If

        ..Else_If eax = M00_Load_from_File
            CloseDebuggerOrIgnore
            If B$OnDialogEdition = &FALSE
                mov B$SameIdAllowed &FALSE
                On B$BlinkingCaretWanted = &TRUE, call KillBlinkCursor
                    call ReleaseDialogMemories | call LoadDialogFromFile
                On B$BlinkingCaretWanted = &TRUE, call ResetBlinkCursor
                call EnableMenutems | jmp NotReadyToRun
            End_If

        ..Else_If eax = M00_Load_from_Resources
            CloseDebuggerOrIgnore
            If B$OnDialogEdition = &FALSE
                mov B$SameIdAllowed &TRUE
                On B$BlinkingCaretWanted = &TRUE, call KillBlinkCursor
                    call ReleaseDialogMemories | call LoadFromResources
                On B$BlinkingCaretWanted = &TRUE, call ResetBlinkCursor
                jmp NotReadyToRun
            End_If

        ..Else_If eax = M00_Save_to_Binary_File
            CloseDebuggerOrIgnore
            call SaveToBinaryFile

        ..Else_If eax = M00_Load_from_Binary_File
            CloseDebuggerOrIgnore
            mov B$SameIdAllowed &TRUE
            call LoadFromBinaryFile | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Replace_from_Binary_File
            CloseDebuggerOrIgnore
            call ReplaceFromBinaryFile | jmp NotReadyToRun

        ..Else_If eax = M00_Delete_Resources_Dialog
            CloseDebuggerOrIgnore
            On B$BlinkingCaretWanted = &TRUE, call KillBlinkCursor
                call DeleteDialog | call EnableMenutems
            On B$BlinkingCaretWanted = &TRUE, call ResetBlinkCursor
            jmp NotReadyToRun

        ..Else_If eax = M00_Load_BitMap
            CloseDebuggerOrIgnore
            call LoadBitMap | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Delete_BitMap
            CloseDebuggerOrIgnore
            call DeleteBitMap | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_BitMaps_IDs | call ShowBitMapsIds

        ..Else_If eax = M00_Load_Wave
            CloseDebuggerOrIgnore
            call ReadWaveFile | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Delete_Wave
            CloseDebuggerOrIgnore
            call DeleteWave | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Load_Avi
            CloseDebuggerOrIgnore
            call ReadAviFile | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Delete_Avi
            CloseDebuggerOrIgnore
            call DeleteAviFile | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Load_RC
            CloseDebuggerOrIgnore
            call ReadRcData | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Save_RC
            CloseDebuggerOrIgnore
            call SaveRcData | jmp NotReadyToRun

        ..Else_If eax = M00_Delete_RC
            CloseDebuggerOrIgnore
            call DeleteRcData | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Ascii_Table | call AsciiTable

        ..Else_If eax = M00_Win32_hlp | call Win32_Hlp

        ..Else_If eax = M00_Mmedia_hlp | call Mmedia_Hlp

        ..Else_If eax = M00_OpenGl_hlp | call OpenGl_Hlp

        ..Else_If eax = M00_WinSock_hlp | call WinSock_Hlp

        ..Else_If eax = M00_Dx_hlp | call Dx_Hlp

        ..Else_If eax = M00_SDL | call SDL_hlp

        ..Else_If eax = M00_sqlite | call sqlite_Hlp

        ..Else_If eax = M00_DevIl | call DevIL_Hlp

        ..Else_If eax = M00_Win32_Data_Types | call ShowTypes

        ..Else_If eax = M00_Win32_Equates | call ShowEquates

        ..Else_If eax = M00_Strings
            CloseDebuggerOrIgnore
            call StringsResources | jmp NotReadyToRun

        ..Else_If eax = M00_Load_Cursor
            CloseDebuggerOrIgnore
            call ReadCursor | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Delete_Cursor
            CloseDebuggerOrIgnore
            call DeleteCursor | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Load_Icon
            CloseDebuggerOrIgnore
            call ReadIcon | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Delete_Icon
            CloseDebuggerOrIgnore
            call DeleteIcon | call EnableMenutems | jmp NotReadyToRun

        ..Else_If eax = M00_Clip_File | call Templates
           ; call SetQwordCheckSum String2

        ..Else_If eax = M00_Data_to_Equates | call DataToStructure

        ..Else_If eax = M00_Structures | call StructDialog

        ..Else_If eax = M00_Sys_Resources | call ViewSysResources

        ..Else_If eax = M00_GUIDs | call ViewGUIDs

        ..Else_If eax = M00_Show_RosAsm_Mems | call ViewRosAsmMems

        ..Else_If eax = M00_Show_Symbols_Repartition | call TestRepartition

        ..Else_If eax = M00_Local_mem_Tests | call TestLocals

        ..Else_If eax = M00_Serial_Compilations | call MultipleCompileTests

        ..Else_If eax = M00_Encoding
            CloseDebuggerOrIgnore

            call ViewEncoding

            jmp NotReadyToRun

        ..Else
            .If eax > 6999                      ; Clip Files
                call Templates

            .Else_If eax > 5999                  ; Wizards
                CloseDebuggerOrIgnore

                On B$SourceReady = &FALSE,
                    call 'USER32.SendMessageA', D$hwnd, &WM_COMMAND, M00_New, 0

                On B$SourceReady = &TRUE, call NewWizardForm

            .Else_If eax > 4999                  ; Visual Tuts
                If eax < 5100
                   call VisualTuts
                Else
                    jmp L5>>
                End_If

            .Else_If eax > 3999             ; Added FloatMenu under [Struct].
                If eax < 4010
                    mov D$MenuID eax | call StructDialog ; OpenStructureFile
                Else
                    jmp L5>>
                End_If

            .Else_If eax > 3000             ; Most Recently Used Files.
                If eax < 3005
                    CloseDebuggerOrIgnore
                    push eax
                        call Security       ; 'Security' also uses eax as return Value.
                    pop ebx
                    On eax = &IDCANCEL, jmp L9>>
                        mov eax ebx         ; ... and 'LoadRMUfile' as input.
                        call LoadRMUfile
                        On eax = &FALSE, jmp L5>
                        call SetPartialEditionFromPos
                        call LoadBookMarks | call EnableMenutems | call LoadBookMarks
                Else
                    jmp L5>
                End_If
            .Else_If eax > 1999             ; User defined menu:
                If eax < 2009
                    mov eax D@wParam | call UserDefinedAction
                Else
                    jmp L5>
                End_If
            .Else
                jmp L5>
            .End_If
        ..End_if
        jmp L9>>

    ...End_If

L5: If B$SourceReady = &FALSE
        On D@Message = &WM_PAINT, call SplashScreen
        jmp NoClient
    End_If
 __________________________________________

 ; Main window CallBack going on: With opened file only:

    mov eax D@Message

    ...If eax = &WM_PAINT
        .If D$CodeSource > 0
            call TextPos
            mov eax D@Adressee
            If eax = D$EditWindowHandle
                call PrintColorText
            Else_If eax = D$BpWindowHandle
                call PrintBp
            End_If

            If B$MovingBlock = &TRUE
                call SetBlock | call AskForRedraw
            End_If

            call StatusBar

            mov B$RedrawFlag &FALSE
        .End_If

        mov eax D$EditWindowHandle | On D@Adressee <> eax, jmp NoClient

    ...Else_If eax = &WM_CHAR
        ..If B$RedrawFlag = &FALSE
            mov B$RedrawFlag &TRUE

            call CharMessage D@wParam | or B$SourceHasChanged al

            call AskForRedraw | jmp NotReadyToRun
        ..End_If
;;
   Note from Betov: This 'WM_IME_CHAR' case and according Routine have been implemented
   by Liang Xianning. I am pretty sure that holding unicode oriental KeyBoards input
   can *not* be done this way for many reasons (what if one byte inside the unicode
   string is equal to Quote, Double-Quote,... and other critical Bytes values? What of
   BackSpace upon such a String, and so on. Also, all of the innumerous RosAsm Routines
   that perform any action on Source Text should be re-written too... What i would
   clearly refuse 'for many reasons...' too).

   The only solution i can imagine for inputing Oriental Unicode Strings would be to
   write an external little tool (a simple EditControl + a simple Routine to save the
   String Data in U$ RosAsm Format -in hexaDecimal Numbers- to be pasted in the Source
   Data through the ClipBoard. Very easy to do, but i can't do it. (I can't see any
   Oriental Char on my PC...).

   Another thing is that fully holding Oriental Char *inside* an Asm Source Editor
   does not make much sense, as the source would then be turned of no use for all other
   programmers. Do i write in french??? Oh yes,... Sometimes, when i am ashamed... :))
;;
    ...Else_If eax = &WM_IME_CHAR
        .If B$RedrawFlag = &FALSE
            CloseDebuggerOrIgnore

            mov B$RedrawFlag &TRUE
            mov eax D@Wparam | call InsertDoubleByte | call AskForRedraw
            jmp NotReadyToRun
        .End_If

    ...Else_If eax = &WM_MOUSEWHEEL
        mov eax D@wParam | call WheelMsg | call KillCompletionList

    ...Else_If eax = &WM_XBUTTONDOWN
        ..If W@Wparam+2 = &XBUTTON1
            mov B$BlockInside &FALSE
            call RestoreRealSource | call BackClick | call SetPartialEditionFromPos

        ..Else_If W@Wparam+2 = &XBUTTON2
            mov B$BlockInside &FALSE
            call RestoreRealSource | call ForwardClick | call SetPartialEditionFromPos
        ..End_If

        popad | mov eax &TRUE | ExitP

    ...Else_If eax = &WM_COMMAND
        mov eax D@Wparam | and eax 0FFFF

        ..If eax = M00_<<<<_
            mov B$BlockInside &FALSE
            call RestoreRealSource | call BackClick | call SetPartialEditionFromPos

        ..Else_If eax = M00_>>>>_
            mov B$BlockInside &FALSE
            call RestoreRealSource | call ForwardClick | call SetPartialEditionFromPos

        ..Else_If eax = M00_Compile
            mov D$ShowStats &TRUE
            call Compile

        ..Else_If eax = M00_Run
            call Run

        ..Else_If eax = M00_Optimize_Jumps_Sizes
            call Optimize

       ; ..Else_If eax = M00_Profile | call Profiler

        ..Else_If eax = M00_Paste_at_Pos
            On D$IsDebugging = &TRUE, jmp L9>>
            call RestoreRealSource | call IncludeSource | call SetPartialEditionFromPos
            mov B$SourceHasChanged &TRUE, B$FirstBlockDraw &FALSE
            call SetCaret D$CurrentWritingPos

        ..Else_If eax = M00_Find
            mov D$NextSearchPos 0 | call SetSimpleSearchBox

        ..Else_If eax = M00_Replace
            mov D$NextSearchPos 0 | On D$IsDebugging = &FALSE, call SetFindReplaceBox

        ..Else_If eax = M00_Undo
            call ControlZ

        ..Else_If eax = M00_Redo
            call ControlShiftZ

        ..Else_If eax = M00_Copy
            call ControlC

        ..Else_If eax = M00_Paste
            call ControlV | call AskForRedraw

        ..Else_If eax = M00_Delete
            call ControlD | call AskForRedraw

        ..Else_If eax = M00_Cut
            call ControlX | call AskForRedraw

        ..Else_If eax = M00_Save_Source_only
            call ControlS

        ..Else_If eax = M00_Replace_Source_Only
            On D$IsDebugging = &TRUE, jmp L9>>
            call ReInitUndoOnly
            call ReplaceSourceOnly
            call UpdateTitlesFromIncludeFiles
            On D$SourceLen > 0, call SetPartialEditionFromPos

        ..Else_If eax = M00_Tree
            call CreateTreeViewList | call SetTreeDialogPos

        ..Else_If eax = M00_Import
           call ShowSourceImports

        ..Else_If eax = M00_Export
           call ShowSourceExports

        ..Else_If eax = M00_Print | call Print

        ..Else_If eax = Float_Copy
            call CopyFromFloatMenu | call AskForRedraw
            call 'USER32.DestroyMenu' D$FloatHandle

        ..Else_If eax = Float_Delete
            call ControlX | call AskForRedraw
            call 'USER32.DestroyMenu' D$FloatHandle

        ..Else_If eax = Float_Replace
            call ControlD | call ControlV | call AskForRedraw
            call 'USER32.DestroyMenu' D$FloatHandle

        ..Else_If eax = Float_SearchUp
            call RestoreRealSource
            call StorePosInBackTable | call SearchUpFromFloatMenu
            call SetPartialEditionFromPos
            call 'USER32.DestroyMenu' D$FloatHandle

        ..Else_If eax = Float_SearchDown
            call RestoreRealSource
            call StorePosInBackTable | call SearchDownFromFloatMenu
            call SetPartialEditionFromPos
            call 'USER32.DestroyMenu' D$FloatHandle

        ..Else_If eax = Float_SearchFromTop
            call RestoreRealSource
            call StorePosInBackTable | call SearchFromTopFromFloatMenu
            call SetPartialEditionFromPos
            call 'USER32.DestroyMenu' D$FloatHandle

        ..Else_If eax = Float_Unfold
            call 'USER32.DestroyMenu' D$FloatHandle
            call RestoreRealSource | call ShowUnfoldMacro | call SetPartialEditionFromPos

        ..Else_If eax = Float_BookMark | call StoreBookMark
            call 'USER32.DestroyMenu' D$FloatHandle

        ..Else_If eax = Float_UnBookMark | call DeleteBookMark
            call 'USER32.DestroyMenu' D$FloatHandle

        ..Else_If eax = Float_Number | call ViewClickedNumber
            call 'USER32.DestroyMenu' D$FloatHandle

        ..Else_If eax = Float_SelReplace
            call 'USER32.DestroyMenu' D$FloatHandle | call BlockReplaceAll

        ..Else_If eax = FloatSetBp
            call 'USER32.DestroyMenu' D$FloatHandle
            call SetBreakPoint | call DoStoreBP | jmp NotReadyToRun

        ..Else_If eax = FloatDelBp
            call 'USER32.DestroyMenu' D$FloatHandle
            call DeleteBreakPoint | call DoStoreRemoveBP | jmp NotReadyToRun

        ..Else_If eax = FloatDelAllBp
            call 'USER32.DestroyMenu' D$FloatHandle
            call DeleteAllBreakpoints | jmp NotReadyToRun

        ..Else_If eax = Float_BadDisLabel
            call 'USER32.DestroyMenu' D$FloatHandle
            call ForcedFlags

        ..Else_If eax = M00_Output
            call OutputFormat | call EnableMenutems | jmp NotReadyToRun

        ..End_If

    ...Else_If eax = &WM_SETCURSOR
        mov eax D@wParam
        .If eax = D$StatusBarHandle
            If D$TitleWindowHandle = 0
                call ShowTitles
            End_If
        .End_If

        jmp NoClient

    ...Else_If eax = &WM_MOUSEMOVE
        .If D$TitleWindowHandle > 0
            mov ebx D$TabWindowY
            On W@lParam+2 < bx, call KillTitleTab
        .End_If

        If D@Wparam <> &MK_LBUTTON                          ; Is the Left Button Down?
            call 'USER32.ClipCursor' &NULL | jmp NoClient
        End_If

        On B$UserHaveClickDown = &FALSE, jmp NoClient
            On B$UserClickAfterEnd = &TRUE, jmp NoClient
                push D@Lparam | pop W$MousePosX, W$MousePosY

                call SetBlock

                If B$FirstBlockDraw = &FALSE
                    On B$BlockRedraw = &TRUE, call AskForRedrawNow
                End_If

    ...Else_If eax = &WM_LBUTTONDOWN
        mov B$ShiftBlockInside &FALSE

        call KillCompletionList

        On B$BlinkingCaretWanted = &TRUE, call ResetBlinkCursor
        push D@Lparam | pop W$MousePosX, W$MousePosY

        mov B$BlockInside &FALSE, eax D@Adressee | call LeftButton

        call AskForRedrawNow
        mov D$NextSearchPos 0, B$UserHaveClickDown &TRUE

    ...Else_If eax = &WM_LBUTTONUP
        On B$BlinkingCaretWanted = &TRUE, call ResetBlinkCursor
        On B$FirstBlockDraw = &TRUE, mov B$BlockInside &FALSE
        call LeftButtonUp | mov B$UserHaveClickDown &FALSE | call AskForRedrawNow

    ...Else_If eax = &WM_RBUTTONUP
        call KillCompletionList
        On B$BlinkingCaretWanted = &TRUE, call ResetBlinkCursor

        mov eax D@Adressee
        .If eax = D$BpWindowHandle
            If D$DBPMenuOn = RIGHT_CLICK_ACTION
                mov B$ShiftBlockInside &FALSE

                call KillCompletionList

                On B$BlinkingCaretWanted = &TRUE, call ResetBlinkCursor
                call RestoreRealSource
                    push D@Lparam | pop W$MousePosX, W$MousePosY
                    call MarginRightClick
                call SetPartialEditionFromPos
            End_If

            jmp NoClient
        .End_If

        call RestoreRealSource
            push D@Lparam | pop W$MousePosX, W$MousePosY
            call RightClick
        call SetPartialEditionFromPos

    ...Else_If eax = &WM_LBUTTONDBLCLK
        mov B$ShiftBlockInside &FALSE

        call KillCompletionList

        On B$BlinkingCaretWanted = &TRUE, call ResetBlinkCursor
        call RestoreRealSource
            push D@Lparam | pop W$MousePosX, W$MousePosY
            call DoubleClick
        call SetPartialEditionFromPos

    ...Else_If eax = D$FindStringMessage
        call KillCompletionList

        call StringSearch | call AskForRedraw

    ...Else
        jmp NoClient

    ...End_If
 ____________________________________

L9: popad | mov eax &FALSE | jmp P9>>

L7: ; NotReadyToRun:
    .If B$ReadyToRun = &TRUE         ; (Something has just been modified).
        mov B$ReadyToRun &FALSE
        VirtualFree D$IpTable, D$StatementsTable, D$StatementsTable2
    .End_If

    mov B$SourceHasChanged &TRUE

    popad | mov eax &FALSE | jmp P9>

L8: ; NoClient:
    popad | call 'User32.DefWindowProcA' D@Adressee D@Message D@wParam D@lParam
EndP

____________________________________________________________________________________________

Compile:
        If D$UnusedCodeAndDataDialogHandle = &FALSE
            On B$Compiling = &TRUE, ret
            On D$IsDebugging = &TRUE, ret
        Else
            mov D$ShowStats &FALSE
        End_If

        mov B$RecompileWanted &FALSE, B$Compiling &TRUE
        call RestoreRealSource

        On D$UnusedCodeAndDataDialogHandle <> 0, call ReInitUnusedDialog

        call AsmMain | mov D$OldStackPointer 0

        If B$CompileErrorHappend = &FALSE
            mov B$ReadyToRun &TRUE, B$SourceHasChanged &FALSE
        End_If

        call SetPartialEditionFromPos
        call AskForRedraw

        mov B$Compiling &FALSE | call ResetKeys
ret


Run:
    If D$UnusedCodeAndDataDialogHandle <> &FALSE
      ; 'UnusedCodeAndDataDialogCallBack'
        call 'USER32.EndDialog' D$UnusedCodeAndDataDialogHandle, 0
        mov D$UnusedCodeAndDataDialogHandle 0
        mov B$Compiling &FALSE, B$UnusedSymbolsDialogWanted &FALSE, B$ShowStats &FALSE
        mov B$UnusedSymbolsDialogWanted &FALSE
    End_If

    On B$Compiling = &TRUE, ret
    On D$IsDebugging = &TRUE, ret

    mov B$ShowStats &FALSE, B$Compiling &TRUE, B$RecompileWanted &FALSE

    call RestoreRealSource

    If B$ReadyToRun = &FALSE
        mov B$ShowStats &FALSE
        call AsmMain
        mov D$OldStackPointer 0
        mov D$UnusedSymbolsDialogWanted &FALSE

        On B$CompileErrorHappend = &FALSE, mov B$ReadyToRun &TRUE
    End_If

    call SetPartialEditionFromPos

    If B$CompileErrorHappend = &FALSE
        mov B$SourceHasChanged &FALSE
        call Debugger
    End_If

    mov B$Compiling &FALSE | call ResetKeys
ret


Optimize:
    mov B$AlignFound &FALSE

    If D$UnusedCodeAndDataDialogHandle <> &FALSE
      ; 'UnusedCodeAndDataDialogCallBack'
        call 'USER32.EndDialog' D$UnusedCodeAndDataDialogHandle, 0
        mov D$UnusedCodeAndDataDialogHandle 0
        mov B$Compiling &FALSE, B$UnusedSymbolsDialogWanted &FALSE, B$ShowStats &FALSE
    End_If

    If B$ReadyToRun = &FALSE
        mov D$ShowStats &FALSE
        call Compile
    End_If

    .If B$ReadyToRun = &TRUE
        If B$AlignFound = &TRUE
            call 'USER32.MessageBoxA' &NULL, NoptimizeMessage,
                                      NoptimizeTitle, &MB_SYSTEMMODAL
        Else
            mov B$ShortenJumpsWanted &TRUE
            mov D$ShowStats &TRUE
            call Compile
            mov B$ShortenJumpsWanted &FALSE
        End_If
    .End_If
ret

[NoptimizeTitle: 'Optimizer', 0
 NoptimizeMessage: "The Assembler can not yet optimize the Jump Sizes  
 on a Source making use of the Align Statement:
 
 The Alignments would be broken.", 0]
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc ScrollBarProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    On B$SourceReady = &FALSE, jmp L8>>

    pushad

    ...If D@Message = &WM_VSCROLL
        call KillCompletionList

        call 'USER32.IsMenu' D$FloatHandle
        ..If eax = &FALSE
            .If W@wParam = &SB_THUMBTRACK
                If D$TotalNumberOfLines < 0FFFF
                    movzx edx W@wParam+2
                Else
                    call 'USER32.GetScrollInfo' D$ScrollWindowHandle, &SB_VERT, VScroll
                    mov edx D$VScroll.nTrackPos
                End_If
                call RePosFromScroll

            .Else_If W@wParam = &SB_LINEDOWN    ; SB > ScrollBar.
                call DownOneLine

            .Else_If W@wParam = &SB_LINEUP
                call UpOneLine

            .Else_If W@wParam = &SB_PAGEDOWN
                mov ecx D$LineNumber
L4:             push ecx | call DownOneLine | pop ecx | loop L4<

            .Else_If W@wParam = &SB_PAGEUP
                mov ecx D$LineNumber
L0:             call UpOneLine | loop L0<

            .End_If
            call AskForRedraw
        ..End_If

        popad | mov eax &FALSE | ExitP

     ...End_If

     On D$TitleWindowHandle > 0, call KillTitleTab

    popad
L8: call 'User32.DefWindowProcA' D@Adressee D@Message D@wParam D@lParam
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

[QuitTitle: 'Sure?', 0
QuitMessage: 'Source has changed. Save/Compile now?', 0]

Security:
    mov eax &IDNO

    On D$CodeSource = 0, ret

    ...If B$SecurityWanted = &TRUE
        ..If B$SourceHasChanged = &TRUE
            call 'MessageBoxA' D$hwnd, QuitMessage, QuitTitle, &MB_YESNOCANCEL
            .If eax = &IDYES
                call RestoreRealSource
                call AsmMain | mov D$OldStackPointer 0
                If B$CompileErrorHappend = &FALSE
                    mov B$ReadyToRun &TRUE, B$SourceHasChanged &FALSE, eax &IDNO
                Else
                    call SetPartialEditionFromPos | mov eax &IDCANCEL
                End_If
            .End_if
        ..End_If
    ...End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[OldBlockInside: ?]  [DollarOnly: &FALSE]

Proc CharMessage:
    Argument @wParam

    mov eax D@wParam | On eax = &VK_ESCAPE, ExitP

    On B$keys+&VK_CONTROL = &TRUE, jmp L2>>

    .If D$DebugDialogHandle <> 0
        push eax
        call KillDebugger
            If eax = &IDNO
                mov eax &FALSE | ExitP
            End_If
        pop eax
    .End_If

    move D$OldBlockInside D$BlockInside | mov B$BlockInside &FALSE

    If B$WriteCheckerWanted = &TRUE
        cmp eax 32 | je L1>
        cmp eax CR | je L1>
        cmp eax ',' | je L1>
        cmp eax 8 | je L1>
       ; cmp eax ':' | je L1>
        cmp eax Tab | jne L0>
L1:     call WriteChecker D$CurrentWritingPos, eax
    End_If

L0: cmp eax CR | jne L1>
        If D$CompletionListHandle <> 0
            call ToCompletionList CR | ExitP
        End_If
        call CarriageReturn | jmp P8>>
L1: cmp eax 8 | jne L1>
        call BackSpace | jmp P8>>
L1: cmp al 167 | jne L1>   ; 167 = Paragraph Char (no more available).
        On B$DollarOnly = &TRUE, mov al '$'
L1: mov B$SimulatedBlock &FALSE
    cmp B$keys+&VK_SHIFT &TRUE | jne L1>
        On B$OldBlockInside = &FALSE, call SimulateBlockForBackIndent
L1: cmp B$OldBlockInside &TRUE | jne L1>
        cmp al Tab | jne L1>
            call IsItBlockIndent
            .If B$SimulatedBlock = &TRUE
                mov B$BlockInside &FALSE
                mov esi D$CurrentWritingPos
                If B$esi-1 = LF
                    call StartOfLine
                Else
                    call StartOfLine | call AskForRedrawNow | call StartOfLine
                End_If
            .End_If
            On B$BlockIndent = &TRUE, jmp P8>>
L1: ;mov D$OldBlockInside &FALSE
    cmp B$Overwrite &TRUE | jne L1>
        call OverwriteSource | jmp P8>>
L1:     call InsertSource | jmp P8>>

L2: call GetCtrlKeyState

    .If eax = 03
        call ControlC | mov eax &FALSE
    .Else_If eax = 016
        ;mov B$BlockInside &FALSE
        call ControlV | mov eax &TRUE
        mov B$BlockInside &FALSE
    .Else_If eax = 018
        call ControlX | mov eax &TRUE
    .Else_If eax = 04
        call ControlD | mov eax &TRUE
    .Else_If eax = 01A
        If B$Keys+&VK_SHIFT = &TRUE
            call ControlShiftZ | mov eax &FALSE ; ??? What use is this, here ???
        Else
            call ControlZ | mov eax &TRUE  ; ???
        End_If
    .Else_If eax = 1
        call ControlA | mov eax &FALSE
    .Else_If eax = 010
        call ControlP | mov eax &FALSE
    .Else_If eax = 012
        mov D$NextSearchPos 0 | call SetFindReplaceBox
        mov B$keys+&VK_CONTROL &FALSE, eax &TRUE
    .Else_If eax = 013
        call ControlS | mov eax &FALSE
        mov B$keys+&VK_CONTROL &FALSE
    .Else_If eax = 0B
        call ControlK | mov eax &FALSE
        mov B$keys+&VK_CONTROL &FALSE
    .Else_If eax = 06
        mov D$NextSearchPos 0 | call SetSimpleSearchBox
        mov B$keys+&VK_CONTROL &FALSE
        mov eax &FALSE
        mov B$keys+&VK_CONTROL &FALSE
    .Else_If eax = 019
        If B$CtrlYFlag = &TRUE
            call ControlY | mov eax &TRUE
        End_If
    .Else_If eax = 020
        On B$Underline = &TRUE, call Completion
        mov eax &TRUE
        mov B$keys+&VK_CONTROL &FALSE
    .Else
        mov eax &FALSE
    .End_If

    push eax | call CheckCtrlKeyState | pop eax | mov D$OldBlockInside &FALSE | ExitP

P8: mov D$OldBlockInside &FALSE, eax &TRUE
EndP
____________________________________________________________________________________________

[CtrlKeyState: ?]

; The "and eax 0FFFF" makes it work as well under 95 and 2000

GetCtrlKeyState:
    push eax
        call 'USER32.GetKeyState' &VK_CONTROL
        and eax 0FFFF | mov D$CtrlKeyState eax
    pop eax
ret


CheckCtrlKeyState:
    call 'USER32.GetKeyState' &VK_CONTROL | and eax 0_FFFF
    On eax <> D$CtrlKeyState, mov B$keys+&VK_CONTROL &FALSE
ret
____________________________________________________________________________________________

[SimulatedBlock: ?]

SimulateBlockForBackIndent:
    push esi
        mov esi D$CurrentWritingPos
        While B$esi-1 <> LF | dec esi | End_While
        mov D$BlockStartTextPtr esi

        mov esi D$CurrentWritingPos
        While B$esi <> CR | inc esi | End_While | dec esi
        mov D$BlockEndTextPtr esi

        mov B$OldBlockInside &TRUE, B$SimulatedBlock &TRUE
    pop esi
ret


[BlockIndent: ?]

IsItBlockIndent:
    mov B$BlockIndent &FALSE

  ; Verify that the Block includes a start of Line (accept non included Labels):
    mov esi D$BlockStartTextPtr
    While B$esi <> LF
        dec esi
        If B$esi = ':'
            jmp L2>
        Else_If B$esi > ' '
            jmp L9>>
        End_If
    End_While

  ; Verify that the Block is not empty:
L2: mov esi D$BlockStartTextPtr
    While esi < D$BlockEndTextPtr
        On B$esi > ' ', jmp L2>
        inc esi
    End_While
    jmp L9>>

  ; Verify that the last selected line is complete (does not stop before CRLF):
L2: mov esi D$BlockEndTextPtr

    While W$esi+1 <> CRLF
        On esi < D$BlockStartTextPtr, jmp L9>>
        dec esi
    EndWhile

  ; OK, Block holds a full Lines content.  ; 'InsertSource'
  ; Insert or retrieve as many Tab as Lines (but preserve Labels):
L2: On B$keys+&VK_SHIFT = &TRUE, jmp RetrieveBlockIndent

L2: mov esi D$BlockStartTextPtr, B$FirstBlockLine &TRUE

    ..While esi < D$BlockEndTextPtr
      ; Go to Start of Line:
        mov ebx esi | While B$ebx <> LF | dec ebx | End_While
      ; Go to Start of first member, and save in eax:
        While B$ebx <= ' ' | inc ebx | End_While
        mov eax ebx
        .While B$ebx > ' '
            inc ebx
            If B$ebx = ':'
                inc ebx
                While B$ebx <= ' '
                    inc ebx | On B$ebx = CR, jmp L8>>
                End_While
          ; New Start of first memeber if first one was a label:
            mov eax ebx
            End_If
        .End_While
      ; eax > real first member to move. Adjust Block Start if necessary:
        If B$FirstBlockLine = &TRUE
            mov D$BlockStartTextPtr eax
            mov B$FirstBlockLine &FALSE
        End_If
        push eax, D$SourceLen
            call SetCaret eax | dec D$CaretRow | move D$PhysicalCaretRow D$CaretRow
            mov al Tab | call InsertSourceOnBlockIndent
        pop ecx, esi
      ; Next Line:
        While B$esi <> CR | inc esi | End_While | inc esi
        mov eax D$SourceLen | sub eax ecx | add D$BlockEndTextPtr eax
    ..End_While

    mov eax D$BlockStartTextPtr
    While B$eax = ' ' | inc eax | End_While
    mov D$BlockStartTextPtr eax

    call SetCaret D$BlockEndTextPtr | mov B$RightScroll 0

  ; 'KeyMessage'
  ;  move D$ShiftBlockCol D$CaretRow
  ;  move D$ShiftBlockLine D$CaretLine
  ;  move D$PhysicalCaretRow D$CaretRow
  ;  mov D$CaretEndOfLine &TRUE
  ;  call KeyMessage

L8: mov B$BlockIndent &TRUE, B$BlockInside &TRUE
L9: ret


[FirstBlockLine: ?    NewCaretBlockPos: ?]

RetrieveBlockIndent:
    mov B$BlockIndent &TRUE, D$NewCaretBlockPos 0
  ; Are there enough free Spaces to be deleted on each Line? If not, abort:
    mov esi D$BlockStartTextPtr
    ..While esi < D$BlockEndTextPtr
      ; Go to Start of Line:
        mov ebx esi | While B$ebx <> LF | dec ebx | End_While
      ; Go to Start of first member, and save in eax:
        While B$ebx <= ' ' | inc ebx | End_While
        mov eax ebx
      ; If Label, jmp over it:
        .While B$ebx > ' '
            inc ebx
            If B$ebx = ':'
                inc ebx
                While B$ebx <= ' '
                    inc ebx | On B$ebx = CR, jmp L8>>
                End_While
              ; New Start of first memeber if first one was a label:
                mov eax ebx
            End_If
        .End_While

      ; eax > now real first member to move. Are there enough Spaces in front of it?
        push eax
            mov ecx D$TabIs
L0:         dec eax
            If B$eax <> ' '
                pop eax | jmp L8>>
            End_If
            loop L0<
        pop esi
      ; OK, enough spaces > Next Line:
        While B$esi <> CR | inc esi | End_While | inc esi
    ..End_While

  ; OK, enough Spaces on each Line > Delete:
    mov esi D$BlockStartTextPtr, B$FirstBlockLine &TRUE
    ..While esi < D$BlockEndTextPtr
      ; Go to Start of Line:
        mov ebx esi | While B$ebx <> LF | dec ebx | End_While
      ; Go to Start of first member, and save in eax:
        While B$ebx <= ' ' | inc ebx | End_While
        mov eax ebx
        .While B$ebx > ' '
            inc ebx
            If B$ebx = ':'
                inc ebx
                While B$ebx <= ' '
                    inc ebx | On B$ebx = CR, jmp L8>>
                End_While
              ; New Start of first member if first one was a label:
                mov eax ebx
            End_If
        .End_While
      ; eax > real first member to move:
        On D$NewCaretBlockPos = 0, mov D$NewCaretBlockPos eax

        If B$FirstBlockLine = &TRUE
            mov D$BlockStartTextPtr eax, B$FirstBlockLine &FALSE
        End_If
        push eax, D$SourceLen
            call SetCaret eax | dec D$CaretRow | move D$PhysicalCaretRow D$CaretRow
            mov ecx D$TabIs
L0:         push ecx
                mov al Tab | call BackSpace | dec D$BlockEndTextPtr
            pop ecx | loop L0<
        pop ecx, esi
      ; Next Line:
        sub esi D$TabIs
        While B$esi <> CR | inc esi | End_While | inc esi
    ..End_While

    mov eax D$TabIs | sub D$BlockStartTextPtr eax
    mov eax D$NewCaretBlockPos | sub eax D$TabIs | dec eax | call SetCaret eax

   ; move D$ShiftBlockCol D$CaretRow
   ; move D$ShiftBlockLine D$CaretLine
   ; move D$PhysicalCaretRow D$CaretRow
   ; mov D$CaretEndOfLine &FALSE

L8: mov B$BlockIndent &TRUE, B$BlockInside &TRUE
L9: ret



[ShiftDown: ?    ShiftBlockCol: ?    ShiftBlockLine: ?]

[keys: B$ ? #0100]

[KeyHasModifedSource: ?   KeyHasMovedCaret: ?   SourceHasChanged: ?]

KeyMessage:
    On B$SourceReady = &FALSE, ret

    mov B$KeyHasModifedSource &FALSE, B$KeyHasMovedCaret &FALSE

    ..If B$BlockInside = &TRUE
        .If B$ShiftBlockInside = &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                move D$CaretRow D$ShiftBlockCol
                move D$CaretLine D$ShiftBlockLine
                move D$PhysicalCaretRow D$CaretRow
                mov D$CaretEndOfLine &FALSE
            End_If
        .Else
            mov D$ShiftDown 0
        .End_If
    ..End_If

  ; Under some configurations, it appears that [Atl-Gr] (Right [Alt]), may generate
  ; a Key Down Message not followed by a Key Up message, for the Control Key... So:
    ...If B$keys+&VK_MENU = &TRUE
        mov B$keys+&VK_MENU &FALSE, B$keys+&VK_CONTROL &FALSE

    ...Else_If B$keys+&VK_CONTROL = &TRUE
        .If B$keys+&VK_PGDN = &TRUE
            call FullDown | mov B$BlockInside &FALSE
            mov B$KeyHasMovedCaret &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                call AskForRedrawNow | jmp L1>>
            End_If

            On B$ShiftBlockInside = &TRUE, mov B$BlockInside &FALSE, B$ShiftBlockInside &FALSE

        .Else_If B$keys+&VK_PGUP = &TRUE
            call FullUp | mov B$BlockInside &FALSE
            mov B$KeyHasMovedCaret &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                call AskForRedrawNow | jmp L1>>
            End_If

            On B$ShiftBlockInside = &TRUE, mov B$BlockInside &FALSE, B$ShiftBlockInside &FALSE

        .Else_If B$keys+&VK_LEFT = &TRUE
            call StartOfWord | mov B$KeyHasMovedCaret &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                call AskForRedrawNow | jmp L1>>
            End_If

            On B$ShiftBlockInside = &TRUE, mov B$BlockInside &FALSE, B$ShiftBlockInside &FALSE
            mov B$keys+&VK_LEFT &FALSE

        .Else_If B$keys+&VK_RIGHT = &TRUE
            call EndOfWord | mov B$KeyHasMovedCaret &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                call AskForRedrawNow | jmp L1>>
            End_If

            On B$ShiftBlockInside = &TRUE, mov B$BlockInside &FALSE, B$ShiftBlockInside &FALSE
            mov B$keys+&VK_RIGHT &FALSE

        .Else_If B$keys+&VK_DOWN = &TRUE
            call DownOneLine | mov B$KeyHasMovedCaret &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                call AskForRedrawNow | jmp L1>>
            End_If

            On B$ShiftBlockInside = &TRUE, mov B$BlockInside &FALSE, B$ShiftBlockInside &FALSE
            mov B$keys+&VK_DOWN &FALSE

        .Else_If B$keys+&VK_UP = &TRUE
            call UpOneLine | mov B$KeyHasMovedCaret &TRUE
            If B$keys+&VK_SHIFT = &TRUE
                call AskForRedrawNow | jmp L1>>
            End_If

            On B$ShiftBlockInside = &TRUE, mov B$BlockInside &FALSE, B$ShiftBlockInside &FALSE
            mov B$keys+&VK_UP &FALSE

        .Else_If B$keys+&VK_DELETE = &TRUE
            On D$DebugDialogHandle <> 0, ret
            call ControlD | mov B$keys+&VK_DELETE &FALSE, B$KeyHasModifedSource &TRUE

        .Else_If B$keys+&VK_INSERT = &TRUE
            On D$DebugDialogHandle <> 0, ret
            call ControlC | mov B$keys+&VK_INSERT &FALSE, B$KeyHasModifedSource &TRUE

        .Else_If B$keys+&VK_BACK = &TRUE
            On D$DebugDialogHandle <> 0, ret
            call ControlX | mov B$keys+&VK_BACK &FALSE, B$KeyHasModifedSource &TRUE
            mov B$RedrawFlag &TRUE
          ; This 'RedrawFlag' is to kill the next coming WM_CHAR holding
          ; ([Ctrl][Back] sends a char).

        .Else_If B$keys+&VK_F4 = &TRUE
            call RestoreRealSource
                call SetCaret D$CurrentWritingPos
                mov eax 0, ebx D$CaretLine | call MarginAction
            call SetPartialEditionFromPos
            mov B$keys+&VK_F4 0

        .Else
            On B$keys+&VK_SHIFT = &TRUE, jmp L1>

        .End_If



    ...Else_If B$keys+&VK_SHIFT = &TRUE
L1:     .If B$keys+&VK_LEFT = &TRUE
            call SetPhysicalCaretRow
            On B$keys+&VK_CONTROL = &FALSE, call KeyLeft
            If D$ShiftDown <> 0
                call SetShiftBlock
            Else
                mov B$BlockInside &FALSE
            End_If
            mov B$KeyHasMovedCaret &TRUE
            move D$PhysicalCaretRow D$CaretRow

        .Else_If B$keys+&VK_RIGHT = &TRUE
            On B$keys+&VK_CONTROL = &FALSE, call KeyRight
            If D$ShiftDown <> 0
                call SetShiftBlock
            Else
                mov B$BlockInside &FALSE
            End_If
            mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_UP = &TRUE
            On B$keys+&VK_CONTROL = &FALSE, call KeyUp
            If D$ShiftDown <> 0
                call SetShiftBlock
            Else
                mov B$BlockInside &FALSE
            End_If
            mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_DOWN = &TRUE
            On B$keys+&VK_CONTROL = &FALSE, call KeyDown
            If D$ShiftDown <> 0
                call SetShiftBlock
            Else
                mov B$BlockInside &FALSE
            End_If
            mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_PGUP = &TRUE
            On B$keys+&VK_CONTROL = &FALSE, call OnlyOnePageUp
            If D$ShiftDown <> 0
                call SetShiftBlock
            Else
                mov B$BlockInside &FALSE
            End_If
            mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_PGDN = &TRUE
            On B$keys+&VK_CONTROL = &FALSE, call OnlyOnePageDown
            If D$ShiftDown <> 0
                call SetShiftBlock
            Else
                mov B$BlockInside &FALSE
            End_If
            mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_HOME = &TRUE
            call StartOfLine
            If D$ShiftDown <> 0
                call SetShiftBlock
            Else
                mov B$BlockInside &FALSE
            End_If
            mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_END = &TRUE
            call EndOfLine
            If D$ShiftDown <> 0
                call SetShiftBlock
            Else
                mov B$BlockInside &FALSE
            End_If
            mov B$KeyHasMovedCaret &TRUE

        .Else_If B$keys+&VK_INSERT = &TRUE
            On D$DebugDialogHandle <> 0, ret
            call ControlV | mov B$keys+&VK_INSERT &FALSE, B$KeyHasModifedSource &TRUE

        .Else_If B$keys+&VK_DELETE = &TRUE
            On D$DebugDialogHandle <> 0, ret
            call ControlX | mov B$keys+&VK_DELETE &FALSE, B$KeyHasModifedSource &TRUE

        .Else_If B$keys+&VK_F4 = &TRUE
            call RestoreRealSource
                call SetCaret D$CurrentWritingPos
                mov eax 0, ebx D$CaretLine | call MarginAction
            call SetPartialEditionFromPos
            mov B$keys+&VK_F4 0

        .Else
            If B$BlockInside = &FALSE
                move D$ShiftDown D$CurrentWritingPos | ret
           ; Else
           ;     mov B$BlockInside &FALSE | call AskForRedraw | ret
            End_If

        .End_If

    ...Else
        ..If eax = &VK_PGDN
            call OnlyOnePageDown | mov B$BlockInside &FALSE

        ..Else_If eax = &VK_PGUP
            call OnlyOnePageUp | mov B$BlockInside &FALSE

        ..Else_If eax = &VK_DOWN
            If D$CompletionListHandle <> 0
                mov B$Keys+eax 0
                call ToCompletionList &VK_DOWN
              ; To save from downward 'KeyHasMovedCaret' Flag modification:
                ret
            Else
                call KeyDown | mov B$BlockInside &FALSE
            End_If

        ..Else_If eax = &VK_UP
            If D$CompletionListHandle <> 0
                mov B$Keys+eax 0
                call ToCompletionList &VK_UP
              ; To save from downward 'KeyHasMovedCaret' Flag modification:
                ret
            Else
                call KeyUp | mov B$BlockInside &FALSE
            End_If

        ..Else_If eax = &VK_LEFT
            call KeyLeft | mov B$BlockInside &FALSE

        ..Else_If eax = &VK_RIGHT
            call KeyRight | mov B$BlockInside &FALSE

        ..Else_If eax = &VK_INSERT
            call KeyInsert | mov B$BlockInside &FALSE

        ..Else_If eax = &VK_DELETE
            .If D$DebugDialogHandle <> 0
                mov B$Keys+eax 0
                call KillDebugger | On eax = &IDNO, ret
            .End_If
            call KeyDelete | mov B$BlockInside &FALSE, B$KeyHasModifedSource &TRUE

        ..Else_If eax = &VK_END
            call EndOfLine | mov B$BlockInside &FALSE

        ..Else_If eax = &VK_HOME
            call StartOfLine | mov B$BlockInside &FALSE

        ..Else_If eax = &VK_ESCAPE
            If D$CompletionListHandle <> 0
                call 'USER32.SendMessageA' D$CompletionListHandle, &WM_COMMAND, &IDCANCEL, 0
                mov B$keys+&VK_ESCAPE &FALSE | ret
            End_If

        ..Else_If eax = &VK_F1
            call RosAsmHelp | mov B$keys+&VK_F1 &FALSE

        ..Else_If eax = &VK_F2
            call F2Help | mov B$keys+&VK_F2 &FALSE

        ..Else_If eax = &VK_F3
            call RestoreRealSource | call StringSearch | call SetPartialEditionFromPos
            mov B$keys+&VK_F3 0

        ..Else_If eax = &VK_F4  ; BpMenu / SetBreakPoint / DeleteBreakpoint
            call RestoreRealSource
                call SetCaret D$CurrentWritingPos
                mov eax 0, ebx D$CaretLine | call MarginAction
            call SetPartialEditionFromPos
            mov B$keys+&VK_F4 0

        ..Else_If eax = &VK_F5
            mov B$keys+&VK_F5 &FALSE
            mov D$ShowStats &TRUE
            call Compile

        ..Else_If eax = &VK_F6
            mov B$keys+&VK_F6 &FALSE

            If D$DebugDialogHandle <> 0
                ret
            Else
                call Run
            End_If

        ..Else_If eax = &VK_F8
            If D$DebugDialogHandle <> 0
                mov B$keys+&VK_F2 &FALSE
                call KillDebugger | On eax = &IDNO, ret
            End_If
            call DrawOneLine

        ..Else_If eax = &VK_F9
            mov B$Keys+eax 0
            ;mov eax D$BreakPointsTables | int3
            ret
;;
; Problem if someone want to implement a Key doinf the same job as Right-Click:
; How to get back after Editor moves?

            call KillCompletionList
  
            call RowToX D$CaretRow | mov D$MousePosY eax
            call LineToY D$CaretLine | mov D$MousePosY eax
            call 'USER32.SetCursorPos' D$MousePosX, D$MousePosY

            call RestoreRealSource
                call RightClick
            call SetPartialEditionFromPos
            mov B$keys+&VK_F9 &FALSE
;;
        ..Else_If eax = &VK_F11
            call SavePosOnF11

        ..Else_If eax = &VK_F12
            call SetPosOnF12

        ..Else
            mov B$Keys+eax 0 | ret

        ..End_If
      ; Necessity for clearing by hand because, with lengthy case (like upper 'StringSearch'),
      ; the OS clear the remaining Messages (here WM_KEYUP!!!) for the Message Flow.
       ; pop eax | mov B$Keys+eax 0
        mov B$KeyHasMovedCaret &TRUE

    ...End_If


    On B$KeyHasMovedCaret = &TRUE, call KillCompletionList
ret
____________________________________________________________________________________________

ResetKeys:
    mov edi keys, eax 0, ecx (0100/4) | rep stosd
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

EnableMenutems:
   ; call 'USER32.EnableMenuItem' D$MenuHandle, M00_Profile, &MF_GRAYED

    .If B$SourceReady = &FALSE
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Tree, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Paste_at_Pos, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Change_Compile_Name, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Replace_Source_Only, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_Source_Only, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Output, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Print, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Find, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Replace, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Replace, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Undo, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Redo, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Copy, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Paste, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Cut, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Compile, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Run, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Import, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Export, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_GUIDs, &MF_GRAYED

    .Else
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Tree, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Paste_at_Pos, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Change_Compile_Name, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Replace_Source_Only, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_Source_Only, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Output, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Print, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Find, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Replace, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Replace, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Undo, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Redo, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Copy, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Paste, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Cut, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Compile, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Run, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Import, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Export, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_GUIDs, &MF_ENABLED

    .End_If

    If D$SavingExtension = '.SYS'
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Run, &MF_GRAYED
    Else_If B$SourceReady = &TRUE
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Run, &MF_ENABLED
    End_If

    If D$IconList = 0
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_Icon, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Icon_IDs, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_Icon, &MF_GRAYED
    Else
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_Icon, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Icon_IDs, &MF_GRAYED ; &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_Icon, &MF_GRAYED ;&MF_ENABLED
    End_If

    If D$BitMapList = 0
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_BitMap, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_BitMaps_IDs, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_BitMap, &MF_GRAYED
    Else
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_BitMap, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_BitMaps_IDs, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_BitMap, &MF_GRAYED ;&MF_ENABLED
    End_If

    If D$CursorList = 0
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_Cursor, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Cursors_IDs, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_Cursor, &MF_GRAYED
    Else
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_Cursor, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Cursors_IDs, &MF_GRAYED ;&MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_Cursor, &MF_GRAYED ;&MF_ENABLED
    End_If

    If D$WaveList = 0
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_Wave, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Waves_IDs, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_Wave, &MF_GRAYED
    Else
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_Wave, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Waves_IDs, &MF_GRAYED ;&MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_Wave, &MF_GRAYED ;&MF_ENABLED
    End_If

    If D$AviList = 0
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_Avi, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Avi_IDs, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_Avi, &MF_GRAYED
    Else
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_Avi, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Avi_IDs, &MF_GRAYED ;&MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_Avi, &MF_GRAYED ;&MF_ENABLED
    End_If

    If D$RCDataList = 0
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_RC, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_RCs_IDs, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_RC, &MF_GRAYED
    Else
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_RC, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_RCs_IDs, &MF_GRAYED ;&MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_RC, &MF_ENABLED
    End_If

    If D$DialogList = 0
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Load_from_Resources, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_Resources_Dialog, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_to_Binary_File, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Replace_from_Binary_File, &MF_GRAYED
    Else
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Load_from_Resources, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_Resources_Dialog, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_to_Binary_File, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Replace_from_Binary_File, &MF_ENABLED
    End_If

    If B$SourceReady = &FALSE
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Load_from_Binary_File, &MF_GRAYED
    Else
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Load_from_Binary_File, &MF_ENABLED
    End_If

    If D$MenuList = 0
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Existing_Menu, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_a_Menu, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_to_Binary_Menu_File, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Load_Binary_Menu_File, &MF_GRAYED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Replace_from_Binary_Menu_File, &MF_GRAYED
    Else
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Existing_Menu, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Delete_a_Menu, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Save_to_Binary_Menu_File, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Load_Binary_Menu_File, &MF_ENABLED
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Replace_from_Binary_Menu_File, &MF_ENABLED
    End_If

    call 'USER32.DrawMenuBar' D$hwnd
ret


[VisualTutsFindHandle: ?    VisualTutsMenuHandle: ?    VisualTutMenuID: ?]
[VisualTutsItem: 'Visual Tuts', 0]
[VisualTutPath: B$ ? #&MAXPATH]
[WizardPath: B$ ? #&MAXPATH]


EnableHelpMenutems:
    call EnableHelpMenutem B_U_AsmName, M00_B_U_Asm
    call EnableHelpMenutem Win32HlpName, M00_Win32_hlp
    call EnableHelpMenutem MmediaHlpName, M00_Mmedia_hlp
    call EnableHelpMenutem OpenGlHlpName, M00_OpenGl_hlp
    call EnableHelpMenutem DxHlpName, M00_Dx_hlp
    call EnableHelpMenutem WinsockHlpName, M00_WinSock_hlp
    call EnableHelpMenutem SDLRefName, M00_SDL
    call EnableHelpMenutem sqliteName, M00_sqlite
    call EnableHelpMenutem DevILName, M00_DevIL
ret


[PreviousIVT: ?] [IVTFilesNames1 Trash1][IVTFilesNames2 Trash2]

EnableVisualTutsMenu:
  ; Enable the 'Visual Tuts' Item and create the Pop-Up if some Visual Tuts are there:
    mov esi EquatesName, edi VisualTutPath, ecx (&MAXPATH / 4) | rep movsd

    mov esi VisualTutPath | While B$esi <> 0 | inc esi | End_While
    While B$esi <> '\' | dec esi | End_While
    mov D$esi+1 'IVT*', D$esi+5 '.exe', B$esi+9 0

    call 'KERNEL32.FindFirstFileA' VisualTutPath, FindFile

    .If eax = &INVALID_HANDLE_VALUE
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Visual_Tuts, &MF_GRAYED

    .Else
        mov D$VisualTutsFindHandle eax

        call 'USER32.CreatePopupMenu' | mov D$VisualTutsMenuHandle eax

        mov edi IVTFilesNames1, ecx 0

L1:     mov esi FindFile.cFileName | inc ecx

        While B$esi <> 0 | movsb | End_While | mov B$edi 0 | inc edi

        push ecx
            call 'KERNEL32.FindNextFileA' D$VisualTutsFindHandle, FindFile
        pop ecx

        On eax = &TRUE, jmp L1<

        call zStringsSort IVTFilesNames1, IVTFilesNames2, ecx
        ____________________________________________________

        mov B$PreviousIVT '0', D$VisualTutMenuID 5000

        call 'USER32.CreatePopupMenu' | mov D$VisualTutsMenuHandle eax

        mov esi IVTFilesNames2

L1:     add esi 6

        push esi
            mov al B$esi-3
            If al <> B$PreviousIVT
                mov B$PreviousIVT al
                call 'USER32.AppendMenuA' D$VisualTutsMenuHandle, &MF_SEPARATOR, 0, 0
            End_If

            call 'USER32.AppendMenuA' D$VisualTutsMenuHandle, &MF_ENABLED__&MF_STRING,
                                      D$VisualTutMenuID, esi
        pop esi

        While B$esi <> 0 | inc esi | End_While | inc esi

        If B$esi <> 0
            inc D$VisualTutMenuID | jmp L1<
        End_If

        call 'USER32.InsertMenuA' D$MenuHandle, M00_Visual_Tuts,
                                  &MF_BYCOMMAND__&MF_POPUP__&MF_STRING,
                                  D$VisualTutsMenuHandle, VisualTutsItem

        call 'USER32.DeleteMenu' D$MenuHandle, M00_Visual_Tuts, &MF_BYCOMMAND

        call 'KERNEL32.FindClose' D$VisualTutsFindHandle
    .End_If
ret


VisualTuts:
    push eax
        .If D$DebugDialogHandle <> 0
            call KillDebugger
            If eax = &IDNO
                pop eax | ret
            End_If
        .End_If

        ...If B$SourceReady = &TRUE
            ..If B$ReadyToRun = &FALSE
                .If B$SecurityWanted = &TRUE
                    call 'USER32.MessageBoxA' D$hwnd, {'Close the Actual File ?', 0},
                                              {'Visual Tutorial', 0}, &MB_YESNO
                    If eax = &IDNO
                        pop eax | ret
                    End_If
                .End_If
            ..End_If
        ...End_If
    pop eax

    mov esi VisualTutPath | While D$esi <> '\IVT' | inc esi | End_While
    add esi 4 | mov D$esi '???' | add esi 3
    call 'USER32.GetMenuStringA' D$MenuHandle, eax, esi, 100, &MF_BYCOMMAND

    call 'KERNEL32.FindFirstFileA' VisualTutPath, FindFile

    .If eax <> &INVALID_HANDLE_VALUE
        mov D$VisualTutsFindHandle eax
        call 'KERNEL32.FindClose' D$VisualTutsFindHandle

        mov esi VisualTutPath, edi SaveFilter
        While D$esi <> '\IVT' | movsb | End_While | movsb
        mov esi FindFile.cFileName | While B$esi <> 0 | movsb | End_While | movsb

        call DirectLoad

        call ReInitUndo
        call SetPartialEditionFromPos | call EnableMenutems
        call LoadBookMarks
    .End_If
ret


Proc EnableHelpMenutem:
    Argument @FileName, @Item

    call 'KERNEL32.FindFirstFileA' D@FileName, FindFile
    push eax
        If eax = &INVALID_HANDLE_VALUE
            mov eax &MF_GRAYED
        Else
            mov eax &MF_ENABLED
        End_If

        call 'USER32.EnableMenuItem' D$MenuHandle, D@Item, eax
    pop eax
    call 'KERNEL32.FindClose' eax
EndP
____________________________________________________________________________________________

[WizardsFindHandle: ?    WizardsMenuHandle: ?    WizardMenuID: ?]
[PreviousWZRD: ?]

[WizardsItem: 'Wizards', 0]

EnableWizardsMenu:
    call ClearTrashTables

  ; Enable the 'Visual Tuts' Item and create the Pop-Up if some Visual Tuts are there:
    mov esi EquatesName, edi WizardPath, ecx (&MAXPATH / 4) | rep movsd

    mov esi WizardPath | While B$esi <> 0 | inc esi | End_While
    While B$esi <> '\' | dec esi | End_While

    mov D$esi+1 'WZRD', D$esi+5 '*.*'

    call 'KERNEL32.FindFirstFileA' WizardPath, FindFile

    .If eax = &INVALID_HANDLE_VALUE
        call 'USER32.EnableMenuItem' D$MenuHandle, M00_Wizards, &MF_GRAYED

    .Else
        mov D$WizardsFindHandle eax

        call 'USER32.CreatePopupMenu' | mov D$WizardsMenuHandle eax

        mov edi Trash1, ecx 0

L1:     mov esi FindFile.cFileName | inc ecx

        While B$esi <> 0 | movsb | End_While | mov B$edi 0 | inc edi

        push ecx
            call 'KERNEL32.FindNextFileA' D$WizardsFindHandle, FindFile
        pop ecx

        On eax = &TRUE, jmp L1<

        call zStringsSort Trash1, Trash2, ecx

        ____________________________________________________

        mov B$PreviousWZRD '0', D$WizardMenuID 6000

        call 'USER32.CreatePopupMenu' | mov D$WizardsMenuHandle eax

        mov esi Trash2

L1:     add esi 4

        push esi
           ; mov al B$esi-3
           ; If al <> B$PreviousWZRD
           ;     mov B$PreviousWZRD al
           ;     call 'USER32.AppendMenuA' D$VisualTutsMenuHandle, &MF_SEPARATOR, 0, 0
           ; End_If

            call 'USER32.AppendMenuA' D$WizardsMenuHandle, &MF_ENABLED__&MF_STRING,
                                      D$WizardMenuID, esi
        pop esi

        While B$esi <> 0 | inc esi | End_While | inc esi

        If B$esi <> 0
            inc D$VisualTutMenuID | jmp L1<
        End_If

        call 'USER32.InsertMenuA' D$MenuHandle, M00_Wizards,
                                  &MF_BYCOMMAND__&MF_POPUP__&MF_STRING,
                                  D$WizardsMenuHandle, WizardsItem

        call 'USER32.DeleteMenu' D$MenuHandle, M00_Wizards, &MF_BYCOMMAND

        call 'KERNEL32.FindClose' D$WizardsFindHandle
    .End_If
ret
____________________________________________________________________________________________

[ClipMenuID: 7000    NumberOfClipFiles: 0]

[FindClipFilesHandle: ?    ClipFilePopUpMenuHandle: ?
 ClipFilesPath: B$ ? #&MAXPATH]

[ClipFilesItem: 'Clip Files', 0]

; Room for storing 20 Clip Files Names of 20 Chars each:

[ClipMenuStrings: ? #100]

Proc StoreClipMenuStrings:
    Argument @Source
    uses esi, edi

        mov edi ClipMenuStrings
L1:     While B$edi <> 0 | inc edi | End_While
        If edi <> ClipMenuStrings
            inc edi | On B$edi <> 0, jmp L1<
        End_If
        mov esi D@Source
        While B$esi <> 0 | movsb | End_While
EndP


EnableClipMenu: ; M00_Clip_File / 'LoadClipFile'
    call 'KERNEL32.FindFirstFileA' ClipName, FindFile
;;
  Assuming Multiple Clip Files had never been planed, and the whole implementation
  is supposed to work withnone single 'Clip.txt', which Path is given in 'ClipName',
  from the Configuration.
  
  So, if no Clip File found, we simple leave, and let the default way:
;;
    ...If eax = &INVALID_HANDLE_VALUE
        jmp L9>>

    ...Else
        call 'KERNEL32.FindClose' eax

        mov esi ClipName, edi ClipFilesPath
        While B$esi <> 0 | movsb | End_While
        While B$edi <> '\' | dec edi | End_While | inc edi
        mov D$edi '*Cli', D$edi+4 'p.tx', W$edi+8 't'

        call 'KERNEL32.FindFirstFileA' ClipFilesPath, FindFile

        ..If eax = &INVALID_HANDLE_VALUE
            jmp L9>>

        ..Else
            mov D$FindClipFilesHandle eax

L1:         If D$ClipFilePopUpMenuHandle = 0
                call 'USER32.CreatePopupMenu' | mov D$ClipFilePopUpMenuHandle eax
            End_If

            inc D$NumberOfClipFiles

            call 'USER32.AppendMenuA' D$ClipFilePopUpMenuHandle,
                                      &MF_ENABLED__&MF_STRING,
                                      D$ClipMenuID, FindFile.cFileName

            call StoreClipMenuStrings FindFile.cFileName

            inc D$ClipMenuID

            call 'KERNEL32.FindNextFileA' D$FindClipFilesHandle, FindFile
            On eax = &TRUE, jmp L1<<

            call 'KERNEL32.FindClose' D$FindClipFilesHandle

            .If D$ClipFilePopUpMenuHandle <> 0
                If D$NumberOfClipFiles > 1
                    call 'USER32.InsertMenuA' D$MenuHandle, M00_ClipFile,
                                              &MF_BYCOMMAND__&MF_POPUP__&MF_STRING,
                                              D$ClipFilePopUpMenuHandle, ClipFilesItem

                    call 'USER32.DeleteMenu' D$MenuHandle, M00_ClipFile, &MF_BYCOMMAND
                End_If
            .End_If

        ..End_If

    ...End_If
L9: ret
____________________________________________________________________________________________


SetShiftBlock:
    mov eax D$CaretRow, ebx D$CaretLine
    push eax, ebx

        call SearchTxtPtr               ; >>> eax = new Pos.

        .If B$BlockInside = &FALSE
            If eax > D$ShiftDown
                dec eax
            End_If

        .Else
            If eax = D$ShiftDown
                mov B$BlockInside &FALSE | jmp L9>
            Else_If eax > D$ShiftDown
                dec eax
            End_If

        .End_If

        If eax < D$ShiftDown
            move D$BlockStartTextPtr eax, D$BlockEndTextPtr D$ShiftDown
            dec D$BlockEndTextPtr
        Else
            move D$BlockStartTextPtr D$ShiftDown, D$BlockEndTextPtr eax
        End_If

        mov B$BlockInside &TRUE, B$ShiftBlockInside &TRUE

L9: pop D$ShiftBlockLine, D$ShiftBlockCol
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

SplashScreen:
    call 'USER32.BeginPaint' D$EditWindowHandle, PAINTSTRUCT | mov D$hdc eax

    call 'User32.GetClientRect' D$EditWindowHandle, RECT

    shr D$RECTright 1 | shr D$RECTbottom 1
    sub D$RECTright 75 | sub D$RECTbottom 75

    call 'USER32.LoadBitmapA' D$hInstance, 5 | mov D$BitMapHandle eax

    call 'GDI32.CreateCompatibleDC' D$hdc | mov D$hMemDC eax

    call 'GDI32.SelectObject' eax, D$BitMapHandle

    call 'GDI32.BitBlt' D$hdc, D$RECTright, D$RECTbottom, 150, 150,
                        D$hMemDC, 0, 0, &SRCCOPY

    call 'GDI32.DeleteDC' D$hMemDC

    call 'GDI32.DeleteObject' D$BitMapHandle

    call 'USER32.EndPaint' D$EditWindowHandle, PAINTSTRUCT
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  BackUps.
;;

____________________________________________________________________________________________
____________________________________________________________________________________________






TITLE MRU
____________________________________________________________________________________________
____________________________________________________________________________________________

;                            Most Recently Used Files job.
____________________________________________________________________________________________
____________________________________________________________________________________________

[MRU1: B$ ? #260][MRU2: B$ ? #260][MRU3: B$ ? #260][MRU4: B$ ? #260]


; Adds the menu Items in [File] Popup, between [OutPut] and [Exit]:

[FilePopUpHandle: ?    AddedMRUitems: ?]

SetMRUmenu:
    call DeleteMRUmenu

    If D$MRU1 > 0
        call 'USER32.InsertMenuA' D$FilePopUpHandle, M00_Exit, &MF_BYCOMMAND, 3001, MRU1
        inc D$AddedMRUitems
    End_If
    If D$MRU2 > 0
        call 'USER32.InsertMenuA' D$FilePopUpHandle, M00_Exit, &MF_BYCOMMAND, 3002, MRU2
        inc D$AddedMRUitems
    End_If
    If D$MRU3 > 0
        call 'USER32.InsertMenuA' D$FilePopUpHandle, M00_Exit, &MF_BYCOMMAND, 3003, MRU3
        inc D$AddedMRUitems
    End_If
    If D$MRU4 > 0
        call 'USER32.InsertMenuA' D$FilePopUpHandle, M00_Exit, &MF_BYCOMMAND, 3004, MRU4
        inc D$AddedMRUitems
    End_If

  ; Separator:
    If D$MRU1 > 0
        call 'USER32.InsertMenuA' D$FilePopUpHandle, M00_Exit, &MF_BYCOMMAND__&MF_SEPARATOR, 0 0
        inc D$AddedMRUitems
    End_If
ret


DeleteMRUmenu:
    call 'USER32.GetSubMenu' D$MenuHandle 0 | mov D$FilePopUpHandle eax
    While D$AddedMRUitems > 0
        call 'USER32.DeleteMenu' D$FilePopUpHandle, 16, &MF_BYPOSITION
        dec D$AddedMRUitems
    End_While
ret


; Push down (out) one MRU record to make leading room for a new File:

PushOneMRUrecordDown:
    mov esi MRU3, edi MRU4, ecx,(260*3)
    add esi 259 | add edi 259
    std | rep movsb | cld
ret

;;
 The recently saved file was already in the MRU list, but not in first Pos. We
 reorganise the List. Before calling, 'RecordMRU' Routine set esi to 'DestinationFile'
 and edi to MRU1/2/... We reuse 'DestinationFile', just in case the Name Cases would
 have been changed by user in between. So, at first, we arase the old record (this
 let room in first Pos). I do not use directely 'DestinationFile', but edi, instead,
 in case this function would be extended in the futur.
;;
RePosMRU:
    push esi, edi
      ; First arase the record at edi:
        std
            mov esi edi | add edi 259 | dec esi
            mov ecx esi | sub ecx MRU1
            rep movsb
        cld
    pop edi, esi
  ; then write new record at first Pos:
    mov edi MRU1, ecx 260 | rep movsb
ret

;;
  Adding a new File in the MRU List if it is not already inside, or update the range
  if already there. The file is the last compiled one ('DestinationFile').
;;
RecordMRU:
    mov esi DestinationFile | call CheckMRUFile
    mov ecx DestinationFile | While B$ecx <> 0 | inc ecx | End_While
    sub ecx DestinationFile

    mov esi DestinationFile
    push esi, ecx
        mov edi MRU1 | repe cmpsb | je L9>
L1: pop ecx, esi

    push esi, ecx
        mov edi MRU2 | repe cmpsb | jne L1>
            mov edi MRU2 | jmp L8>
L1: pop ecx, esi

    push esi, ecx
        mov edi MRU3 | repe cmpsb | jne L1>
            mov edi MRU3 | jmp L8>
L1: pop ecx, esi

    push esi, ecx
        mov edi MRU4 | repe cmpsb | jne L1>
            mov edi MRU4 | jmp L8>
  ; If here, it is a new file name:
L1: pop ecx, esi

    call PushOneMRUrecordDown
    mov esi DestinationFile, edi MRU1, ecx 260 | rep movsb | call SetMRUmenu | ret

  ; If here, the File is already Listed, but not at first Pos:
L8: pop ecx, esi
    call RePosMRU | call SetMRUmenu | ret

  ; If here, the File is already Listed at first Pos >>> OK, exit:
L9: pop ecx, esi | ret


; Arase one record if the File do not exist (example, if user deleted the file):

[CheckMRUpointer: ?]

CheckMRUFile:
    mov D$CheckMRUpointer esi
    call 'KERNEL32.FindFirstFileA' esi, FindFile
    push eax

        .If eax = &INVALID_HANDLE_VALUE
            mov eax 0, esi D$CheckMRUpointer, edi esi | add esi 260
            mov ecx MRU4 | sub ecx edi
            jecxz L1>
                rep movsb
L1:         mov ecx 260, al 0 | rep stosb

        .Else                                           ; All this is only to retrieve
            mov edi D$CheckMRUpointer                   ; the Name case (upper/lower),
            mov al 0, ecx 0-1 | repne scasb | dec edi   ; in case the user modified it
            mov esi FindFile.cFileName, ecx 0           ; since last session.
            While B$esi <> 0
                inc ecx | inc esi
            End_While
            sub edi ecx
            mov esi FindFile.cFileName | rep movsb

        .End_If

    pop eax | On eax <> &INVALID_HANDLE_VALUE, call 'KERNEL32.FindClose' eax
ret


CheckAllMRUFile:
    mov esi MRU1 | call CheckMRUFile
    mov esi MRU2 | call CheckMRUFile
    mov esi MRU3 | call CheckMRUFile
    mov esi MRU4 | call CheckMRUFile
ret


[MRUfileHasBeenDeleted: 'This File has been deleted or renamed Since last MRU update', 0]

[SelectedMRUFileName: B$ ? #260]

; Called from Main Message Loop with Menu ID in eax.

LoadRMUfile:
    push eax
        If eax = 3001
            mov esi MRU1
        Else_If eax = 3002
            mov esi MRU2
        Else_If eax = 3003
            mov esi MRU3
        Else_If eax = 3004
            mov esi MRU4
        End_If

        mov edi SelectedMRUFileName, ecx 260 | rep movsb

        call CheckAllMRUFile | call SetMRUmenu
        call ReInitUndo
    pop eax

    If eax = 3001
        mov esi MRU1
    Else_If eax = 3002
        mov esi MRU2
    Else_If eax = 3003
        mov esi MRU3
    Else_If eax = 3004
        mov esi MRU4
    End_If

    push esi
        mov edi SelectedMRUFileName, ecx 260 | rep cmpsb | je L1>
            mov eax MRUfileHasBeenDeleted | call MessageBox | pop esi | mov eax &FALSE | ret
L1: pop esi

    mov edi SaveFilter, ecx 260 | rep movsb

    mov edi SaveFilter
    While B$edi <> 0 | inc edi | End_While
    While B$edi <> '\' | dec edi | End_While

    push D$edi, edi
        mov B$edi 0
        call 'KERNEL32.SetCurrentDirectoryA' SaveFilter  ; says TRUE.
    pop edi, D$edi

    If eax = &TRUE
        call DirectMRUload
        call UpdateTitlesFromIncludeFiles
        call AskForRedraw
        mov eax &TRUE
    End_If
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
; Loading the last MRU File on Startup, if 'LoadMRU' Flag is set On.

[LoadMRU: ?]

LoadLastMRUFile:
    .If D$MRU1 <> 0
        StoreNameOnly MRU1

        mov esi MRU1, edi SaveFilter
        While B$esi <> 0 | movsb | End_While

        call LastMRULoading

        If D$SourceLen > 0
            call SetPartialEditionFromPos | call EnableMenutems
            call LoadBookMarks
        End_If

    .End_If
ret
;;
____________________________________________________________________________________________
____________________________________________________________________________________________


  ; Loading the last MRU File on Startup, if 'LoadMRU' Flag is set On.
; RWE1 start of drag and drop modification
[LoadMRU: ?]

LoadLastMRUFile:
    call ProcessCL
  ; eax returned pointing to command line filename in CLbuffer:
  ;showme eax
    ..If eax = 0
        .If D$MRU1 <> 0 ; Do this if no command line parameters i.e. no drag and drop file
            StoreNameOnly MRU1 ; Do this if 'autoreload last file on start up' selected

            mov esi MRU1, edi SaveFilter
            While B$esi <> 0 | movsb | End_While ; string MRU1 saved to Savefilter

            call LastMRULoading

            If D$SourceLen > 0 ; If the file includes assembly language source
                call SetPartialEditionFromPos | call EnableMenutems
                call LoadBookMarks
            End_If

        .End_If
    ..Else
        StoreNameOnly CLBuffer ; Do this if e.g. a file has been drag / dropped onto RosASM icon

        mov esi CLBuffer, edi SaveFilter
        While B$esi <> 0 | movsb | End_While ; string MRU1 saved to Savefilter

        call LastMRULoading

        If D$SourceLen > 0 ; If the file includes assembly language source
            call SetPartialEditionFromPos | call EnableMenutems
            call LoadBookMarks
        End_If
    ..End_If
ret

______________________________________________________________________________________________________________________________________________

[CLBuffer : B$ 0 #&MAXPATH] ; Stores any filename drag and dropped to RosASM icon on desktop

ProcessCL:
    call 'Kernel32.GetCommandLineA'
    mov edx eax, edi eax, ecx 0FF, al 0 | repne scasb
    mov esi edi, edi CLBuffer

    .While esi > edx
        dec esi
        .If B$esi = '"'
            dec esi
            While B$esi <> '"' | dec esi | End_While
            mov eax edi
            If esi <> edx
                inc esi | While B$esi <> '"' | movsb | End_While
            Else
                mov eax 0
            End_If
            mov B$edi 0 | ret

        .Else_If B$esi = '.'
            While B$esi <> ':' | dec esi | End_While
            dec esi | mov eax edi
            While B$esi <> 0 | movsb | End_While
            mov B$edi 0 | ret

        .End_If
    .End_While

    mov eax 0
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[ActualDir: B$ ? #&MAXPATH] [ActualDirPointer: ?]
[DllScannerDir: B$ ? #&MAXPATH]

Proc GetDirectory:
    Argument @Dir

        call 'KERNEL32.GetCurrentDirectoryA' &MAXPATH, D@Dir
EndP


Proc SetDirectory:
    Argument @Dir

        mov eax D@Dir | On D$eax <> 0, call 'KERNEL32.SetCurrentDirectoryA' D@Dir
EndP




TITLE Status
____________________________________________________________________________________________
____________________________________________________________________________________________

;                                   Status Bar Job.
;
; Mainly done by Pit (Peter Tuente).
____________________________________________________________________________________________
____________________________________________________________________________________________

[StatusbarHandle: ?    OnStatusBar: ?]

[STATUSBAR_ID 999]

[StatusPartsPos: 0 100 200 300 400 500 600 700 800 900 1000]

[SbLine: ? #10]
[SbLineTotalLineText: B$ ' Total Lines', 0
 SbLineOctetsText:       ' Bytes', 0
 SbLineModified:         'Modified', 0
 SbLineUnModified:       'Ready to Run', 0
 SbLineLinePos:          'Line: '
 SbLineLinePosNumber:    '           '
 SbLineRowPos:           'Row: '
 SbLineRowPosNumber:     '           '
 SbF9Off:                '[F9] Inspector Off', 0
 SbF9On:                 '[F9] Inspector On', 0 ]
[SbLine2: '12345', 0]


; > input: eax = Number / edi = String Pointer

FromBinaryToDecimalAscii:
    If eax = 0
        mov B$edi '0', B$edi+1 0 | ret
    Else
        mov ecx 10, edx 0-1
L0:     push edx | mov edx 0 | div ecx | cmp eax 0 | ja L0<
        mov al dl
L0:     add eax '0' | stosb | pop eax | cmp eax 0-1 | jne L0<
        mov al 0 | stosb
    End_If
ret


SbLineAppend:
    mov edi sbLine, al 0, ecx 40 | repne scasb | dec edi
    While B$esi <> 0
        movsb
    End_While
    mov al 0 | stosb
ret

____________________________________________________________________________________________

[PointZeroed: ?]

StatusBar:
    mov eax D$CaretRowValue | shr eax 3 | add eax D$RightScroll | mov D$StatusCol eax

  ; Name of the File, or of the TITLE:
    mov esi D$ActualTitle

    ..If esi <> 0
        On D$esi <> 'TITL', jmp L2>>

        While B$esi > ' ' | inc esi | End_While
        While B$esi = ' ' | inc esi | End_While
        mov edi esi
        While B$edi > ' ' | inc edi | End_While
        push D$edi, edi
            mov B$edi 0
            call 'USER32.SendMessageA' D$StatusbarHandle, &SB_SETTEXT, 1, esi
        pop edi, D$edi
    ..Else
      ; eax: Simple flag for '.', because under some OS the .ext may be missing:
        mov eax &FALSE, B$PointZeroed &FALSE
        mov esi SaveFilter | On D$esi = 0, ret

        While B$esi <> 0 | inc esi | End_While
        While B$esi-1 <> '\'
            dec esi | On esi = SaveFilter, jmp L1>
            .If B$esi = '.'
                If B$PointZeroed = &FALSE
                    push D$esi, esi
                    mov B$esi 0
                    mov eax &TRUE, B$PointZeroed &TRUE
                End_If
            .End_If
        End_While
L1:     push eax
            call 'USER32.SendMessageA' D$StatusbarHandle, &SB_SETTEXT, 1, esi
        pop eax
        If eax = &TRUE
            pop edi, D$edi
        End_If
    ..End_If
L2:
  ; Total Number of Sources Lines:
    mov eax D$TotalNumberOfLines, edi SbLine | call FromBinaryToDecimalAscii
    mov esi SbLineTotalLineText | call SbLineAppend
    call 'USER32.SendMessageA' D$StatusbarHandle &SB_SETTEXT 2 SbLine

  ; Total Number of Bytes:
    mov eax D$SourceEnd | sub eax D$CodeSource
    mov edi SbLine | call FromBinaryToDecimalAscii
    mov esi SbLineOctetsText | call SbLineAppend
    call 'USER32.SendMessageA' D$StatusbarHandle &SB_SETTEXT 3 SbLine

  ; Line Pos:
    mov eax D$StatusLine, edi SbLineLinePosNumber | call FromBinaryToDecimalAscii
    call 'USER32.SendMessageA' D$StatusbarHandle, &SB_SETTEXT, 4, SbLineLinePos

  ; Row Pos:
    mov eax D$StatusCol, edi SbLineRowPosNumber | call FromBinaryToDecimalAscii
    call 'USER32.SendMessageA' D$StatusbarHandle, &SB_SETTEXT, 5, SbLineRowPos

  ; Source modified of ready to run:
    If B$ReadyToRun = &TRUE
        call 'USER32.SendMessageA' D$StatusbarHandle &SB_SETTEXT 6 SbLineUnModified
    Else
        call 'USER32.SendMessageA' D$StatusbarHandle, &SB_SETTEXT, 6, SbLineModified
    End_If
ret


[ModifiedRect: ? ? ? ?]














TITLE Tab
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
                  Main Editor's Upper Tab Control for TITLEd Chapters.

 When working with enTITLEd Sources, The Editor Copy/Paste the Actually edited Part
 at the very end of the Source Memory. Each time a new Part is activated, the previous
 one is copied back to its own room, and the new selected part is copied down in turn.

 At each event, a 'TitleTable' is build. This Table holds nothing but the Addresses
 of each 'TITLE' inside the Source.

 During Partial Edition, the Partial Source is substituted to the real Source. This
 means that all the KeyBoard features work like if the whole Source was nothing but
 the Partial Source. The modified behaviours are:

 * All KeyBoard actions (example: [Ctrl][PgDwn/PgUp] are limited to the Actual Part).
 * The ScrollBar, if any.
 * The Status Bar, if any.
 * The [Ctrl][S] feature is added a Dialog to choose between Whole/Part Saving.

 All of the Search Features (Right-Click / Tree View / SearchBox / ...) work the
 same as without TITLEs (upon the real whole Source).

 The goals of the feature are:

 * To make Part savings easier (for example, for reuse of wide Chuncks).
 * To accelerate the Source Editor, which, with uge Sources (1 Mega and more) may
   become slow on older Computers.
 * To make easy uge Source reorganisations.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[TITLE_TC_ITEM:
 TITLE_TC_ITEM_imask: D$ &TCIF_TEXT__&TCIF_IMAGE
 TITLE_TC_ITEM_lpReserved1: D$ 0
 TITLE_TC_ITEM_lpReserved2: D$ 0
 TITLE_TC_ITEM_pszText: D$ 0
 TITLE_TC_ITEM_cchTextMax: D$ 0
 TITLE_TC_ITEM_iImage: D$ 0-1
 TITLE_TC_ITEM_lParam: D$ 0]

SetPartialEditionFromPos:
    On D$PreviousPartialSourceLen <> 0, ret

SetPartialEdition:
; Called when opening a new File, or by 'TitleWindowProc' (on user Tab Selection).
    call BuildTitleTable

    If D$TiTleTable <> 0
        call GetActualPartFromPos | call SetActualPartFromPos
    End_If

    mov D$PreviousUpperLine 0-1 ; (To force remaping the Source Editor Colors)

    call AskForRedraw

    mov B$RealSourceRestored &FALSE
ret


SetPartialEditionFromPosNoRedraw:
    On D$PreviousPartialSourceLen <> 0, ret

; Called when opening a new File, or by 'TitleWindowProc' (on user Tab Selection).
    call BuildTitleTable

    If D$TiTleTable <> 0
        call GetActualPartFromPos | call SetActualPartFromPos
    End_If

    mov D$PreviousUpperLine 0-1

    mov B$RealSourceRestored &FALSE
ret


; 'Called by 'ControlZ'.

UndoTitleMove:
    push D$CaretRow D$CaretLine D$CurrentWritingPos D$UpperLine
    push ebx
        call RestoreRealSource | call BuildTitleTable
    pop ebx
    mov eax D$TitleTable+ebx*4, D$CurrentWritingPos eax
    call GetActualPartFromPos | call SetActualPartFromPos

    mov ebx D$UndoPtr | sub bx 32 | mov esi ebx
    If D$esi+(7*4) <> 0
        lodsd | mov D$CaretRow eax
        lodsd | mov D$CaretLine eax
        lodsd | add eax D$CodeSource | mov D$CurrentWritingPos eax
        lodsd | add eax D$CodeSource | mov D$UpperLine eax
        pop eax, eax, eax, eax
    Else
        pop D$UpperLine D$CurrentWritingPos D$CaretLine D$CaretRow
    End_If
ret


[AddedSize: ?]
[RealSourceRestored: ?]

RestoreRealSource:                      ; Called only by 'UndoTitleMove'
    On D$PreviousPartialSourceLen = 0, ret

   ; call DeleteUndoFiles
   ; call KillUndo
   ; call InitUndo

    mov eax D$SourceEnd
    If W$eax-2 <> CRLF
        add D$SourceEnd 2 | add D$SourceLen 2
    End_If

    mov eax D$SourceLen | sub eax D$PreviousPartialSourceLen
    mov D$AddedSize eax

  ; Move down (as many 'AddedSize') from Top of Actual Source Part to
  ; End of Actual Edition, to make room:
    .If eax = 0
        mov edi D$ActualTitle, esi D$CodeSource, ecx D$SourceLen
        rep movsb

    .Else_If eax g 0                ; Positive Number.

        mov esi D$SourceEnd         ; End of Partial Edition
        mov edi esi | add edi D$AddedSize
        mov ecx esi | sub ecx D$NextTitle | inc ecx
      ; ecx = length from Source-Next-Title to End-of-Partial-Edition
        std
            rep movsb
        cld
        mov esi D$CodeSource, edi D$ActualTitle
        add esi D$AddedSize         ; equal to the made up room
        mov ecx D$SourceLen | rep movsb

    .Else                           ; Negative Number.
        mov esi D$CodeSource, edi D$ActualTitle
        mov ecx D$SourceLen | jecxz L0>
            rep movsb
L0:     mov esi D$NextTitle
        mov ecx D$CodeSource | sub ecx D$NextTitle | rep movsb

    .End_If

    mov eax D$CurrentWritingPos
    If eax = D$SourceEnd
L0:     dec eax | cmp B$eax ' ' | jb L0<
    End_If

    sub eax D$CodeSource
    add eax D$ActualTitle | mov D$CurrentWritingPos eax

    mov eax D$ActualTitle | sub eax D$CodeSource    ; eax = adjustement to new Pos.

    add D$UpperLine eax

    If B$BlockInside = &TRUE
        add D$BlockStartTextPtr eax
        add D$BlockEndTextPtr eax
    End_If

    move D$CodeSource D$RealCodeSource
    move D$SourceEnd D$RealSourceEnd
    move D$SourceLen D$RealSourceLen
    mov eax D$AddedSize | add D$SourceEnd eax | add D$SourceLen eax

    mov D$PreviousPartialSourceLen 0

    mov B$RealSourceRestored &TRUE
ret


; Called when Mouse outside User area.

ShowTitles:
    call RestoreRealSource | call BuildTitleTable

    If D$TitleTable > 0
        call CreateTitleTab | call ShowTitleTab | call SetActualTitle

        On B$BlinkingCaretWanted = &TRUE, call KillBlinkCursor
    End_If

    call SetPartialEditionFromPos
ret


[NumberOfTitles: ?   PreviousNumberOfTitles: ?]

BuildTitleTable:
    mov edi D$CodeSource, ecx D$SourceLen, ebx TitleTable
    mov B$edi-1 LF

    move D$PreviousNumberOfTitles D$NumberOfTitles
    mov D$NumberOfTitles 0

L0: mov al 'T'

L1: repne scasb | jne L9>>

        cmp D$edi 'ITLE' | jne L1<
            cmp B$edi+4 ' ' | ja L1<
                cmp B$edi-2 LF | jne L1<

              ; If the first 'TITLE' is not Top-of-File, set one now:
                .If ebx = TitleTable
                    mov eax edi | dec eax
                    If eax > D$CodeSource
                        move D$TitleTable D$CodeSource | add ebx 4
                        inc D$NumberOfTitles
                    End_If
                .End_If

                If ebx > TitleTable
                    call TitleSize | jna L2>
                End_If

                mov eax edi | dec eax | mov D$ebx eax
                add ebx 4
                inc D$NumberOfTitles
                If ebx = TitleTableEnd
                    call 'USER32.MessageBoxA', 0, {'Too many TITLEs', 0},
                                                  {'BuildTitleTable', 0}, 0
                    sub ebx 4
                End_If

L2:             On ecx > 0, jmp L0<<

L9: mov D$ebx 0     ; 'TitleTable' End Mark.

  ; In case when Only one valid TITLE is found, we run no TITLE:
    If D$TitleTable > 0
        On D$TitleTable+4 = 0, mov D$TitleTable 0
    End_If

    mov eax D$NumberOfTitles
    If eax <> D$PreviousNumberOfTitles
        call KillUndo | call InitUndo
    End_If
ret

; If the TITLE too smaller for the screen, skip over:

TitleSize:
    push ecx
        mov esi D$ebx-4 ; previous Title Pos.
        mov ecx 0
        while esi < edi
            On B$esi = CR, inc ecx
            inc esi
        End_While
        cmp ecx D$LineNumber
    pop ecx
ret

____________________________________________________________________________________________
;;
 Partial Edition is done inside the 1_000_000 Octets reserved space that
 RosAsm always sets at the end of User Source. In case User would be
 dividing for the first time a very uge source, and, for example, write
 only one TITLE statement at the Top of Source, and then try to see what
 happends by moving the mouse outside the Client Area, the Partial Edition
 would be unable to copy Megas inside the reserved space. In such cases,
 we abort, and wait until user cut the Source in smaller parts, with
 more TITLES.
;;

[TooLongTitle: 'Part too long:', 0]

[TITLE_MAX 1_000_000]


; Sets the Actual Part Variables, depending on the Writing Position.

[ActualTiTle: ?    NextTitle: ?    PreviousPartialSourceLen: ?
 ActualPartIndex: ?    PreviousPartIndex: ?]

GetActualPartFromPos:
    mov esi TiTleTable, ebx D$CurrentWritingPos, eax D$TiTleTable, edx 0
    mov D$ActualTitle eax | move D$NextTitle D$esi+4

    mov D$ActualPartIndex 0-2
  ; 0-2 because Tab Index are zero based (> -1) and because we are
  ; INCreasing until *next* Title found (> -1)

    While eax <= ebx
        inc D$ActualPartIndex
        mov edx eax | lodsd | On eax = 0, jmp L1>
    End_While

L1: On edx = 0, mov edx D$TiTleTable, eax D$TiTleTable+4
    On eax = 0, mov eax D$SourceEnd

    mov D$ActualTitle edx, D$NextTitle eax
ret
____________________________________________________________________________________________

;;
 The Code Source is always followed by 200 CR/LF (security) + 1_000_000
 octets reserved for Editing. We set the Partial Edition after the 200
 CR/LF.
;;

[RealCodeSource: ?    RealSourceEnd: ?    RealSourceLen: ?]

SetActualPartFromPos:
    On D$TiTleTable = 0, ret

    move D$RealCodeSource D$CodeSource
    move D$RealSourceEnd D$SourceEnd
    move D$RealSourceLen D$SourceLen

    mov edi D$SourceEnd | add edi 400
    mov D$CodeSource edi
    mov esi D$ActualTitle, ecx D$NextTitle | sub ecx esi

    mov D$PreviousPartialSourceLen ecx, D$SourceLen ecx
    mov D$SourceEnd edi | add D$SourceEnd ecx | rep movsb
    mov eax 0A0D0A0D, ecx 100 | rep stosd

    mov eax D$CodeSource | sub eax D$ActualTiTle  ; eax = Displacement.

    add D$CurrentWritingPos eax | add D$UpperLine eax

    If B$BlockInside = &TRUE
        add D$BlockStarttextPtr eax | add D$BlockEndTextPtr eax
        move D$CurrentWritingPos D$BlockEndTextPtr
        call SetCaret D$CurrentWritingPos
    End_If

  ; If user add or suppress a TITLE statement in the Partial Edition;
  ; all these Pointers are wrong. We reset at Top of Part:
    mov eax D$CurrentWritingPos
    If eax >= D$SourceEnd
L1:     move D$CurrentWritingPos D$CodeSource
        move D$UpperLine D$CodeSource
        mov B$BlockInside &FALSE | jmp L9>>
    Else_If eax < D$CodeSource
        jmp L1<
    End_If

    mov eax D$UpperLine
    If eax >= D$SourceEnd
        jmp L1<
    Else_If eax < D$CodeSource
        jmp L1<
    End_If
ret
____________________________________________________________________________________________

KillTitleTab:
    call 'USER32.DestroyWindow' D$TitleWindowHandle | mov D$TitleWindowHandle 0

    On B$BlinkingCaretWanted = &TRUE, call InitBlinkCursor
ret


SetActualTitle:
    call 'User32.SendMessageA' D$TitleWindowHandle, &TCM_SETCURSEL, D$ActualPartIndex, 0
    call 'USER32.ShowWindow' D$TitleWindowHandle, &SW_SHOW
ret


[MAXTITLE 100]
[TitleIndex: ?] [ TiTleTable: ? #MAXTITLE] [TitleTableEnd: ?]
[DefaultTopTitle: 'Top', 0]

[TabRECT: TabRECT.left: D$ 0,  TabRECT.top: D$ 0
          TabRECT.right: D$ 0, TabRECT.bottom: D$ 0]

[ClientToScreenPoint: ? ?]

; One TiTleTable Record is: dWord = Top of Part Pointer
; (>>> "TITLE TitleName")

ShowTitleTab: ; CreateTitleTab
    mov esi TitleTable, D$TitleIndex 0

  ; Add a [Top] Tab Item if user did not.
    mov eax D$esi
    If D$eax <> 'TITL'
        mov D$TITLE_TC_ITEM_pszText DefaultTopTitle
        push esi
            call 'User32.SendMessageA' D$TitleWindowHandle, &TCM_INSERTITEM,
                                       D$TitleIndex, TITLE_TC_ITEM
        pop esi
        inc D$TitleIndex
        move D$TiTleTable D$CodeSource | add esi 4
        On esi = TitleTableEnd, sub esi 4
    End_If

L0: lodsd | cmp eax 0 | je L9>>

    While B$eax = ' ' | inc eax | End_While  ; jump over 'TITLE'.
    While B$eax > ' ' | inc eax | End_While
    mov ebx eax | add ebx 20
    mov D$TITLE_TC_ITEM_pszText eax
    While B$eax = ' '
        inc eax | On eax > ebx, jmp L1>
    End_While

  ; Search for end of 'TitleName', to write a zero, in user source.
    While B$eax > ' '
        inc eax | On eax > ebx, jmp L1>
    End_While
L1: push D$eax, eax, esi
        mov B$eax 0

        call 'USER32.SendMessageA' D$TitleWindowHandle, &TCM_INSERTITEM,
                                   D$TitleIndex, TITLE_TC_ITEM
        inc D$TitleIndex
    pop esi, eax, D$eax
    jmp L0<<

  ; This first 'MoveWindow' is to ensure that the Tab Control has the Width of the
  ; Window, before asking for how many Tab Rows:
L9: move D$TabWindowX D$EditWindowX, D$TabWindowY D$EditWindowY,
         D$TabWindowW D$EditWindowW, D$TabWindowH D$EditWindowH

         move D$TabWindowY D$EditWindowH

    call 'USER32.MoveWindow' D$TitleWindowHandle,
                             D$TabWindowX, D$TabWindowY, D$TabWindowW, D$TabWindowH,
                             &FALSE

  ; Get the hight of _one_ Tab, inside the Tabbed Control:
    call 'USER32.SendMessageA' D$TitleWindowHandle, &TCM_GETITEMRECT, 0, TabRECT
    mov eax D$TabRECT.bottom | sub eax D$TabRECT.top | inc eax

    push eax
        call 'USER32.SendMessageA' D$TitleWindowHandle, &TCM_GETROWCOUNT, 0, 0
    pop ecx

  ; Now: ecx = Hight of a Tab // eax Number of Rows
    mul ecx | mov D$TitleTabHight eax

    call 'USER32.GetSystemMetrics' &SM_CYDLGFRAME | shl eax 1 | add eax 4
    add D$TitleTabHight eax

    mov eax D$TabWindowH | sub eax D$TitleTabHight | mov D$TabWindowY eax

    move D$TabWindowH D$TitleTabHight

    move D$ClientToScreenPoint 0, D$ClientToScreenPoint+4 0

    call 'USER32.ClientToScreen' D$BpWindowHandle, ClientToScreenPoint

    mov eax D$ClientToScreenPoint | add D$TabWindowX eax
    mov eax D$ClientToScreenPoint+4 | add D$TabWindowY eax
    mov eax D$BpMarginWidth | sub D$TabWindowX eax | add D$TabWindowW eax

    call 'USER32.MoveWindow' D$TitleWindowHandle,
                             D$TabWindowX, D$TabWindowY, D$TabWindowW, D$TabWindowH,
                             &FALSE

  ; Set 'TabWindowY' to 'hwnd' coordinates, for firing 'KillTitleTab' on &WM_MOUSEMOVE:
    call 'USER32.ScreenToClient' D$hwnd, TabWindowX

  ; Adjust the "Dead-Point" if the ToolBar is [On]:
    If B$ToolBarWanted = &TRUE
        mov eax D$ToolBarPixelsHight | sub D$TabWindowY eax
    End_If
ret

[TabWindowX: ?  TabWindowY: ?  TabWindowW: ?  TabWindowH: ?]

[ErrorInTab: 'Error in Tab Building:', 0
 MoreThanFive: 'More than 5 Rows encounted', 0
 ZeroTabRow:   'Zero Tab Row...', 0
 BadTabWidth: 'Bad Tab Width', 0]


[TitleWindowHandle: 0    TitleTabHight: 60    TitleFontHandle: 0
 TitleTabWindowTitle: 'SysTabControl32' 0]

;[TITLEWINDOWSTYLE &TCS_MULTILINE__&TCS_BUTTONS__&TCS_HOTTRACK__&TCS_TOOLTIPS__&WS_DLGFRAME__&WS_VISIBLE]
[TITLEWINDOWSTYLE &TCS_MULTILINE__&WS_VISIBLE__&TCS_BUTTONS__&TCS_HOTTRACK]

CreateTitleTab:
    call 'USER32.CreateWindowExA' 0, TitleTabWindowTitle, &NULL,
                                  TITLEWINDOWSTYLE, 0, 0, 0, 0,
                                  D$hWnd, &NULL, D$hInstance, &NULL

    mov D$TitleWindowHandle eax

    call 'USER32.GetWindowLongA' D$TitleWindowHandle, &GWL_STYLE
    and eax (not &WS_CAPTION)
    call 'USER32.SetWindowLongA' D$TitleWindowHandle, &GWL_STYLE, eax

    On D$TitleFontHandle = 0, call CreateFontForTitles
    call 'User32.SendMessageA' D$TitleWindowHandle, &WM_SETFONT, D$TitleFontHandle, &FALSE

    call 'USER32.SetWindowLongA' D$TitleWindowHandle, &GWL_WNDPROC, TitleWindowProc
    mov D$OriginalTitleBarProcedure eax
ret


CreateFontForTitles:
  call 'GDI32.CreateFontA' 8 4 0 0 400 0 0 0  1,   ;  DEFAULT_CHARSET 1  OEM_CHARSET 255
                       0 0 0 0 Helv
  mov D$TitleFontHandle eax
ret


[OriginalTitleBarProcedure: ?]

Proc TitleWindowProc:
    Arguments @Adressee, @Message, @wParam, @lParam

        On B$SourceReady = &FALSE, jmp L8>>

L8:     call 'USER32.CallWindowProcA' D$OriginalTitleBarProcedure,
                                      D$TitleWindowHandle,
                                      D@Message, D@wParam, D@lParam

; Make sure that something would likely work under whatever OS version.
; But makes it as short as possible, because this is re-intrant with...
; here! Risks of Stack overflow, with the Tab Messages.
        ...If D@Message >= &WM_MOUSEFIRST
            ..If D@Message =< &WM_MOUSELAST ; (0209) // &WM_CAPTURECHANGED (0215)
                pushad
                    call 'User32.SendMessageA' D$TitleWindowHandle, &TCM_GETCURSEL, 0, 0
                    If eax <> D$ActualPartIndex
                        mov B$BlockInside &FALSE
                        push eax
                            call RestoreRealSource
                        pop eax
                        mov D$ActualPartIndex eax
                        move D$CurrentWritingPos D$TitleTable+eax*4
                        call SetPartialEdition
                        call AskForRedrawNow
                    End_If
                popad
            ..End_If
        ...End_If
EndP













TITLE Main
 _______________________________________________________________________________________
 _______________________________________________________________________________________


[WindowX: 5  WindowY: 2  WindowW: 790  WindowH: 595
 SaveMainPosFlag: 0  IsMaximizedFlag: &SW_SHOWNORMAL]

[ListEditRect: ListERX:0   ListERY: 0   ListERW:0   ListERH: 0]
[WindowStyle: &WS_OVERLAPPEDWINDOW
 WindowExStyle: &WS_EX_CLIENTEDGE]
[MenuHandle: 0    ScrollBarWanted: &TRUE]

[FindString: 'commdlg_FindReplace' 0  FindStringMessage: 0]

[RosAsmMutexName: B$ 'RosAsmIsRuning', 0   MultiInstance: &FALSE]

[ClassName: B$ 'RosAsmWindowClass' 0   EditClassName: 'EDIT' 0
 AppName: '  RosAsm, The Bottom-Up Assembler for ReactOS -V.2.051b-' 0]


[WndClassEx:
 wc_Size: len         wc_style: 11      WndProc: MainWindowProc   wc_ClsExtra: 0
 wc_WndExtra: 0       wc_hInstance: 0   wc_hIcon: 0               wc_hCursor: 0
 wc_hbrBackground: &COLOR_SCROLLBAR+1 ; 6
 wc_MenuName: 0    wc_ClassName: ClassName   wc_hIconSm: 0]

[Bp_hCursor: ?   ActualCursor: ?  WaitCursor: ?]
 __________________________________________________________________________________

; First message structure is for the main loop (Get-Translate-DispatchMessage)
; Second is for Callback. They can't be only one because Wparam for ExitProcess is
; not the same as Wparam previously stored for CallBack.

[FirstMsg: FAdressee: ?  FuMsg: ?  FWparam: ?  FLparam: ?  FTime: ?  FPoint: ? ?]

[hInstance: ?  hwnd: ?  hwndEdit: ?  FindHandle: ?]

; For mem tests:

[Meminfo: ? #20]

GetMemory:
    call 'KERNEL32.GlobalMemoryStatus' Meminfo
    hexprint D$Meminfo+12
ret
 __________________________________


[UserHaveClickDown: B$ 0]

; (UserHaveClickDown flag is to prevent block drawing when back from 'OpenFileName' api
 __________________________________

; Accelerators:

; [DRAWLINE 628]

;;
ACCELNUMBER 2    FLAGLAST 080]

;  ;  01  070  03E8  00    ;03E8 > about ID  (F1)
;  ;  01  071  03F4  00    ;03F4 > Save ID   (F2)
;  ;  01  072  03EC  00    ;03EC > Open ID   (F3)
;  ; 090  078  03ED  00    ;03ED > Exit ID   (Alt-X)  78 > 'x'

; &FCONTROL  &FNOINVERT  &FSHIFT  &FVIRTKEY  &FALT

[ACCELERATORS:
 U$ &FVIRTKEY__&FNOINVERT                        &VK_F1    M00_RosAsm
    &FVIRTKEY__&FCONTROL__&FNOINVERT+FLAGLAST    &VK_8     DRAWLINE]
;;

[IncludesOK: ?  RichEditHandle: ?]

Main:
  ; For the Resurces Editor:
    call 'KERNEL32.LoadLibraryA' {'riched20.dll',0} | mov D$RichEditHandle eax

  ; Install exception handler
    call 'KERNEL32.SetUnhandledExceptionFilter' FinalExceptionHandler

  ; Ensure mono-instance:
    call 'KERNEL32.CreateMutexA' &NULL &TRUE RosAsmMutexName
    call 'KERNEL32.GetLastError'
    On eax = &ERROR_ALREADY_EXISTS, mov B$MultiInstance &TRUE

    call 'Kernel32.GetModuleHandleA' 0
      mov D$hInstance eax, D$wc_hInstance eax, D$OSSInstance eax,
          D$OPESInstance eax, D$BmOpenInstance eax

    call 'User32.LoadIconA' eax 1
    mov D$wc_hIcon eax, D$wc_hIconSm eax

    call 'User32.LoadCursorA' 0, &IDC_ARROW  | mov D$Bp_hCursor eax
    call 'User32.LoadCursorA' 0, &IDC_IBEAM | mov D$wc_hCursor eax
    mov D$ActualCursor eax
    call 'User32.LoadCursorA' 0, &IDC_WAIT | mov D$WaitCursor eax

    call WineKey
    call WhateverConfig

    mov D$WriteCheckerWanted 0 ; Temporary locked. ('WriteChecker' ---> toDo as a Hook).

    call ResetBackGroundColors | move D$wc_hbrBackground D$BackGroundBrushHandle

    call 'User32.RegisterClassExA' WndClassEx

    call 'User32.LoadMenuA' D$hInstance M00_Menu | mov D$MenuHandle eax

    call GetWheelInfo

    call AddUserMenu

    call NewBuildWin32Equates

    If B$IncludesOK = &TRUE
        On D$EquatesName = 'Equa', call AppendToCurrentDirectory
        call PrepareStructuresFiles
    End_If

    call 'User32.CreateWindowExA' D$WindowExStyle, ClassName, AppName, D$WindowStyle,
                                  D$WindowX, D$WindowY, D$WindowW, D$WindowH, 0,
                                  D$MenuHandle, D$hInstance, 0

   ; for a 'full screen 'window's user area (ex: screen-saver):
   ;
   ; call 'User32.CreateWindowExA' 04030D0  ClassName  AppName  096000000,
   ;                               D$WindowX  D$WindowY  D$WindowW  D$WindowH  0,
   ;                               0  D$hInstance  0

    mov D$hwnd eax, D$hwndFileOwner eax, D$hwndPEFileOwner eax,
        D$PD_hWndOwner eax, D$BmhwndFileOwner eax

    On D$StringsLanguage <> '.en', call OpenStringsFile

    call EnableMenutems | call EnableHelpMenutems
    call EnableVisualTutsMenu | call EnableWizardsMenu
    call EnableClipMenu

    call CreateStatusBar
    On B$ToolBarWanted = &TRUE, call CreateToolBar
    On B$ScrollBarWanted = &TRUE, call CreateScrollBar
    call CreateEditWindow

  ; (D$IsMaximizedFlag = &SW_SHOWNORMAL or &SW_MAXIMIZE):
    call 'USER32.ShowWindow'  D$hwnd, D$IsMaximizedFlag

    call 'USER32.UpdateWindow' D$hwnd

    call 'USER32.GetClipCursor' FullRECT

    call 'USER32.RegisterWindowMessageA' FindString | mov D$FindStringMessage eax

  ; Rotary table for moving inside text:
    call SetBackTableMemory | call InitUndo

    call CreateFontForDialogEdition | call LoadFont

    On D$NATION_LOGFONT@lfWeight <> 0, call LoadNationalFont

    call SetUndoDirectory
    call DeleteOldUndoFiles

    call CheckAllMRUFile | call SetMRUmenu | On B$LoadMRU = &TRUE, call LoadLastMRUFile


  ; copying compilable version of icon in case user compiles vithout defining any icon:
    call StoreIcon

    On B$BlinkingCaretWanted = &TRUE, call InitBlinkCursor

    call InitExpressionBuffers

;    call 'USER32.CreateAcceleratorTableA' ACCELERATORS ACCELNUMBER
;    mov D$AccelHandle eax

    jmp L1>>
   ___________________________________________________________________________

   ; Our main loop: when 'DispatchMessageA' called, Win calls upper CallBack:
   ___________________________________________________________________________

L0: call 'User32.IsDialogMessageA' D$FindReplaceHandle Firstmsg  | On eax > 0, jmp L1>

    If B$IsDebugging = &TRUE
        call 'User32.TranslateAcceleratorA' D$DebugDialogHandle, D$DbgAccelHandle, FirstMsg
        cmp eax &TRUE | je L1>
        call 'User32.IsDialogMessageA' D$CurrentDataPageHandle, FirstMsg
        cmp eax &TRUE | je L1>
        call 'User32.IsDialogMessageA' D$DebugDialogHandle, FirstMsg
        cmp eax &TRUE | je L1>
    End_If

    call 'User32.TranslateMessage' Firstmsg
    call 'User32.DispatchMessageA' Firstmsg

L1: call 'User32.GetMessageA' FirstMsg 0 0 0

    cmp eax 0 | ja L0<<

  ; call ReleaseFonts
    call UpdateRegistry

    call 'KERNEL32.FreeLibrary' D$RichEditHandle

  ; call 'USER32.DestroyAcceleratorTable' D$AccelHandle

    call 'Kernel32.ExitProcess' D$FWparam
____________________________________________________________________________________________

ResetBackGroundColors:
    On D$BackGroundBrushHandle <> 0, call 'KERNEL32.CloseHandle' D$BackGroundBrushHandle
    call 'GDI32.CreateSolidBrush' D$NormalBackColor
    mov D$BackGroundBrushHandle eax

    On D$DialogsBackGroundBrushHandle, <> 0, call 'KERNEL32.CloseHandle' D$DialogsBackGroundBrushHandle
    call 'GDI32.CreateSolidBrush' D$DialogsBackColor
    mov D$DialogsBackGroundBrushHandle eax

    On D$CaretBrushHandle, <> 0, call 'KERNEL32.CloseHandle' D$CaretBrushHandle
    call 'GDI32.CreateSolidBrush' D$StatementColor
    mov D$CaretBrushHandle eax

    On D$RedBrushHandle, <> 0, call 'KERNEL32.CloseHandle' D$RedBrushHandle
    call 'GDI32.CreateSolidBrush' D$BracketColor
    mov D$RedBrushHandle eax
ret

[CaretTime: 600    ShowCaret: &TRUE    BlinkingCaretWanted: &FALSE]

ResetBlinkCursor:
    call KillBlinkCursor
InitBlinkCursor:
    call 'User32.SetTimer' D$hwnd, 1, D$CaretTime, BlinkProc
ret


[CaretOnlyRedraw: ?]

BlinkProc:
    .If B$BlockInside = &FALSE
L1:     xor B$ShowCaret &TRUE
        If D$CaretRectangle+8 <> 0
            mov B$CaretOnlyRedraw &TRUE | call AskForRedraw
        End_If
    .Else
        On B$ShowCaret = &FALSE, jmp L1<
    .End_If
ret 16


KillBlinkCursor:
    call 'User32.KillTimer' D$hwnd, 1
    mov B$ShowCaret &TRUE
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
; Init the Deleted Blocks Undo Folder and delete Undo Files if any:

[UndoDirectory: UndoFile: B$ ? #&MAX_PATH]
[PointerToUndoNumber: '000.'] ; Old nUndoFile
[AllUndoFiles2: B$ ? #&MAX_PATH]

;[UndoFile: 'RosAsmUndo' nUndoFile: '000.$$$' 0  ; 17 Bytes.
; AllUndoFiles: 'RosAsmUndo???.$$$' 0]
;
; The full name looks like this:
; 'E:\RosAsm3\RosAsmUndo\Undo000.$$$'
;
; 'PointerToUndoNumber' points to '000.$$$'
;
; 'AllUndoFiles', used to search for Files to be deleted, looks like this:
; 'E:\RosAsm3\RosAsmUndo\Undo???.$$$'

[UndoExist: "
Block-Delete Undo-Files have been found in the
Temporary Directory (...\RosAsmUndo\).

The existing Undo-Files are going to be deleted and
the previous instance of RosAsm will no more be able to
UnDelete its saved Blocks.
"

MultiUndo: "
You are runing several instances of RosAsm. Do not        
Delete/UnDelete Blocks of text [Ctrl][X] / [Ctrl][Z]
The results could be unwished.

" 0]

SetUndoDirectory:
    mov edi UndoDirectory, ecx &MAX_PATH, al 0 | rep stosb
    call 'KERNEL32.GetTempPathA' &MAX_PATH UndoDirectory

    mov edi UndoDirectory, al 0, ecx &MAX_PATH | repne scasb | dec edi
    On B$edi-1 = '\', dec edi
    mov eax '\Ros' | stosd | mov eax 'AsmU' | stosd | mov ax 'nd' | stosw | mov al 'o' | stosb

    push edi
        call 'KERNEL32.CreateDirectoryA' UndoDirectory &NULL | mov ebx eax
    pop edi

    If B$MultiInstance = &FALSE
        push edi
            mov D$edi '\Und', D$edi+4 'o*.$', W$edi+8 '$$', B$edi+9 0
            call 'KERNEL32.DeleteFileA' UndoDirectory
        pop edi
    End_If

    mov eax '\Und' | stosd | mov eax 'o001' | stosd | mov eax '.$$$' | stosd | mov B$edi 0
    sub edi 5
    mov D$PointerToUndoNumber edi | sub D$PointerToUndoNumber 2

    mov esi UndoDirectory, edi AllUndoFiles2, ecx &MAX_PATH | rep movsb
    mov eax D$PointerToUndoNumber | sub eax UndoDirectory
    mov edi AllUndoFiles2 | add edi eax | mov eax '???.' | stosd

    ..If ebx = 0   ; 'CreateDirectoryA failed to create a new Dir >>> Already exist.

        call 'KERNEL32.FindFirstFileA' AllUndoFiles2 FindFile
        .If eax <> &INVALID_HANDLE_VALUE
            If B$MultiInstance = &TRUE
                call 'USER32.MessageBoxA' D$hwnd, UndoExist, Argh, &MB_OKCANCEL__&MB_ICONHAND
                On eax = &IDCANCEL, call 'KERNEL32.ExitProcess' 0
            End_If

            call DeleteOldUndoFiles

        .Else
            call 'KERNEL32.FindClose' eax
            If B$MultiInstance = &TRUE
                call 'USER32.MessageBoxA' D$hwnd, MultiUndo, Argh, 0
            End_If

        .End_If
    ..End_If

    mov edi D$PointerToUndoNumber, eax '000.' | stosd
ret


;;
 BackTable is used for moving back and forward in text after tree view or right clicks
 moves. It is an 8 bytes rotary table; this is to say that we use only lower byte of
 BackTablePtr to ajust moves inside table, like this:

 > mov ebx D$BackTablePtr | add (or sub) BL 4

 As memory given by win is page aligned, if Bl = 0, "sub bl 4" points to end of table.
;;

[BackTable: ?  BackTablePtr: ?]

SetBackTableMemory:
    VirtualAlloc BackTable 0100
    move D$BackTablePtr D$BackTable
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

[ToolBarHandle: ?]
[TOOLBUTTONS_NUMBER 18] ; (zero based).

[ToolBarButtons:
 D$  0  M00_Tree  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  0 0 B$ &TBSTATE_ENABLED  &TBSTYLE_SEP 0 0  D$ 0 0
 D$  1  M00_Open  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  2  M00_New  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 0 0 B$ &TBSTATE_ENABLED  &TBSTYLE_SEP 0 0  D$ 0 0
 D$  3  M00_Compile  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  4  M00_Run  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 0 0 B$ &TBSTATE_ENABLED  &TBSTYLE_SEP 0 0  D$ 0 0
 D$ 14  M00_About_ToolBar  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0

 D$ 0 0 B$ &TBSTATE_ENABLED  &TBSTYLE_SEP 0 0  D$ 0 0
 D$  5  M00_Calc  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  6  M00_Clip_File  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  7  M00_Structures  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  8  M00_New_Dialog   B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$  9  M00_Find  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 10  M00_Replace  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 11  M00_Ascii_Table   B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 12  M00_Configuration   B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 13  M00_B_U_Asm  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
; D$ 14  M00_About   B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 15  M00_Print   B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 16  M00_Main_Icon   B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 17  M00_Save_Source_Only  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 18  M00_Exit  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 D$ 19 12  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
; D$ 20 0CE  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
; D$ 21 0CE  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
; D$ 22 0CE  B$ &TBSTATE_ENABLED  &TBSTYLE_BUTTON  0 0  D$ 0 0
 ]

[toolbar00_str_00: B$ 'Tree', 0
 toolbar00_str_01: '', 0
 toolbar00_str_02: 'Open', 0
 toolbar00_str_03: 'New', 0
 toolbar00_str_04: '', 0
 toolbar00_str_05: 'Compile', 0
 toolbar00_str_06: 'Run', 0
 toolbar00_str_07: '', 0
 toolbar00_str_08: 'About ToolBar', 0
 toolbar00_str_09: '', 0
 toolbar00_str_10: 'Calc', 0
 toolbar00_str_11: 'Clip', 0
 toolbar00_str_12: 'Structures', 0
 toolbar00_str_13: 'New Dialog', 0
 toolbar00_str_14: 'Find', 0
 toolbar00_str_15: 'Replace', 0
 toolbar00_str_16: 'Ascii Table', 0
 toolbar00_str_17: 'Configuration', 0
 toolbar00_str_18: 'B_U_Asm', 0
 toolbar00_str_19: 'Print', 0
 toolbar00_str_20: 'Main Icon', 0
 toolbar00_str_21: 'Save Source',0
 toolbar00_str_22: 'Exit', 0
 toolbar00_str_23: 'Wizards', 0, 0]

 [PointersToToolTipsStrings: toolbar00_str_00   toolbar00_str_01
                              toolbar00_str_02
                             toolbar00_str_03   toolbar00_str_04
                             toolbar00_str_05
                             toolbar00_str_06   toolbar00_str_07
                              toolbar00_str_08
                             toolbar00_str_09
                            toolbar00_str_10   toolbar00_str_11
                             toolbar00_str_12   toolbar00_str_13   toolbar00_str_14
                             toolbar00_str_15   toolbar00_str_16   toolbar00_str_17
                             toolbar00_str_18   toolbar00_str_19   toolbar00_str_20
                             toolbar00_str_21   toolbar00_str_22   toolbar00_str_23]

[TOOLTIPTEXT_NMHDR_hwndFrom 0            ; With WM_NOTIFY Message, Win sends in
 TOOLTIPTEXT_NMHDR_idfrom   4          ; lParam a pointer to a TOOLTIPTEXT
 TOOLTIPTEXT_NMHDR_code     8          ; Structure (which win GIVES to us).

 TOOLTIPTEXT_lpszText       12         ; Item
 TOOLTIPTEXT_szText         16         ; These Equates are to ease accesses to
 TOOLTIPTEXT_hInst          96         ; this Structure (which doesn't belong
 TOOLTIPTEXT_uFlags         100]       ; to our Data area).


[TB_NOTIFY_NMHDR_hwndFrom     0          ; And same for "TBN_GETBUTTONINFO" answers:
 TB_NOTIFY_NMHDR__idfrom      4
 TB_NOTIFY_NMHDR__code        8

 TB_NOTIFY_Item      12

 TB_NOTIFY_TBBUTTON_iBitmap   16
 TB_NOTIFY_TBBUTTON_idCommand 20
 TB_NOTIFY_TBBUTTON_fsState   24
 TB_NOTIFY_TBBUTTON_fsStyle   23
 TB_NOTIFY_TBBUTTON_dwData    28
 TB_NOTIFY_TBBUTTON_iString   32

 TB_NOTIFY_CharCount 36
 TB_NOTIFY_TextPtr   40]

[TbRECT: TbRECTleft: ?  TbRECTtop: ?  TbRECTright: ?  TbRECTbottom: ?]
[ToolBarPixelsHight: ?    ToolBarLinesHight: ?]
[ToolBarWanted: ?]

[HelpToolBar: 'Sure you need some help???!!!!', 0
 HelpToolBarTitle: 'Poor you!' 0]

[ToolBar_Registry:
 TB_hkr: &HKEY_CURRENT_USER
 TB_SubKey: ToolBarSubKey
 TB_ValueName: ToolBarValueName]

[ToolBarChange: B$ 0   ToolBarSubKey: 'Software\RosAsm\ToolBar' 0
                       ToolBarValueName: 'ToolBarState' 0]

CreateToolBar:
 ;&TBSTYLE_TOOLTIPS__&TBSTYLE_ALTDRAG__&CCS_ADJUSTABLE,
    call 'COMCTL32.CreateToolbarEx' D$hWnd,
    &CCS_TOP__&TBSTYLE_TOOLTIPS__&WS_CHILD__&WS_VISIBLE__&TBSTYLE_ALTDRAG__&CCS_ADJUSTABLE__&WS_BORDER,
    0300, TOOLBUTTONS_NUMBER, D$hInstance, 2, ToolBarButtons, 9, 0, 0, 20, 20, 20

; &WS_CHILD__&WS_VISIBLE__&WS_BORDER__&CCS_TOP__&TBSTYLE_ALTDRAG__&CCS_ADJUSTABLE,

    mov D$ToolBarHandle eax

    call 'USER32.SendMessageA' D$ToolBarHandle, &TB_AUTOSIZE, 0, 0

    call 'USER32.GetWindowRect' D$ToolBarHandle, TbRECT
    mov eax D$TbRECTbottom | sub eax D$TbRECTtop | dec eax
    mov D$ToolBarPixelsHight eax

    call 'USER32.SendMessageA' D$ToolBarHandle, &TB_SAVERESTORE, &FALSE,  ; FALSE > restore
                               ToolBar_Registry
SaveToolBar:
    call 'USER32.SendMessageA' D$ToolBarHandle, &TB_SAVERESTORE, &TRUE,   ; TRUE > save
                               ToolBar_Registry
ret



[StatusBarX: ?  StatusBarY: ? StatusBarW: ? StatusBarH: ?]
[StatusBarHight: ?]

CreateStatusBar:
    call 'COMCTL32.CreateStatusWindowA',
        &WS_CHILD__&WS_VISIBLE__&WS_DLGFRAME__&WS_BORDER__&SBARS_SIZEGRIP, 0, D$hwnd,
        STATUSBAR_ID
    mov D$StatusbarHandle eax

    call 'USER32.SendMessageA' D$StatusbarHandle, &SB_SETPARTS, 7, StatusPartsPos

    call 'USER32.GetWindowRect' D$StatusbarHandle, StatusBarX
    push D$StatusBarY
        call 'USER32.GetClientRect' D$hWnd, StatusBarX
        call 'USER32.ClientToScreen' D$hWnd, StatusBarW
    pop ebx
    mov eax D$StatusBarH | sub eax ebx | mov D$StatusBarHight eax
    call 'USER32.ShowWindow' D$StatusBarHandle &SW_SHOW
ret


[SbRECT: ScrollBarX: ?  ScrollBarY: ?  ScrollBarW: ?  ScrollBarH: ?]
[ScrollWindowHandle: ?]
[ScrollBarName: 'SCROLLBAR', 0]

CreateScrollBar:
    call 'USER32.GetClientRect' D$hWnd ScrollBarX
    push D$ScrollBarW
        If B$ToolBarWanted = &TRUE
            mov eax D$ToolBarPixelsHight | add D$ScrollBarY eax | sub D$ScrollBarH eax
        End_If
        call 'USER32.GetSystemMetrics' &SM_CXVSCROLL | mov D$ScrollBarW eax
    pop ebx | sub ebx eax | mov D$ScrollBarX ebx
    mov eax D$StatusBarHight | sub D$ScrollBarH eax

    call 'USER32.CreateWindowExA' 0, EditClassName, &NULL,
                                  &WS_CHILD__&WS_VISIBLE__&WS_VSCROLL,
                                  D$ScrollBarX, D$ScrollBarY, D$ScrollBarW, D$ScrollBarH,
                                  D$hWnd, &NULL, D$hInstance, 0
    mov D$ScrollWindowHandle eax

    call 'USER32.SetWindowLongA' D$ScrollWindowHandle, &GWL_WNDPROC, ScrollBarProc
ret


[EditWindowHandle: ?   BpWindowHandle: ?
 EditWindowX: ? EditWindowY: ? EditWindowW: EditWindowX2: ? EditWindowH: EditWindowY2: ?]

[BpMarginWidth: ?]

CreateEditWindow:
    mov eax D$FontWidth | shl eax 1 | mov D$BpMarginWidth eax

    call 'USER32.GetClientRect' D$hWnd EditWindowX
    mov eax D$BpMarginWidth | add D$EditWindowX eax

    If B$ToolBarWanted = &TRUE
        mov eax D$ToolBarPixelsHight
        add D$EditWindowY eax
        sub D$EditWindowH eax
    End_If

    If B$ScrollBarWanted = &TRUE
        mov eax D$ScrollBarW | sub D$EditWindowW eax
    End_If

    mov eax D$StatusBarHight | sub D$EditWindowH eax
    mov eax D$BpMarginWidth | sub D$EditWindowW eax

    call 'USER32.CreateWindowExA' 0, ClassName, &NULL,
                                  &WS_CHILD__&WS_VISIBLE,
                                  D$EditWindowX, D$EditWindowY, D$EditWindowW, D$EditWindowH,
                                  D$hWnd, &NULL, D$hInstance, 0
    mov D$EditWindowHandle eax

  ; Prepare the Client area for printing:
    ;call 'USER32.GetClientRect' D$EditWindowHandle, EditWindowX

  ; Create the BP Margin Window:
    call 'USER32.CreateWindowExA' 0, ClassName, &NULL,
                                  &WS_CHILD__&WS_VISIBLE,
                                  0, D$EditWindowY, D$EditWindowX, D$EditWindowH,
                                  D$hwnd, &NULL, D$hInstance, 0
    mov D$BpWindowHandle eax
ret
____________________________________________________________________________________________

[AraseBackEdit: ? #4]

Proc AraseBackGround:
    Argument @hdc
    call 'USER32.GetClientRect' D$EditWindowHandle, AraseBackEdit
    call 'USER32.FillRect' D@hdc, AraseBackEdit, D$BackGroundBrushHandle

    call AskForRedraw
EndP


MainResize:
  ; StatusBar:
    call 'USER32.GetClientRect' D$hWnd, StatusBarX

    mov eax D$StatusBarH | sub eax D$StatusBarHight | mov D$StatusBarY eax
    call 'USER32.MoveWindow' D$StatusBarHandle,
                             D$StatusBarX, D$StatusBarY, D$StatusBarW, D$StatusBarH,
                             &TRUE

  ; ToolBar:
    If B$ToolBarWanted = &TRUE
        call 'USER32.SendMessageA' D$ToolBarHandle, &TB_AUTOSIZE, 0, 0
    End_If

  ; ScrollBar:
    .If B$ScrollBarWanted = &TRUE
        call 'USER32.GetClientRect' D$hWnd ScrollBarX
        push D$ScrollBarW
            If B$ToolBarWanted = &TRUE
                mov eax D$ToolBarPixelsHight | add D$ScrollBarY eax | sub D$ScrollBarH eax
            End_If
            call 'USER32.GetSystemMetrics' &SM_CXVSCROLL | mov D$ScrollBarW eax
        pop ebx | sub ebx eax | mov D$ScrollBarX ebx
        mov eax D$StatusBarHight | sub D$ScrollBarH eax

        call 'USER32.MoveWindow' D$ScrollWindowHandle,
                                 D$ScrollBarX, D$ScrollBarY, D$ScrollBarW, D$ScrollBarH,
                                 &TRUE
    .End_If

  ; Edit:
    mov eax D$FontWidth | shl eax 1 | mov D$BpMarginWidth eax

    call 'USER32.GetClientRect' D$hWnd EditWindowX
    mov eax D$BpMarginWidth | add D$EditWindowX eax

    If B$ToolBarWanted = &TRUE
        mov eax D$ToolBarPixelsHight
        add D$EditWindowY eax
        sub D$EditWindowH eax
    End_If

    If B$ScrollBarWanted = &TRUE
        mov eax D$ScrollBarW | sub D$EditWindowW eax
    End_If

    mov eax D$StatusBarHight | sub D$EditWindowH eax
    mov eax D$BpMarginWidth | sub D$EditWindowW eax


;If D$TitleFontHandle <> 0
;    mov eax D$TitleTabHight | sub D$EditWindowH eax
;End_If

    call 'USER32.MoveWindow' D$EditWindowHandle,
                             D$EditWindowX, D$EditWindowY, D$EditWindowW, D$EditWindowH,
                             &TRUE
  ; Initialize the Edit Window dims as used by the Editor:
    ;call 'USER32.GetClientRect' D$EditWindowHandle, EditWindowX
    ;mov eax D$BpMarginWidth | add D$EditWindowX eax

  ; Bp Margin:
    call 'USER32.MoveWindow' D$BpWindowHandle,
                             0, D$EditWindowY, D$BpMarginWidth, D$EditWindowH,
                             &TRUE
ret


RedrawInterface:
  ; Use of 'ScrollBarProc' for killing the various windows because this Proc.
  ; (As MainWindowProc would close RosAsm)

  ; Edit:
    call 'USER32.SetWindowLongA' D$EditWindowHandle, &GWL_WNDPROC, ScrollBarProc
    call 'USER32.DestroyWindow' D$EditWindowHandle

  ; ScrollBar
    If D$ScrollWindowHandle <> 0
        call 'USER32.DestroyWindow' D$ScrollWindowHandle
        mov D$ScrollWindowHandle 0
    End_If

  ; ToolBar:
    If D$ToolBarHandle <> 0
        call 'USER32.SetWindowLongA' D$ToolBarHandle, &GWL_WNDPROC, ScrollBarProc
        call 'USER32.DestroyWindow' D$ToolBarHandle
        mov D$ToolBarHandle 0
    End_If

  ; StatusBar:
    call 'USER32.SetWindowLongA' D$StatusbarHandle, &GWL_WNDPROC, ScrollBarProc
    call 'USER32.DestroyWindow' D$StatusbarHandle

  ; BpWindow
    call 'USER32.SetWindowLongA' D$BpWindowHandle, &GWL_WNDPROC, ScrollBarProc
    call 'USER32.DestroyWindow' D$BpWindowHandle

    call CreateStatusBar
    On B$ToolBarWanted = &TRUE,  call CreateToolBar
    On B$ScrollBarWanted = &TRUE, call CreateScrollBar
    call CreateEditWindow
ret












TITLE Progress
 _______________________________________________________________________________________
 _______________________________________________________________________________________

; Progress Bar

[ProgressTitle: B$ 'Done' 0]

[ProgressClassName: 'msctls_progress32' 0 ; ProgressName: 'Compiling...' 0
 PWindowX: 10 PWindowY: 5 PWindowW: 300 PWindowH: 10
 PBarWindow: PBarWindowX: 0   PBarWindowY: 0   PBarWindowW: 340  PBarWindowH: 45
 ProgressInst: 0   hwndForBar: 0]

 call 'Comctl32.InitCommonControls'

[Writing:       '[Writing PE__<<<<<__'
 Fixing:        'Resolving__<<<<<__'
 BuildingHeader:'PE headers__<<<<<__'
 Encoding:      'Encoding__<<<<<__'
 BuildingData:  'Data job__<<<<<__'
 BuildingRsrc:  'Resources__<<<<<__'
 BuildingImport:'Import Section__<<<<<__'
 Replacing:     'Replacing__<<<<<__'
 Storing:       'Storing Mac/Equ__<<<<<__'
 Cleaning:      'Cleaning]', 0]

[PROGRESS_BAR_WIDTH 340    PROGRESS_BAR_HIGHT 45]


InitProgressBar:
  ; Center the bar:
    mov eax D$EditWindowW | sub eax PROGRESS_BAR_WIDTH
    shr eax 1 | mov D$PBarWindowX eax

    mov ebx D$EditWindowH | sub ebx PROGRESS_BAR_HIGHT
    shr ebx 1 | mov D$PBarWindowY eax

    mov D$PBarWindowW PROGRESS_BAR_WIDTH, D$PBarWindowH, PROGRESS_BAR_HIGHT

    call 'USER32.ClientToScreen' D$EditWindowHandle, PBarWindow

    call 'USER32.CreateWindowExA' 0, ClassName, Cleaning,
                                  &WS_OVERLAPPED__&WS_CAPTION__&WS_THICKFRAME_&WS_VISIBLE,
                                  D$PBarWindowX, D$PBarWindowY, D$PBarWindowW, D$PBarWindowH,
                                  0, 0, D$hInstance, 0
    mov D$hwndForBar eax

    call 'USER32.ShowWindow' D$hwndForBar, &SW_SHOW ;&SW_SHOWNORMAL

    call 'USER32.UpdateWindow' D$hwndForBar
_____________________________

    call 'USER32.CreateWindowExA' 0, ProgressClassName, 0, &WS_CHILD__&WS_VISIBLE,
                                  D$PWindowX, D$PWindowY, D$PWindowW, D$PWindowH,
                                  D$hwndForBar, 0, D$hInstance, 0
    mov D$ProgressInst eax
ret


Proc InitProgressSteps:
    Arguments @Range, @Step
      ; Low Word is 'Min', High Word is 'Max':
        shl D@Range 16
        call 'USER32.SendMessageA'  D$ProgressInst, &PBM_SETRANGE, 0, D@Range
        call 'USER32.SendMessageA'  D$ProgressInst, &PBM_SETSTEP, D@Step, 0
EndP


BarProgress:
    On B$WeAreUnfolding = &TRUE, ret

    pushad
        call 'USER32.SendMessageA' D$ProgressInst &PBM_STEPIT 0 0
    popad
ret


[CompileInfos: ]
;;
"



      code instructions:                 "
 InstNumber: "                                               

              Data Labels:                 "
 LabsNumber: "                              
              Code Labels:                  "
 CodeLabelsNumber: "


             
             Parsing Time:                "
 ParsingTime: "           ms
             Compile time:                 "
 CompileTime: "           ms
            Creating time:                  "
 CreatingTime:"           ms

                Total time:                  "
 TotalTime:   "           ms


              Source size:                "
 SourceSize:"             octets
                    PE size:                "
     PEsize:"             octets
                Total Size:                "
  TotalSize:"             octets



 "

 0]
;;

StatDecimalWritting:
    push eax
        mov eax '    ' | stosd | stosd
    pop eax

L0: mov edx 0
    div ebx
    add dl '0' | mov B$edi dl | dec edi | cmp eax 0 | ja L0<
ret


; Tag Dialog 1

[StatsHandle: ?   TotalTime: ?   UnusedSymbolsWanted: ?]

Proc Statistics:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ..If D@Message = &WM_COMMAND
        If D@wParam = &IDCANCEL
            call 'USER32.EndDialog' D@Adressee, 0
        Else_If D@wParam = 3
            ;call DisplayUnusedSymbolsDialog D@Adressee
            call 'USER32.EndDialog' D@Adressee, 0
            mov D$UnusedSymbolsDialogWanted &TRUE
        End_If

    ..Else_If D@Message = &WM_INITDIALOG
        move D$StatsHandle D@Adressee

        call 'USER32.SetClassLongA' D@Adressee, &GCL_HICON, D$wc_hIcon

      ; Number of Instructions:
        call 'USER32.SetDlgItemInt' D@Adressee, 110, D$InstructionsCounter, 0
      ; Number of Code and Data Labels:
        call 'USER32.SetDlgItemInt' D@Adressee, 111, D$DataLabelsCounter, 0
        call 'USER32.SetDlgItemInt' D@Adressee, 112, D$CodeLabelsCounter, 0

      ; Parsing Time:
        mov eax D$Time2 | sub eax D$Time1 | mov D$TotalTime eax
        call 'USER32.SetDlgItemInt' D@Adressee, 120, eax, 0
      ; Compile Time:
        mov eax D$Time3 | sub eax D$Time2 | add D$TotalTime eax
        call 'USER32.SetDlgItemInt' D@Adressee, 121, eax, 0
      ; Creation Time:
        mov eax D$Time4 | sub eax D$Time3 | add D$TotalTime eax
        call 'USER32.SetDlgItemInt' D@Adressee, 122, eax, 0
      ; Total Time:
        call 'USER32.SetDlgItemInt' D@Adressee, 129, D$TotalTime, 0

      ; Source Size:
        call 'USER32.SetDlgItemInt' D@Adressee, 130, D$SourceLen, 0
      ; Code Size:
        call 'USER32.SetDlgItemInt' D@Adressee, 131, D$LenOfCode, 0
      ; Total Size:
        mov eax D$LenOfCode | add eax D$SourceLen
        call 'USER32.SetDlgItemInt' D@Adressee, 139, eax, 0

        call WritePE | call RecordMRU | On D$BookMarks > 0, call SaveBookMarks

        If B$UnusedSymbolsWanted = &TRUE
            call DisplayUnusedSymbolsDialog D@Adressee
        Else
            mov D$UnusedCodeIndex 0, D$UnusedDataIndex 0
        End_If

    ..Else
        popad | mov eax &FALSE | ExitP

    ..End_If

    popad | mov eax &TRUE
EndP


CloseProgressBar:
    call 'User32.SendMessageA' D$ProgressInst &PBM_SETPOS 0 0
    call 'User32.DestroyWindow' D$hwndForBar
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

[AboutMessage: B$ "
         RosAsm, the Specific Assembler

            is free, open source, GPL.

Main Author is René Tournois < betov@free.fr>        

            Download last version at:

        http://betov.free.fr/RosAsm.html

", 0

AboutTitle:  ' About:', 0]


AboutBox:
   call 'USER32.MessageBoxA' D$hwnd,                ; handle
                            AboutMessage ,         ; Message
                            AboutTitle,            ; Message-Window-Title
                            &MB_ICONINFORMATION__&MB_SYSTEMMODAL         ; Style (0 to 4) 0 > 'OK'
ret


About_ToolBar:
    call 'USER32.MessageBoxA' D$hwnd, {"
    
    Double-Click on the ToolBar for customization
    
    You can move the ToolBar Buttons by [Alt]+Drag             
    ", 0}, {'ToolBar Info:', 0}, &MB_ICONINFORMATION__&MB_SYSTEMMODAL
ret


____________________________________________________________________________________________
____________________________________________________________________________________________




TITLE SourceEdit

 ______________________________________________________________________________________
 ______________________________________________________________________________________
;;
  RosAsm Sources Editor
  
  - The Caret is Screen dependant. Not Text dependant.
  
  - The Editor is _not_ a Line-Oriented one.
  
  - The Main Routine called on WM_PAINT is 'PrintColorText'
  
  - Most minor Routines are called from 'CharMessage' or from 'KeyMessage'
  
  - The coloring is achieve through a parallele Table ('ColorsMap')
  
  __________________
  Overall mechanism: 
  
  This Editor is "File Oriented". This is to say, that, each time we insert
  or delete one single Char, all of the downward Text is moved. Over some size
  (depending on the Processor speed) the Editor looses its responsivity, once
  the Copy Operations are slwoer than the KeyBoard inputs speed.
  
  This was the first reason why a Mechanism of TITLEs was introduced, in order
  to divide the real momolitic user Source into "Sub-Sources": For Sources divided
  into TITLEs, the Editor makes a Copy of the Edited TITLE, at the End of the real
  Source, in Memory, and we always work on this isolated Part. This reduces the
  Copy operation to one smaller TITLE part, and the real Copy, into the real user
  Source is done only for each operation requiring to work with the real Source.
  
  The concerned Routines is 'RestoreRealSource' and, for going back to a TITLE
  Edition, 'SetPartialEditionFromPos'.
  
  ________________
  The user inputs:
  
  As said above ('CharMessage', 'KeyMessage') two imputs are considered:
  
  * &WM_CHAR, of course (Nothing special).
  
  * &WM_KEYDOWN / &WM_KEYUP. For these ones, the Editor manages a 'Keys' Table,
    where each Key State (1/0 -On/Off-) is stored.
    
  So, some Functionalities are driven from the &WM_CHAR, and some are driven
  from the &WM_KEYDOWN Messages.
  
    ____________________
    The output Routines.
    
    'XtoRow' 'RowToX' 'TroncatedXtoRow' 'YtoLine' 'LineToY' 'TroncatedYtoLine'
    
    'InitPrintText' 'BlankRemainders'
    
        'PrintColorText'
        
            'PrintCaretAndUnderline' 'GetLastCharPosOnScreen' 'AjustForRightScroll'
        
            'SetColorsMap' 'TextColorsMap'  'TextOutput'
    
            'InitPrintText'  'ClosePrint'
    
    ______________
    Minor Routines
   
    'MouseTextPos' 'SimpleMouseTextPos'
    
    'DownOneLine' 'UpOneLine' 'FullDown' 'OnlyOnePageDown' 'FullUp' 'OnlyOnePageUp'
    
    'AutoDeleteBlock'
    
    'OverwriteSource' 'InsertSource' 'InsertDoubleByte'
    
    'SetIndent' 'CarriageReturn'
    
    'TryToMove'
    
    'ResetCaretOnStripTab' 'StripBackSpace' 'BackSpace'
    
    'KeyDown' 'KeyUp' 'StartOfLine' 'KeyLeft'
    
    'SetPhysicalCaretRow'
    
    'StartOfWord' 'EndOfLine' 'KeyRight' 'EndOfWord'
    
    'KeyInsert' 'StripOneChar' 'KeyDelete'
    
    'SearchTxtPtr'
    
    'SetCaret' 'LeftButton'
    
    'SetBlock'
    
    'LeftButtonUp'
    
    'ControlC' 'ControlY' 'ControlD' 'ControlX' 'UndoControlV'
    
    'OpenClipBoard' 'ClipBordCleaner' 'KillTabs' 'CloseClipBoard'
    
    'ControlV'
    
    'ReMapSourceMemoryIfNeeded'
    
    'DrawOneLine'
    
    ____________
    Undo feature
    
    'InitUndo' 'KillUndo' 'ReInitUndo' 'DoStoreInsert' 'DoStoreOverWrite'
    'DoStoreCharDelete' 'ReInsertDeletedChar' 'DoStoreBlockPaste'
    
    'ResetUndoFileName' 'IncUndoFileName' 'DecUndoFileName'
    
    'WriteUndoBlockFile'
    
    'DeleteUndoFiles' 'DeleteOldUndoFiles'
    
    'UndoBlockCopy' 'ReadUndoBlockFile'
    
    'ControlZ' 'ReadUndoRecord'
    
    ____________________
    Main Redraw Routines
    
    'AskForRedraw' 'AskForRedrawNow'
    
    _____________________
    Text Pos and searches
    
    'TextPos' 'RedrawScrollBar' 'RePosFromScroll'
    
    'KillTrailingSpaces'
    
    'GetWheelInfo' 'WheelMsg'
    
    'StartEdition' 'ReplaceParagraphByDollar'
    
    'CloseHelp'
    
    'InternSearch'

    'SavePosOnF11' 'SetPosOnF12' 'ClearF11F12' 'ClearF12'
    
    _____
    Fonts (called from the Configuration Tab or from main
    
    'ChooseFontHook' 'SelectFont' 'LoadFont'
;;

; looks: Red , Green , Blue , 0  when bytes,     0/Blue/Green/Red  when dWord

[NormalTextColor: B$    0   0   0 0    ; color for Statements or brackets
 CaretColor:          150 150 150 0    ; (xor 00_01101001 for Insert Mode... avoid modifying)
 PreviousNormalColor:   0   0   0 0]

[PAINTSTRUCT: PShdc: 0  PSfErase: 0  PSrcPaint: 0 0 0 0
              PSfRestore: 0  PSfIncUpdate: 0
              PSrgbReserved: 0 0 0 0  0 0 0 0]

[RECT: RECTleft: ?  RECTtop: ?  RECTright: ?  RECTbottom: ?]
____________________________________________________________________________________________

[EditData:  ; 21 dwords
 hFont: 0
 Col: 0  Line: 0  ; Col2: 0  Line2: 0
 hdc: 0  CurrentWritingPos: 0 ColNumber: 8  LineNumber: 0
 SourceEnd: 0  CaretLine: 0  CaretRow: 1  CaretRowValue: 8  PhysicalCaretRow: 1
 Caret: 0  RightScroll: 0
 CaretEndOfLine: 0  Overwrite: 0  StartOfNormalText: 0  StartOfComment: 0
 StartOfBlockText: 0  UpperLine: 0]

____________________________________________________________________________________________

; SourceEnd: points AFTER the last byte (so that D$SourceEnd-D$CodeSource = D$SourceLen).

[BlankLine: B$ 32 #200, 0] [TRANSPARENT 1]

[BackGroundBrushHandle: ?   DialogsBackGroundBrushHandle: ?]

[Font1Handle: ?]
____________________________________________________________________________________________

Proc XtoRow:
    Argument @X
    Uses edx, ecx

        mov edx 0, eax D@X, ecx D$FontWidth | div ecx
      ; Round up:
        shr ecx 1 | On edx > ecx, inc eax
EndP


[XRemainder: ?    YRemainder: ?]

Proc TroncatedXtoRow:
    Argument @X
    Uses edx

        mov edx 0, eax D@X | div D$FontWidth
        mov D$XRemainder edx
EndP


Proc YtoLine:
    Argument @Y
    Uses edx, ecx

        mov edx 0, eax D@Y, ecx D$FontHeight | div ecx
      ; No 'HalfWay' adjustement to do: The Hot Point of the default Edit-type Cursor
      ; seems to be at the bottom of its shape...
EndP

Proc TroncatedYtoLine:
    Argument @Y
    Uses edx, ecx

        mov edx 0, eax D@Y | div D$FontHeight
        mov D$YRemainder edx
EndP


Proc RowToX:
    Argument @Row
    Uses edx

        mov eax D@Row | mul D$FontWidth
EndP


Proc LineToY:
    Argument @Line
    Uses edx

        mov eax D@Line | mul D$FontHeight
EndP
____________________________________________________________________________________________

; If the division of the writing area by the Font size is not exact (no remainder)
; redraw this background part.

BlankRemainders:
    If D$XRemainder <> 0
        call 'USER32.GetClientRect' D$EditWindowHandle, AraseBackEdit
        move D$AraseBackEdit D$AraseBackEdit+8
        mov eax D$XRemainder | sub D$AraseBackEdit eax
        call 'USER32.FillRect' D$hdc, AraseBackEdit, D$BackGroundBrushHandle
    End_If

    If D$YRemainder <> 0
        call 'USER32.GetClientRect' D$EditWindowHandle, AraseBackEdit
        move D$AraseBackEdit+4 D$AraseBackEdit+12
        mov eax D$YRemainder | sub D$AraseBackEdit+4 eax
        call 'USER32.FillRect' D$hdc, AraseBackEdit, D$BackGroundBrushHandle
    End_If
ret
____________________________________________________________________________________________

[SourceEndReached: ?    EditRightPixel: ?    EditBottomPixel: ?]

InitPrintText:
    call 'User32.BeginPaint' D$EditWindowHandle, PAINTSTRUCT | mov D$hdc eax

    call 'GDI32.SelectObject'  D$hdc D$Font1Handle | mov D$hfont eax
    call 'GDI32.SetBkColor' D$hdc D$NormalBackColor

    call TroncatedXtoRow D$EditWindowW | mov D$ColNumber eax
    call RowToX eax | mov D$EditRightPixel eax

    ;If D$TitleWindowHandle <> 0
    ;    mov eax D$TabWindowH | sub D$EditWindowH eax
    ;End_If

    call TroncatedYtoLine D$EditWindowH | mov D$LineNumber eax
    call LineToY eax | dec eax | mov D$EditBottomPixel eax

    On B$CaretOnlyRedraw = &FALSE, call BlankRemainders

    dec D$LineNumber | dec D$ColNumber

    mov B$TextGoingOn &FALSE | move D$NormalTextColor D$StatementColor
    mov B$SourceEndReached &FALSE
ret


[MarginLine: @X1: ? @Y1: ?   @X2: ? @Y2: ?]

DrawMarginLine:
    mov eax D$FontWidth | dec eax | mov D$MarginLine@X2 eax
    dec eax | mov D$MarginLine@X1 eax
    mov D$MarginLine@Y1 0
    move D$MarginLine@Y2 D$EditWindowH

    call 'USER32.FillRect' D$hdc, MarginLine, D$CaretBrushHandle
ret


RemoveCaretAndUnderline:
    If D$CaretRectangle+8 <> 0
        call 'USER32.FillRect'  D$hdc CaretRectangle D$BackGroundBrushHandle
        mov D$CaretRectangle+8 0
    End_If

    If D$UnderLineRectangle+8 <> 0
        call 'USER32.FillRect' D$hdc, UnderLineRectangle, D$BackGroundBrushHandle
    End_If
ret

ClosePrint:
    call 'GDI32.SelectObject' D$hdc D$hfont
    call 'USER32.EndPaint' D$EditWindowHandle, PAINTSTRUCT

    mov B$TextGoingOn &FALSE
ret
____________________________________________________________________________________________

[TabOldCaretRow: 1    Underline: &FALSE]

[CaretRectangle: ? ? ? ?   CaretBrushHandle: ?  RedBrushHandle: ?
 UnderLineRectangle: ? ? ? ?]

PrintCaretAndUnderline:
    mov eax D$LineNumber | On D$CaretLine > eax, mov D$CaretLine eax

    mov esi D$UpperLine, ecx 0

L0: cmp ecx D$CaretLine | je L2>                 ; search for Caret line (esi)

    On ecx > D$LineNumber, ret
L1: lodsb | cmp al LF | jne L1<
    inc ecx | jmp L0<

L2: mov B$CaretEndOfLine &FALSE, ecx 0
    On D$RightScroll > 0, sub ecx D$RightScroll

L0: cmp ecx D$CaretRow | je L5>>
L1: lodsb | cmp al tab | je L3>
            cmp al CR | ja L2>                      ; search for Caret col (esi too)
      mov B$CaretEndOfLine &TRUE | inc ecx
      mov B$Caret 32, ebx ecx, D$PhysicalCaretRow ebx | jmp L6>>   ; Caret at end of line
L2: inc ecx | jmp L0<

L3: mov ebx D$CaretRow, edx ecx | or ecx 00_111 | inc ecx | On ebx > ecx, Jmp L0<

    inc edx | mov D$CaretRow edx | cmp ebx D$TabOldCaretRow | jbe L5>

    If edx = D$TabOldCaretRow
        inc ecx | mov D$CaretRow ecx | lodsb  ; just for insert Pos on Tab
    End_If

L5: mov B$Caret al, ebx D$CaretRow, D$PhysicalCaretRow ebx
L6: dec esi | mov D$CurrentWritingPos esi | mov D$TabOldCaretRow ebx

    call LineToY D$CaretLine | mov ecx eax
    call RowToX ebx | mov ebx eax

    mov D$CaretRowValue ebx
    On esi >= D$SourceEnd, mov B$Caret ' '

    If ecx > 0
        mov eax D$FontHeight | shr eax 2 | sub ecx eax
    Else
        mov eax 0
    End_If
    mov D$CaretRectangle ebx, D$CaretRectangle+4 ecx
    add ebx 3 | add ecx eax | add ecx D$FontHeight
    mov D$CaretRectangle+8 ebx, D$CaretRectangle+12 ecx

  ; Let Overwrite Dims a special case to let max speed to the normal Caret:
    If B$Overwrite = &TRUE
        mov eax D$FontWidth | add eax D$CaretRectangle | mov D$CaretRectangle+8 eax
        mov eax D$FontHeight | shr eax 2 | add D$CaretRectangle+4 eax
    End_If

    On B$ShowCaret = &TRUE, call 'USER32.InvertRect' D$hdc, CaretRectangle

    .If B$Underline = &TRUE
        move D$UnderLineRectangle D$CaretRectangle,
             D$UnderLineRectangle+4 D$CaretRectangle+4,
             D$UnderLineRectangle+8 D$CaretRectangle+8,
             D$UnderLineRectangle+12 D$CaretRectangle+12

        mov ebx D$CurrentWritingPos | dec ebx
        mov eax D$FontWidth
        While B$ebx > ' ' | dec ebx | sub D$UnderLineRectangle eax | End_While
        mov eax D$FontHeight | inc eax
        add D$UnderLineRectangle+4 eax | sub D$UnderLineRectangle+8 6
        mov eax D$UnderLineRectangle+4 | add eax 2 | mov D$UnderLineRectangle+12 eax

        call 'USER32.FillRect' D$hdc, UnderLineRectangle, D$CaretBrushHandle
    .End_If
ret

____________________________________________________________________________________________

[RosAsmBracket: ?    MultiLinesComment: ?]

[MLC 0D3B3B0A] ; MLC: Multi-Lines Comment (LF ; ; CR). Set first in 'SearchForBrackets'.

____________________________________________________________________________________________
____________________________________________________________________________________________

[LastCharPosOnScreen: ?]

GetLastCharPosOnScreen:
  ; LineNumber is zero based:
    mov eax D$LineNumber | inc eax

    mov esi D$UpperLine

L0: .If B$esi < ' '
        If B$esi = CR
            On B$esi+1 <> LF, mov B$esi ' '
        Else_If B$esi = LF
            On B$esi-1 <> CR, mov B$esi ' '
        Else
            mov B$esi ' '
        End_If
    .End_If

    inc esi | cmp B$esi CR | jne L0<
    dec eax | jnz L0<

    inc esi | mov D$LastCharPosOnScreen esi
ret
____________________________________________________________________________________________

[WantSizeMarkerColor: &TRUE]

Proc SetColorsMap:
    Argument @First, @Last, @Color

        mov esi D@First, edx D@Last | add edx 100
        mov edi esi | sub edi D$CodeSource | add edi D$ColorsMap
        mov bl B@Color | On bl = 0, mov bl 1

L0:     .While esi < edx
            mov al B$esi

            ; Normal = 1 // Brackets = 2 // Strings = 3 // Comments = 4 // Selection 5
            ...If al = "'"
                Do
                    If B$esi >= ' '
                        mov B$edi 3
                    Else
                        mov B$edi 0
                    End_If
                    inc esi | inc edi | cmp esi edx | je L9>>
                Loop_Until B$esi = "'"
                mov B$edi 3 | inc esi | inc edi | jmp L0<

            ...Else_If al = '"'
                mov eax esi
                Do
                    If B$esi >= ' '
                        mov B$edi 3
                    Else
                        mov B$edi 0
                    End_If
                    inc esi | inc edi | cmp esi edx | je L9>>
                Loop_Until B$esi = '"'
                mov B$edi 3 | inc esi | inc edi | jmp L0<<

            ...Else_If al = '['
                mov bl 2, B$edi 2
                inc esi | inc edi | jmp L0<<

            ...Else_If al = ']'
                mov B$edi 2, bl 1
                inc esi | inc edi | jmp L0<<

            ...Else_If B$esi = ';'
                .If D$esi-1 = MLC
                    mov eax esi
                    Do
                        If B$esi < ' '
                            mov B$edi 0
                        Else
                            mov B$edi 4
                        End_If
                        inc esi | inc edi | cmp esi edx | je L9>>
                    Loop_Until D$esi = MLC
                    mov B$edi 0, W$edi+1 0404, B$edi+3 0
                    mov B@Color 0
                    add esi 4 | add edi 4 | jmp L0<<
                .Else
                    Do
                        mov B$edi 4
                        inc esi | inc edi | cmp esi edx | je L9>>
                    Loop_Until B$esi < ' '
                    mov B@Color 0
                    jmp L0<<
                .End_If

            ...Else_If al < ' '
                Do
                    mov B$edi 0
                    inc esi | inc edi | cmp esi edx | je L9>>
                Loop_Until B$esi >= ' '
                jmp L0<<

            ...Else_If al = 36
                mov al B$ParagraphChar, B$esi al
                mov B$edi bl | On B$WantSizeMarkerColor = &TRUE, xor B$edi 0011
                inc esi | inc edi | jmp L0<<

            ...Else_If al = 167
                mov al B$ParagraphChar, B$esi al
                mov B$edi bl | On B$WantSizeMarkerColor = &TRUE, xor B$edi 0011
                inc esi | inc edi | jmp L0<<

            ...Else_If al = '@'
                mov B$edi bl
                On B$WantSizeMarkerColor = &TRUE, xor B$edi 0011
                inc esi | inc edi | jmp L0<<

            ...Else
L1:             mov B$edi bl | inc esi | inc edi | jmp L0<<

            ...End_If

        .End_While

      ; Arase any remaining color flag at the end of the last line
        mov ecx 100, al 0 | rep stosb

L9:     If B$BlockInside = &TRUE
            mov esi D@First, edx D@Last, eax D$BlockStartTextPtr, ebx D$BlockEndTextPtr

            On eax > ebx, xchg eax ebx

            On eax < esi, mov eax esi
            On ebx > edx, mov ebx edx

            sub eax D$CodeSource | add eax D$ColorsMap
            sub ebx D$CodeSource | add ebx D$ColorsMap | inc ebx

          ; Normal = 1 // Brackets = 2 // Strings = 3 // Comments = 4 // Selection 5
            While eax < ebx | On B$eax <> 0, mov B$eax 5 | inc eax | End_While
        End_If
;;
        ..If B$WantSizeMarkerColor = &TRUE
            mov esi D@First, edx D@Last, eax esi, ebx edx

            sub eax D$CodeSource | add eax D$ColorsMap
            sub ebx D$CodeSource | add ebx D$ColorsMap

            .While esi < edx
                .If B$esi = 167     ; Paragraph Char
                    If B$eax = 1
                        mov B$eax 2
                    Else_If B$eax = 2
                        mov B$eax 1
                    End_If
                .Else_If B$esi = 36 ; Dollar Char
                    If B$eax = 1
                        mov B$eax 2
                    Else_If B$eax = 2
                        mov B$eax 1
                    End_If
                .Else_If B$esi = '@'
                    If B$eax = 1
                        mov B$eax 2
                    Else_If B$eax = 2
                        mov B$eax 1
                    End_If
                .End_If
                
                inc eax | inc esi
            .End_While
        ..End_If
;;
EndP
____________________________________________________________________________________________

[ColorsMap: ?    ColorMapSize: ?]

[BlockStartTextPtr: D$ ?  BlockEndTextPtr: ?  ReverseBlock: B$ ?]

TextColorsMap:
    mov eax D$SourceLen | add eax 300 | Align_On 01000 eax

    If D$ColorMapSize < eax
        mov D$ColorMapSize eax
        VirtualFree D$ColorsMap
        VirtualAlloc ColorsMap, D$ColorMapSize
    End_If
ret
____________________________________________________________________________________________

[ParagraphChar: 36] ; 36 or 167 (Dollar or Paragraph)

TextOutput:
    mov esi D$UpperLine, ebx esi | sub ebx D$CodeSource | add ebx D$ColorsMap
    move D$Col D$FontWidth | mov D$Line 0

    push D$LineNumber
        inc D$LineNumber

        On D$RightScroll <> 0, call AjustForRightScroll

        push ebx
            call 'GDI32.TextOutA' D$hdc, 0, D$Line, BlankLine, 1
        pop ebx

      ; Set the Color for a Chunk of Text:
L0:     movzx eax B$ebx
        If al <> 5
            mov eax D$StatementColor+eax*4-4
            push esi, ebx
                push eax
                    call 'GDI32.SetBkColor' D$hdc D$NormalBackColor
                pop eax
                call 'GDI32.SetTextColor' D$hdc, eax
            pop ebx, esi
        Else
            push esi, ebx
                call 'GDI32.SetBkColor' D$hdc D$CaretColor
                call 'GDI32.SetTextColor' D$hdc D$NormalBackColor
            pop ebx, esi
        End_If

      ; How many Chars in that Color Chunk, into ecx:
        mov al B$ebx, ecx 0
        If al <> 0
            While B$ebx = al
                inc ebx | inc ecx
            End_While
        Else
          ; CR/LF:
            add ebx 2 | mov ecx 2 | dec D$LineNumber
        End_If

      ; Output:
        push esi, ebx, ecx
            ..If al <> 0
              ; Normal output:
                call RowToX ecx
              ; > eax = Number of Pixels to output.
                push eax
                  ; Limit to the available number of Chars:
                    add eax D$Col
                    If eax > D$EditRightPixel
                        pop ecx
                            mov ecx D$EditRightPixel | sub ecx D$Col
                        push ecx
                        call XToRow ecx | mov ecx eax
                    End_If
                    .If ecx <> 1
                        call 'GDI32.TextOutA' D$hdc, D$Col, D$Line, esi, ecx
                    .Else
                        If B$esi = 36
                            call 'GDI32.TextOutA' D$hdc, D$Col, D$Line, ParagraphChar, ecx
                        Else_If B$esi = 167
                            call 'GDI32.TextOutA' D$hdc, D$Col, D$Line, ParagraphChar, ecx
                        Else
                            call 'GDI32.TextOutA' D$hdc, D$Col, D$Line, esi, ecx
                        End_If
                    .End_If
                pop eax
                add D$Col eax

            ..Else
              ; CR/LF:
                mov eax D$EditRightPixel
                If eax > D$Col
                  ; Here we "blank" the End of Line:
                    sub eax D$Col | call XToRow eax
                    push ecx
                        call 'GDI32.TextOutA' D$hdc, D$Col, D$Line, BlankLine, eax
                    pop ecx
                End_If

              ; And here, we Blank the next Row Zero (DCBP,...):
                move D$col D$FontWidth | mov eax D$FontHeight | add D$Line eax
                On D$LineNumber > 0, call 'GDI32.TextOutA' D$hdc, 0, D$Line, BlankLine, 1

                If D$RightScroll <> 0
                    pop ecx, ebx, esi
                        call AjustForRightScroll
                    push esi, ebx, ecx
                End_If

            ..End_If
        pop ecx, ebx, esi

        add esi ecx | cmp D$LineNumber 0 | ja L0<<
    pop D$LineNumber
ret
____________________________________________________________________________________________

;;
  Outputs the Char under the Cursor. Usefull in case when the Blinking Cursor is
  set On, in Config, and that the partial redraw is called by 'BlinkProc',
  particulary in OverWrite Mode, that, otherwise, would leave this char blanked.
;;

CharOutput:
    mov esi D$UpperLine, eax 0, ebx 1, edx D$ColorsMap

    While esi < D$CurrentWritingPos
        If B$esi = CR
            add esi 2 | add edx 2
            mov ebx 1 | inc eax
        Else
            inc ebx | inc esi | inc edx
        End_If
    End_While

    call LineToY eax

    push eax | call RowToX ebx | pop ebx

    pushad
        If B$edx <> 5
            mov eax D$StatementColor+eax*4-4
            push eax
                call 'GDI32.SetBkColor' D$hdc D$NormalBackColor
            pop eax
            call 'GDI32.SetTextColor' D$hdc, eax
        Else
            call 'GDI32.SetBkColor' D$hdc D$CaretColor
            call 'GDI32.SetTextColor' D$hdc D$NormalBackColor
        End_If
    popad

    On B$esi <> CR, call 'GDI32.TextOutA' D$hdc, eax, ebx, esi, 1
ret
____________________________________________________________________________________________

AjustForRightScroll:
    mov eax D$RightScroll

L0: cmp B$ebx 0 | je L9>

    inc esi | inc ebx | dec eax | cmp eax 0 | ja L0<

L9: ret

;;
  We do not search directely for _the_ previous Color (far too complicated). We search
  for an upward Position that will give a proper start point for building the ColorMap.
  
  So, we:
  
  * exclude the Text Color (too many possible cases).
  
  * exclude the Comments cases (because of Multi-Lines Comments complications).
  
  We simply search for the next upper Line starting with either Statement or Data
  color. 'GetStartUpColorPos' return this Color (eax) and the according Pos in the
  user's SourceCode (esi). If Top of File is reached, we return the Statement Color.
;;

[PreviousStartUpColour: ?   PreviousStartUpColourPos: ?]

GetStartUpColorPos:
    mov esi D$UpperLine | sub esi D$CodeSource | add esi D$ColorsMap
    mov edx D$ColorsMap

  ; CRLF = 0 // Normal = 1 // Brackets = 2 // Strings = 3 // Comments = 4 // Selection 5
    While esi > edx
        .If B$esi = 0
            If B$esi+1 = 1
                mov eax 1 | jmp L5>
            Else_If B$esi+1 = 2
                mov eax 2 | jmp L5>
            End_If

L0:         dec esi
        .End_If

        dec esi
    End_While

  ; Top of File reached:
    move D$PreviousStartUpColourPos D$CodeSource
    mov D$PreviousStartUpColour 1  | ret

  ; Start point found. Check cases of Local Symbols label at first Row:
L5: inc esi | mov ebx esi
    sub ebx D$ColorsMap | add ebx D$CodeSource | On B$ebx = '@', jmp L0<

    sub esi D$ColorsMap | add esi D$CodeSource
    mov D$PreviousStartUpColourPos esi
    mov D$PreviousStartUpColour eax | ret
____________________________________________________________________________________________

____________________________________________________________________________________________

[PreviousUpperLine: ?]

PrintColorText:
    On B$SourceReady = &FALSE, ret
   ; On D$TitleFontHandle <> 0, ret

    call TextColorsMap | call InitPrintText | On D$LineNumber <s 1, ret

    If B$CaretOnlyRedraw = &TRUE
        call RemoveCaretAndUnderline | call CharOutput | call PrintCaretAndUnderline
        mov B$CaretOnlyRedraw &FALSE | jmp L9>>
    End_If

    call GetLastCharPosOnScreen

    mov eax D$PreviousUpperLine
    If eax <> D$Upperline
        call SetColorsMap D$CodeSource, D$LastCharPosOnScreen, 1
    Else
        call GetStartUpColorPos
        call SetColorsMap D$PreviousStartUpColourPos,
                          D$LastCharPosOnScreen, D$PreviousStartUpColour
    End_If

    call RemoveCaretAndUnderline | call TextOutput | call PrintCaretAndUnderline

    move D$PreviousUpperLine D$UpperLine

    ;If D$BreakPointsTables <> 0
    ;    On D$RightScroll = 0, call DrawTheRedPlots
    ;End_If

L9: ;call DrawMarginLine

    call ClosePrint
ret


PrintBp:
    On B$BpLineDrawn = &FALSE, call DrawBpLine

    If D$BreakPointsTables <> 0
        call DrawTheRedPlots
    Else
        call BlankMargin
    End_If
ret


[BpLineDrawn: ?
 BpLine:
 BpLineX1: ? BpLineY1: ? BpLineX2: ? BpLineY2: ?]

DrawBpLine:
    call 'USER32.BeginPaint' D$BpWindowHandle, PAINTSTRUCT | mov D$hdc eax

    call DrawTheBpLine

    call 'USER32.EndPaint' D$BpWindowHandle, PAINTSTRUCT

    mov B$BpLineDrawn &TRUE
ret

DrawTheBpLine:
    call 'USER32.GetClientRect' D$BpWindowHandle, BpLine

    mov eax D$BpLineX2 | dec eax | mov D$BpLineX1 eax

    call 'USER32.FillRect' D$hdc, BpLine, D$CaretBrushHandle
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 Once user has set the caret, let us say, in the middle of a line, and then moves
 up or down, we do not want the caret horizontal position to be reset definitively
 at left if vertical movement crosses some empty lines (or to left if shorter). So:
 Caret has 2 possible horizontal positions: the one we see at screen (Physical)
 and a virtual one (or physical, if the same), that allow keeping a raw displacement
 while jumping on shorter lines. 'PhysicalCaretRow' is set by writing routine;
 'CaretRow' is set by actions routines. When user hits a key driving an horizontal
 mouvement, we clear this virtual difference if any:
;;

[RealCaretRow | move D$CaretRow D$PhysicalCaretRow]

[MousePosX: ?   MousePosY: ?]

[GetMousePos | push D@Lparam | pop W$MousePosX, W$MousePosY]

[ClickOnMargin: ?  DoubleClickOnMargin: ?]

MouseTextPos:
    call YtoLine D$MousePosY | mov ebx eax
    call XtoRow D$MousePosX

L9: ;If eax < 1
    ;    mov B$ClickOnMargin &TRUE | mov eax 1
    ;Else
    ;    mov B$ClickOnMargin &FALSE
    ;End_If

    On eax = 0, mov eax 1

  ; > eax = Row from start of line // ebx = Line
ret


; Same as above, but with no adjustement (this is for the Mouse Blocks Selections):

SimpleMouseTextPos:
   ; mov eax D$MousePosX, ebx D$MousePosY
   ; shr eax 3 | shr ebx 4
    call YtoLine D$MousePosY | mov ebx eax
    call XtoRow D$MousePosX

    On eax = 0, inc eax
ret                            ; > eax = col from start of line   ebx = line


DownOneLine:
    push eax, ebx, ecx
        mov esi D$UpperLine
L0:     lodsb | cmp al LF | jne L0<                     ; New pos OK:

        mov ebx esi, ecx D$LineNumber
L0:     lodsb | On esi > D$SourceEnd, jmp L9>           ; abort if end of text found
            cmp al LF | jne L0<
        loop L0<
        mov D$UpperLine ebx
L9: pop ecx, ebx, eax
ret


UpOneLine:
    push eax
        mov esi D$UpperLine
        std
            lodsw
L0:         lodsb | cmp al LF | jne L0<
            add esi 2
            If esi >= D$CodeSource
                mov D$UpperLine esi
            Else
                move D$UpperLine D$CodeSource
            End_If
        cld
    pop eax
ret


FullDown:
    move D$UpperLine D$SourceEnd

  ; call OnlyOnePageUp
    mov ecx D$LineNumber | On ecx > 1, dec ecx
L0: call UpOneLine | loop L0<

    call OnlyOnePageDown
ret


OnlyOnePageDown:
L1: mov ebx D$LineNumber

    If D$CaretLine < ebx
        mov esi D$UpperLine, ecx D$LineNumber, ebx 0
L2:     lodsb | On esi > D$SourceEnd, jmp L3>
        cmp al LF | jne L2<
        inc ebx
        loop L2<
L3:     mov D$CaretLine ebx
    Else
        mov ecx ebx | On ecx > 1, dec ecx
L4:     push ecx
            call DownOneLine
        pop ecx | loop L4<
    End_If
ret


FullUp:
    move D$UpperLine D$CodeSource | mov D$CaretLine 0
ret

OnlyOnePageUp:
    mov eax D$LineNumber
    If D$CaretLine > 0
        mov D$CaretLine 0
    Else
        mov ecx eax | On ecx > 1, dec ecx
L0:     call UpOneLine | loop L0<
    End_If
ret


[BlockAutoDelete: &FALSE]

AutoDeleteBlock:
    If B$OldBlockInside = &TRUE
        .If B$SimulatedBlock <> &TRUE
            push eax
                mov B$BlockInside &TRUE | call ControlD | call AskForRedrawNow
            pop eax
        .End_If
    End_If
ret


[RIGHT_FEED 8]

OverwriteSource:
    On B$BlockAutoDelete = &TRUE, call AutoDeleteBlock

    mov edi D$CurrentWritingPos
    On B$edi = CR, jmp InsertSource
  ;  On eax = Tab, jmp TabCarret
    mov cl B$edi

    On al < 32, ret

    stosb

    push eax
        mov eax D$ColNumber
        If D$CaretRow < eax
            inc D$CaretRow
        Else
            add D$RightScroll RIGHT_FEED
            sub D$CaretRow 7
        End_If
    pop eax

    call DoStoreOverWrite
ret


[InsertedChar: ?]

InsertSource:   ; eax = Char.
    On B$BlockAutoDelete = &TRUE, call AutoDeleteBlock
InsertSourceOnBlockIndent:
    RealCaretRow

    Agree  al = 13, al = 10, al = tab
    Reject  al < 32  ;, al > 126

    mov esi D$SourceEnd | add esi 400 | mov edi esi      ; 400 is security 13/10/...
    mov ecx esi | sub ecx D$CurrentWritingPos | inc ecx

    If al = Tab
        mov B$InsertedChar ' ' | jmp L2>
    Else
        mov B$InsertedChar al
    End_If

L1: inc edi
    std
        rep movsb | stosb
    cld
    mov ebx 1 | jmp L3>

L2: mov eax D$CaretRow | add eax D$RightScroll
    add eax D$TabIs | dec eax
    mov ebx D$TabIs | neg ebx | and eax ebx
    mov ebx eax
    sub ebx D$CaretRow | sub ebx D$RightScroll | inc ebx
    add edi ebx
        std
            rep movsb | mov al ' ', ecx ebx | rep stosb
        cld

L3: add D$SourceLen ebx | add D$CurrentWritingPos ebx | add D$SourceEnd ebx

    mov eax D$ColNumber

    cmp D$CaretRow  eax | jae L4>
      add D$CaretRow ebx | jmp L9>
L4:   push ebx
      AlignOn RIGHT_FEED ebx | add D$RightScroll ebx | sub D$CaretRow ebx | inc D$CaretRow
      pop ebx

L9: call DoStoreInsert

    .If B$CompletionWanted = &TRUE
      ; To prevent from runing when doing the Substitution:
        If B$CompletionRuning = &FALSE
            call CodeComplete | mov B$CompletionRuning &FALSE
        End_If
    .End_If

ret
____________________________________________________________________________________________

InsertDoubleByte:
    cmp ah 0 | jne L1>
    call InsertSource
    ret

L1: mov esi D$SourceEnd | add esi 400 | mov edi esi
    mov ecx esi | sub ecx D$CurrentWritingPos | inc ecx

L2: add edi 2
        std
            rep movsb | stosb | mov al ah | stosb
        cld
        mov ebx 2

L3: add D$SourceLen ebx | add D$CurrentWritingPos ebx | add D$SourceEnd ebx

    mov eax D$ColNumber

    cmp D$CaretRow  eax | jae L4>
    add D$CaretRow ebx | jmp L9>
L4: push ebx
        AlignOn RIGHT_FEED ebx | add D$RightScroll ebx | sub D$CaretRow ebx | dec D$CaretRow
    pop ebx
L9: call DoStoreInsert
ret
____________________________________________________________________________________________

;;
 [Carriage Return] includes an indent feature. As many spaces may have to be added
 at once, we do not simply call to "InsertSource" for each but, instead insert all
 spaces at once for speed reasons (we make a move on the entire tail of file...):
;;

[AutoIndent: 0   AutoIndentFlag: &TRUE]

SetIndent:
    push eax
        mov D$AutoIndent 0, esi D$CurrentWritingPos

L0:     dec esi | cmp B$esi LF | ja L0<

        inc esi                             ; Start of Current Line.

        .If B$esi+2 = ':'
            add esi 3 | mov D$AutoIndent 3
            If esi > D$CurrentWritingPos
              ; Cases of CRLF from  a Pos before a Local Label:
                sub esi 3 | sub D$AutoIndent 3
            End_If
        .End_If

        While esi < D$CurrentWritingPos
            lodsb | cmp al ' ' | jne L9>
                inc D$AutoIndent
        End_While
L9: pop eax
ret


CarriageReturn:
    .If B$BlockAutoDelete = &TRUE
        If B$OldBlockInside = &TRUE
            call AutoDeleteBlock | ret
        End_If
    .End_If

    On B$AutoIndentFlag = &TRUE, call SetIndent
    mov eax CR | call InsertSource | mov eax LF | call InsertSource

    If D$AutoIndent > 0                                ; instead of "InsertSource":
        mov esi D$SourceEnd | add esi 400
        mov edi esi | add edi D$AutoIndent | mov ecx esi
        sub ecx D$CurrentWritingPos | inc ecx
        std
            rep movsb | mov ecx D$AutoIndent, al ' ' | rep stosb
        cld
        mov eax D$AutoIndent
        add D$SourceLen eax | add D$CurrentWritingPos eax | add D$SourceEnd eax
    End_If

    mov D$RightScroll 0 | move D$CaretRow D$AutoIndent
    inc D$CaretRow | mov eax D$LineNumber ;;;| mov D$AutoIndent 0   ; in case flag changed

    If D$CaretLine = eax
        call DownOneLine
    Else
        inc D$CaretLine
    End_If

    mov ebx D$AutoIndent     ; If AutoIndent on, we have to memorize this event now
    If ebx > 0               ; (after CR/LF recording. Undo will hold 2 jobs for this:
        mov D$InsertedChar ' '
        call DoStoreInsert   ; one for undo indent and another for undo CR/LF).
    End_If
ret
____________________________________________________________________________________________

;;
 Instead of searching if end of text is on screen, we try to move one line up: if it
 is possible, we try to move one line down. If it is unpossible, end of text is on
 screen and the one-line-up mouvement is validate:
;;

[CanGoUp: B$ ? CanGoDown: B$ ?]

TryToMove:
    On D$LineNumber <s 1, ret

L0: mov B$CanGoUp &FALSE, B$CanGoDown &FALSE,  esi D$UpperLine     ; try Up One Line:
    std
        lodsw
L1:     lodsb | cmp al LF | ja L1<
        add esi 2
    cld
    mov edx esi | On esi > D$CodeSource, mov B$CanGoUp &TRUE

    mov esi D$UpperLine, ecx D$LineNumber       ; try down one line:

L1: lodsb | cmp al LF | ja L1<
    loop L1<
    add esi 2 | On esi < D$SourceEnd, mov B$CanGoDown &TRUE

    On B$CanGoDown = &TRUE, ret
    On B$CanGoUp = &FALSE, ret

    mov D$UpperLine edx | inc D$CaretLine       ; up one line (down false / up true)
    jmp L0<
____________________________________________________________________________________________

ResetCaretOnStripTab:
    pushad
        std
L0:         lodsb | cmp al LF | jne L0<
        cld
        add esi 2 | mov ecx 0
L0:     lodsb | inc ecx | cmp al 255 | je L9>
            cmp al tab | jne L0<
                Align_on 8 ecx | jmp L0<
L9:     inc ecx | mov D$CaretRow ecx, D$PhysicalCaretRow ecx
    popad
ret


StripBackSpace:
    mov esi D$CurrentWritingPos
    If B$esi-1 = tab
        mov B$esi-1 255 | call ResetCaretOnStripTab
    End_If
    mov edi esi | dec edi, D$CurrentWritingPos, D$SourceLen, D$SourceEnd
    mov ecx D$SourceEnd | sub ecx D$CurrentWritingPos | add ecx 0100 | rep movsb
ret


BackSpace:
    ..If B$BlockAutoDelete = &TRUE
        .If B$OldBlockInside = &TRUE
            If al <> Tab
                call AutoDeleteBlock | ret
            End_If
        .End_If
    ..End_If
EraseLastChar:
    RealCaretRow | On D$SourceLen = 0, ret
    mov eax D$CurrentWritingPos | On eax = D$CodeSource, ret
    mov ebx BACK | call DoStoreCharDelete
    call StripBackSpace

    .If D$RightScroll = 0
        dec D$CaretRow
    .Else
        If D$CaretRow = 1
            sub D$RightScroll RIGHT_FEED
            add D$CaretRow (RIGHT_FEED-1)
        Else
            dec D$CaretRow
        End_If
    .End_If

    ...If D$CaretRow = 0
        mov esi D$CurrentWritingPos
        If D$CaretLine = 0
            call UpOneLine
        Else
            dec D$CaretLine
        End_If
        std | lodsb                                        ; strip CR
L0:         lodsb | cmp al LF | jne L0<
        cld
        lodsw                                              ; strip CR/LF
L0:     lodsb | inc D$CaretRow | cmp al tab | jne L1>
        or D$CaretRow 00_111 | inc D$CaretRow | jmp L0<
L1:     cmp al CR | ja L0<
        mov ebx BACK | call DoStoreCharDelete | call StripBackSpace | call TryToMove
    ...Else
;;
  When called from 'SimulateBlockForBackIndent' / 'IsItBlockIndent' / 'RetrieveBlockIndent'
  don't play: [Shift][Tab] is going on, not [Shift][BackSpace]. The 'OldBlockInside' Flag
  let us know of it:
;;
        ..If B$keys+&VK_SHIFT = &TRUE
            .If B$OldBlockInside = &FALSE
                mov eax D$CaretRow | dec eax | mov ebx D$TabIs | dec ebx | and eax ebx
                If eax <> 0
                    call AskForRedrawNow
                    mov eax D$CurrentWritingPos
                    On B$eax-1 = ' ', jmp BackSpace
                End_If
            .End_If
        ..End_If
    ...End_If
ret


KeyDown:
    mov eax D$LineNumber

    If D$CaretLine >= eax
        call DownOneLine
    Else
        mov esi D$CurrentWritingPos
L0:     lodsb | On esi > D$SourceEnd, ret
        cmp al LF | ja L0<
            inc D$CaretLine
    End_If
ret


KeyUp:
    If D$CaretLine = 0
      call UpOneLine
    Else
      dec D$CaretLine
    End_If

ret


StartOfLine:
    mov D$RightScroll 0, eax 1

    mov esi D$CurrentWritingPos | While B$esi-1 <> LF | dec esi | End_While

    .If B$esi+2 = ':'
        add esi 3 | add eax 3
        If B$esi = ':'
            inc esi | inc eax
        End_If
    .End_If
    While B$esi = ' ' | inc esi | inc eax | End_While

    If D$CaretRow = 1
        mov D$CaretRow eax
    Else_If D$CaretRow = eax
        mov D$CaretRow 1
    Else
        mov D$CaretRow eax
    End_If
ret


KeyLeft:
    RealCaretRow
SimpleKeyLeft:
    .If D$RightScroll > 0
        If D$CaretRow = 1
            sub D$RightScroll RIGHT_FEED
            add D$CaretRow (RIGHT_FEED-1)
        Else
            dec D$CaretRow
        End_If
    .Else_If D$CaretRow > 1
        dec D$CaretRow
    .End_If
ret
____________________________________________________________________________________________

; When user selects a Block with the KeyBoard, when he goes Down, and the start point of
; the selection is, say, at row 52, when he stops on a Line with 5 Chars, and hits the
; Left Arrow, he does not mean to wait that the Real Carret Col achieves moving back to
; the end of the 5 Chars Line, but, directely to unselect the 5th Char. For normal use,
; this complicated computation is done both by 'KeyLeft' and by 'PrintCaretAndUnderline',
; but, with Block Selection, there is no call to 'PrintCaretAndUnderline'? So:

SetPhysicalCaretRow:
    mov esi D$UpperLine, ecx 0

L0: cmp ecx D$CaretLine | je L2>                    ; search for Caret line (esi)
L1: lodsb | cmp al LF | jne L1<
    inc ecx | jmp L0<

L2: mov ecx 0
    On D$RightScroll > 0, sub ecx D$RightScroll

L0: cmp ecx D$CaretRow | je L5>>
L1: lodsb | cmp al CR | ja L2>                      ; search for Caret col (esi too)
        inc ecx
         mov D$PhysicalCaretRow ecx | jmp L6>>      ; Caret at end of line
L2: inc ecx | jmp L0<
L6: ret


StartOfWord:  ; KeyLeft
    mov esi D$CurrentWritingPos
    While B$esi-1 = ' ' | call SimpleKeyLeft | dec esi | End_While
    While B$esi-1 > ' ' | call SimpleKeyLeft | dec esi | End_While
    mov D$CurrentWritingPos esi
ret



EndOfLine:
    mov esi D$CurrentWritingPos | mov ecx D$ColNumber

L0: While B$esi <> CR
        If D$CaretRow < ecx
            inc D$CaretRow
        Else
            inc D$RightScroll
        End_If
        inc esi
    End_While

    AlignOn RIGHT_FEED D$RightScroll
ret


KeyRight:
    RealCaretRow

SimpleKeyRight:
    mov eax D$ColNumber

    If D$CaretRow < eax
        inc D$CaretRow
    Else
        add D$RightScroll RIGHT_FEED
        sub D$CaretRow 7
    End_If

    If B$CaretEndOfLine = &TRUE
        .If D$RightScroll > 0
            If D$CaretRow = 1
                sub D$RightScroll RIGHT_FEED
            End_If
        .Else
            dec D$CaretRow
        .End_If
    End_If
ret


EndOfWord:
    mov esi D$CurrentWritingPos
    While B$esi = ' ' | call SimpleKeyRight | inc esi | End_While
    While B$esi > ' ' | call SimpleKeyRight | inc esi | End_While
    mov D$CurrentWritingPos esi
ret


KeyInsert:
    xor B$CaretColor 00_01101001 | xor B$Overwrite &TRUE
ret


StripOneChar:
    inc D$CurrentWritingPos | mov ebx FORTH | call DoStoreCharDelete
    dec D$CurrentWritingPos
    mov esi D$CurrentWritingPos,  edi esi | inc esi | dec D$SourceLen, D$SourceEnd
    mov ecx D$SourceEnd | sub ecx D$CurrentWritingPos
    add ecx 0100 | rep movsb
ret


KeyDelete:
    .If B$BlockAutoDelete = &TRUE
        If B$BlockInside = &TRUE
            call ControlD | ret
        End_If
    .End_If

    RealCaretRow | On D$SourceLen = 0, ret
    mov eax D$CurrentWritingPos
    If eax < D$SourceEnd
        call StripOneChar | mov esi D$CurrentWritingPos
        On B$esi = LF, call StripOneChar
    End_If
ret

; (CaretPos to Source Pos).
; This is to translate screen line / col coordinates in one text pointer:
; input eax = Row; ebx = Line
; output eax = ptr

SearchTxtPtr:
    mov esi D$UpperLine, ecx 0, edx D$SourceEnd
    push eax
L0:     cmp ecx ebx | je L2>
L1:
            lodsb | cmp esi edx | ja L2>
            cmp al LF | jne L1<
                inc ecx | jmp L0<

L2: pop eax | mov ebx eax, ecx 0               ; switch eax (col Pos) > ebx
    add ebx D$RightScroll

L3: cmp esi edx | ja L9>
L3: lodsb | cmp esi edx | ja L9>
    cmp B$esi LF | je L8>
            inc ecx | cmp ecx ebx | jb L3<
                jmp L9>

L8: sub ebx ecx | sub D$CaretRow ebx | inc D$CaretRow

L9: dec esi | mov eax esi

    If D$CaretRow <s 1
        mov D$CaretRow 1 | mov D$RightScroll 0
    End_If
ret

____________________________________________________________________________________________

; In fact, sets the Caret and the Current Writing Position at the next Char after
; the Parameter.

Proc SetCaret:
    Argument @Location

        mov esi D$UpperLine, D$CaretRow 1, D$CaretLine 0

      ; Very rude and durty hak: There is a problem when the Search Box is runing and the
      ; user Click on a TITLE Tab... (temporary security >> To do analyze step by step what
      ; is going on when crossing these two...).
        mov eax D@Location
        If eax < D$CodeSource
            move D@Location D$CodeSource
        Else_If eax > D$SourceEnd
            move D@Location D$SourceEnd
        End_If

        While esi < D@Location
            If B$esi = LF
                mov D$CaretRow 1 | inc D$CaretLine
            Else
                inc D$CaretRow
            End_If
            inc esi
        End_While
        inc D$CaretRow | mov D$CurrentWritingPos esi
EndP


[FullRECT: ? ? ? ?  ConfinedRECT: ? ? ? ?  UserClickAfterEnd: ?  TrueCaretRow: ?]

LeftButtonSimulation:
    mov B$BlockInside &FALSE, B$UserClickAfterEnd &FALSE
    call MouseTextPos |  | jmp L2>>

LeftButton:
    mov B$BlockInside &FALSE, B$UserClickAfterEnd &FALSE, B$ClickOnMargin &FALSE

    If eax = D$EditWindowHandle
        call MouseTextPos | mov D$CaretRow eax, D$CaretLine ebx
    Else_If eax = D$BpWindowHandle
        mov B$ClickOnMargin &TRUE
        call MouseTextPos | mov D$CaretRow 1, eax 1, D$CaretLine ebx
    End_If

    .If B$ClickOnMargin = &TRUE
L1:    ;jmp DoubleClickMarginAction

        On D$BreakPointsTables = 0, call InitBreakPointsTables

        call IsBreakPointHere

        If B$InsideBpTable = &TRUE
            call DeleteBreakPoint | call DoStoreRemoveBP
        Else
            call SetBreakPoint | call DoStoreBP
        End_If

        mov B$UserClickAfterEnd &TRUE | jmp L9>>
    .End_If

L2: mov D$PhysicalCaretRow eax, D$CaretRow eax

    mov D$CaretLine ebx

L1: call SearchTxtPtr | mov D$ShiftDown eax  ; Ready for Block Selection

    If eax < D$SourceEnd
        mov D$CurrentWritingPos eax
    Else
        mov B$UserClickAfterEnd &TRUE
        call SetCaret D$SourceEnd
       ; mov eax D$CaretRow, ebx D$CaretLine | dec ebx | mov D$CaretLine ebx | jmp L1<
    End_If

    call 'USER32.GetClientRect' D$EditWindowHandle, ConfinedRECT
    call 'USER32.ClientToScreen' D$EditWindowHandle, ConfinedRECT
    lea eax D$ConfinedRECT+8
    call 'USER32.ClientToScreen' D$EditWindowHandle, eax
    mov eax D$FontWidth | sub D$ConfinedRECT eax
    call 'USER32.ClipCursor' ConfinedRECT
L9: ret


[StartBlockCol: ?  StartBlockLine: ?  EndBlockCol: ?  EndBlockLine: ?
 BlockInside: ?  BlockRedraw: ?    ShiftBlockInside: ?]

[MovingBlock: ?    BlockMoveDelay: ?    BlockMoveTicks: ?]

[PreviousMouseLine: ?    PreviousMouseCol: ?    FirstBlockDraw: ?]

SetBlock:
   ; Slow down the Block moving up or down (by mouse action). Speed increases while moving:
    .If B$MovingBlock = &TRUE
        If D$BlockMoveTicks = 0
            call 'KERNEL32.GetTickCount'
            add eax D$BlockMoveDelay | mov D$BlockMoveTicks eax
        Else
            Do
                call 'KERNEL32.GetTickCount'
            Loop_Until eax > D$BlockMoveTicks
            add eax D$BlockMoveDelay | mov D$BlockMoveTicks eax
            dec D$BlockMoveDelay | jnz L0>
                mov D$BlockMoveDelay 1
        End_If

    .Else
        mov D$BlockMoveTicks 0, D$BlockMoveDelay 60

    .End_If

  ; Set the new Block:
L0: If B$BlockInside = &TRUE
        move D$PhysicalCaretRow D$CaretRow
        mov B$CaretEndOfLine &FALSE
    Else
      ; D$ShiftDown is now set in 'LeftButton' (from WM_LBUTTONDOWN Case).
        mov eax D$CurrentWritingPos
        mov D$BlockStartTextPtr eax, D$BlockEndTextPtr eax
        call SimpleMouseTextPos
        mov D$CaretLine ebx, D$CaretRow eax
        mov D$PreviousMouseLine ebx, D$PreviousMouseCol eax
        mov D$ShiftBlockLine ebx, D$ShiftBlockCol eax
        mov B$FirstBlockDraw &TRUE, B$BlockRedraw &TRUE, B$BlockInside &TRUE | ret
    End_If

  ; Do not run for nop with an empty Block:
    call SimpleMouseTextPos | call SearchTxtPtr
    If eax = D$ShiftDown
        mov B$BlockInside &FALSE | ret
    End_If

    call SimpleMouseTextPos | mov D$PhysicalCaretRow eax, D$CaretRow eax

  ; Vertical Scrolling, if needed:
    push eax, ebx
        If ebx = 0
            push D$UpperLine
                call UpOneLine
            pop eax
            On D$UpperLine < eax, mov B$MovingBlock &TRUE
        Else_If ebx >= D$LineNumber
            push D$UpperLine
                call DownOneLine
            pop eax
            On D$UpperLine > eax, mov B$MovingBlock &TRUE
        Else
            mov B$MovingBlock &FALSE
        End_If
    pop ebx, eax

  ; Don't redraw for moves after End-of-Line (lazy reuse of SearchTxtPtr to ajust Row):
    push ebx | call SearchTxtPtr | pop ebx | mov eax D$CaretRow

  ; Compute and Redraw only if different:
    If B$FirstBlockDraw = &TRUE
        mov B$FirstBlockDraw &FALSE | jmp L1>
    Else_If B$MovingBlock = &TRUE
        jmp L1>
    Else_If eax <> D$PreviousMouseCol
        jmp L1>
    Else_If ebx <> D$PreviousMouseLine
L1:     mov D$PreviousMouseLine ebx, D$PreviousMouseCol eax
        mov D$CaretRow eax, D$CaretLine ebx

            call SetShiftBlock | mov B$ShiftBlockInside &FALSE

        mov B$BlockRedraw &TRUE
    Else
        mov B$BlockRedraw &FALSE
    End_If
ret
____________________________________________________________________________________________

; "On B$ebx = CR, dec D$BlockEndTextPtr" is because when a block-end-pointer points
; to an empty line, it is right upon the CR of next line. I spent much time to understand
; that, but it is normal. If it was a simple Caret, this would really be the good place.

LeftButtonUp:
    call 'USER32.IsMenu' D$FloatHandle
    On eax = &TRUE, call 'USER32.DestroyMenu' D$FloatHandle

    call 'USER32.ClipCursor' &NULL
    On B$BlockInside = &FALSE, ret
    If B$UserClickAfterEnd = &TRUE
        mov B$BlockInside &FALSE | ret
    End_If

    mov B$MovingBlock &FALSE
ret
; Should be no more use, with new Block Routines:
    mov eax D$BlockStartTextPtr
    cmp eax D$BlockEndTextPtr | jna L5>
        push eax, D$BlockEndTextPtr | pop D$BlockStartTextPtr D$BlockEndTextPtr
L5: mov ebx D$BlockEndTextPtr
    On B$ebx = CR, dec D$BlockEndTextPtr
    mov eax D$RightScroll | add D$BlockStartTextPtr eax | add D$BlockEndTextPtr eax
ret
____________________________________________________________________________________________

; Block action routines:

[hBlock: ?  BlockSize: ?  ClipBoardPTR: ?  ClipBoardLen: ?]

ControlC:
    cmp B$BlockInside &FALSE | je L9>>

    call 'USER32.OpenClipboard' D$hwnd | cmp eax 0 | je L9>>
    call 'USER32.EmptyClipboard' | cmp eax 0 | je L8>>
    mov ecx D$BlockEndTextPtr | sub ecx D$BlockStartTextPtr | inc ecx
    mov D$BlockSize ecx | mov ebx ecx | inc ebx
    call 'KERNEL32.GlobalAlloc' &GMEM_DDESHARE, ebx | cmp eax 0 | je L8>  ; > eax = handle
    mov D$hBlock eax
    call 'KERNEL32.GlobalLock' eax                                       ; > eax = adress
    mov edi eax, esi D$BlockStartTextPtr, ecx D$BlockSize
    rep movsb | mov al 0 | stosb
    call 'KERNEL32.GlobalUnlock' D$hBlock
    call 'USER32.SetClipboardData' &CF_TEXT, D$hBlock

L8: call 'USER32.CloseClipboard'
L9: ret


ControlY:
    If D$DebugDialogHandle <> 0
        call KillDebugger | On eax = &IDNO, jmp L9>>
    End_If

    mov esi D$CurrentWritingPos
    While esi > D$CodeSource
        dec esi | cmp B$esi CR | je L1>
    End_While

L1: mov D$BlockStartTextPtr esi
    While esi < D$SourceEnd
        inc esi | cmp B$esi CR | je L1>
    End_While

L1: dec esi | mov D$BlockEndTextPtr esi
    If esi > D$BlockStartTextPtr
        push D$CaretRow
            mov B$BlockInside &TRUE | call ControlD | call KeyDown
        pop D$CaretRow
    End_If
ret


ControlD:
    cmp B$BlockInside &FALSE | je L9>>
    jmp L0>

ControlX:
    cmp B$BlockInside &FALSE | je L9>>
    call ControlC

L0: If D$DebugDialogHandle <> 0
        call KillDebugger | On eax = &IDNO, jmp L9>>
    End_If

    call WriteUndoBlockFileFromBlock | call StoreUserActionOfBlockDeletion

    mov eax D$CaretRow, ebx D$CaretLine | call SearchTxtPtr

    ...If eax <> D$BlockStartTextPtr

        std                                         ; reset cursor at "BlockStartText":
            mov esi D$BlockEndTextPtr
L0:         cmp esi D$BlockStartTextPtr | je L2>
                lodsb
                cmp al LF | jne L0<
                If esi < D$LastCharPosOnScreen         ; do not DEC Caret Line if block bigger
                    sub D$CaretLine 1 | jc L1>      ; than screen "upward drawn" by user
                End_If
                jmp L0<
L1:         mov D$CaretLine 0 | jmp L0<             ; same, but "downward drawn" by user

L2:         mov D$CaretRow 1 | dec esi              ; search for Col:
L3:         lodsb | cmp al LF | je L4>              ; count how many chars between start of block
                ;cmp esi D$CodeSource | jbe L4>      ; and left edge
                If esi <= D$CodeSource
                    add D$CaretRow 2 | jmp L4>
                End_If
                inc D$CaretRow | jmp L3<

L4:         .If esi < D$Upperline                   ; rePos screen if block greater than screen:
                mov eax D$UpperLine
                If eax > D$CodeSource
                    add esi 2
                    mov D$Upperline esi
                    mov D$CaretLine 0
                Else
                    inc D$CaretRow
                End_If
            .End_If

            move D$PhysicalCaretRow D$CaretRow
        cld

        move D$CurrentWritingPos D$BlockStartTextPtr

    ...End_If

UndoControlV:                                   ; strip text:

    mov edi D$BlockStartTextPtr, esi D$BlockEndTextPtr | inc esi

    mov eax esi | sub eax edi                   ; eax = Block-to-strip-out length
    push eax
        mov ecx D$SourceEnd | add ecx 100 | sub ecx esi | rep movsb
    pop eax
    sub D$SourceEnd eax | sub D$SourceLen eax | jnc L0>
        mov D$SourceLen 0

  ; Should be no use. just to be absolutely sure no wrong CR/LF after End Of Source:
L0: mov edi D$SourceEnd | mov eax 0A0D0A0D, ecx 100 | rep stosd
    call TryToMove                              ; ensure screen Pos in all cases.

    mov B$BlockInside &FALSE

;;
  This rebuild should be no use (???), and switches to the Next TITLE, in case of
  Block Deletions, probably, because the 'BlockEndTextPtr', of the deleted Chunk
  is at a virtual Pos in the next Tab (???) before the Redraw of the Caret (???).
  
  In case this Comment-Out, would produce some un-wished side-effect, restore it,
  and try to redefine the Caret Pos (line and Row), at the 'BlockStartTextPtr',
  immidiately after the Block Deletion, above, in 'ControlX'. It is already "done",
  but seems to be ineffective... :( :(( :(((
;;
L9: ;call RestoreRealSource | call SetPartialEditionFromPos
ret


OpenClipBoard:
    mov D$ClipBoardLen 0
    call 'USER32.IsClipboardFormatAvailable' &CF_TEXT | cmp eax 0 | je L9>>
    call 'USER32.OpenClipboard' D$hwnd | cmp eax 0 | je L9>>
    call 'USER32.GetClipboardData' &CF_TEXT  | cmp eax 0 | je L8>>    ; > eax = handle
    mov D$hBlock eax
    call 'KERNEL32.GlobalLock' eax                          ; > eax = pointer

    mov D$ClipBoardPtr eax
    mov edi eax, al 0, ecx 0-1 | repne scasb
    mov ecx edi | sub ecx D$ClipBoardPtr | dec ecx          ; len
    mov D$ClipBoardLen ecx
    call ClipBordCleaner
L9: ret
L8: call 'USER32.CloseClipboard' | ret


ClipBordCleaner:
    mov esi D$ClipBoardPtr
BlockCleaner:
L0: lodsb | If al = CR
                On B$esi <> LF, mov B$esi-1 ' '
                inc esi | dec ecx | jecxz L9>
            Else_If al = LF
                mov B$esi-1 ' '
            Else_If al < ' '
                mov B$esi-1 ' '
            Else_If al = 255      ;> 127
                mov B$esi-1 ' '
            End_If
    loop L0<
L9: ret


KillTabs:
    mov esi D$CodeSource, ecx D$SourceLen
KillTab:
L0: lodsb | cmp al tab | jne L1>
        mov B$esi-1 ' '
L1: loop L0<
ret


CloseClipBoard:
    call 'KERNEL32.GlobalUnlock' D$hBlock
    call 'USER32.CloseClipboard'
ret


[TooLongClipBoard: "
  ClipBord size too big. The limit is 1,000,000 octets.
  Do this in several operations. After each paste, Compile,
  close RosAsm and re-run.", 0

NotEnoughMemLeft: "
  Not enough Memory left for pasting this CliBoard.
  Compile, if you want to save your work, Close
  RosAsm and re-run", 0

CloseToMemoryEnd: "
  After pasting this ClibBoard, Compile, to save your work,
  Close RosAsm and re-run, to enable more Memory", 0]

ControlV:
    call OpenClipBoard | On D$ClipBoardLen = 0, jmp L7>>

    If D$DebugDialogHandle <> 0
        call KillDebugger | On eax = &IDNO, jmp L9>>
    End_If

    call ReMapSourceMemoryIfNeeded D$ClipBoardLen | On eax = &IDNO, jmp L7>>

    If B$BlockAutoDelete = &TRUE
        On B$BlockInside = &TRUE, call ControlD
    End_If

    call DoStoreBlockPaste

  ; Make room inside our text:
    mov esi D$SourceEnd | add esi 400
    mov edi esi | add edi D$ClipBoardLen
    mov ecx esi | sub ecx D$CurrentWritingPos | inc ecx
    std | rep movsb | cld | inc esi

  ; Write from clipboard:
    mov edi esi, esi D$ClipBoardPtr, ecx D$ClipBoardLen
    pushad | rep movsb | popad

  ; Search for the new Caret Position:
    mov esi edi, ebx D$CaretLine
L0: lodsb | inc D$CaretRow | cmp al CR | jne L1>
        inc ebx | mov D$CaretRow 1 | lodsb | dec ecx | jz L0>
L1: loop L0<

L0: cmp ebx D$LineNumber | jna L6>
        mov esi D$UpperLine | mov ecx ebx | sub ecx D$CaretLine
L1:     lodsb | cmp al LF | ja L1<
            mov D$UpperLine esi | dec ebx | jmp L0<

L6: mov D$CaretLine ebx

    mov eax D$ClipBoardLen
    add D$SourceLen eax | add D$SourceEnd eax | add D$CurrentWritingPos eax
L7: call 'KERNEL32.GlobalUnlock' D$hBlock
L8: call 'USER32.CloseClipboard'
L9: ret
____________________________________________________________________________________________

[ExtendMemoryString: "This operation requires more Memory than actually reserved:

Extend ?...", 0]

[UserPeStartEqualCodeSource: ?]

Proc ReMapSourceMemoryIfNeeded:
    Argument @Added
    [@TempoPointer: ?]

        shl D@Added 1
      ; (to care about Tabs-partial-editions !!!)

        mov eax D$CodeSource, ebx D$UserPeStart
        and eax 0_FFFF_FFF0 | and ebx 0_FFFF_FFF0

        If eax = ebx
            mov B$UserPeStartEqualCodeSource &TRUE
        Else
            mov B$UserPeStartEqualCodeSource &FALSE
        End_If

        add eax D$SourceLen | add eax D@Added | add eax 400

        ...If eax >= D$EndOfSourceMemory
            call 'USER32.MessageBoxA' D$hwnd, ExtendMemoryString, Argh, &MB_YESNO
            .If eax = &IDYES
                call RestoreRealSource

              ; New User PE Memory size:
                mov ecx D$EndOfSourceMemory | sub ecx D$UserPeStart
                add ecx D@Added | shl ecx 1 | add ecx 0100_000

                push ecx
                  ; Allocate to 'TempoPointer':
                    VirtualAlloc @TempoPointer, ecx

                  ; Copy it all:
                    mov esi D$UserPeStart, edi D@TempoPointer

                    If B$UserPeStartEqualCodeSource = &TRUE
                        mov D$edi CRLF2, D$edi+4 CRLF2 | add edi 4 | add D@TempoPointer 4
                    End_If

                    mov ecx D$EndOfSourceMemory | sub ecx D$UserPeStart
                    shr ecx 2 | rep movsd
                pop ecx
                add ecx D@TempoPointer | mov D$EndOfSourceMemory ecx

              ; New 'CodeSource', 'SourceEnd', 'CurrentWritingPos', 'UpperLine':
                mov eax D@TempoPointer | sub eax D$UserPeStart
                add D$CodeSource eax
                add D$CurrentWritingPos eax
                add D$UpperLine eax
                add D$SourceEnd eax

                push D$CurrentWritingPos, D$UpperLine, D$CaretLine, D$CaretRow

                  ; Release old Memory:
                    Exchange D$UserPeStart D@TempoPointer
                    VirtualFree D@TempoPointer

                  ; SourceLen may be = 0, when pasting after a [File]/[New]:
                    On D$Sourcelen > 0, call StartEdition

                    mov eax &IDOK

                pop D$CaretRow, D$CaretLine, D$UpperLine, D$CurrentWritingPos

                call SetPartialEditionFromPos

                mov eax &IDYES
            .End_If

          ; eax = &IDNO if not &IDYES

        ...Else
            mov eax &IDOK

        ...End_If
EndP
____________________________________________________________________________________________

; [F8] Separator Line

DrawOneLine:
    RealCaretRow

    mov esi D$SourceEnd | add esi 400 | mov edi esi      ; 400 is security 13/10/...
    mov ecx esi, ebx DRAWLINELEN | sub ecx D$CurrentWritingPos | inc ecx

    add edi ebx
        std
          rep movsb
          mov al '_', ecx ebx | rep stosb
        cld

    add D$SourceLen ebx | add D$CurrentWritingPos ebx | add D$SourceEnd ebx

    mov D$InsertedChar '_'

    call DoStoreInsert | call CarriageReturn
ret

____________________________________________________________________________________________

[WithControlA: ?]

ControlA:
    If B$WithControlA = &TRUE
        move D$BlockStartTextPtr D$CodeSource
        move D$BlockEndTextPtr D$SourceEnd
      ; SourceEnd is the Byte _after_ // BlockEndTextPtr is the last Byte:
        dec D$BlockEndTextPtr
        mov B$BlockInside &TRUE
    End_If
ret
____________________________________________________________________________________________

AskForRedraw:
    mov B$CaretOnlyRedraw &FALSE
    call 'USER32.RedrawWindow' D$BpWindowHandle, 0, 0, &RDW_INVALIDATE+&RDW_INTERNALPAINT
    call 'USER32.RedrawWindow' D$EditWindowHandle, 0, 0, &RDW_INVALIDATE+&RDW_INTERNALPAINT
ret


AskForRedrawNow:
    mov B$CaretOnlyRedraw &FALSE
    call 'USER32.RedrawWindow' D$BpWindowHandle, 0, 0,
                               &RDW_INVALIDATE+&RDW_INTERNALPAINT+&RDW_UPDATENOW
    call 'USER32.RedrawWindow' D$EditWindowHandle, 0, 0,
                               &RDW_INVALIDATE+&RDW_INTERNALPAINT+&RDW_UPDATENOW
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

;                               Source Edition Routines.
____________________________________________________________________________________________

; The Source Editor does not use any concept of Line / Row for defining the actual
; editing Position. For Status Bar, we need them, and for ScrollBar, the Line too.

[StatusLine: 0   StatusCol: 0   TotalNumberOfLines: 0]

[VScroll:
 VScroll.cbSize: D$ len
 VScroll.fMask: D$ &SIF_ALL__&SIF_DISABLENOSCROLL ; = &SIF_PAGE+&SIF_POS+&SIF_RANGE // &SIF_DISABLENOSCROLL
 VScroll.nMin: D$ 1
 VScroll.nMax: D$ 0
 VScroll.nPage: D$ 0
 VScroll.nPos: D$ 0
 VScroll.nTrackPos: D$ 0]

[TestCodeSource: ?]

TextPos:
    mov edi D$CodeSource, ecx 0-1, al CR, D$StatusLine 0, D$StatusCol 0
    Align 32

    mov ebx D$UpperLine
    If ebx < D$CodeSource
        move D$UpperLine D$CodeSource, D$CurrentWritingPos D$CodeSource
        mov D$CaretRow 1, D$CaretLine 0, D$PhysicalCaretRow 1

    Else_If ebx > D$SourceEnd
        move D$UpperLine D$CodeSource, D$CurrentWritingPos D$CodeSource
        mov D$CaretRow 1, D$CaretLine 0, D$PhysicalCaretRow 1

    End_If

L0: repne scasb | inc D$StatusLine | cmp edi D$UpperLine | jb L0<

    move D$TotalNumberOfLines D$StatusLine
    mov eax D$CaretLine | add D$StatusLine eax

    mov al CR
L0: repne scasb | inc D$TotalNumberOfLines | cmp edi D$SourceEnd | jb L0<
    mov eax D$TotalNumberOfLines | dec eax

    move D$VScroll.nMax eax
    move D$VScroll.nPage D$LineNumber
    mov eax D$statusLine | sub eax D$CaretLine | inc eax
    mov D$VScroll.nPos eax

RedrawScrollBar:
    On B$ScrollBarWanted = &TRUE,
        call 'USER32.SetScrollInfo' D$ScrollWindowHandle, &SB_VERT, VScroll, &TRUE
ret


RePosFromScroll:    ; called with eax = Line Number Wanted by user Bar Scrolling.
    mov edi D$CodeSource, ecx 0-1, al CR, D$StatusLine 0, D$StatusCol 0
   ; Align 32
    mov ecx D$SourceLen
L0: cmp edx 1 | je L1>
L0: repne scasb | dec edx | cmp edx 1 | ja L0<
   ; jz L9>
    inc edi
L1: mov D$UpperLine edi

L9: ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
 The Editor may let no use Spaces (between the end of text and CR/LF. This happend,
 for example when you enter blanks Lines on Indentations.

 The first time i applied it on RosAsm Source, it retrieved 15046 no use Spaces. This
 is to say less than 1 per cent of the Source. So, i do not implement it in the Menu,
 and as this is fast enough i implement it when opening a file.
 (OpenSourceOnly / OpenRosAsmPE).
;;

KillTrailingSpaces:
    call CorrectCRLFs D$CodeSource, D$SourceEnd

    mov esi D$CodeSource, edi esi, ecx 0, edx D$SourceEnd

    .While esi <= edx
        lodsb

        .If al = '"'
L0:         stosb | lodsb | cmp esi edx | jae L9>>
            cmp al '"' | jne L0<    ; Allow blank Lines in Data Text.

        .Else_If al = "'"
L0:         stosb | lodsb | cmp esi edx | jae L9>>
            cmp al "'" | jne L0<

        .Else_If al = ';'
            If D$esi-2 = MLC   ; (LF ; ; CR)
                Do
                    stosb | lodsb | cmp esi edx | je L9>
                Loop_Until D$esi-2 = MLC
            Else
L0:             stosb | lodsb | cmp al CR | jne L0<
                    jmp L1>
            End_If

        .Else_If al = CR
L1:         While B$edi-1 = ' '
                dec edi | dec D$SourceLen | dec D$SourceEnd
                inc ecx
            End_While

        .End_If

        stosb

    .End_While

L9: If B$edi-1 = CR
        mov B$edi LF | inc D$SourceEnd | inc D$SourceLen | inc edi
    End_If

    shr ecx 2 | add ecx 10 | mov eax CRLF2 | rep stosd
ret
____________________________________________________________________________________________

Proc CorrectCRLFs:
    Arguments @Start, @End

        mov esi D@Start, edx D@End

        While esi < edx
            If B$esi = CR
                On B$esi+1 = CR, mov B$esi+1 LF
            Else_If B$esi = LF
                On B$esi-1 = LF, mov B$esi-1 CR
            End_If

            inc esi
        End_While
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

[LineToWheelScroll: D$ 1] ; Default to 1 Line per Message. 'SM_MOUSEWHEELPRESENT' may
; return FALSE even if a Wheel Mouse *is* present.

GetWheelInfo:
    call 'USER32.GetSystemMetrics' &SM_MOUSEWHEELPRESENT
    .If eax = &TRUE
        call 'USER32.SystemParametersInfoA' &SPI_GETWHEELSCROLLLINES, 0,
                                            LineToWheelScroll, 0
        If D$LineToWheelScroll = 0
            mov D$LineToWheelScroll 3
        Else_If D$LineToWheelScroll > 30
            mov D$LineToWheelScroll 3
        End_If
    .End_If
ret


WheelMsg:
    mov ecx D$LineToWheelScroll | shr eax 16 | jecxz L9>
    If ax >s 0
L0:    call UpOneLine | loop L0<
    Else
L0:    call DownOneLine | loop L0<
    End_if
    call AskForRedraw
L9: ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; Positioning Edition at 'MainWindowProc' or at 'Main' or at Top:

StartEdition:
    call GetEditWindowClientRectangle

    ;call ScanSourceForBadChars

    mov edx CallBackName, ebx D$CallBackNameLen

    call InternSearch

    On B$BlockInside = &TRUE, jmp L9>
        mov edx EntryPointLabel, ebx 0, eax edx
        While B$eax <> 0 | inc ebx | inc eax | End_While

        call InternSearch

L9: mov B$OnReplaceAll &FALSE, B$BlocKInside &FALSE, B$DownSearch &TRUE, B$ReadyToRun &FALSE
    call StorePosInBackTable

    mov D$TitleTable 0, D$PreviousPartialSourceLen 0

    call ReplaceParagraphByDollar
ret


ScanSourceForBadChars:
    mov esi D$CodeSource, edx D$SourceEnd

    sub edx 100
    showme edx
ret

    While esi < edx
        lodsb

        If al < LF
           ; hexprint 1
        Else_If al > 127
            mov edi TrashString, ecx 100
            dec esi
            rep movsb
            showme TrashString
        End_If
    End_While
ret


GetEditWindowClientRectangle:
    call 'USER32.GetClientRect' D$EditWindowHandle RECT
      mov eax D$RECTright | sub eax D$RECTleft
      shr eax 3 | dec eax | mov D$ColNumber eax
        mov eax D$RECTbottom | sub eax D$RECTtop
          or eax 00111 | xor eax 00111
            shr eax 4 | dec eax | mov D$LineNumber eax
ret


ReplaceParagraphByDollar:
    mov eax D$CodeSource, ecx D$SourceEnd

    While eax < ecx
      ; 167 = Code of Paragraph Char (yet available as keyboard input, but no more
      ; available as screen output).
        If D$eax = MLC
            add eax 4
            While D$eax <> MLC
                On eax = ecx, jmp L9>>
                inc eax
            End_While
            add eax 2

        Else_If B$eax = ';'
            While B$eax > CR
                inc eax | On eax = ecx, jmp L9>>
            End_While

        Else_If B$eax = '"'
            inc eax
            While B$eax <> '"'
                inc eax | On eax = ecx, jmp L9>>
            End_While

        Else_If B$eax = "'"
            inc eax
            While B$eax <> "'"
                inc eax | On eax = ecx, jmp L9>>
            End_While

        Else_If B$eax = 167
            mov B$eax '$'

        End_If

        inc eax
    End_While

L9: ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[HelpHandle: 0    HelpMutexName: 'BaseMutexName', 0
 RosAsmHelpClassName: 'RosAsmHelpEditClass',0]

; We close B_U_Asm if run from RosAsm:

CloseHelp:
    call 'KERNEL32.CreateMutexA' &NULL &TRUE HelpMutexName         ; Someone?
    call 'KERNEL32.GetLastError'
    .If eax = &ERROR_ALREADY_EXISTS
        call 'User32.FindWindowA' RosAsmHelpClassName &NULL | mov D$HelpHandle eax

        call 'User32.GetWindowLongA' D$HelpHandle &GWL_EXSTYLE

        If eax <> &WS_EX_WINDOWEDGE                                 ; WS_EX value if auto-run
            call 'User32.SendMessageA' D$HelpHandle  &WM_CLOSE  0  0 ; If run from RosAsm
        End_If

    .End_If
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; Simplified version of 'RightClick' Search (used by 'StartEdition' to point out 'Main' or
; MainWindowProc:

InternSearch:
    mov B$InsideMLC &FALSE, B$InsideComment &FALSE
    mov ah B$edx | or ah 32                           ; ah = first char
    inc edx                                           ; edx > second char (> edi)
    sub ebx 1

    ; Now, edi (edx) > start+1 of right clicked word; ebx = len-1. Search fitting:
L0: mov esi D$CodeSource, ecx D$SourceLen, B$InsideBracket &FALSE, B$InsideComment &FALSE

    jmp L0>

T0: lodsb | jmp L1>                          ; simplified loop for strip texts and comments
T1: loop T0<
      ret

L0: lodsb | cmp al ah | je L3>>              ; test XORed AH each pass in order to handle
            xor ah 32 | cmp al ah | je L3>>  ; case without modifying AL (following tests)
      jmp L1>
L2: loop L0<
        ret

L1: cmp B$InsideMLC &TRUE | jne L1>
      cmp D$esi-2 MLC | jne T1<          ; (LF ; ; CR)
        mov B$InsideMLC &FALSE | jmp L2<
L1: cmp B$InsideComment &TRUE | jne L1>
      cmp al LF  | jne T1<
        mov B$InsideComment &FALSE | jmp L2<
L1: cmp B$InsideText &FALSE | je L1>
      cmp al B$InsideText | jne T1<
        mov B$InsideText &FALSE | jmp L2<
L1: cmp al "'" | jne L1>
      mov B$InsideText al | jmp T1<
L1: cmp al '"' | jne L1>
      mov B$InsideText al | jmp T1<
L1: cmp al '[' | jne L1>
      mov B$InsideBracket &TRUE, B$DataDeclaration &FALSE    ;;;, B$OddWord 1
S0:   cmp B$esi ' ' | jne L2<
        inc esi | sub ecx 1 | jnc S0<        ; strip double spaces
          ret
L1: cmp al ']' | jne L1>
      mov B$InsideBracket &FALSE, B$DataDeclaration &FALSE | jmp L2<<
L1: cmp al ';' | jne L1>                     ; jmp over comments
        If D$esi-2 = MLC   ; (LF ; ; CR)
            mov B$InsideMLC &TRUE | jmp T1<<
        Else
            mov B$InsideComment &TRUE | jmp T1<<
        End_If
L1: cmp al '|' | jne L1>
      mov B$InsideBracket &FALSE | jmp L2<<
L1: cmp al ':' | jne L2<<
      mov B$DataDeclaration &TRUE

            jmp L2<<                     ; (avoids pointing equates datas).

L3: mov al B$esi-2 | call WordEdge | cmp B$Edge &FALSE | je L2<<     ; left edge?

        mov D$NumberDashLines 0

        pushad | mov ecx ebx, edi edx
C0:       lodsb | mov ah B$edi | inc edi | or ax 02020     ; case insensitive comparison

            While B$esi-1 = '_'
                lodsb | or al 020 | inc D$NumberDashLines
            End_While

            While B$edi-1 = '_'
                mov ah B$edi | or ah 020 | inc edi | dec ecx | jz C1>
            End_While

          cmp ah al | jne C1>
            loop C0<

            mov al B$esi | call WordEdge
            If B$Edge = &FALSE
                popad | jmp L2<<
            End_If
            popad | jmp C2>

C1:     popad | jne L2<<

   ; mov al B$esi+ebx | call WordEdge | cmp B$Edge &FALSE | je L2<<    ; right edge?

; as we have tested for '|' (> InsideBracket = FALSE), "test B$OddWord 1" applies either
; uppon first word of macro def. or odd word of equate def. But data body could still
; be pointed as odd equate dec. So we finally test 'B$DataDeclaration'.

C2: push ebx
        add ebx D$NumberDashLines
        cmp B$esi+ebx ':'
    pop ebx
    je L4>                                 ; Label?
      cmp B$InsideBracket &TRUE | jne L2<<                     ; equ. / macro
          cmp B$DataDeclaration &TRUE | je L2<<  ; avoid pointing data body instead of Equate

L4: dec esi                                                    ; found
    mov D$BlockStartTextPtr esi, D$RCstart esi                 ; RCstart/End used by
    add esi ebx | mov D$BlockEndTextPtr esi, D$RCend esi       ; 'BackClick'
    mov B$BlockInside &TRUE
    inc esi | mov D$CurrentWritingPos esi

    std | mov ecx 0
L5:     lodsb | inc ecx | cmp al LF | jne L5<                  ; search for start of line
    cld | dec ecx

    add esi 2 | mov D$UpperLine esi                            ; and set all needed
    call UpOneLine | call UpOneLine | call UpOneLine           ; variables for Pos, in
    mov D$CaretLine 3, D$CaretRow ecx, D$PhysicalCaretRow ecx  ; case user wish editing
    call TryToMove

L9: ret
____________________________________________________________________________________________

; [F11] / [F12] instant BookMark feature

[F11Upperline: ?    F11CurrentWritingPos: ?    F11CaretLine: ?    F11CaretRow: ?]

SavePosOnF11:
    call ClearF12
    call RestoreRealSource
    move D$F11Upperline D$Upperline, D$F11CurrentWritingPos D$CurrentWritingPos,
         D$F11CaretLine D$CaretLine, D$F11CaretRow D$CaretRow
    call SetPartialEditionFromPos
ret


[F12Upperline: ?    F12CurrentWritingPos: ?    F12CaretLine: ?    F12CaretRow: ?]

SetPosOnF12:
    ..If D$F11Upperline <> 0
        call RestoreRealSource

        mov eax D$Upperline

      ; If we are not already at the saved F11 Pos, we go to it:
        .If eax <> D$F11Upperline
          ; Save first the actual F12 Pos for On-Off effect:
            move D$F12Upperline D$Upperline, D$F12CurrentWritingPos D$CurrentWritingPos,
                 D$F12CaretLine D$CaretLine, D$F12CaretRow D$CaretRow
          ; Go:
            move D$Upperline D$F11Upperline, D$CurrentWritingPos D$F11CurrentWritingPos,
                 D$CaretLine D$F11CaretLine, D$CaretRow D$F11CaretRow

        .Else
          ; Pos is the one save by F11: we switch back to the F12 previous Pos:
            If D$F12Upperline <> 0
                move D$Upperline D$F12Upperline, D$CurrentWritingPos D$F12CurrentWritingPos,
                     D$CaretLine D$F12CaretLine, D$CaretRow D$F12CaretRow
            End_If

        .End_If

        call SetPartialEditionFromPos

        mov esi D$Upperline
        While B$esi-1 <> LF | dec esi | End_While
        mov D$Upperline esi

    ..End_If
ret


ClearF11F12:
    mov edi F11Upperline, eax 0, ecx 4 | rep stosd
ClearF12:
    mov edi F12Upperline, eax 0, ecx 4 | rep stosd
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[EditorLOGFONT:
 @lfHeight: D$ 0_FFFF_FFF3
 @lfWidth: D$ 0
 @lfEscapement: D$ 0
 @lfOrientation: D$ 0
 @lfWeight: D$ 02BC
 @lfItalic: B$ 0
 @lfUnderline: B$ 0
 @lfStrikeOut: B$ 0
 @lfCharSet: B$ 0
 @lfOutPrecision: B$ 03
 @lfClipPrecision: B$ 02
 @lfQuality: B$ 01
 @lfPitchAndFamily: B$ 031
 @lfFaceName: 'Courier New', 0
 @Trailing: B$ 0 #&LF_FACESIZE
 EditorLOGFONT.len: Len]

[EditorCHOOSEFONT:
 @lStructSize: D$ len
 @hwndOwner: D$ 0
 @hDC: D$ &NULL
 @lpLogFont: D$ EditorLOGFONT
 @iPointSize: D$ 0
 @Flags: D$
 &CF_FIXEDPITCHONLY__&CF_SCREENFONTS__&CF_INITTOLOGFONTSTRUCT__&CF_APPLY__&CF_ENABLEHOOK__&CF_NOSIMULATIONS
 @rgbColors: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ ChooseFontHook
 @lpTemplateName: D$ 0
 @hInstance: D$ 0
 @lpszStyle: D$ 0
 @nFontType: W$ &SCREEN_FONTTYPE
 @Alignment: W$ 0
 @nSizeMin: D$ 0
 @nSizeMax: D$ 0]

[EditFontHdc: ?   FontHandle: ?]

[TEXTMETRICA:
 tmHeight: D$ 0
 tmAscent: D$ 0
 tmDescent: D$ 0
 tmInternalLeading: D$ 0
 tmExternalLeading: D$ 0
 tmAveCharWidth: D$ 0
 tmMaxCharWidth: D$ 0
 tmWeight: D$ 0
 tmOverhang: D$ 0
 tmDigitizedAspectX: D$ 0
 tmDigitizedAspectY: D$ 0
 tmFirstChar: B$ 0
 tmLastChar: B$ 0
 tmDefaultChar: B$ 0
 tmBreakChar: B$ 0
 tmItalic: B$ 0
 tmUnderlined: B$ 0
 tmStruckOut: B$ 0
 tmPitchAndFamily: B$ 0
 tmCharSet: B$ 0]

[FontHeight: 16   FontWidth: 8    LineSpacingAdjust: 0]

; React to the [Apply] Button (&CF_APPLY__&CF_ENABLEHOOK, in EditorCHOOSEFONT@Flags):

Proc ChooseFontHook:
    Arguments @Adressee, @Message, @wParam, @lParam

            .If D@Message = &WM_COMMAND
                If D@wParam = 0402
                    call LoadFont | call AskForRedrawNow
                    mov eax &TRUE | ExitP
                End_If
            .End_If

    mov eax &FALSE
EndP


SelectFont:
    move D$EditorCHOOSEFONT@hwndOwner D$ConfigDialogHandle
    call 'Comdlg32.ChooseFontA' EditorCHOOSEFONT

    If eax = &TRUE
        call LoadFont | call AskForRedrawNow | call MainResize
    End_If
ret


LoadFont:
    On D$Font1Handle <> 0, call 'GDI32.DeleteObject' D$Font1Handle
    call 'GDI32.CreateFontIndirectA' EditorLOGFONT | mov D$Font1Handle eax
    call 'USER32.GetDC' D$EditWindowHandle | mov D$EditFontHdc eax
    call 'GDI32.SetMapMode' eax &MM_TEXT
    call 'GDI32.SelectObject' D$EditFontHdc, D$Font1Handle
    call 'GDI32.GetTextMetricsA' D$EditFonthdc, TEXTMETRICA

    mov eax D$tmAveCharWidth | mov D$FontWidth eax
    mov eax D$tmHeight | mov D$FontHeight eax
ret


LoadNationalFont:
    call 'GDI32.CreateFontIndirectA' NATION_LOGFONT | mov D$NationalFontHandle eax
ret


TITLE Undo

________________________________________________________________________________________
________________________________________________________________________________________
;;
  Undo feature; 2046 events are stored in UndoTable:
  
  Note: 'DoStoreBP' is in the DCBP TITLE and, as the 'UnDoStoreBP' job is done by
  'AdjustBpTable' and 'AdjustDownwardPointers', there is no 'UnDoStoreBP' Routine.
  
  ____________________
  Undo Table Routines:
  
  'InitUndo', 'KillUndo', 'ReInitUndo', 'ReadUndoRecord'
  
  ______________
  "DoStore" Routines:
  
  'DoStoreInsert', 'DoStoreOverWrite', 'DoStoreCharDelete'
  'DoStoreBlockPaste' (called from 'ControlV', 'AddWizardCode' -???!!!...-)
  'WriteUndoBlockFile' (caled from 'ControlX')
  
  'DoStoreBP' (in DCBP TITLE)
  
  ____________________
  Main "UnDo" Routine: 'ControlZ', calling for:
  
  'ReInsertDeletedChar', 'UndoBlockCopy', 'ReadUndoBlockFile'
  
  __________________________
  Files Managements Routines (for Blocks):
  
  'ResetUndoFileName', 'IncUndoFileName', 'DecUndoFileName', 'DeleteUndoFiles'
  'DeleteOldUndoFiles'
  _____________
  ReDo Routines:
  
  'ControlShiftZ' >>> 'ReInsertSource'

;;
________________________________________________________________________________________
________________________________________________________________________________________

[UndoPtr: 0    UndoMemory: 0] ; BuildTitleTable
;;
 The Undo Table is a rotary table 010000 sized for 2048 (0800h) records of 8 dWords:
;;

; Undo Flags:

[ACTION_INSERT 1, ACTION_OVERWRITE 2, ACTION_BLOCKCOPY 3, ACTION_BLOCKDELETE 4
 ACTION_DCBP 5, ACTION_DELDCBP 6, ACTION_DEL 7]

;[UNO_N_CHARS ecx  UNDOCHAR ebx  UNDOBLOCKBEGIN ebx  UNDOBLOCKEND edx  UNDOFLAG eax]

; Displacements Equates for pointing into one 'UndoMemory' Record:
; 0FFFF
[RECORD_CARET_ROW 0
 RECORD_CARET_LINE 4
 RECORD_CURRENTWRITINGPOS 8
 RECORD_ACTUALTITLE 12
 RECORD_UPPERLINE 16

 RECORD_PARAM1 20
 RECORD_PARAM2 24

 RECORD_FLAG 28

 UNDO_RECORD 32]
____________________________________________________________________________________________
____________________________________________________________________________________________

; The Undo Buffer Managements:

InitUndo:
    VirtualAlloc UndoMemory 010000 | move D$UndoPtr D$UndoMemory
ret


KillUndo:
   VirtualFree D$UndoMemory
   mov D$PreviousPartIndex 0-1
ret


ReInitUndo:
    On B$CompletionWanted = &TRUE, VirtualFree D$CompletionTable, D$CompletionPointers
    call ClearF11F12
    mov D$TiTleTable 0, D$ActualTitle 0
ReInitUndoOnly:
    call DeleteUndoFiles
    call KillUndo
    call InitUndo
    call CloseTree
    VirtualFree D$BreakPointsTables
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; The centralized Storing Routines

Proc StoreUserAction:
    Argument @Flag, @Param1, @Param2
    Uses eax, ecx, edi

        mov edi D$UndoPtr
    ; action_insert

        move D$edi+RECORD_CARET_ROW D$CaretRow
        move D$edi+RECORD_CARET_LINE D$CaretLine
        mov eax D$CurrentWritingPos | sub eax D$CodeSource
        mov D$edi+RECORD_CURRENTWRITINGPOS eax
        move D$edi+RECORD_ACTUALTITLE D$ActualTitle
        mov eax D$UpperLine | sub eax D$CodeSource | move D$edi+RECORD_UPPERLINE eax

        move D$edi+RECORD_PARAM1 D@Param1
        move D$edi+RECORD_PARAM2 D@Param2

        move D$edi+RECORD_FLAG D@Flag

        On D$BpOnTable <> 0, call AdjustBpTable D@Flag

      ; Prepare the Undo Table Pointer for next registration:
        mov edi D$UndoPtr | add di 32 | mov D$UndoPtr edi
      ; Clear the next Record:
        mov eax 0, ecx 8 | rep stosd
EndP


DoStoreInsert:
  ; The Callers set the Number of Chars into ebx. (Usefull for Tab Spaces):
    call StoreUserAction ACTION_INSERT, ebx, D$InsertedChar
ret


DoStoreOverWrite:
  ; The Caller sets the overwritten Char into cl, and the new Char in al:
    and ecx 0FF | and eax 0FF
    call StoreUserAction ACTION_OVERWRITE, ecx, eax
ret


DoStoreCharDelete:
  ; ebx set to BACK or FORTH by callers: 'BackSpace' 'StripOneChar'
    mov esi D$CurrentWritingPos | movzx eax B$esi-1
  ; eax is the deleted Char:
    call StoreUserAction ACTION_DEL, eax, ebx
ret


DoStoreBlockPaste:
    pushad
        mov ebx D$CurrentWritingPos                       ; block start
        mov edx ebx | add edx D$ClipBoardLen | dec edx    ; block end

        sub ebx D$CodeSource | sub edx D$CodeSource
        call StoreUserAction ACTION_BLOCKCOPY, ebx, edx

        call WriteUndoBlockFileFromClipBoard
    popad
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; The Undo Files Managements. (They are only used for the Blocks Selections Operations).

ResetUndoFileName:
    mov edi D$PointerToUndoNumber, al '0' | stosb | stosb | stosb
ret


IncUndoFileName:
    mov eax D$PointerToUndoNumber
    inc B$eax+2 | cmp B$eax+2 '9' | jbe L9>
    mov B$eax+2 '0'
    inc B$eax+1 | cmp B$eax+1 '9' | jbe L9>
    mov B$eax+1 '0'
    inc B$eax
L9: ;Showme D$PointerToUndoNumber

    ret

DecUndoFileName:
    ;call 'KERNEL32.DeleteFileA' UndoFile ; Keep it, now, for Redo!!!!
    mov eax D$PointerToUndoNumber
    dec B$eax+2 | cmp B$eax+2 '0' | jae L9>
    mov B$eax+2 '9'
    dec B$eax+1 | cmp B$eax+1 '0' | jae L9>
    mov B$eax+1 '9'
    dec B$eax
L9: ret


[UndoFileHandle: ?]

WriteUndoBlockFileFromBlock: ; ControlV ControlX
L0: call IncUndoFileName | mov eax UndoFile
    call 'KERNEL32.CreateFileA' eax, &GENERIC_WRITE, 0, 0, &CREATE_ALWAYS,
                                &FILE_ATTRIBUTE_NORMAL, 0
    mov D$UndoFileHandle eax

    If eax = &INVALID_HANDLE_VALUE
        call KillUndo | call InitUndo
        call SetUndoDirectory | jmp L0<
    End_If

    mov ecx D$BlockEndTextPtr | sub ecx D$BlockStartTextPtr | inc ecx

    call 'KERNEL32.WriteFile' D$UndoFileHandle, D$BlockStartTextPtr, ecx, NumberOfReadBytes, 0
    call 'KERNEL32.CloseHandle' D$UndoFileHandle
ret


WriteUndoBlockFileFromClipBoard: ; ControlV ControlX
L0: call IncUndoFileName | mov eax UndoFile
    call 'KERNEL32.CreateFileA' eax, &GENERIC_WRITE, 0, 0, &CREATE_ALWAYS,
                                &FILE_ATTRIBUTE_NORMAL, 0
    mov D$UndoFileHandle eax

    If eax = &INVALID_HANDLE_VALUE
        call KillUndo | call InitUndo
        call SetUndoDirectory | jmp L0<
    End_If
    call 'KERNEL32.WriteFile' D$UndoFileHandle, D$ClipBoardPtr, D$ClipBoardLen,
                              NumberOfReadBytes, 0

    call 'KERNEL32.CloseHandle' D$UndoFileHandle
ret


[UndoBlockLen: ?]
;;
  Called from 'ControlZ'. A Selection has been Delete, and save into an Undo File. 
  we re-paste this Selection:
;;
ReadUndoBlockFile: ; ControlX
    mov D$BlockStartTextPtr ebx, D$BlockEndTextPtr ecx

    call 'KERNEL32.CreateFileA' UndoFile, &GENERIC_READ, 0, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, 0

    .If eax <> &INVALID_HANDLE_VALUE
        mov D$UndoFileHandle eax, D$NumberOfReadBytes 0

        call 'KERNEL32.GetFileSize' eax, 0 | mov D$UndoBlockLen eax
        add D$SourceLen eax | add D$SourceEnd eax

        mov esi D$SourceEnd | add esi 400 | mov edi esi | add edi eax
        mov ecx edi | sub ecx D$CurrentWritingPos | std | rep movsb | cld
        call 'KERNEL32.ReadFile' D$UndoFileHandle, D$CurrentWritingPos,
                                 D$UndoBlockLen, NumberOfReadBytes, 0

        call 'KERNEL32.CloseHandle' D$UndoFileHandle
    .End_If
ret


StoreUserActionOfBlockDeletion:
    push D$CurrentWritingPos
        move D$CurrentWritingPos D$BlockStarttextPtr
        mov eax D$BlockStarttextPtr | sub eax D$CodeSource
        mov ebx D$BlockEndTextPtr | sub ebx D$CodeSource

        call StoreUserAction ACTION_BLOCKDELETE, eax, ebx
    pop D$CurrentWritingPos
ret


DeleteUndoFiles:
    mov eax D$PointerToUndoNumber | cmp D$eax '000.' | je L9>
L1:     call 'KERNEL32.DeleteFileA' UndoFile
            call DecUndoFileName
            mov eax D$PointerToUndoNumber | cmp D$eax '000.' | ja L1<
L9: ret


; Undo Files WIN32_FIND_DATA Structure:

[DelUndo:
 DelUndo.dwFileAttributes: D$ ?
 DelUndo.ftCreationTime.dwLowDateTime: D$ ?
 DelUndo.ftCreationTime.dwHighDateTime: D$ ?
 DelUndo.ftLastAccessTime.dwLowDateTime: D$ ?
 DelUndo.ftLastAccessTime.dwHighDateTime: D$ ?
 DelUndo.ftLastWriteTime.dwLowDateTime: D$ ?
 DelUndo.ftLastWriteTime.dwHighDateTime: D$ ?
 DelUndo.nFileSizeHigh: D$ ?
 DelUndo.nFileSizeLow: D$ ?
 DelUndo.dwReserved0: D$ ?
 DelUndo.dwReserved1: D$ ?]
[DelUndo.cFileName: B$ ? #260]
[DelUndo.cAlternate: B$ ? #14]

[DelUndoHandle: ?]

DeleteOldUndoFiles:
    call 'KERNEL32.FindFirstFileA' AllUndoFiles2 DelUndo

    If eax <> &INVALID_HANDLE_VALUE
        mov D$DelUndoHandle eax
L0:     call 'KERNEL32.DeleteFileA' DelUndo.cFileName
        call 'KERNEL32.FindNextFileA' D$DelUndoHandle DelUndo
        cmp eax &TRUE | je L0<

        call 'KERNEL32.FindClose' D$DelUndoHandle
    End_If

    mov edi D$PointerToUndoNumber, eax '000.' | stosd
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Main undo routine:

[ControlZreRunForCRLF: 0]
[BackOrForth: ?]

ControlZ:
    mov B$BlockInside &FALSE

    If D$DebugDialogHandle <> 0
        call KillDebugger | On eax = &IDNO, jmp L9>>
    End_If

    mov ebx D$UndoPtr | sub bx UNDO_RECORD
    cmp D$ebx+RECORD_FLAG 0 | je L9>>   ; depend on flag > 0 > End
        mov D$UndoPtr ebx

    If D$BpOnTable <> 0
        pushad
            call AdjustBpTable, ControlZ
        popad
    End_If

    call ReadUndoRecord

  ; >>> eax = RECORD_FLAG, ebx = RECORD_PARAM1, ecx = RECORD_PARAM2

    .If eax = ACTION_INSERT
        mov ecx ebx, ebx D$CurrentWritingPos
        if B$ebx-1 = LF
            call StripBackSpace
            mov ebx D$UndoPtr | sub bx 32 | mov D$UndoPtr ebx
            call StripBackSpace
            dec D$CurrentWritingPos, D$CaretRow
        Else
L1:         push ecx
                call StripBackSpace
            pop ecx
            dec D$CaretRow
            loop L1<
        End_If

    .Else_If eax = ACTION_OVERWRITE
        dec D$CaretRow | mov edi D$CurrentWritingPos, eax ebx | stosb

    .Else_If eax = ACTION_DEL
; Why this complicated stuff around 'ControlZreRunForCRLF': We may have to undo a CR/LF
; arasement done either by [BackSpace] or by [Del]. With [backSpace], we have first arased
; the LF and then the CR. With [Del], we have arased in the other way.
        mov D$BackOrForth ecx
        If ebx = CR
            dec D$CurrentWritingPos | xor B$ControlZreRunForCRLF &TRUE
            call ReInsertDeletedChar
            On B$ControlZreRunForCRLF = &TRUE, jmp ControlZ

        Else_If ebx = LF
            dec D$CurrentWritingPos | xor B$ControlZreRunForCRLF &TRUE
            call ReInsertDeletedChar
            On B$ControlZreRunForCRLF = &TRUE, jmp ControlZ
        Else
            dec D$CurrentWritingPos, D$CaretRow | call ReInsertDeletedChar
        End_If

        On D$BackOrForth = FORTH, dec D$CurrentWritingPos, D$CaretRow

    .Else_If eax = ACTION_BLOCKDELETE
        add ebx D$CodeSource | add ecx D$CodeSource
        call ReadUndoBlockFile | call DecUndoFileName

    .Else_If eax = ACTION_BLOCKCOPY
      ; 'DoStoreBlockPaste'
        add ebx D$CodeSource | add ecx D$CodeSource
        call UndoBlockCopy | call DecUndoFileName

    .Else_If eax = ACTION_DCBP
      ; 'DoStoreBp', 'DoStoreInsert', 'ReadUndoRecord'
        mov D$BreakPointLocation ebx
        call DeleteBreakPoint

    .Else_If eax = ACTION_DELDCBP
        mov D$BreakPointLocation ebx
        call SetBreakPoint

    .End_If

    call AskForRedraw
L9: ret
____________________________________________________________________________________________
;;
All the Pointers in UndoPtr Table are turned into Displacements from the 'CodeSource'
origin. This origin is continuously moving when the Source increases or decreases.
;;
ReadUndoRecord:
    mov esi D$UndoPtr

  ; When storing BPs, the Sources Pos are the ones of the Real Source. So:
   ; If D$esi+RECORD_FLAG = ACTION_DCBP
   ;     mov ebx D$esi+RECORD_PARAM1, eax ACTION_DCBP | ret
   ; End_If

    mov eax D$ActualTitle

    If eax <> D$esi+RECORD_ACTUALTITLE
        push esi
            call RestoreRealSource
        pop esi

        mov eax D$esi+RECORD_CURRENTWRITINGPOS
        add eax D$esi+RECORD_ACTUALTITLE
        mov D$CurrentWritingPos eax
        move D$UpperLine D$esi+RECORD_UPPERLINE

        push esi
            call SetPartialEdition
        pop esi
    End_If

    move D$CaretRow D$esi+RECORD_CARET_ROW
    move D$CaretLine D$esi+RECORD_CARET_LINE
    mov eax D$esi+RECORD_CURRENTWRITINGPOS | add eax D$CodeSource | mov D$CurrentWritingPos eax
    mov eax D$esi+RECORD_UPPERLINE | add eax D$CodeSource | mov D$UpperLine eax

    mov eax D$esi+RECORD_FLAG, ebx D$esi+RECORD_PARAM1, ecx D$esi+RECORD_PARAM2
ret
____________________________________________________________________________________________

; Called by 'ControlZ':

ReInsertDeletedChar:
    RealCaretRow

    mov esi D$SourceEnd | add esi 400 | mov edi esi      ; 400 is security 13/10/...
    mov ecx esi | sub ecx D$CurrentWritingPos | inc ecx

    mov eax ebx

    cmp al tab | jne L1>
        cmp D$TabIs &TRUE | jne L2>
L1:         inc edi
            std
                rep movsb | stosb
            cld
            mov ebx 1 | jmp L3>

L2:     mov ebx D$TabIs | add edi ebx
        std
          rep movsb | mov al ' ', ecx ebx | rep stosb
        cld

L3: add D$SourceLen ebx | add D$CurrentWritingPos ebx | add D$SourceEnd ebx

    mov eax D$ColNumber

    cmp D$CaretRow  eax | jae L4>
    add D$CaretRow ebx | jmp L9>

L4: AlignOn RIGHT_FEED ebx | add D$RightScroll ebx | sub D$CaretRow ebx | dec D$CaretRow

L9: ret


UndoBlockCopy:
    mov D$BlockStartTextPtr ebx, D$BlockEndTextPtr ecx
    mov B$BlockInside &TRUE
    call UndoControlV
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[BACK 1, FORTH 0]

ControlShiftZ: ; ControlZ
    If D$DebugDialogHandle <> 0
        call KillDebugger | On eax = &IDNO, jmp L9>>
    End_If

    mov ebx D$UndoPtr | cmp D$ebx+RECORD_FLAG 0 | je L9>>   ; depend on flag > 0 > End
        mov D$UndoPtr ebx

    If D$BpOnTable <> 0
        pushad
            call AdjustBpTable, ControlShiftZ
        popad
    End_If

    call ReadUndoRecord
  ; >>> eax = RECORD_FLAG, ebx = RECORD_PARAM1, ecx = RECORD_PARAM2

    ..If eax = ACTION_INSERT
      ; RECORD_PARAM1 = Number of Chars // RECORD_PARAM2 = Char
        dec D$CaretRow | sub D$CurrentWritingPos ebx
        mov al cl, ecx ebx

L0:     push eax, ecx
            If al = CR
                call ReInsertSource | mov al LF | add D$UndoPtr UNDO_RECORD
            End_If
            call ReInsertSource
        pop ecx, eax
        loop L0<

    ..Else_If eax = ACTION_OVERWRITE
      ; RECORD_PARAM1 = Overwritten Char // RECORD_PARAM2 = New Char
        mov edi D$CurrentWritingPos, B$edi cl

    ..Else_If eax = ACTION_DEL ; 'DoStoreCharDelete' <<< 'BackSpace" // 'StripOneChar'
      ; RECORD_PARAM1 = Char // RECORD_PARAM2 = BACK, or FORTH
        .If ecx = FORTH
            If B$CurrentWritingPos = CR
                call StripBackSpace
                call StripBackSpace
                add D$UndoPtr UNDO_RECORD
            Else
                call StripBackSpace
                dec D$CurrentWritingPos
            End_If
        .Else
            call StripBackSpace
            dec D$CurrentWritingPos
            mov eax D$CurrentWritingPos | dec eax
            If B$eax = CR
                mov D$CurrentWritingPos eax
                call StripBackSpace
                call SetCaret D$CurrentWritingPos
                add D$UndoPtr UNDO_RECORD
            End_If
        .End_If

    ..Else_If eax = ACTION_BLOCKDELETE
        add ebx D$CodeSource | add ecx D$CodeSource
        mov D$BlockStartTextPtr ebx, D$BlockEndTextPtr ecx
        call WriteUndoBlockFileFromBlock | call UndoControlV
        mov ecx D$BlockEndTextPtr | sub ecx D$BlockStartTextPtr | inc ecx
        sub D$CurrentWritingPos ecx | sub D$CaretRow ecx

    ..Else_If eax = ACTION_BLOCKCOPY
        add ebx D$CodeSource | add ecx D$CodeSource
        call IncUndoFileName | call ReadUndoBlockFile
        mov eax D$UndoBlockLen | add D$CurrentWritingPos eax | add D$CaretRow eax

    ..Else_If eax = ACTION_DCBP
        mov D$BreakPointLocation ebx
        call SetBreakpoint

    ..Else_If eax = ACTION_DELDCBP
        mov D$BreakPointLocation ebx
        call DeleteBreakpoint

    ..End_If

    add D$UndoPtr UNDO_RECORD

    call AskForRedraw
ret


; Simplified 'InsertSource':

ReInsertSource:
    mov esi D$SourceEnd | add esi 400 | mov edi esi      ; 400 is security 13/10/...
    mov ecx esi | sub ecx D$CurrentWritingPos | inc ecx

L1: inc edi
    std
        rep movsb | stosb
    cld
    mov ebx 1 | jmp L3>

L3: add D$SourceLen ebx | add D$CurrentWritingPos ebx | add D$SourceEnd ebx

    mov eax D$ColNumber

    cmp D$CaretRow  eax | jae L4>
    add D$CaretRow ebx | jmp L9>
L4: push ebx
        AlignOn RIGHT_FEED ebx | add D$RightScroll ebx | sub D$CaretRow ebx | inc D$CaretRow
    pop ebx

L9: ret


TITLE WriteCheck

;;
  Write-Time syntax error checker. First Try&See implementation:
  
  Checks for Mnemonics and Macros evocations in Code.
;;


[WriteCheckPointer: ?   WriteChar: ?    WriteCheckerThreadID: ?    WeAreChecking: ?]

[WriteCheckerWanted: ?    WriteCheckerRuning: ?]

Proc WriteChecker:
    Argument @Pointer, @Char

        On B$WriteCheckerRuning =  &TRUE, ExitP

      ; BackSpace:
        On eax = 8, ExitP

        mov B$WriteCheckerRuning &TRUE

        pushad

            mov eax D@Pointer, D$WriteChar 0

            If B$eax-1 <= ' '
                mov B$WriteCheckerRuning &FALSE

            Else_If B$eax-1 <> ':'
                mov D$WriteCheckPointer eax | move D$WriteChar D@Char

                call 'KERNEL32.CreateThread' &NULL, 0, WriteCheckerThread, 0,
                                             &THREAD_PRIORITY_IDLE, ;THREAD_PRIORITY_NORMAL,
                                             WriteCheckerThreadID
            Else
                mov B$WriteCheckerRuning &FALSE

            End_If

        popad
EndP
____________________________________________________________________________________________


Proc WriteCheckerThread: ; 'CharMessage'
    Local @Exit @ContinueStatus @hThread

    pushad

      ; The Pointer is given when user hits CRLF, Space or Comma:
        mov esi D$WriteCheckPointer | dec esi
        mov D$BlockEndTextPtr esi

      ; We go to start of the word:
L0:     dec esi | cmp B$esi ',' | je L1>
                  cmp B$esi '|' | je L1>
                  cmp B$esi ':' | je L1>
                  cmp B$esi ' ' | ja L0<

      ; Keep track of component case, in eax (Either Instruction or Parameter):
L1:     mov ebx esi | While B$ebx = ' ' | dec ebx | End_While
        If B$ebx = '|'
            mov eax 1
        Else_If B$ebx < ' '
          ; "1" >>> First Component (Mnemonic or Macro)
            mov eax 1
        Else
          ; "2" >>> Parameter
            mov eax 2
        End_If

        inc esi | mov D$BlockStartTextPtr esi

      ; Must be a Statement > Color = Statememts Color (1) ?
        mov ebx esi | sub ebx D$CodeSource | add ebx D$ColorsMap

      ; If Code Color Statement:
        ...If B$ebx = 1
            ..If D$WriteChar = ':'
                call CheckUniqueSymbol

          ; If Instruction:
            ..Else_If eax = 1
                mov ecx D$BlockEndTextPtr | sub ecx D$BlockStartTextPtr
                mov eax &FALSE
                If ecx < 15
                    call CheckMnemonic
                End_If

                If eax = &FALSE
                    call CheckForMacro
                End_IF

                .If eax = &FALSE
                    mov B$BlockInside &TRUE | call AskForRedrawNow | Beep
                .End_If

            ..End_If

      ; If Data Color Statement:
        ...Else_If B$ebx = 2
            ..If D$WriteChar = ':'
                call CheckUniqueSymbol

            ..Else

            ..End_If

        ...End_If

    popad

    mov B$WriteCheckerRuning &FALSE

    call 'Kernel32.ExitThread' 0
EndP
____________________________________________________________________________________________

[TrashCode: ? #8]
CheckMnemonic:
    mov B$WeAreChecking &TRUE

    mov edi MnemonicCopy, esi D$BlockStartTextPtr, D$LineStart esi
    mov ecx D$BlockEndTextPtr | sub ecx esi | inc ecx
L0: lodsb | and eax (not 32) | stosb | loop L0<
    mov B$edi 0

    mov edi TrashCode | call Encode

    mov B$WeAreChecking &FALSE


    .If B$CompileErrorHappend = &TRUE
        If eax = NotAnOpcode
            mov eax &FALSE
        Else
            mov eax &TRUE
        End_If

    .Else
        mov eax &TRUE

    .End_If
ret
____________________________________________________________________________________________

; User entered a Colon Char:

CheckUniqueSymbol:
  ; Compute the lenght of the actualy edited Label into ebx:
    mov esi D$CurrentWritingPos, ebx 0 | dec esi

  ; Do not check again Exported Labels:
    cmp B$esi-1 ':' | je L9>>

L0: dec esi | inc ebx
    cmp B$esi ' ' | jbe L1>
    cmp B$esi '[' | jne L0<

  ; Do not consider Local Labels:
    cmp ebx 3 | jb L9>>

L1: std
        mov esi D$CodeSource, edx D$SourceEnd

        While esi < edx
            inc esi
            If B$esi = ':'
                push esi
                    mov edi D$CurrentWritingPos, ecx ebx
                    dec edi | cmp esi edi | je L1>

                    repe cmpsb | jne L1>
                    cmp B$esi ' ' | jbe L0>
                    cmp B$esi '[' | jne L1>

L0:                     cld
                        pop esi
                        inc edi | mov D$BlockStartTextPtr edi
                        mov eax D$CurrentWritingPos | dec eax | mov D$BlockEndTextPtr eax

                        Beep | ret

L1:             pop esi
            End_If

        End_While
L8: cld

L9: ret
____________________________________________________________________________________________

CheckForMacro:
    call IsItaMacro

    .If eax = 0
        If D$TitleTable +4 > 0
            push D$CodeSource, D$SourceEnd, D$SourceLen
                move D$CodeSource D$RealCodeSource
                move D$SourceEnd D$RealSourceEnd
                move D$SourceLen D$RealSourceLen
                call IsItaMacro
            pop D$SourceLen, D$SourceEnd, D$CodeSource
        End_If
    .End_If
ret


























TITLE Tree
 _______________________________________________________________________________________
 _______________________________________________________________________________________
;;
 Tree view
 _______________________________________________________________________________________
 _______________________________________________________________________________________

 Building the tree view:

 here we build a simple list of labels encounted in source: label declarations 'Label:'
 and label evocations ('call label'). A byte flag is used for declarations and for
 evocations. A Declaration record is:         Flag (1) / DoneFlag (0/1) / adr / name
                                              ..(Byte)....(Byte)........(dWord)(Bytes)
             An evocation record is:          Flag (2) / name
                                              ..(Byte)..(Bytes)
 Names Strings are NOT zero ended (No need as following byte is either 1 or 2).

 We store everything we find in read order. Local label are not considered; so that
 each main label is followed by its own labels evocations, without any check of
 'ret' statement (that would be too uncertain...).

 No error check here for open text / brackets. We pop the return adress and return
 to caller of 'CreateTreeViewList'.
;;

[TreeList: ?  TreeListPtr: ?  TreeListEnd: ?]

[DeclarationFlag 1  EvocationFlag 2  ListFlagMax 3]

BuildLabelTreeList:
    mov eax D$SourceEnd | add eax 400 | mov D$eax-4 0A0D0A0D
    mov D$TreeList eax, D$TreeListPtr eax
    mov esi D$CodeSource, edx D$SourceEnd

L0: lodsb | cmp esi edx | jae L9>>

    cmp al ';' | jne L1>                     ; jmp over comments
        If D$esi-2 = MLC   ; (LF ; ; CR)
            Do
                inc esi | cmp esi edx | jae L9>>
            Loop_Until D$esi = MLC
            add esi 3 | jmp L0<
        Else
L2:         lodsb | cmp al LF | jne L2<
            jmp L0<
        End_If

L1:   cmp al "'" | jne L1>                   ; jump over 'text'
L2:     lodsb | cmp al CR | je L3>
        cmp al "'" | jne L2<
          jmp L0<
L3:   jmp AbortTree

L1:   cmp al '"' | jne L1>                   ; jump over "text"
L2:     lodsb | cmp al '"' | je L0<
          cmp esi edx | jb L2<
      jmp AbortTree

; __________________________    Inside [brackets]: ________________________________

L1:   cmp al '[' | jne L1>                   ; jump over [Brackets]

L2:     lodsb | cmp al ';' | jne L4>

        If D$esi-2 = MLC   ; (LF ; ; CR)
            Do
                inc esi | cmp esi edx | jae L9>>
            Loop_Until D$esi = MLC
            add esi 3 | cmp esi edx | jae L9>>
        Else
L3:         lodsb | cmp al LF | jne L3<
        End_If
        jmp L2<

L4:     cmp al "'" | jne L4>
L5:       lodsb | cmp al "'" | je L2<        ; 'text' in brackets
          cmp al CR | jne L5<
            jmp L8>

L4:     cmp al '"' | jne L4>
L5:       lodsb | cmp al '"' | je L2<        ; "text" in brackets
          cmp esi edx | jb L5<
            jmp L8>

L4:     cmp al ']' | je L0<<
        cmp esi edx | jb L2<
L8:   jmp AbortTree

L1: cmp al ':' | jne L1>                              ; Label declaration found ?
        cmp B$esi-4 32  | jbe L0<<                         ; local ?
        cmp B$esi-4 '|' | je L0<<

      ; End of Label:
        mov ecx esi | dec ecx

      ; Case of Exported Functions.
        On B$esi = ':', inc esi

        push esi
L2:       dec esi | cmp B$esi 32 | ja L2<
            inc esi | mov edi D$TreeListPtr
            mov al DeclarationFlag | stosb            ; declaration flag
            mov al 0 | stosb                          ; done flag
            mov eax esi | stosd                       ; adress in source
            sub ecx esi | rep movsb                   ; label name
            mov D$edi 0
            mov D$TreeListPtr edi
        pop esi
      jmp L0<<

L1:   or al 32 | cmp al 'a' | je IsItDialogApi        ; >>> down here
      cmp al 'c' | jne L0<<                           ; Label evocation found ?
      cmp B$esi-2 32 | jbe L2>
        cmp B$esi-2 '|' | jne L0<<
L2:   lodsd | or eax 020202020 | cmp eax 'all ' | je L3>
        sub esi 4 | jmp L0<<
L3:   cmp B$esi 32 | jne L4>                          ; strip double spaces
        inc esi | jmp L3<
L4:   If B$esi = "'"                                  ; direct api call (without 'api' macro)
        mov ebp esi | dec ebp | inc esi | jmp L3>>
      End_If

L8:           mov edi D$TreeListPtr                   ; jmp target of successfull 'IsItDialogApi'
                mov al EvocationFlag | stosb          ; evocation flag
L5:             lodsb | cmp al '0' | jb L6>
                        cmp al 'z' | ja L6>
                stosb | jmp L5<                       ; label name
L6:           mov D$edi 0
              mov D$TreeListPtr edi | dec esi
        jmp L0<<

L9: mov edi D$TreeListPtr
    mov al DeclarationFlag | stosb         ; security if 'Callback:' is last main label
    mov al 0 | stosb
    move D$TreeListEnd D$TreeListPtr
ret


IsItDialogApi:
    cmp B$esi-2 32 | jbe L2>
        cmp B$esi-2 '|' | jne L0<<
L2: mov ebp esi
    lodsd | or eax 02020 | cmp eax "pi '" | je L3>
L7:     mov esi ebp | jmp L0<<
L3: add esi 7 | lodsd | cmp eax 'Crea' | jne L4>      ; esi+7 > jumps over 'User32.'
      lodsd | cmp eax 'teDi' | jne L7<
        lodsd | cmp eax 'alog' | jne L7<
          jmp L5>
L4: cmp eax 'Dial' | jne L7<
      lodsd | cmp eax 'ogBo' | jne L7<

L5: ; We found either call 'CreateDialog/Indirect/paramA' or 'DialogBox/Indirect/ParamA'.
    ; the pointed Proc is always the fourth following parameter:

    mov ecx 4

P0: lodsb | cmp al ' ' | je P1>                      ; search a separator
            cmp al ',' | jne P0<

P1: lodsb | cmp al ' ' | jbe P1<                     ; search start of parameter
            cmp al ';' | jne P4>                     ; jmp over comments
P2:            lodsb | cmp al LF | jne P2<
                   jmp P1<
P4: loop P0<

L6: dec esi | jmp L8<<


; If Building tree fails, we abort: strip previous record in BackTable, pop the return
; adress of caller and return to Callback.

[TreeAborted: 0]
[AbortTreeMessage: "Unpaired Text delimiter or unpaired Bracket", 0]

AbortTree:
    mov ebx D$BackTablePtr | sub bl 4 | mov D$ebx 0 | mov D$BackTablePtr ebx
    call 'USER32.MessageBoxA' D$hwnd, AbortTreeMessage, Argh, &MB_SYSTEMMODAL
    mov B$TreeAborted &TRUE
ret


;;
 Now the list of labels declarations and of labels evocation (by call) is done. Let us
 take a short exemple: 'CallBack:' contains three calls (to SubA1/A2/A3); SubA1 contains
 two calls (to SubB1/B2); SubB1 again two calls (SubC1/C2); and at last, SubC2 has one
 call (to SubD1). The tree we want to print could be:

 > CallBack
 >      SubA1
 >          SubB1
 >              SubC1
 >              SubC2
 >                  SubD1
 >          SubB2
 >      SubA2
 >      SubA3

 The List could be (1 is DeclarationFlag, 2 EvocationFlag, adr is Ptr in source):

 / 1 / adr / CallBack / 2 / SubA1 / 2 / SubA2 / 2 / SubA3 /
 / 1 / adr / SubA3 /
 / 1 / adr / SubA1 / 2 / SubB1 / 2 / SubB2 /
 / 1 / adr / SubA2
 / 1 / adr / SubB1 / 2 / SubC1 / 2 / SubC2 /
 / 1 / adr / SubC1 /
 / 1 / adr / SubC2 / 2 / SubD1 /
 / 1 / adr / SubD1 /
 / 1 / adr / SubB2 /
 / 1 ......

 We are going to get the tree from this list simply with playing with PUSH/POP: We first
 push 0, search for 'MainWindowProc' in the list, read/write; we push a pointer to next
 evocation, search actual label declaration, write it, and so on until we find a label
 with a declaration flag. In this case, we pop previous adress and go on. So, we go
 forth and back in the list until the entirely job is done; this is to say, until we
 pop 0. The 'base' of search (edi) is always an evocation and 'what we search' (esi)
 is always a declaration.

 this entire job is done each time user click on 'Tree'.
;;

[FirstLabelToSearch: ? #20] [TreeLabelPtr: ?  DoNotWriteInTree: B$ ?]

SearchListDeclaration:  ; edi(ah) > what to find (evoc.) // esi(al) search ptr (> declar.)

    mov edx D$TreeListEnd, esi D$TreeList, B$DoNotWriteInTree &FALSE
    push edi
L0:     lodsb | cmp esi edx | jae L8>
L1:     cmp al DeclarationFlag | ja L0<           ; jump over evocations
        mov ebx esi | inc esi                     ; ebx = done flag ptr. Jump over
        mov D$TreeLabelPtr esi | add esi 4 | pop edi | push edi
L4:     lodsb | mov ah B$edi | inc edi
        and eax 00_11011111_11011111              ; ah, al > Upper Case
        cmp eax 0202 | je L7>
        cmp eax 0101 | je L7>
        cmp al 0 | je L8>>
        cmp al ah | je L4<

        cmp al ListFlagMax | ja L0<
L6:     cmp ah ListFlagMax | ja L1<

L7:     If B$ShowLabelsOnce = &TRUE
            On B$ebx = 1, mov B$DoNotWriteInTree &TRUE
        End_If
        mov B$ebx &TRUE                           ; write done flag
        dec esi | mov ecx esi                     ; ecx = size
        mov esi D$TreeLabelPtr
        lodsd | mov ebx eax                       ; eax, ebx = declaration ptr in source
        sub ecx esi | jmp L9>

L8:     mov ecx 0
L9: pop edi
ret                     ; >>> ecx = 0 if not found,  esi = pointer to name if found


; For RightClick (direct search in tree View), the edge of the text must be defined.

[TreeViewItemEdge: ? ] [TreeViewItem: ? #100]

; when In, ecx = size of label name.

WriteTreeView:           ; Page set up of the tree like in Win32 TreeView Lists.
                         ; Here one Item once.
    push esi, edi, ecx
        mov edi TreeViewItem
L1:     cmp D$TreeIndent 0 | je L1>
L0:         push ecx
                mov ecx D$TreeIndent, ebx ecx
L0:             mov eax '    ' | stosd
                mov eax '|   ' | stosd
                loop L0<
            pop ecx
L1:     rep movsb                   ; ecx still good from 'SearchLabelInTreeList'

L2:     mov al ' ' | stosb | mov al 0 | stosb
        call 'USER32.SendDlgItemMessageA' D$ShowTreeHandle, 100, &LB_ADDSTRING,
                                          0, TreeViewItem
    pop ecx, edi, esi
ret

;;
 In next routine, reintrant procedure would produce infinite loop; This may append, for
 exemple when a DialogBox routine Closes the Dialog and re-run the same fresh Dialog to
 re-init its values (This is the case in RosAsm Dialog Editor source).

 For such cases, we store all Source Adresses of declarations at each increment of tree
 writting position, and check if new written declaration adress is up there in the same
 tree branching. It yes, we pop back and go on.

 The checked value (Adress of Declaration in source) is given in eax by "SearchListDeclaration".
 but on "WriteTreeView" exit it is POPed in ebx, so that here, ebx is used instead.

 These adresses are stored in "TreeLevels" table which grows and decreases with indentations.

 What we push and pop here until poping 0 is nothing but a pointer to TreeList records.
 What we search in "SearchListDeclaration" is always the source adress of a declaration.
 When we see several following Labels at the same indent in Tree View window, we have
 both push (for "If Next") and pop (for "Next was a Declaration")... Difficult to explain
 difficult to understand, ... difficult to write... PUSHing is like going down in Tree
 branching and POPing is like going up. At each leave, we both push and pop.
;;

[TreeIndent: ?]
[TreeRoot: ? #120]

[TreeLevels: ? #30]

ClearTreeLevels: mov edi TreeLevels, eax 0, ecx 30 | rep stosd | ret

BuildOneTree:
    push 0                                           ; end search mark on stack first.
    mov D$TreeIndent 0, edi TreeRoot                 ; Root String set by caller.
    call SearchListDeclaration
    If ecx = 0                                       ; zero lenght (not found) > abort
        pop eax | ret
    End_If
    mov D$TreeLevels ebx

L0: call WriteTreeView | add esi ecx
                                                     ; Testing NEXT RECORD flag:
L2: .If B$esi = EvocationFlag                        ; ________Evocation Case______________
        inc esi | mov edi esi
L3:     lodsb | cmp al ListFlagMax | ja L3<          ; Search end of evocation Name
        dec esi | push esi                           ; push next possible evocation record Ptr
        inc D$TreeIndent                             ; > esi points to next record Type Flag
    .Else                                            ; ________Declaration Case____________
L4:     dec D$TreeIndent                             ; > No more evocation in that branch
        pop esi | cmp esi 0 | ja L2<                 ; pop previous TreeList pointer
            jmp L9>>
    .End_If

    call SearchListDeclaration | cmp ecx 0 | je L4<  ; Evocation of a non existing Label
    cmp B$DoNotWriteInTree &TRUE | je L4<            ; If "First Call Only" selected

    push edi, ecx                                    ; Compare new Source Label Adress with
        mov edi TreeLevels, ecx D$TreeIndent         ; other adresses of the same branch
        inc ecx | repne scasd                        ; to prevent from infine loop in case
    pop ecx, edi                                     ; of imbricated re-intrant calls.
    je L4<

    mov eax D$TreeIndent, D$TreeLevels+eax*4 ebx | jmp L0<< ; store source Label Adresses.
                                                            ; for next time upper control
L9: ret


[ContinueOrphans: 'List Orphans Labels?', 0
 ManyOrphans: "
   After analyzes, the resulting Tree is found poorly organised,   
   and the amount of Labels is uge.
   
   Listing all of the orphan Labels may take a very long time,
   because the tree Builder will try to recreate a sub-Tree from
   each orphan...
 
                                    Go on listing?", 0]

ListOrphanLabels:
    mov D$TreeIndent 0, edx D$TreeListEnd, esi D$TreeList, ecx 0, ebx 0

  ; Count how many Orphan Labels to be listed:
L1: lodsb | cmp esi edx | jae L2>
    cmp al DeclarationFlag | ja L1<                       ; jump over evocations
      lodsb | add esi 4                                   ; jump over adress
        inc ebx
        cmp al &TRUE | je L1<                             ; done flag ?
            inc ecx | jmp L1<

  ; The number of orphans Labels may be uge with Disassemblies:
L2: shr ecx 2
    If ecx > ebx
            call 'USER32.MessageBoxA' D$hwnd, ManyOrphans, ContinueOrphans,
                                      &MB_SYSTEMMODAL__&MB_YESNO
        On eax = &IDNO, ret
    End_If

    mov D$TreeIndent 0, edx D$TreeListEnd, esi D$TreeList

L1: lodsb | cmp esi edx | jae L9>
    cmp al DeclarationFlag | ja L1<                       ; jump over evocations
      lodsb | add esi 4                                   ; jump over adress
        cmp al &TRUE | je L1<                             ; done flag ?
        push esi                                          ; start of name
L4:       lodsb | cmp al ListFlagMax | ja L4<             ; search end of name
          mov ecx esi
        pop eax
          sub ecx eax                                     ; ecx = size
          dec esi
        push esi, edx                                     ; next record
          mov edi TreeRoot, D$TreeIndent 0, esi eax       ; esi > start of name
          rep movsb | mov al 0 | stosb
          call BuildOneTree
        pop edx, esi                                      ; next record
      jmp L1<
L9: ret


[ShowOrphan: &FALSE  ShowLabelsOnce: &TRUE]    ; keep dWords (evocated both as Bytes and dWords)

BuildTree:             ; build the tree from the List

    mov D$TreeIndent 0
    mov esi CallBackName, ecx D$CallBackNameLen, edi TreeRoot
    rep movsb | mov al 0 | stosb

    call BuildOneTree

    mov esi EntryPointLabel, edi TreeRoot, D$TreeIndent 0
    While B$esi <> 0 | movsb | End_While | movsb
    call BuildOneTree

    On B$ShowOrphan = &TRUE, call ListOrphanLabels
L9: ret

 _______________________________________________________________________________________
 _______________________________________________________________________________________

; tree view main routines:

; Tag Dialog 22000

CreateTreeViewList:
    If D$ShowTreeHandle = 0
        call 'USER32.CreateDialogParamA' D$hInstance, 22000, D$hWnd, ShowTree, &NULL
        On D$BookMarks > 0, call ReInsertBookMarks
    Else
        call 'USER32.SetForegroundWindow' D$ShowTreeHandle
        call 'USER32.ShowWindow' D$ShowTreeHandle, &SW_RESTORE
    End_If
ret


; Called when loading a new file:

CloseTree:
    If D$ShowTreeHandle > 0
        call 'User32.DestroyWindow' D$ShowTreeHandle
        mov D$ShowTreeHandle 0
    End_If
ret


[ShowTreeHandle: ?]
[ActualWindow: ActualWindowX: ?  ActualWindowY: ?  ActualWindowW: ?  ActualWindowH: ?]

[TreeWP:
 TreeWP.iLength: D$ Len
 TreeWP.flags: D$ 0
 TreeWP.showCmd: D$ 0
 TreeWP.ptMinPosition.x: D$ 0
 TreeWP.ptMinPosition.y: D$ 0
 TreeWP.ptMaxPosition.x: D$ 0
 TreeWP.ptMaxPosition.y: D$ 0
 TreeWP.rcNormalPosition.left: D$ 0
 TreeWP.rcNormalPosition.top: D$ 0
 TreeWP.rcNormalPosition.right: D$ 0
 TreeWP.rcNormalPosition.bottom: D$ 0]

[ListKeyBoardInput: ?    AutoHideTreeView: ?    AutoRebuildTreeView: ?]

Proc ShowTree:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ..If D@Message = &WM_COMMAND
        .If D@wParam = &IDCANCEL
L7:        mov D$ShowTreeHandle 0
           call 'User32.EndDialog' D@Adressee 0   ; CloseTree

        .Else
            shr D@wParam 16

            If D@wParam = &LBN_KILLFOCUS
                On B$AutoHideTreeView = &TRUE,
                    call 'USER32.ShowWindow' D@Adressee &SW_MINIMIZE
            Else_If D@wParam = &LBN_SELCHANGE
                On B$ListKeyBoardInput = &FALSE, call SearchFromTreeListBox D@lParam
                mov B$ListKeyBoardInput &FALSE
            End_If
        .End_If

    ..Else_If D@Message = &WM_VKEYTOITEM    ; Prevents from searching hundreads of
        If W@wParam <> CR                   ; Label when user is moving through the
            mov B$ListKeyBoardInput &TRUE   ; List with the KeyBorad.
        Else                                ; But allow Search if [Return] Key depressed.
            call SearchFromTreeListBox D@lParam
        End_If
        popad | mov eax 0-1 | jmp L9>>

    ..Else_If D@Message = &WM_INITDIALOG
      ; Does not survive in the Minimized state...:
      ; call 'USER32.SetWindowLongA' D@Adressee, &GWL_EXSTYLE, &WS_EX_TOOLWINDOW
        call RestoreRealSource
        mov D$TreeViewItemEdge '    '
        move D$ShowTreeHandle D@Adressee
        call StorePosInBackTable
        call 'USER32.SetClassLongA' D$ShowTreeHandle &GCL_HICON D$wc_hIcon
        call ClearTreeLevels
        mov B$TreeAborted &FALSE | push ebp | call BuildLabelTreeList | pop ebp
        cmp B$TreeAborted &TRUE | je L7<<
        call BuildTree
        call SetPartialEditionFromPos

    ..Else_If D@Message = &WM_SIZE
      ; This is for adjusting the List Control to the Dialog new Size:
        call 'USER32.GetClientRect' D@Adressee, ListEditRect
        mov eax D$ListERX | sub D$ListERW eax
        mov eax D$ListERY | sub D$ListERH eax
        call 'USER32.GetDlgItem' D@Adressee, 100
        call 'USER32.MoveWindow' eax D$ListERX D$ListERY D$listERW D$ListERH &TRUE

      ; Save the user's Tree Dialog Width:
        call 'USER32.GetWindowRect' D@Adressee, ListEditRect
        mov eax D$ListERW | sub eax D$ListERX | mov D$TreeWidth eax

L1:     push D$TreeWP.ptMinPosition.x, D$TreeWP.ptMinPosition.y, D$TreeWP.flags
            call 'USER32.GetWindowPlacement' D$ShowTreeHandle TreeWP
        pop D$TreeWP.flags, D$TreeWP.ptMinPosition.y, D$TreeWP.ptMinPosition.x

    ..Else_If D@Message = &WM_MOVE
        jmp L1<

    ..Else_If D@Message = &WM_CTLCOLORLISTBOX
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    ..Else_If D@Message = &WM_ACTIVATE
       ; Wanted by... Anvar if i remember, but conflicts with any wish of moving
       ; the reduced Tree Window, with AutoHide Flag set on. So commented out:

       ; On B$AutoHideTreeView = &TRUE, call 'USER32.ShowWindow' D@Adressee &SW_NORMAL

    ..Else
        popad | mov eax &FALSE | jmp L9>

    ..End_If

    popad | mov eax &TRUE

L9: EndP


[TreeCurrentSel: ?    TreeUpperMainLabelSel: ?]

Proc SearchFromTreeListBox:
    Argument @lParam

    call RestoreRealSource

    call 'USER32.SendMessageA' D@lParam, &LB_GETCURSEL, 0, 0
    mov D$TreeCurrentSel eax, D$TreeUpperMainLabelSel eax

    call 'USER32.SendMessageA' D@lParam, &LB_GETTEXT, D$TreeUpperMainLabelSel, TreeViewItem
    mov esi TreeViewItem | On B$esi > ' ', jmp L2>
L1: lodsb | cmp B$esi ' ' | je L1<
        cmp B$esi '|' | je L1<

L2: If B$esi = '@'
L0:     dec D$TreeUpperMainLabelSel | jc L9>>
        call 'USER32.SendMessageA' D@lParam, &LB_GETTEXT, D$TreeUpperMainLabelSel,
                                   TreeViewItem
        mov esi TreeViewItem | On B$esi > ' ', jmp L2>
L1:     lodsb | cmp B$esi ' ' | je L1<
            cmp B$esi '|' | je L1<
L2:             On B$esi = '@', jmp L0<
                    call InternalRightClick

    Else
        call InternalRightClick | jmp L9>>

    End_If
;;
  If here, after having a selected Item saying "@Label", we have found out the upper
  MainLabel, which is now a selected Block.  We search downward for the wanted relative
  "@Label":
;;
    call 'USER32.SendMessageA' D@lParam, &LB_GETTEXT, D$TreeCurrentSel, TreeViewItem
        mov esi TreeViewItem | On B$esi > ' ', jmp L2>
L1:     lodsb | cmp B$esi ' ' | je L1<
            cmp B$esi '|' | je L1<

L2: push D$LenOfSearchedString
        mov edi SearchString, D$LenOfSearchedString 1
        While B$esi > ' '
            movsb | inc D$LenOfSearchedString
        End_While
        mov al ':' | stosb | mov al 0 | stosb

        push D$DownSearch, D$CaseSearch, D$WholeWordSearch, D$CurrentWritingPos
            mov B$DownSearch &TRUE, B$CaseSearch &FALSE, B$WholeWordSearch &TRUE
            move D$CurrentWritingPos D$BlockEndTextPtr
            push D$NextSearchPos
                move D$NextSearchPos D$CurrentWritingPos
                call StringSearch
            pop D$NextSearchPos
        pop D$CurrentWritingPos, D$CurrentWritingPos, D$CaseSearch, D$DownSearch
    pop D$LenOfSearchedString

L9: call SetPartialEditionFromPos
EndP



; Set the Tree Window at left of Main Window:

SetTreeDialogPos:
    call GetTreePlacement

    call 'USER32.SetWindowPlacement' D$ShowTreeHandle, TreeWP

    call 'USER32.GetWindowLongA' D$ShowTreeHandle, &GWL_STYLE | or eax &WS_VISIBLE
    call 'USER32.SetWindowLongA' D$ShowTreeHandle, &GWL_STYLE, eax
ret


[TreePlacementDone: ?    TreeWidth: ?
 TreeMinX: ?   TreeMinY: ?]

[EditWindowXforTree: ? EditWindowYforTree: ?
 EditWindowX2forTree: ? EditWindowY2forTree: ?]

GetTreePlacement:
    On B$TreePlacementDone = &TRUE, ret

    mov B$TreePlacementDone &TRUE

    call 'USER32.GetWindowRect' D$EditWindowHandle, EditWindowXforTree

  ; Default Width if the user never redefined it:
    On D$TreeWidth = 0, mov D$TreeWidth 250

    mov eax D$EditWindowX2forTree | mov D$TreeWP.rcNormalPosition.right eax
    sub eax D$TreeWidth | mov D$TreeWP.rcNormalPosition.left eax
    mov eax D$EditWindowYforTree | mov D$TreeWP.rcNormalPosition.top eax
    mov eax D$EditWindowY2forTree | mov D$TreeWP.rcNormalPosition.bottom eax

    mov D$TreeWP.flags &WPF_SETMINPOSITION
    mov eax D$TreeWP.rcNormalPosition.right | sub eax 160    ; founded Minimized Width.
    mov D$TreeWP.ptMinPosition.x eax
    mov eax D$TreeWP.rcNormalPosition.top
    move D$TreeWP.ptMinPosition.Y eax
    mov D$TreeWP.flags &WPF_SETMINPOSITION

    mov D$TreeWP.showCmd &SW_SHOWNORMAL
ret


____________________________________________________________________________________________

;;
  Simplified version of the &WM_INITDIALOG case in 'ShowTree' Proc. Called from
  'AsmMain' when 'AutoRebuildTreeView' is TRUE.
;;

TreeUpDate:
    call 'USER32.SendDlgItemMessageA' D$ShowTreeHandle, 100, &LB_RESETCONTENT, 0, 0

    mov D$TreeViewItemEdge '    ' | call ClearTreeLevels

    mov B$TreeAborted &FALSE | push ebp | call BuildLabelTreeList | pop ebp

    On B$TreeAborted = &FALSE, call BuildTree
L9: ret




TITLE Complete

;;
  Flag in [Configuration]: 'CompletionWanted'.

  'BuildCompletionTable' is called after each Compilation. It builds a Table of
  symbols (Labels, Macros and Equates), form the Assembler Lists: 'CompletionTable',
  Where each Record is a zero ended String.
  
  'CompletionPointers' is a Table of Pointers to the 'CompletionTable' Strings Table.
  
  The 'CodeComplete' Routines set the 'Underline' Flag on if one (and only one)
  fitting Symbol has been found.
  
  Once the 'Underline' Flag is set on, if the user hit [Ctrl]/[Space], the 'Completion'
  Routine is called.
  
  
  General Completion Checking: 'CodeComplete'
  
  'Completion' is the default (User symbols) and route to api or Equates when wanted.
  
  User symbols Routines:
  
  'UserSymbolsComplete' > 'CompletionCompare'  >'IsTheSmallerOnePartOfOthers'
  'Completion' > 'TakeCompleteModel' > 'CompleteSubstitute'
  
  Api Routine:
  
  'ApiComplete' > 'ApiCompletion' > 'CompletionListProc' > 'ApiSubstitute' > 'ReadApiForCompletion'

  OS Equates:
  
  'WinEquatesComplete'
  'EquatesCompletion'  > 'CompletionListProc' > 'InitListForEquates' > 'Win32EquatesSubstitute'
  
  'ListAllEquates'
;;
____________________________________________________________________________________________

[CompletionMode: ?] ; either 'Api', 'User', or 'Equ'

[CompletionTable: ?    CompletionPointers: ?]

BuildCompletionTable:
    VirtualFree D$CompletionTable, D$CompletionPointers

  ; Count how many Symbols:
    mov ecx 0, edx 0
    mov esi D$LabelList | add esi 5
    .While B$esi <> 0
        inc ecx | While B$esi > ' ' | inc esi | End_While | add esi 7
    .End_While
    add edx esi | sub edx D$LabelList

    mov esi D$MacroList | add esi 5
    .While B$esi <> 0
        inc ecx | While B$esi > ' ' | inc esi | End_While | add esi 11
    .End_While
    add edx esi | sub edx D$MacroList

    mov esi D$EquateList | add esi 5
    .While B$esi <> 0
        inc ecx | While B$esi > ' ' | inc esi | End_While | add esi 11
    .End_While
    add edx esi | sub edx D$EquateList

  ; Allocate mem for Strings ('CompletionTable')
  ; and for list of pointers to Strings ('CompletionPointers'):

    push edx
        inc ecx | shl ecx 2 | or ecx 1
        VirtualAlloc CompletionPointers ecx
    pop edx

    VirtualAlloc CompletionTable edx | inc D$CompletionTable

  ; Fill the Tables:
    mov edi D$CompletionTable, ebx D$CompletionPointers

    mov esi D$LabelList | add esi 5
    .While B$esi > ' '
        mov D$ebx edi | add ebx 4
        mov ecx 0
        While B$esi > ' '
            and B$esi 07F
            If B$esi = '@'
                sub ebx 4 | mov D$ebx 0
L0:             dec edi | cmp B$edi 0 | jne L0<
L0:             inc esi | cmp B$esi ' ' | ja L0<
                jmp L2>

            End_If
            movsb | inc ecx

        End_While
      ; Do not store all of Local Labels, and smaller than 4 Chars Labels
        If ecx < 4
            sub ebx 4 | mov D$ebx 0
L0:         dec edi | cmp B$edi 0 | jne L0<
        End_If

L2:     add esi 7
        mov B$edi 0 | inc edi
    .End_While

    mov esi D$MacroList | add esi 5
    .While B$esi > ' '
        mov D$ebx edi | add ebx 4
        While B$esi > ' ' | and B$esi 07F |  movsb | End_While | add esi 11
        mov B$edi 0 | inc edi
    .End_While

    mov esi D$EquateList | add esi 5
    .While B$esi > ' '
        mov D$ebx edi | add ebx 4
        While B$esi > ' '
            and B$esi 07F
            If B$esi = '@'
                sub ebx 4 | mov D$ebx 0
L0:             dec edi | cmp B$edi 0 | jne L0<
L0:             inc esi | cmp B$esi ' ' | ja L0<
                jmp L1>
            End_If
            movsb
        End_While
L1:     add esi 11
        mov B$edi 0 | inc edi
    .End_While
ret

____________________________________________________________________________________________
____________________________________________________________________________________________


[CompletionWanted: ?    CompletionFound: ?    CompletionRuning: ?]

[CompletionMinimumInput: 3]

; Check what the user is typing in:

CodeComplete:
    mov D$CompletionFound 0, B$Underline &FALSE, B$CompletionRuning &TRUE

    mov eax D$CurrentWritingPos

    If B$eax <= ' '
        ; OK
    Else_If B$eax = ','
        ; OK
    Else_If B$eax = "'"
        ; OK
    Else_If B$eax = '"'
        ; OK
    Else_If B$eax = ';'
        ; OK
    Else_If B$eax = '|'
        ; OK
    Else
        jmp L9>>
    End_If

    mov esi D$CurrentWritingPos
    push D$esi, esi
        mov B$esi 0 | dec esi
        mov ecx 0 | While B$esi > ' ' | dec esi | inc ecx | End_While | inc esi
        On ecx < D$CompletionMinimumInput, jmp L5>

        If B$esi+1 = '$'
            add esi 2 | On B$esi = '@', inc esi
            call UserSymbolsComplete
        Else_If B$esi+1 = '@'
            add esi 2 | call UserSymbolsComplete
        Else_If B$esi = "'"
            call ApiComplete
        Else_If B$esi = '"'
            call ApiComplete
        Else_If B$esi = '&'
            call WinEquatesComplete
        Else_If B$esi > ' '
            call UserSymbolsComplete
        End_If
L5: pop esi, D$esi

    ..If D$CompletionFound = 1
        mov B$Underline &TRUE

    ..Else_If D$CompletionFound > 20
      ; Too much > nop

    ..Else_If D$CompletionFound > 1
        .If D$CompletionMode = 'User'
            call IsTheSmallerOnePartOfOthers

            If eax = &TRUE
                move D$CompletionPointer D$ShorterSymbolPointer
                mov B$Underline al
            End_If
        .End_If

    ..End_If

L9: ..If D$CompletionListHandle <> 0
        .If B$Underline = &TRUE
            If D$CompletionMode = 'Api'
                call ApiCompletion
            Else_If D$CompletionMode = 'Equ'
                call EquatesCompletion
            End_If
        .Else
            call 'USER32.DestroyWindow' D$CompletionListHandle
            mov D$CompletionListHandle 0
        .End_If
    ..End_If
ret


; Search if the user entered text fits with some registred compiled Symbol:

UserSymbolsComplete:
    On D$CompletionTable = 0, ret ; jmp L5>>

    mov ebx D$CompletionPointers, D$CompletionMode 'User'
    While D$ebx <> 0

        mov edi D$ebx | add ebx 4
        call CompletionCompare
        .If al = 0
            If D$CompletionFound = 1
                move D$CompletionPointersList D$CompletionPointer
            Else_If D$CompletionFound > 20
              ; Too much > nop
            Else_If D$CompletionFound > 1
                push ebx
                    mov eax D$CompletionFound, ebx D$CompletionPointer
                    dec eax | mov D$CompletionPointersList+eax*4 ebx
                pop ebx
            End_If
        .End_IF

    End_While
ret


CompletionCompare:
  ; esi > User Source // edi > CompletionTable
  ; (At esi, the user's text has been temporary zero ended)
    push esi, edi, ebx
        mov ecx 0
L0:     mov bl B$edi | inc edi
L1:     mov al B$esi | inc esi | cmp al '_' | je L1<

        .If al >= 'a'
            On al <= 'z', sub al 020
        .Else_If al = 0
            If bl > ' '
                inc D$CompletionFound
                pop ebx, edi, esi
                mov D$CompletionPointer edi | ret
            End_If
        .End_If

        cmp al bl | jne L9>

        jmp L0<
L9: pop ebx, edi, esi
ret


; Several fiting Symbols found:
; Take the smaller one if all others bigger ones have the same prefix:

[ShorterSymbolPointer: ?    ShorterSymbolSize: ?]

IsTheSmallerOnePartOfOthers:
  ; get the smaller one:
    mov esi CompletionPointersList

    mov edx D$CompletionFound, ebx 0, D$ShorterSymbolSize 0-1

    .While ebx < edx
        mov eax D$esi+ebx*4, ecx 0

        While B$eax > ' ' | inc eax | inc ecx | End_While
        If ecx < D$ShorterSymbolSize
            mov D$ShorterSymbolSize ecx
            move D$ShorterSymbolPointer D$esi+ebx*4
        End_If

        inc ebx
    .End_While

  ; Now, is this smaller one a valid Prefix for all fitting Symbols:
    mov ebx 0, edx CompletionPointersList

    .While ebx < D$CompletionFound
        mov edi D$ShorterSymbolPointer, esi D$edx, ecx D$ShorterSymbolSize
        repe cmpsb
        If ecx <> 0
            mov eax &FALSE | ret
        End_If
        inc ebx | add edx 4
    .End_While

    mov eax &TRUE
ret


[CompletionPointer: ?]

; 'Completion' is called when user hit [Ctrl][Space]

Completion:
    If D$CompletionMode = 'Api'
        jmp ApiCompletion
    Else_If D$CompletionMode = 'Equ'
        jmp EquatesCompletion
    End_If

  ; Default case for User Symbols Completion:

    mov D$CompletionMode 'User'

    call RestoreRealSource

    mov esi D$CodeSource, edx D$SourceEnd

    .While esi < edx
        ...If D$esi = MLC
            add esi 4
            While D$esi <> MLC
                inc esi | On esi >= edx, jmp L9>>
            End_While
            add esi 4

        ...Else_If B$esi = ';'
            While B$esi > CR | inc esi | End_While

        ...Else_If B$esi = '"'
            inc esi
            While B$esi <> '"'
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ...Else_If B$esi = "'"
            inc esi
            While B$esi <> "'"
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ...Else
          ; Not necesserary the Declaration. Any previous evocation will do as well:
            mov al B$esi-1
            If al = '['
                ; Good
            Else_If al <= ' '
                ; Good
            Else_If al = ','
                ; Good
            Else_If al = '$'
                ; Good
            Else_If al = '|'
                ; Good
            Else
                jmp L5>>
            End_If

          ; > edi > ebx > Edition Pointer  //  esi > ecx > Search Pointer
            mov edi D$CompletionPointer, ecx esi

L0:         mov al B$esi
            If al >= 'a'
                On al <= 'z', sub al 020
            Else_If al = '_'
                inc esi | jmp L0<
            End_If

            If al <> B$edi
                mov esi ecx | jmp L5>
            End_If

            inc esi | inc edi

            .If B$edi <= ' '
                If B$esi <= ' '
                    ; Good
                Else_If B$esi = ','
                    ; Good
                Else_If B$esi = ':'
                    ; Good
                Else_If B$esi = ';'
                    ; Good
                Else_If B$esi = '|'
                    ; Good
                Else
                    mov esi ecx | jmp L5>
                End_If

                xchg esi ecx | mov edi CompletionModel
                While esi < ecx | movsb | End_While | mov B$edi 0 | jmp L9>

            .Else
                jmp L0<

            .End_If
        ...End_If

L5:     inc esi
    .End_While

L9: call SetPartialEditionFromPos

    call CompleteSubstitute
ret


[CompletionPointersList: ? #20] [CompletionModel: ? #20]

; Substitution for User defined Symbols

CompleteSubstitute:
    mov B$Underline &FALSE, B$Keys+&VK_CONTROL &FALSE
    mov D$CompletionMode 0, B$CompletionRuning &TRUE

    mov edi D$CurrentWritingPos
    dec edi | While B$edi > ' ' | dec edi | End_While | inc edi
    If B$edi+1 = '$'
        add edi 2 | On B$edi = '@', inc edi
    Else_If B$edi+1 = '@'
        add edi 2
    End_If

    mov B$OldBlockInside &FALSE
    While D$CurrentWritingPos > edi
        push edi
            call EraseLastChar
            call AskForRedrawNow
        pop edi
    End_While

    mov esi CompletionModel

    While B$esi <> 0
        push esi
            movzx eax B$esi | call InsertSource
            call AskForRedrawNow
        pop esi
        inc esi
    End_While

    mov B$CompletionRuning &FALSE
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Api Completion

[ApiInput: ? #20]

; Search if the user entered text fits with some Api Name:

ApiComplete: ; Win32Functions  WinApiFirstPass
    mov D$CompletionFound 0, D$CompletionMode 'Api'

    mov eax D$esi-5 | or eax 020202020 | On eax <> 'call', ret

    inc esi

  ; esi points now after the Text Separator. Is there some '.'?
    mov ebx D$CurrentWritingPos
    While ebx > esi
        dec ebx
        If B$ebx = '.'
            inc ebx | mov esi ebx | jmp L0>
        End_If
    End_While

  ; Make a Copy for the ListBox Edit: ;;; ???!!! What use now?
L0: push esi
        mov edi ApiInput
        While esi < D$CurrentWritingPos | movsb | End_While | mov B$edi 0
    pop esi

    mov ecx D$CurrentWritingPos | sub ecx esi | On ecx < D$CompletionMinimumInput, ret

    mov al B$esi, edi Win32Functions, ecx 0

    .While edi < EndOfFunctionsList
        ..If B$edi < al
          ; Next Line:
L2:         While B$edi <> LF | inc edi | End_While | inc edi

        ..Else_If B$edi > al
            ret

        ..Else
            mov D$CompletionPointer edi
            mov ebx esi | inc ebx | inc edi
            While ebx < D$CurrentWritingPos
                mov cl B$ebx | cmp cl B$edi | jne L2<
                inc ebx | inc edi
            End_While
            mov D$CompletionFound 1 | ret

        ..End_If

    .End_While
L9: ret

____________________________________________________________________________________________

ApiCompletion:
    mov D$CompletionMode 'Api'

    If D$CompletionListHandle <> 0
        call 'USER32.DestroyWindow' D$CompletionListHandle
    End_If

    call 'USER32.CreateDialogParamA' D$hinstance, 1200, D$hwnd, CompletionListProc, 0

    call 'USER32.SetFocus' D$hwnd

    mov B$Keys+&VK_CONTROL &FALSE
ret

____________________________________________________________________________________________

Proc ToCompletionList:
    Argument @Key

    call 'USER32.GetDlgItem' D$CompletionListHandle, 10
    call 'USER32.SetFocus' eax

    call 'USER32.SendDlgItemMessageA' D$CompletionListHandle, 10, &LB_GETCURSEL, 0, 0

    .If D@Key = &VK_UP
        If eax > 0
            dec eax
            call 'USER32.SendDlgItemMessageA' D$CompletionListHandle, 10,
                                              &LB_SETCURSEL, eax, 0
        End_If

    .Else_If D@Key = &VK_DOWN
        inc eax
        call 'USER32.SendDlgItemMessageA' D$CompletionListHandle, 10, &LB_SETCURSEL, eax, 0

    .Else_If D@Key = CR
        call CompletionListProc D$CompletionListHandle, &WM_COMMAND, &IDOK, 0

    .End_If
EndP


[CompletionListHandle: ?]

; Tag Dialog 1200

Proc CompletionListProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_INITDIALOG
        On D$CompletionListHandle <> 0,
            call 'USER32.EndDialog' D$CompletionListHandle, 0

        move D$CompletionListHandle D@Adressee | call SetCompletionPos

        .If D$CompletionMode = 'Api'
            call InitListForApi
        .Else_If D$CompletionMode = 'User'
            mov ecx 0
        .Else_If D$CompletionMode = 'Equ'
            call InitListForEquates
            If ecx = 0-1
                call 'USER32.EndDialog' D$CompletionListHandle, 0
                mov D$CompletionListHandle 0
            Else_If ecx = 0
                call 'USER32.SendDlgItemMessageA' D$CompletionListHandle, 10,
                                                  &LB_GETTEXT, 0, CompletionModel
                mov ecx 0
            End_If
        .End_If

L1:     If ecx = 0
            mov D$CompletionPointer CompletionModel
            call AskForRedrawNow
            call SubstituteFromEitherList
            call 'USER32.EndDialog' D$CompletionListHandle, 0
            mov B$Underline &FALSE, D$CompletionListHandle, 0
        Else
            call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &LB_SETCURSEL, 0, 0
        End_If

        jmp L8>>

    ...Else_If D@Message = &WM_COMMAND
        If D@wParam = &IDCANCEL
            call 'USER32.EndDialog' D$CompletionListHandle, 0
            mov D$CompletionListHandle 0

        Else_If D@wParam = &IDOK
            call ListOk

        Else_If W@wParam+2 = &LBN_DBLCLK
            call ListOk

        End_If

    ...Else_If D@Message = &WM_VKEYTOITEM
        If W@wParam = &VK_RETURN
            call ListOk
            popad | mov eax 0-2 | jmp L9>

        Else_If W@wParam = &VK_ESCAPE
            call 'USER32.EndDialog' D$CompletionListHandle, 0
            mov D$CompletionListHandle 0
            popad | mov eax 0-2 | jmp L9>

        Else
            popad | mov eax 0-1 | jmp L9>

        End_If

    ...Else_If D@Message = &WM_CHARTOITEM
      ; For Chars inputs to the User's Source. Does not work under 95:
        call 'USER32.SetFocus' D$hwnd

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE
L9: EndP

[ListRectangle: @X1: ? @Y1: ? @X2: @W: ? @Y2: @H: ?
 HwndTitleHight: ?]

SetCompletionPos:
    call 'USER32.GetWindowRect' D$hwnd, WindowX
    mov eax D$WindowX | sub D$WindowW eax
    mov eax D$WindowY | sub D$WindowH eax

    call 'USER32.GetClientRect' D$hwnd, ListRectangle
    mov eax D$WindowH | sub eax D$ListRectangle@H | mov D$HwndTitleHight eax

    call 'USER32.GetWindowRect' D$CompletionListHandle, ListRectangle

  ; Write the ApiList Window Width and hight, instead of RECTright, RECTbottom:
    mov eax D$ListRectangle@X2 | sub eax D$ListRectangle@X1
    mov D$ListRectangle@W eax
    mov eax D$ListRectangle@Y2 | sub eax D$ListRectangle@Y1
    mov D$ListRectangle@H eax

  ; Count how many Chars in the Underlinement:
    mov esi D$CurrentWritingPos, ecx 0 | dec esi
    While B$esi > ' ' | dec esi | inc ecx | End_While

  ; Translate Caret Pos into Pixels Pos:
    mov eax D$CaretRow | sub eax ecx | call RowToX eax | add eax D$WindowX
    push eax
        call LineToY D$CaretLine
        add eax D$WindowY | add eax D$HwndTitleHight
        push eax

          ; Is the Caret in the upper of lower part of the Screen?
            call 'USER32.GetSystemMetrics' &SM_CYSCREEN
            mov ecx eax | shr ecx 1
    pop ebx, eax

    If ebx < ecx
      ; Upper half: Set ListBox Pos under the user writing Pos:
        add ebx  D$FontHeight
    Else
      ; Lower half: Set ListBox Pos above the user writing Pos:
        sub ebx D$FontHeight | sub ebx D$ListRectangle@H
        On ebx > 0FFFF, mov ebx 0
    End_If

    call 'USER32.MoveWindow' D$CompletionListHandle, eax, ebx,
                             D$ListRectangle@W, D$ListRectangle@H, &TRUE
ret


InitListForApi:
    mov esi D$CompletionPointer, ecx 0
L0: mov edi CompletionModel
    While B$esi > ' ' | movsb | End_While | mov B$edi 0
    push esi, ecx
        call 'USER32.SendDlgItemMessageA' D$CompletionListHandle, 10, &LB_ADDSTRING,
                                          0, CompletionModel
    pop ecx esi
    While B$esi <= ' ' | inc esi | End_While
    mov ebx esi, edi ApiInput
    While B$edi <> 0
        mov al B$ebx | cmp al B$edi | jne L9>
        inc ebx | inc edi
    End_While
    inc ecx | mov B$edi 0 | jmp L0<
L9: ret


ListOk:
    call 'USER32.SendDlgItemMessageA' D$CompletionListHandle, 10, &LB_GETCURSEL, 0, 0
    call 'USER32.SendDlgItemMessageA' D$CompletionListHandle, 10, &LB_GETTEXT, eax,
                                      CompletionModel
    mov D$CompletionPointer CompletionModel
    call SubstituteFromEitherList
    call 'USER32.EndDialog' D$CompletionListHandle, 0
    mov B$Underline &FALSE, D$CompletionListHandle, 0
ret


SubstituteFromEitherList:
    If D$CompletionMode = 'Api'
        call ApiSubstitute
    Else_If D$CompletionMode = 'User'

    Else_If D$CompletionMode = 'Equ'
        call Win32EquatesSubstitute
    End_If
Ret


ApiSubstitute:
    mov B$CompletionRuning &TRUE, B$Underline &FALSE
    mov esi D$CurrentWritingPos

    call ReadApiForCompletion | On B$ApiFileOK = &FALSE, ret

L0: call EraseLastChar | call AskForRedrawNow
    mov eax D$CurrentWritingPos
    .If B$ApiFound = &FALSE
        If B$eax-1 = '.'
            While B$eax-1 <> "'"
                dec eax | cmp B$eax-1 '"' | je L1>
            End_While
            jmp L1>
        End_If
    .End_If
    cmp B$eax-1 "'" | je L1>
    cmp B$eax-1 '"' | jne L0<

L1: movzx eax B$eax-1
    push eax
        mov esi D$CompletionPointer
        While B$esi > ' '
            push esi
                movzx eax B$esi | call InsertSource
                move D$PhysicalCaretRow D$CaretRow
            pop esi
            inc esi
        End_While
    pop eax

    mov esi D$CurrentWritingPos | On B$esi <> al, call InsertSource
    call AskForRedrawNow

    mov B$ApiFound &FALSE, B$CompletionRuning &FALSE, D$CompletionMode 0
ret


ReadApiForCompletion:
    mov B$ApiFound &FALSE
    call OpenApiFunctionsFile | On B$ApiFileOK = &FALSE, ret

    mov esi D$Win32ApiList, ebx D$CompletionPointer

    mov edx D$ApiFileSize | add edx esi

L1: .While esi < edx
        inc esi
        ...If B$esi = '.'
            mov edi ebx                 ; edi > Our model  // esi > Win32ApiList
            inc esi

            Do
                mov al B$esi, ah B$edi

                .If al = '('
                    If ah <= ' '
                        mov B$ApiFound &TRUE
                        While B$esi-1 > LF | dec esi | End_While
                        mov edi ebx

                        While B$esi <> '(' | movsb | End_While | mov B$edi 0 | jmp L9>
                    End_If
                .End_If

                inc esi | inc edi
            Loop_Until al <> ah

        ...End_If
    .End_While

L9: VirtualFree D$Win32ApiList
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; OS Equates Completion

____________________________________________________________________________________________
____________________________________________________________________________________________


; Search if the user entered text fits with some Win32 Equate:

WinEquatesComplete:
    mov D$CompletionFound 1, D$CompletionMode 'Equ'
ret


EquatesCompletion:
    call IsEquatesEquThere

    If B$IncludesOK = &TRUE
        call GetEquFilesMemory
        call ReadEquatesEqu
        call 'USER32.CreateDialogParamA' D$hinstance, 1200, D$hwnd, CompletionListProc, 0
        call 'USER32.SetFocus' D$hwnd
    End_If

    VirtualFree D$EquateIncMemory

    mov B$Keys+&VK_CONTROL &FALSE
ret


InitListForEquates:
    mov esi D$CurrentWritingPos, ecx 0

  ; Take an Upper Case copy of user input:
    While B$esi-1 > '&' | dec esi | End_While | mov edi CompletionModel
    While esi < D$CurrentWritingPos
        lodsb | On al > 'Z', and al 00_11011111
        stosb
    End_While
    mov B$edi 0

  ; Search fitting Items in Equates.equ:
    mov edi D$EquateIncMemory, ecx 0, edx edi | add edx D$EquatesIncFileSize

L0: mov esi CompletionModel, al B$esi
    .If B$edi = al
        While B$edi = al | inc esi | inc edi | mov al B$esi | End_While
        If al = 0
            While B$edi > ' ' | inc edi | End_While
            push edx, ecx, D$edi, edi
                mov B$edi 0 | dec edi
                While B$edi > LF
                    dec edi | On edi = D$EquateIncMemory, jmp L1>
                End_While
                inc edi
L1:             call 'USER32.SendDlgItemMessageA' D$CompletionListHandle, 10, &LB_ADDSTRING, 0, edi
            pop edi, D$edi, ecx, edx
            inc ecx
            jmp L2>

        Else
L2:         While B$edi > LF | inc edi | End_While | inc edi
            On edi >= edx, jmp L9>
            mov al B$CompletionModel
            On al >= B$edi, jmp L0<

        End_If

    .Else_If B$edi <= al
        jmp L2<

    .End_If

L9: dec ecx | On ecx = 0-1, call ListAllEquates
ret


; No matching Equate found > propose the full List:

ListAllEquates:
    call 'USER32.MessageBoxA', D$hwnd, {"Do you want the complete List?

(This may take some time to build the list)", 0}, {'No such OS Equate', 0},
&MB_YESNO__&MB_SYSTEMMODAL

    If eax = &IDNO
        mov ecx 0-1 | ret
    End_If

    On D$EquateIncMemory = 0, ret
    On D$EquatesIncFileSize = 0, ret

    mov esi D$EquateIncMemory, edx esi | add edx D$EquatesIncFileSize

L0: mov edi esi | While B$edi > ' ' | inc edi | End_While

    push edx, esi D$edi, edi
        mov B$edi 0
        call 'USER32.SendDlgItemMessageA' D$CompletionListHandle, 10, &LB_ADDSTRING, 0, esi
    pop edi, D$edi, esi, edx

    If eax <> &LB_ERR
        mov esi edi |  While B$esi-1 <> LF | inc esi | End_While
        On esi < edx, jmp L0<
    End_If
ret


Win32EquatesSubstitute:
    mov B$CompletionRuning &TRUE, B$Underline &FALSE, D$CompletionMode 0

    mov esi D$CurrentWritingPos

L0: call EraseLastChar | ;call AskForRedrawNow
    mov eax D$CurrentWritingPos
    cmp B$eax-1 '&' | jne L0<

L1: mov esi D$CompletionPointer
    While B$esi > ' '
        push esi
            movzx eax B$esi | call InsertSource
            move D$PhysicalCaretRow D$CaretRow
        pop esi
        inc esi
    End_While

    call AskForRedrawNow

    mov B$CompletionRuning &FALSE
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  While the Completion ListBox is runing, there are many user actions that may
  require to close this ListBox (moves of Caret by KeyBoard or Mouse).
;;

KillCompletionList:
    If D$CompletionListHandle <> 0
        call 'USER32.SendMessageA' D$CompletionListHandle, &WM_COMMAND, &IDCANCEL, 0
    End_If
    mov B$Underline &FALSE
    call AskForRedraw
ret












TITLE Search
 _______________________________________________________________________________________
 _______________________________________________________________________________________

;                              Search / replace routines:
 _______________________________________________________________________________________
 _______________________________________________________________________________________


; Dialog Box for Find/Replace and simple search. writing
; "U$ 04 0 0 0CA 03D" at FRdialog+4 turns it simple search

[FRdialog: D$ 090C008C2 0      ; Style
 U$ 0C 0 0 0CB 06A             ; Dim  >>>   U$ 04 0 0 0CA 03D  ; Dim for search only
 0                             ; Menu (not yet)
 0                             ; Class(not yet)
 'Search what' 0               ; Title
 08 'Helv' 0]                  ; Font

[FRC0: D$ 050000202 0          ; Style
 U$ 02 0 0C8 093               ; Dim
 012C                          ; ID
 0FFFF 085                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

[FRC1: D$ 050000001 0          ; Style
 U$ 089 02A 03F 011            ; Dim
 &FR_FINDNEXT                   ; ID
 0FFFF 080                     ; Class
 'Search' 0                    ; Title
 0]                            ; No creation data

[FRC2: D$ 050000000 0          ; Style
 U$ 089 013 03F 011            ; Dim
 &FR_DIALOGTERM                 ; ID
 0FFFF 080                     ; Class
 'Close' 0                     ; Title
 0]                            ; No creation data

[FRC3: D$ 050000003 0          ; Style
 U$ 047 029 036 010            ; Dim
 FR_WHOLEWORD                  ; ID
 0FFFF 080                     ; Class
 'Whole word' 0                 ; Title
 0]                            ; No creation data

[FRC4: D$ 050000007 0          ; Style
 U$ 02 0F 080 02C              ; Dim
 041                           ; ID
 0FFFF 080                     ; Class
 'Search Flags' 0              ; Title
 0]                            ; No creation data

[FRC5: D$ 050000009 0          ; Style
 U$ 07 019 038 010             ; Dim
 FR_UP                         ; ID
 0FFFF 080                     ; Class
 'Upward' 0                    ; Title
 0]                            ; No creation data

[FRC6: D$ 050000009 0          ; Style
 U$ 07 029 038 010             ; Dim
 FR_DOWN                       ; ID
 0FFFF 080                     ; Class
 'Downward' 0                  ; Title
 0]                            ; No creation data

[FRC7: D$ 050000003 0          ; Style
 U$ 047 01B 032 0E             ; Dim
 FR_MATCHCASE                  ; ID
 0FFFF 080                     ; Class
 'Case' 0                      ; Title
 0]                            ; No creation data    <<<<<<<<<<<< end of simple search

[FRC8: D$ 050000027 0          ; Style
 U$ 0 049 0CC 07               ; Dim
 0133                          ; ID
 0FFFF 080                     ; Class
 'Replace with' 0              ; Title
 0]                            ; No creation data

[FRC9: D$ 050000000 0          ; Style
 U$ 042 046 040 011            ; Dim
 FR_REPLACEALL                 ; ID
 0FFFF 080                     ; Class
 'Replace all' 0               ; Title
 0]                            ; No creation data

[FRC10: D$ 050000000 0         ; Style
 U$ 089 046 03F 011            ; Dim
 FR_REPLACE                    ; ID
 0FFFF 080                     ; Class
 'Find/Replace' 0              ; Title
 0]                            ; No creation data

[FRC11: D$ 050000202 0         ; Style
 U$ 01 05B 0C8 093             ; Dim
 0136                          ; ID
 0FFFF 085                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data



[FR_UP 150    FR_DOWN 151    FR_WHOLEWORD 154    FR_MATCHCASE 155
 FR_REPLACEALL 156    FR_REPLACE 157]

________________________________________________________________________________________

; these setting use the same Dialog Box data for both options:

SetFindReplaceBox:
    mov B$Replace &TRUE
    mov edi FRdialog | add edi 8
    mov ax 0C | stosw | mov eax 0 | stosd | mov eax 06A_00CB | stosd  ; U$ 0C 0 0 0CB 06A
    jmp L9>

SetSimpleSearchBox:
    mov B$Replace &FALSE
    mov edi FRdialog | add edi 8
    mov ax 08 | stosw | mov eax 0 | stosd | mov eax 0_3D_00CB | stosd  ; U$ 04 0 0 0CB 03D

L9: If D$FindReplaceHandle = 0
        call 'User32.CreateDialogIndirectParamA' D$hinstance, FRdialog, D$hwnd, FRproc, 0
    Else
        Beep
    End_If
ret


[UserSearchStringHandle: ?  UserReplaceStringHandle: ?  OnReplace: ?
 LenOfSearchedString: ?     LenOfReplaceString: ?]

[StringChange: ?]

GetUserSearchString:
    mov edi ControlString, esi SearchString, ecx 120 | rep movsb
    mov edi SearchString, al 0, ecx 120 | rep stosb
    call 'User32.SendMessageA' D$UserSearchStringHandle &WM_GETTEXTLENGTH 0 0
    mov D$LenOfSearchedString eax
    On eax = 0, ret
    mov D$LenOfSearchedString eax
 ; "WM_GETTEXTLENGTH" message does not include end mark. "WM_GETTEXT" does >>> inc eax
    inc eax
    call 'User32.SendMessageA' D$UserSearchStringHandle &WM_GETTEXT eax SearchString
    mov B$OnReplace &FALSE

  ; Control if user changed the string for FindOrReplace flag in FRproc. (if he changed
  ; between a Find and a Replace, we have to reset to search again):
    mov B$StringChange &FALSE
    mov edi ControlString, esi SearchString, ecx 120 | rep cmpsb | je L5>
      mov B$StringChange &TRUE

  ; add (only new) string to List and delete last one (limit=15 strings):

L5: call 'User32.SendMessageA' D$UserSearchStringHandle  &CB_FINDSTRINGEXACT 0-1 SearchString
    If eax = &CB_ERR
        call 'User32.SendMessageA' D$UserSearchStringHandle &CB_INSERTSTRING 0  SearchString
        call 'User32.SendMessageA' D$UserSearchStringHandle &CB_DELETESTRING 15 0
    End_If
ret

GetUserReplaceString:
    mov edi ReplaceWithString, al 0, ecx 120 | rep stosb
    call 'User32.SendMessageA' D$UserReplaceStringHandle, &WM_GETTEXTLENGTH, 0, 0
    mov D$LenOfReplaceString eax
    On eax = 0, ret
    inc eax
    call 'User32.SendMessageA' D$UserReplaceStringHandle, &WM_GETTEXT, eax, ReplaceWithString
    mov B$OnReplace &TRUE

  ; add (only new) string to List and delete last one (limit=15 strings):
    call 'User32.SendMessageA' D$UserReplaceStringHandle, &CB_FINDSTRINGEXACT, 0-1,
                               ReplaceWithString
    If eax = &CB_ERR
      call 'User32.SendMessageA' D$UserReplaceStringHandle, &CB_INSERTSTRING, 0,
                                 ReplaceWithString
      call 'User32.SendMessageA' D$UserReplaceStringHandle, &CB_DELETESTRING, 15, 0
    End_If
ret


; Set them all to previous state (third parameter) at initialisation time:

SetSearchFlagButtons:
    call 'User32.GetDlgItem' D$FindReplaceHandle, FR_DOWN
    call 'User32.SendMessageA' eax, &BM_SETCHECK, D$DownSearch, 0

    call 'User32.GetDlgItem' D$FindReplaceHandle, FR_UP
    mov ebx D$DownSearch | xor ebx &TRUE
    call 'User32.SendMessageA' eax, &BM_SETCHECK, ebx, 0

    call 'User32.GetDlgItem' D$FindReplaceHandle, FR_MATCHCASE
    call 'User32.SendMessageA' eax, &BM_SETCHECK, D$CaseSearch, 0

    call 'User32.GetDlgItem' D$FindReplaceHandle, FR_WHOLEWORD
    call 'User32.SendMessageA' eax, &BM_SETCHECK, D$WholeWordSearch, 0
ret


[STR01: B$ ? #120] [STR02: B$ ? #120] [STR03: B$ ? #120] [STR04: B$ ? #120] [STR05: B$ ? #120]
[STR06: B$ ? #120] [STR07: B$ ? #120] [STR08: B$ ? #120] [STR09: B$ ? #120] [STR10: B$ ? #120]
[STR11: B$ ? #120] [STR12: B$ ? #120] [STR13: B$ ? #120] [STR14: B$ ? #120] [STR15: B$ ? #120]
[STR16: ?]
[RTR01: B$ ? #120] [RTR02: B$ ? #120] [RTR03: B$ ? #120] [RTR04: B$ ? #120] [RTR05: B$ ? #120]
[RTR06: B$ ? #120] [RTR07: B$ ? #120] [RTR08: B$ ? #120] [RTR09: B$ ? #120] [RTR10: B$ ? #120]
[RTR11: B$ ? #120] [RTR12: B$ ? #120] [RTR13: B$ ? #120] [RTR14: B$ ? #120] [RTR15: B$ ? #120]
[RTR16: ?] [STR_RTR_len: RTR16-STR01]

StoreSearchStrings:
  ; ecx = [(120 bytes * 30) / 4] + 2 (edges) = 902
    mov edi STR01, eax 0, ecx D$STR_RTR_len | rep stosb                  ; clear all tables
    call 'User32.SendMessageA' D$UserSearchStringHandle, &CB_GETCOUNT, 0, 0
    On eax = &CB_ERR, ret

    mov edi STR01, ebx 0

    While eax > 0
      push eax, ebx, edi
        call 'User32.SendMessageA' D$UserSearchStringHandle, &CB_GETLBTEXT, ebx, edi
      pop edi, ebx, eax
      dec eax | inc ebx | add edi 120
    End_While

    call 'User32.SendMessageA' D$UserReplaceStringHandle, &CB_GETCOUNT, 0, 0
    On eax = &CB_ERR, ret

    mov edi RTR01, ebx 0

    While eax > 0
      push eax, ebx, edi
        call 'User32.SendMessageA' D$UserReplaceStringHandle, &CB_GETLBTEXT, ebx, edi
      pop edi, ebx, eax
      dec eax | inc ebx | add edi 120
    End_While
ret


RestoreSearchStrings:
    mov esi STR01, ebx 0
    While B$esi > 0
        push ebx, esi
            call 'User32.SendMessageA' D$UserSearchStringHandle, &CB_INSERTSTRING, ebx, esi
        pop esi, ebx
        inc ebx | add esi 120
    End_While

    mov esi RTR01, ebx 0
    While B$esi > 0
        push ebx, esi
            call 'User32.SendMessageA' D$UserReplaceStringHandle, &CB_INSERTSTRING, ebx, esi
        pop esi, ebx
        inc ebx | add esi 120
    End_While
ret

_____________________________________________________________________________________

[FinfOrReplace: ?    FindReplaceHandle: ?]

Proc FRproc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message  = &WM_INITDIALOG
        mov B$ShiftBlockInside &FALSE

        move D$FindReplaceHandle D@Adressee
        mov B$FinfOrReplace &FALSE                  ; flag 0 for Search / 1 Replace
        call 'User32.GetDlgItem' D@Adressee 012C     ; 012C = our Find Edit Box
        mov D$UserSearchStringHandle eax
        call 'User32.GetDlgItem' D@Adressee 0136     ; 0136 = our Replace Edit Box
        mov D$UserReplaceStringHandle eax
        call RestoreSearchStrings
        call SetSearchFlagButtons
        call 'User32.SetFocus' D$UserSearchStringHandle  ; return 0  to
        call 'USER32.SetClassLongA' D$FindReplaceHandle &GCL_HICON D$wc_hIcon
        jmp L8>>                                        ; keep focus to first edit control

    ...Else_If D@Message = &WM_COMMAND
        mov eax D@wParam
        .If eax = &FR_DIALOGTERM
L0:         call StoreSearchStrings
            mov D$FindReplaceHandle 0
            call 'User32.DestroyWindow' D@Adressee
        .Else_If eax = &FR_FINDNEXT
L1:         call GetUserSearchString
            On D$LenOfSearchedString = 0, jmp L8>>
                call RestoreRealSource
                    call StringSearch
                    On B$BlockInside = &TRUE, mov B$FinfOrReplace &TRUE ; ready for Replace if whished
                call SetPartialEditionFromPos
        .Else_If eax = &IDCANCEL
            jmp L0<
        .Else_If eax = &IDOK
            jmp L1<
        .Else_If eax = FR_DOWN
            mov B$DownSearch &TRUE, B$FinfOrReplace &FALSE
        .Else_If eax = FR_UP
           mov B$DownSearch &FALSE, B$FinfOrReplace &FALSE
        .Else_If eax = FR_MATCHCASE
           xor B$CaseSearch &TRUE | mov B$FinfOrReplace &FALSE
        .Else_If eax = FR_WHOLEWORD
           xor B$WholeWordSearch &TRUE | mov B$FinfOrReplace &FALSE
        .Else_If eax = FR_REPLACE
           call GetUserSearchString | call GetUserReplaceString
           ..If B$FinfOrReplace = &TRUE
                If B$StringChange = &TRUE   ; see "StringChange" comment in GetUserSearchString
                    mov B$FinfOrReplace &FALSE
                    call RestoreRealSource
                        call StringSearch
                    call SetPartialEditionFromPos
                Else
                  On D$LenOfSearchedString > 0, call StringReplace  ; &TRUE > Replace
                End_If
           ..Else
                call RestoreRealSource
                    call StringSearch                               ; false > Search
                call SetPartialEditionFromPos
           ..End_If
           xor B$FinfOrReplace &TRUE
        .Else_If eax = FR_REPLACEALL
           call RestoreRealSource
                call GetUserReplaceString | call GetUserSearchString
                On D$LenOfSearchedString > 0,  call StringReplaceAll
           call SetPartialEditionFromPos
        .Else
           jmp L8>
        .End_If

        call 'USER32.SetFocus' D@Adressee

    ...Else_If D@Message = &WM_CTLCOLOREDIT
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP



[SearchString: B$ ? #120]  [ReplaceWithString: B$ ? #120]  [ControlString:B$ ? #120]

[DownSearch:  ?  CaseSearch: ?  WholeWordSearch: ?   SkipDashLines: ?
 Replace: ?   StringFound: ?]
[StringNotFound: B$ 'String not found', 0]

[NextSearchPos: ?    SearchFirstChar: ?]


[Lowcase | cmp #1 'A' | jb C9> | cmp #1 'Z' | ja C9> | or #1 020 | C9:]

; If user change the searched string inside a Find/Replace process, we have to reset
; the "FindOrReplace" flag in FRproc:

StringSearch:
    mov B$ShiftBlockInside &FALSE, B$StringFound &TRUE

    On D$LenOfSearchedString = 0, ret
    mov B$BlockInside &FALSE

L0: mov edi SearchString, esi edi, edx D$LenOfSearchedString
    dec edx                                                     ; - first tested char
    If B$DownSearch = &TRUE
        mov ah B$edi | inc edi | mov ebx 1
    Else
        add edi edx | mov ah B$edi | dec edi | std | mov ebx 0-1; ebx > inc/dec edi in L4 loop
    End_If

    On B$CaseSearch = &FALSE, LowCase ah

    If D$NextSearchPos = 0
        mov esi D$CurrentWritingPos
    Else
        mov esi D$NextSearchPos
        On esi > D$SourceEnd, mov esi D$CurrentWritingPos       ; case of massive block delete
    End_If

L2: cmp esi D$SourceEnd | ja L8>>                               ; search for fitting first Char:
    cmp esi D$CodeSource | jb L8>>
        lodsb | On B$CaseSearch = &FALSE, LowCase al
        cmp al ah | jne L2<

    ..If edx = 0                                                ; len = 1 > string found
        mov D$NextSearchPos esi
    ..Else
       mov ecx edx                                              ; first letter found:
       push eax, esi, edi
L4:      .If esi > D$SourceEnd
             pop edi, esi, eax | jmp L8>>
         .Else_If esi < D$CodeSource
             pop edi, esi, eax | jmp L8>>
         .Else
K0:          lodsb | mov ah al
             If B$SkipDashLines = &TRUE
                cmp ah '_' | je K0<
             End_If
K0:          mov al B$edi | add edi ebx
             If B$SkipDashLines = &TRUE
                cmp al '_' | je K0<
             End_If
             If B$CaseSearch = &FALSE
                LowCase ah
                LowCase al
             End_If
             If ah = al
                loop L4<
             Else
                 pop edi, esi, eax | jmp L2<<
             End_If
             mov D$NextSearchPos esi
         .End_If
L5:   pop edi, esi, eax
    ..End_If

    mov eax D$NextSearchPos                                 ; string found
    If B$DownSearch = &TRUE
        mov bl B$eax | dec eax | mov D$BlockEndTextPtr eax
        sub eax edx | mov D$CurrentWritingPos eax | mov D$BlockStartTextPtr eax
        mov bh B$eax-1
    Else
        mov bl B$eax | inc eax | mov D$CurrentWritingPos eax | mov D$BlockStartTextPtr eax
        mov D$NextSearchPos eax
        add eax edx | mov D$BlockEndTextPtr eax
        mov bh B$eax+1
    End_If

    .If B$WholeWordSearch = &TRUE
        mov al bl | call WordEdge
        If B$Edge = &TRUE
            mov al bh | call WordEdge
        End_If
        If B$Edge = &FALSE
            jmp L0<<
        End_If
    .End_If

    std | mov B$BlockInside &TRUE, D$RightScroll 0
L6: lodsb | cmp al LF | ja L6<
        dec esi | mov ebx esi | add ebx 2                     ; for caret h. Pos. count
L6: lodsb | cmp al LF | ja L6<                              ; start printing 2 lines upper
        dec esi
L6: lodsb | cmp al LF | ja L6<
        add esi 2

    If esi >= D$CodeSource
        mov D$UpperLine esi
    Else
        move D$UpperLine D$CodeSource
    End_If

    call SetCaret D$BlockEndtextPtr | jmp L9>

L8: cld
    If B$OnReplaceAll = &FALSE
        mov eax StringNotFound | call MessageBox            ; if not found
        mov B$StringFound &FALSE
    End_If
    mov D$NextSearchPos 0

L9: cld | On B$Disassembling = &FALSE, call AskForRedrawNow
ret


[ReplaceStart: ?]

StringReplace:
    mov B$ShiftBlockInside &FALSE

    .If B$BlockInside = &TRUE
        call ControlX
        mov ecx D$BlockEndTextPtr
        mov D$ReplaceStart ecx
        sub ecx D$BlockStartTextPtr | inc ecx
        dec D$CaretRow | dec D$PhysicalCaretRow
        mov esi ReplaceWithString
        While B$esi <> 0
            lodsb
            pushad
                movzx eax al | call InsertSource
            popad
            inc D$CaretRow | inc D$PhysicalCaretRow
            If al = LF
                mov D$CaretRow 1
            End_If
        End_While
    .Else
       jmp StringSearch
    .End_If

    If B$DownSearch = &TRUE
        move D$NextSearchPos D$CurrentWritingPos
    Else
        move D$NextSearchPos D$ReplaceStart
    End_If

    call AskForRedrawNow
ret


[AllDanger: "

  Are you sure you want 'replace all' ?

", 0  AllTitle: 'Danger:', 0]

[OnReplaceAll: SilentSearch: ?]

StringReplaceAll:
    call 'USER32.MessageBoxA' D$hwnd, AllDanger, AllTitle,
                              &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL

    ..If eax = &IDYES
        mov B$OnReplaceAll &TRUE

L0:     call RestoreRealSource
            call StringSearch
        call SetPartialEditionFromPos

        cmp B$BlockInside &TRUE | jne L9>

        call AskForRedrawNow | call StringReplace | jmp L0<

L9:     mov B$OnReplaceAll &FALSE
    ..End_If
ret

;StringReplaceAll:
    mov B$ShiftBlockInside &FALSE

    call 'USER32.MessageBoxA' D$hwnd, AllDanger, AllTitle,
                              &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL

    ..If eax = &IDYES
        mov B$OnReplaceAll &TRUE
L0:     call RestoreRealSource
        call StringSearch | cmp B$BlockInside &TRUE | jne L9>
        call StringReplace
        call SetPartialEditionFromPos | jmp L0<

L9:     mov B$OnReplaceAll &FALSE
        call SetPartialEditionFromPos
    ..End_If
ret








TITLE Config
 _______________________________________________________________________________________
 _______________________________________________________________________________________

; Configuration tab:

[StaticClassName: B$ 'STATIC', 0
 ButtonClassName:    'BUTTON' 0]

[ConfigTabHandle: ?]

[FirstTab:   B$ 'Tree View', 0       FirstTabLen: len
 SecondTab:  B$ 'Sources Editor', 0  SecondTabLen: len
 ThirdTab:   B$ 'Bad Habits' 0       ThirdTabLen: len
 FourthTab:   B$ 'Colors' 0          FourthTabLen: len
 FifthTab:  B$ 'Help Files' 0        FifthTabLen: len
 SixthTab:   B$ 'Companion Files' 0  SixthTabLen: len
 SeventhTab:   B$ 'User Menu' 0      SeventhTabLen: len
 HeigthTab: B$ 'Pos' 0               HeigthTabLen: len
 NinethTab: B$ 'Lang' 0              NinethTabLen: len
 DBPMenuTab: B$ 'DBP' 0              DBPMenuLen: len
 APItab:     B$ 'API', 0             APItabLen: len]

[CalcName: 'Calc.exe', 0] [CalcNameTail: 0 #60]                        ; If same dir
[EquatesName: 'Equates.equ', 0] [EquatesNameTail: 0 #60]
[F2Name: ? #60]
[CalcLinkName: 'C:\Program Files\BaseCalc\BASECALC.EXE', 0  OnCalc: 0] ; If Link to...

;[Asm32TutName: 'Asm32Help.exe', 0]      [Asm32TutNameTail: 0 #60]
[Win32HlpName: 'Win32.hlp', 0]          [Win32HlpNameTail: 0 #60] ;&MAX_PATH 0104  / 4 > 65d
[MmediaHlpName: 'Mmedia.hlp', 0]        [MmediaHlpNameTail: 0 #60]
[OpenGlHlpName: 'OpenGl.hlp', 0]        [OpenGlHlpNameTail: 0 #60]
;[OpcodeHlpName: 'x86eas.hlp', 0]        [OpcodeHlpNameTail: 0 #60]
;[WinDataFileName: 'WindowsData.inc', 0]     [WinDataFileNameTail: 0 #60]
[DxHlpName:    'directx.chm', 0]        [DxHlpNameTail: 0 #60]
[WinsockHlpName: 'Winsock.hlp', 0]      [WinsockHlpNameTail: 0 #60]
[SDLRefName: 'SDLRef.chm', 0]           [SDLRefNameTail: 0 #60]
[sqliteName: 'sqlite.hlp', 0]           [sqliteNameTail: 0 #60]
[DevILName: 'DevIL.html', 0]            [DevILNameTail: 0 #60]
[ClipName: 'Clip.txt', 0]               [ClipNameTail: 0 #60]
[B_U_AsmName: 'B_U_Asm.exe', 0]      [B_U_AsmNameTail: 0 #60]

[EntryPointLabel: B$ 'MAIN' 0 0 0 0 0 0 0 0 0 0
 EntryPointLabelLen: len]       ; upper case needed
;;
  Take care, that since the implementation of the "Tag Main NewName" Feature, this 
  'EntryPointLabelLen' can no more be used as such, and must be re-computed:
;;
[CallBackName: B$ 'MainWindowProc'  CallBackNameLen: len]

[TC_ITEM:
 TC_imask: &TCIF_TEXT__&TCIF_IMAGE   TC_lpReserved1: 0   TC_lpReserved2: 0
 TC_pszText: 0   TC_cchTextMax: 0    TC_iImage: 0-1      TC_lParam: 0]

[ITB1: "

Tree view is build by analyze of main labels and of calls to these main labels® If you validate [List orphans], the list will be added all 'non-called' main labels.

If you validate [First call only],  and some label is called many times, it will be listed at first call occurence only.", 0 ]

 ________________________________________________________________________

[TabDialogHandle: ?     ConfigTabbedDialogHandle: ?    ConfigTabIndex: ?]
[TabIs: 4    CtrlYflag: 0    SecurityWanted: &FALSE    SoundsWanted: &TRUE]

____________________________________________________________________________________________
____________________________________________________________________________________________

; Providing the required Path for "RosAsm Files" (Equates.equ and friends).

[FolderPath: B$ ? #&MAXPATH]
[PathInfo: B$ 'Choose a Path', 0]
[PathTitle: B$ 'For RosAsm Files', 0]

[BROWSEINFOA:
 BROWSEINFOA.hwndOwner: D$ 0
 BROWSEINFOA.pidlRoot: D$ 0
 BROWSEINFOA.pszDisplayName: D$ 0
 BROWSEINFOA.lpszTitle: D$ 0
 BROWSEINFOA.ulFlags: D$ &BIF_RETURNONLYFSDIRS__&BIF_DONTGOBELOWDOMAIN__&BIF_USENEWUI
 BROWSEINFOA.lpfn: D$ cbBrowse
 BROWSEINFOA.lParam: D$ PathInfo
 BROWSEINFOA.iImage: D$ 0]

[BrowseForFolderAborted: ?]

Proc BrowseForFolder:
    Arguments @hParent, @PathTitle

        mov D$FolderPath 0
        move D$BROWSEINFOA.hwndOwner D@hParent
        move D$BROWSEINFOA.lpszTitle D@PathTitle
        call 'SHELL32.SHBrowseForFolder' BROWSEINFOA

        If eax <> &FALSE
            push eax
                call 'SHELL32.SHGetPathFromIDList' eax, FolderPath
            pop eax
            mov B$BrowseForFolderAborted &FALSE

        Else
            mov B$BrowseForFolderAborted &TRUE

        End_If

        call 'OLE32.CoTaskMemFree' eax
Endp


Proc cbBrowse:
    Argument @hWin, @uMsg, @lParam, @lpData

    call 'USER32.SetWindowTextA'  D@hWin, D@lpData
EndP


; User has selected a Path for RosAsmFiles (Equates.equ *must* be there).

[MustHaveEquatesPath: "
You have not provided a Path to Equates.equ.

RosAsm is going to shut down, because it can't do anything       
whithout the OS Equates List.

", 0]


[BadEquatesPath: "
You have provided a Path for 'Equates.equ',
but this File is not there.

           Try again?


", 0]


VerifyEquatesPath:
    ..If D$FolderPath = 0
        If B$IncludesOK = &FALSE
L1:         call 'USER32.MessageBoxA', D$hwnd, MustHaveEquatesPath, Argh, &MB_SYSTEMMODAL
            call 'KERNEL32.ExitProcess' 0
        End_If

        mov eax 0-1

    ..Else
        mov eax FolderPath
        While B$eax <> 0 | inc eax | End_While
        mov D$eax '\Equ', D$eax+4 'ates', D$eax+8 '.equ', B$eax+12 0
        mov eax FolderPath

        call 'KERNEL32.FindFirstFileA' FolderPath, FindFile

        .If eax = &INVALID_HANDLE_VALUE
            call 'USER32.MessageBoxA' D$hwnd, BadEquatesPath, Argh,
                                      &MB_YESNO+&MB_SYSTEMMODAL+&MB_ICONQUESTION
            If eax = &IDNO
                On B$IncludesOK = &FALSE, jmp L1<<
                mov eax 0-1

            Else
                mov eax 0

            End_If

        .Else
            call 'KERNEL32.FindClose' eax

            mov eax FolderPath

        .End_If

    ..End_If
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; Tag Dialog 3000 >>> Main
; Tag Dialog 4000 >>> ListView
; Tag Dialog 4100 >>> Sources Editor
; Tag Dialog 4200 >>> Bad Habit
; Tag Dialog 4300 >>> Colors
; Tag Dialog 4400 >>> Help Files
; Tag Dialog 4500 >>> Companion Files
; Tag Dialog 4600 >>> User Menu
; Tag Dialog 4700 >>> Pos
; Tag Dialog 4800 >>> National Language
; Tag Dialog 4900 >>> Definition of the BP Menu

Configuration:
    If D$ConfigDialogHandle = 0
        call 'USER32.DialogBoxParamA' D$hinstance, 3000, &NULL, ConfigTabProc, &NULL
    Else
        Beep
    End_If
ret


InitConfigDialogTab:
    call 'USER32.GetDlgItem' D$ConfigDialogHandle, 100 | mov D$ConfigTabHandle eax

    mov D$TC_pszText FirstTab | move D$TC_cchTextMax, D$FirstTabLen
    call 'User32.SendMessageA' D$ConfigTabHandle, &TCM_INSERTITEM, 0, TC_ITEM

    move D$TC_pszText SecondTab | move D$TC_cchTextMax D$SecondTabLen
    call 'User32.SendMessageA' D$ConfigTabHandle, &TCM_INSERTITEM, 1, TC_ITEM

    move D$TC_pszText ThirdTab | move D$TC_cchTextMax, D$ThirdTabLen
    call 'User32.SendMessageA' D$ConfigTabHandle, &TCM_INSERTITEM, 2, TC_ITEM

    move D$TC_pszText FourthTab | move D$TC_cchTextMax D$FourthTabLen
    call 'User32.SendMessageA' D$ConfigTabHandle, &TCM_INSERTITEM, 3, TC_ITEM

    move D$TC_pszText FifthTab | move D$TC_cchTextMax D$FifthTabLen
    call 'User32.SendMessageA' D$ConfigTabHandle, &TCM_INSERTITEM, 4, TC_ITEM

    move D$TC_pszText SixthTab | move D$TC_cchTextMax D$SixthTabLen
    call 'User32.SendMessageA' D$ConfigTabHandle, &TCM_INSERTITEM, 5, TC_ITEM

    move D$TC_pszText SeventhTab | move D$TC_cchTextMax, D$SeventhTabLen
    call 'User32.SendMessageA' D$ConfigTabHandle, &TCM_INSERTITEM, 6, TC_ITEM

    move D$TC_pszText HeigthTab | move D$TC_cchTextMax D$HeigthTabLen
    call 'User32.SendMessageA' D$ConfigTabHandle, &TCM_INSERTITEM, 7, TC_ITEM

    move D$TC_pszText NinethTab | move D$TC_cchTextMax D$NinethTabLen
    call 'User32.SendMessageA' D$ConfigTabHandle, &TCM_INSERTITEM, 8, TC_ITEM

    move D$TC_pszText DBPMenuTab | move D$TC_cchTextMax D$DBPMenuLen
    call 'User32.SendMessageA' D$ConfigTabHandle, &TCM_INSERTITEM, 9, TC_ITEM

    move D$TC_pszText APItab | move D$TC_cchTextMax D$APItabLen
    call 'User32.SendMessageA' D$ConfigTabHandle, &TCM_INSERTITEM, 10, TC_ITEM
ret

____________________________________________________________________________________________

; The Main Proc for Configuration:

[ConfigDialogHandle: ?]

; Tag Dialog 4100 [Text Editor]

Proc ConfigTabProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_INITDIALOG
        .If D$ConfigDialogHandle = 0
            move D$ConfigDialogHandle D@Adressee
            call InitConfigDialogTab
            call 'USER32.CreateDialogParamA' D$hinstance, 4000, D$ConfigTabHandle,
                                             ConfigTabProc, &NULL
            mov D$ConfigTabbedDialogHandle eax, D$ConfigTabIndex 0
            call InittabTreeView
            call 'USER32.SetClassLongA' D$ConfigDialogHandle &GCL_HICON D$wc_hIcon
        .End_If
        jmp L8>>

    ...Else_If D@Message = &WM_NOTIFY
        mov esi D@lParam, eax D$esi+8
        ..If eax = &TCN_SELCHANGE
            call 'User32.SendMessageA' D$ConfigTabHandle, &TCM_GETCURSEL, 0, 0
            mov D$ConfigTabIndex eax

            call 'User32.DestroyWindow' D$ConfigTabbedDialogHandle
            mov eax D$ConfigTabIndex, ecx 100 | mul ecx | add eax 4000
push D$StringsLanguage ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            call 'USER32.CreateDialogParamA' D$hinstance, eax, D$ConfigTabHandle,
                                             ConfigTabProc, &NULL
            mov D$ConfigTabbedDialogHandle eax
pop D$StringsLanguage  ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            .If D$ConfigTabIndex = 0
                call InittabTreeView
            .Else_If D$ConfigTabIndex = 1
                call InitTabTextEditor
            .Else_If D$ConfigTabIndex = 2
                call InitBadHabits
            .Else_If D$ConfigTabIndex = 3
                call InitTabColors
            .Else_If D$ConfigTabIndex = 4
                call InitTabHelpFiles
            .Else_If D$ConfigTabIndex = 5
                call InitTabOtherFiles
            .Else_If D$ConfigTabIndex = 6
                call InitTabUserMenu
            .Else_If D$ConfigTabIndex = 7
                call InitTabPos
            .Else_If D$ConfigTabIndex = 8
                call InitTabLang
            .Else_If D$ConfigTabIndex = 9
                call InitTabdbp
            .Else_If D$ConfigTabIndex = 10
; Tag Dialog 5000
                call InitTabAPI
            .End_If

        ..End_If

    ...Else_If D@Message = &WM_COMMAND
        mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        ..If D@wParam = &IDCANCEL
            jmp L1>

        ..Else_If D@wParam = &IDOK
            call UpdateRegistry

            If D$UserPopUpHandle > 0
                call 'USER32.DeleteMenu' D$MenuHandle 7 &MF_BYPOSITION
            End_If
            call AddUserMenu | call EnableMenutems | call EnableHelpMenutems
            call 'USER32.DrawMenuBar' D$hwnd
L1:         call 'User32.DestroyWindow' D@Adressee
            mov D$ConfigDialogHandle 0

        ..Else_If D@wParam = &IDHELP
            call Help, B_U_AsmName, ConfigHelp, ContextHlpMessage

        ..Else_If eax = &BN_CLICKED
            mov eax D@wParam
            .If D$ConfigTabIndex = 0                ; Tree View.
                If eax = 11                         ; Check Orphans
                    xor B$ShowOrphan &TRUE
                Else_If eax = 12                    ; Check First call only
                    xor B$ShowLabelsOnce &TRUE
                Else_If eax = 13                    ; Check Tree View Auto-Hide
                    call CloseTree
                    xor B$AutoHideTreeView &TRUE
                Else_If eax = 14                    ; Rebuild tree after each Compilation
                    xor B$AutoRebuildTreeView &TRUE
                End_If

            .Else_If D$ConfigTabIndex = 1           ; Text Editor.
                call GetEditorConfig D@Adressee


            .Else_If D$ConfigTabIndex = 2           ; Bad Habits.
                If eax = 20
                    xor B$CtrlYFlag &TRUE
                Else_If eax = 21
                    xor B$BlockAutoDelete &TRUE
                Else_If eax = 22
                    xor B$NoVirtualLimit &TRUE
                Else_If eax = 23
                    xor B$WithControlA &TRUE
                End_If

L2:         .Else_If D$ConfigTabIndex = 3           ; Colors.
                pushad
                    If eax = 20                     ;D$Color1Handle
                        mov eax D$NormalBackColor | call SetColor
                        mov D$NormalBackColor eax | call ResetBackGroundColors
                    Else_If eax = 10                ; Color 2
                        mov eax D$StatementColor | call SetColor | mov D$StatementColor eax
                    Else_If eax = 11                ; Color 3
                        mov eax D$CommentColor | call SetColor | mov D$CommentColor eax
                    Else_If eax = 12                ; Color 4
                        mov eax D$TextColor | call SetColor | mov D$TextColor eax
                    Else_If eax = 13                ; Color 5
                        mov eax D$BracketColor | call SetColor | mov D$BracketColor eax
                    Else_If eax = 21                ; Color of Edit Controls, List Boxes,...
                        mov eax D$DialogsBackColor | call SetColor
                        mov D$DialogsBackColor eax | call ResetBackGroundColors
                    Else_If eax = 30
                        xor B$WantSizeMarkerColor &TRUE
                    End_If

                    call AskForRedrawNow
                popad

            .Else_If D$ConfigTabIndex = 4           ; Help Files.
                If eax = 500
                    call Help, B_U_AsmName, HelPFiles, ContextHlpMessage
                Else
                    call ConfigHelpFiles
                End_If

            .Else_If D$ConfigTabIndex = 5           ; Other Files

                pushad
                    push eax
                        If eax = 14
L1:                         call BrowseForFolder D@Adressee, PathTitle
                            call VerifyEquatesPath | On eax = &FALSE, jmp L1<
                                                     On eax <> 0-1, jmp L1>
                            pop eax | jmp L2>
                        Else
                            call ConfigSearchFile       ; returns Ptr or 0 in eax
                        End_If
L1:                 pop ebx
                    On eax = 0, jmp L2>>
                    mov esi eax
                    If ebx = 10
                        mov edi CalcName
                    Else_If ebx = 11
                        mov edi ClipName
                    Else_If ebx = 12
                        mov edi B_U_AsmName
                    Else_If ebx = 13
                        mov edi F2Name
                    Else_If ebx = 14
                        mov edi EquatesName
                    Else
                        jmp L2>
                    End_If

                    Do
                        lodsb | stosb
                    Loop_Until al = 0

                    call InitTabOtherFiles
L2:             popad

            .Else_If D$ConfigTabIndex = 6           ; User Menu
                On eax < 310, jmp L1>
                    On eax > 320, jmp L1>
                        call StripOneMenuUserItem | jmp L7>>

L1:             pushad
                    call CheckUserMenuItemText | On eax = 0, jmp L2>>
                popad
                pushad
                    push eax
                        call ConfigSearchFile       ; returns Ptr or 0 in eax
                    pop ebx
                    On eax = 0, jmp L2>>
                    mov esi eax

                    If ebx = 110
                        mov edi UserMenu0Path
                    Else_If ebx = 111
                        mov edi UserMenu1Path
                    Else_If ebx = 112
                        mov edi UserMenu2Path
                    Else_If ebx = 113
                        mov edi UserMenu3Path
                    Else_If ebx = 114
                        mov edi UserMenu4Path | I9: jmp I9>    ; just because no more '.'If
                    Else_If ebx = 115
                        mov edi UserMenu5Path
                    Else_If ebx = 116
                        mov edi UserMenu6Path
                    Else_If ebx = 117
                        mov edi UserMenu7Path
                    Else_If ebx = 118
                        mov edi UserMenu8Path
                    Else_If ebx = 119
                        mov edi UserMenu9Path
                    Else
                        jmp L2>
                    End_If

                    Do
                        lodsb | stosb
                    Loop_Until al = 0
                    call SaveUserMenuTab | call InitTabUserMenu
L2:             popad

            .Else_If D$ConfigTabIndex = 7           ; Pos
                If eax = 50
                    On B$SaveMainPosFlag = &FALSE, call GetUserPosTab
                Else_If eax = 51
                    On B$SaveMainPosFlag = &FALSE, call SaveUserPosTab
                Else_If eax = 52
                    call SetMaximized
                Else_If eax = 20
                    xor B$SaveMainPosFlag &TRUE | call InitTabPos
                End_If

          ; Tag Dialog 4800

             .Else_If D$ConfigTabIndex = 8           ; Lang
                call SetNationalLanguage

             .Else_If D$ConfigTabIndex = 9           ; DBPMenu
                call SetDBPMenu

             .Else_If D$ConfigTabIndex = 10          ; API verifications
                sub eax 10 | mov D$ApiCheckFlag eax

             .End_If

        ..End_If

    ...Else_If D@Message = &WM_CTLCOLOREDIT
        jmp L1>

    ...Else_If D@Message = &WM_CTLCOLORLISTBOX
L1:     call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

L7: popad | mov eax &TRUE

L9: EndP
____________________________________________________________________________________________

[NATION_CHOOSEFONT: ; EditorCHOOSEFONT
 @lStructSize: D$ len
 @hwndOwner: D$ 0
 @hDC: D$ 0
 @lpLogFont: D$ NATION_LOGFONT
 @iPointSize: D$ 0
 @Flags: D$ &CF_SCREENFONTS__&CF_INITTOLOGFONTSTRUCT
 @rgbColors: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0
 @hInstance: D$ 0
 @lpszStyle: D$ &SCREEN_FONTTYPE
 @nFontType: W$ 0
 @Alignment: W$ 0
 @nSizeMin: D$ 0
 @nSizeMax: D$ 0]

[NATION_LOGFONT: ; EditorLOGFONT
 @lfHeight: D$ 0
 @lfWidth: D$ 0
 @lfEscapement: D$ 0
 @lfOrientation: D$ 0
 @lfWeight: D$ 0
 @lfItalic: B$ 0
 @lfUnderline: B$ 0
 @lfStrikeOut: B$ 0
 @lfCharSet: B$ 0
 @lfOutPrecision: B$ 0
 @lfClipPrecision: B$ 0
 @lfQuality: B$ 0
 @lfPitchAndFamily: B$ 0
 @lfFaceName: B$ 0 #&LF_FACESIZE
 NATION_LOGFONTlen: len] ; NATION_LOGFONT@lfFaceName

[NationalFontHandle: ?]

GetNationalFont:
    move D$NATION_CHOOSEFONT@hwndOwner D$ConfigDialogHandle
    call 'Comdlg32.ChooseFontA' NATION_CHOOSEFONT

    If eax = &TRUE
        On D$NationalFontHandle <> 0, call 'GDI32.DeleteObject' D$NationalFontHandle
        call 'GDI32.CreateFontIndirectA' NATION_LOGFONT | mov D$NationalFontHandle eax
    End_If
ret


ConfigHelpFiles:
    pushad
        push eax
            call ConfigSearchFile       ; returns Ptr or 0 in eax
        pop ebx
        On eax = 0, jmp L2>>
        mov esi eax
        .If ebx = 10
        ;  mov edi Asm32TutName
        .Else_If ebx = 11
            mov edi Win32HlpName
        .Else_If ebx = 12
            mov edi MmediaHlpName
        .Else_If ebx = 13
            mov edi OpenGlHlpName
        .Else_If ebx = 14
        ; mov edi OpcodeHlpName
        .Else_If ebx = 15
        ;   mov edi WinDataFileName ;| I9: jmp I9>
    ; .Else_If ebx = 16
    ;     mov edi B_U_AsmName    ; Now only in [Other Files]
        .Else_If ebx = 17
            mov edi DxHlpName
        .Else_If ebx = 18
            mov edi WinsockHlpName
        .Else_If ebx = 19
            mov edi SDLRefName
        .Else_If ebx = 20
            mov edi sqliteName
        .Else_If ebx = 21
            mov edi DevILName
        .End_If

        Do
            lodsb | stosb
        Loop_Until al = 0
        call InitTabHelpFiles
L2: popad
ret


Proc GetEditorConfig:
    Argument @Parent

        .If eax = 11                    ; Tab is 2 spaces
            mov D$TabIs 2
        .Else_If eax = 12                    ; Tab is 4 spaces
            mov D$TabIs 4
        .Else_If eax = 13                    ; Tab is 8 spaces
            mov D$TabIs 8

        .Else_If eax = 50
            call XorScrollBar
        .Else_If eax = 51
            xor B$SecurityWanted &TRUE
        .Else_If eax = 52
            xor B$DollarOnly &TRUE
        .Else_If eax = 53                         ; Indent
            xor D$AutoIndentFlag &TRUE
            On B$AutoIndentFlag = &FALSE, mov D$AutoIndent 0
        .Else_If eax = 54
            xor B$LoadMRU &TRUE
           ; call 'USER32.CheckDlgButton' D@Parent 54 D$LoadMRU
        .Else_If eax = 55
            call XorToolBar
        .Else_If eax = 56
            xor B$SoundsWanted &TRUE
        .Else_If eax = 57
            xor B$CompletionWanted &TRUE
       ; .Else_If eax = 58
       ;     xor B$WriteCheckerWanted &TRUE
        .Else_If eax = 58
            If B$ParagraphChar = 167    ; Paragraph
                mov B$ParagraphChar 36  ; Dollar
            Else
                mov B$ParagraphChar 167
            End_If
        .Else_If eax = 201
            call GetMaxBackUp
        .Else
            call CheckFontAndBlink
        .End_If
EndP


GetMaxBackUp:
    mov D$MaxBackUp 0
    call 'USER32.GetDlgItemTextA' D$ConfigTabbedDialogHandle, 200,
                                  MaxBackUp, 5

    On B$MaxBackUp = 0, mov D$MaxBackUp '0000'

    While B$MaxBackUp+3 = 0
        shl D$MaxBackUp 8 | mov B$MaxBackUp '0'
    End_While

    call UpDateRegistry
ret


XorScrollBar:
    xor D$ScrollBarWanted &TRUE | call RedrawInterface
ret


XorToolBar:
    xor D$ToolBarWanted &TRUE | call RedrawInterface
ret


InittabTreeView:
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 10, &WM_SETTEXT, 0, ITB1
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 11, &BM_SETCHECK,
                                      D$ShowOrphan, 0
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 12, &BM_SETCHECK,
                                      D$ShowLabelsOnce, 0
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 13, &BM_SETCHECK,
                                      D$AutoHideTreeView, 0
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 14, &BM_SETCHECK,
                                      D$AutoRebuildTreeView, 0
ret

[NotYet: ' Will be available for next release...' 0]

InitTabTextEditor:
    mov ebx D$TabIs | and ebx 2 | shr ebx 1
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 11, &BM_SETCHECK, ebx, 0
    mov ebx D$TabIs | and ebx 4 | shr ebx 2
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 12, &BM_SETCHECK, ebx, 0
    mov ebx D$TabIs | and ebx 8 | shr ebx 3
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 13, &BM_SETCHECK, ebx, 0

    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 50, &BM_SETCHECK,
                                      D$ScrollBarWanted, 0
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 51, &BM_SETCHECK,
                                      D$SecurityWanted, 0
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 52, &BM_SETCHECK,
                                      D$DollarOnly, 0
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 53, &BM_SETCHECK,
                                      D$AutoIndentFlag, 0
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 54, &BM_SETCHECK,
                                      D$LoadMRU, 0
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 55, &BM_SETCHECK,
                                      D$ToolBarWanted, 0
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 56, &BM_SETCHECK,
                                      D$SoundsWanted, 0
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 57, &BM_SETCHECK,
                                      D$CompletionWanted, 0
   ; call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 58, &BM_SETCHECK,
   ;                                   D$WriteCheckerWanted, 0
    If B$ParagraphChar = 167
        mov eax &TRUE
    Else
        mov eax &FALSE
    End_If
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 58, &BM_SETCHECK,
                                      eax, 0


    mov eax MaxBackUp | While B$eax = '0' | inc eax | End_While
    On B$eax = 0, dec eax
    call 'USER32.SetDlgItemTextA' D$ConfigTabbedDialogHandle, 200, eax
    call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 200, &EM_SETLIMITTEXT, 4, 0

    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 301, &BM_SETCHECK,
                                      D$BlinkingCaretWanted, 0
    call 'User32.SetDlgItemInt' D$ConfigTabbedDialogHandle, 302, D$CaretTime, 0
ret

____________________________________________________________________________________________

[BadHabittext: "

A Sources Editor is not a Text Editor. 


This is why i spend much work-time with writing the Sources Editor from scratch instead of doing what most other IDEs Authors do:

Making use of an Edit or Richedit Control.

If you disagree with my choices these Flags are under your own decision.


Again, my recommandation: 

Do not use these Flags. 
These actions are incompatible with Assembly Edition, because they are going to help to corrupt your Sources.", 0]

InitBadHabits:
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 10, &WM_SETTEXT,
                                      0, BadHabittext

    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 20, &BM_SETCHECK,
                                      D$CtrlYFlag, 0

    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 21, &BM_SETCHECK,
                                      D$BlockAutoDelete, 0

    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 22, &BM_SETCHECK,
                                      D$NoVirtualLimit, 0

    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 23, &BM_SETCHECK,
                                      D$WithControlA, 0
ret
____________________________________________________________________________________________


CheckFontAndBlink:
    .If eax > 13
        If eax = 20
            call SelectFont

        Else
            jmp CheckBlinkCaret

        End_If

    .End_If
ret

CheckBlinkCaret:
    If eax = 301
        call KillBlinkCursor
        xor B$BlinkingCaretWanted &TRUE
        On B$BlinkingCaretWanted = &TRUE, call InitBlinkCursor
        call AskForRedraw

    Else_If eax = 303
        call 'User32.GetDlgItemInt' D$ConfigTabbedDialogHandle, 302, 0, 0
        mov D$CaretTime eax
        call ResetBlinkCursor

    Else_If eax = 320
        xor B$CompletionWanted &TRUE

    End_If
ret


InitTabColors:
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 30, &BM_SETCHECK,
                                      D$WantSizeMarkerColor, 0
ret


[HelpFilesPathsPtrs: Win32HlpName, MmediaHlpName, OpenGlHlpName,
                     DxHlpName, WinsockHlpName, SDLRefName, sqliteName, DevILName, 0]

InitTabHelpFiles:
;    mov esi HelpFilesPathsPtrs, ebx 110
;L0: push ebx esi
;        call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle ebx &WM_SETTEXT 0 D$esi
;    pop esi ebx
;    add esi 4 | inc ebx | cmp D$esi 0 | ja L0<
    call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 111, &WM_SETTEXT 0,
                                      Win32HlpName
    call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 112, &WM_SETTEXT 0,
                                      MmediaHlpName
    call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 113, &WM_SETTEXT 0,
                                      OpenGlHlpName
    call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 117, &WM_SETTEXT 0,
                                      DxHlpName
    call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 118, &WM_SETTEXT 0,
                                      WinsockHlpName
    call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 119, &WM_SETTEXT 0,
                                      SDLRefName
    call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 120, &WM_SETTEXT 0,
                                      sqliteName
    call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 121, &WM_SETTEXT 0,
                                      DevILName
ret


[OthersFilesPathsPtrs: CalcName ClipName B_U_AsmName F2Name EquatesName 0]

InitTabOtherFiles:
    mov esi OthersFilesPathsPtrs, ebx 100
L0: push ebx esi
        If D$esi = EquatesName
            push esi
                mov esi EquatesName
                While B$esi <> 0 | inc esi | End_While
                While D$esi <> 'Equa' | dec esi | End_While
                mov B$esi 0
            pop esi
        End_If
        call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, ebx, &WM_SETTEXT, 0,
                                          D$esi
    pop esi ebx
    add esi 4 | inc ebx | cmp D$esi 0 | ja L0<

    mov esi EquatesName
    While B$esi <> 0 | inc esi | End_While
    On D$esi+1 = 'quat', mov B$esi 'E'
ret

;;
  Note: a Durty hack up there, because i don't want to rewrite all of the Routines
  concerned by 'EquatesName' (providing the Path to all RosAsm Files, now). Previously
  i did not know how to do what 'BrowseForFolder' actually does, and i was retrieving
  the Path by runing a usual 'GetOpenFileName' pointing to Equates.equ.
;;


[UserMenuItemsPtrs: UserMenu0String UserMenu1String UserMenu2String UserMenu3String
                    UserMenu4String UserMenu5String UserMenu6String UserMenu7String
                    UserMenu8String UserMenu9String 0

 UserMenuPathsPtrs: UserMenu0Path UserMenu1Path UserMenu2Path UserMenu3Path
                    UserMenu4Path UserMenu5Path UserMenu6Path UserMenu7Path
                    UserMenu8Path UserMenu9Path 0]

InitTabUserMenu:
    mov esi UserMenuItemsPtrs, edi UserMenuPathsPtrs, ebx 10, ecx 210

L0: push edi, ecx, esi, ebx
        call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, ecx, &WM_SETTEXT,
                                          0, D$edi
        pop ebx, esi | push esi, ebx
        call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, ebx, &WM_SETTEXT,
                                          0, D$esi
    pop ebx, esi, ecx, edi
    add esi 4 | add edi 4 | inc ebx | inc ecx
    cmp D$esi 0 | ja L0<
ret


; ebx = 310 Based ID of [x] Button.

StripOneMenuUserItem:
    sub eax 310
  ; 'UserMenu0String' length is 8 dWords (32 Bytes per Record)
  ; 'UserMenu0Path' is 64 dWords (256 Bytes per Record)
  ; (sizes for ease of pointing).

    shl eax 5 ; * 32  (8 * dWord)

    lea edi D$UserMenu0String+eax | mov esi edi | add esi (4*8)
    mov ecx (8*8) | rep movsd

    shl eax 3  ; this is 3 more times > * 256 (64 * dWord)

    lea edi D$UserMenu0Path+eax | mov esi edi | add esi (4*64)
    mov ecx (64*8) | rep movsd

    call InitTabUserMenu
ret


; Tag Dialog 4700 >>> Pos

InitTabPos:
     call 'USER32.SetDlgItemInt' D$ConfigTabbedDialogHandle, 10, D$WindowX, &NULL
     call 'USER32.SetDlgItemInt' D$ConfigTabbedDialogHandle, 11, D$WindowY, &NULL
     call 'USER32.SetDlgItemInt' D$ConfigTabbedDialogHandle, 12, D$WindowW, &NULL
     call 'USER32.SetDlgItemInt' D$ConfigTabbedDialogHandle, 13, D$WindowH, &NULL

     If B$IsMaximizedFlag = &SW_MAXIMIZE
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 52,
                                          &BM_SETCHECK &TRUE, 0
        mov eax &FALSE

     Else_If B$SaveMainPosFlag = &TRUE
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 20,
                                          &BM_SETCHECK &TRUE, 0
        mov eax &FALSE

     End_If

     push eax
     call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 10, &WM_ENABLE, eax, 0
     pop eax | push eax
     call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 11, &WM_ENABLE, eax, 0
     pop eax | push eax
     call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 12, &WM_ENABLE, eax, 0
     pop eax
     call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 13, &WM_ENABLE, eax, 0
ret


SetMaximized:
     If B$IsMaximizedFlag = &SW_SHOWNORMAL
        mov B$IsMaximizedFlag &SW_MAXIMIZE
     Else
        mov B$IsMaximizedFlag &SW_SHOWNORMAL
     End_If

     call 'USER32.ShowWindow'  D$hwnd, D$IsMaximizedFlag
ret

; Tag Dialog 4800

InitTabLang:
    .If D$StringsLanguage = '.en'
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 10, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.fr'
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 11, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.br'
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 12, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.sp'
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 13, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.zh'
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 14, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.it'
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 15, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.de'
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 16, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.no'
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 17, &BM_SETCHECK, 1, 0
    .Else_If D$StringsLanguage = '.ca'
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 18, &BM_SETCHECK, 1, 0
    .Else
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 10, &BM_SETCHECK, 1, 0
    .End_If

    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 100, &EM_SETMARGINS,
                                      &EC_LEFTMARGIN__&EC_RIGHTMARGIN, 0100010

    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 100, &WM_SETTEXT, 0,
    {"
This Tab is for the definition of the Language to be used for displaying the Errors Messages given at Compile-Time, by the Assembler. The method will be generalized to the other Messages progressively.

Before using, you must have the National Strings Files, in a '.../RosAsmFiles/Lang/' Folder. If you downloaded 'RosAsmFull.zip', you have nothing to do. If you dowloaded the partial Files, unzip 'LangFiles.zip', in such a Folder.

The [National Font] Button is for choosing the Font to be used for dispaying the Error Messages. For the 'Ascii Users', this is just an option, but for the 'Unicode Users', - actualy only the [Chinese] ones -, this Font MUST be defined.

If your Language is missing, in this list, and if you wish to do the translation work, go to your Directory of 'RosAsm Files', and, in the [Lang] Folder, take the 'RosAsmStrings.en' Files, in any Editor.

In this File:

The '$$$$1', '$$$$2', ... Markers are simple Strings IDs, that you have to leave the way they are. These IDs are used by RosAsm to point out what National String subsitution matches with the default one.

In case you would see some '#1', '#2', ... inside a String, let these special Markers, as they are. These ones are used by RosAsm to mark the Positions of some Components of the Strings. For example, if an Error Message includes a Variable Number, these Markers are replaced on the fly, by the wished Numbers.

When you are over with a Translation, send me your work by Mail, at < betov@free.fr >, so that i could include it, and implement the needed Radio Button is this Tab.

", 0}
ret
____________________________________________________________________________________________

[DOUBLE_CLICK_ACTION 2  RIGHT_CLICK_ACTION 3]

[DBPMenuOn: DOUBLE_CLICK_ACTION]

InitTabdbp:
    If D$DBPMenuOn = DOUBLE_CLICK_ACTION
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 11, &BM_SETCHECK, 1, 0
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 12, &BM_SETCHECK, 0, 0
    Else
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 11, &BM_SETCHECK, 0, 0
        call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 12, &BM_SETCHECK, 1, 0
    End_If
ret


[ApiCheckFlag: ?] ; 0 // &DONT_RESOLVE_DLL_REFERENCES // No Verifiction

[ApiCheckInfo: "
Beginners: Let this Flag [Normal].

When compiling a Source, RosAsm does several verifications on your API calls, in order to point you to typos, missing DLLs, and so on...

In some exeptional cases (WDM drivers, General Hocks, ...) this may be a problem. So, if you perfectly know what you are doing, two Flags let you define the behaviour of RosAsm:

With the DONT_RESOLVE_DLL_REFERENCES Flag, the verifications of your calls will not address the references inside the concerned DLLS.

The last Flag will completely skip your API calls verifications. You do not need to set it for WDM Drivers, because, in the case of .SYS files, no such verification, is done, anyway.", 0]

InitTabAPI:
    mov eax 10 | add eax D$ApiCheckFlag

    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, eax, &BM_SETCHECK, 1, 0

    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 100, &WM_SETTEXT, 0, ApiCheckInfo
ret


SetDBPMenu:
    If eax = 11
        mov D$DBPMenuOn DOUBLE_CLICK_ACTION
    Else
        mov D$DBPMenuOn RIGHT_CLICK_ACTION
    End_If
ret
____________________________________________________________________________________________

[ConfigFilesFilters: B$ 'All'  0  '*.*'   0  0] [FullPathUserChoice: B$ ? #260]
[ConfigInitialDir: B$ ? #260]
[ConfigFileTitle: 'Choose the file to asign to the Menu', 0]

[CONFIGOPENFILENAME:
 @lStructSize: D$ LEN
 @hWndOwner: D$ 0
 @hInstance: D$ 0
 @lpstrFilter: D$ ConfigFilesFilters
 @lpstrCustomFilter: D$ 0
 @nMaxCustFilter: D$ 0
 @nFilterIndex: D$ 0
 @lpstrFile: D$ FullPathUserChoice
 @nMaxFile: D$ 260
 @lpstrFileTitle: D$ 0
 @nMaxFileTitle: D$ 0
 @lpstrInitialDir: D$ ConfigInitialDir
 @lpstrTitle: D$ ConfigFileTitle
 @Flags: D$ 0281804
 @nFileOffset: W$ 0
 @nFileExtension: W$ 0
 @lpstrDefExt: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0]

ConfigSearchFile:
    move D$CONFIGOPENFILENAME@hWndOwner D$ConfigDialogHandle
    move D$CONFIGOPENFILENAME@hInstance D$hInstance
    mov edi FullPathUserChoice, al 0, ecx 260 | rep stosb
    call 'COMDLG32.GetOpenFileNameA' CONFIGOPENFILENAME
    If B$FullPathUserChoice <> 0
        mov eax FullPathUserChoice
    Else
        mov eax 0
    End_If
ret

____________________________________________________________________________________________

; User ask for a 'ConfigSearchFile'. He must first set the Menu Item text:

[TitleErrorUserMenu: 'User Menu:', 0
 ErrorUserMenu:      'Enter the Menu item Text in the EditBox first.', 0]

CheckUserMenuItemText:
  ; > in: eax = ID of [File...] Button (first one = 110
    push eax
        sub eax 110 | shl eax 5
        lea edi D$UserMenu0String+eax
    pop eax
    push edi
        sub eax 100                             ; Menu Item Edit Control (First one = 10)
        call 'USER32.GetDlgItem' D$ConfigTabbedDialogHandle eax
    pop edi
    call 'USER32.SendMessageA' eax &WM_GETTEXT 30 edi
    If eax = 0
        call 'USER32.MessageBoxA' D$hwnd, ErrorUserMenu, TitleErrorUserMenu, &MB_SYSTEMMODAL
        mov eax &FALSE
    Else
        mov eax &TRUE
    End_If
ret


SaveUserMenuTab:
    pushad
        mov edi UserMenu0String, eax 10
L1:     push edi, eax
            call 'USER32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, eax,
                                              &WM_GETTEXT, 30, edi
        pop eax, edi
        inc eax | add edi 32 | cmp edi UserMenu9String | jbe L1<

        mov esi UserMenu0String, edi UserMenu0Path
L1:     On B$esi = 0, mov B$edi 0
        add esi 32 | add edi 256 | cmp edi UserMenu9Path | jbe L1<
    popad
ret



GetUserPosTab:
    call 'User32.GetWindowRect' D$hwnd WindowX
    If D$WindowX > 0FFF_FFFF
        mov D$WindowX 0
        mov D$WindowY 0
        call 'USER32.GetSystemMetrics' &SM_CXSCREEN | mov D$WindowW eax
        call 'USER32.GetSystemMetrics' &SM_CYSCREEN | mov D$WindowH eax
    Else
        mov eax D$WindowX | sub D$WindowW eax
        mov eax D$WindowY | sub D$WindowH eax
    End_If
    call InitTabPos
ret

SaveUserPosTab:
    call 'User32.SendDlgItemMessageA' D$ConfigTabbedDialogHandle, 20, &BM_GETCHECK, 0, 0
    mov D$SaveMainPosFlag eax
    call 'User32.GetDlgItemInt' D$ConfigTabbedDialogHandle, 10, &NULL, &NULL
    mov D$WindowX eax
    call 'User32.GetDlgItemInt' D$ConfigTabbedDialogHandle, 11, &NULL, &NULL
    mov D$WindowY eax
    call 'User32.GetDlgItemInt' D$ConfigTabbedDialogHandle, 12, &NULL, &NULL
    mov D$WindowW eax
    call 'User32.GetDlgItemInt' D$ConfigTabbedDialogHandle, 13, &NULL, &NULL
    mov D$WindowH eax

    call 'User32.MoveWindow' D$hwnd, D$WindowX, D$WindowY, D$WindowW, D$WindowH, &TRUE

    mov eax D$WindowX | or eax D$WindowY
    ..If eax = 0
        call 'USER32.GetSystemMetrics' &SM_CXSCREEN
        .If eax = D$WindowW
            call 'USER32.GetSystemMetrics' &SM_CYSCREEN
            If eax = D$WindowH
                call 'USER32.ShowWindow' D$hwnd, &SW_MAXIMIZE
            End_if
        .End_If
    ..End_If
ret

____________________________________________________________________________________________

[CustomColorsSet: ? #16]

[CHOOSECOLORAPI:
 CHOOSECOLORAPI_lStructSize: D$ len
 CHOOSECOLORAPI_hwndOwner: D$ 0
 CHOOSECOLORAPI_hInstance: D$ 0
 CHOOSECOLORAPI_rgbResult: D$ 0
 CHOOSECOLORAPI_lpCustColors: D$ CustomColorsSet
 CHOOSECOLORAPI_Flags: D$ &CC_RGBINIT__&CC_FULLOPEN
 CHOOSECOLORAPI_lCustData: D$ 0
 CHOOSECOLORAPI_lpfnHook: D$ 0
 CHOOSECOLORAPI_lpTemplateName: D$ 0]

SetColor:
        move D$CHOOSECOLORAPI_hwndOwner D$ConfigDialogHandle
        move D$CHOOSECOLORAPI_hInstance D$hInstance
        mov D$CHOOSECOLORAPI_rgbResult eax

        push eax                                          ; old color set by caller in eax
            call 'COMDLG32.ChooseColorA' CHOOSECOLORAPI
        pop ebx

        If eax = &FALSE
            mov eax ebx                                   ; restore old color if no choice.
        Else
            mov eax D$CHOOSECOLORAPI_rgbResult
        End_If
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
; Registry jobs:

[hRegKey: 0    Result: 0    Datatype: 0    RegistryDataSize: 4]

[RosAsmConfigClass: B$ 'RosAsmConfigClass', 0
 RosAsmKey:      'Software\RosAsm', 0
 Color1:         'Color1', 0
 Color2:         'Color2', 0
 Color3:         'Color3', 0
 Color4:         'Color4', 0
 Color5:         'Color5', 0
 Color10:        'Color10', 0
 SizeColorFlag:  'SizeMarker Color Flag', 0

 UserLanguage:   'Lang', 0

 Blink:          'Blink', 0
 BlinkTime:      'BlinkTime', 0

 Complete:       'Complete', 0

 PrinterFont:    'PrinterFont', 0
 ScrollBar:      'ScrollBar', 0
 ToolBar:       'ToolBar', 0

 SourceEditorFont: 'SourceEditorFont', 0
 NationalLanguageFont: 'NationalLanguageFont', 0
 UnicodeEditorFont: 'UnicodeEditorFont', 0

 BackUpLimit: 'MaxBackUp', 0

 MainPosX:       'MainPosX', 0
 MainPosY:       'MainPosY', 0
 MainPosW:       'MainPosW', 0
 MainPosH:       'MainPosH', 0

 SaveMainPos:    'SaveMainPos', 0
 IsMaximized:    'IsMaximized', 0

 TreeViewReg:    'TreeViewReg', 0
 TreeViewReg2:   'TreeViewReg2', 0
 TreeViewAutoHide: 'TreeViewAutoHide', 0
 TreeRebuild:    'TreeRebuild', 0
 TreeW:          'Tree Width', 0

 AutoIndentReg:  'AutoIndentReg', 0
 TabReg:         'TabReg', 0
; Font:           'Font', 0
 CtrlYis:        'CtrlYis', 0
 LoadMRUis:      'LoadLastMRU', 0
 BlockAutoDeleteIs: 'BlockAutoDeleteIs', 0
 VirtualLimit:   'VirtualLimit', 0
 WithCtrlA:      'With Ctrl A', 0
 WithSecurity:   'WithSecurity', 0
 WithSounds:      'WithSounds', 0
 WithDollarOnly:  'Dollar only', 0
 WithChecker:     'Write Checker', 0
 ParagrafChar:    'ParagrafChar', 0

 CalcPath:       'CalcPath', 0
 EquatesPath:    'EquatesPath', 0
 F2Path:         'F2Path', 0
 RosAsmHelpPath:  'RosAsmHelpPath', 0
 Asm32HelpPath:  'Asm32HelpPath', 0
 WinApiPath:     'WinApiPath', 0
 AsmHelPath:     'AsmHelPath', 0
 MmediaPath:     'MmediaPath', 0
 OpenGlPath:     'OpenGlPath', 0
 DxPath:         'DxPath', 0
 WinSockPath:    'WinSockPath', 0
 SDLRefPath:     'SDLRefPath', 0
 sqlitePath:     'sqlitePath', 0
 DevILPath:      'DevILPath', 0
 ClipPath:       'ClipPath', 0
 StrucPath:      'StrucPath' 0

 LastUserPath:   'LastUserPath', 0

 UserMenu0:      'UserMenu0', 0
 UserMenu1:      'UserMenu1', 0
 UserMenu2:      'UserMenu2', 0
 UserMenu3:      'UserMenu3', 0
 UserMenu4:      'UserMenu4', 0
 UserMenu5:      'UserMenu5', 0
 UserMenu6:      'UserMenu6', 0
 UserMenu7:      'UserMenu7', 0
 UserMenu8:      'UserMenu8', 0
 UserMenu9:      'UserMenu9', 0
 UserPath0:      'UserMenuPath0', 0
 UserPath1:      'UserMenuPath1', 0
 UserPath2:      'UserMenuPath2', 0
 UserPath3:      'UserMenuPath3', 0
 UserPath4:      'UserMenuPath4', 0
 UserPath5:      'UserMenuPath5', 0
 UserPath6:      'UserMenuPath6', 0
 Userpath7:      'UserMenuPath7', 0
 UserPath8:      'UserMenuPath8', 0
 UserPath9:      'UserMenuPath9', 0

 MRU1Title:      'MRU1', 0
 MRU2Title:      'MRU2', 0
 MRU3Title:      'MRU3', 0
 MRU4Title:      'MRU4', 0
 DBPMenuString:  'DBPMenu', 0
 ApiCheckString: 'ApiCheck', 0
 UserConfigString: 'UserConfig', 0]

[UserMenu0String: ? #8] [UserMenu1String: ? #8] [UserMenu2String: ? #8]
[UserMenu3String: ? #8] [UserMenu4String: ? #8] [UserMenu5String: ? #8]
[UserMenu6String: ? #8] [UserMenu7String: ? #8] [UserMenu8String: ? #8]
[UserMenu9String: ? #8]
;&MAX_PATH = 0104   (0104/4) = 041 = 65
[UserMenu0Path: ? #64] [UserMenu1Path: ? #64] [UserMenu2Path: ? #64] [UserMenu3Path: ? #64]
[UserMenu4Path: ? #64] [UserMenu5Path: ? #64] [UserMenu6Path: ? #64] [UserMenu7Path: ? #64]
[UserMenu8Path: ? #64] [UserMenu9Path: ? #64]

[RegistryData:  Color1          &REG_DWORD  NormalBackColor
              ; NEVER INSERT ANYTHING !!!
                Color2          &REG_DWORD  StatementColor
                Color3          &REG_DWORD  CommentColor
                Color4          &REG_DWORD  TextColor
                Color5          &REG_DWORD  BracketColor
                Color10         &REG_DWORD  DialogsBackColor
                SizeColorFlag   &REG_DWORD  WantSizeMarkerColor
              ; NEVER INSERT ANYTHING !!!
                UserLanguage    &REG_DWORD  StringsLanguage
                NationalLanguageFont &REG_BINARY NATION_LOGFONT
                UnicodeEditorFont &REG_BINARY UNICODE_EDITION_LOGFONT
              ; NEVER INSERT ANYTHING !!!
                Blink           &REG_DWORD  BlinkingCaretWanted
                BlinkTime       &REG_DWORD  CaretTime
              ; NEVER INSERT ANYTHING !!!
                Complete        &REG_DWORD  CompletionWanted
              ; NEVER INSERT ANYTHING !!!
                PrinterFont     &REG_BINARY cbbuffer
                ScrollBar       &REG_DWORD  ScrollBarWanted
                ToolBar         &REG_DWORD  ToolBarWanted
              ; NEVER INSERT ANYTHING !!!
                SourceEditorFont &REG_BINARY EditorLOGFONT
              ; NEVER INSERT ANYTHING !!!
                BackUpLimit     &REG_DWORD  MaxBackUp
              ; NEVER INSERT ANYTHING !!!
                MainPosX        &REG_DWORD  WindowX
                MainPosY        &REG_DWORD  WindowY
                MainPosW        &REG_DWORD  WindowW
                MainPosH        &REG_DWORD  WindowH
              ; NEVER INSERT ANYTHING !!!
                SaveMainPos     &REG_DWORD  SaveMainPosFlag
                IsMaximized     &REG_DWORD  IsMaximizedFlag
              ; NEVER INSERT ANYTHING !!!
                TreeViewReg     &REG_DWORD  ShowOrphan
                TreeViewReg2    &REG_DWORD  ShowLabelsOnce
                TreeViewAutoHide &REG_DWORD AutoHideTreeView
                TreeRebuild     &REG_DWORD  AutoRebuildTreeView
                TreeW           &REG_DWORD  TreeWidth
              ; NEVER INSERT ANYTHING !!!
                AutoIndentReg   &REG_DWORD  AutoIndentFlag
                TabReg          &REG_DWORD  TabIs
               ; Font            &REG_DWORD  UserFont
                CtrlYis         &REG_DWORD  CtrlYflag
                LoadMRUis       &REG_DWORD  LoadMRU
                BlockAutoDeleteIs &REG_DWORD  BlockAutoDelete
                VirtualLimit    &REG_DWORD  NoVirtualLimit
                WithCtrlA       &REG_DWORD  WithControlA
                WithSecurity    &REG_DWORD  SecurityWanted
                WithSounds      &REG_DWORD  SoundsWanted
                WithDollarOnly  &REG_DWORD  DollarOnly
                WithChecker     &REG_DWORD  WriteCheckerWanted
                ParagrafChar    &REG_DWORD  ParagraphChar
              ; NEVER INSERT ANYTHING !!!
                CalcPath        &REG_SZ     CalcName
                EquatesPath     &REG_SZ     EquatesName
              ; NEVER INSERT ANYTHING !!!
                F2Path          &REG_SZ     F2Name
              ; NEVER INSERT ANYTHING !!!
                RosAsmHelpPath   &REG_SZ    B_U_AsmName

              ; NEVER INSERT ANYTHING !!!
                WinApiPath      &REG_SZ     Win32HlpName
              ;  AsmHelPath      &REG_SZ     OpcodeHlpName
                MmediaPath      &REG_SZ     MmediaHlpName
                OpenGlPath      &REG_SZ     OpenGlHlpName
                DxPath          &REG_SZ     DxHlpName
                WinSockPath     &REG_SZ     WinsockHlpName
                SDLRefPath      &REG_SZ     SDLRefName
                sqlitePath      &REG_SZ     sqliteName
                DevILPath       &REG_SZ     DevILName
                ClipPath        &REG_SZ     ClipName
              ; NEVER INSERT ANYTHING !!!
                UserMenu0       &REG_SZ     UserMenu0String
                UserMenu1       &REG_SZ     UserMenu1String
                UserMenu2       &REG_SZ     UserMenu2String
                UserMenu3       &REG_SZ     UserMenu3String
                UserMenu4       &REG_SZ     UserMenu4String
                UserMenu5       &REG_SZ     UserMenu5String
                UserMenu6       &REG_SZ     UserMenu6String
                UserMenu7       &REG_SZ     UserMenu7String
                UserMenu8       &REG_SZ     UserMenu8String
                UserMenu9       &REG_SZ     UserMenu9String
                UserPath0       &REG_SZ     UserMenu0Path
                UserPath1       &REG_SZ     UserMenu1Path
                UserPath2       &REG_SZ     UserMenu2Path
                UserPath3       &REG_SZ     UserMenu3Path
                UserPath4       &REG_SZ     UserMenu4Path
                UserPath5       &REG_SZ     UserMenu5Path
                UserPath6       &REG_SZ     UserMenu6Path
                UserPath7       &REG_SZ     UserMenu7Path
                UserPath8       &REG_SZ     UserMenu8Path
                UserPath9       &REG_SZ     UserMenu9Path
              ; NEVER INSERT ANYTHING !!!
                MRU1Title       &REG_SZ     MRU1
                MRU2Title       &REG_SZ     MRU2
                MRU3Title       &REG_SZ     MRU3
                MRU4Title       &REG_SZ     MRU4
              ; NEVER INSERT ANYTHING !!!
                DBPMenuString   &REG_DWORD  DBPMenuOn
              ; NEVER INSERT ANYTHING !!!
                ApiCheckString  &REG_DWORD  ApiCheckFlag

              ; ALWAYS ADD AT THE END !!!!!!!!!!!!!!!!!!!!

                0]

OpenRegistry:
    call 'ADVAPI32.RegCreateKeyExA' &HKEY_CURRENT_USER, RosAsmKey, 0,
                                    RosAsmConfigClass, 0,
                                    &KEY_READ__&KEY_WRITE__&KEY_QUERY_VALUE,
                                    0, hRegKey, Result
ret


ReadRegistry:
    mov esi RegistryData

    ...If D$Result = &REG_CREATED_NEW_KEY
      ; Case of new installation of the Registry:
L1:     push esi
            call GetFieldDataSize esi
            call 'ADVAPI32.RegSetValueExA' D$hRegKey, D$esi, 0, D$esi+4, D$esi+8, eax
        pop esi
        On eax <> &ERROR_SUCCESS, jmp AutoInit
        add esi 12 | cmp D$esi 0 | ja L1<<

        call AutoInit

    ...Else
      ; Case of existing Registry to be read:
L1:     push esi
            lea ebx D$esi+4 | mov D$RegistryDataSize 0FF
            call 'ADVAPI32.RegQueryValueExA' D$hRegKey, D$esi, 0, ebx, D$esi+8,
                                             RegistryDataSize
            .If eax <> &ERROR_SUCCESS
                pop esi | push esi
                call GetFieldDataSize esi
                call 'ADVAPI32.RegSetValueExA' D$hRegKey, D$esi, 0, D$esi+4, D$esi+8, eax
            .End_If
        pop esi
        add esi 12 | cmp D$esi 0 | ja L1<<
    ...End_If

    call CloseRegistry
ret


UpdateRegistry:
    On D$UserConfig = CONFIGFILE, jmp WriteConfigFile

    call OpenRegistry

    mov esi RegistryData
  ; either &REG_BINARY // &REG_DWORD // &REG_SZ
L1: push esi
        call GetFieldDataSize esi
        call 'ADVAPI32.RegSetValueExA' D$hRegKey, D$esi, 0, D$esi+4, D$esi+8, eax
    pop esi
    add esi 12 | cmp D$esi 0 | ja L1<<

    call CloseRegistry
ret


Proc GetFieldDataSize:
    Argument @Pointer
    Uses esi

        mov esi D@Pointer
      ; esi >>> One Key in 'RegistryData': PointerToName // &FLAG // RosAsmData
      ; &FLAG can be: &REG_BINARY // &REG_DWORD // &REG_SZ
        If D$esi+4 = &REG_DWORD
            mov eax 4
      ; cases of Fonts LOGFONT Structures:
        Else_If D$esi = PrinterFont
          ; Static size of cbbuffer (&REG_BINARY):
            mov eax 60
        Else_If D$esi = SourceEditorFont
            mov eax D$EditorLOGFONT.len
        Else_If D$esi = NationalLanguageFont
            mov eax D$NATION_LOGFONTlen
        Else_If D$esi = UnicodeEditorFont
            move eax D$UNICODE_EDITION_LOGFONTlen
      ; Cases of Strings (&REG_SZ):
        Else
            push edi
                mov edi D$esi+8, ecx 0FFFF, al 0 | repne scasb
                sub ecx 0FFFF | neg ecx | mov eax ecx
            pop edi
        End_If
      ; eax = Size of the Data to be saved into the Registry Key:
EndP


CloseRegistry:
    call 'ADVAPI32.RegCloseKey' D$hRegKey
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  Auto initialize the companion Files registries if this is a first install done
  after unzipping the whole Package.
;;


AutoInit:  ; 'RegistryData'
    call GetDirectory ActualDir

    mov edi ActualDir | While B$edi <> 0 | inc edi | End_While

    On B$edi-1 <> '\', mov B$edi '\' | inc edi
  ; ...\RosAsmFiles\
    mov D$edi 'RosA', D$edi+4 'smFi', D$edi+8 'les\' | add edi 12
    mov D$ActualDirPointer edi

  ; 'Equates.inc'
    mov D$edi 'Equa', D$edi+4 'tes.', D$edi+8 'equ'
    call 'KERNEL32.FindFirstFileA' ActualDir, WIN32_FIND_DATA

    .If eax <> &INVALID_HANDLE_VALUE
        call 'KERNEL32.FindClose' eax
        mov esi ActualDir, edi EquatesName
        While B$esi <> 0 | movsb | End_While | mov B$edi 0

      ; 'B_U_Asm.exe'
        mov edi D$ActualDirPointer
        mov D$edi 'B_U_', D$edi+4 'Asm.', D$edi+8 'exe', B$edi+12 0
        call 'KERNEL32.FindFirstFileA' ActualDir, WIN32_FIND_DATA

        If eax <> &INVALID_HANDLE_VALUE
            call 'KERNEL32.FindClose' eax
            mov esi ActualDir, edi B_U_AsmName
            While B$esi <> 0 | movsb | End_While | mov B$edi 0
        End_If

      ; 'Clip.txt
        mov edi D$ActualDirPointer
        mov D$edi 'Clip', D$edi+4 '.txt', B$edi+8 0
        call 'KERNEL32.FindFirstFileA' ActualDir, WIN32_FIND_DATA
        If eax <> &INVALID_HANDLE_VALUE
            call 'KERNEL32.FindClose' eax
            mov esi ActualDir, edi ClipName
            While B$esi <> 0 | movsb | End_While | mov B$edi 0
        End_If

    .End_If
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; add a User Menu if any.

[UserPopUpHandle: 0    UserPopMenu: 'User', 0]

[MENUITEMINFO:
 @cbSize: D$ len
 @fMask: D$ 0
 @fType: D$ &MFT_STRING
 @fState: D$ 0
 @wID: D$ 0
 @hSubMenu: D$ 0
 @hbmpChecked: D$ 0
 @hbmpUnchecked: D$ 0
 @dwItemData: D$ 0
 @dwTypeData: D$ 0
 @cch: D$ 0]


AddUserMenu:
    On B$UserMenu0Path = 0, jmp L9>>
    On B$UserMenu0String = 0, jmp L9>>

    call 'USER32.CreatePopupMenu' | mov D$UserPopUpHandle eax
    call 'USER32.AppendMenuA' D$UserPopUpHandle &MF_STRING 2000 UserMenu0String

    On B$UserMenu1Path = 0, jmp L8>>
    On B$UserMenu1String = 0, jmp L8>>
        call 'USER32.AppendMenuA' D$UserPopUpHandle &MF_STRING 2001 UserMenu1String
    On B$UserMenu2Path = 0, jmp L8>>
    On B$UserMenu2String = 0, jmp L8>>
        call 'USER32.AppendMenuA' D$UserPopUpHandle &MF_STRING 2002 UserMenu2String
    On B$UserMenu3Path = 0, jmp L8>>
    On B$UserMenu3String = 0, jmp L8>>
        call 'USER32.AppendMenuA' D$UserPopUpHandle &MF_STRING 2003 UserMenu3String
    On B$UserMenu4Path = 0, jmp L8>>
    On B$UserMenu4String = 0, jmp L8>>
        call 'USER32.AppendMenuA' D$UserPopUpHandle &MF_STRING 2004 UserMenu4String
    On B$UserMenu5Path = 0, jmp L8>>
    On B$UserMenu5String = 0, jmp L8>>
        call 'USER32.AppendMenuA' D$UserPopUpHandle &MF_STRING 2005 UserMenu5String
    On B$UserMenu6Path = 0, jmp L8>>
    On B$UserMenu6String = 0, jmp L8>>
        call 'USER32.AppendMenuA' D$UserPopUpHandle &MF_STRING 2006 UserMenu6String
    On B$UserMenu7Path = 0, jmp L8>>
    On B$UserMenu7String = 0, jmp L8>>
        call 'USER32.AppendMenuA' D$UserPopUpHandle &MF_STRING 2007 UserMenu7String
    On B$UserMenu8Path = 0, jmp L8>>
    On B$UserMenu8String = 0, jmp L8>>
        call 'USER32.AppendMenuA' D$UserPopUpHandle &MF_STRING 2008 UserMenu8String
    On B$UserMenu9Path = 0, jmp L8>>
    On B$UserMenu9String = 0, jmp L8>>
        call 'USER32.AppendMenuA' D$UserPopUpHandle &MF_STRING 2009 UserMenu9String

 L8: call 'USER32.InsertMenuA' D$MenuHandle 7 &MF_BYPOSITION__&MF_STRING__&MF_POPUP,
                              D$UserPopUpHandle  UserPopMenu

L9: ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; Using a Config File instead of the Registry. Implemented by Eric, October the 19th of 2006

[ConfigBinaryName: B$ 'config.bin' 0]
[ConfigFileHandle: D$ 0 ConfigSizeReadWrite: 0]
[ConfigDataSize: D$ 0 ]
[ConfigFilePath: B$ 0 #&MAX_PATH]

SetMainConfigFilePath:
    push esi
        call 'KERNEL32.GetCurrentDirectoryA' &MAX_PATH, ConfigFilePath

        mov edi ConfigFilePath, eax 0, ecx 0-1
        repne scasb | dec edi

        On B$edi-1 <> '\', mov B$edi '\' | inc edi

        mov esi ConfigBinaryName, ecx 13
        rep movsb
    pop esi
ret


WriteConfigFile:
    push esi, edi

    call 'KERNEL32.CreateFileA' ConfigFilePath, &GENERIC_READ+&GENERIC_WRITE,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, &NULL,
                                &CREATE_ALWAYS, &FILE_ATTRIBUTE_ARCHIVE, &NULL
    mov D$ConfigFileHandle eax

    mov esi RegistryData
L1:
    push esi
        call GetFieldDataSize esi
        mov D$ConfigDataSize eax
        call 'KERNEL32.WriteFile' D$ConfigFileHandle, ConfigDataSize, 4,
                                  ConfigSizeReadWrite, &NULL
        call 'KERNEL32.WriteFile' D$ConfigFileHandle, D$esi+8, D$ConfigDataSize,
                                  ConfigSizeReadWrite, &NULL
    pop esi
    add esi 12 | cmp D$esi 0 | ja L1<

    call 'KERNEL32.CloseHandle' D$ConfigFileHandle

    pop edi, esi
ret


ReadConfigFile:
    push esi

    call SetMainConfigFilePath

    call 'KERNEL32.CreateFileA' ConfigFilePath, &GENERIC_READ+&GENERIC_WRITE,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE,
                                &NULL &OPEN_EXISTING, &FILE_ATTRIBUTE_ARCHIVE &NULL
    mov D$ConfigFileHandle eax

    mov esi RegistryData
L1:
    push esi
        ; The config is  structured like: [dword: sizeof data][data]
        ; So get the first dword and store it in >ConfigDataSize< :
        call 'KERNEL32.ReadFile' D$ConfigFileHandle, ConfigDataSize, 4,
                                 ConfigSizeReadWrite, &NULL
        ; Read the block of data the sizeof >ConfigDataSize< and copy into
        ; RegistryData:
        call 'KERNEL32.ReadFile' D$ConfigFileHandle, D$esi+8, D$ConfigDataSize,
                                 ConfigSizeReadWrite, &NULL
    pop esi
    add esi 12 | cmp D$esi 0 | ja L1<

    call 'KERNEL32.CloseHandle' D$ConfigFileHandle
    pop esi
ret
____________________________________________________________________________________________

;;
  When the Config.bin file is being used on an USB Memory Stick, if the user moves from
  Computer to computer, the Drive may be different, and force to re-initialize if the
  Drive Char is different.
  
  To avoid this problem, we give a try to substitute, with the actual one.
  
  'RegistryData'
;;

CheckPaths:
    mov al B$ConfigFilePath, bl B$EquatesName

    .If al <> bl
        If D$EquatesName <> 'Equa'
            mov B$EquatesName al
        End_If

        If D$B_U_AsmName <> 'B_U_'
            mov B$B_U_AsmName al
        End_If

        ;If D$CalcName <> 'Calc'
        ;    On B$CalcName <> 0, mov B$CalcName al
        ;End_If

        ;On B$F2Name <> 0, mov B$F2Name al

        ;If D$Win32HlpName <> 'Win3'
        ;    mov B$Win32HlpName al
        ;End_If

    .End_If
ret
____________________________________________________________________________________________


[WineDebugKey: 'Software\Windows NT\CurrentVersion\AeDebug', 0]
[WineDbg: 'winedbg %ld %ld', 0]
[WineDbgString: 'Debugger', 0]

WineKey:
    call 'ADVAPI32.RegCreateKeyExA' &HKEY_LOCAL_MACHINE, WineDebugKey, 0,
                                    0, 0,
                                    &KEY_READ__&KEY_WRITE__&KEY_QUERY_VALUE,
                                    0, hRegKey, Result

    call 'ADVAPI32.RegSetValueExA' D$hRegKey, WineDbgString, 0, &REG_SZ, WineDbg, 15
ret
____________________________________________________________________________________________

; Regedit.exe: HKEY_CURRENT_USER / Software / RosAsm

WhateverConfig:  ; 'Main'
    call SetMainConfigFilePath

    call 'KERNEL32.FindFirstFileA' ConfigFilePath, FindFile
    push eax
        call 'KERNEL32.FindClose' eax
    pop eax

    ..If eax = &INVALID_HANDLE_VALUE
        call OpenRegistry

        .If D$Result = &REG_CREATED_NEW_KEY
         ; Tag Dialog 3
            call 'USER32.DialogBoxParamA' D$hinstance, 3, &NULL,
                                           ConfigProc, &NULL
            If D$UserConfig = 0FF
                call CloseRegistry
                call 'ADVAPI32.RegDeleteKeyA' &HKEY_CURRENT_USER, RosAsmKey
                call 'KERNEL32.ExitProcess', 0

            Else_If D$UserConfig = REGISTRY
              ; "Read" assumes create when none:
                call ReadRegistry
                mov D$UserConfig REGISTRY

            Else
                call CloseRegistry
                call 'ADVAPI32.RegDeleteKeyA' &HKEY_CURRENT_USER, RosAsmKey
                mov D$UserConfig CONFIGFILE
                call AutoInit
                call WriteConfigFile

            End_If

        .Else
            call ReadRegistry
            mov D$UserConfig REGISTRY

        .End_If

    ..Else
        call ReadConfigFile
        call CheckPaths
        mov D$UserConfig CONFIGFILE

    ..End_If
ret

[ConfigMessage: "You can choose to save your Configuration either as a Registry Key, or under the form of a File: config.bin

You should choose the first option for regular work on your home computer.

The second option may be of interrest, for example, when working from an USB memory stick.

If you choose the second option, when doing a Copy of RosAsm to another Folder, you will have to also copy your 'config.bin' aside", 0]

[UserConfig: ?]

[REGISTRY 1, CONFIGFILE 2]
____________________________________________________________________________________________

; Tag Dialog 3

Proc ConfigProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ..If D@Message = &WM_COMMAND
        and D@wParam 0FFFF

        .If D@wParam = &IDCANCEL
            mov D$UserConfig 0FF
            call 'User32.EndDialog' D@Adressee, 0

        .Else_If D@wParam = &IDOK
            call 'USER32.SendDlgItemMessageA' D@Adressee, 20, &BM_GETCHECK, 0, 0
            If eax = &TRUE
                mov D$UserConfig REGISTRY
            Else
                mov D$UserConfig CONFIGFILE
            End_If

            call 'User32.EndDialog' D@Adressee, 0
        .End_If

    ..Else_If D@Message = &WM_INITDIALOG
        move D$ShowApiDialogHandle D@Adressee
        call 'USER32.SetClassLongA' D@Adressee, &GCL_HICON, D$wc_hIcon

        call 'User32.SetDlgItemTextA' D@Adressee, 10, ConfigMessage

        call 'USER32.SendDlgItemMessageA' D@Adressee, 20, &BM_SETCHECK, 1, 0

    ..Else_If D@Message = &WM_CTLCOLOREDIT
        If B$FirstCTLCOLOREDIT = &TRUE
            call 'USER32.SendMessageA' D@lParam, &EM_SETSEL, 0, 0
            mov B$FirstCTLCOLOREDIT &FALSE
        End_If
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    ..Else
        popad | mov eax &FALSE | jmp L9>

    ..End_If

    popad | mov eax &TRUE

L9: EndP
EndP

____________________________________________________________________________________________

Create_Config_bin:
    call 'USER32.MessageBoxA' 0, Config.Bin_Message, Config.Bin_Title, &MB_YESNO

    If eax = &IDYES
        call SetMainConfigFilePath
        call WriteConfigFile
    End_If
ret

[Config.Bin_Message:
"Do you want to create a 'config.bin' file in the current
Directory?

When a 'config.bin' is found aside RosAsm, this file is
used, instead of the Registry.

If you mean, later to recover the Registry functionalities,    
you will just have to delete this file", 0

Config.Bin_Title: 'Configuration File', 0]
____________________________________________________________________________________________















TITLE Click
 _______________________________________________________________________________________
 _______________________________________________________________________________________
;;
 Search feature by right-clicking on text: We search for main Labels, macros or
 equates declarations, data declarations. This is to say that, if we are inside
 square brackets, any fitting first word, or odd word, or ':' ended word is good;
 if outside, only ':' ended words.
;;

[InsideText: ?  RCstart: ?  RCend: ?  DataDeclaration: ?    MacroDeclaration: ?]

[OldEditData: ? #21] [PreviousSearch: ? #32]
[OneWordChars: B$ '0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.' 0
 OneWordCharsLen: D$ len   Edge: B$ 0   OddWord: 0   BackAnyWhere: &TRUE]

; WordEdge looks if a char is or not inside OneWordChars and tells if word edge or not.
; we preserve the flags because direction flag may be set on or off by caller:

WordEdge:
    pushfd | cld
        push ecx, esi, edi
            mov ecx D$OneWordCharsLen, edi OneWordChars, B$Edge &TRUE
            repne scasb | jne L9>
                mov B$Edge &FALSE
L9:     pop edi, esi, ecx
    popfd
ret


[ShowEquateTitle: 'Win Equate Value', 0]

[ShowEquateHexa: ? #40]

ShowEquate:
     mov ebx, eax

     mov edi ShowEquateHexa, esi TrashString
     While B$esi <> 0
        movsb
     End_While
     mov eax '   =' | stosd | mov eax '    ', ecx 3 | rep stosd

     push edi, ebx
         std
            mov ecx, 9
L1:         If ecx = 5
                mov al '_' | stosb
            End_If
            If ecx = 1
                mov al '_' | stosb
            End_If
            mov al bl | and al 0F | add al, '0' |  On al > '9', add al 7
            stosb | shr ebx, 4 | loop L1<
         cld
     pop ebx, edi
     inc edi

     mov D$edi '_h  ', D$edi+4 '  [' | add edi 7

     mov eax ebx | call WriteEaxDecimal

     mov D$edi ']   ', B$edi+4 0

     call 'USER32.MessageBoxA' D$hwnd, ShowEquateHexa, ShowEquateTitle, &MB_SYSTEMMODAL
ret

;;
 I suppress OdWord testing for Equates pointing because it is much difficult work for
 NOP: Usually Equates are defined BEFORE they are used. A wrong pointing could only
 append if user define some Equate AFTER reusing it in Equates definitions (???!!!).
 Good for him!
;;

[PossibleWinApi: B$ ?   PossibleOpCode: ?   LocalSymbol: ?] [NumberDashLines: ?]

RightClick: ; 'InternSearch'
    mov B$ShiftBlockInside &FALSE

    push D$BlockInside
        call LeftButtonSimulation | call LeftButtonUp
        mov eax D$CurrentWritingPos
    pop D$BlockInside

    ..If B$BlockInside = &TRUE
       .If eax >= D$BlockStartTextPtr
            If eax <= D$BlockEndTextPtr
               jmp RightClickOnBlock
            End_If
       .End_If
    ..End_If

    call LeftButtonSimulation | call LeftButtonUp | call AskForRedraw

  ; Save all 'EditData's
    mov esi EditData, edi OldEditData, ecx 21 | rep movsd

    mov esi D$CurrentWritingPos

  ; Special Selections cases when Clicking exactely on '"' or '[':
    If B$esi = '"'
        call SelectDoubleQuotedText | ret
    Else_If B$esi = '['
        call SelectDataBlock | ret
    End_If

  ; Is it a Right-Click on 'blank' area for simply routing back?
  ; Or on a DashLine >>> do nothing.
    mov al B$esi
    If B$esi = '_'
        On B$esi+1 = '_', ret
        On B$esi-1 = '_', ret
    End_If

    call WordEdge

    .If B$Edge <> &FALSE
        If B$esi <= ' '
            jmp BlankRightClick
        Else_If B$esi = '&'
          ; '&' not considered in the WordEdge Routine, but valid here for Win32 Equates
        Else
          ; Abort on alien Char that could be found, for example, in Strings:
            ret
        End_If
    .End_If

    mov B$PossibleWinApi &FALSE

; Reused by 'SearchFromTreeListBox' and the Debugger 'DataView_ShowDeclaration':
InternalRightClick: ; 'InternSearch'
    mov B$InsideMLC &FALSE, B$InsideComment &FALSE

  ; Go to start of Clicked word:
    std
L0:     lodsb | call WordEdge | cmp B$Edge &TRUE | jne L0<
    cld
    inc esi

  ; Special case for Numbers:
    ..If B$esi+1 >= '0'
        .If B$esi+1 <= '9'
            call RightClickedNumber | ret
        .End_If
    ..End_If

  ; Special case of Tag Comment:
    mov eax D$esi+1 | or eax 020202020
    If eax = 'tag '
        call IsItTag | On eax = &TRUE, jmp TagParser
    End_If

  ; To differenciate for example a Click on 'mov' (if 'mov' is a Macro) from '[mov | ...':
    push esi
        While B$esi = ' ' | dec esi | End_While
        mov B$PossibleOpCode &FALSE
        On B$esi = '[', mov B$PossibleOpCode &TRUE
    pop esi

    inc esi

  ; Special case for OS Equates, plus, take care of Strings Delimiters for Api calls:
    If B$esi-1 = '&'
        push esi
            call NewGetEquates | mov edx esi
        pop esi
        On B$EquateFound = &TRUE, call ShowEquate
        ret
    Else_If B$esi-1 = "'"
        mov B$PossibleWinApi &TRUE
    Else_If B$esi-1 = "'"
        mov B$PossibleWinApi &TRUE
    End_If

  ; First Char, Low Case into ah:
    mov ah B$esi | or ah 32

  ; edx > second char (> edi)
    inc esi | mov ebx 0, edx esi

  ; Search for end of Clicked word:
L0: lodsb | inc ebx | call WordEdge | cmp B$Edge &TRUE | jne L0<
    sub ebx 1 | jc L9>>             ; ebx = length-1
        cmp ebx 0 | je L9>>
    cmp ebx 1 | ja L0>              ; Abort if local label
    cmp B$esi-2 '9' | ja L0>
        ret

  ; Now, edi (edx) > start+1 of right clicked word; ebx = lenght-1. Search maching Symbol:
L0: mov esi D$CodeSource, ecx D$SourceLen, B$InsideBracket &FALSE, B$InsideComment &FALSE
;;
  Clean up, in actual Style to be continued from here, when i will have time.
  Old Routines yet here at 'OldRightClick', 'OldInternalRightClick'.
;;
    jmp L0>

T0: lodsb | jmp L1>                         ; simplified loop for strip texts and comments
T1: loop T0<
    On B$InsideMLC = &TRUE, jmp C0>         ; Because unpaired MLC are allowed
      ret

L0: lodsb | cmp al ah | je L3>>             ; test XORed AH each pass in order to handle
            xor ah 32 | cmp al ah | je L3>> ; case without modifying AL (following tests)
        jmp L1>
L2: loop L0<

C0:     .If B$PossibleWinApi = &TRUE
            call WinApiFirstPass ; SearchWinApi
        .Else
            mov B$MnemonicHelpFound &FALSE
            call SearchMneMonic             ; Nothing found > it it a Mnemonic?
            If B$MnemonicHelpFound = &FALSE
                On ebx < 3, call SearchForReg
            End_If
        .End_If
        ret

L1: cmp B$InsideMLC &TRUE | jne L1>
      cmp D$esi-2 MLC | jne T1<
        mov B$InsideMLC &FALSE | jmp L2<
L1: cmp B$InsideComment &TRUE | jne L1>
      cmp al LF  | jne T1<<
        mov B$InsideComment &FALSE | jmp L2<
L1: cmp B$InsideText &FALSE | je L1>
      cmp al B$InsideText | jne T1<<
        mov B$InsideText &FALSE | jmp L2<<
L1: cmp al "'" | jne L1>
      mov B$InsideText al | jmp T1<<
L1: cmp al '"' | jne L1>
      mov B$InsideText al | jmp T1<<
L1: cmp al '[' | jne L1>
        call ScaningBracket

S0:   cmp B$esi ' ' | jne L2<<
        inc esi | sub ecx 1 | jnc S0<        ; strip double spaces
          ret

L1: cmp al ']' | jne L1>
      mov B$InsideBracket &FALSE, B$DataDeclaration &FALSE, B$MacroDeclaration &FALSE
      jmp L2<<

L1: cmp al ';' | jne L1>                     ; jmp over comments
        If D$esi-2 = MLC   ; (LF ; ; CR)
            mov B$InsideMLC &TRUE | jmp T1<<
        Else
            mov B$InsideComment &TRUE | jmp T1<<
        End_If

L1: cmp al '|' | jne L1>
      mov B$InsideBracket &FALSE | jmp L2<<
L1: cmp al ':' | jne L2<<
      mov B$DataDeclaration &TRUE

            jmp L2<<                         ; (avoids pointing equates datas).

L3: mov al B$esi-2 | call WordEdge | cmp B$Edge &FALSE | je L2<<     ; left edge?

        mov D$NumberDashLines 0

        pushad | mov ecx ebx, edi edx

C0:       lodsb | mov ah B$edi | inc edi

          ; case insensitive comparison:
            If al >= 'A'
                On al <= 'Z', or al 020
            End_If

            If ah >= 'A'
                On ah <= 'Z', or ah 020
            End_If

          ; Edi is pointing to the clicked Word. Esi ---> Parsed Source:

            .If B$edi-1 <> '_'
                While B$esi-1 = '_'
                    lodsb
                    If al >= 'A'
                        On al <= 'Z', or al 020
                    End_If
                    inc D$NumberDashLines | dec ecx | jz X1>
                End_While
            .End_If

            .If B$esi-1 <> '_'
                While B$edi-1 = '_'
                    mov ah B$edi | inc edi
                    If ah >= 'A'
                        On ah <= 'Z', or ah 020
                    End_If
                    dec D$NumberDashLines | dec ecx | jz X1>
                End_While
            .End_If

            cmp ah al | jne C1>
            loop C0<

X1:         mov al B$esi | call WordEdge
            If B$Edge = &FALSE
                popad | jmp L2<<
            End_If

            popad | jmp C2>

C1:     popad | jne L2<<

   ; mov al B$esi+ebx | call WordEdge | cmp B$Edge &FALSE | je L2<<    ; right edge?

C2: If B$MacroDeclaration = &TRUE
      ; Was it first word?
        cmp esi D$MacroNamePointer | jne L2<<
    End_If

    push ebx
        add ebx D$NumberDashLines
        cmp B$esi+ebx ':'
    pop ebx
    je L4>                                 ; Label?

; as we have tested for '|' (> InsideBracket = FALSE), "test B$OddWord 1" applies either
; uppon first word of macro def. or odd word of equate def. But data body could still
; be pointed as odd equate dec. So we finally test 'B$DataDeclaration'.

      cmp B$InsideBracket &TRUE | jne L2<<                     ; equ. / macro
          cmp B$DataDeclaration &TRUE | je L2<<  ; avoid pointing data body instead of Equate
              If B$MacroDeclaration = &FALSE
                call PairedEquate | On B$ValidEquateOrMacro = &FALSE, jmp L2<<
              End_If

L4: dec esi                                                    ; found
    mov D$BlockStartTextPtr esi, D$RCstart esi                 ; RCstart/End used by
    add esi ebx | mov D$BlockEndTextPtr esi, D$RCend esi       ; 'BackClick'
    mov B$BlockInside &TRUE
    inc esi | mov D$CurrentWritingPos esi

    std | mov ecx 0
L5:     lodsb | inc ecx
        cmp al LF | jne L5<                    ; search for start of line
        cld | ;dec ecx

    call StorePosInBackTable

    add esi 2 | mov D$UpperLine esi                            ; and set all needed
    call UpOneLine | call UpOneLine | call UpOneLine           ; variables for Pos, in

  ; Would be a good thing... but doesn't work. The Block seems cleared by 'TryToMove'
  ; when it can't move any more upward... complicated... later...

  ;  call UpOneLine | call UpOneLine | call UpOneLine
  ;  call UpOneLine | call UpOneLine | call UpOneLine

    mov D$CaretLine 3, D$CaretRow ecx, D$PhysicalCaretRow ecx  ; case user wish editing
    call TryToMove
    mov D$RightScroll 0 | call AskForRedraw

    If B$PossibleOpCode = &TRUE
        mov esi D$BlockStartTextPtr, ah B$esi, edx esi, ebx D$BlockEndTextPtr
        or ah 32 | inc edx | sub ebx esi
        call SearchMneMonic
    End_If

L9: ret


SearchForReg:
    pushad
        dec edx | mov esi edx, edi MnemonicCopy, ecx ebx | inc ecx
L0:     lodsb | On al > 'Z', and eax (not 020) | stosb | loop L0<
        mov B$edi 0
        mov esi MnemonicCopy
        Call IsItaReg
        On eax <> 0, call Help B_U_AsmName, {'Registers', 0}, ContextHlpMessage
    popad
ret
____________________________________________________________________________________________

[ValidEquateOrMacro: ?]
;;
[LowSigns            31
    TextSign            30
;;

;;
  'PairedEquate' job is to make sure, for the Right-Click feature, that, the pointed
  word is really an Equate Declaration, and not an Evocation.
;;

PairedEquate:
  ; esi points to the Second Char of the pointed word.
    pushad
    push D$CodeSourceA, D$CodeSourceB
        While B$esi >= '0' | inc esi | End_While
        mov ecx 2

L0:     While B$esi <> '[' | dec esi | inc ecx | End_While

      ; Case of '[' in Text or Comments:
        If esi > D$MacroNamePointer
            dec esi | inc ecx | jmp L0<
        End_If

        mov edi Trash1, D$StripLen ecx | rep movsb | mov D$edi CRLF2

        move D$CodeSourceA Trash1, D$CodeSourceB Trash2

      ; CoolParsers
        call KillMultiLineComments
        call NewKillVirtualCRLF
        call KillMeaninglessCommas

      ; HotParsers
        call StripUnderscore
        call TranslateAsciiToMyAscii
        call StripUnneededSpaces
        call ConvertCommasToSpace

        mov esi D$CodeSourceA, edx D$StripLen | add edx esi

        While esi < edx
            If B$esi < Separators
                mov B$esi Space
            End_If
            inc esi
        End_While

        call StripUnneededSpaces

        mov esi D$CodeSourceA, edx D$StripLen | add edx esi | dec edx
        mov D$ValidEquateOrMacro &FALSE

      ; Don't know why, but it seems that when stripping un-needed Spaces,
      ; the last one might be lost. Probably when followed by EOI:
        On B$edx <> Space, mov B$edx Space

        While esi < edx
            inc esi | On B$esi = Space, xor D$ValidEquateOrMacro &TRUE
            On B$esi = Space, inc eax
        End_While
    pop D$CodeSourceB, D$CodeSourceA
    popad
ret



BlankRightClick:    On B$BackAnyWhere = &TRUE, call BackClick | ret


[MacroNamePointer: ?]

ScaningBracket:
    mov B$InsideBracket &TRUE, B$DataDeclaration &FALSE, B$MacroDeclaration &FALSE

  ; Verify that this is not an Alternate Syntax Instruction:
    push eax
        mov al B$esi-2 | or al 020
        If al = 'd'
L0:         pop eax
            While B$esi > LF | inc esi | End_While
            ret
        Else_If al = 'r'
            jmp L0<
        End_If
    pop eax

    push esi

      ; Go to first word and keep pointer as required for final test (+1):
        While B$esi = ' ' | inc esi | End_While
        mov D$MacroNamePointer esi | inc D$MacroNamePointer

      ; Skip first word:
        While B$esi > ' '
            inc esi
            If B$esi = '|'
                mov B$MacroDeclaration &TRUE | jmp L9>
            End_If
        End_While

      ; What last Char in first word:
        If B$esi-1 = ':'
            mov B$DataDeclaration &TRUE | jmp L9>
        Else_If B$esi-1 = '|'
            mov B$MacroDeclaration &TRUE | jmp L9>
        End_If

      ; What is next non space Char:
        While B$esi = ' ' | inc esi | End_While | lodsb

        If al = '|'
            mov B$MacroDeclaration &TRUE
        Else_If al = CR
            mov B$MacroDeclaration &TRUE
        Else_If al = ';'
            mov B$MacroDeclaration &TRUE
        End_If
L9: pop esi
ret

____________________________________________________________________________________________

SelectDoubleQuotedText:
    mov D$BlockStartTextPtr esi | inc D$BlockStartTextPtr

    mov B$TextGoingOn &FALSE | lodsb | call IsItFirstText

L1: lodsb | On esi >= D$SourceEnd, ret
            call IsItFirstText | je L1<

    sub esi 2
    mov D$BlockEndTextPtr esi, B$BlockInside &TRUE
    call AskForRedraw
ret


SelectDataBlock:
    inc esi | mov D$BlockStartTextPtr esi, B$TextGoingOn &FALSE
    .While B$esi <> ']'

        .If B$esi = ';'
            If D$esi-2 = MLC   ; (LF ; ; CR)
                Do
                    inc esi | On esi >= D$SourceEnd, ret
                Loop_Until D$esi-2 = MLC
            Else
                While B$esi <> LF
                    inc esi
                End_While
            End_If
        .End_If

L1:     lodsb | On esi >= D$SourceEnd, ret
                call IsItFirsttext | je L1<
    .End_While

L9: dec esi
    mov D$BlockEndTextPtr esi, B$BlockInside &TRUE
    call AskForRedraw
ret

____________________________________________________________________________

; User selected a Block of text and then RightClick uppon it:

[FloatHandle: 0
 Float_Copy_String: B$ 'Copy', 0
 Float_Delete_String: 'Delete', 0
 Float_Replace_String: 'Replace', 0

 Float_SearchFromTop_String: 'Search from Top', 0
 Float_SearchUp_String: 'Search Up', 0
 Float_SearchDown_String: 'Search Down', 0

 Float_Unfold_String: 'Unfold', 0         Float_BookMark_String: 'BookMark', 0
 Float_UnBookMark_String: 'UnBookMark', 0 Float_Number_String: 'Number forms', 0
 Float_SelReplace_String: 'Replace in Selection', 0
 Float_BadDisLabel_String: 'Bad Disassembly', 0
 Float_Turn_Code_String: 'This should have been Code', 0]


[Float_Copy 5500    Float_SearchFromTop 5501    Float_SearchUp 5502    Float_SearchDown 5503
 Float_Unfold 5504  Float_BookMark 5505         Float_UnBookMark 5506  Float_Number 5507
 Float_ReArange 5508 Float_SelReplace 5509         Float_Delete 5510      Float_Replace 5511
 Float_BadDisLabel 5512]

RightClickOnBlock:
    call 'USER32.CreatePopupMenu' | mov D$FloatHandle eax
    call 'USER32.AppendMenuA' D$FloatHandle &MF_STRING, Float_Copy, Float_Copy_String
    call 'USER32.AppendMenuA' D$FloatHandle &MF_STRING, Float_Delete, Float_Delete_String
    call 'USER32.AppendMenuA' D$FloatHandle &MF_STRING, Float_Replace, Float_Replace_String

    call 'USER32.AppendMenuA' D$FloatHandle &MF_SEPARATOR &NULL &NUll
    call 'USER32.AppendMenuA' D$FloatHandle &MF_STRING Float_SearchFromTop,
                             Float_SearchFromTop_String
    call 'USER32.AppendMenuA' D$FloatHandle &MF_STRING Float_SearchUp Float_SearchUp_String
    call 'USER32.AppendMenuA' D$FloatHandle &MF_STRING Float_SearchDown Float_SearchDown_String

    call IsItaNumber
    If eax > 0
        call 'USER32.AppendMenuA' D$FloatHandle, &MF_SEPARATOR, &NULL, &NUll
        call 'USER32.AppendMenuA' D$FloatHandle, &MF_STRING, Float_Number, Float_Number_String
    End_If

    call IsItanEqual | On eax = &TRUE, jmp L0>

    call IsItaMacro
    If eax > 0
L0:     call 'USER32.AppendMenuA' D$FloatHandle, &MF_SEPARATOR, &NULL, &NUll
        call 'USER32.AppendMenuA' D$FloatHandle, &MF_STRING, Float_Unfold, Float_Unfold_String
    End_If

    call IsItaLabel
    If eax = 1
        call 'USER32.AppendMenuA' D$FloatHandle, &MF_SEPARATOR, &NULL, &NUll
        call 'USER32.AppendMenuA' D$FloatHandle, &MF_STRING, Float_BookMark,
                                  Float_BookMark_String
    Else_If eax = 2
        call 'USER32.AppendMenuA' D$FloatHandle, &MF_SEPARATOR, &NULL, &NUll
        call 'USER32.AppendMenuA' D$FloatHandle, &MF_STRING, Float_UnBookMark,
                                  Float_UnBookMark_String
    End_If

    .If D$IsDebugging = &FALSE
        mov ecx D$BlockEndTextPtr | sub ecx D$BlockStartTextPtr
        If ecx > 50
            call 'USER32.AppendMenuA' D$FloatHandle, &MF_SEPARATOR, &NULL, &NUll
            call 'USER32.AppendMenuA' D$FloatHandle, &MF_STRING, Float_SelReplace,
                                    Float_SelReplace_String
        End_If
    .End_If


    .If B$ThisSourceIsDisassembled = &TRUE
        call IsItDisassembledLabel
        If eax = &TRUE
            call 'USER32.AppendMenuA' D$FloatHandle, &MF_SEPARATOR, &NULL, &NUll
            call 'USER32.AppendMenuA' D$FloatHandle, &MF_STRING, Float_BadDisLabel,
                                      Float_BadDisLabel_String
        end_If
    .End_If


    call 'USER32.GetWindowRect' D$hwnd RECT
    mov eax D$RECTleft | add eax 20 | add D$MousePosX eax
    mov eax D$RECTtop | add D$MousePosY eax

    call 'KERNEL32.GetCurrentThreadId'
    call 'USER32.SetWindowsHookExA' &WH_KEYBOARD, FloatMenuProc, &NULL, eax
    mov D$hHook eax

    mov eax D$MousePosX | add eax D$BpMarginWidth

    call 'USER32.TrackPopupMenu' D$FloatHandle,
                                 0, eax, D$MousePosY, 0,
                                 D$EditWindowHandle, &NULL

    call 'USER32.UnhookWindowsHookEx' D$hHook
ret


IsItDisassembledLabel:
    mov esi D$BlockEndTextPtr | On B$esi+1 <> ':', jmp L7>

    mov esi D$BlockStartTextPtr
    If D$esi = 'Code'
        mov D$DisLabelTypeWas CODEFLAG
        call GetDisLabelHexaValue
        xor B$GetHexaFromTextError &TRUE | mov eax D$GetHexaFromTextError

    Else_If D$esi = 'Data'
        mov D$DisLabelTypeWas DATAFLAG
        call GetDisLabelHexaValue
        xor B$GetHexaFromTextError &TRUE | mov eax D$GetHexaFromTextError

    Else
L7:     mov eax 0

    End_If
ret


GetDisLabelHexaValue:
;;
  The "On B$esi = '_', jmp L1>" are for cases of Label that are appended with a "_Symbol"
  taken from the 'StringsMap'.
;;
    mov esi D$BlockStartTextPtr, edi CopyOfLabelHexa | add esi 4
    While B$esi <> ':'
        movsb | On B$esi = '_', jmp L1>
    End_While
L1: mov B$edi 0

    call GetHexaFromText CopyOfLabelHexa

    If B$GetHexaFromTextError = &TRUE
        mov D$DisAddressWas 0
    Else
        mov D$DisAddressWas eax
    End_If

    mov D$CopyOfNextLabelHexa 0
    mov eax D$CopyOfLabelHexa
    .While esi < D$SourceEnd
        inc esi
        .If D$esi = eax
            mov ebx esi
            While B$esi <> ':'
                inc esi | On B$esi <= ' ', jmp L2>
            End_While

            mov esi ebx, edi CopyOfNextLabelHexa
            While B$esi <> ':'
                movsb | On B$esi = '_', jmp L1>
            End_While
L1:         mov B$edi 0
            push D$GetHexaFromTextError
                call GetHexaFromText CopyOfNextLabelHexa
                If B$GetHexaFromTextError = &TRUE
                    mov D$NextDisAddressWas 0, D$CopyOfNextLabelHexa 0
                Else
                    mov D$NextDisAddressWas eax
                End_If
            pop D$GetHexaFromTextError
        .End_If
L2: .End_While
ret


Proc FloatMenuProc:
    Arguments @nCode, @wParam, @lParam

        ..If D@nCode = &HC_ACTION ; HC_NOREMOVE
            On D@wParam = &VK_ESCAPE
L1:             mov B$BlockInside &FALSE
            End_If
        ..End_If

L9:     mov eax &FALSE ; Forwarding
EndP


CopyFromFloatMenu:
    call 'USER32.DestroyMenu' D$FloatHandle
    call ControlC
ret


SetFloatSearch:
    mov esi D$BlockStartTextPtr, edi SearchString, ecx D$BlockEndTextPtr
    sub ecx esi | inc ecx
    mov D$LenOfSearchedString ecx
    rep movsb
ret

SearchUpFromFloatMenu:
    mov B$DownSearch &FALSE
    call SetFloatSearch | call SetCaret D$BlockStartTextPtr | call StringSearch
ret

SearchFromTopFromFloatMenu:
    mov B$DownSearch &TRUE
    call SetFloatSearch
    call FullUp | mov D$CaretRow 1, D$CaretLine 0 | move D$CurrentWritingPos D$CodeSource
    call StringSearch
ret

SearchDownFromFloatMenu:
    mov B$DownSearch &TRUE
    call SetFloatSearch | call StringSearch
ret


RightClickedNumber:
    inc esi
    push D$BlockStartTextPtr, D$BlockEndTextPtr
        mov D$BlockStartTextPtr esi
        push esi
L0:         lodsb | call WordEdge | cmp B$Edge &TRUE | jne L0<
            sub esi 2 | mov D$BlockEndTextPtr esi
        pop esi
        call IsItaNumber
    pop D$BlockEndTextPtr, D$BlockStartTextPtr
    If eax <> 0
        call ViewClickedNumber
    End_If
ret


[ClickedNumberValue: ?    HexaInBlock: ?    BinaryInBlock: ?]

[NumberCopy: ? #25]

IsItaNumber:
    mov eax 0, esi D$BlockStartTextPtr, bl B$esi
    mov B$HexaInBlock &FALSE, B$BinaryInBlock &TRUE

    cmp bl '0' | jb L9>>
        cmp bl '9' | ja L9>>

L0: inc esi
    cmp B$esi '_' | je L1>
    cmp B$esi '0' | jb L2>  ; 010_0000_0000
    cmp B$esi 'F' | ja L2>
    cmp B$esi 'A' | jae L1>
    cmp B$esi '9' | ja L2>
L1: jmp L0<

L2: mov ecx esi | sub ecx D$BlockStartTextPtr
    If ecx > 50
        mov eax 0 | jmp L9>>
    End_If
    mov esi D$BlockStartTextPtr, edi NumberCopy

    While esi <= D$BlockEndTextPtr
L3:     lodsb
        If al >= 'a'
            On al <= 'f', sub al 32
        End_If

        If al = '_'
            jmp L3<
        Else_If al > 'F'
            mov eax 0 | jmp L9>>
        Else_If al < '0'
            mov eax 0 | jmp L9>>
        End_If

        On al > '9',  mov B$HexaInBlock &TRUE
        On al > '1', mov B$BinaryInBlock &FALSE

        On al <> '_', stosb
    End_While

    mov D$OldStackPointer esp
    mov B$edi 0
    mov esi NumberCopy
    .If W$esi = '00'
        If B$BinaryInBlock = &TRUE
            call ClickBinary
        Else
            mov eax 0
        End_If
    .Else_If B$esi = '0'
        call ClickHexa
    .Else
        If B$HexaInBlock = &FALSE
            call ClickDecimal
        Else
            mov eax 0
        End_If
    .End_If

  ; eax = Number if any (or 0):
L9: mov D$ClickedNumberValue eax
ret
____________________________________________________________________________________________

; Numbers translations Routines without error report (no Menu Option on failure, instead)

ClickBinary:
    lodsw                                               ; clear first '00'
NackedClickBinary:
    mov ebx 0, edx 0, ecx 0
L0: lodsb | cmp al Closebracket | jbe L9>
    sub al '0' | shld edx ebx 1 | shl ebx 1 | or bl al
    cmp edx ecx | jb L8>
        mov ecx edx
            cmp al 2 | jb L0<
L8:             mov ecx D$BinTypePtr | jmp BadNumberFormat
L9: mov eax ebx
ret


ClickHexa:
    lodsb                                               ; clear first '0'
NackedClickHexa:
    mov ebx 0,  edx 0, ecx 0
L0: lodsb | cmp al LowSigns | jbe L9>
        sub al '0' | cmp al 9 | jbe L2>
            sub al 7
L2: shld edx ebx 4 | shl ebx 4 | or bl al
    cmp edx ecx | jb L8>
        mov ecx edx
            cmp al 0F | jbe L0<
L8: mov ecx HexType | jmp BadClickFormat
L9: mov eax ebx
ret


ClickDecimal:
    mov eax 0, ecx 0

L2: mov cl B$esi | inc esi                        ; (eax used for result > no lodsb)
    cmp cl LowSigns | jbe  L9>

      mov edx 10 | mul edx | jo L3>               ; loaded part * 10
                                                  ; Overflow >>> Qword
        sub  ecx '0' | jc L7>
        cmp  ecx 9   | ja L7>

          add  eax ecx | jnc  L2<
            jmp  L4>                              ; carry >>> Qword

                                                  ; if greater than 0FFFF_FFFF:
L3: sub ecx '0' | jc L7>
    cmp ecx 9   | ja L7>

      add eax ecx

L4:   adc edx 0
      mov cl B$esi | inc  esi
      cmp cl LowSigns | jbe L9>

        mov ebx eax, eax edx, edx 10 | mul edx    ; high part * 10
          jo L6>                                  ; Qword overflow
            xchg eax ebx | mov edx 10 | mul edx   ; low part * 10
            add  edx ebx
            jnc   L3<                             ; carry >>> overflow
L6:           mov eax 0 | ret

L7: mov ecx D$DezimalTypePtr | jmp BadNumberFormat
L9: ret                                           ; >>> number in EDX:EAX


BadClickFormat:
    dec esi
L0: lodsb | On al = 'X', lodsb

    ..If al = 'H'
        cmp B$esi LowSigns | ja L7>
    ..Else_If al = 'D'
        cmp B$esi LowSigns | ja L7>
    ..Else_If al = 'B'
        cmp B$esi LowSigns | ja L7>
    ..Else
      ; Try to read a Type Marker at the end, and re-run if possible:
L7:     While B$esi > LowSigns | inc esi | End_While | dec esi | lodsb
        .If al = 'H'
            If ecx = HexType
                mov eax 0 | ret
            End_If
        .Else_If al = 'D'
            If ecx = DezimalType
                mov eax 0 | ret
            End_If
        .Else_If al = 'B'
            If ecx = BinType
                mov eax 0 | ret
            End_If
        .Else
            mov eax 0 | ret
        .End_If
    ..End_If

    dec esi
;;
 esi now points to the last Char of the Number. We overwrite it: We kill the Types Markers
 and we fill at the other end (start), with zeros:
;;
    push edi
        mov edi esi | dec esi | On B$esi = 'X', dec esi
        std
            While B$esi > LowSigns | movsb | End_While
        cld
        While B$edi > LowSigns | mov B$edi '0' | dec edi | End_While
    pop edi

    inc esi | While B$esi = '0' | inc esi | End_While

    If al = 'H'
        jmp NackedClickHexa
    Else_If al = 'D'
        jmp ClickDecimal
    Else  ; al = 'B'
        jmp NackedClickBinary
    End_If
____________________________________________________________________________________________



[ClickedNumberText: ClickedHexa: "

                                    

                                                               

                                                        



", 0

ClickedNumberTitle: 'Bases forms', 0]


ViewClickedNumber:
    mov eax D$ClickedNumberValue | lea edi D$ClickedHexa+8

  ; Write Hexa form:
    call WriteEax
    mov al ' '
    While B$edi <> CR
        stosb
    End_While
    add edi 8

  ; Write Decimal form:
    mov eax D$ClickedNumberValue
    mov dl 0FF | push edx                       ; Push stack end mark
    mov ecx 10
L0: mov edx 0
    div ecx | push edx | cmp eax 0 | ja L0<     ; Push remainders
L2: pop eax                                     ; Retrieve Backward
    cmp al 0FF | je L9>                         ; Over?
       add al '0' | stosb | jmp L2<             ; Write
L9:
    mov al ' '
    While B$edi <> CR
        stosb
    End_While
    add edi 8

  ; Write Binary form:
    mov D$edi '00_ ' | add edi 3
    mov ebx D$ClickedNumberValue, ecx 4
L0: shl ebx 1 | mov al '0' | adc al 0 | stosb | loop L0<
    mov al '_' | stosb | mov ecx 4
L0: shl ebx 1 | mov al '0' | adc al 0 | stosb | loop L0<
    mov al '_' | stosb | mov ecx 4
L0: shl ebx 1 | mov al '0' | adc al 0 | stosb | loop L0<
    mov al '_' | stosb | mov ecx 4
L0: shl ebx 1 | mov al '0' | adc al 0 | stosb | loop L0<
    mov al '_' | stosb | mov ecx 4

    mov al '_' | stosb | stosb

L0: shl ebx 1 | mov al '0' | adc al 0 | stosb | loop L0<
    mov al '_' | stosb | mov ecx 4
L0: shl ebx 1 | mov al '0' | adc al 0 | stosb | loop L0<
    mov al '_' | stosb | mov ecx 4
L0: shl ebx 1 | mov al '0' | adc al 0 | stosb | loop L0<
    mov al '_' | stosb | mov ecx 4
L0: shl ebx 1 | mov al '0' | adc al 0 | stosb | loop L0<

    call 'USER32.MessageBoxA' D$hwnd, ClickedNumberText, ClickedNumberTitle, &MB_SYSTEMMODAL
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Little feature for "Replace all" in Selected Block: Whole words / Case insensitive

; Tag Dialog 1050

BlockReplaceAll:
    call 'USER32.DialogBoxParamA' D$hinstance, 1050, D$hwnd, BlockReplaceAllProc, &NULL
ret


[BlockFrCase: &TRUE    BlockWwSearch: &TRUE]

; Tag Dialog 1050

Proc BlockReplaceAllProc:
    Arguments @Adressee, @Message, @wParam, @lParam
    Local @StartOfBlock, @EndOfBlock

    pushad

    ...If D@Message = &WM_INITDIALOG
       ; call 'USER32.SendDlgItemMessageA' D@Adressee, 50, &BM_SETCHECK, D$BlockFrCase, 0
       ; call 'USER32.SendDlgItemMessageA' D@Adressee, 51, &BM_SETCHECK, D$BlockWwSearch, 0
        call 'USER32.GetDlgItem' D@Adressee, 10
        call 'USER32.SetFocus' eax
        popad | mov eax &TRUE | ExitP

    ...Else_If D@Message = &WM_COMMAND

        mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        ..If D@wParam = &IDCANCEL
            call 'USER32.EndDialog' D@Adressee, 0

        ..Else_If D@wParam = &IDOK
            call 'USER32.SendDlgItemMessageA' D@Adressee, 50, &BM_GETCHECK, 0, 0
            mov D$BlockFrCase eax

            call 'USER32.SendDlgItemMessageA' D@Adressee, 51, &BM_GETCHECK, 0, 0
            mov D$BlockWwSearch eax

            call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &WM_GETTEXT, 80,
                                              SearchString
            call 'USER32.SendDlgItemMessageA' D@Adressee, 11, &WM_GETTEXT, 80,
                                              ReplaceWithString
            mov esi SearchString, ecx 0
            While B$esi > 0 | inc esi | inc ecx | End_While
            mov esi ReplaceWithString, D$LenOfReplaceString 0
            While B$esi > 0 | inc esi | inc D$LenOfReplaceString | End_While

            .If ecx > 0
                push D$UpperLine, D$CaretRow, D$CaretLine
                push D$DownSearch, D$CaseSearch, D$WholeWordSearch
                    mov B$BlockInside &FALSE

                    mov D$LenOfSearchedString ecx
                  ; No 'String not found" Message at the end:
                    mov B$OnReplaceAll &TRUE
                    move D$NextSearchPos D$BlockStartTextPtr
                    move D$CaseSearch D$BlockFrCase, D$WholeWordSearch D$BlockWwSearch
                    mov B$DownSearch &TRUE
                    move D@StartOfBlock D$BlockStartTextPtr, D@EndOfBlock D$BlockEndTextPtr

L0:                 call StringSearch

                    If B$BlockInside = &TRUE
                        mov eax D@EndOfBlock | cmp D$BlockStartTextPtr eax | ja L1>
                        call StringReplace | jmp L0<
                    End_If

L1:                 mov B$OnReplaceAll &FALSE, B$Disassembling &FALSE, B$BlockInside &TRUE
                    move D$BlockStartTextPtr D@StartOfBlock, D$BlockEndTextPtr D@EndOfBlock
                pop D$WholeWordSearch, D$CaseSearch, D$DownSearch
                pop D$CaretLine, D$CaretRow, D$UpperLine
                call AskForRedraw
            .End_If

            call 'USER32.EndDialog' D@Adressee, 0
        ..End_If

    ...Else
L8:     popad | mov eax &FALSE | ExitP

    ...End_If

    popad | mov eax &TRUE
EndP


____________________________________________________________________________________________
____________________________________________________________________________________________


; If user DoubleClick or RightClick on Block, we check if the pointed thing is a Macro
; evocation (to append an 'Unfold' Item in the Floating Menu). Called from
; 'RightClickOnBlock'.

IsItaMacro:
    mov esi D$BlockStartTextPtr

  ; Verify we are not pointing a Declaration:
    push esi
        While B$esi-1 = ' '
            dec esi
        End_While
        mov al B$esi-1
    pop esi
    If al = '['
        mov eax 0 | ret
    End_If

    mov edi D$CodeSource, al '[', ecx D$SourceLen
    mov edx D$BlockEndTextPtr | sub edx D$BlockStartTextPtr | inc edx

  ; Search for '[' in user Source:
L0: repne scasb | jne L8>
        push eax, ecx, esi, edi
            While B$edi = ' '
                inc edi                     ; Strip possible leading Space(s).
            End_While
            mov ecx edx
L1:         mov al B$esi, bl B$edi | inc esi | inc edi | dec ecx
            or al 020 | or bl 020 | cmp al bl | jne L2>          ; No case compare with Block.
            cmp ecx 0 | ja L1<
               jmp L9>
L2:     pop edi, esi, ecx, eax

L3: cmp ecx 0 | ja L0<

L8: mov eax 0 | ret                         ; No mach found.

  ; Mach found, but is it a Macro?
L9: While B$edi = ' '
        inc edi                             ; strip trailing Space(s)
    End_While
    cmp B$edi CR | je L9>                   ; Macro.
    cmp B$edi '|' | je L9>                  ; Macro too.
    cmp B$edi ';' | je L9>                  ; Macro too with comment after symbol.
        pop edi, esi, ecx, eax | jmp L3<         ; Equate, Data or Macro with the same begining

L9: pop edi, esi, ecx, eax

    move D$InstructionToUnfold D$BlockStartTextPtr
    dec edi | mov eax edi, D$UnfoldedMacro eax
ret


; Checks if we are pointing on an Equal PreParser line.


[ASCII_DOLLAR 024, ASCII_PARAGRAPH 0A7]

IsItAnEqual:
    mov esi D$BlockStartTextPtr, eax 0, B$UnfoldEqual &FALSE
    If B$esi-1 = ASCII_DOLLAR
        sub esi 2
    Else_If B$esi-1 = ASCII_PARAGRAPH
        sub esi 2
    End_If

    mov D$InstructionToUnfold esi

  ; Go to the start of the Statement:
L0: dec esi
    If B$esi = '|'
        jmp L1>
    Else_If B$esi = LF
        jmp L1>
    Else_If B$esi = ' '
        je L0<
    Else
        ret
    End_If

  ; OK, the Selection is the first Member of a Statement. Go to next Component:
L1: mov esi D$BlockEndTextPtr
L0: inc esi
    If B$esi = ' '
        jmp L1>
    Else_If B$esi = LF
        ret
    Else_If B$esi = ','
        ret
    End_If
    jmp L0<

L1: While B$esi = ' ' | inc esi | End_While

    .If B$esi = '='
        If B$esi+1 = ' '
            mov B$UnfoldEqual &TRUE
            move D$UnfoldedMacro D$CodeSource
            dec D$UnfoldedMacro
            mov eax &TRUE | ret
        End_If
    .End_If
ret
____________________________________________________________________________________________

; Called by User DoubleLefClick. If the Block is a Label, the user can store it as
; BookMarked.

[BookMarks: ?    BookMarkLen: ?    BookMarkPtr: ?]
[ToBeBookMarked: ? #20]

IsItaLabel:
  ; If not a Label, we abort:
    mov esi D$BlockEndTextPtr
    If B$esi+1 <> ':'
        mov eax 0 | ret
    End_If

  ; Local Label, we abort:
    mov esi D$BlockStartTextPtr
    If B$esi+2 = ':'
        mov eax 0 | ret
    End_If

  ; If It is a Local Symbol, we extend. If it is a Local Label we abort:
    mov esi D$BlockStartTextPtr, edi ToBeBookMarked

    If B$esi-1 = '@'
        push edi | call SearchUpperMainLabel | pop edi | On eax = 0, ret
        mov esi eax
        While B$esi <> ':'
            movsb
        End_While
        mov B$edi '@' | inc edi
        mov esi D$BlockStartTextPtr
    End_If

    While esi < D$BlockEndTextPtr | movsb | End_While | movsb | mov B$edi 0

    sub edi ToBeBookMarked | mov D$BookMarkLen edi
    mov esi ToBeBookMarked

  ; If the Block is aready BookMarked, we enable the [UnBookMark] option:
    If D$BookMarks > 0
        mov edi D$BookMarks, ecx D$BookMarkLen
        inc edi
L0:     push esi, edi, ecx
            mov D$BookMarkPtr edi
L1:         mov al B$esi, bl B$edi | or al 020 | or bl 020 | inc esi | inc edi
            cmp al bl | jne L2>
            loop L1<
        pop ecx, eax, esi                       ; Found.
        cmp B$edi ' ' | ja L3>
        mov eax 2 | ret                         ; Return for [UnBookMark] option.
L2:     pop ecx, eax, esi                       ; Not yet found.
L3:     mov edi eax
L3:     cmp B$edi 0 | je L4>
            inc edi | jmp L3<
L4:     inc edi | cmp B$edi 0 | jne L0<         ; Not yet end of Stored BookMarks.
    End_If

  ; If here, the Label is a Main label and is not yet BookMarked:
    mov eax 1
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

SearchUpperMainLabel:
    mov edi D$BlockStartTextPtr
L0: dec edi
    While B$edi <> ':'
        dec edi
        If B$edi = '"'
            Do
                dec edi | on edi = D$CodeSource, jmp L7>
            Loop_Until B$edi = '"'
            dec edi
        Else_If B$edi = "'"
            Do
                dec edi | on edi = D$CodeSource, jmp L7>
            Loop_Until B$edi = "'"
            dec edi
        End_If
        on edi = D$CodeSource, jmp L7>
    End_While
    While B$edi > ' '
        dec edi | on edi = D$CodeSource, jmp L7>
    End_While
    inc edi
    If B$edi = '@'
        jmp L0<<
    Else_If B$edi+2 = ':'
        jmp L0<<
    Else
        mov eax edi | ret
    End_If

L7: mov eax 0
ret


[FullBookMarks: 'No more room to store BookMarks', 0
 BookMarksTitle: '               ----------- BookMarks -----------', 0
 EndBookMarks:   '                 ------------- Tree --------------', 0]
[NumberOfBookMarks: 0]

StoreBookMark:
    call CreateTreeViewList
    If D$BookMarks = 0
        VirtualAlloc BookMarks 01000 | mov D$NumberOfBookMarks 2
        call 'USER32.SendDlgItemMessageA' D$ShowTreeHandle, 100, &LB_INSERTSTRING, 0,
                                          EndBookMarks
        call 'USER32.SendDlgItemMessageA' D$ShowTreeHandle, 100, &LB_INSERTSTRING, 0,
                                          BookMarksTitle
    End_If
    mov edi D$BookMarks, al 0, ecx 01000
L0: repne scasb | cmp B$edi 0 | jne L0<
    push edi
        mov eax ToBeBookMarked
        While B$eax <> 0 | inc eax | End_While
        sub eax ToBeBookMarked
        If ecx <= eax
            call 'USER32.MessageBoxA' D$hwnd, FullBookMarks, Argh, &MB_SYSTEMMODAL
            pop edi | jmp L9>
        End_If
        mov ecx eax, esi ToBeBookMarked
        rep movsb
        mov al ' ' | stosb | mov al 0 | stosb
    pop edi

    call 'USER32.SendDlgItemMessageA' D$ShowTreeHandle 100  &LB_INSERTSTRING 1 edi
    inc D$NumberOfBookMarks
L9: ret


ReInsertBookMarks:
    mov D$NumberOfBookMarks 2
    call 'USER32.SendDlgItemMessageA' D$ShowTreeHandle 100  &LB_INSERTSTRING 0,
                                     EndBookMarks
    call 'USER32.SendDlgItemMessageA' D$ShowTreeHandle 100  &LB_INSERTSTRING 0,
                                     BookMarksTitle

    mov esi D$BookMarks | inc esi
    .While B$esi > 0
        call 'USER32.SendDlgItemMessageA' D$ShowTreeHandle 100  &LB_INSERTSTRING 1 esi
        inc D$NumberOfBookMarks
        While B$esi <> 0
            inc esi
        End_While
        inc esi
    .End_While
ret


DeleteBookMark:
    call CreateTreeViewList
    call 'USER32.SendDlgItemMessageA' D$ShowTreeHandle 100  &LB_FINDSTRING 0-1 D$BookMarkPtr
    call 'USER32.SendDlgItemMessageA' D$ShowTreeHandle 100  &LB_DELETESTRING eax 0
    mov edi D$BookMarkPtr, esi edi
    add esi D$BookMarkLen | While B$esi > 0 | inc esi | End_While | inc esi
    mov ecx D$BookMarks | add ecx 01000 | sub ecx esi | rep movsb

  ; Delete the 2 added titles if no more BookMarks, delete the .BKM File and release Mem:
    dec D$NumberOfBookMarks
    If D$NumberOfBookMarks = 2
        call 'USER32.SendDlgItemMessageA' D$ShowTreeHandle 100  &LB_DELETESTRING 0 0
        call 'USER32.SendDlgItemMessageA' D$ShowTreeHandle 100  &LB_DELETESTRING 0 0
        call DeleteBookMarkFile

        VirtualFree D$BookMarks
    End_If
ret


DeleteBookMarkFile:
    mov D$NumberOfBookMarks 0
    mov edi SaveFilter, al 0, ecx 0-1 | repne scasb
    While B$edi <> '.'
        dec edi
    End_While

    push D$edi, edi
        mov D$edi '.BKM'

        call 'KERNEL32.FindFirstFileA' SaveFilter FindFile

        .If eax <> &INVALID_HANDLE_VALUE
            call 'KERNEL32.FindClose' eax
            call 'KERNEL32.DeleteFileA' SaveFilter
        .End_If
    pop edi, D$edi
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
           Unfolder's jobs.
           
  'ShowUnfoldMacro' ---> 'ShowUnfoldDialog' ---> 'UnfoldMacro' ---> 'AsmMain'
  
  Both 'AsmMain' and (after final RET), 'UnfoldMacro' call for 'UnfoldOutput'.
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[UnfoldedMacro: ?    InstructionToUnfold: ?    StackBeforeUnfolding: ?    WeAreUnfolding: ?]

[ShowUnfoldDialogHandle: ?]

ShowUnfoldMacro:
    If D$DebugDialogHandle <> 0
        call KillDebugger | On eax = &IDNO, ret
    End_If

    .If D$ShowUnfoldDialogHandle = 0
        mov B$CompileErrorHappend &FALSE
        call 'USER32.DialogBoxParamA' D$hInstance, 23000, &NULL, ShowUnfoldDialog, &NULL

    .Else
        Beep

    .End_If
ret
____________________________________________________________________________________________

[UnfoldTitle: B$ 'Macro Unfolding', 0]

; Tag Dialog 23000

Proc ShowUnfoldDialog:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    .If D@Message = &WM_COMMAND
         If W@wParam = &IDCANCEL
L0:         mov D$ShowUnfoldDialogHandle 0
            call 'USER32.EndDialog' D@Adressee, 0

         Else_If W@wParam = &IDOK
            jmp L0<

         End_If

    .Else_If D@Message = &WM_SIZE
        Call ResizeEditControl

    .Else_If D@Message = &WM_INITDIALOG
        move D$ShowUnfoldDialogHandle D@Adressee
        call 'USER32.SetClassLongA' D@Adressee, &GCL_HICON, D$wc_hIcon

        call UnfoldMacro

        If B$UnfoldCompleted = &FALSE
            jmp L0<
        Else
            call 'USER32.SendMessageA' D@Adressee, &WM_SETTEXT, &NULL, UnfoldTitle
            mov B$FirstCTLCOLOREDIT &TRUE
        End_If

    .Else_If D@Message = &WM_CTLCOLOREDIT
        If B$FirstCTLCOLOREDIT = &TRUE
            call 'USER32.SendMessageA' D@lParam, &EM_SETSEL, 0, 0
            mov B$FirstCTLCOLOREDIT &FALSE
        End_If
        call 'GDI32.SetBkColor' D@wParam, D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    .Else_If B$CompileErrorHappend = &TRUE
        mov D$ShowUnfoldDialogHandle 0
        call 'USER32.EndDialog' D@Adressee, 0

    .Else
        popad | mov eax &FALSE | jmp L9>

    .End_If

    popad | mov eax &TRUE

L9: EndP


Proc ResizeEditControl:
    Structure @RECT 16, @RECT_leftDis 0, @RECT_topDis 4, @RECT_rightDis 8, @RECT_bottomDis 12

        call 'USER32.GetClientRect' D$ShowUnfoldDialogHandle, D@RECT

        call 'USER32.GetDlgItem' D$ShowUnfoldDialogHandle, 101

        mov ebx D@RECT_rightDis | sub ebx D@RECT_leftDis
        mov ecx D@RECT_bottomDis | sub ecx D@RECT_topDis

        call 'USER32.MoveWindow' eax, 0, 0, ebx, ecx, &TRUE
EndP
____________________________________________________________________________________________

[UnfoldEqual: ?  UnfoldCompleted: ?]

UnfoldMacro:
    call 'USER32.SetCursor', D$WaitCursor | call AskForRedrawNow

    mov B$WeAreUnfolding &TRUE, B$UnfoldStepIndice '0'
    mov D$TrashPointer Trash3

    push D$SourceLen, D$SourceEnd

        mov D$StackBeforeUnfolding esp

        call AsmMain
      ; 'AsmMain' stops after the Macros jobs, in cases when "B$WeAreUnfolding = &TRUE".

        call 'USER32.SetCursor' D$ActualCursor

        call UnfoldOutput

        mov D$edi CRLF2, B$edi+4 0

      ; Show the result:
        mov eax D$CodeSourceB
        If D$eax <> 0
            call 'USER32.SetDlgItemTextA' D$ShowUnfoldDialogHandle, 101, Trash3
            mov B$UnfoldCompleted &TRUE

        Else
            mov B$UnfoldCompleted &FALSE

        End_If

L8: pop D$SourceEnd, D$SourceLen

    ;VirtualFree D$LabelList, D$MacroList, D$PlainLabelList,
    ;        D$StatementsTable, D$StatementsTable2, D$CodeSourceB, D$CodeSourceA
    call ReleaseAsmTables

    mov B$WeAreUnfolding &FALSE, B$ReadyToRun &FALSE

    call ReleaseAsmTables
ret

UnfoldingError:
    mov D$UnfoldErrorMessage eax, B$CompileErrorHappend &TRUE, B$UnfoldCompleted &FALSE

    call 'USER32.SetCursor' D$ActualCursor

    While esp <> D$StackBeforeUnfolding
        pop ebx
    End_While

    jmp L8<<
____________________________________________________________________________________________

[UnfoldErrorMessage: ?]

GetUnfoldStatement:
    push esi, ebx, ecx
        mov esi D$CodeSourceA, eax 0
        mov edx esi | add edx D$SourceLen

        While eax <> ecx
            .If B$esi = EOI
                If B$esi+1 = OpenBracket
                    ;
                Else_If B$esi+1 = OpenVirtual
                    ;
                Else
                    inc eax
                End_If

            .Else_If B$esi = OpenBracket
                inc eax

            .Else_If B$esi = OpenVirtual
                inc eax

            .End_If

            inc esi | On esi > edx, jmp L8>>
        End_While

      ; Translate into normal Ascii form:
        mov edi D$TrashPointer

        If B$esi-1 = OpenVirtual ; 016
            dec esi | call TranslateDeclarationToNormalAscii

        Else_If B$esi-1 = OpenBracket ; 014
            dec esi | call TranslateDeclarationToNormalAscii

        Else
            call TranslateCodeToNormalAscii

        End_If

L8: pop ecx, ebx, esi
ret
____________________________________________________________________________________________

TranslateDeclarationToNormalAscii:
L0: lodsb

    .If al = Space
        mov al ' '
    .Else_If al = EOI
        jmp L2>>
    .Else_If al = meEOI
        mov al CR | stosb | mov al LF
    .Else_If al = TextSign
        mov B$edi '"' | inc edi
        While B$esi <> TextSign
            lodsb
            If al = CR
                mov W$edi CRLF | add edi 2 | add esi 2
            Else
                stosb
            End_If
        End_While
        inc esi | mov al '"'

    .Else_If al = MemMarker
        mov al '$'
    .Else_If al = OpenBracket
        mov al '['
    .Else_If al = CloseVirtual
        mov al ']' | stosb
        mov al CR | stosb | mov al LF | stosb | jmp L2>>
    .Else_If al = CloseBracket
        mov al ']' | stosb
        mov al CR | stosb | mov al LF | stosb | jmp L2>>
    .Else_If al = OpenVirtual
        mov al '['
    .Else_If al = AddSign
        mov al '+'
    .Else_If al = SubSign
        mov al '-'
    .Else_If al = MulSign
        mov al '*'
    .Else_If al = DivSign
        mov al '/'
    .Else_If al = numSign
        mov al '#'
    .Else_If al = colonSign
        mov al ':' | stosb | mov al ' ' | stosb
    .End_If

    stosb

    If al = LF
        mov D$edi '    ' | add edi 4
    End_If

    jmp L0<<

L2: mov ax CRLF | stosw ;| mov al 0 | stosb
ret
____________________________________________________________________________________________

TranslateCodeToNormalAscii:
L0: lodsb

    .If al = Space
        mov al ' '
    .Else_If al = EOI
        jmp L2>>
    .Else_If al = meEOI
        mov al CR | stosb | mov al LF
    .Else_If al = TextSign
        mov B$edi '"' | inc edi
        While B$esi <> TextSign
            lodsb
            If al = CR
                mov W$edi CRLF | add edi 2 | add esi 2
            Else
                stosb
            End_If
        End_While
        inc esi | mov al '"'
    .Else_If al = MemMarker
        mov al '$'
    .Else_If al = OpenBracket
        jmp L2>>
    .Else_If al = CloseVirtual
        mov al ']'
    .Else_If al = OpenVirtual
        mov al '['
    .Else_If al = AddSign
        mov al '+'
    .Else_If al = SubSign
        mov al '-'
    .Else_If al = MulSign
        mov al '*'
    .Else_If al = DivSign
        mov al '/'
    .Else_If al = numSign
        mov al '#'
    .Else_If al = colonSign
        mov al ':' | stosb | mov al CR | stosb | mov al LF
    .End_If

    stosb

    If al = LF
        mov D$edi '    ' | add edi 4
    End_If

    jmp L0<<

L2: mov ax CRLF | stosw ;| mov al 0 | stosb
ret
____________________________________________________________________________________________

; pos '0' = 31
[UnfoldSteps: "
******************************
*    Macros-Engine Pass "

UnfoldStepIndice: "0    *
******************************

    ", 0]

UnfoldOutput:
    inc B$UnfoldStepIndice

    mov edi D$TrashPointer
    zCopy UnfoldSteps
    mov esi D$CodeSourceA
    mov D$TrashPointer edi

  ; Count how many Statements, in the 'StatementsTable', down to our Line:
    mov ebx D$BlockStartTextPtr, esi D$StatementsTable, ecx 1

  ; For "some reason", leading Labels must be included in the Statement:
    mov eax ebx | dec eax | While B$eax = ' ' | dec eax | End_While
    If B$eax = ':'
        While B$eax-1 > ' ' | dec eax | End_While
        mov ebx eax
    End_If

  ; Unfold upon an Equal Pre-Parser Statement:
    If B$ebx-1 = 024 ;'$' ; CharMessage
        sub ebx 2
    Else_If B$ebx-1 = 0A7 ;'$'
        sub ebx 2
    End_If

  ; Several Statements are possible. Example, in Data and in Code with a Para-Macro:
    While D$esi <> 0
        If D$esi = ebx
            call GetUnfoldStatement
            mov D$edi '    ' | add edi 4
            mov D$TrashPointer edi
        End_If

        add esi 4 | inc ecx
    End_While
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

EncodeBoxError:
    call ErrorMessageBox 0, D$ErrorMessagePtr
    mov esp D$OldStackPointer | sub esp 4
ret
____________________________________________________________________________________________

MarginRightClick:
    On D$BreakPointsTables = 0, call InitBreakPointsTables

    call MouseTextPos
    push ebx
        call SearchTxtPtr | mov D$BreakPointLocation eax
    pop ebx

    mov D$PhysicalCaretRow eax, D$CaretRow eax, D$StartBlockCol eax, D$EndBlockCol eax,
        D$CaretLine ebx, D$StartBlockLine ebx, D$EndBlockLine ebx

    mov D$CaretRow 1

    mov eax D$BreakPointLocation | call IsEaxInBpOnTable

    call BpMenu
ret
____________________________________________________________________________________________

DoubleClick:
    call MouseTextPos

    mov D$PhysicalCaretRow eax, D$CaretRow eax, D$StartBlockCol eax, D$EndBlockCol eax,
        D$CaretLine ebx, D$StartBlockLine ebx, D$EndBlockLine ebx

    If D$DBPMenuOn = DOUBLE_CLICK_ACTION
        On B$ClickOnMargin = &TRUE, jmp DoubleClickMarginAction
    End_If

    call SearchTxtPtr

    mov al B$esi | call WordEdge | On B$Edge = &TRUE, ret

    push esi
        std
L0:       lodsb | call WordEdge | cmp B$Edge &TRUE | jne L0<         ; search start
        cld
        add esi 2 | mov D$BlockStartTextPtr esi
    pop esi

L0: lodsb | call WordEdge | cmp B$Edge &TRUE | jne L0<               ; search end

    sub esi 2 | mov D$BlockEndTextPtr esi

    mov B$BlockInside &TRUE | call SetCaret esi
    call AskForRedraw | call RightClickOnBlock
ret
____________________________________________________________________________________________


_________________________________________________________

; See comment for rotary BackTable at "SetBackTableMemory"

ClearBackTable:
    mov edi D$BackTable, D$BackTablePtr edi, eax 0, ecx 040 | rep stosd
ret


StorePosInBackTable:
    mov ebx D$BackTablePtr, eax D$UpperLine
    mov D$ebx eax | add bl 4 | mov D$ebx 0
    mov D$BackTablePtr ebx, B$MovingBack  &FALSE
ret


[MovingBack: ?]

BackClick:
    mov eax D$CodeSource | On D$SourceEnd = eax, ret

    If B$MovingBack = &FALSE              ; BackTable store old pos, not last new one.
      call StorePosInBackTable            ; here we add last new one to allow Forward
      sub bl 4                            ; moves completion.
      mov D$BackTablePtr ebx, B$MovingBack &TRUE
    End_If

    mov ebx D$BackTablePtr | sub bl 4
    If D$ebx = 0                          ; If Start pointer, lock on it
        call StartEdition | call AskForRedraw | ret
    End_If

L1: mov eax D$ebx
    mov D$BackTablePtr ebx, D$UpperLine eax
    mov D$CaretRow 1, D$CaretLine 0, D$CurrentWritingPos eax
    call TryToMove
    call ResetUpperline
    call AskForRedraw
L9: ret


ForwardClick:
    mov eax D$CodeSource | On D$SourceEnd = eax, ret

    mov ebx D$BackTablePtr | add bl 4
    mov eax D$ebx | cmp eax 0 | je L9>
      mov D$BackTablePtr ebx, D$UpperLine eax
      mov D$CaretRow 1, D$CaretLine 0, D$CurrentWritingPos eax
      call TryToMove | call ResetUpperline | call AskForRedraw
L9: ret


; If text lenght have change between two right-click moves, D$Upperline may point to
; any char in a line. We ensure start of line in D$Upperline:

ResetUpperline:
    mov esi D$Upperline
L0: cmp B$esi-1 LF | je L9>
        dec esi | jmp L0<
L9: mov D$Upperline esi
ret






TITLE DCBP

;;
  "DCBP" stands for "Double-Click Break-Points"
  
   Left-Margin Double-Left-Click relative Routines:
  
  * User Double-Left-Click in the left Margin:
  
    'MarginAction', 'IsEaxInBpOnTable', 'BpMenu', 'InitBreakPointsTables'
  
  * User choice in the BP Float Menu:
  
    'SetBreakpoint', ('SortBpOnTable', 'DoStoreBP'),
    'DeleteBreakpoint', 'DeleteAllBreakpoints'
  
  * Routines call by the Sources Editor (factual Edition):
  
    'AdjustBpTable' ('AdjustDownwardPointers' // 'DeleteBpInBlock') are called by:
    'DoStoreInsert', 'DoStoreCharDelete', 'DoStoreBlockPaste',
    'WriteUndoBlockFile', 'ControlZ'
  
  * Routines called by the Source Editor output:
  
    'DrawOneBreakPoint'
  
  * Temporary example for Pointers translation at the attention of Ludwig:
  
    'GetcodeBreakPointPosFromSourcePointer'
  
  
  The two Tables, 'BpOnTable' and 'BpOffTable' are 512 dWords each (No security
  needed with one 01000 Bytes page).
  Each dword is a Pointer to the user Source: Not to the Code 'CodeListPtr'.
  
  The call to 'WriteBpOffTable' is actualy commented out for this Static version. 
  I suppose you will need it, for BP deleted by the user during the Debug session.
;;
____________________________________________________________________________________________

; Run by 'DoubleClick'.

[BreakPointLocation: ?]

MarginAction:
    mov B$ReadyToRun &FALSE

    On D$BreakPointsTables = 0, call InitBreakPointsTables
;;
  eax and ebx have been set to 'MousePosX' and 'MousePosY' by a previous call to
  'MouseTextPos' in 'DoubleClick. 'SearchTxtPtr' is going to return the Source
  Pointer from these Screen Coordinates.
;;
    call SearchTxtPtr | mov D$BreakPointLocation eax | dec D$CaretRow
  ; ('Dec' because 'SearchTxtPtr' forces Row 0 to 1, for usual actions)
  ; eax now the Pointer to Row 1 (Source Pointer form). Is it already recorded or not?

    .If B$Keys+&VK_SHIFT = &TRUE
        call DeleteAllBreakpoints

    .Else_If B$Keys+&VK_CONTROL = &TRUE
        call IsEaxInBpOnTable

        call BpMenu

;;
  The BreakPoints Float Menu may generate call's to:
  'SetBreakpoint', 'DeleteBreakpoint', 'DeleteAllBreakpoints'
;;
        inc D$CaretRow

    .Else
        call IsEaxInBpOnTable

        If B$InsideBpTable = &TRUE
            call DeleteBreakPoint | call DoStoreRemoveBP
        Else
            call SetBreakPoint | call DoStoreBP
        End_If

     .End_If

     mov B$Keys+&VK_SHIFT &FALSE, B$Keys+&VK_CONTROL &FALSE
ret


DoubleClickMarginAction:
    On D$BreakPointsTables = 0, call InitBreakPointsTables
;;
  eax and ebx have been set to 'MousePosX' and 'MousePosY' by a previous call to
  'MouseTextPos' in 'DoubleClick. 'SearchTxtPtr' is going to return the Source
  Pointer from these Screen Coordinates.
;;
    call SearchTxtPtr | mov D$BreakPointLocation eax | dec D$CaretRow
  ; ('Dec' because 'SearchTxtPtr' forces Row 0 to 1, for usual actions)
  ; eax now the Pointer to Row 1 (Source Pointer form). Is it already recorded or not?

;;
  The Left Button Double-Click generates: WM_LBUTTONDOWN, WM_LBUTTONUP, WM_LBUTTONDBLCLK,
  and WM_LBUTTONUP. So forth, the 'LeftButton' stuff has already (wrongly) been
  executed and we have to reverse its effect:
;;
    call IsEaxInBpOnTable

    If B$InsideBpTable = &TRUE
        call DeleteBreakPoint | call DoStoreRemoveBP
    Else
        call SetBreakPoint | call DoStoreBP
    End_If

    xor B$InsideBpTable &TRUE

    mov D$CaretRow 1

    call BpMenu
;;
  The BreakPoints Float Menu may generate call's to:
  'SetBreakpoint', 'DeleteBreakpoint', 'DeleteAllBreakpoints'
;;
ret


IsBreakPointHere:
    call RestoreRealSource
        call SearchTxtPtr
        While B$eax-1 <> LF | dec eax | End_While
        mov D$BreakPointLocation eax
        call IsEaxInBpOnTable
    call SetPartialEditionFromPos
  ; Returns 'InsideBpTable' &TRUE or &FALSE.
ret

____________________________________________________________________________________________

[FloatSetBp 5600    FloatDelBp 5601    FloatDelAllBp 5602]
[FloatSetBpString: B$ 'Set BreakPoint [F4]', 0 0 0 0 0
FloatDelBpString: 'Delete BreakPoint [F4]', 0 0 0 0 0
FloatDelAllBpString: 'Delete all BreakPoints [Shift]/[F4]', 0]

[FirstStrike: ?  BpMousePos: ? ? BpMouseX: ? BpMouseY: ?]

Proc KeyBoardProc:
    Arguments @nCode, @wParam, @lParam

        Inc D$FirstStrike | On D$FirstStrike < 2, jmp L9>>

        pushad
            ..If D@nCode = &HC_NOREMOVE
                .If D@wParam = &VK_F4
L1:                 call KillBpMenu

                    If B$InsideBpTable = &FALSE
                        call SetBreakPoint | call DoStoreBP
                    Else
                        call DeleteBreakPoint | call DoStoreRemoveBP
                    End_If

                    popad | mov eax &TRUE | ExitP ; Not forwarding

                .Else_If D@wParam = &VK_RETURN
                    call 'USER32.GetMenuState' D$FloatHandle, 0, &MF_BYPOSITION
                    test eax &MF_HILITE | jnz L1<

                .End_If
            ..End_If
        popad

L9:     mov eax &FALSE ; Forwarding
EndP


KillBpMenu:
  ; Forcing the Float Menu to close

  ; Simulate a Left-Click in the middle of the Window:
    push D$CaretRow, D$CaretLine
        call 'USER32.GetClientRect' D$EditWindowHandle, BpMousePos
        shr D$BpMouseX 1 | shr D$BpMouseY 1
        call 'USER32.ClientToScreen' D$EditWindowHandle, BpMouseX
        call BpClick
    pop D$CaretLine, D$CaretRow

  ; Restore the Caret initial Position:
    call FromCaretPosToScreen | mov D$BpMouseX eax, D$BpMouseY ebx
    call BpClick
ret


; Reurns: eax = X // ebx = Y

FromCaretPosToScreen:
    push D$EditWindowX, D$EditWindowY
        call 'USER32.GetClientRect' D$EditWindowHandle, EditWindowX
        call 'USER32.ClientToScreen' D$EditWindowHandle, EditWindowX
        mov eax D$CaretLine, ecx D$FontHeight | mul ecx | mov ebx eax
        mov eax D$CaretRow | mov ecx D$FontWidth | mul ecx
        add eax D$EditWindowX | add ebx D$EditWindowY
    pop D$EditWindowY, D$EditWindowX
ret


BpClick:
    call 'USER32.SetCursorPos' D$BpMouseX, D$BpMouseY
    call 'USER32.mouse_event' &MOUSEEVENTF_LEFTDOWN, D$BpMouseX, D$BpMouseY, 0, 0
    call 'USER32.mouse_event' &MOUSEEVENTF_LEFTUP, D$BpMouseX, D$BpMouseY, 0, 0
ret


[BpMenuPOINT: ? ?]

BpMenu:
  ; Build the Foating Menu:
    call 'USER32.CreatePopupMenu' | mov D$FloatHandle eax

    .If B$InsideBpTable = &FALSE
        call 'USER32.AppendMenuA' D$FloatHandle &MF_STRING, FloatSetBp, FloatSetBpString
        mov eax D$BpOnTable
        If D$eax <> 0
            call 'USER32.AppendMenuA' D$FloatHandle, &MF_STRING, FloatDelAllBp,
                                      FloatDelAllBpString
        End_If

    .Else
        call 'USER32.AppendMenuA' D$FloatHandle &MF_STRING, FloatDelBp, FloatDelBpString
        mov eax D$BpOnTable
        If D$eax+4 <> 0
            call 'USER32.AppendMenuA' D$FloatHandle, &MF_STRING, FloatDelAllBp,
                                      FloatDelAllBpString
        End_If

    .End_If

    call 'USER32.HiliteMenuItem' D$EditWindowHandle, D$FloatHandle, 0,
                                 &MF_BYPOSITION__&MF_HILITE

  ; Create the KeyBoard Hook:
    mov D$FirstStrike 0
    call 'KERNEL32.GetCurrentThreadId'
    call 'USER32.SetWindowsHookExA' &WH_KEYBOARD, KeyBoardProc, &NULL, eax ; <<<<<<<<<<<
    mov D$hHook eax

  ; Menu Position:
    push D$CaretRow
        mov D$CaretRow 1 | call FromCaretPosToScreen
    pop D$CaretRow
    call 'USER32.TrackPopupMenu' D$FloatHandle, &TPM_LEFTALIGN , eax, ebx, 0,
                                D$EditWindowHandle, &NULL

    call 'USER32.UnhookWindowsHookEx' D$hHook

    call 'USER32.DestroyMenu' D$FloatHandle
ret
____________________________________________________________________________________________

[InsideBpTable: ?]

IsEaxInBpOnTable:
    mov ebx D$BpOnTable

    While D$ebx <> 0
        If D$ebx = eax
            mov B$InsideBpTable &TRUE | ret
        End_If
        add ebx 4
    End_While

    mov B$InsideBpTable &FALSE
ret
____________________________________________________________________________________________

; 01000 Bytes (0400 dwords) >>> 2*512 dWords

[BreakPointsTables: BpOnTable: ?    BpOffTable: ?]

; No need to ever clear, as, each time a new file is loaded, the Table is released
; by 'ReInitUndo', at the same time other features are reset.

InitBreakPointsTables:
    pushad
        VirtualAlloc BreakPointsTables 01000
        add eax 0800 | mov D$BpOffTable eax
    popad
ret

____________________________________________________________________________________________
;;
  Routines called on user choice in the BP Float Menu
  
  We reuse 'DebugDialogHandle' (set to 1 in case of Mouse BP without Debugger Runing
  and to zero if none), in order to forbid editing Sources with Mouse defined BP inside
;;

SetBreakpoint:
    call RestoreRealSource

; >>> UPDATED
    If D$BPAnteroom <> 0
        call AddBPToAnteroom D$BreakPointLocation &TRUE
    EndIf
; <<< UPDATED

    ;call DoStoreBP

    mov eax D$BreakPointLocation, edi D$BpOnTable

    While D$edi <> 0
        add edi 4
    End_While

  ; What we are storing is the real pos, in the real Source:

    stosd

    mov B$ReadyToRun &FALSE

    call SortBpOnTable

    call SetPartialEditionFromPos
ret


DeleteBreakpoint:
    call RestoreRealSource

; >>> UPDATED
    If D$BPAnteroom <> 0
        call AddBPToAnteroom D$BreakPointLocation &FALSE
    EndIf
; <<< UPDATED

    mov eax D$BreakPointLocation
    mov esi D$BpOnTable

    While D$esi <> eax
        add esi 4 | On D$esi = 0, ret
    End_While

    mov edi esi | add esi 4
    While D$esi <> 0 | movsd | End_While
    mov D$edi 0
    mov B$ReadyToRun &FALSE

    call SetPartialEditionFromPos
ret


DeleteAllBreakpoints:
    mov edi D$BpOnTable

    While D$edi <> 0
        mov eax D$edi
        call StoreUserAction ACTION_DELDCBP, eax, &NULL
        mov D$edi 0 | add edi 4
    End_While

    mov B$ReadyToRun &FALSE
ret


; For the Undo Feature:

DoStoreBP:
    call StoreUserAction ACTION_DCBP, D$BreakPointLocation, &NULL
ret

DoStoreRemoveBP:
    call StoreUserAction ACTION_DELDCBP, D$BreakPointLocation, &NULL
ret

;;
  The Undo is done without any need of some 'UnDoStoreBP' Routine, as this is done by:
  'AdjustBpTable' and 'AdjustDownwardPointers'.
;;


; This first one is called from 'SetBreakpoint' so that the Pointers are always sorted:

SortBpOnTable:
  ; Sort BpOnTable:
    mov esi D$BpOnTable, ecx 0
    While D$esi <> 0 | add esi 4 | add ecx 4 | End_While
    call BubbleSort D$BpOnTable, ecx

  ; Init the Pointer to 'BpOnTable' for insertions:
  ;  move D$BpOnTablePtr D$BpOnTable
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  If the user mofifies the Source with BreakPoints inside, we have to modify the
  Table Pointers accordingly.
  
  We make use of the Undo Table ('UndoMemory') Records to achieve this.
  
  This 'AdjustBpTable' Routine is called from:
  
  'DoStoreInsert', 'DoStoreCharDelete'
  'DoStoreBlockPaste', 'WriteUndoBlockFile'
  'ControlZ'
;;

; Called from 'StoreUserAction', 'ControlZ, 'ControlShiftZ'.

Proc AdjustBpTable:
    Argument @Type

    pushad
        mov esi D$UndoPtr, eax D@Type

        If eax = ACTION_INSERT
            mov eax D$esi+RECORD_CURRENTWRITINGPOS
;;
  The calls to 'DoStoreInsert' are dones after the Insertion. So, we have to
  substract the Number of inserted Chars:
;;
            sub eax D$esi+RECORD_PARAM1

        Else_If eax = ACTION_BLOCKCOPY
            mov eax D$esi+RECORD_CURRENTWRITINGPOS

        Else_If eax = ACTION_BLOCKDELETE
            mov eax D$esi+RECORD_CURRENTWRITINGPOS

        Else_If eax = ACTION_DEL
            mov eax D$esi+RECORD_CURRENTWRITINGPOS

        Else_If eax = ControlZ
            mov eax D$esi+RECORD_CURRENTWRITINGPOS

        Else_If eax = ControlShiftZ
            mov eax D$esi+RECORD_CURRENTWRITINGPOS

        Else ; ACTION_OVERWRITE, ACTION_DCBP, ACTION_DELDCBP
            popad | ExitP

        End_If

        If D$ActualTitle <> 0
            add eax D$ActualTitle
        Else
            add eax D$CodeSource
        End_If

        mov edi D$BpOnTable

        While D$edi <> 0
            If eax < D$edi
                call AdjustDownwardPointers, D@Type | popad | ExitP
            End_If
            add edi 4
        End_While
    popad
EndP


Proc AdjustDownwardPointers:
    Argument @Type
      ; esi >>> last record in the UndoTable
      ; edi >>> first 'BpOnTable' Pointer coming downward from the 'CurrentWritingPos'
      ;
      ; Displacement Table are the ones from 'UndoPtr'

        mov eax D$esi+RECORD_FLAG, ecx 0

        .If eax = ACTION_INSERT
          ;' n Chars':
            mov ecx D$esi+RECORD_PARAM1

        .Else_If eax = ACTION_DEL
            call DeleteBpOnDelCRLF
            mov ecx 0-1

        .Else_If eax = ACTION_BLOCKDELETE
            call DeleteBpInBlock
           ; Selected Block length:
            mov ecx D$esi+RECORD_PARAM2 | sub ecx D$esi+RECORD_PARAM1 | inc ecx
            neg ecx

        .Else_If eax = ACTION_BLOCKCOPY
          ; 'ClipBoardLen' used in ControlV
            mov ecx D$esi+RECORD_PARAM2 | sub ecx D$esi+RECORD_PARAM1 | inc ecx
;;
        .Else_If eax = ACTION_DCBP
          ;; CurrentWritingPos:
          ;  mov eax D$esi+8
          ;  If D$TitleTable = 0
          ;      add eax D$CodeSource
          ;  Else
          ;      add eax D$ActualTitle
          ;  End_If
          ;  mov D$BreakPointLocation eax
          ;  call DeleteBreakpoint | ExitP
          
          ExitP
          
        .Else_If eax = ACTION_DELDCBP
            ExitP
;;
        .Else
            ExitP

        .End_If

      ; ControlZ cases:
        If D@Type = ControlZ
            neg ecx
            mov eax D$CurrentWritingPos | On B$eax-1 = LF, dec ecx
        End_If

        While D$edi <> 0
            add D$edi ecx | add edi 4
        End_While
EndP


DeleteBpInBlock:
    pushad
        mov ebx D$BlockStartTextPtr, edx D$BlockEndTextPtr | inc edx
;;
  The user is deleting a Selected Block with BreakPoints inside. Remove these BPs.
  
  The Selection Values are the real Edition ones. If TITLEs inside, we have to switch
  to the real Source. If no TITLE inside, the Values are the real Source ones and we
  have nothing to do, even though this Routine is called from:
  
  'StoreUserAction' >>> 'AdjustBpTable'  >>> 'AdjustDownwardPointers'
;;
        If D$TitleTable <> 0
            sub ebx D$CodeSource | add ebx D$ActualTitle
            sub edx D$CodeSource | add edx D$ActualTitle
        End_If

        mov esi D$BpOnTable

        .While D$esi <> 0
            lodsd
            .If eax >= ebx
                If eax <= edx
                    push esi
                      ; Direct Delete of concerned BP:
                        mov edi esi | sub edi 4
                        While D$esi <> 0 | movsd | End_While
                        mov D$edi 0
                    pop esi
                End_If
            .End_If
        .End_While
    popad
ret
____________________________________________________________________________________________

; If the user [Del]s a CRLF followed by a DCBP, we remove it:

DeleteBpOnDelCRLF:
    pushad
        mov ebx D$esi+RECORD_CURRENTWRITINGPOS

        If D$TitleTable <> 0
            add ebx D$ActualTitle
        Else
            add ebx D$CodeSource
        End_If

        inc ebx

        mov esi D$BpOnTable

        .While D$esi <> 0
            lodsd
            If eax = ebx
              ; Direct Delete of concerned BP:
                mov edi esi | sub edi 4
                While D$esi <> 0 | movsd | End_While
                mov D$edi 0 | jmp L9>
            End_If
        .End_While
L9: popad
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; These are the Routines called by the Source Editor (at the end of 'TextOutput')

[RedPlotSize: ?   RedPlotX: ?]

DrawTheRedPlots:
    mov eax D$FontHeight | shl eax 1 | add eax D$FontWidth | shr eax 2
    mov D$RedPlotSize eax
    mov eax D$BpMarginWidth | sub eax D$RedPlotSize | shr eax 1
    mov D$RedPlotX eax

    call 'User32.BeginPaint' D$BpWindowHandle, PAINTSTRUCT | mov D$hdc eax

    call 'GDI32.SelectObject' D$hdc D$RedBrushHandle
    call 'GDI32.SelectObject'  D$hdc D$Font1Handle | mov D$hfont eax
    call 'GDI32.SetBkColor' D$hdc D$NormalBackColor

    mov ecx D$LineNumber, D$Line 0 | inc ecx | inc ecx

L0: push ecx
        call 'GDI32.TextOutA' D$hdc, 0, D$Line, BlankLine, 2
    pop ecx
    mov eax D$FontHeight | add D$Line eax | dec ecx | cmp ecx 0 | jne L0<

    mov esi D$UpperLine, D$Line 0

    While esi < D$LastCharPosOnScreen
        If B$esi-1 = LF
            push esi
                call DrawIfEsiInBreakPointsTable
            pop esi
        End_If
        inc esi
        If B$esi = LF
            mov eax D$FontHeight | add D$line eax
        End_If
    End_While

    call DrawTheBpLine

    call 'USER32.EndPaint' D$BpWindowHandle, PAINTSTRUCT
ret


BlankMargin:
    call 'User32.BeginPaint' D$BpWindowHandle, PAINTSTRUCT | mov D$hdc eax

    call 'GDI32.SetBkColor' D$hdc D$NormalBackColor
    call 'GDI32.SelectObject' D$hdc D$Font1Handle

    mov ecx D$LineNumber, D$Line 0 | inc ecx | inc ecx

L0: push ecx
        call 'GDI32.TextOutA' D$hdc, 0, D$Line, BlankLine, 2
    pop ecx
    mov eax D$FontHeight | add D$Line eax | dec ecx | cmp ecx 0 | jne L0<

    call DrawTheBpLine

    call 'USER32.EndPaint' D$BpWindowHandle, PAINTSTRUCT
ret


DrawIfEsiInBreakPointsTable:
    mov ebx D$BpOnTable

    .If B$RealSourceRestored = &FALSE
        If D$ActualTitle <> 0
            sub esi D$CodeSource | add esi D$ActualTitle
        End_If
    .End_If

    .While D$ebx <> 0
        If D$ebx = esi
            push esi, ebx
              ; Draw one Break-Point:
                mov eax D$RedPlotX
                mov ebx D$Line
                mov ecx eax | add ecx D$RedPlotSize
                mov edx ebx | add edx D$RedPlotSize
                call 'GDI32.Ellipse' D$hdc, eax, ebx, ecx, edx
            pop ebx, esi
        End_If

        add ebx 4

    .End_While
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  This is a fully _un-tested_ ;) example about the way to switch from a dword found in
  the BP Tables -in form of Pointer to User Source- to a dword pointing to the Debuggee
  App Address space Code.
;;

; UPDATED >>>

Proc GetcodeBreakPointPosFromSourcePointer:
    Argument @SourcePtr

        mov eax D@SourcePtr, esi D$StatementsTable, edx D$StatementsPtr
        mov ebx D@SourcePtr

      ; 'edx' (D$StatementsPtr) should still point to the last record of 'StatementsTable'
      ; it doesn't :?

        While D$esi <> 0
            On D$esi >= eax, jmp L1>
;;
  Why '>=', up there? This is because the registred Sources Pointers, in the BP Tables,
  may point, for example, to leading spaces, and such (cases of Indents, Blank lines,
  Square Brackets Declarations,...).
;;
            add esi 4
        End_While

;;
  At 'L1:', edi should point to the Record of the searched Location in the 
  'StatementsTable' dwords Pointers Table. Now, get the Matching Code one:
;;
L1:     sub esi D$StatementsTable | add esi D$IpTable | lodsd
;;
  'eax' should now be a Pointer to Code as viewed by the Encoder. There is an
  adjustement variable called 'DebugBaseOfCode' that should enable with the true
  location inside the Debuggee App real Address space. (It is computed by 'SetCodeRVA')
  To be verified by experiment, but i think you should now say:
;;
        add eax D$DebugBaseOfCode

      ; 'eax' should ready as Return value...
EndP

; <<<
____________________________________________________________________________________________
____________________________________________________________________________________________




TITLE Tag


;;
  Tag Feature:
  
  When a commented out 'Tag' KeyWord is found out (Right-Click feature), these Parsers
  are run and branced to the according associated action.
  
  First implementation, for test, if:
_________________

; Tag Dialog 1000
_________________

  'WizardTag' 'NewWizardForm'

  is written in some Source, when Right-Clicking on 'Tag', and if the Edited PE Resources
  contain a Dialog with an ID 1000 (Decimal only), the Dialog Editor should be run.
;;

____________________________________________________________________________________________
____________________________________________________________________________________________

; General purpose Routines: 'IsItTag', 'TagParser', 'NoSuchTag', 'TagDecimalToBin', 'NewWizardForm', 'WizardFormTag'

; When called from 'RightClick' > 'InternalRightClick', esi+1 point to 'Tag '

IsItTag:
    push esi
  ; Is it a Comment?
L0:     If B$esi = ';'
            ; OK
        Else_If B$esi = ' '
            dec esi | jmp L0<
        Else
            pop esi | mov eax &FALSE | ret
        End_If

    pop esi
    mov eax &TRUE
ret
____________________________________________________________________________________________

TagParser:
  ; Check for the Tag KeyWords:
  ; 'Dialog' or 'Wizard'

  ; esi > 'tag '
    add esi 4 | While B$esi = ' ' | inc esi | End_While
    mov eax D$esi | or eax 020202020
  ; "Tag Dialog DialogID":
    ...If eax = 'dial'
        mov ax W$esi+4 | or ax 02020
        .If ax = 'og'
            If B$esi+6 = ' '
                mov B$ReadyToRun &FALSE
                add esi 7 | jmp DialogTag
            End_If
        .End_If
  ; "Tag Wizard WizardName 'Path...........' ":
    ...Else_If eax = 'wiza'
        mov ax W$esi+4 | or ax 02020
        .If ax = 'rd'
            If B$esi+6 = ' '
                mov B$ReadyToRun &FALSE
                add esi 6 | jmp WizardTag
            End_If
        .End_If
  ; "Tag Unicode LabelName":
    ...Else_If eax = 'unic'
        mov eax D$esi+3 | or eax 020202020
        .If eax = 'code'
            If B$esi+7 = ' '
                mov B$ReadyToRun &FALSE
                add esi 8 | jmp UnicodeTag
            End_If
        .End_If
  ; "Tag Menu MenuID":
    ...Else_If eax = 'menu'
        If B$esi+4 = ' '
            mov B$ReadyToRun &FALSE
            add esi 5 | jmp MenuTag
        End_If

    ...End_If

    call 'USER32.MessageBoxA' D$hwnd, {'Unknown Tag KeyWord', 0}, {'No such Tag', 0}, 0
ret


TagDecimalToBin:
    mov ecx 0, eax 0

L0: lodsb
    cmp al ' ' | jbe L9>
    cmp al '9' | ja L8>
    cmp al '0' | jb L8>
        sub al '0'                  ; convert Decimal to binary:
        lea ecx D$ecx+ecx*4         ;     ecx = ecx * 5
        lea ecx D$eax+ecx*2         ;     ecx = eax + old ecx * 10
    jmp L0<

L8: call 'USER32.MessageBoxA' D$hwnd, {"Tags' Numbers are to be provided in Decimal notation", 0},
                              {'Bad Number', 0}, 0
    mov eax &FALSE | ret

L9: mov eax &TRUE | ret

____________________________________________________________________________________________

; "Tag Dialog" Routines:

; "; Tag Dialog " found // esi on next possible ID

DialogTag:
    While B$esi = ' ' | inc esi | End_While

    call TagDecimaltoBin

    .If eax = &TRUE
        mov eax ecx

        If eax = 0
            ; nope
        Else_If eax > 0_FFFF
            ; nope
        Else
            call GetTagedDialog
        End_If
    .End_If
ret

____________________________________________________________________________________________

; Simplified version of the 'LoadFromResources' executed by Menu Selection:

GetTagedDialog:
    If B$OnDialogEdition = &TRUE
        Beep | ret  ; prevents from multi-runs
    End_If

    push eax
        call ReleaseDialogMemories | call InitDialogMemory
    pop eax

    mov esi DialogList, D$MenuListPtr esi      ; 1 record:  ID / Ptr / Size

L0: .If D$esi = eax
        mov D$WhatDialogListPtr esi | add D$WhatDialogListPtr 4  ;DialogList+4

        mov ebx D$WhatDialogListPtr, ebx D$ebx
        If W$ebx+18 = 0
            mov D$ActualMenutestID 0, D$DialogMenuTrueID 0
        Else
            movzx eax W$ebx+20 | mov D$DialogMenuTrueID eax
            mov esi MenuList
            While D$esi <> eax
                add esi 12
            End_While
            mov D$MenuListPtr esi
            add esi 4
            call 'User32.LoadMenuIndirectA' D$esi | mov D$ActualMenutestID eax
        End_If

        mov B$DialogLoadedFromResources &TRUE
        call FromBinToTextTemplate
        call ReInitDialogEdition

    .Else_If D$esi = 0
        call 'USER32.MessageBoxA' D$hwnd, {'No Dialog found with matching ID Number', 0},
                                  {'Bad ID', 0}, 0
    .Else
        add esi 12 | jmp L0<<
    .End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
[WizardCommandLine: ?  #512]
[ApplicationPath:   ? #&MAX_PATH]
[NewFormPath:       ? #&MAX_PATH]
[ProducedCode_BeginWrite: ?    ProducedCode_Written: ?
 ProducedCodeHandle:      ?    ProducedCode:         ?
 WizardSearchHandle:      ?]

[WizardName: 'WZRD010Form.exe', 0]

[WizardSaving:
 @dwFileAttributes: D$ 0
 @ftCreationTime.dwLowDateTime: D$ 0
 @ftCreationTime.dwHighDateTime: D$ 0
 @ftLastAccessTime.dwLowDateTime: D$ 0
 @ftLastAccessTime.dwHighDateTime: D$ 0
 @ftLastWriteTime.dwLowDateTime: D$ 0
 @ftLastWriteTime.dwHighDateTime: D$ 0
 @nFileSizeHigh: D$ 0
 @nFileSizeLow: D$ 0
 @dwReserved0: D$ 0
 @dwReserved1: D$ 0]
[@cFileName: B$ 0 #&MAX_PATH]
[@cAlternate: B$ 0 #14]

; tag example :
; >  ; Tag Wizard Form "C\MyPath\MyFolder\MyFile.wwf" -R

; esi points on the space after "; Tag wizard"
WizardTag:

    If D$DebugDialogHandle <> 0
          push esi | call KillDebugger | pop esi | On eax = &IDNO, ret
    End_If

    ;push D$CurrentWritingPos
    mov D$CurrentWritingPos esi
    call SetPartialEditionFromPos
    mov esi D$CurrentWritingPos

    ; selects the wizard
    mov eax D$esi+1
    or eax 020202020
    If eax = 'form'

        call WizardFormTag
    ;  ; Temporary add, because of the new 'ControlZ', that does not work on the Full Source:
    ;    call ReInitUndo
    Else_If eax = 'test'
        ;jmp WizardFormTest
    End_If

    call RestoreRealSource

    call ReInitUndoOnly
ret
____________________________________________________________________________________________
WizardFormTest:
    call CheckTagEndPos | On eax = &FALSE, ret
    call DeleteLastWizardCode esi
ret
____________________________________________________________________________________________
WizardFormTag:

    call CheckTagEndPos | On eax = &FALSE, ret

    ; retrieves Wizard Path :
    push esi
        call GetRosAsmFilesPath
        mov esi RosAsmFilesPath | mov edi WizardPath
        While B$esi <> 0 | movsb | End_While
        mov esi WizardName
        While B$esi <> 0 | movsb | End_While | mov B$edi 0
    pop esi

    ; set esi on the character after the first double quote following 'Tag Wizard Form'
    While B$esi <> '"' | inc esi | End_While | inc esi

    ; => command line writing:
    mov edi WizardCommandLine

    ;    * Wizard FileName
    mov B$edi '"' | inc edi
    push esi
        mov esi WizardPath
        While B$esi <> 0 | movsb | End_While
    pop esi
    mov B$edi '"' | inc edi

    ;    * File location
    mov D$edi '-f "'  | add edi 4
    While B$esi <> '"' | movsb | End_While
    mov W$edi '" ' | add edi 2

    ;    * RosAsm ID
    mov W$edi '-R'  | add edi 2 | mov B$edi 0 | inc edi

    call LoadWizardAndPasteCode esi

ret
____________________________________________________________________________________________
Proc DeleteLastWizardCode:
    Argument @TagBegin
    Uses edx

    mov esi D@TagBegin
    While B$esi <> LF | dec esi | End_While | inc esi | mov edx esi
    While esi <= D$SourceEnd
        .If W$esi = ((59 shl 8) or LF)
            mov eax D$esi+3 | or eax 0202020
            If eax = 'tag '
                mov eax D$esi+6 | or eax 020202000
                On eax = ' end', jmp L1>
                ExitP
            End_If
        .End_If
        inc esi
    End_While
    ; should not be accessed ( checked before)
    ExitP

L1: While B$esi <> CR | inc esi | End_While | dec esi | mov D$BlockEndTextPtr esi
    mov D$BlockStartTextPtr edx
    mov B$BlockInside &TRUE
    mov D$CaretRow 1              ; the caret is set at the beginning of the block
    mov D$PhysicalCaretRow 1      ;
    mov eax D$CaretRow, ebx D$CaretLine | call SearchTxtPtr
    mov D$CurrentWritingPos eax
    call ControlD

    ;ControlZ

EndP
____________________________________________________________________________________________
Proc CheckTagEndPos:
    Uses esi

    While B$esi <> LF | dec esi | End_While | inc esi | mov edx esi
    While esi <= D$SourceEnd
        .If W$esi = ((59 shl 8) or LF)
            mov eax D$esi+3 | or eax 0202020
            If eax = 'tag '
                mov eax D$esi+6 | or eax 020202000
                On eax = ' end', jmp L1>
                jmp L2>
            End_If
        .End_If
        inc esi
    End_While

L2: call 'USER32.MessageBoxA' D$hwnd,
{"Can't find '; Tag End' mark.
Write it back and try again ;o)", 0},  {"Error", 0}, &MB_ICONERROR
    mov eax &FALSE
    ExitP

L1: mov eax &TRUE

EndP
____________________________________________________________________________________________
Proc AddWizardCode:
    Argument @WizardCodePtr @WizardCodeLen
    Uses D$ClipBoardLen

    move D$ClipBoardLen D@WizardCodeLen

    call ReMapSourceMemoryIfNeeded D$ClipBoardLen | On eax = &IDNO, ret

    call DoStoreBlockPaste

    mov esi D$SourceEnd | add esi 400                       ; make room inside our text:
    mov edi esi | add edi D$ClipBoardLen
    mov ecx esi | sub ecx D$CurrentWritingPos | inc ecx
    std | rep movsb | cld | inc esi
                                                            ; write from clipboard:
    mov edi esi, esi D@WizardCodePtr, ecx D$ClipBoardLen
    pushad | rep movsb | popad
                                                            ; position:
    mov esi edi, ebx D$CaretLine
L0: lodsb | inc D$CaretRow | cmp al CR | jne L1>
        inc ebx | mov D$CaretRow 1 | lodsb | dec ecx | jz L0>
L1: loop L0<

L0: cmp ebx D$LineNumber | jna L6>
        mov esi D$UpperLine | mov ecx ebx | sub ecx D$CaretLine
L1:     lodsb | cmp al LF | jne L1<
            mov D$UpperLine esi | dec ebx | jmp L0<

L6: mov D$CaretLine ebx

    mov eax D$ClipBoardLen
    add D$SourceLen eax | add D$SourceEnd eax | add D$CurrentWritingPos eax


EndP
____________________________________________________________________________________________
NewWizardForm:

    .If D$DebugDialogHandle <> 0
          call KillDebugger | If eax = &IDNO | pop esi | ret | End_If
    .End_If

    call 'User32.MessageBoxA' &NULL {'Set the caret where you want the code to be pasted, and click OK.',0},
                              {'Wait a minute...',0}    &MB_ICONEXCLAMATION+&MB_SYSTEMMODAL


    call GetRosAsmFilesPath
    mov esi RosAsmFilesPath | mov edi WizardPath
    While B$esi <> 0 | movsb | End_While
    mov esi WizardName
    While B$esi <> 0 | movsb | End_While | mov B$edi 0


    call 'Kernel32.GetCurrentDirectoryA' &MAX_PATH NewFormPath
    mov esi NewFormPath | add esi eax
    mov D$esi '\Wiz' | add esi 4 | mov D$esi 'ardF' | add esi 4 | mov D$esi 'iles' | add esi 4
    mov B$esi 0

    push esi | call 'Kernel32.CreateDirectoryA' NewFormPath &NULL | pop esi

    mov D$esi '\WZR' | add esi 4 | mov D$esi 'DFor' | add esi 4 | mov D$esi 'm*.w' | add esi 4
    mov W$esi 'wf'   | add esi 2 | mov B$esi 0

  push esi
    ; looks for existing wizard files in the '\WizardFiles\' sub-directory of the program's directory
    call 'Kernel32.FindFirstFileA' NewFormPath WizardSaving
    mov D$WizardSearchHandle eax
    xor ecx ecx
    If eax <> &INVALID_HANDLE_VALUE
L1:     push ecx | call 'Kernel32.FindNextFileA' D$WizardSearchHandle WizardSaving | pop ecx
        inc ecx
        cmp eax 0 | jnz L1<
        push ecx | call 'Kernel32.FindClose' D$WizardSearchHandle | pop ecx
    End_If
  pop esi

    ; creates the new file name according to the number of already existing files
    mov ebx ecx | mov edi esi | sub edi 2
    std
        mov ecx, 4
L1:     mov al bl | and al 0F | On al >= 0A, add al 7
        add al, '0' | stosb | shr ebx, 4 | loop L1
    cld
    mov D$esi-1 '.wwf' | mov B$esi+3 0


    ; => command line writing:
    mov edi WizardCommandLine

    ;    * Wizard FileName
    mov B$edi '"' | inc edi
    mov esi WizardPath
    While B$esi <> 0 | movsb | End_While
    mov B$edi '"' | inc edi

    ;    * File location
    mov D$edi '-f "'  | add edi 4
    mov esi NewFormPath
    While B$esi <> 0 | movsb | End_While
    mov W$edi '" ' | add edi 2

    ;    * create the Wizard File
    mov W$edi '-c'  | add edi 2 | mov B$edi 020 | inc edi

    ;    * RosAsm ID
    mov W$edi '-R'  | add edi 2 | mov B$edi 0 | inc edi

    call LoadWizardAndPasteCode &FALSE

    call ReInitUndoOnly
ret

____________________________________________________________________________________________
Proc LoadWizardAndPasteCode:
    Argument @TagBegin

    call 'Kernel32.CreateEventA' &NULL &FALSE &FALSE {'ProducedCode_BeginWrite',0}
    mov D$ProducedCode_BeginWrite eax

    call 'Kernel32.CreateProcessA' WizardPath WizardCommandLine 0 0  0  0 0 0  STARTUPINFO  ProcessInfos
    If eax = 0
        call 'User32.MessageBoxA' &NULL {"The Wizard cannot be loaded.",0},
                                        ErrorMessageTitle   &MB_ICONEXCLAMATION+&MB_SYSTEMMODAL
        jmp L9>>
    End_If
    call 'Kernel32.WaitForSingleObject' D$ProducedCode_BeginWrite &INFINITE  ; wait while the user uses the wizard

    ; open the shared memory where the code has been written.
    ; the first DWord of this data is the code length.
    call 'Kernel32.OpenFileMappingA' &FILE_MAP_ALL_ACCESS 0 {'RosAsmWizardProducedCode',0}
    mov D$ProducedCodeHandle eax
    call 'Kernel32.MapViewOfFile' D$ProducedCodeHandle &FILE_MAP_ALL_ACCESS 0 0 0 | mov edx eax
    mov D$ProducedCode edx | add D$ProducedCode 4

    If D$edx <> 0
        On D@TagBegin <> &FALSE, call DeleteLastWizardCode D@TagBegin
        call AddWizardCode D$ProducedCode D$edx
    Else
        On D@TagBegin = &FALSE, call 'Kernel32.DeleteFileA' NewFormPath
    End_If

    call 'Kernel32.OpenEventA' &EVENT_MODIFY_STATE &FALSE {'ProducedCode_Written',0}
    mov D$ProducedCode_Written eax
    call 'Kernel32.SetEvent' D$ProducedCode_Written

L9: call 'Kernel32.CloseHandle' D$ProducedCode_BeginWrite

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

 ; Tag Unicode MyUnicodeString

[MyUnicodeString: W$ 06D, 06C, 06B, 06D, 06C, 06B, 06D, 06C, 06B, 0D, 0A,
                     06D, 06D, 06C, 06B, 06D, 06C, 06B, 0D, 0A, 06C, 06B,
                     06A, 06C, 06A]

UnicodeTag:
  ; esi points to 'MyUnicodeString', inside "; Tag Unicode MyUnicodeString":
    call 'USER32.DialogBoxParamW' D$hinstance, 600, &NULL, UnicodeEditorProc, esi
ret


[UnicodeEditorHandle: ?, UnicodeDataPointer: ?]

; Tag Dialog 600

Proc UnicodeEditorProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_INITDIALOG
        move D$UnicodeEditorHandle D@Adressee, D$UnicodeDataPointer D@lParam

        call 'USER32.SetClassLongW' D@Adressee, &GCL_HICON, D$wc_hIcon

        call LoadUnicodeEditorFont

        On D$UnicodeEditorFontHandle <> 0,
            call 'USER32.SendDlgItemMessageW' D@Adressee, 10, &WM_SETFONT,
                                              D$UnicodeEditorFontHandle, &TRUE

        call SetUnicodeDialogContent | jmp L8>>

    ...Else_If D@Message = &WM_COMMAND
        mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        .If D@wParam = &IDCANCEL
            If D$UnicodeEditorFontHandle <> 0
                call 'GDI32.DeleteObject' D$UnicodeEditorFontHandle
                mov D$UnicodeEditorFontHandle 0
            End_If

            call 'User32.DestroyWindow' D@Adressee

        .Else_If D@wParam = &IDOK
          ; The call is from inside the Right-Click, with full Source restored. So:
            call SetPartialEditionFromPos
                call PasteUnicodeDialogContent
            call RestoreRealSource

            If D$UnicodeEditorFontHandle <> 0
                call 'GDI32.DeleteObject' D$UnicodeEditorFontHandle
                mov D$UnicodeEditorFontHandle 0
            End_If

            call 'User32.DestroyWindow' D@Adressee

        .Else_If D@wParam = 3
            call GetUnicodeEditorFont

            If D$UnicodeEditorFontHandle <> 0
                call 'USER32.SendDlgItemMessageW' D@Adressee, 10, &WM_SETFONT,
                                              D$UnicodeEditorFontHandle, &TRUE
                call UpdateRegistry
            End_If
;;
; Does not work, at all:

        .Else_If D@wParam = 4
            call 'USER32.GetDlgItem' D@Adressee, 10
            push eax
                call 'USER32.GetWindowLongW' eax, &GWL_STYLE
                xor eax &ES_AUTOHSCROLL__&WS_HSCROLL
            pop ebx
            call 'USER32.SetWindowLongW' ebx, &GWL_STYLE, eax
;;
        .End_If

    ...Else_If D@Message = &WM_CTLCOLOREDIT
        call 'USER32.SendMessageA' D@lParam, &EM_SETSEL, 0-1, 0
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | ExitP


    ...Else
L8:     popad | mov eax &FALSE | ExitP

    ...End_If

    popad | mov eax &TRUE
EndP


[UNICODE_EDITION_CHOOSEFONT: ; EditorCHOOSEFONT
 @lStructSize: D$ len
 @hwndOwner: D$ 0
 @hDC: D$ 0
 @lpLogFont: D$ UNICODE_EDITION_LOGFONT
 @iPointSize: D$ 0
 @Flags: D$ &CF_SCREENFONTS__&CF_INITTOLOGFONTSTRUCT
 @rgbColors: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0
 @hInstance: D$ 0
 @lpszStyle: D$ &SCREEN_FONTTYPE
 @nFontType: W$ 0
 @Alignment: W$ 0
 @nSizeMin: D$ 0
 @nSizeMax: D$ 0]

[UNICODE_EDITION_LOGFONT:
 @lfHeight: D$ 0
 @lfWidth: D$ 0
 @lfEscapement: D$ 0
 @lfOrientation: D$ 0
 @lfWeight: D$ 0
 @lfItalic: B$ 0
 @lfUnderline: B$ 0
 @lfStrikeOut: B$ 0
 @lfCharSet: B$ 0
 @lfOutPrecision: B$ 0
 @lfClipPrecision: B$ 0
 @lfQuality: B$ 0
 @lfPitchAndFamily: B$ 0
 @lfFaceName: U$ 0 #&LF_FACESIZE
 UNICODE_EDITION_LOGFONTlen: len]

[UnicodeEditorFontHandle: ?]

LoadUnicodeEditorFont:
    If D$UnicodeEditorFontHandle = 0
        call 'GDI32.CreateFontIndirectA' UNICODE_EDITION_LOGFONT
        mov D$UnicodeEditorFontHandle eax
    End_If
ret


GetUnicodeEditorFont:
    move D$UNICODE_EDITION_CHOOSEFONT@hwndOwner D$UnicodeEditorHandle
    call 'Comdlg32.ChooseFontW' UNICODE_EDITION_CHOOSEFONT

    If eax = &TRUE
        On D$UnicodeEditorFontHandle <> 0, call 'GDI32.DeleteObject' D$UnicodeEditorFontHandle
        call 'GDI32.CreateFontIndirectW' UNICODE_EDITION_LOGFONT
        mov D$UnicodeEditorFontHandle eax
    End_If
ret


[AddedCRLF: ?, UnicodeDataInsertionPoint: ?, UnicodeValuesAlignment: ?
 NumberOfUnicodeChars: ?]

PasteUnicodeDialogContent:
    mov esi D$UnicodeDataPointer
    call InternalRightClick
    If B$BlockInside = &TRUE
        mov esi D$BlockStartTextPtr
        While B$esi <> '[' | dec esi | End_While
        mov D$BlockStartTextPtr esi, D$UnicodeDataInsertionPoint esi

        mov esi D$BlockEndTextPtr
        While B$esi <> ']' | inc esi | End_While
        mov D$BlockEndTextPtr esi
        call ControlD

        mov B$AddedCRLF &FALSE

    Else
        mov B$AddedCRLF &TRUE

        mov esi D$UnicodeDataPointer
        While B$esi >= ' ' | inc esi | End_While
        mov D$UnicodeDataInsertionPoint esi

    End_If

    ;    mov ebx D$UnicodeDataPointer
    ;    While B$ebx > CR | inc ebx | End_While | add ebx 2

    call 'USER32.SendDlgItemMessageW' D$UnicodeEditorHandle, 10, &WM_GETTEXTLENGTH,
                                      D$UnicodeEditorFontHandle, &FALSE
    add eax 100
    push eax
        shl eax 1 | VirtualAlloc Trash1 eax
    pop eax

    push eax
        call 'USER32.SendDlgItemMessageW' D$UnicodeEditorHandle, 10, &WM_GETTEXT,
                                          eax, D$Trash1
    pop eax

  ; Max = 7 Char ("0FFFF, ") >>> 8 + Alignements (....) >>>> 32
    shl eax 5 | VirtualAlloc Trash2 eax

    mov edi D$Trash2

    If B$AddedCRLF = &TRUE
        mov D$edi CRLF2 | add edi 4
    End_If

    mov B$edi '[', ecx edi | inc edi

  ; Write the Data Label to the Tempo Buffer:
    mov esi D$UnicodeDataPointer
    While B$esi > ' ' | movsb | End_While
    mov D$edi ': U$', B$edi+4 ' '| add edi 5

  ; Alignement count:
    sub ecx edi | neg ecx | mov D$UnicodeValuesAlignment ecx

    mov esi D$Trash1, ecx 0, D$NumberOfUnicodeChars 0
    .While W$esi <> 0
        movzx eax W$esi| add esi 2 | call WriteEax | mov W$edi ', ' | add edi 2 | inc ecx
        inc D$NumberOfUnicodeChars
      ; New Line when wished:
        If ecx = 11
            mov ecx 0
            mov W$edi CRLF | add edi 2
            mov ecx D$UnicodeValuesAlignment
            While ecx > 0 | mov B$edi ' ' | dec ecx | inc edi | End_While
        End_If
    .End_While

  ; Remove the possible CRLF and ',', at the end of the buffer:
    While B$edi <= ' ' | dec edi | End_While | On B$edi = ',', dec edi
    inc edi

  ; Cases of empty Edition:
    If W$edi-2 = 'U$'
        mov W$edi ' 0' | add edi 2
    Else
        mov D$edi ', 0]' | add edi 3
    End_If

    mov W$edi CRLF | add edi 2
    mov esi D$UnicodeDataPointer
    mov B$edi ' ' | inc edi
    While B$esi > ' ' | movsb | End_While
    mov D$edi 'Ncha', D$edi+4 'rs: ' | add edi 8
    mov D$edi 'D$  ' | add edi 3
    mov eax D$NumberOfUnicodeChars | call WriteEax

    mov B$edi ']' | inc edi

    move D$BlockStartTextPtr D$Trash2, D$BlockEndTextPtr edi
    mov B$BlockInside &TRUE
    call ControlC

    mov B$BlockInside &FALSE
    call SetCaret D$UnicodeDataInsertionPoint
    call ControlV

    VirtualFree D$Trash2, D$Trash1
ret


SetUnicodeDialogContent:
    mov esi D$UnicodeDataPointer | call InternalRightClick

    .If B$BlockInside = &TRUE
        mov esi D$BlockEndTextPtr
        While B$esi <> '0'
            inc esi | On B$esi = ']', ret
        End_While
        push esi
        ; Count the number of Words (at least...):
          mov ecx 0
          While B$esi <> ']'
            On B$esi = '0', inc ecx
            inc esi
          End_While
          inc ecx | shl ecx 1
        ; Get a mem:
          VirtualAlloc Trash1, ecx
        pop esi

      ; esi >>> first '0' of the first hexa data.
      ; Translate each Hexa Word to Binary:
        mov edi D$Trash1
      ; strip the leading '0'
L0:     lodsb
        mov ebx 0
L1:     lodsb | cmp al ',' | je L8>
                cmp al ']' | je L8>
                    sub al '0' | cmp al 9 | jbe L2>
                        sub al 7
                        cmp al 0F | ja L9>
L2:     shl ebx 4 | or bl al | jmp L1<

L8:     mov W$edi bx | add edi 2

        If al <> ']'
            While B$esi < '0'
                inc esi | On esi >= D$SourceEnd, jmp L9>
            End_While
            On B$esi = '0', jmp L0<
        End_If

L9:     mov W$edi 0
        call 'USER32.SendDlgItemMessageW' D$UnicodeEditorHandle, 10, &WM_SETTEXT, 0, D$Trash1

        VirtualFree D$Trash1
    .End_If
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

MenuTag: ; 'ExistingMenu'
    While B$esi = ' ' | inc esi | End_While

    call TagDecimalToBin

    If eax = &TRUE
        mov eax ecx | call GetTagedMenu
    End_If
ret


[TagedEdition: ?]

GetTagedMenu:
    mov esi MenuList
  ; (ID / Ptr / Size)
    While D$esi <> 0
        If D$esi = eax
            mov B$TagedEdition &TRUE
            mov D$MenuListPtr esi
            call ReEditExistingMenu | jmp L9>
        Else
            add esi (4*3)
        End_If
    End_While

L9: .If B$TagedEdition = 0-1
      ; Delete the Previous Menu Equates Block, and paste the New Menu Equates Block:
        Lea esi D$DataForClipEquates+3 | call InternalRightClick

        If D$BlockInside = &TRUE
            mov esi D$BlockStartTextPtr
            While B$esi <> '[' | dec esi | End_While
            mov D$BlockStartTextPtr esi
            inc esi
            While B$esi <> ']' | inc esi | End_While
            mov D$BlockEndTextPtr esi
            call ControlD | call ControlV
        End_If
    .End_If

    mov B$TagedEdition &FALSE
ret









TITLE Icon
 _______________________________________________________________________________________
 _______________________________________________________________________________________
;;
                                      icon editor
 
 (To be entirely re-written by who wants to).

 _______________________________________________________________________________________
 _______________________________________________________________________________________
;;

; Dialog Box Template in memory.

[ID_Inew 301  ID_Ipeek 302  ID_Ipoke 303  ID_IfromIco 304  ID_ItoIco 305
 ID_Icancel 306  ID_Ikeep 307  ID_TrackBar 320]

 _______________________________
;;
 The icon editor is set upon a dialog box created at run time (when created
 no dialog resource editor in RosAsm). The only one difficulty i encounted is
 that 'title's must be dWords aligned (doc doesn't tell).

 The predefined classes values are:
 080=button / 081=Edit / 082=Static / 083=ListBox / 084=ScrollBar / 085=ComboBox
;;

[IconDialogData:

; Dialog Box template:

  D$ &DS_SETFONT+&DS_CENTER+&WS_CAPTION+&WS_VISIBLE+&DS_MODALFRAME+&DS_3DLOOK+&WS_SYSMENU  ; style
     0                                                                   ; ext. Style
  U$ 8  0  0  220  200     ; control-number, x, y, width, hight
     0                       ; no menu
     0                       ; class 0 > default
    'Icon Editor' 0 0        ; title
     10 'Helv' 0

; controls (7 button):

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 15  40  8            ; x y w h
     ID_Inew                 ; ID
     0FFFF                   ; Predefined class
     080                     ; 080=button
    '> New >' 0                   ; button title
     0                       ; no creation data

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 30  40  8            ; x y w h
     ID_Ipeek                ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '> .exe >' 0 0                  ; button title
     0                       ; no creation data

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 45  40  8            ; x y w h
     ID_Ipoke                ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '< .exe <' 0  0                 ; button title
     0                       ; no creation data

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 60  40  8            ; x y w h
     ID_IfromIco             ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '> .ico >' 0  0          ; button title
     0                       ; no creation data

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 75  40  8            ; x y w h
     ID_ItoIco               ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '< .ico <' 0  0          ; button title
     0                       ; no creation data

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 90  40  8           ; x y w h
     &IDCANCEL               ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '= Cancel =' 0  0        ; button title
     0                       ; no creation data

  D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 105 40  8           ; x y w h
     ID_Ikeep                ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '* Keep *' 0  0          ; button title
     0]                      ; no creation data

 [AddToIcon: D$ &WS_CHILD&WS_VISIBLE  0     ; style / ext.style
  U$ 10 120 40  8           ; x y w h
     ID_Help                ; ID
     0FFFF                   ; Predefined class
     080                     ; button
    '  Help  ' 0  0          ; button title
     0]                      ; no creation data

 _______________________________

; Icon Edition data

[iIcoFileHeader:

 ; poor little thing for saving a poor little icon alone in a poor little ico file:

 W$    0   ; reserved
       1   ; Type 1
       1   ; entries number
B$   020   ; width
     020   ; hight
     010   ; color count
       0   ; reserved
W$     0   ; planes
       0   ; bits count
D$  02E8   ; size
     016   ; offset from .ico start


; All these data are not the table used to build a PE. Just a temporary table for
; icon edition. In case user compiles a source without having drawn any icon, this
; one is copyied to &TRUE buffer as default. Once user have compiled an application
; reloading it fills this table with previously defined icon.

iIcon:
iIconHeader:
B$ 028,0,0,0     ; size
   020,0,0,0     ; width
   040,0,0,0     ; height (maybe 40h because of the two masks)
   01,0          ; planes
   04,0          ; bit count
   0,0,0,0       ; compression 0
   080,02,0,0    ; 0280 > size of icon data
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0   ; (dummy)


iIconPalette:
;Blue,green,red,0    (16 color palette -values seams to be fixed ones-)

B$ 0,  0,  0,  0 ; color 0
   0,  0,080,  0 ;       1
   0,080,  0,  0 ;       2
   0,080,080,  0 ;       3
 080,  0,  0,  0 ;       4
 080,  0,080,  0 ;       5
 080,080,  0,  0 ;       6
 0C0,0C0,0C0,  0 ;       7
 080,080,080,  0 ;       8
   0,  0,0FF,  0 ;       9    rouge
   0,0FF,  0,  0 ;       A
   0,0FF,0FF,  0 ;       B
 0FF,  0,  0,  0 ;       C    bleu
 0FF,  0,0FF,  0 ;       D
 0FF,0FF,  0,  0 ;       E
 0FF,0FF,0FF,  0 ;       F


iIconXorMask:
; XOR color mask: (32*16 octets > 2 pixels / byte > 32*32 pixels)

B$    0    0
B$    0    0    0    0    0    0    0    0    0    0    0   0C    0    0   09  099
B$  099  099  099  099  099  099  099  099  099  099  099   0C  0C0    0   09  099
B$  099  099  099  099  099  099  099  099  099  099  099   0C  0CC    0    0    0
B$   09  099  099  099  099  099  099  099  099  099  099   0C  0CC  0C0   03  03B
B$   09  099  099  099  099  099  099  099  099  099  099   0C  0CC  0C0    0  033
B$   09  099  090    0    0    0    0  099  099  099  099   0C  0CC  0C0    0   03
B$   09  099  090  0B$  0BB  0BB  0B0  099  099  099  099   0C  0CC  0C0    0    0
B$   09  099  090  0DD  0BB  0BB  0B0  099  099  099  099   0C  0CC  0C0    0    0
B$   09  099  090  0DD  0B$  0BB  0B0  099  099  099  099   0C  0CC  0C0    0    0
B$   09  099  090  0DD  0DD  033  030  099  099  099  099   0C  0CC  0C0    0    0
B$    0    0    0  0DD  0DD    0    0  099  099  099  099   0C  0CC  0C0    0    0
B$   03  03B  0BB  0BD  0DD    0    0  099  099  099  099   0C  0CC  0C0    0    0
B$    0  033  0BB  0BB  0DD    0    0  099  099  099  099   0C  0CC  0C0    0    0
B$  0C0   03  03B  0BB  0BD    0    0    0    0    0    0   0C  0CC  0C0   0E  0E0
B$  0CC    0  033  033  033    0    0  033  0BB  0BB  0BB  0BB  0CC  0C0   0E  0E0
B$  0CC  0C0    0    0    0    0    0   03  03B  0BB  0BB  0BB  0BC  0C0   0E  0E0
B$  0CC  0CC    0    0    0    0   0C    0  033  0BB  0BB  0BB  0BB  0C0   0E  0E0
B$  0CC  0CC    0   0E  0EE  0EE   0C  0C0   03  033  033  033  033  030   0E  0E0
B$  0CC  0CC    0   0E  0EE  0EE   0C  0CC    0    0    0    0    0    0   0E  0E0
B$  0CC  0CC    0   0E  0EE  0EE   0C  0CC  0C0    0    0    0    0    0   0E  0E0
B$    0    0    0   0E  0EE  0EE   0C  0C0    0    0    0    0    0    0   0E  0EE
B$  0EE  0EE  0EE  0EE  0EE  0EE   0C  0C0  0AA  0AA  0AA  0AA   0C    0   0E  0EE
B$  0EE  0EE  0EE  0EE  0EE  0EE   0C  0C0  0AA  0AA  0AA  0AA   0C  0C0   0E  0EE
B$  0EE  0EE  0EE  0EE  0EE  0EE   0C  0C0  0AA  0AA  0AA  0AA   0C  0CC   0E  0EE
B$  0EE  0EE  0EE  0EE  0EE  0EE   0C  0C0  0AA  0AA  0AA  0AA   0C  0CC    0    0
B$    0    0    0    0    0    0   0C  0C0  0AA  0AA  0AA  0AA   0C  0CC   03  03B
B$  0BB  0BB  0BB  0BB  0BB  0BB  0BB  0C0  0AA  0AA  0AA  0AA   0C  0CC    0  033
B$  0BB  0BB  0BB  0BB  0BB  0BB  0BB  0B0  0AA  0AA  0AA  0AA   0C  0CC    0   03
B$  03B  0BB  0BB  0BB  0BB  0BB  0BB  0B0    0    0    0    0   0C  0CC    0    0
B$  033  033  033  033  033  033  033  033   03  0BB  0BB  0BB  0BB  0CC    0    0
B$    0    0    0    0    0    0    0    0    0  03B  0BB  0BB  0BB  0BC    0    0
B$    0    0    0    0    0    0    0    0    0   03  033  033  033  033


iIconAndMask:
; AND monochrome mask: (8*16 octects > 8 pixels / byte > 32*32 pixels)

B$    0    0
B$    0   0F    0    0    0   07    0    0    0   03    0    0    0   01  080    0
B$    0   01  0C0    0    0   01  0E0    0    0   01  0F0    0    0   01  0F0    0
B$    0   01  0F0    0    0   01  0F0   03  080   01  0F8   03  080   01  0FC   03
B$  080   01   06   03  080   01   03   03  0C0   01   01  0FF  0E0   01    0  0C0
B$  030   01    0  0C0  018   01    0  0C0   0F  0FF    0  0C0   07  0FF    0    0
B$    0   07    0    0    0   03    0    0    0   01    0    0    0    0    0    0
B$    0    0    0    0    0    0  080    0    0    0  0C0    0    0    0  0E0    0
B$    0    0  0F0    0    0    0  0FF  0FF  0F8    0  0FF  0FF  0FC    0

EndiIconAndMask:]

 ______________________________

; RGB (eax) <> RGBquad (eax) (red green blue <> blue red green):

reverseRGB:
    push ecx, ebx
      mov ebx eax, ecx eax
      and eax 0FF | and ebx 0FF00 | and ecx 0FF0000
      shl eax 16 | shr ecx 16
      add eax ebx | add eax ecx
    pop ebx, ecx
ret

 _______________________________

; Routines for drawing on Icon Dialog Box.

[iRECT: iRECTx1: 120  iRECTy1: 20  iRECTx2: 130  iRECTy2: 30]

[iPAINTSTRUCT:
 ihdc: ?  ifErase: ?  ircPaint: B$ ?  ifRestore: D$ ?
 ifIncUpdate: ?   irgbReserved: ? ? ? ?  ? ? ? ?]

[iXcount: ?  iYcount: ?]

; drawing one little box (each 'pixel') in edit icon image. Calculations at
; 'IBrush index' are to translate the "handles'Brushes" (linear dWords) in
; a pointer to "Brushes'structures". DL is used to rotary point to AND mask bits.

iOneRect:
    mov dh B$iIconAndMask+ecx | and dh dl
    pushad
      if dh <> 0
; blank area box:
        call 'GDI32.Rectangle' D$ihdc  D$iRECTx1  D$iRECTy1  D$iRECTx2  D$iRECTy2
; blank of true size icon at bottom:
        mov eax D$iRECTx1, ebx D$iRECTy1 ; | sub eax 140 | sub ebx 276
        shr eax 3 | shr ebx 3 | add eax 40 | add ebx 360
        call 'GDI32.SetPixel' D$ihdc eax ebx D$iBackGroundColor
      Else
        push eax
; One color pixel box of icon :
          call 'USER32.FillRect' D$ihdc iRECT D$ihBrush0+eax
        pop ebx
; show true size icon pixel at bottom:
        shr ebx 2                                    ; IBrush index
        mov ecx ebx | shl ebx 1 | add ecx ebx        ; * 3
        inc ecx                                      ; + 1
        shl ecx 2                                    ; * 4
        mov ecx D$IBrush0+ecx
      ;  mov eax D$iRECTx1, ebx D$iRECTy1 | sub eax 140 | sub ebx 276
      ;  shr eax 3 | shr ebx 3 | add eax 40 | add ebx 360

        mov eax D$iRECTx1, ebx D$iRECTy1
        shr eax 3 | shr ebx 3 | add eax 28 | add ebx 320
      ; Toto fix

        call 'GDI32.SetPixel' D$ihdc eax ebx ecx      ; handle, X, Y, color
; NT > problem: only bottom line drawn (ebx always the same value ???) don't find any
; reason for...
      end_if
    popad
    ror dl 1 | On dl = 00_1000_0000, inc ecx
ret


; Drawing of edition image of icon:

iDrawColorBox:
    call 'USER32.BeginPaint' D$IconEditorHandle, iPAINTSTRUCT
    call 'USER32.GetDC' D$IconEditorHandle | mov D$ihdc eax
    mov D$iRECTx1 135,  D$iRECTy1 305, D$iRECTx2 0192,  D$iRECTy2 016C
    call 'USER32.FillRect' D$ihdc iRECT D$IhBackBrush
    mov D$iRECTx1 140,  D$iRECTy1 310, D$iRECTx2 160,  D$iRECTy2 330, ecx 0
L0: push ecx
      dec D$iRECTx1 | dec D$iRECTy1 | inc D$iRECTx2 | inc D$iRECTy2
      call 'GDI32.Rectangle' D$ihdc  D$iRECTx1  D$iRECTy1  D$iRECTx2  D$iRECTy2
      inc D$iRECTx1 | inc D$iRECTy1 | dec D$iRECTx2 | dec D$iRECTy2
    pop ecx
    push ecx
      mov al cl | shr al 2 | cmp B$ActualColor, al | jne L1>
        pushad
          mov eax D$iRECTx1, ebx D$iRECTy1, ecx D$iRECTx2, edx D$iRECTy2
          sub eax 3 | sub ebx 3 | add ecx 3 | add edx 3
          call 'GDI32.Rectangle' D$ihdc  eax ebx ecx edx
        popad
L1:   call 'USER32.FillRect' D$ihdc iRECT D$ihBrush0+ecx
    pop ecx
      add ecx 4 | cmp ecx 64 | jae L9>
        add D$iRECTx1 34 | add D$iRECTx2 34
        If ecx = 32
          mov D$iRECTx1 140,  D$iRECTy1 340, D$iRECTx2 160,  D$iRECTy2 360
        End_If
      jmp L0<<
L9: call 'USER32.ReleaseDC' D$IconEditorHandle, D$ihdc
    call 'USER32.EndPaint' D$IconEditorHandle, iPAINTSTRUCT
 ret


; Main Construction of the editor: edit image + true size icon + color selection boxes:

[iBackGroundColor: ?    DrawIconMessage: ?]

DrawIcon:
    call 'USER32.BeginPaint' D$IconEditorHandle, iPAINTSTRUCT
      call 'USER32.GetDC' D$IconEditorHandle | mov D$ihdc eax
      call 'GDI32.GetPixel' eax 5 5 | mov D$iBackGroundColor eax, D$iBackBrush+4 eax
      call DeleteIconBrushes | call CreateIconBrushes
        mov D$iXcount 0, D$iYcount 0
        mov D$iRECTx1 140,  D$iRECTy1 276,  D$iRECTx2 149,  D$iRECTy2 285
        mov esi iIconXorMask, ecx 0, edx 00_1000_0000

L0:     mov ebx 0, eax 0 | lodsb | mov bl al | and ebx 0F | and eax 0F0 | shr eax 4
          shl eax 2 | shl ebx 2
            call iOneRect
              inc D$iXcount | add D$iRECTx1 8 | add D$iRECTx2 8
                mov eax ebx
                  call iOneRect
                    inc D$iXcount | cmp D$iXcount 32 | je L2>
        add D$iRECTx1 8 | add D$iRECTx2 8 | jmp L0<<

L2:     inc D$iYcount | cmp D$iYcount 32 | je L3>
          mov D$iRECTx1 140,  D$iRECTx2 149, D$iXcount 0
            sub D$iRECTy1 8 | sub D$iRECTy2 8 | jmp L0<<

L3: call 'USER32.ReleaseDC' D$IconEditorHandle,  D$ihdc
    call 'USER32.EndPaint' D$IconEditorHandle, iPAINTSTRUCT
    On D$DrawIconMessage <> &WM_MOUSEMOVE, call iDrawColorBox
ret

 ______________________________________

; Brushes used by icon editor. 'iBrush0', ... are brushes creation data;
; 'ihBrush0, ... are brushes handles.

; [BS_SOLID 0] = first of 3 members, second is the color

[IBrush0: ? ? ?   IBrush1: ? ? ?   IBrush2: ? ? ?   IBrush3: ? ? ?   ; brushes struc
 IBrush4: ? ? ?   IBrush5: ? ? ?   IBrush6: ? ? ?   IBrush7: ? ? ?
 IBrush8: ? ? ?   IBrush9: ? ? ?   IBrushA: ? ? ?   IBrushB: ? ? ?
 IBrushC: ? ? ?   IBrushD: ? ? ?   IBrushE: ? ? ?   IBrushF: ? ? ?  iBrushesEnd:]

[IhBrush0: ?   IhBrush1: ?   IhBrush2: ?   IhBrush3: ?               ; brushes handles
 IhBrush4: ?   IhBrush5: ?   IhBrush6: ?   IhBrush7: ?
 IhBrush8: ?   IhBrush9: ?   IhBrushA: ?   IhBrushB: ?
 IhBrushC: ?   IhBrushD: ?   IhBrushE: ?   IhBrushF: ?]

[iBackBrush: ? ? ?  IhBackBrush: ?]


CreateIconBrushes:
    mov edi iBrush0, esi iIconPalette | add edi 4        ; store icon palette colors
L0: lodsd | call reverseRGB | stosd | add edi 8          ; in brushes structures
    cmp edi iBrushesEnd | jb L0<

    call 'GDI32.CreateBrushIndirect' iBrush0 | mov D$ihBrush0 eax
    call 'GDI32.CreateBrushIndirect' iBrush1 | mov D$ihBrush1 eax
    call 'GDI32.CreateBrushIndirect' iBrush2 | mov D$ihBrush2 eax
    call 'GDI32.CreateBrushIndirect' iBrush3 | mov D$ihBrush3 eax
    call 'GDI32.CreateBrushIndirect' iBrush4 | mov D$ihBrush4 eax
    call 'GDI32.CreateBrushIndirect' iBrush5 | mov D$ihBrush5 eax
    call 'GDI32.CreateBrushIndirect' iBrush6 | mov D$ihBrush6 eax
    call 'GDI32.CreateBrushIndirect' iBrush7 | mov D$ihBrush7 eax
    call 'GDI32.CreateBrushIndirect' iBrush8 | mov D$ihBrush8 eax
    call 'GDI32.CreateBrushIndirect' iBrush9 | mov D$ihBrush9 eax
    call 'GDI32.CreateBrushIndirect' iBrushA | mov D$ihBrushA eax
    call 'GDI32.CreateBrushIndirect' iBrushB | mov D$ihBrushB eax
    call 'GDI32.CreateBrushIndirect' iBrushC | mov D$ihBrushC eax
    call 'GDI32.CreateBrushIndirect' iBrushD | mov D$ihBrushD eax
    call 'GDI32.CreateBrushIndirect' iBrushE | mov D$ihBrushE eax
    call 'GDI32.CreateBrushIndirect' iBrushF | mov D$ihBrushF eax
    call 'GDI32.CreateBrushIndirect' iBackBrush | mov D$IhBackBrush eax
ret


DeleteIconBrushes:
    call 'GDI32.DeleteObject'  D$ihBrush0
    call 'GDI32.DeleteObject'  D$ihBrush1
    call 'GDI32.DeleteObject'  D$ihBrush2
    call 'GDI32.DeleteObject'  D$ihBrush3
    call 'GDI32.DeleteObject'  D$ihBrush4
    call 'GDI32.DeleteObject'  D$ihBrush5
    call 'GDI32.DeleteObject'  D$ihBrush6
    call 'GDI32.DeleteObject'  D$ihBrush7
    call 'GDI32.DeleteObject'  D$ihBrush8
    call 'GDI32.DeleteObject'  D$ihBrush9
    call 'GDI32.DeleteObject'  D$ihBrushA
    call 'GDI32.DeleteObject'  D$ihBrushB
    call 'GDI32.DeleteObject'  D$ihBrushC
    call 'GDI32.DeleteObject'  D$ihBrushD
    call 'GDI32.DeleteObject'  D$ihBrushE
    call 'GDI32.DeleteObject'  D$ihBrushF
    call 'GDI32.DeleteObject'  D$IhBackBrush
ret
 ________________________________________

; calculation of icon editor position of some user click:

[InsideEditBox edx  InsideColorBox ecx]

iPos:
    mov InsideEditBox &FALSE, InsideColorBox &FALSE
    mov eax D$MousePosX, ebx D$MousePosY
  ;  mov eax 0, ebx 0 | push D$Lparam | pop ax, bx      ; eax > x / ebx > y
    cmp eax 08D  | jbe L9>
    cmp eax 018D | jae L9>
    cmp ebx 01C  | jbe L9>
    cmp ebx 011C | jae L8>
      sub eax 08D | sub ebx 01C                         ; Pos - origin
      mov InsideEditBox &TRUE | ret
L8: cmp ebx 0135 | jb L9>
    cmp ebx 0167  | ja L9>
      sub eax 08D | sub ebx 0135
      mov InsideColorBox &TRUE | ret
L9: ret

; Drawing in icon image.

[ActualColor: ?]  ; accessed as byte and as dword.

; In: eax / ebx = indexes x/y to on icon pixel. we really write at iIconXorMask,
; (iIconAndMask used as "iIconXorMaskEnd"). first line is last one.
; When back from iPos, if user clicked on left upper little box, eax=0 / ebx=0
; ... on right lower one: eax=01F / ebx=01F:

EditIcon:
    shr eax 3 | shr ebx 3                                  ; 8 pixels per little box
    push eax, ebx
      mov esi iIconAndMask | sub esi 16 | shl ebx 4 | sub esi ebx ; + lines
      mov ebx eax                                                 ; keep for odd test
      shr eax 1 | add esi eax
      mov al B$ActualColor | mov ah 00_1111_0000
      Test ebx 1 | jnz L2>
        shl al 4 | mov ah 00_1111
L2:   and B$esi ah | or B$esi al
    pop ebx, eax
    mov esi EndiIconAndMask | sub esi 4 | shl ebx 2 | sub esi ebx
    mov ecx eax
    shr eax 3 | add esi eax
    and ecx 00_111
    mov al 00_1000_0000 | shr al cl
    or B$esi al | xor B$esi al
    call DrawIcon
  ret

; Clearing in icon image.

ClearIconPix:
    shr eax 3 | shr ebx 3                               ; 8 pixels per little box
    push eax, ebx
      mov esi iIconAndMask | sub esi 16 | shl ebx 4 | sub esi ebx  ; + lines
      mov ebx eax                                     ; keep for odd test
      shr eax 1 | add esi eax
      mov al B$ActualColor | mov ah 00_1111_0000
      Test ebx 1 | jnz L2>
        shl al 4 | mov ah 00_1111
L2:   and B$esi ah
    pop ebx, eax
    mov esi EndiIconAndMask | sub esi 4 | shl ebx 2 | sub esi ebx
    mov ecx eax
    shr eax 3 | add esi eax
    and ecx 00_111
    mov al 00_1000_0000 | shr al cl
    or B$esi al
    call DrawIcon
ret


; Search what color choice box user clicked on.

WhatColor:
    shr eax 5 | shr ebx 5 | shl ebx 3
    add eax ebx | mov B$ActualColor al
    call DrawIcon
ret


; user left click on the square rainbow:

[NewColor: ?]

WhatNewColor:
    call 'GDI32.GetPixel' D$RainbowDC eax ebx | call ReverseRGB
    mov edi iIconPalette, ebx D$ActualColor | shl ebx 2 | add edi ebx | stosd
    call DeleteIconBrushes | call CreateIconBrushes
    call iDrawColorBox
ret

; User left Click on selected Color Box while in 'Choose Color':

SetNewColor:
    shr eax 5 | shr ebx 5 | shl ebx 3
    add eax ebx | cmp al B$ActualColor | jne L9>
      call 'USER32.DestroyWindow' D$GreenSliderHandle
      call DeleteRainbowDC
      mov B$OnRainbow &FALSE
      call DrawIcon
L9: ret


iLeft:
    call iPos
    cmp B$OnRainbow &TRUE | jne L5>

    If InsideEditBox = &TRUE
      call WhatNewColor
    Else_If InsideColorBox = &TRUE
      call SetNewColor
    End_If
    ret

L5: If InsideEditBox = &TRUE
      call EditIcon
    Else_If InsideColorBox = &TRUE
      call WhatColor
    End_If
L9: ret

 ________________________________________

; Showing Square Rainbow for color choice:

[RedBit 1  BlueBit  00_00000001_00000000_00000000  GreenBit  00_00000001_00000000
 NO_RED 0FFFFFF00  NO_BLUE 0FFFF  NO_GREEN 0FF00FF]

; size, width, height, planes, bitCount, compression imagesize x/meter y/meter 0  0
[RainBowHeader:  40 255 255 W$ 1 32 D$ 0  65025  xMeter: 0  yMeter: 0   0  0]

[SquareRainbowHandle: ?  SquareRainbowPtr: ?  RainBowHandle: ?  RainbowDC: ?
 RainData: ?  SlideGreen: ?   OldRainbowBitMaP: ?]


; Build a 2 dimensions color table in memory (blue/red):

DeleteRainbowDC:
    call 'GDI32.SelectObject' D$RainBowDC  D$OldRainbowBitMaP
    call 'GDI32.DeleteObject' D$RainbowHandle
    call 'GDI32.DeleteDC' D$RainbowDC
ret


Rainbow:
    call 'USER32.BeginPaint' D$IconEditorHandle iPAINTSTRUCT

    call 'USER32.GetDC' D$IconEditorHandle | mov D$ihdc eax

    call 'GDI32.CreateCompatibleDC' D$ihdc | mov D$RainbowDC eax

    call 'GDI32.CreateDIBSection' D$RainBowDC RainBowHeader,
                                     &DIB_RGB_COLORS RainData 0 0
    mov D$RainbowHandle eax

; filling colors data:

    mov eax D$SlideGreen, ecx 0FF, edi D$RainData
    shl eax 8
L0: push ecx
        mov ecx 0FF
L1:     stosd | add eax RED_BIT | loop L1<
            and eax NO_RED
    pop ecx
    add eax BLUE_BIT | loop L0<

; Painting at screen (we do not release rainbow DC and object here -needed-):

    call 'GDI32.SelectObject' D$RainBowDC  D$RainbowHandle
        mov D$OldRainbowBitMaP eax
    call 'GDI32.BitBlt' D$ihdc 140 30  255 255 D$RainbowDC 0  0  &SRCCOPY

    call 'USER32.ReleaseDC' D$IconEditorHandle D$ihdc

    call 'USER32.EndPaint' D$IconEditorHandle, iPAINTSTRUCT
ret


; Icon edition area is a little bit larger than 255/255 because of little boxes edges.
; we clean that here, at first 'color box right click':

clearIconArea:
    call 'USER32.BeginPaint' D$IconEditorHandle, iPAINTSTRUCT
      call 'USER32.GetDC' D$IconEditorHandle | mov D$ihdc eax
        mov D$iRECTx1 135,  D$iRECTy1 25, D$iRECTx2 400,  D$iRECTy2 290
        call 'USER32.FillRect' D$ihdc iRECT D$IhBackBrush
      call 'USER32.ReleaseDC' D$IconEditorHandle  D$ihdc
    call 'USER32.EndPaint' D$IconEditorHandle, iPAINTSTRUCT
ret


[TrackClassName: 'msctls_trackbar32', 0  TrackTitle: 'Green' 0  GreenSliderHandle: 0]

GreenSlider:
    call 'User32.CreateWindowExA' 0, TrackClassName, TrackTitle,
                                  &WS_CHILD+&WS_VISIBLE+&TBS_LEFT+&TBS_VERT,
                                  410, 25, 20, 265, D$IconEditorHandle, ID_TRACKBAR,
                                  D$hinstance, 0
    mov D$GreenSliderHandle eax
    call 'User32.SendMessageA' D$GreenSliderHandle  &TBM_SETRANGE 1 0FF_0000
    mov eax D$SlideGreen | not al
    call 'User32.SendMessageA' D$GreenSliderHandle  &TBM_SETPOS 1  eax
ret


[OnRainbow: ?  OldSelectedColor: ?]

RestorePreviousColor:
    mov edi iIconPalette, eax D$ActualColor | shl eax 2
    add edi eax | mov eax D$OldSelectedColor | stosd
    call DeleteIconBrushes | call CreateIconBrushes | call DrawIcon
ret


SaveActualColor:
    mov esi iIconPalette, eax D$ActualColor | shl eax 2
    add esi eax | lodsd | mov D$OldSelectedColor eax
ret


iRight:
    If B$OnRainbow = &TRUE
      call RestorePreviousColor
      call 'USER32.DestroyWindow' D$GreenSliderHandle
      call deleteRainbowDC
      mov B$OnRainbow &FALSE | ret
    End_If

    call iPos
    If InsideEditBox = &TRUE
      call ClearIconPix
    Else_If InsideColorBox = &TRUE
      mov B$OnRainbow &TRUE
      call WhatColor
      call SaveActualColor
      mov esi iIconPalette, eax D$ActualColor | shl eax 2
      add esi eax | inc esi | mov eax 0, al B$esi | mov D$SlideGreen eax
      call clearIconArea | call GreenSlider | call RainBow
    End_If
L9: ret


; Retrieve the slider value on user move and redraw rainbow:

iTrackMove:
      call 'User32.SendMessageA' D$GreenSliderHandle &TBM_GETPOS 0 0
        not al | mov D$SlideGreen eax
      call DeleteRainbowDC | call Rainbow
L9: ret

 ___________________________________________________________________________________
 ___________________________________________________________________________________

; reading and writing icons from/to files:

 ___________________________________________________________________________________

; Reading and writing an icon from/to a PE:
 ___________________________________________________________________________________

[iStartOfResources: 0  iExePtr: 0  iExeLen: 0  iResourceRVA: 0  iSourceHandle: 0
 iSourceFilterPtr: 1
 iPEFilesFilters:  B$ 'PE files'     0  '*.exe'   0  0]

[iuFileFilter: ? #262] [iSaveFilter: ? #262] [iChoosenFile: ? #262]

[iOpenPEStruc: len
 ihwndPEFileOwner: 0  iOPESInstance:0  iPEFilesFilters  iuFileFilter  260
 iSourceFilterPtr  iSaveFilter  260  iChoosenFile  260  0
 OpenPEFileTitle  0281804
 0  0  0  0  0]

[ResourcesRVA: ?    NoResourcesPE: ?    PeIconFound: ?]


OpenPeForReadingIcon:
  ; Opening a file:
    mov B$NoResourcesPE &FALSE

    mov edi iSaveFilter, ecx 260, eax 0 | rep stosd

    call 'Comdlg32.GetOpenFileNameA' iOpenPEStruc
      On D$iSaveFilter = 0, ret
 ______________________________________

  ; Loading the entire file in memory:

    On D$iSourceHandle > 0, call 'KERNEL32.CloseHandle' D$iSourceHandle

    mov esi iSaveFilter

    call 'KERNEL32.CreateFileA' esi &GENERIC_READ, &FILE_SHARE_READ+&FILE_SHARE_WRITE,
                                0, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
        mov eax D$BusyFilePtr | call MessageBox ;;;;| pop eax | ret  ; return to caller of caller
        mov D$iSourceHandle 0
    Else
        mov D$iSourceHandle eax

        call 'KERNEL32.GetFileSize'  eax 0
        mov D$iExeLen eax | VirtualAlloc iExePtr eax

        mov D$NumberOfReadBytes 0
        call 'KERNEL32.ReadFile' D$iSourceHandle D$iExePtr,
                                D$iExeLen NumberOfReadBytes 0      ; load headers
    End_If
ret


ReadRosAsmPeIcon:                     ; reused by general purpose RosAsm PE opening.
    mov B$PeIconFound &FALSE

  ; read dos header:
    mov esi D$iExePtr
    mov eax 0 | add esi 8 | lodsw    ; parag. size of dos header end >PE header adress

    shl eax 4 | sub eax 4
    mov esi D$iExePtr | add esi eax | lodsd      ; eax = PE header

    mov esi D$iExePtr | add esi eax
    If W$esi <> 'PE'
        mov esi D$iExePtr | add esi 03C | lodsd | add eax D$iExePtr | mov esi eax
        cmp W$esi 'PE' | jne PeNotFound
    End_If

 ______________________________________

  ; read data in PE header:

    movzx ecx w$esi+6                     ; word record of section number
    add esi 136 | lodsd | mov ebx eax     ; RVA of resources from "Image Data Dir..."
    mov D$ResourcesRVA eax  ; jmp over general purpose headers and reach PE sections headers:

    add esi 120                           ; esi points to RVA of first section header

L0: lodsd | cmp eax ebx | je L1>
        add esi 36 | loop L0<
        On ebx = 0, jmp AbortIconSearch
          jmp SectNotFound

L1: On D$esi-16 <> '.rsr', jmp AbortIconSearch

 ______________________________________

  ; if here, '.rsrc' section found:

L1: add esi 4 | lodsd                            ; > app ptr to resources

    add eax D$iExePtr | mov D$iStartOfResources eax

DisReadMainIcon:
    mov B$PeIconFound &FALSE

    mov esi eax | add esi 14                     ; > number of ID resources
    mov eax 0 | lodsw | mov ecx eax              ; > in ecx
    add cx W$esi-4                               ; add number of Named IDs
    On eax = 0, jmp AbortIconSearch      ; if no resources at all

  ; search RT_ICON in resource general header:

L0: lodsd | cmp eax RT_ICON | je L1>
    lodsd | loop L0<
      jmp AbortIconSearch                        ; no icon found (possible naked PE)

L1: lodsd                   ; icon found "Level2Rt_Icon-StartOfRsrc+NodeFlag" in eax
    and eax 0FFFFFFF        ; strip node flag (0_80000000)
    add eax D$iStartOfResources

    add eax 14 | mov esi eax, edx 0, dx W$esi | sub  esi 2

 ______________________________________

  ; resource TYPEs dir:

NextiRecord:

    add esi 8
    push esi

    lodsd                              ; "Level3Rt_Icon-StartOfRsrc+NodeFlag" in eax
    and eax 0FFFFFFF
    add eax D$iStartOfResources
    add eax 20 | mov esi eax

  ; language. dir:
    lodsd                      ; "Level4Rt_Icon-StartOfRsrc" in eax (no NodeFlag here
                                       ; next one is leave ptr to true resources)
    add eax D$iStartOfResources
    mov esi eax

  ; records of each resource:
    lodsd                              ; ptr to icon data (but RVA - startOfResource)
    mov ecx D$esi

    If ecx <> 02E8                                       ; 2E8h = size of common icons
      pop esi | dec edx | On edx > 0, jmp NextiRecord
        jmp BadIcoSize
    Else
      pop esi
    End_If

    sub eax ebx                              ; - RVA
    add eax D$iStartOfResources              ; eax now points to true icon data
    mov B$PeIconFound &TRUE
  ret


SectNotFound:    mov eax SectionNotFound | jmp L9>
AbortIconSearch:

    If D$SavingExtension = '.DLL'
        jmp L7>
    Else_If D$SavingExtension = '.SYS'
        jmp L7>
    End_If

                    mov eax NoIcon       | jmp L9>
BadIcoSize:      mov eax BadIconSize     | jmp L9>
PeNotFound:      mov eax NoPE

L9: ;If B$Disassembling = &TRUE
    ;    mov D$iExePtr 0 | ret  ; restored by Disassembler call (used as Flag, here).
    ;End_If
    call MessageBox ;;;;| call IconSearchOut ;| pop eax |
    ret     ;;;; return to caller of caller

L7: mov B$NoResourcesPE &TRUE ;;;;| call IconSearchOut |
    ret


;IconSearchOut:
;    mov eax D$UserPeStart | On D$iExePtr <> eax, VirtualFree D$iExePtr
;  ; Don't destroy User Source in any case, if the 'readRosAsmPeIcon' Routine is called
;  ; from some Open PE ,normal Functions.
;ret

[SectionNotFound: 'Section not found', 0
 BadIconSize:     'Icon size not assumed', 0
 NoPE:            'PE signature not found', 0
 NoIcon:          'Icon not found in this file', 0]


; peek from PE:

PeekIcon:
    call OpenPeForReadingIcon

    .If D$iSourceHandle <> 0
        call ReadRosAsmPeIcon                        ; eax > start of icon data

        If B$PeIconFound = &TRUE
            mov esi eax | mov edi iIcon | rep movsb  ; Copying to ower buffer
        End_If

        call 'KERNEL32.CloseHandle' D$iSourceHandle | mov D$iSourceHandle 0

        VirtualFree D$iExePtr
    .End_If
ret


[iDestinationHandle: 0  PokeSure: 'Ready to modify choosen PE?', 0   NullTitle: ' ', 0]

; Poke inside PE:

PokeIcon:
    call OpenPeForReadingIcon                        ; eax > start of icon data

    ..If D$iSourceHandle <> 0
        call ReadRosAsmPeIcon                        ; eax > start of icon data

        .If B$PeIconFound = &TRUE
            mov edi eax | mov esi iIcon | rep movsb  ; Copying from ower buffer
            call 'KERNEL32.CloseHandle' D$iSourceHandle | mov D$iSourceHandle 0
            call 'USER32.MessageBoxA' D$hwnd  PokeSure  NullTitle,
                                    &MB_YESNO+&MB_ICONEXCLAMATION +&MB_SYSTEMMODAL
            On eax = &IDNO, jmp L9>>

            call 'KERNEL32.CreateFileA' iSaveFilter &GENERIC_WRITE,
                                        &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                        &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
            If eax = &INVALID_HANDLE_VALUE
                mov eax D$BusyFilePtr | call MessageBox | ret
            Else
                mov D$iDestinationHandle eax
            End_If

            mov D$NumberOfReadBytes  0
            call 'KERNEL32.WriteFile'   D$iDestinationHandle D$iExePtr D$iExeLen,
                                        NumberOfReadBytes  0
        .End_If

L9:     VirtualFree D$iExePtr
        call 'KERNEL32.CloseHandle' D$iDestinationHandle
    ..End_If
ret

 _______________________________________________________________________________________

 ; reading and writting .ico files:
 _______________________________________________________________________________________

[FileIconDir: W$ 0 1  FIDcount: 1

FIDentriesTable: FIwidth: B$ 020   FIheight: 020    FIcolorCount: 010  0
                 FIplanes: W$ 0     FIbitCount: 0
             FIBytesInRes: D$ 02E8  FIdwImagePtr: 022    ; * by "FIDcount" number
             FileIconDirLen: len]

[IcoFilePtr: ?  IcoFileLen: ?]

[icoFilesFilters:  B$ 'icon files'     0  '*.ico'   0  0
 OpenIcoFileTitle: 'Choose an icon file', 0]


[icoOpenStruc: len
 icohwndFileOwner: 0  icohInstance:0  icoFilesFilters  iuFileFilter  260
 iSourceFilterPtr  iSaveFilter  260  iChoosenFile  260  0
 OpenIcoFileTitle  IOSflags: 0281804 ; for read
 0  0  0  0  0]            ; 0280006 : for write  .ico



[BadFIsiz: 'No 36/36 icon in this file (or too much colors)', 0]

BadFIsize: mov eax BadFIsiz | call MessageBox | ret


ReadIcoFile:
  ; Opening a .ico file:

    mov edi iSaveFilter, ecx 260, eax 0 | rep stosd
    mov D$IOSflags 0281804 | call 'Comdlg32.GetOpenFileNameA' icoOpenStruc
      On D$iSaveFilter = 0,  ret

  ; Loading the entire file in memory:

    call 'KERNEL32.CreateFileA' iSaveFilter &GENERIC_READ, &FILE_SHARE_READ+&FILE_SHARE_WRITE,
                                0, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
                                              ; hTemplateFile
    If eax = &INVALID_HANDLE_VALUE
      mov eax D$BusyFilePtr | call MessageBox | ret         ; return to caller of caller
    Else
      mov D$iSourceHandle eax
    End_If

    call 'KERNEL32.GetFileSize'  eax 0 | mov D$icoFileLen eax

    VirtualAlloc icoFilePtr eax
    mov D$NumberOfReadBytes 0

    call 'KERNEL32.ReadFile' D$iSourceHandle D$icoFilePtr,
                            D$icoFileLen NumberOfReadBytes 0

    mov esi D$IcoFilePtr | add esi 4
    lodsw | movzx ecx ax                             ; icons number in ecx
L0: cmp B$esi 020 | je L1>                           ; first size
      add esi 16 | loop L0<                          ; next record
        jmp BadFIsize
L1: On D$esi+8 <> 02E8, jmp BadFIsize
    add esi 12                                       ; ptr to ico data
    mov esi D$esi, edi iIcon, ecx 02E8
    add esi D$IcoFilePtr | rep movsb                 ; Copying to ower buffer

    call 'KERNEL32.CloseHandle' D$iSourceHandle

    VirtualFree D$icoFilePtr
ret


[NewOnly: 'This option saves only new files', 0]

WriteIcoFile:
  ; Opening a .ico file:

    mov edi iSaveFilter, ecx 260, eax 0 | rep stosd
    mov D$IOSflags 0288006 | call 'Comdlg32.GetSaveFileNameA' icoOpenStruc
      On D$iSaveFilter = 0,  ret

    call 'KERNEL32.CreateFileA' iSaveFilter &GENERIC_WRITE, 0, 0,
                                &CREATE_NEW, &FILE_ATTRIBUTE_NORMAL, 0

    If eax = &INVALID_HANDLE_VALUE
      mov eax NewOnly | call MessageBox | ret  ; return to caller of caller
    Else
      mov D$iDestinationHandle eax
    End_If

    mov D$NumberOfReadBytes  0
    call 'KERNEL32.WriteFile'   D$iDestinationHandle iIcoFileHeader 02FE,
                               NumberOfReadBytes  0
    call 'KERNEL32.CloseHandle' D$iDestinationHandle
ret

 ____________________________________________________________________________________


; saving icon data in user stub data for effective compilation:

StoreIcon:
    mov esi iIcon, edi uIcon, ecx 02E8 | rep movsb
ret

 ____________________________________________________________________________________
 ____________________________________________________________________________________

; Main of icon edition (dialog box Proc):

IconEdition:
    If D$IconEditorHandle = 0
        call 'User32.DialogBoxIndirectParamA' D$hinstance, IconDialogData, D$hwnd,
                                              IconEditProc, 0
    Else
        Beep
    End_If
ret


[iDraw: B$ ?  iArase: ?] [IconEditorHandle: ?]

Proc IconEditProc:
  Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    move D$DrawIconMessage D@Message

    ...If D@Message = &WM_PAINT
        call DrawIcon

    ...Else_If D@Message = &WM_VSCROLL
        call iTrackMove

    ...Else_If D@Message = &WM_LBUTTONDOWN
        mov B$iDraw &TRUE

    ...Else_If D@Message = &WM_LBUTTONUP
        push D@Lparam | pop W$MousePosX, W$MousePosY
        mov B$idraw &FALSE | call iLeft

    ...Else_If D@Message = &WM_RBUTTONDOWN
        mov B$iArase &TRUE

    ...Else_If D@Message = &WM_RBUTTONUP
        push D@Lparam | pop W$MousePosX, W$MousePosY
        mov B$iArase &FALSE | call iRight

    ...Else_If D@Message = &WM_MOUSEMOVE
        push D@Lparam | pop W$MousePosX, W$MousePosY
        If B$iDraw = &TRUE
            call iLeft
        Else_If B$iArase = &TRUE
            call iRight
        EndIf

    ...Else_If D@Message = &WM_COMMAND
        .If D@wParam = &IDCANCEL
            mov D$IconEditorHandle 0
            call 'User32.EndDialog' D@Adressee 0
        .Else_If D@wParam = ID_Inew
            mov edi iIconAndMask, ecx 128, al 0FF | rep stosb
            mov edi iIconXorMask, ecx 512, al 0   | rep stosb
            call DrawIcon
        .Else_If D@wParam = ID_Ipeek
            call PeekIcon | call DrawIcon
        .Else_If D@wParam = ID_Ipoke
            call PokeIcon
        .Else_If D@wParam = ID_IfromIco
            call ReadIcoFile | call DrawIcon
        .Else_If D@wParam = ID_ItoIco
            call WriteIcoFile
        .Else_If D@wParam = ID_iKeep
            move D$IconEditorHandle 0
            call StoreIcon | call 'User32.EndDialog' D@Adressee 0
        .Else_If D@wParam = ID_Help
            call Help, B_U_AsmName, IconHelp, ContextHlpMessage
        .Else
            popad | mov eax &FALSE | jmp L9>>
        .End_If

    ...Else_If D@Message = &WM_INITDIALOG
        move D$IconEditorHandle D@Adressee
        move D$icohInstance D$hInstance
        move D$iOPESInstance D$hInstance
        move D$icohwndFileOwner D@Adressee
        move D$ihwndPEFileOwner D@Adressee
        call CreateIconBrushes
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon

    ...Else_If D@Message = &WM_Close
        mov D$IconEditorHandle 0
        If B$OnRainbow = &TRUE
            call RestorePreviousColor
            call 'USER32.DestroyWindow' D$GreenSliderHandle
            call deleteRainbowDC
            mov B$OnRainbow &FALSE
        End_If
        popad | call DeleteIconBrushes | mov eax &FALSE | jmp L9>

    ...Else
        popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP


TITLE menu
 _______________________________________________________________________________________
 _______________________________________________________________________________________
;;
                                  Memus editor

'MenuEditProc'

 There are 2 types of menus for Win i use the newer (EX type) one, with MFT and
 MFS independant flags stored as dwords in Resources, plus ID dWord, plus PopUp
 and End Flags as Words.

 &MF_POPUP value is 010, but, in the Resources Word for this, this value is 01,
 what gives for LastPopUp, 081. As this 1 conflicts with &MF_GRAYED (01) or
 &MFS_GRAYED (3), the translation from 010 to 01 is only done when storing (and
 reverse when loading).

 As i use only one dWord per item to store all the various flags for the Editor
 internal use (MenuItemsFlags table).
;;
 _______________________________________________________________________________________
 _______________________________________________________________________________________


; 080=button / 081=Edit / 082=Static / 083=ListBox / 084=ScrollBar / 085=ComboBox


[MenuDialogData: D$ 090CC08C2 0        ; Style
 U$ 0B 0 0 0FC 0A8             ; Dim
 0                             ; Menu
 0                             ; Class
 'Menu Edition' 0               ; Title
 08 'Helv' 0]                      ; Font

; WS_BORDER|WS_TABSTOP|WS_HSCROLL|WS_VSCROLL| ES_WANTRETURN|ES_NOHIDESEL|ES_AUTOVSCROLL|ES_MULTILINE
[MDD0000: D$ 050B01144 0       ; Style
 U$ 0 0 0FB 07D                ; Dim
 065                           ; ID
 0FFFF 081                     ; Class  > Edit Control
 '' 0                          ; Title
 0]                            ; No creation data

[MDD0001: D$ 050000003 0      ; Style
 U$ 0 084 020 0B              ; Dim
 IDR_Grayed                           ; ID  06F
 0FFFF 080                     ; Class
 'Gray' 0                    ; Title
 0]                            ; No creation data

[MDD0011: D$ 050000003 0      ; Style
 U$ 028 084 020 0B              ; Dim
 IDR_Checked                           ; ID  070
 0FFFF 080                     ; Class
 'Check' 0                   ; Title
 0]                            ; No creation data

[MDD0111: D$ 050000009 0      ; Style
 U$ 050 084 020 0B              ; Dim
 IDR_Radio                           ; ID
 0FFFF 080                     ; Class
 'Radio' 0                      ; Title
 0]                            ; No creation data

[MDD1111: D$ 050000003 0      ; Style
 U$ 078 084 020 0B              ; Dim
 IDR_Right                           ; ID
 0FFFF 080                     ; Class
 'Right' 0                      ; Title
 0]                            ; No creation data

[MDD0002: D$ 050000000 0      ; Style
 U$ 01 098 033 010             ; Dim
 02                            ; ID
 0FFFF 080                     ; Class
 'Cancel' 0                    ; Title
 0]                            ; No creation data

[MDD0003: D$ 050000000 0      ; Style
 U$ 035 098 033 010            ; Dim
 07B                           ; ID
 0FFFF 080                     ; Class
 'Help' 0                      ; Title
 0]                            ; No creation data

[MDD0004: D$ 050000000 0      ; Style
 U$ 0C9 098 033 010            ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data

[MDD0005: D$ 050000000 0      ; Style
 U$ 069 098 05F 010            ; Dim
 078                           ; ID
 0FFFF 080                     ; Class
 'Store Equates to ClipBoard' 0 ; Title
 0]                            ; No creation data

[MDD0006: D$ 050802002 0      ; Style
 U$ 0C7 083 033 0C             ; Dim
 06E                           ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

[MDD0007: D$ 050000000 0      ; Style
 U$ 0A0 086 020 0B             ; Dim
 016E                           ; ID
 0FFFF 082                     ; Class
 'Id_Menu=' 0                ; Title
 0]                            ; No creation data


[ID_MenuEdit 065
 IDR_Radio 072
 IDR_Right 071
 IDR_Checked 070
 IDR_Grayed 06F
 ID_IDedit 06E
 ID_EquToClip 078  ID_MenuHelp 07B]

[hPopup: 0  hItem: 0  hLastPopUp: 0  hLastItem: 0
 hGrayed: 0   hChecked: 0   hRight: 0  hRadio: 0
 FirstMenuID: ' 1000', 0 0 0 0 0 0 0 0     MenuIDsHandle: 0]

[MENU_DWORDS 4000]

[eMenu: ? #MENU_DWORDS]  ; temporary table for menu edition
[ceMenu: ? #MENU_DWORDS] ; temporary table for menu edition control routine
[EndOfeMenu: ?]

[MenuEditHandle: 0   PostInit: 0  MenuEditIDHandle: 0   mEditClass: 'EDIT', 0]

[EdgeOfMenuEdition: 0FFFFFFFF]
[MenuEdition: B$ ?  #10000] [MenuItemsFlags: ? #500 MenuItemsFlagsEnd:]
[IndexToMenuItemsFlags: ?]

; MenuList, like 'DialogList', holds records for each menu to be used by
; 'TemporaryFillRsrcList' to prepare the Resource tree construction. Each record is:
; ID / Ptr / Size > 100 possible menus here:

 _________________________________

; These two basics routines are used for ID base holding (back and forth).
; Input dWord value in eax. Writes Ascii corresponding chain at edi:

[TenTable:  10000 1000  100  10  1 0]

TransDwordToAsciiDecimal:
    mov ebx TenTable, ecx D$ebx, B$edi '0'
L0: cmp eax ecx | jb L1>
        sub eax ecx | inc B$edi | jmp L0<
L1: inc edi |  mov B$edi '0' | add ebx 4 | mov ecx D$ebx | cmp ecx 0 | ja L0<
    mov B$edi 0
ret


[TranslateDwordToAscii | pushad | push #1 | pop eax | push #2 | pop edi
                                         call TransDwordToAsciiDecimal | popad]

TransDecimalAsciiToDword:
    While B$esi = ' '
        inc esi
    End_While
    mov ebx 0
L0: mov eax 0
    lodsb | cmp al 0 | je L9>
    sub al '0' | shl ebx 1 | add eax ebx | shl ebx 2 | add ebx eax    ; (EBX * 10) + AL
        jmp L0<
L9: mov eax ebx
ret

[TranslateAsciiToDword | push #1 | pop esi | call TransDecimalAsciiToDword]
 _________________________________

;;
 Here, we read a resource menu and translate it in formated text for Edit Control and
 in a dWords table of flags (at MenuItemsFlags). Down there, 'StoreMenuEdition' does
 the reverse operation. 'eMenu' is the resource menu, including header. 'MenuEdition'
 is the text table to send to Edit Control.
;;

[uMenu_ID: 1000] [MenuTabsCount: 0]

FillMenuEditData:
    mov D$MenuTabsCount 0
    mov esi eMenu, edi MenuEdition, ebx MenuItemsFlags
    add esi 8                                           ; skip header

L0: lodsd | mov D$ebx eax                               ; MFT Flags
    lodsd | or D$ebx eax                                ; MFS Flags

    lodsd                                               ; jump over ID

    mov eax 0 | lodsw                                   ; Pop Flags

    .If eax = PopUpFlag
        inc D$MenuTabsCount
        mov eax &MF_POPUP
    .Else_If eax = LastPopUpFlag
        inc D$MenuTabsCount
        mov eax &MF_POPUP__&MF_END
    .Else_If eax = LastItemFlag
        On D$MenuTabsCount > 0, dec D$MenuTabsCount
        push ebx, eax
            sub ebx 4
            .While ebx > MenuItemsFlags
                mov eax D$ebx | and eax POPMASK
                If eax = &MF_POPUP__&MF_END
                    On D$MenuTabsCount > 0, dec D$MenuTabsCount
                Else_If eax = &MF_POPUP
                   jmp L1>
                End_If
                sub ebx 4
            .End_While
L1:     pop eax, ebx
        mov eax &MF_END
    .End_If

    or D$ebx eax                                        ; All Flags

    lodsw                                               ; item first letter
    If ax = 0
      mov ax 0A0D | stosw                               ; Separator
    Else
      mov edx 0                                         ; simple counter for read alignement
L1:   stosb | inc edx
      lodsw | cmp ax 0 | jne L1<                        ; write item name
      mov ax 0A0D | stosw                               ; end mark
      test edx 1 | jz L2>
        lodsw                                           ; dWord align
L2:   test D$ebx &MF_POPUP
      jz L2>
        lodsd                                           ; + 1 dWord in case of popup
    End_If

L2: mov ecx D$MenuTabsCount, al tab
    while ecx > 0
        stosb | dec ecx
    End_While

    add ebx 4 | cmp esi D$EndOfeMenu | jb L0<<

; In case user hit some CR/LF at the end of menu items, some separators are added. This
; 'strip job' should be done at the end of 'StoreMenuEdition' but it is much more easier
; here, as some '0' analyzes are done here.

L8: cmp B$edi-1  ' ' | jae L9>
      dec edi | jmp L8<

L9: On B$edi = 0FF, inc edi                          ; edge in case of empty menu
    mov eax 0 | stosd                                   ; End mark


    mov esi MenuItemsFlags
ret

____________________________________________________________________________________________

; &MF_POPUP 010   &MF_END 080  > but in resources >>> word value = popup = 1 (my equates)
;
; &MFS_GRAYED 3   &MFS_CHECKED 8   &MF_HELP 04000   &MF_POPUP 010  &MF_END 080
; (grayed=1 + disable=2)
;
; &MFT_MENUBARBREAK  020   &MFT_MENUBREAK 040   &MFT_OWNERDRAW 0100
; &MFT_RADIOCHECK 0200     &MFT_RIGHTJUSTIFY 04000

[MFSMASK 00_1111    MFTMASK 0_FFFF_FF00     POPMASK 090]

[GrayedFlag 2  PopUpFlag 1  LastPopUpFlag 081  ItemFlag 0  LastItemFlag 080]

[SelectionStart: 0 SelectionEnd: 0  MenuFlagEnable: 0]


SetMenuItemFlag:
; When user double click on some item with possible spaces in it, we generalise
; one word selection to the whole item line (like in a List box):

    On B$OnMenuEdition = &FALSE, ret

    call 'User32.SendMessageA' D$MenuEditHandle &EM_GETSEL SelectionStart SelectionEnd
    mov ebx D$SelectionStart, eax D$SelectionEnd | sub eax ebx | cmp eax 0 | je L8>>
    call 'User32.SendMessageA' D$MenuEditHandle &EM_LINEFROMCHAR D$SelectionStart 0
  ; eax > line number
    call 'User32.SendMessageA' D$MenuEditHandle &EM_LINEINDEX    eax   0
  ; eax > first line char
        mov D$SelectionStart eax
    call 'User32.SendMessageA' D$MenuEditHandle &EM_LINELENGTH   eax   0
  ; eax > lenght
        add eax D$SelectionStart | mov D$SelectionEnd eax
    call 'User32.SendMessageA' D$MenuEditHandle &EM_SETSEL D$SelectionStart D$SelectionEnd

; Now, set the according flags:

    .If B$MenuFlagEnable = &FALSE
        call 'User32.EnableWindow' D$hRight &TRUE
        call 'User32.EnableWindow' D$hChecked &TRUE
        call 'User32.EnableWindow' D$hGrayed &TRUE
        call 'User32.EnableWindow' D$hRadio &TRUE
        call 'User32.SendMessageA' D$hRight &BM_SETCHECK 0 0
        call 'User32.SendMessageA' D$hChecked &BM_SETCHECK 0 0
        call 'User32.SendMessageA' D$hGrayed &BM_SETCHECK 0 0
        call 'User32.SendMessageA' D$hRadio &BM_SETCHECK 0 0
        mov B$MenuFlagEnable &TRUE

        call 'User32.SendMessageA' D$MenuEditHandle &EM_LINEFROMCHAR  D$SelectionStart 0
        shl eax 2 | mov D$IndexToMenuItemsFlags eax
        mov ebx MenuItemsFlags | add ebx eax | mov eax D$ebx
        test eax &MFS_GRAYED | jz L1>
            push eax
                call 'User32.SendMessageA' D$hGrayed &BM_SETCHECK 1 0
            pop eax
L1:     test eax &MFS_CHECKED | jz L1>
            push eax
                call 'User32.SendMessageA' D$hChecked &BM_SETCHECK 1 0
            pop eax
L1:   test eax &MFT_RADIOCHECK | jz L1>
            push eax
                call 'User32.SendMessageA' D$hRadio &BM_SETCHECK 1 0
            pop eax
L1:   test eax &MFT_RIGHTJUSTIFY | jz L9>>
            push eax
                call 'User32.SendMessageA' D$hRight &BM_SETCHECK 1 0
            pop eax
    .End_If
    jmp L9>

; sleep:

L8: If B$MenuFlagEnable = &TRUE
        call 'User32.EnableWindow' D$hRight &FALSE
        call 'User32.EnableWindow' D$hChecked &FALSE
        call 'User32.EnableWindow' D$hGrayed &FALSE
        call 'User32.EnableWindow' D$hRadio &FALSE
        mov B$MenuFlagEnable &FALSE
    End_If

L9: ret


; Read a menu in RosAsm PE. Basicaly same routine as the one for icons.

ReadRosAsmPeMenus:
    mov edi MenuList, eax 0, ecx 300 | rep stosd
    mov ebx RT_MENU | call SearchResourceType | On eax = 0, ret
    mov D$MenuListPtr MenuList, ebx MenuListPtr | call ReadResourcesRecord
ret
 ______________________________________

[PreviousEditProc: ?]

Proc InitMenuEdition:
    Argument @Adressee

    call 'User32.GetDlgItem' D@Adressee ID_MenuEdit
      mov D$MenuEditHandle eax

  ; subClassing Edit control for tab problem:
    call 'User32.SetWindowLongA' D$MenuEditHandle  &GWL_WNDPROC mEditProc
      mov D$PreviousEditProc eax

  ; Limit edition of Equate number to 5 chars and set text at 1000:
    call 'User32.GetDlgItem' D@Adressee ID_IDedit
      mov D$MenuIDsHandle eax

    call 'User32.SendMessageA' eax  &EM_SETLIMITTEXT 5  0

    call 'User32.SendMessageA' D$MenuIDsHandle  &WM_SETTEXT 0 FirstMenuID

  ; Disable all the CheckBoxes:
    call 'User32.GetDlgItem' D@Adressee IDR_Grayed | mov D$hGrayed eax
    call 'User32.EnableWindow' D$hGrayed &FALSE
    call 'User32.GetDlgItem' D@Adressee IDR_Checked | mov D$hChecked eax
    call 'User32.EnableWindow' D$hChecked &FALSE
    call 'User32.GetDlgItem' D@Adressee IDR_Right | mov D$hRight eax
    call 'User32.EnableWindow' D$hRight &FALSE
    call 'User32.GetDlgItem' D@Adressee IDR_Radio | mov D$hRadio eax
    call 'User32.EnableWindow' D$hRadio &FALSE
Endp

____________________________________________________________________________________________

[OneItemString: 160 ] [StringData: 0 #40]

GetuMenuID:
    call 'User32.SendMessageA' D$MenuIDsHandle &WM_GETTEXTLENGTH 0 0 | inc eax
    call 'User32.SendMessageA' D$MenuIDsHandle &WM_GETTEXT eax FirstMenuID
    TranslateAsciiToDword FirstMenuID
    mov D$FirstMenuId 0                           ; just for abort tests in callers:
    If eax > 32000                                ; 'StoreMenuEdition' / 'MenuEditProc'
      mov eax D$IdTooBigPtr | call MessageBox | mov D$FirstMenuId 0 | ret
    Else_If eax < 1   ;000
      mov eax D$IdTooSmallPtr | call MessageBox | mov D$FirstMenuId 0 | ret
    End_If
    mov D$uMenu_ID eax
    inc eax | mov D$FirstMenuId eax
ret

____________________________________________________________________________________________

EM_GETLINE_Comment:

;;
  EM_GETLINE Message, when applied to a Multi-Lines Edit Control, may fills the Destination
  Buffer with additional corrupted Characters. This seems to happend when a Logitech
  Mouse-Wheel Driver has been installed on the Computer (intellimouse 1.2a (Microsoft) 2 
  buttons + wheel // Win 2000).
  
  Hopefully, the (eax) Return Value, saying the number of written Chars seems good. This is 
  why i add this:
  
  > mov B$Destination+eax 0
  
  after retrieving a Line by EM_GETLINE Message.
;;




; Here, we save user definition for menu edition. We read Edit Control text and the
; flags table (at MenuItemsFlags). We write at 'eMenu:' a true resource conventional
; menu. Up there, 'FillMenuEditData' does the reverse operation.

[SeparatorsNumber: ?    PopUpNumber: ?]

StoreMenuEdition:
    call GetuMenuID | On D$FirstMenuId = 0, ret
   ; "EM_GETLINECOUNT" returns 1 if empty; so, ...:
    call 'User32.SendMessageA' D$MenuEditHandle, &EM_GETLINE, 0, OneItemString
    mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'

    If eax = 0
        mov D$FirstMenuId 0 | ret
    End_If

    mov edi eMenu, ecx MENU_DWORDS, eax 0 | rep stosd

    call 'User32.SendMessageA' D$MenuEditHandle, &EM_GETLINECOUNT, 0, 0

    mov ecx eax, ebx MenuItemsFlags, edi eMenu, edx 0
    mov D$SeparatorsNumber 0, D$PopUpNumber 0
    mov ax 1 | stosw | mov ax 4 | stosw | mov eax 0 | stosd     ; header (8 bytes)
L0: pushad
T0:     mov eax 0, edi OneItemString, ecx 40 | rep stosd        ; GETLINE not zero-ended
        mov W$OneItemString 160                                 ; max write for GETLINE
        call 'User32.SendMessageA' D$MenuEditHandle, &EM_GETLINE, edx, OneItemString
      ; Copied Line may be corrupted at the end with some weird Drivers on Board:
        mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'

        On eax = 0, jmp T1>
        mov esi OneItemString
        While B$esi = tab
            inc esi | dec eax                                   ; no header tabs in chars count
        End_While
        On B$esi = 0 , mov eax 0
        .If eax = 0
T1:         popad
                mov eax 0 | stosd | stosd | stosd | stosd       ; Separator = 16 zero bytes
                inc edx | inc D$SeparatorsNumber | add ebx 4
                If edx < ecx
                    pushad | jmp T0<<
                Else
                    jmp L9>>
                End_If
        .End_If
    popad

    mov eax D$ebx | and eax MFTMASK | stosd

    mov eax D$ebx | and eax MFSMASK | stosd

    mov eax D$FirstMenuID | add eax edx
    sub eax D$SeparatorsNumber
    sub eax D$PopUpNumber
    test D$ebx &MF_POPUP | jz F0>
        inc D$PopUpNumber | mov eax 0                          ; No ID for PopUp
F0: stosd                                                      ; ID number
    mov eax D$ebx | and eax POPMASK
    If eax = &MF_POPUP
        mov eax PopUpFlag
    Else_If eax = &MF_POPUP__&MF_END
        mov eax LastPopUpFlag
    Else_If eax = &MF_END
        mov eax LastItemFlag
    End_If
    stosw | mov esi OneItemString

    push ecx
        mov ecx 0, eax 0                                      ; align counter
        While B$esi < ' '
           lodsb                                              ; clear tabs if any
        End_While
L1:     lodsb | stosw | inc ecx | cmp al 0 | ja L1<           ; name
        test ecx 1 | jnz L2>
          stosw                                               ; align
L2: pop ecx
    test D$ebx &MF_POPUP | jz L3>
        stosd                                                 ; PopUp padding

L3: inc edx | add ebx 4 | cmp edx ecx | jb L0<<

L9: mov eax 0 | stosd | stosd

    mov D$EndOfeMenu edi, eax &TRUE
ret


PackMenuInList:
    mov eax D$MenuListPtr | add eax 4
    push eax
        mov edi D$MenuListPtr | mov eax D$uMenu_ID | stosd  ; ID
        push edi
            mov eax D$EndOfeMenu | sub eax eMenu | inc eax
            push eax
                VirtualAlloc TempoMemPointer eax            ; New memory
                mov ebx D$TempoMemPointer, eax ebx
            pop ecx
        pop edi
        stosd                                               ; Ptr (eax from 'AskMem')
        mov eax ecx                                         ; Size
        stosd
        mov esi eMenu, edi ebx | rep movsb                  ; store
    pop eax
  ;  call FreeMemory                                        ; release previous Listed memory
ret


; Here, we save Memu IDs Equates in CiplBoard 'WriteClipIDvalue' is a SubRoutine of
; 'ClipEquates'

[DataForClipEquates: ? #1000] [StartOfItemsLine: ?]

WriteClipIDvalue:
    mov ax '  ' | stosw
    mov eax D$FirstMenuID | add eax edx
    sub eax D$SeparatorsNumber | sub eax D$PopUpNumber

    push ecx
    ; adapted version of 'TransDwordToAsciiDecimal' for ID number:
      mov ebx TenTable, ecx D$ebx, B$edi '0'
L1:   cmp eax ecx | jae L2>
            add ebx 4 | mov ecx D$ebx | jmp L1<
L2:   cmp eax ecx | jb L3>
            sub eax ecx | inc B$edi | jmp L2<
L3:   inc edi |  mov B$edi '0' | add ebx 4 | mov ecx D$ebx | cmp ecx 0 | ja L2<

      mov ecx edi | sub ecx D$StartOfItemsLine        ; align items text (3 per line):
      If ecx > 64                                     ; 32 chars each
            mov ax 0A0D | stosw | mov al ' ' | stosb
            mov D$StartOfItemsLine edi
      Else
            mov al ' ' | and ecx 00_11111 | xor ecx 00_11111 | inc ecx | rep stosb
      End_If
    pop ecx


ret

____________________________________________________________________________________________

[MenuEquateIndice: 'M00_']

ClipEquates:
    mov D$MenuEquateIndice 'M00_'
    mov eax D$MenulistPtr | sub eax MenuList
    mov ebx 12, edx 0 | div ebx                 ; > indice = 0, 1, 2, ...
    mov ebx 10, edx 0 | div ebx
    add B$MenuEquateIndice+2 dl
    mov edx 0 | div ebx
    add B$MenuEquateIndice+1 dl

    call GetuMenuID
    call 'User32.SendMessageA' D$MenuEditHandle &EM_GETLINECOUNT 0 0
    mov ecx eax, edi DataForClipEquates, edx 0, D$SeparatorsNumber 0, D$PopUpNumber 0
    mov al '[' | stosb | mov D$StartOfItemsLine edi

    mov eax D$MenuEquateIndice | stosd | mov eax 'Menu' | stosd
    dec D$FirstMenuID | call WriteClipIDvalue | inc D$FirstMenuID

L0:
L1: push edi, ecx
        mov eax 0, edi OneItemString, ecx 40 | rep stosd        ; GETLINE not zero-ended
    pop ecx, edi
    mov W$OneItemString 160                                 ; max write for GETLINE
    pushad
        call 'User32.SendMessageA' D$MenuEditHandle, &EM_GETLINE, edx, OneItemString
        mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'
    popad
    mov esi OneItemString
    While B$esi = tab
        inc esi
    End_While
    If B$esi = 0
        inc D$SeparatorsNumber | inc edx | cmp edx ecx | je L9>>   ; No Separators
            jmp L1<<
    End_If
    mov eax D$MenuItemsFlags+edx*4 | test eax &MF_POPUP | jz T0>   ; No Popup  ; PopUpFlag
    inc D$PopUpNumber | inc edx | jmp L1<<

T0: mov esi OneItemString, eax 0, eax D$MenuEquateIndice | stosd
    While B$esi <= ' '
        lodsb                                           ; strip leading tabs and spaces
    End_While

L3: lodsb | cmp al 0 | je L4>
       ; On al = ' ', mov al '_'                         ; link separates words
        On al = '&', jmp L3<                            ; do not write '&'
        On al = tab  , jmp L4>                          ; do not write 'hot keys'
        On al < '0', mov al '_'
        If al = '_'
            On B$edi-1 = '_', jmp L3<                   ; only one '_' at a time
        End_If

        stosb | jmp L3<                                 ; name Char writing

L4: call WriteClipIDvalue

    inc edx | cmp edx ecx | jb L0<<

L9: dec edi | cmp B$edi ' ' | jbe L9<                   ; suppress lasting spaces / CR/LF
    inc edi | mov al ']' | stosb | mov al 0 | stosb     ; and close Bracket

    dec edi                                             ; reuse 'ControlC' for clip:
    push D$BlockStartTextPtr, D$BlockEndTextPtr, D$BlockInside
      mov D$BlockStartTextPtr DataForClipEquates, D$BlockEndTextPtr edi
      mov B$BlockInside &TRUE | call ControlC
    pop D$BlockInside, D$BlockEndTextPtr, D$BlockStartTextPtr
ret
____________________________________________________________________________________________
; As i get no end problems with this damned Edit Controls when i need to know if there
; are some ending CR/LF or not at the end, i get the text, strip the CR/LF, reset the
; text:

[LenOfMenuText: ?    TempoMenuTextPtr: ?]

CleanMenuEnd:
    call 'User32.SendMessageA' D$MenuEditHandle &WM_GETTEXTLENGTH 0 0
    inc eax | mov D$LenOfMenuText eax
    VirtualAlloc TempoMenuTextPtr eax
    call 'User32.SendMessageA' D$MenuEditHandle, &WM_GETTEXT, D$LenOfMenuText,
                               D$TempoMenuTextPtr
    mov esi D$TempoMenuTextPtr

    If D$esi = 0
L1:     VirtualFree D$TempoMenuTextPtr
        mov eax &FALSE | ret
    End_If
    add esi D$LenOfMenuText | mov D$esi+1 0
    While B$esi <= ' '
        mov B$esi 0 | dec esi | cmp esi D$TempoMenuTextPtr | jb L1<
    End_While
    call 'User32.SendMessageA' D$MenuEditHandle &WM_SETTEXT 0 D$TempoMenuTextPtr

    VirtualFree D$TempoMenuTextPtr
    mov eax &TRUE
ret

____________________________________________________________________________________________
; Here, we set the menu organisation flags (Item / LasItem / PopUp / LastPopUp)
; We use the number of leading tabs to retrieve the tree.

[MAXMENUTABS 500]

[MenuItemTabsList: B$ ? #MAXMENUTABS] [MenuItemTabsListPtr: ?]

StoreMenuPopFlags:
    mov D$MenuItemTabsListPtr MenuItemTabsList

    call 'User32.SendMessageA' D$MenuEditHandle, &EM_GETLINE, 0, OneItemString
    mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'

    On eax = 0, ret

    call 'User32.SendMessageA' D$MenuEditHandle, &EM_GETLINECOUNT, 0, 0

    mov ecx eax, edx 0

L0: pushad
      mov eax 0, edi OneItemString, ecx 40 | rep stosd       ; GETLINE not zero-ended
      mov W$OneItemString 160                                ; max write for GETLINE

      call 'User32.SendMessageA' D$MenuEditHandle, &EM_GETLINE, edx, OneItemString
      mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'

      mov esi OneItemString, edi D$MenuItemTabsListPtr, B$edi 1

      .If eax > 0
          While B$esi = tab
             lodsb | inc B$edi
          End_While
      .End_If
    popad

    inc D$MenuItemTabsListPtr | inc edx | cmp edx ecx | jb L0<<

    mov edi D$MenuItemTabsListPtr, D$edi 0

    ; Now, set the Flags in MenuItemsFlags:

    mov esi MenuItemTabsList, edi MenuItemsFlags

    .While B$esi > 0
        lodsb
        .If al > B$esi
            mov eax &MF_END
        .Else_If al = B$esi
            mov eax 0
        .Else
            push esi
                While B$esi > al
                    inc esi
                End_While
                If B$esi < al
                    mov eax &MF_POPUP__&MF_END
                Else
                    mov eax &MF_POPUP
                End_If
            pop esi
       .End_If
       or D$edi POPMASK | xor D$edi POPMASK | or D$edi eax
       add edi 4
    .End_While
ret


[Beep | On B$SoundsWanted = &TRUE, call BeepIt]

BeepIt: pushad | call 'USER32.MessageBeep' &MB_ICONHAND | popad | ret

call 'USER32.MessageBeep' &MB_ICONHAND
;;
0xFFFFFFFF Standard beep using the computer speaker
&MB_ICONASTERISK SystemAsterisk
&MB_ICONEXCLAMATION SystemExclamation
&MB_ICONHAND SystemHand
&MB_ICONQUESTION SystemQuestion
&MB_OK SystemDefault
;;

[ClickMessage: ?   OnMenuEdition: ?    MenuEditorHandle: ?]

Proc MenuEditProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    mov eax D@wParam | shr eax 16 | mov D$ClickMessage eax

    If D@Message = &WM_CTLCOLOREDIT
        call SetMenuItemFlag | mov B$OnMenuEdition &TRUE
    End_If

    ...If D@Message = &WM_COMMAND
        mov eax D@lParam
        .If eax = D$MenuEditHandle
            mov eax D@wParam | shr eax 16
            If eax = &EN_CHANGE
                call MenuLinesControl | popad | mov eax &TRUE | jmp L9>>
            End_If
        .End_If

        ..If D@wParam = &IDCANCEL
            mov B$OnMenuEdition &FALSE, D$MenuEditorHandle 0
            call 'User32.EndDialog' D@Adressee 0

        ..Else_If D@wParam = &IDOK
            call CleanMenuEnd
            If eax = &FALSE
                mov D$MenuEditorHandle 0 | call 'User32.EndDialog' D@Adressee 0
            End_If
            call StoreMenuPopFlags | call StoreMenuEdition
            If D$FirstMenuId <> 0
                call PackMenuInList
                mov B$OnMenuEdition &FALSE, D$MenuEditorHandle 0
                call 'User32.EndDialog' D@Adressee 0
            End_If

      ..Else_If D@wParam = ID_EquToClip
            call CleanMenuEnd
            If eax = &TRUE
                call StoreMenuPopFlags
                call StoreMenuEdition
                On D$FirstMenuId <> 0, call ClipEquates
            End_If

            On B$TagedEdition = &TRUE, mov B$TagedEdition 0-1

      ..Else_If D@wParam = ID_MenuHelp
            call Help, B_U_AsmName, MenuHelp, ContextHlpMessage

      ..Else_If D$ClickMessage = &BN_CLICKED
            mov eax D@lParam, ebx MenuItemsFlags               ; D$lParam = from what
            add ebx D$IndexToMenuItemsFlags

            If eax = D$hGrayed
                xor D$ebx &MFS_GRAYED
            Else_If eax = D$hChecked
               xor D$ebx &MFS_CHECKED
            Else_If eax = D$hRight
               xor D$ebx &MFT_RIGHTJUSTIFY
            Else_If eax = D$hRadio
                xor D$ebx &MFT_RADIOCHECK
            End_If

      ..Else
            jmp L8>>

      ..End_If

    ...Else_If D@Message = &WM_INITDIALOG
        call FillMenuEditData | call InitMenuEdition D@Adressee
        call 'User32.SetDlgItemTextA' D@Adressee, 065, MenuEdition
        call 'User32.SendMessageA' D$MenuEditHandle, &EM_GETLINECOUNT, 0, 0
        mov D$NumberOfMenuLines eax
            call MenuLinesControl
        move D$MenuEditorHandle D@Adressee
        call 'USER32.SetClassLongA' D@Adressee, &GCL_HICON, D$wc_hIcon

        If B$TagedEdition = &TRUE
            call 'USER32.SendDlgItemMessageA' D@Adressee, ID_EquToClip,
                                              &WM_SETTEXT, 0, {'Replace in Source', 0}
        End_If

    ...Else_If D@Message = &WM_CTLCOLOREDIT
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    ...Else
L8:   popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP



NewMenu:
    mov esi MenuList                               ; (ID / Ptr / Size)
    While D$esi > 0
        mov eax D$esi | add esi 12
    End_While

    mov D$MenuListPtr esi

    If esi = MenuList
        mov eax 1000
    Else
        add eax 1000
    End_If
    mov D$uMenu_ID eax
    mov ebx 10, edi FirstMenuID | add edi 5
L0: mov edx 0 | div ebx
    dec edi | add dl '0' | mov B$edi dl | cmp edi FirstMenuID | ja L0<
    While B$edi = '0'
        mov B$edi ' ' | inc edi
    End_While

    mov eax 0, ecx MENU_DWORDS, edi eMenu | rep stosd     ; clear temporary table
    mov D$EndOfeMenu eMenu

    call MenuEditor
ret


SaveMenuBinaryFile:
  ; Prevent from Multiple Instances:
    If B$OnMenuEdition = &TRUE
        Beep | ret
    End_If

    mov D$MenuListPtr MenuList,  B$UserTellWhatMenu &FALSE
    While B$UserTellWhatMenu = &FALSE
        call WhatMenu
    End_While
    On D$MenuListPtr = 0, ret

    mov edi SaveFilter, eax 0, ecx 65 | rep stosd
    mov D$SaveDlgFilter 'New.', D$SaveDlgFilter+3 '.bmf', D$SaveDlgFilter+7 0

    call 'Comdlg32.GetSaveFileNameA' OpenDlg | On eax = &FALSE, ret

    call ForceExtension SaveDlgFilter, '.bmf'

    call 'KERNEL32.CreateFileA' SaveDlgFilter &GENERIC_WRITE,
                               &FILE_SHARE_READ__&FILE_SHARE_WRITE, 0,
                               &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0

    If eax = &INVALID_HANDLE_VALUE
        mov eax D$BusyFilePtr | call MessageBox | ret
    End_If

    mov D$DestinationHandle eax, D$NumberOfReadBytes 0

    mov esi D$MenuListPtr | mov ecx D$esi+8, esi D$esi+4

    call 'KERNEL32.WriteFile' D$DestinationHandle, esi, ecx, NumberOfReadBytes  0

    call 'KERNEL32.CloseHandle' D$DestinationHandle | mov D$DestinationHandle 0
ret


[BinMenuMemory: ?   BinMenuLength: ?]

LoadMenuBinaryFile:
    If B$OnMenuEdition = &TRUE
        Beep | ret
    End_If

    mov D$OtherFilesFilters BinMenuFilesFilters
    mov D$OpenOtherFileTitle DialogFilesTitle

    move D$OtherhwndFileOwner D$hwnd, D$OtherhInstance D$hInstance

    mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc

    On D$OtherSaveFilter = 0, ret

    call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
      mov eax D$BusyFilePtr | call MessageBox | ret  ; return to caller of caller
    Else
      mov D$OtherSourceHandle eax
    End_If

    call 'KERNEL32.GetFileSize' eax, 0 | mov D$BinMenuLength eax

    If eax > 0
        VirtualAlloc BinMenuMemory eax

        mov D$NumberOfReadBytes 0
        call 'KERNEL32.ReadFile' D$OtherSourceHandle, D$BinMenuMemory,
                                 D$BinMenuLength, NumberOfReadBytes, 0
    Else
        ret
    End_If

    call 'KERNEL32.CloseHandle' D$OtherSourceHandle

    mov esi MenuList | While D$esi <> 0 | add esi 12 | End_While
    mov eax D$esi-12 | add eax 1000 | mov D$esi eax
    mov eax D$BinMenuMemory, D$esi+4 eax
    mov eax D$BinMenuLength, D$esi+8 eax
ret


ReplaceMenuBinaryFile:
    If B$OnMenuEdition = &TRUE
        Beep | ret
    End_If

    mov D$MenuListPtr MenuList,  B$UserTellWhatMenu &FALSE
    While B$UserTellWhatMenu = &FALSE
        call WhatMenu
    End_While
    On D$MenuListPtr = 0, ret

    mov D$OtherFilesFilters BinMenuFilesFilters
    mov D$OpenOtherFileTitle DialogFilesTitle

    move D$OtherhwndFileOwner D$hwnd, D$OtherhInstance D$hInstance

    mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc

    On D$OtherSaveFilter = 0, ret

    call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
      mov eax D$BusyFilePtr | call MessageBox | ret  ; return to caller of caller
    Else
      mov D$OtherSourceHandle eax
    End_If

    call 'KERNEL32.GetFileSize' eax, 0 | mov D$BinMenuLength eax

    If eax > 0
        VirtualAlloc BinMenuMemory eax

        mov D$NumberOfReadBytes 0
        call 'KERNEL32.ReadFile' D$OtherSourceHandle, D$BinMenuMemory,
                                 D$BinMenuLength, NumberOfReadBytes, 0
    Else
        ret
    End_If

    call 'KERNEL32.CloseHandle' D$OtherSourceHandle

    mov esi D$MenuListPtr
    push esi
        VirtualFree D$esi+4
    pop esi
    mov eax D$BinMenuMemory, D$esi+4 eax
    mov eax D$BinMenuLength, D$esi+8 eax
ret


MenuEditor:
    If D$MenuEditorHandle = 0
        call 'User32.DialogBoxIndirectParamA' D$hinstance, MenuDialogData, D$hwnd,
                                              MenuEditProc, 0
    Else
        Beep
    End_If
ret


[NoResourceMenu: '   There is no Menu in Resources    ', 0]
[UserTellWhatMenu: ?]

ExistingMenu:
    mov esi MenuList                                ; (ID / Ptr / Size)
    If D$esi = 0
       call 'User32.MessageBoxA' D$hwnd, NoResourceMenu, Argh,
                                 &MB_ICONINFORMATION+&MB_SYSTEMMODAL
       ret
    Else_If D$esi+12 = 0
      mov D$MenuListPtr MenuList
    Else
      mov D$MenuListPtr MenuList,  B$UserTellWhatMenu &FALSE
      While B$UserTellWhatMenu = &FALSE
        call WhatMenu
      End_While

      On D$MenuListPtr = 0, ret
    End_If

    ; MenuListPtr > choosen or alone menu

ReEditExistingMenu:

    mov esi D$MenuListPtr
    lodsd | mov D$uMenu_ID eax
      mov ebx 10, edi FirstMenuID | add edi 5
L0:     mov edx 0 | div ebx
          dec edi | add dl '0' | mov B$edi dl | cmp edi FirstMenuID | ja L0<
          While B$edi = '0'
            mov B$edi ' ' | inc edi
          End_While
    lodsd | mov ebx eax                           ; Ptr
    lodsd | mov ecx eax                           ; Size
    mov esi ebx, edi eMenu | rep movsb
    mov D$EndOfeMenu edi

    call MenuEditor
ret


[DelteMenuQuestion: 'Suppress choosen Menu from resources?', 0
 Sure: 'Are you sure...', 0]

DeleteMenu:
    mov esi MenuList                                ; (ID / Ptr / Size)

    If D$esi = 0
       call 'User32.MessageBoxA' D$hwnd, NoResourceMenu, Argh,
                                 &MB_ICONINFORMATION+&MB_SYSTEMMODAL
       ret
    Else
        mov D$MenuListPtr MenuList,  B$UserTellWhatMenu &FALSE
        While B$UserTellWhatMenu = &FALSE
            call WhatMenu
        End_While

        On D$MenuListPtr = 0, ret
    End_If

    call 'User32.MessageBoxA' D$hwnd, DelteMenuQuestion, Sure,
                             &MB_ICONQUESTION+&MB_SYSTEMMODAL+&MB_YESNO
   .If eax = &IDYES
        call VerifyNotDialogMenu
        If B$CancelDeleteMenu = &FALSE
            mov esi D$MenuListPtr, edi esi | add esi 12
            mov ecx MAXMENU, eax esi | sub eax MenuList | sub ecx eax
            rep movsd
        End_If
   .End_If
ret


; User asked for delete a menu. If the menu is used by a Dialog we must ajust the Dialog
; data if user persist:

[CancelDeleteMenu: ?]

VerifyNotDialogMenu:
    mov B$CancelDeleteMenu &FALSE
    mov ecx 0, edx D$MenuListPtr, edx D$edx                  ; whished delete Menu ID
    mov esi DialogList | add esi 4 | mov D$DialogListPtr esi

    While D$esi > 0
      mov ebx D$DialogListPtr | mov ebx D$ebx    ; ebx > DialogData > menu (0 / 0FFFF)
      mov ax W$ebx+18

      .If ax = 0FFFF                             ; (see ex.: EditedDialogBoxData)
         mov ax W$ebx+20                         ; Menu ID
         If ax = dx
           call 'User32.DialogBoxIndirectParamA' D$hinstance DelMenuDialog D$hwnd,
                                                DelDialogMenuProc 0
           On B$CancelDeleteMenu = &TRUE, ret
         End_If
      .End_If

      add D$DialogListPtr 12 | mov esi D$DialogListPtr
    End_While
ret


Proc DelDialogMenuProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND

        .If D@wParam = &IDCANCEL
            mov D$CancelDeleteMenu &TRUE | call 'User32.EndDialog' D@Adressee 0

        .Else_If D@wParam = &IDOK
            mov edi D$DialogListPtr, edi D$edi, eax 0   ; scratch menu record in Dialog Data:
            add edi 18 | stosw                          ; replace 0FFFF by 0
            mov esi edi | add esi 2                     ; (see ex: EditedDialogBoxData)

          ; We can't copy simply, because of alignement to reset before first control.
            If W$esi = 0                                ; copy Class record
                movsw
            Else_If W$esi = 0FFFF
                movsd
            Else
                While W$esi <> 0 | movsw | End_While | movsw
            End_If

            If W$esi = 0                                ; copy Title record
                movsw
            Else
                While W$esi <> 0 | movsw | End_While | movsw
            End_If

            While W$esi <> 0 | movsw | End_While | movsw; we have strip one Word >

; If aligment is good now , it was not previously and had require the add of a zeroed word
            Test edi 00_111 | jz L1>
                mov eax 0 | stosw | jmp L2>

L1:         add esi 2

          ; copy remaining controls:
L2:         mov eax D$DialogListPtr                     ; > List recorded lenght of Dialog data
            add eax 4 | mov ecx D$eax                   ; lenght of data do NOT change
            sub ecx 26 | rep movsb                      ; 'about...'

            call 'User32.EndDialog' D@Adressee, 0
        .End_If

    ...Else_If D@Message = &WM_INITDIALOG
        call 'USER32.SetClassLongA' D@Adressee, &GCL_HICON, D$wc_hIcon

    ...Else
        popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP


[DelMenuDialog: D$ 090C408C2 0 ; Style
 U$ 03 0 0 09C 042             ; Dim  8c
 0                             ; no Menu
 0                             ; Class(not yet)
 'Delete Dialog Menu???...' 0  ; Title
 08 'Helv' 0]                  ; Font

[DMD0: D$ 050000000 0          ; Style
 U$ 014 015 0100 018           ; Dim
 022B                          ; ID
 0FFFF 082                     ; Class
 'This Menu is used by one or more Dialog(s).' 0 ; Title
 0]                            ; No creation data

[DMD1: D$ 050000000 0          ; Style
 U$ 02 02D 038 013             ; Dim
 02                            ; ID
 0FFFF 080                     ; Class
 'Abort' 0                     ; Title
 0]                            ; No creation data

[DMD2: D$ 050000000 0          ; Style
 U$ 03C 02D 04D 013            ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 'Delete in Dialog too' 0      ; Title
 0]                            ; No creation data

____________________________________________________________


[WhatMenuData: D$ 090CC08C2 0  ; Style
 U$ 04 0 0 01F9 080            ; Dim 88 > 80
 0                             ; Menu
 0                             ; Class(not yet)
 'WhatMenu Dialog' 0           ; Title
 08 'Helv' 0]                  ; Font

[WMD0000: D$ 050000000 0       ; Style
 U$ 0 060 044 013              ; Dim
 064                           ; ID
 0FFFF 080                     ; Class
 '<<<<' 0                      ; Title
 0]                            ; No creation data

[WMD0001: D$ 050000000 0       ; Style
 U$ 0167 060 091 014           ; Dim
 01                            ; IDOK
 0FFFF 080                     ; Class
 'Yeah! This is this one i was searching!' 0 ; Title
 0]                            ; No creation data

[WMD0002: D$ 050000000 0       ; Style
 U$ 046 060 047 013            ; Dim
 065                           ; ID
 0FFFF 080                     ; Class
 '>>>>' 0                      ; Title
 0]                            ; No creation data

[WMD0003: D$ 050000000 0       ; Style
 U$ 0B0 060 0B5 014            ; Dim 60 > 90 > 75
 02                            ; IDCancel
 0FFFF 080                     ; Class
 "I don't find it. Maybe i've lost it, i am so stupid..." 0 ; Title
 0]                            ; No creation data

 [IDNextMenu 3  IDPreviousMenu 4]


WhatMenu:
    call 'User32.DialogBoxParamA' D$hinstance, 500, D$hwnd, WhatMenuProc, 0
ret


[ActualMenutestID: ?]

; Tag Dialog 500

Proc WhatMenuProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND

        .If D@wParam = &IDCANCEL
            mov D$MenuListPtr 0, B$UserTellWhatMenu &TRUE
            call 'User32.EndDialog' D@Adressee 0

        .Else_If D@wParam = &IDOK
            mov B$UserTellWhatMenu &TRUE
            call 'User32.EndDialog' D@Adressee 0

        .Else_If D@wParam = IDNextMenu
            mov ebx D$MenuListPtr | add ebx 12
            If D$ebx > 0
                mov D$MenuListPtr ebx | call SetTestMenu D@Adressee
                call 'User32.EndDialog' D@Adressee 0
            End_If

        .Else_If D@wParam = IDPreviousMenu
            mov ebx D$MenuListPtr | sub ebx 12
            If ebx >= MenuList
            mov D$MenuListPtr ebx
            call 'User32.DestroyMenu' D$ActualMenutestID
            call SetTestMenu D@Adressee
            call 'User32.EndDialog' D@Adressee 0
            End_If

        .End_If

    ...Else_If D@Message = &WM_INITDIALOG
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        call SetTestMenu D@Adressee

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP


Proc SetTestMenu:
    Argument @Adressee

      mov eax D$MenuListPtr | add eax 4
      call 'User32.LoadMenuIndirectA' D$eax
      mov D$ActualMenutestID eax
      call 'User32.SetMenu' D@Adressee eax
EndP


; We associate each user edited line for menu with a table of flag. In case user suppress
; or add one line, we have to ajust the flag table:

; Copy whole user edition to "eMenu" (reuse of final storage area):

MenuCopy:
    mov edx 0, edi ceMenu, eax 0, ecx MENU_DWORDS | rep stosd
    mov edi ceMenu
    While edx < D$NumberOfMenuLines
L0:     pushad
            mov W$edi 160
            push edi
                call 'User32.SendMessageA' D$MenuEditHandle, &EM_GETLINE, edx, edi
            pop edi
            mov B$edi+eax 0  ; >>> 'EM_GETLINE_Comment'
        popad
        mov al 0, ecx 200 | repne scasb
        inc edx
    End_While
ret


[MenuEditCaretPos: ? ?]
SearchMenuLineChange:
    call 'USER32.GetCaretPos' MenuEditCaretPos
  ; Zero based X/Y in eax: Y >>> High Word // X >>> Low Word:
    mov eax D$MenuEditCaretPos+4 | shl eax 16 | or eax D$MenuEditCaretPos

    call 'USER32.SendMessageA' D$MenuEditHandle, &EM_CHARFROMPOS, 0, eax
  ; Line in the high Word:
    shr eax 16 | mov edx eax
ret

;;
    mov edx 0, esi ceMenu

L0: push edx, esi
        mov eax 0, edi OneItemString, ecx 40 | rep stosd       ; GETLINE not zero-ended
        mov W$OneItemString 160                                ; max write for GETLINE
        call 'User32.SendMessageA' D$MenuEditHandle, &EM_GETLINE, edx, OneItemString
        mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'
    pop esi, edx

    cmp eax 0 | je L9>
    mov edi OneItemString, ecx eax | repe cmpsb | jne L9>
    cmp B$esi 0 | jne L9>
        inc edx | inc esi | jmp L0<<
L9: ret
;;

; edx > 0 based index of suppressed item.

DeleteMenuFlagRecord:
    inc edx | mov edi MenuItemsFlags | shl edx 2 | add edi edx
    lea esi D$edi+4
    While esi < MenuItemsFlagsEnd | movsb | End_While
ret

    mov ecx MenuItemsFlagsEnd | sub ecx MenuItemsFlags | shr ecx 2
    sub ecx edx    ; Number of dWords to move backward.

    shl edx 2
    mov esi MenuItemsFlags | add esi edx | mov edi esi | add esi 4
    rep movsd
ret


; edx > 0 based index of added item.

InsertMenuFlagRecord:
    mov edi MenuItemsFlagsEnd, esi edi | sub esi 4
    mov ecx MenuItemsFlagsEnd | sub ecx MenuItemsFlags | shr ecx 2
    sub ecx edx    ; Number of dWords to move forward
    std | rep movsd | cld
    mov eax 0 | stosd
ret


[NumberOfMenuLines: ?]

MenuLinesControl:
    call 'User32.SendMessageA' D$MenuEditHandle, &EM_GETLINECOUNT, 0, 0

    If eax = D$NumberOfMenuLines
        call MenuCopy
    Else_If eax < D$NumberOfMenuLines   ; user has suppressed one item:
        mov D$NumberOfMenuLines eax
        call SearchMenuLineChange       ; edx > 0 based index of suppressed line
        call DeleteMenuFlagRecord
    Else                                ; user has added one item:
        mov D$NumberOfMenuLines eax
        call SearchMenuLineChange       ; edx > 0 based index of added line
        call InsertMenuFlagRecord
        call IndentMenuItem
    End_If
ret


[ItemLevel: ?] ; = how many tab in previous item

[ItemTab: B$ 9 0]

IndentMenuItem:
    push edx
        dec edx
        mov eax 0, edi OneItemString, ecx 40 | rep stosd       ; GETLINE not zero-ended
        mov W$OneItemString 160                                ; max write for GETLINE
        call 'User32.SendMessageA' D$MenuEditHandle, &EM_GETLINE, edx, OneItemString
        mov B$OneItemString+eax 0  ; >>> 'EM_GETLINE_Comment'
        mov D$ItemLevel 0, esi OneItemString
        While B$esi = tab
            inc D$ItemLevel | inc esi
            pushad
                call 'User32.SendMessageA' D$MenuEditHandle &EM_REPLACESEL &TRUE ItemTab
            popad

        End_While
    pop edx
ret


; Tab is used by edit controls/dialog box as a selector. We set in normal:

[mEditRet: ?  mEditAdressee: ?  mEditMessage: ?  mEditWparam: ?  mEditLparam: ?]

mEditProc:
    pop D$mEditRet, D$mEditAdressee, D$mEditMessage, D$mEditWparam, D$mEditLparam
    push D$mEditRet

    .If D$mEditMessage = &WM_KEYDOWN
        If D$mEditWparam = tab
            call StoreTabInClipBoard
            call 'User32.SendMessageA' D$MenuEditHandle &WM_PASTE 0  0
            mov eax &FALSE | ret
        End_If
    .End_If

L9: call 'User32.CallWindowProcA' D$PreviousEditProc D$mEditAdressee,
                                 D$mEditMessage, D$mEditWparam, D$mEditLparam
    ret


[TabForEditControl: B$ tab]

StoreTabInClipBoard:
    pushad
        push D$BlockStartTextPtr, D$BlockEndTextPtr, D$BlockInside
            mov D$BlockStartTextPtr TabForEditControl, D$BlockEndTextPtr TabForEditControl
            mov B$BlockInside &TRUE | call ControlC | mov B$BlockInside &FALSE
        pop D$BlockInside, D$BlockEndTextPtr, D$BlockStartTextPtr
    popad
ret


TITLE String

 _______________________________________________________________________________________
 _______________________________________________________________________________________

                            ; Strings Resources Management.
 _______________________________________________________________________________________
 _______________________________________________________________________________________

; Read resources when loading a new RosAsm PE:

ReadRosAsmStrings:
    mov edi StringsList, eax 0, ecx 300 | rep stosd
    mov ebx &RT_STRING | call SearchResourceType | On eax = 0, ret
    mov D$StringsListPtr StringsList,  ebx StringsListPtr | call ReadResourcesRecord
ret


; Editing Resources Strings. A simple EditBox holds the Strings. Each String begins with
; leading '#n ' 'n' being decimal Ascii. CR/LF are allowed inside Strings:

StringsResources:
    If D$StringsEditorHandle = 0
        call 'USER32.CreateDialogIndirectParamA' D$hinstance StringsDialog D$hwnd StringsProc 0
    Else
        Beep
    End_If
ret


[ID_HELP 3    ID_EDITSTRINGS 4]

[StringsDialog: D$ 090CC08C2 0        ; Style
 U$ 04 0 0 0DC 0C8             ; Dim
 0                             ;      no Menu
 '' 0                          ; Class
 'Strings Resources' 0         ; Title
 08 'Helv' 0]                  ; Font

[StringC0: D$ 050B000C4 0      ; Style
 U$ 0 0 0DB 0B2                ; Dim
 ID_EDITSTRINGS                ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

[strngC1: D$ 050000001 0      ; Style
 U$ 0A1 0B4 039 013            ; Dim
 &IDOK                            ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data

[StringC2: D$ 050000000 0      ; Style
 U$ 065 0B4 03A 013            ; Dim
 &IDCANCEL                    ; ID
 0FFFF 080                     ; Class
 'Cancel' 0                    ; Title
 0]                            ; No creation data

[StringC3: D$ 050000000 0      ; Style
 U$ 0 0B4 038 013              ; Dim
 ID_HELP                       ; ID
 0FFFF 080                     ; Class
 'Help' 0                      ; Title
 0]                            ; No creation data

____________________________________________________________________________________________
; Same as CleanMenuEnd.
; As i get no end problems with this damned Edit Controls when i need to know if there
; are some ending CR/LF or not at the end, i get the text, strip the CR/LF, reset the
; text:

[LenOfStringsText: ?    TempoStringsTextPtr: ?    StringsEditHandle: ?]

CleanStrings:
    mov B$ErrorString &FALSE
    call 'User32.GetDlgItem' D$StringsEditorHandle ID_EDITSTRINGS
    mov D$StringsEditHandle eax
    call 'User32.SendMessageA' D$StringsEditHandle &WM_GETTEXTLENGTH 0 0
    inc eax | mov D$LenOfStringsText eax

    VirtualAlloc TempoStringsTextPtr eax

    call 'User32.SendMessageA' D$StringsEditHandle &WM_GETTEXT,
                              D$LenOfStringsText D$TempoStringsTextPtr

    mov ecx eax | On ecx = 0, jmp L8>>

  ; Clean ending bad chars:
    mov esi D$TempoStringsTextPtr | add esi D$LenOfStringsText | mov D$esi+1 0
    While B$esi < ' '
        mov B$esi 0 | dec esi
    End_While

  ; Clean bad first chars too:
    mov esi D$TempoStringsTextPtr | add ecx esi      ; ecx = end of data
    While B$esi < '#'
        lodsb | cmp esi ecx | ja L1>
    End_While

L1: If B$esi <> '#'
L8:     call 'USER32.MessageBoxA' D$hwnd, BadStringID, ErrorMessageTitle, &MB_SYSTEMMODAL
        mov B$ErrorString &TRUE
    Else
        mov D$TempoStringsTextPtr esi
    End_If

L1: call 'User32.SendMessageA' D$StringsEditHandle &WM_SETTEXT 0 D$TempoStringsTextPtr
    VirtualFree D$TempoStringsTextPtr
ret
____________________________________________________________________________________________


[StringsEditorHandle: ?     StringsListHandle: ?    StringEditFirstRun: ?]

Proc StringsProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_INITDIALOG
        mov B$StringEditFirstRun &TRUE
        move D$StringsEditorHandle D@Adressee
        call 'USER32.GetDlgItem' D@Adressee ID_EDITSTRINGS | mov D$StringsListHandle eax
        call InitStringsList
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon

    ...Else_If D@Message = &WM_CTLCOLOREDIT                           ; Un-selected text at first show:
        .If B$StringEditFirstRun = &TRUE
            mov eax D$StringsListHandle
            If D@lParam = eax
                call 'User32.SendMessageA' D$StringsListHandle &EM_SETSEL 0 0
                mov B$StringEditFirstRun &FALSE
            End_If
        .End_If
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>>

    ...Else_If D@Message = &WM_COMMAND
        ..If D@wParam = &IDCANCEL
L1:         mov D$StringsEditorHandle 0
            call 'User32.DestroyWindow' D@Adressee

        ..Else_If D@wParam = ID_HELP
            call Help, B_U_AsmName, StringsHelp, ContextHlpMessage

        ..Else_If D@wParam = &IDOK
            call CleanStrings
            On B$ErrorString = &FALSE, call StoreStringsList
            If B$ErrorString = &FALSE
                call ReorderStringsList | call Group16Strings | jmp L1<<
            End_If

        ..End_If

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP


[TempoAsciiStrings: ?    TempoUnicodeStrings: ?    OneStringID: ?]

TransDwordToAsciiNakedDecimal:
    mov dl 0FF | push edx
    mov ecx 10
L0: mov edx 0 | div ecx | push edx | cmp eax 0 | ja L0<
L2: pop eax
    cmp al 0FF | je L9>
       add al '0' | stosb | jmp L2<
L9: ret


InitStringsList:
    mov esi StringsList | On D$esi = 0, ret

    VirtualAlloc TempoAsciiStrings 0FFFF
    mov ebx StringsList, edi eax                           ; ebx points to 'StringsList' ID
    mov D$StringsListPtr StringsList

    .While D$ebx > 0
        mov esi D$StringsListPtr
        mov al '#' | stosb
        lodsd | dec eax | shl eax 4 | mov D$OneStringID eax
        call TransDwordToAsciiNakedDecimal | mov al ' ' | stosb
        add D$StringsListPtr 4
        mov esi D$StringsListPtr, esi D$esi
        While W$esi > 0
            lodsw | movzx ecx ax
L0:         lodsw | stosb | loop L0<
            mov al CR | stosb | mov al LF | stosb
            If W$esi > 0
                mov al '#' | stosb
                inc D$OneStringID | mov eax D$OneStringID
                call TransDwordToAsciiNakedDecimal | mov al ' ' | stosb
            End_If
        End_While
        add D$StringsListPtr 8                             ; next record
        mov ebx D$StringsListPtr
    .End_While
    mov al 0 | stosb

    call 'User32.SendMessageA' D$StringsListHandle &WM_SETTEXT 0 D$TempoAsciiStrings

    VirtualFree D$TempoAsciiStrings
ret


[OneStringBuffer: ?    IndexToStringsLines: ?    ErrorString: ?    NumberOfStrings: ?]

[BadStringID: "Bad or missing ID number encounted    
                         or
   missing space separator or String", 0]

StoreStringsList:
    mov edi StringsList,  eax 0, ecx MAXSTRINGS | rep stosd

    mov B$ErrorString &FALSE, D$StringsListPtr, StringsList, D$IndexToStringsLines 0
    VirtualAlloc OneStringBuffer 0FFFF

    call 'User32.SendMessageA' D$StringsListHandle &EM_GETLINECOUNT 0 0
    mov D$NumberOfStrings eax

  ; Read one Line (supposed beginning with '#n ':
L0: mov edi D$OneStringBuffer, ecx 0FFFF, al 0 | rep stosb
    mov edi D$OneStringBuffer, W$edi 0FFFF
    push edi
    call 'User32.SendMessageA' D$StringsListHandle, &EM_GETLINE, D$IndexToStringsLines, edi
    pop edi
    mov B$edi+eax 0  ; >>> 'EM_GETLINE_Comment'
    cmp eax 0 | je L9>>
L1: mov edi D$OneStringBuffer, B$edi+eax 0

  ; Read next Line(s), in Case it (they) would not begin with '#', this would be the same
  ; String:
L1: mov esi D$OneStringBuffer | inc D$IndexToStringsLines         ; Allowing CR/LF:
    while B$esi <> 0
        lodsb
    End_While
    mov W$esi 0A0D | add esi 2
    mov W$esi 0FFFF
    push esi
        call 'User32.SendMessageA' D$StringsListHandle, &EM_GETLINE, D$IndexToStringsLines,
                                   esi
    pop esi
    mov B$esi+eax 0  ; >>> 'EM_GETLINE_Comment'
    mov ebx D$NumberOfStrings | cmp D$IndexToStringsLines ebx | je L2>
    mov B$esi+eax 0                     ; clear remaining 0FF / 0FFFF when 1 / 0 char
    cmp B$esi '#' | jne L1<
  ; '#' encounted >>> stop appending:
L2: sub esi 2 | mov B$esi 0 | dec D$IndexToStringsLines

    mov esi D$OneStringBuffer
    lodsb | cmp al '#' | jne L8>
    cmp B$esi ' ' | je L8>
    mov ecx 0
    While B$esi > ' '                   ; Compute #n:
        lodsb
        If al > '9'
L8:         call 'USER32.MessageBoxA' D$hwnd, BadStringID, ErrorMessageTitle, &MB_SYSTEMMODAL
            mov B$ErrorString &TRUE | ret
        Else_If al < '0'
            jmp L8<
        End_If
        sub al '0'                      ; convert Decimal to binary:
        lea ecx D$ecx+ecx*4             ;     ecx = ecx * 5
        lea ecx D$eax+ecx*2             ;     ecx = eax + old ecx * 10
    End_While

    On B$esi <> ' ', jmp L8<            ; Suppress > Allow Tab and CR/LF
                                        ; > Down there test ecx=0 instead
    mov eax ecx
    On eax > 0FFFF, jmp L8<
    mov edi D$StringsListPtr
    stosd                               ; store ID in 'StringsList'
    inc esi | mov ecx 0
    push esi
        While B$esi > 0
            lodsb | inc ecx             ; compute lenght
        End_While
        If ecx = 0
            pop esi | jmp L8<<
        End_If
        inc ecx
        push ecx
            inc ecx | shl ecx 1         ; Unicode length
            push ecx
                push edi, esi
                    VirtualAlloc TempoMemPointer ecx | mov eax D$TempoMemPointer
                pop esi, edi
                mov ebx eax | stosd     ; store Pointer
            pop eax | stosd             ; store Size
        pop ecx
        mov edi ebx, eax 0
    pop esi
L1: lodsb | stosw | loop L1<            ; Fill Unicode String mem
    add D$StringsListPtr 12
    inc D$IndexToStringsLines | jmp L0<<

    VirtualFree D$OneStringBuffer
ret


[Reordered: ?]

ReorderStringsList:
  ; First, numerical order:
L0: mov B$Reordered &FALSE
    mov esi StringsList, edi esi | add edi 12   ; esi > ID  // edi next ID
    While D$edi+4 > 0
        mov eax D$esi
        If eax > D$edi
            Exchange D$esi D$edi                ; exchange IDs
            Exchange D$esi+4 D$edi+4            ; exchange Ptrs
            Exchange D$esi+8 D$edi+8            ; exchange Sizes
            mov B$Reordered &TRUE
        End_If
        add esi 12 | add edi 12
   End_While
   cmp B$Reordered &TRUE | je L0<

  ; Now, ensure no identical IDs. If yes, auto_ajust:
L0: mov esi StringsList, B$Reordered &FALSE
    While D$esi+16 > 0
       mov eax D$esi
       If D$esi+12 = eax
           mov B$Reordered &TRUE | inc D$esi+12 | jmp L0<
       End_If
       add esi 12
    End_While
    cmp B$Reordered &TRUE | je L0<
ret


[NextIdNode: ?    Group16StringsLen: ?    StringsGroupBoudary: ?    GroupStringsID: ?]

; Resource tree IDs are not user defined IDs. They are ((User_ID shr 4) +1) and attached
; Resource Pointers point to groups of 16 Stings. Writes the ID high bits:

[StoreStringID | push eax | shr eax 4 | inc eax | mov D$GroupStringsID eax | pop eax]

Group16Strings:
    VirtualAlloc OneStringBuffer 0FFFF

    mov esi StringsList, D$StringsListPtr esi

L0: mov edi D$OneStringBuffer | cmp D$esi+4 0 | je L9>>

    mov eax D$esi | StoreStringID | mov D$Group16StringsLen 0
    move D$NextIdNode D$GroupStringsID | shl D$NextIdNode 4  ; '+16' is done by (shr 4)+1

  ; Store dummy Strings if the first ID is not at a 00_1_0000 boundary or if Strings IDs
  ; are missing in between:
L1: mov ecx D$esi
    .If esi > StringsList
        mov ebx D$esi-12
        and ecx 00_1111
        If ecx > ebx
            dec ecx | sub ecx ebx
        End_If
    .End_If
    jecxz L2>
; Guga points to a hang at' M0:' and replaces by the next 4 lines:
      ; I ensure ecx is dWord aligned, because i don't recall of this shit:
        or ecx 00_11 | xor ecx 00_11 | jecxz L2>
        mov eax 0200001                             ; 01 00 020 00 (1 Char: 1 Space).
;M0:     add D$Group16StringsLen 4 | stosd | loop M0<

        Do                                          ; <<< ('4 lines')
            add D$Group16StringsLen 4 | stosd       ; <<<
            sub ecx 4                               ; <<<
        Loop_Until ecx = 0                          ; <<<

  ; Store one String to "OneStringBuffer":
L2: push esi
        mov esi D$esi+4, ecx 0
        While W$esi > 0
            inc ecx | lodsw
        End_While
        mov eax ecx | stosw | add D$Group16StringsLen 2
        shl ecx 1 | add D$Group16StringsLen ecx
    pop esi
    push esi
        mov esi D$esi+4 | rep movsb                 ; Temporay Storage of one Unicode String
    pop esi

  ; Stop grouping if:
  ; - Next ID is 00_10000 aligned (ebx)
  ; - Previous ID includes 00_1111 (eax)
  ; - Next record is greater than next 16 Strings Node
  ; - Next record is empty
    mov eax D$esi, ecx eax | inc ecx                ; ecx: Next ID should be ID+1
    add esi 12 | mov ebx D$esi
    and eax 00_1111

    mov B$StringsGroupBoudary &FALSE
    If D$esi+4 = 0
        mov B$StringsGroupBoudary &TRUE             ; Next = empty
    Else_If eax = 00_1111
        mov B$StringsGroupBoudary &TRUE             ; Actual = End of Set
    Else_If ebx >= D$NextIdNode
        mov B$StringsGroupBoudary &TRUE             ; Next >= Start of Set
    End_If

    .If B$StringsGroupBoudary = &TRUE
        push esi
            push edi
                mov eax D$StringsListPtr | mov eax D$eax+4 | VirtualFree eax
                VirtualAlloc TempoMemPointer D$Group16StringsLen
                mov eax D$TempoMemPointer
                push eax
                    mov edi D$StringsListPtr
                    mov eax D$GroupStringsID | stosd    ; Write Splitted ID
                pop eax
                push eax
                    stosd                               ; Write Ptr
                    mov eax D$Group16StringsLen | stosd ; Write Lenght
                pop edi
                mov ecx eax, esi D$OneStringBuffer | rep movsb; Write Strings group Data
            pop edi
        pop esi
        add D$StringsListPtr 12 | jmp L0<<
    .Else_If D$esi = ecx
        jmp L2<<                            ; OK > group
    .Else
        jmp L1<<                            ; Missing records > Pad and group
    .End_If

L9: mov esi D$StringsListPtr
    While D$esi+4 > 0
        mov eax D$esi+4
        push esi
            VirtualFree eax                 ; Release possible tail mems.
        pop esi
        mov D$esi 0, D$esi+4 0, D$esi+8 0   ; Clear Record
        add esi 12
    End_While

    VirtualFree D$OneStringBuffer           ; Release temporary storage.
ret


TITLE Tools_Exec
 _______________________________________________________________________________________
 _______________________________________________________________________________________
;;
                               ; run "Calc.exe" and friends...
 _______________________________________________________________________________________
 _______________________________________________________________________________________

 Icons Links are not yet used by RosAsm. I had a look at Win32.hlp for how to use them
 from an app, in order to retrieve the true link. >>> 3 pages of C chiet (!!!!!!).

 So, i will try later to read the link file. It looks like this:


 D:\RosAsm\Calc.exe.lnk  334 bytes

00000000: 4C 00 00 00 01 14 02 00 - 00 00 00 00 C0 00 00 00
00000010: 00 00 00 46 13 00 00 00 - 20 00 00 00 C0 9C 12 13
00000020: 7C D1 BF 01 00 B0 92 B9 - CB D0 BF 01 00 8C FC C4
00000030: F8 CD BC 01 00 82 03 00 - 00 00 00 00 01 00 00 00
00000040: 00 00 00 00 00 00 00 00 - 00 00 00 00 90 00 14 00
00000050: 1F 00 E0 4F D0 20 EA 3A - 69 10 A2 D8 08 00 2B 30
00000060: 30 9D 19 00 23 43 3A 5C - 00 00 00 00 00 00 00 00
00000070: 00 00 00 00 00 00 00 00 - 00 11 EE 25 00 31 00 00
00000080: 00 00 00 6D 28 9A 65 11 - 00 50 72 6F 67 72 61 6D
00000090: 20 46 69 6C 65 73 00 50 - 52 4F 47 52 41 7E 31 00
000000A0: 20 00 31 00 00 00 00 00 - C8 28 4B 98 10 00 42 61
000000B0: 73 65 43 61 6C 63 00 42 - 41 53 45 43 41 4C 43 00
000000C0: 1C 00 32 00 00 82 03 00 - 3E 23 C0 BB 20 80 42 61
000000D0: 73 65 63 61 6C 63 2E 65 - 78 65 00 00 00 00 55 00
000000E0: 00 00 1C 00 00 00 01 00 - 00 00 1C 00 00 00 2D 00
000000F0: 00 00 00 00 00 00 54 00 - 00 00 11 00 00 00 03 00
00000100: 00 00 EE 15 26 16 10 00 - 00 00 00 43 3A 5C 50 72
                                              C  :  \  P  r
00000110: 6F 67 72 61 6D 20 46 69 - 6C 65 73 5C 42 61 73 65
           o  g  r  a  m --  F  i    l  =  s  \  <  a  s  e
00000120: 43 61 6C 63 5C 42 41 53 - 45 43 41 4C 43 2E 45 58
           C  a  l  c  \  <  A  S    =  C  A  L  C  .  =  X
00000130: 45 00 00 19 00 43 3A 5C - 50 72 6F 67 72 61 6D 20
           =              C  :  \    P  r  o  g  r  a  m --
00000140: 46 69 6C 65 73 5C 42 61 - 73 65 43 61 6C 63
           F  i  l  =  s  \  <  a    s  =  C  a  l  c

 So do i think it will be much easier to read this thing down to the end, make

 > std
 >   mov al ':', ecx 0FFFF | repne scasb | repne scasb   ; >>> edi > C:\Pr...
 > cld

 store a copy in place of default, and go on (3 simple lines instead of 3 uncertain pages).

 i'll see if it works like this later because i do not know if the links files are
 the same in all win32 platforms.... (i am affraid they are not...)

 Right now, if you use a calc that need installation at C:\somewhere\...
 just copy the full path and name down here instead of "CalcName" or "CalcLinkName".
 the "CalcLinkName" down here is the one i use on my computer... do it your own and
 recompile "CopyOfRosAsm.exe".
;;


[CalcMessage: "

    Copy your prefered Calc in this directory

    and rename it 'Calc.exe'

    or have a search for 'Calc.exe' in RosAsm source    
    and read the header comment...

     "  0

 FileNotFound: 'Requested file not found', 0]


[ProcessInfos: ? #4]

[CalcHandle: ?  CalcExitCode: ?  CalcWindow: ?]

;;
 Multi-instances Calc are a problem: I would have prefered to put the calc foreground
 in case user clic on RosAsm window without closing the calc. I have never been able to
 get the handle of it to transmit to 'SetForeground'. So i leave it like this: Each
 time [Calc] menu item is clicked, we first kill the calc (even if already dead). It
 works supringly well, but i do not understand why. It seams that Win doesn't reuse
 the same "handles"... help wanted!!!
;;

Calc:
    If B$OnCalc = &TRUE
      call 'KERNEL32.TerminateProcess' D$ProcessInfos D$CalcExitCode
    End_If

    call 'KERNEL32.CreateProcessA'  CalcName  0 0 0  0  0 0 0  STARTUPINFO  ProcessInfos

    On eax = 0,
      call 'KERNEL32.CreateProcessA'  CalcLinkName  0 0 0  0  0 0 0  STARTUPINFO  ProcessInfos

    If eax = 0
      call 'User32.MessageBoxA' D$hwnd, CalcMessage, FileNotFound,
                                &MB_ICONINFORMATION+&MB_SYSTEMMODAL
    Else
      call 'KERNEL32.GetExitCodeProcess' D$ProcessInfos CalcExitCode
      mov B$OnCalc &TRUE
    End_If
ret
________________________________________________________________________________________
________________________________________________________________________________________

[open: 'open', 0]

; Same but for OpCodes.hlp / Win32.hlp
;;
[OpCodesMessage: " Copy 'x86eas.hlp' in this directory
or run [Config] menu option" 0]

Opcodes_Hlp:
    call 'Shell32.ShellExecuteA' D$hwnd open  OpcodeHlpName NoParameter &NULL &SW_SHOWDEFAULT
    If eax <= 32
      call 'User32.MessageBoxA' 0 OpCodesMessage, FileNotFound, &MB_ICONINFORMATION+&MB_SYSTEMMODAL
    End_If
ret
;;

[WinHlpMessage: "Copy 'Win32.hlp' in this directory
or run [Config] menu option", 0]

Win32_Hlp:
    call Help Win32HlpName, NoParameter, WinHlpMessage
ret

;;
[Asm32HlpMessage: "Copy 'Asm32Tut.exe' in this directory
or run [Config] menu option", 0]

Asm32_Hlp:
    call 'Shell32.ShellExecuteA' D$hwnd open Asm32TutName NoParameter &NULL &SW_SHOWDEFAULT
    If eax <= 32
      call 'User32.MessageBoxA' 0 Asm32HlpMessage, FileNotFound, &MB_ICONINFORMATION+&MB_SYSTEMMODAL
    End_If
ret
;;

[MmediaHlpMessage: "Copy 'Mmedia.hlp' in this directory
or run [Config] menu option", 0]

Mmedia_Hlp:
    call Help MmediaHlpName, NoParameter, MmediaHlpMessage
ret


[OpenGlHlpMessage: "Copy 'OpenGl.hlp' in this directory
or run [Config] menu option", 0]

OpenGl_Hlp:
    call Help OpenGlHlpName, NoParameter, OpenGlHlpMessage
ret


[WinSockHlpMessage: "Copy 'WinSock.hlp' in this directory
or run [Config] menu option", 0]

WinSock_Hlp:
    call Help WinSockHlpName, NoParameter, WinSockHlpMessage
ret


[SDLRefHlpMessage: "Copy 'SDL.chm' in this directory
or run [Config] menu option", 0]

SDL_Hlp:
    call Help SDLRefName, NoParameter, SDLRefHlpMessage
ret


[sqliteHlpMessage: "Copy 'sqlite.hlp' in this directory
or run [Config] menu option", 0]

sqlite_Hlp:
    call Help sqliteName, NoParameter, sqliteHlpMessage
ret


[DevILHlpMessage: "Copy 'DevIL.html' in this directory
or run [Config] menu option", 0]

DevIL_Hlp:
    call Help DevILName, NoParameter, DxHlpMessage
ret


[DxHlpMessage: "Copy 'DirectX.hlp' in this directory
or run [Config] menu option", 0]

Dx_Hlp:
    call Help DxHlpName, NoParameter, DxHlpMessage
ret

;;
[WinDataFileMessage: "Run [Config] menu option and define a File    ", 0]

WinDataFile:
    call 'Shell32.ShellExecuteA' D$hwnd open WinDataFileName NoParameter &NULL &SW_SHOWDEFAULT
    If eax <= 32
      call 'User32.MessageBoxA' 0 WinDataFileMessage, FileNotFound, &MB_ICONINFORMATION+&MB_SYSTEMMODAL
    End_If
ret
;;

[RosAsmHlpMessage: "
Copy 'B_U_Asm.exe' in this directory or run:

[Configuration] menu option.


If this is for a first run, select:

[Configuration][Companion Files] and provide the Path to:

* [B_U_Asm.exe]

Then provide the Path to:        

* [Equates Path]

After this, RosAsm will shut down, and will be ready
for a first Run.

", 0]

RosAsmHelp:
    call Help B_U_AsmName, B_U_AsmTop, RosAsmHlpMessage
ret


[F2HlpMessage: "The File you defined in the [Configuration][Other Files]
to be activated by [F2] is not available", 0]

F2Help:
    If D$F2Name <> 0
        call Help F2Name, NoParameter, F2HlpMessage
    End_If
ret


[RosAsmLicenceHelp: 'RosAsm_License', 0]

LicenseView:
    call Help, B_U_AsmName, RosAsmLicenceHelp, ContextHlpMessage

    call 'USER32.MessageBoxA' D$hwnd,
        {"
        RosAsm License viewed       
        
                   Accept?", 0},
        {'License', 0}, &MB_SYSTEMMODAL__&MB_YESNO

    On eax = &IDNO, call 'KERNEL32.ExitProcess' 0
ret


[GplHelp: 'GPL', 0]

GPLView:
    call Help, B_U_AsmName, GplHelp, ContextHlpMessage
ret






[NoParameter: B$ 0 ;
 B_U_AsmTop: 'Top', 0
 StringsHelp: 'Strings_Editor', 0
 IconHelp: 'Icon_Editor', 0
 MenuHelp: 'Menus_Editor', 0
 DialogHelp: 'Dialog_Editor', 0
 TempateHelp: 'Reusing_Code' 0
 ConfigHelp:  'Configuration_Tab', 0
 DisassemblerHelp: 'Disassembling', 0
 IncludeFilesHelp: 'Include_Files', 0
 SourceEditor: 'Source_Editor', 0
 StructuresHelp: 'Structures', 0
 HelPFiles: 'HelpFiles', 0
 DisMap: 'Disassembler_Flags', 0
 UnusedSymbolsHelp: 'Unused_symbols_Scanner', 0]

[ContextHlpMessage: 'Run [Configuration]/|Files Locations]/[RosAsm]     ' 0]

;[ContextHelp | call 'Shell32.ShellExecuteA' D$hwnd open, B_U_AsmName, #1, &NULL, &SW_SHOWNORMAL
; cmp eax 32 | ja M0>
;    call 'User32.MessageBoxA' D$hwnd ContextHlpMessage, FileNotFound, &MB_ICONINFORMATION+&MB_SYSTEMMODAL
; M0:]


Proc ContextHelp:
    Argument @Doc, @ErrorMessage

        call 'Shell32.ShellExecuteA' D$hwnd, open, B_U_AsmName, D@Doc, &NULL,
                                     &SW_SHOWNORMAL

        If eax <= 32
            call 'User32.MessageBoxA' D$hwnd, D@ErrorMessage, FileNotFound,
                                      &MB_ICONINFORMATION+&MB_SYSTEMMODAL
        End_If
EndP


Proc Help:
    Arguments @HelpFile, @Page, @ErrorMessage

        call 'Shell32.ShellExecuteA' D$hwnd, open, D@HelpFile, D@Page, &NULL,
                                     &SW_SHOWNORMAL
        If eax <= 32
            push eax
                call 'User32.MessageBoxA' D$hwnd, D@ErrorMessage, FileNotFound,
                                          &MB_ICONINFORMATION+&MB_SYSTEMMODAL
            pop eax
        End_If
EndP


; Menu is build at 'AddUserMenu'

UserDefinedAction:
    sub eax 2000  ; eax = 0 to 8
    mov ecx (64*4) | mul ecx
    add eax UserMenu0Path

    call 'Shell32.ShellExecuteA' D$hwnd, open, eax, NoParameter, &NULL, &SW_SHOWDEFAULT
ret

______________________________________________________________________________________

; Show a Box with Ascii codes in decimal and Hexa:

[AsciiData: B$ ? #2860]

[AsciiDialog: D$ 090CC08C2 0   ; Style
 U$ 01 0 0 01E6 0109           ; Dim
 0                             ; Menu
 0                             ; Class(not yet)
 "Ascii Table" 0                ; Title
 08 'Helv' 0]                  ; Font

[AC0: D$ 0508008C4 0           ; Style
 U$ 1 1 01E5 0108              ; Dim
 0100                          ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data


; Build a text table to send to Edit Control:

AsciiTable:
    If D$AsciiDialogHandle > 0
        Beep | ret
    End_If

    push ebp
        mov edi AsciiData, ebx 0, ecx 10, ebp 0
        mov al tab | stosb
        .While ebp < 256
            mov al bl | On al < 32, mov al 2 | stosb
            mov al tab | stosb
            mov eax ebx | add edi 2
            mov edx 0 | div ecx
            add dl '0' | mov B$edi dl
            dec edi
            mov edx 0 | div ecx
            add dl '0' | mov B$edi dl
            dec edi
            mov edx 0 | div ecx
            add dl '0' | mov B$edi dl
            add edi 3 | mov al tab | stosb

            mov al '0' | stosb
            mov eax ebx, edx eax | shr eax 4
            and eax 0F | add al '0' | On al > '9', add al 7
            stosb
            mov eax edx
            and eax 0F | add al '0' | On al > '9', add al 7
            stosb

            add ebx 32
            cmp ebx 255 | jna L2>
            sub ebx 255
            mov al CR | stosb | mov al LF | stosb
            mov al tab | stosb | jmp L3>
L2:         mov al tab | stosb | stosb
L3:         inc ebp
        .End_While

        mov eax 0 | stosd
       ; Show resulting box:
        call 'User32.DialogBoxIndirectParamA' D$hinstance, AsciiDialog, 0, AsciiProc, 0
    pop ebp
ret


[TabDimPtr: 10] [AsciiDialogHandle: ?]

Proc AsciiProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    .If D@Message = &WM_COMMAND
        If D@wParam = &IDCANCEL
            mov D$AsciiDialogHandle 0
            call 'User32.EndDialog' D@Adressee 0
        Else
            call 'User32.GetDlgItem' D@Adressee 0100
            call 'User32.SendMessageA' eax &EM_SETSEL  0-1 0
        End_If

    .Else_If D@Message = &WM_INITDIALOG
        move D$AsciiDialogHandle D@Adressee
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        call 'User32.GetDlgItem' D@Adressee 0100
        call 'User32.SendMessageA' eax &EM_SETTABSTOPS 1 TabDimPtr
        call 'User32.SetDlgItemTextA' D@Adressee 0100 AsciiData

    .Else
       popad | mov eax &FALSE | jmp L9>

    .End_If

    popad | mov eax &TRUE

L9: EndP

___________________________________________________________________________________________
___________________________________________________________________________________________

;             Printer job (here, with fixed pitch fonts for sources alignment)
___________________________________________________________________________________________
___________________________________________________________________________________________

; This Structure is for call 'Comdlg32.PrintDlgA'. We really use only 'PD_Flags' to tell
; if we want/propose a user selected block to print or not:

[PRINTDLG:
 PD_lStructSize: len             PD_hWndOwner: 0       PD_hDevMode: 0
 PD_hDevNames: 0                 PD_hDC: 0
 PD_Flags: &PD_RETURNDC+&PD_SELECTION
 PD_nFromPage: W$ 0              PD_nToPage: 0         PD_nMinPage: 0
 PD_nMaxPage: 0                  PD_nCopies: 1
 PD_hInstance: D$ 0              PD_lCustData: 0
 PD_lpfnPrintHook: 0             PD_lpfnSetupHook: 0   PD_lpPrintTemplateName: 0
 PD_lpPrintSetupTemplateName: 0  PD_hPrintTemplate: 0  PD_hSetupTemplate: 0]

; Needed for 'GDI32.StartDocA' (no interrest for us):

[DocName: ' - Poor text Printer -'  0]

[DOCINFO: DI_cbSize: len  DI_lpszDocName: DocName  DI_lpszOutput: 0  DI_lpszDatatype: 0
           DI_fwType: 0]

; This is for call 'Comdlg32.ChooseFontA'. Important:

;[CF_PRINTERFONTS 2  CF_FIXEDPITCHONLY 04000  CF_INITTOLOGFONTSTRUCT 040]


; Default font for choose-font-box (Courier new 14).
; LOGFONTA Structure (Pointed by record 4 in CHOOSEFONT):

[CbBuffer:
 lfHeight: D$ 0FFFF_FFED    ; (-19) (for details, see "LOGFONT" in win32.hlp)
 lfWidth: D$ 0
 lfEscapement: D$ 0
 lfOrientation: D$ 0
 lfWeight: D$ 0190
 lfItalic: B$ 0
 lfUnderline: B$ 0
 lfStrikeOut: B$ 0
 lfCharSet: B$ 0
 lfOutPrecision: B$ 03
 lfClipPrecision: B$ 02
 lfQuality: B$ 01
 lfPitchAndFamily: B$ 031
 lfFaceName: B$ 'Courier New' 0] [CBBsecurityTail: 0 #5] ; 32 Bytes > Total lenght = 60 Bytes

[PrintTextMetric: 0 #20]

[CHOOSEFONT: CF_lStructSize: Len     CF_hWndOwner: 0      CF_hDC: 0
             CF_lpLogFont: cbbuffer  CF_iPointSize: 0
             CF_Flags: &CF_PRINTERFONTS+&CF_FIXEDPITCHONLY+&CF_INITTOLOGFONTSTRUCT
             CF_rgbColors: 0         CF_lCustData: 0      CF_lpfnHook: 0
             CF_lpTemplateName: 0    CF_hInstance: 0      CF_lpszStyle: 0
             CF_nFontType: W$ 0      CF_Alignment:  0     CF_nSizeMin: D$ 3
             CF_nSizeMax: 0ff]

[UserChoosenPrinterFont: ?]

; Our pointers:
[PrintStartPtr: ?  PrintEndPtr: ?   CharHight: ?  PageHight: ?  PrinterDCavailable: ?]

Print:
    On D$SourceLen = 0, ret

    If B$PrinterDCavailable = &TRUE
        call 'GDI32.DeleteDC' D$PD_hDC
        call 'GDI32.DeleteObject' D$UserChoosenPrinterFont
    End_If

    If B$BlockInside = &TRUE
        mov D$PD_Flags &PD_RETURNDC+&PD_SELECTION
    Else
        mov D$PD_Flags &PD_RETURNDC+&PD_NOSELECTION
    End_If

    call 'Comdlg32.PrintDlgA' PRINTDLG | On eax = 0, ret    ; The Printer dialog sets
    move D$CF_hDC D$PD_hDC,  D$CF_hWndOwner D$hwnd          ; the DC handle in PRINTDLG struc
    If D$PD_Flags = &PD_RETURNDC+&PD_SELECTION
        move D$PrintStartPtr D$BlockStartTextPtr, D$PrintEndPtr D$BlockEndTextPtr
    Else
        mov eax D$UpperLine | mov D$PrintStartPtr eax
        add eax D$SourceLen | mov D$PrintEndPtr eax
    End_If

    call 'Comdlg32.ChooseFontA' CHOOSEFONT | On eax = 0, ret    ; user sets the font:
    call 'GDI32.CreateFontIndirectA' cbbuffer
        mov D$UserChoosenPrinterFont eax

    call UpdateRegistry                                 ; To save last used Printer Font.

StartControlP:
    call 'GDI32.GetDeviceCaps' D$PD_hDC &VERTRES | mov D$PageHight eax   ; we set the sizes:
    call 'GDI32.GetTextMetricsA' D$PD_hDC PrintTextMetric
        mov eax D$PrintTextMetric, D$CharHight eax
        shl eax 4 | sub D$PageHight eax                 ; sub 16 lines for top/bottom blanks

    call 'GDI32.StartDocA' D$PD_hDC  DOCINFO | On eax le 0, jmp L7>>; we print:
        call 'GDI32.StartPage' D$PD_hDC | On eax le 0, jmp L7>>
            call 'GDI32.SelectObject' D$PD_hDC D$UserChoosenPrinterFont

          mov esi D$PrintStartPtr, edx 0
L0:       mov ebx esi, ecx 0
L1:       cmp B$esi ' ' | jb L2>
            lodsb | inc ecx | cmp esi D$PrintEndPtr | jae L3>
              jmp L1<
L2:       add esi 2                                                      ; strip CR/LR
L3:       push esi, edx
            On ecx > 0
              call 'USER32.TabbedTextOutA'  D$PD_hDC 0 edx ebx ecx 0,0,0
            End_If
          pop edx esi
          add edx D$CharHight
          If edx >= D$PageHight                                          ; Next page?:
            pushad
              call 'GDI32.EndPage' D$PD_hDC | On eax le 0, jmp L7>>
                call 'GDI32.StartPage' D$PD_hDC | On eax le 0, jmp L7>>
                  call 'GDI32.SelectObject' D$PD_hDC D$UserChoosenPrinterFont
            popad
            mov edx 0
          End_If
          On esi < D$PrintEndPtr, jmp L0<<

        call 'GDI32.EndPage' D$PD_hDC | On eax le 0, jmp L7>>
      call 'GDI32.EndDoc' D$PD_hDC
    mov B$PrinterDCavailable &TRUE | ret

L7: call 'GDI32.AbortDoc' D$PD_hDC
    call 'GDI32.DeleteObject' D$UserChoosenPrinterFont
    call 'GDI32.DeleteDC' D$PD_hDC

    mov B$PrinterDCavailable &FALSE
ret


ControlP:
    If B$BlockInside = &FALSE
        ret
    Else_If B$PrinterDCavailable = &FALSE
        jmp Print
    Else
        move D$PrintStartPtr D$BlockStartTextPtr,  D$PrintEndPtr D$BlockEndTextPtr
        jmp StartControlP
    End_If

____________________________________________________________________________________________
____________________________________________________________________________________________

; Tool for viewing the System Resources and retrieving the IDs.

ViewSysResources:
    If D$ViewSysResourcesHandle = 0
        call 'USER32.DialogBoxParamA' D$hinstance 29000 &NULL ViewSysResourcesProc &NULL
    Else
        Beep
    End_If
ret


[ViewSysResourcesHandle: ?    SysBitMapsHandle: ?    SysIconsHandle: ?    SysCursorsHandle: ?]

Proc ViewSysResourcesProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_INITDIALOG
        move D$ViewSysResourcesHandle D@Adressee
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        call 'USER32.GetDlgItem' D@Adressee 10 | mov D$SysBitMapsHandle eax
        call 'USER32.GetDlgItem' D@Adressee 11 | mov D$SysIconsHandle eax
        call 'USER32.GetDlgItem' D@Adressee 12 | mov D$SysCursorsHandle eax
        call InitViewSysResourcesListBoxes
        mov D$SysButtonText 0 | jmp L8>>

    ...Else_If D@Message = &WM_COMMAND
        mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        ..If eax = &LBN_SELCHANGE
            call 'USER32.SendDlgItemMessageA' D@Adressee D@wParam &LB_GETCURSEL 0 0

            add D@wParam 10     ; Listy Box ID + 10 >>> Static Control ID

            If D@wParam = 20
                SetOKButtonSysText SysBitMapsStrings SysBitMapsIDs
                lea ebx D$SysBitMapsIDs+eax*4
                call 'USER32.LoadBitmapA' &NULL D$ebx
                mov ecx &IMAGE_BITMAP
            Else_If D@wParam = 21
                SetOKButtonSysText SysIconsStrings SysIconsIDs
                lea ebx D$SysIconsIDs+eax*4
                call 'USER32.LoadIconA' &NULL D$ebx
                mov ecx &IMAGE_ICON
            Else_If D@wParam = 22
                SetOKButtonSysText SysCursorsStrings SysCursorsIDs
                lea ebx D$SysCursorsIDs+eax*4
                call 'USER32.LoadCursorA' &NULL D$ebx
                mov ecx &IMAGE_CURSOR
            End_If

            call 'USER32.SendDlgItemMessageA' D@Adressee D@wParam &STM_SETIMAGE ecx eax
            call 'USER32.SendDlgItemMessageA' D@Adressee 1 &WM_SETTEXT 0 SysButtonText

        ..Else_If D@wParam = &IDCANCEL
            jmp L1>

        ..Else_If D@wParam = &IDOK
            If B$SysButtonText <> 0
                mov esi SysButtonText, edi SysButtonText
                While B$esi > 0
                    movsb
                    On W$esi = '&&', inc esi
                End_While
                mov B$edi 0

                mov eax SysButtonText, D$BlockStartTextPtr eax
                While B$eax > 0 | inc eax | End_While
                dec eax | mov D$BlockEndTextPtr eax, B$BlockInside &TRUE
                call ControlC | mov B$BlockInside &FALSE
            End_If

L1:         mov D$ViewSysResourcesHandle 0
            call 'USER32.EndDialog' D@Adressee 0

        ..End_If

    ...Else_If D@Message = &WM_CTLCOLOREDIT
        jmp L1>

    ...Else_If D@Message = &WM_CTLCOLORLISTBOX
L1:     call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP


[SetOKButtonSysText | mov edi #1 | mov edx #2 | call OKButtonSysText]

; Example: edi > SysBitMapsStrings // eax = zero Based Indice

[SysButtonText: ? #12]
[SysBitMapApiCall: "call 'USER32.LoadBitmapA' &&NULL &&" 0
 SysIconApiCall: "call 'USER32.LoadIconA' &&NULL &&" 0
 SysCursorApiCall: "call 'USER32.LoadCursorA' &&NULL &&" 0]

OKButtonSysText:
    push eax, ebx
        .While eax > 0
            While B$edi <> 0 | inc edi | End_While
            inc edi | dec eax
        .End_While

        push edi
            mov edi SysButtonText
            If edx = SysBitMapsIDs
                mov esi SysBitMapApiCall
            Else_If edx = SysIconsIDs
                mov esi SysIconApiCall
            Else
                mov esi SysCursorApiCall
            End_If
            While B$esi <> 0 | movsb | End_While
        pop esi

      ; Copy the Equate in the Button Buffer:
        inc esi
        While B$esi <> 0 | movsb | End_While
        mov D$edi ' ; =', B$edi+4 ' ' | add edi 5

    pop ebx, eax
    push eax, ebx
        mov eax D$edx+eax*4 | call WriteEax | mov B$edi 0
    pop ebx, eax
ret


[SysStringPointer: ?]

[SysBitMapsStrings: B$
'&OBM_CLOSE' 0       '&OBM_UPARROW' 0     '&OBM_DNARROW' 0     '&OBM_RGARROW' 0
'&OBM_LFARROW' 0     '&OBM_REDUCE' 0      '&OBM_ZOOM' 0        '&OBM_RESTORE' 0
'&OBM_REDUCED' 0     '&OBM_ZOOMD' 0       '&OBM_RESTORED' 0    '&OBM_UPARROWD' 0
'&OBM_DNARROWD' 0    '&OBM_RGARROWD' 0    '&OBM_LFARROWD' 0    '&OBM_MNARROW' 0
'&OBM_COMBO' 0       '&OBM_UPARROWI' 0    '&OBM_DNARROWI' 0    '&OBM_RGARROWI' 0
'&OBM_LFARROWI' 0    '&OBM_SIZE' 0        '&OBM_BTSIZE' 0      '&OBM_CHECK' 0
'&OBM_CHECKBOXES' 0  '&OBM_BTNCORNERS' 0 0]

[SysBitMapsIDs:
 &OBM_CLOSE       &OBM_UPARROW     &OBM_DNARROW     &OBM_RGARROW
 &OBM_LFARROW     &OBM_REDUCE      &OBM_ZOOM        &OBM_RESTORE
 &OBM_REDUCED     &OBM_ZOOMD       &OBM_RESTORED    &OBM_UPARROWD
 &OBM_DNARROWD    &OBM_RGARROWD    &OBM_LFARROWD    &OBM_MNARROW
 &OBM_COMBO       &OBM_UPARROWI    &OBM_DNARROWI    &OBM_RGARROWI
 &OBM_LFARROWI    &OBM_SIZE        &OBM_BTSIZE      &OBM_CHECK
 &OBM_CHECKBOXES  &OBM_BTNCORNERS]

[SysIconsStrings: B$
'&IDI_APPLICATION' 0     '&IDI_HAND' 0    '&IDI_QUESTION' 0    '&IDI_EXCLAMATION' 0
'&IDI_ASTERISK' 0        '&IDI_WINLOGO' 0 0]

[SysIconsIDs: &IDI_APPLICATION  &IDI_HAND  &IDI_QUESTION  &IDI_EXCLAMATION
              &IDI_ASTERISK     &IDI_WINLOGO]

[SysCursorsStrings: B$
'&IDC_ARROW' 0      '&IDC_IBEAM' 0      '&IDC_WAIT' 0       '&IDC_CROSS' 0
'&IDC_UPARROW' 0    '&IDC_SIZENWS' 0    '&IDC_SIZENESW' 0   '&IDC_SIZEWE' 0
'&IDC_SIZENS' 0     '&IDC_SIZEALL' 0    '&IDC_NO' 0         '&IDC_APPSTARTING' 0
'&IDC_HELP' 0 0]

[SysCursorsIDs:
 &IDC_ARROW     &IDC_IBEAM         &IDC_WAIT       &IDC_CROSS     &IDC_UPARROW
 &IDC_SIZENWSE  &IDC_SIZENESW      &IDC_SIZEWE     &IDC_SIZENS    &IDC_SIZEALL
 &IDC_NO        &IDC_APPSTARTING   &IDC_HELP]

InitViewSysResourcesListBoxes:
    mov edi SysBitMapsStrings
    While B$edi <> 0
        push edi
        call 'USER32.SendMessageA' D$SysBitMapsHandle &LB_ADDSTRING 0 edi
        pop edi
        mov al 0, ecx 0FF | repne scasb
    End_While

    mov edi SysIconsStrings
    While B$edi <> 0
        push edi
        call 'USER32.SendMessageA' D$SysIconsHandle &LB_ADDSTRING 0 edi
        pop edi
        mov al 0, ecx 0FF | repne scasb
    End_While

    mov edi SysCursorsStrings
    While B$edi <> 0
        push edi
        call 'USER32.SendMessageA' D$SysCursorsHandle &LB_ADDSTRING 0 edi
        pop edi
        mov al 0, ecx 0FF | repne scasb
    End_While
ret

;;
____________________________________________________________________________________________
____________________________________________________________________________________________

 Used DLL in the actual Source.
;;


ShowSourceImports:
    If D$ImportDialogHandle = 0
        call 'USER32.DialogBoxParamA' D$hinstance, 1100, &NULL,
                                      ViewSourceImportsProc, &NULL
    End_If
ret


ShowSourceExports:
    If D$ExportDialogHandle = 0
        call 'USER32.DialogBoxParamA' D$hinstance, 1101, &NULL,
                                      ViewSourceExportsProc, &NULL
    End_If
ret


[DLLsProcListHandle: ?    DLLsProcFunctionsListHandle: ?]

Proc Enable:
    Arguments @ParentHandle, @ID

        call 'User32.GetDlgItem' D@ParentHandle, D@ID
        call 'User32.EnableWindow' eax &TRUE
EndP

Proc Disable:
    Arguments @ParentHandle, @ID

        call 'User32.GetDlgItem' D@ParentHandle, D@ID
        call 'User32.EnableWindow' eax &FALSE
EndP


[ImportDialogHandle: ?]

; Tag Dialog 1100

Proc ViewSourceImportsProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND
        mov eax D@wParam | and eax 0FFFF
        ..If eax = &IDCANCEL
            mov D$ImportDialogHandle 0
            call 'User32.EndDialog' D@Adressee, 0

        ..Else
            .If W@wParam = 10
                If W@wParam+2 = &LBN_SELCHANGE
                    call RestoreRealSource
                    call ViewDllFunctionList
                    call SetPartialEditionFromPos
                End_If
                call 'USER32.SetDlgItemInt' D@Adressee, 12, 0, &FALSE
                call Disable D@adressee, 3
                call Disable D@adressee, 4

            .Else_If W@wParam = 11
                If W@wParam+2 = &LBN_SELCHANGE
                    call 'USER32.SendMessageA' D$DLLsProcFunctionsListHandle,
                                               &LB_GETCURSEL, 0, 0

                    call 'USER32.SendMessageA' D$DLLsProcFunctionsListHandle,
                                               &LB_GETITEMDATA, eax, 0

                    call 'USER32.SetDlgItemInt' D@Adressee, 12, eax, &FALSE
                    call 'USER32.SendDlgItemMessageA' D@Adressee, 3, &WM_ENABLE,
                                                      &TRUE, 0
                    call Enable D@adressee, 3
                    call Disable D@adressee, 4

                End_If

            .Else_If W@wParam = 3
                call ImportFunctionFindFirst

                call 'USER32.SendMessageA' D$DLLsProcFunctionsListHandle, &LB_GETCURSEL, 0, 0
                call 'USER32.SendMessageA' D$DLLsProcFunctionsListHandle, &LB_GETITEMDATA,
                                           eax, 0
                On eax > 1, call Enable D@adressee, 4

            .Else_If W@wParam = 4
                call ImportFunctionFindNext

            .End_If
        ..End_If

    ...Else_If D@Message = &WM_INITDIALOG
        move D$ImportDialogHandle D@Adressee

        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon

        call 'USER32.GetDlgItem' D@Adressee, 10 | mov D$DLLsProcListHandle eax
        call 'USER32.GetDlgItem' D@Adressee, 11 | mov D$DLLsProcFunctionsListHandle eax

        call Disable D@adressee, 3
        call Disable D@adressee, 4

        call RestoreRealSource
        call InitImportsProcList
        call SetPartialEditionFromPos

        If B$DLLsFoundInSource = &FALSE
            call 'USER32.MessageBoxA' D$hwnd, {'No Import Function found in this Source', 0},
                                     {'Failure:', 0}, 0
            call 'USER32.EndDialog' D@Adressee, 0
        End_If

        popad | mov eax &FALSE | ExitP

    ...Else
        popad | mov eax &FALSE | ExitP

    ...End_If

L8: popad | mov eax &TRUE
EndP


ExportFunctionFindFirst:
    call 'USER32.SendMessageA' D$DLLsProcListHandle, &LB_GETCURSEL, 0, 0
    call 'USER32.SendMessageA' D$DLLsProcListHandle, &LB_GETTEXT, eax, SearchString

    .If eax <> &LB_ERR
        mov W$SearchString+eax '::' | add eax 2 | jmp L1>

ImportFunctionFindFirst:
    call 'USER32.SendMessageA' D$DLLsProcFunctionsListHandle, &LB_GETCURSEL, 0, 0
    call 'USER32.SendMessageA' D$DLLsProcFunctionsListHandle, &LB_GETTEXT, eax, SearchString

    .If eax <> &LB_ERR
        mov D$SearchString+eax "'" | inc eax
L1:     mov D$LenOfSearchedString eax

        call RestoreRealSource

        push D$DownSearch, D$CaseSearch, D$WholeWordSearch
            mov B$DownSearch &TRUE, B$CaseSearch &TRUE, B$WholeWordSearch &FALSE
            move D$CurrentWritingPos D$CodeSource
            call SetCaret D$CodeSource | move D$UpperLine D$CodeSource
            call AskForRedrawNow

                mov D$NextSearchPos 0

                call StringSearch

        pop D$WholeWordSearch, D$CaseSearch, D$DownSearch

        call SetPartialEditionFromPos

    .End_If
ret


ImportFunctionFindNext:
ExportFunctionFindNext:
    call RestoreRealSource
        push D$DownSearch, D$CaseSearch, D$WholeWordSearch
            call StringSearch
        pop D$WholeWordSearch, D$CaseSearch, D$DownSearch
    call SetPartialEditionFromPos
ret


[DLLsFoundInSource: ?]

InitImportsProcList:
    mov esi D$CodeSource, edx D$SourceEnd, B$DLLsFoundInSource &FALSE

    .While esi < edx
        mov eax D$esi
        ..If al = '"'
            inc esi
            While B$esi <> '"'
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ..Else_If al = "'"
            inc esi
            While B$esi <> "'"
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ..Else_If eax = MLC
            add esi 4
            While D$esi <> MLC
                inc esi | On esi = edx, jmp L9>>
            End_While
            add esi 4

        ..Else_If al = ';'
                While B$esi >= ' ' | inc esi | End_While

        ..Else
            or eax 020202020
            If eax = 'call'
                add esi 4
            Else_If eax = 'jmp '
                add esi 3
            Else
                jmp L8>>
            End_If

            While B$esi = ' ' | inc esi | End_While
            mov al B$esi
            .If al = '"'
                jmp L1>
            .Else_If al = "'"
L1:             inc esi | mov ebx esi
                While B$esi <> al
                    On B$esi <= ' ', jmp L2>
                    If B$esi = '.'
                        mov B$DLLsFoundInSource &TRUE
                        push eax, edx, D$esi, esi
                            mov B$esi 0
                            push ebx
                             call Lb_FindString D$DLLsProcListHandle, ebx
         ; call 'USER32.SendMessageA' D$DLLsProcListHandle, &LB_FINDSTRING, 0, ebx
                            pop ebx
                            On eax = &LB_ERR,
                            call 'USER32.SendMessageA' D$DLLsProcListHandle,
                                                       &LB_ADDSTRING, 0, ebx
                        pop esi, D$esi, edx, eax
                        jmp L2>
                    End_If

                    inc esi
                End_While

L2:             While B$esi <> al
                    inc esi | On esi >= edx, jmp L9>
                End_While

            .End_If

        ..End_If

L8:     inc esi

    .End_While

L9: ret


InitExportsProcList:
    mov esi D$CodeSource, edx D$SourceEnd, B$DLLsFoundInSource &FALSE

    .While esi < edx
        mov eax D$esi
        ..If al = '"'
            inc esi
            While B$esi <> '"'
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ..Else_If al = "'"
            inc esi
            While B$esi <> "'"
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ..Else_If eax = MLC
            add esi 4
            While D$esi <> MLC
                inc esi | On esi = edx, jmp L9>>
            End_While
            add esi 4

        ..Else_If al = ';'
                While B$esi >= ' ' | inc esi | End_While

        ..Else_If ax = '::'
                        mov B$DLLsFoundInSource &TRUE
                        push eax, edx, D$esi, esi
                            mov B$esi 0
                            While B$esi-1 > ' ' | dec esi | End_While

                            call 'USER32.SendMessageA' D$DLLsProcListHandle,
                                                       &LB_ADDSTRING, 0, esi
                        pop esi, D$esi, edx, eax
        ..End_If

        inc esi

    .End_While
L9: ret


[CurrentSelectionInDLLsList: ?]

ViewDllFunctionList:
    call 'USER32.SendMessageA' D$DLLsProcFunctionsListHandle, &LB_RESETCONTENT, 0, 0

    call 'USER32.SendMessageA' D$DLLsProcListHandle, &LB_GETCURSEL, 0, 0
    mov D$CurrentSelectionInDLLsList eax

    mov esi D$CodeSource, edx D$SourceEnd

    ..While esi < edx
        mov eax D$esi
        On al = 'C', or eax 020202020 | On al = 'c', or eax 020202020
        On al = 'J', or eax 020202020 | On al = 'j', or eax 020202020
        ...If al = '"'
            inc esi
            While B$esi <> '"'
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ...Else_If al = "'"
            inc esi
            While B$esi <> "'"
                inc esi | On esi >= edx, jmp L9>>
            End_While

        ...Else_If eax = MLC
            add esi 4
            While D$esi <> MLC
                inc esi | On esi = edx, jmp L9>>
            End_While
            add esi 4

        ...Else_If al = ';'
                While B$esi >= ' ' | inc esi | End_While

        ...Else_If eax = 'jmp '
            add esi 3 | jmp L1>

        ...Else_If eax = 'call'
            add esi 4
L1:         While B$esi = ' ' | inc esi | End_While
            mov al B$esi
            ..If al = "'"
L1:             inc esi | mov ebx esi
                .While B$esi <> al
                    On B$esi <= ' ', jmp L2>>
                    .If B$esi = '.'
                        push eax, ebx, edx, D$esi, esi
                            mov B$esi 0
                                call Lb_FindString D$DLLsProcListHandle, ebx
                            mov ecx eax
                        pop esi, D$esi, edx, ebx, eax

                        On ecx <> D$CurrentSelectionInDLLsList, jmp L2>>

                            inc esi | mov ebx esi

                            While B$esi <> al
                                inc esi | On esi >= edx, jmp L9>>
                            End_While
                            push D$esi, esi, edx
                                mov B$esi 0
                                push ebx
                                    call Lb_FindString D$DLLsProcFunctionsListHandle, ebx
                                pop ebx

                                If eax = &LB_ERR
                                    call 'USER32.SendMessageA' D$DLLsProcFunctionsListHandle,
                                                               &LB_ADDSTRING, 0, ebx
                                    call 'USER32.SendMessageA' D$DLLsProcFunctionsListHandle,
                                                               &LB_SETITEMDATA, eax, 1
                                Else
                                    push eax
                                    call 'USER32.SendMessageA' D$DLLsProcFunctionsListHandle,
                                                               &LB_GETITEMDATA, eax, 0
                                    inc eax
                                    pop edx
                                    call 'USER32.SendMessageA' D$DLLsProcFunctionsListHandle,
                                                               &LB_SETITEMDATA, edx, eax
                                End_If

                            pop edx, esi, D$esi
                            jmp L3>
                    .End_If

                    inc esi
                .End_While

L2:             While B$esi <> al
                    inc esi | On esi >= edx, jmp L9>
                End_While

            ..Else_If al = '"'
                jmp L1<<

            ..End_If

        ...End_If

L3:     inc esi

    ..End_While

L9: ret


Proc Lb_FindString:
    Argument @Lb_Handle, @Pointer
    Local @FirstFound
    Uses esi, edi, edx

        mov edx 0-1, D@FirstFound edx

L0:     push edx
            call 'USER32.SendMessageA' D@Lb_Handle, &LB_FINDSTRING, edx, D@Pointer
        pop edx

        .If eax <> &LB_ERR
            push eax
                call 'USER32.SendMessageA' D@Lb_Handle, &LB_GETTEXT, eax, SearchString
            pop edx

            mov esi D@Pointer, edi SearchString | lodsb
            and al UPPERCASEMASK | and B$edi UPPERCASEMASK

            While al = B$edi
                If al = 0
                    mov eax edx | ExitP
                End_If

                lodsb | inc edi
                and al UPPERCASEMASK | and B$edi UPPERCASEMASK
            End_While

            If D@FirstFound = 0-1
                mov D@FirstFound edx | inc edx | jmp L0<
            Else_If edx = D@FirstFound
                mov eax &LB_ERR
            Else
                inc edx | jmp L0<
            EndIf

        .End_If
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[ExportsFoundInSource: ?  ExportDialogHandle: ?]

; Tag Dialog 1101

Proc ViewSourceExportsProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND
        mov eax D@wParam | and eax 0FFFF

        ..If eax = &IDCANCEL
            mov D$ExportDialogHandle 0
            call 'User32.EndDialog' D@Adressee, 0

        ..Else
            .If W@wParam = 10
                If W@wParam+2 = &LBN_SELCHANGE
                    call ExportFunctionFindFirst
                End_If

            .End_If

        ..End_If

    ...Else_If D@Message = &WM_INITDIALOG
        move D$ExportDialogHandle D@Adressee

        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon

        call 'USER32.GetDlgItem' D@Adressee, 10 | mov D$DLLsProcListHandle eax

        call RestoreRealSource
        call InitExportsProcList
        call SetPartialEditionFromPos

        If B$DLLsFoundInSource = &FALSE
            call 'USER32.MessageBoxA' D$hwnd, {'No Export Function found in this Source', 0},
                                     {'Failure:', 0}, 0
            call 'USER32.EndDialog' D@Adressee, 0
        End_If

        popad | mov eax &FALSE | ExitP

    ...Else
        popad | mov eax &FALSE | ExitP

    ...End_If

L8: popad | mov eax &TRUE
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; DLLs Scan.

ExportScanner:
    call GetExportScannerFile

    ..If D$SfFileMemory <> 0
        push D$UserPeStart
            move D$UserPeStart D$SfFileMemory

            call StartScan

            .If eax <> 0
                call ReAlignPE | call GetExportDirPointer

                If D$NumberOfDisExportedFunctions <> 0
                    call 'USER32.DialogBoxParamA' D$hInstance, 30500, &NULL,
                                                  ViewExport, &NULL

                Else
                    jmp L7>

                End_If
            .Else
L7:             call 'USER32.MessageBoxA' D$hwnd, {'No Export found in this File', 0}, SfFile, 0

            .End_If

            VirtualFree D$UserPeStart
          ; D$UserPeStart and not D$SfFileMemory, because of the switch in 'ReAlignPE'

        pop D$UserPeStart

    ..End_If
ret


; Simplified version of 'StartNewDisFile', reuse the same Variables:

StartScan:
    mov edi FirstDisVirtualData, eax 0 | while edi < LastDisVirtualData | stosd | End_While

    mov D$DisPeOrigine 0 | GetPeHeader PeHeaderPointer
    mov eax D$eax | sub eax 080 | mov D$DisPeOrigine eax
  ; (080 is the RosAsm Data 'PeHeaderPointer')

    GetPeHeader PeHeader

    ..If eax < D$SfFileMemory
        mov eax 0

    ..Else_If eax > D$SfFileMemoryEnd
        mov eax 0

    ..Else
        mov eax D$eax

        .If eax = D$PeHeader
            GetPeHeader NumberOfSections | movzx eax W$eax

            If eax <> 0
                mov D$DisNumberOfSections eax
                GetPeHeader ImageBase | mov ebx D$eax, D$DisImageBase ebx
                move D$DisRvaSectionAlignment D$eax+4, D$DisFileSectionAlignment D$eax+8
            End_If

        .Else
            mov eax 0

        .End_If

    ..End_If
ret


; SImplified version of 'CheckExport':

GetExportDirPointer:
    GetPeHeader SectionTable | mov edx D$eax

    mov D$NumberOfDisExportedFunctions 0

    If edx <> 0
        mov ecx D$DisNumberOfSections

        GetPeHeader SectionsHeaders

L0:     mov ebx D$eax+SECTION_RVA |  cmp edx ebx | jb L1>
            add ebx D$eax+SECTION_FILESIZE | cmp edx ebx | jb L2>

L1:     add eax SECTIONHEADERSIZE | loop L0<
            ret

L2:     add edx D$UserPeStart | mov eax D$edx+(5*4), ebx D$edx+(6*4)
        On ebx > eax, mov eax ebx
        move D$NumberOfDisExportedFunctions eax
    End_If
ret


[SF:
 SF.lStructSize: D$ len
 SF.hwndOwner: D$ 0
 SF.hInstance: D$ 0
 SF.lpstrFilter: D$ SfFilter
 SF.lpstrCustomFilter: D$ 0
 SF.nMaxCustFilter: D$ 0
 SF.nFilterIndex: D$ 1
 SF.lpstrFile: D$ SfFile
 SF.nMaxFile: D$ &MAXPATH
 SF.lpstrFileTitle: D$ 0
 SF.nMaxFileTitle: D$ 0
 SF.lpstrInitialDir: D$ 0
 SF.lpstrTitle: D$ 0
 SF.Flags: D$ &OFN_CREATEPROMPT__&OFN_EXPLORER__&OFN_HIDEREADONLY__&OFN_LONGNAMES__&OFN_NONETWORKBUTTON__&OFN_OVERWRITEPROMPT__&OFN_PATHMUSTEXIST
 SF.nFileOffset: W$ 0
 SF.nFileExtension: W$ 0
 SF.lpstrDefExt: D$ 0
 SF.lCustData: D$ 0
 SF.lpfnHook: D$ 0
 SF.lpTemplateName: D$ 0]

[SfFilter: B$ 'Module Name', 0, '*.*', 0, 0]
[SfFile: B$ ? #&MAXPATH]
[SfFileHandle: ?    SfFileLen: ?    SfFileMemory: ?   SfFileMemoryEnd: ?]

GetExportScannerFile:
    mov D$SfFile 0, D$SfFileMemory 0
    move D$SF.hwndOwner D$hwnd, D$SF.hInstance D$hInstance
    call 'Comdlg32.GetOpenFileNameA' SF

    ..If D$SfFile <> 0
        call 'KERNEL32.CreateFileA' SfFile,
                                    &GENERIC_READ, &FILE_SHARE_READ__&FILE_SHARE_WRITE,
                                    0, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, &NULL

        .If eax = &INVALID_HANDLE_VALUE
            mov eax D$BusyFilePtr | call MessageBox | ret

        .Else
            mov D$SfFileHandle eax
            call 'KERNEL32.GetFileSize' eax, 0 | mov D$SfFileLen eax

            VirtualAlloc SfFileMemory D$SfFileLen
            add eax D$SfFileLen | mov D$SfFileMemoryEnd eax

            call 'KERNEL32.ReadFile' D$SfFileHandle, D$SfFileMemory D$SfFileLen,
                                     NumberOfReadBytes, 0

            call 'KERNEL32.CloseHandle' D$SfFileHandle

          ; Is it a PE?
            mov eax D$SfFileMemory | On W$eax <> 'MZ', jmp L7>
            sub eax DosHeader | add eax PeHeaderPointer
            mov ebx D$eax, eax D$SfFileMemory | add eax ebx
            On eax > D$SfFileMemoryEnd, jmp L7>
            On eax < D$SfFileMemory, jmp L7>
            On W$eax <> 'PE', jmp L7>

        .End_If
    ..End_If
ret

L7: mov eax D$NotPeExePtr | call MessageBox
    VirtualFree D$SfFileMemory
ret


[LV_COLUMN:
 @imask: D$ &LVCF_TEXT__&LVCF_WIDTH__&LVCF_FMT  ;__&LVCF_SUBITEM
 @fmt: D$ &LVCFMT_LEFT
 @cx: D$ 0
 @pszText: D$ 0
 @cchTextMax: D$ 0
 @iSubItem: D$ 0
 @iImage: D$ 0
 @iOrder: D$ 0]

[LV_ITEM:
 @imask: D$ &LVIF_TEXT
 @iItem: D$ 0
 @iSubItem: D$ 0
 @state: D$ 0
 @stateMask: D$ 0
 @pszText: D$ ExportViewBuffer
 @cchTextMax: D$ 0
 @iImage: D$ 0
 @lParam: D$ 0
 @iIndent: D$ 0]

[ScanExportPointer: ?    ScanPeOrigine: ?    SfListHandle: ?]

[ExportViewBuffer: ? #20] [AfterExportViewBuffer: ?]

; Tag Dialog 30500

Proc ViewExport:
    Arguments @Adressee, @Message, @wParam, @lParam
    Structure @RECT 16, @leftDis 0,  @topDis 4,  @rightDis 8,  @bottomDis 12

    pushad

    ...If D@Message = &WM_COMMAND
        mov eax D@wParam | and eax 0FFFF
        ..If eax = &IDCANCEL
            call 'User32.EndDialog' D@Adressee, 0

        ..Else
            call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &EM_SETSEL, 0-1, 0

        ..End_If

    ...Else_If D@Message = &WM_INITDIALOG

        call 'USER32.GetDlgItem' D@Adressee, 10 | mov D$SfListHandle eax

        call 'USER32.GetClientRect' D$SfListHandle D@RECT
        mov eax D@rightDis | sub eax D@leftDis | mov D@bottomDis eax
        shr eax 3 | mov D$LV_COLUMN@cx eax | sub D@bottomDis eax

        push eax
            mov D$LV_COLUMN@pszText {'Ordinal', 0}
            call 'USER32.SendMessageA' D$SfListHandle, &LVM_INSERTCOLUMN, 0, LV_COLUMN

            shl D$LV_COLUMN@cx 1 | mov eax D$LV_COLUMN@cx | sub D@bottomDis eax
            mov D$LV_COLUMN@pszText {'Relative Address', 0}
            call 'USER32.SendMessageA' D$SfListHandle, &LVM_INSERTCOLUMN, 1, LV_COLUMN

            move D$LV_COLUMN@cx D@bottomDis
        pop eax

        mov D$LV_COLUMN@pszText {'Name', 0}
        call 'USER32.SendMessageA' D$SfListHandle, &LVM_INSERTCOLUMN, 2, LV_COLUMN

      ; 'ExportSectionComments'

        GetPeHeader SectionTable | mov eax D$eax | add eax D$UserPeStart

        push eax
            mov eax D$eax+(3*4) | add eax D$UserPeStart
            If eax > D$UserPeStart
                On eax < D$UserPeEnd,
                        call 'USER32.SendMessageA', D@Adressee, &WM_SETTEXT, 0, eax
            End_If
        pop eax

        push eax
            mov ebx D$eax+(5*4), eax D$eax+(6*4)
            On ebx > eax, mov eax ebx
            call 'USER32.SendMessageA' D$SfListHandle, &LVM_SETITEMCOUNT, eax, 0
        pop eax

      ; Number of Functions:
        mov ecx D$eax+(5*4) | On D$eax+(6*4) > ecx, mov ecx D$eax+(6*4)
      ; Pointer to ExportAdressesTable:
        mov ebx D$eax+(7*4) | On ebx <> 0, add ebx D$UserPeStart
      ; Pointer to ExportNamesTable:
        mov esi D$eax+(8*4) | On esi <> 0, add esi D$UserPeStart
      ; Pointer to ExportOrdinals:
        mov edx D$eax+(9*4) | On edx <> 0, add edx D$UserPeStart

        On esi = edx, mov esi 0

        mov D$LV_ITEM@iItem 0

L0:   ; Write the Ordinal:
        ..If edx <> 0
            mov edi ExportViewBuffer, D$LV_ITEM@iSubItem 0
            push eax, ebx
                movzx eax W$edx | add edx 2 | call WriteEax | mov B$edi 0
            pop ebx, eax
            pushad
                call 'USER32.SendMessageA' D$SfListHandle, &LVM_INSERTITEM, 0, LV_ITEM
            popad
        ..End_If

      ; Write the Relative Address:
        ..If ebx <> 0
            mov edi ExportViewBuffer
            mov eax D$ebx
            If eax = 0
                call 'USER32.SendMessageA' D$SfListHandle, &LVM_DELETEITEM,
                                           D$LV_ITEM@iItem, 0
                jmp L7>>
            End_If
            add ebx 4  | push ebx | call WriteEax | pop ebx
            mov B$edi 0

            pushad
                mov D$LV_ITEM@iSubItem 1
                call 'USER32.SendMessageA' D$SfListHandle, &LVM_SETITEM, 0, LV_ITEM
            popad
        ..End_If

      ; Write the Function Name:
        ..If esi <> 0
            push esi
                mov esi D$esi, edi ExportViewBuffer | add esi D$UserPeStart
                .If esi =< D$UserPeStart
                    mov D$edi '???'
                .Else_If esi >= D$UserPeEnd
                    mov D$edi '???'
                .Else
                    While B$esi <> 0
                        If B$esi < ' '
                           ; call 'USER32.SendMessageA' D$SfListHandle, &LVM_DELETEITEM,
                           ;                            D$LV_ITEM@iItem, 0
                           ; pop esi | jmp L7>>
                           mov D$ExportViewBuffer '???' | jmp L2>
                        End_If
                        movsb
                        If edi = AfterExportViewBuffer
                            mov D$edi-3 '...' | jmp L2>
                        End_If
                        If esi = D$UserPeEnd
                            mov D$edi '???' | jmp L2>
                        End_If
                    End_While | mov B$edi 0
                .End_If
L2:         pop esi
            add esi 4
            pushad
                mov D$LV_ITEM@iSubItem 2
                call 'USER32.SendMessageA' D$SfListHandle, &LVM_SETITEM, 0, LV_ITEM
            popad
        ..End_If

        inc D$LV_ITEM@iItem | dec ecx | jnz L0<<

L7:     popad | mov eax &FALSE | ExitP

    ...Else
        popad | mov eax &FALSE | ExitP

    ...End_If

L8: popad | mov eax &TRUE
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; GUIDs Stuff

[ShowGUIDsHandle: ?  GUDfileIsThere: ?]

; All of this GUIDs stuff and the associated GUD file is to be used with:
;
; [COMCall | mov eax D$#1 eax D$eax | push #L>3 | Call D$eax+#1.#2 D$#1]

ViewGUIDs:
    If D$ShowGUIDsHandle = 0
        call 'USER32.CreateDialogParamA' D$hInstance, 35, D$hWnd, ShowGUIDsProc, &NULL
    End_If
ret


[GUIDsHelp: 'GUIDs', 0]

; Tag Dialog 35

Proc ShowGUIDsProc:
     Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ..If D@Message = &WM_COMMAND
        .If D@wParam = &IDCANCEL
L7:        mov D$ShowGUIDsHandle 0
           VirtualFree D$GUIDsFileMemory
           call 'User32.EndDialog' D@Adressee, 0

        .Else_If D@wParam = &IDOK
L8:         call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &LB_GETCURSEL, 0, 0
            call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &LB_GETTEXT, eax,
                                              TrashString

            call GetGUID eax | On D$GUIDsPastingType <> 101, jmp L7<<

        .Else_If D@wParam = &IDHELP
            call Help, B_U_AsmName, GUIDsHelp, ContextHlpMessage

        .Else_If D@wParam = 100
            mov D$GUIDsPastingType 100

        .Else_If D@wParam = 101
            mov D$GUIDsPastingType 101

        .Else
            mov eax D@wParam | shr eax 16
            On eax = &LBN_DBLCLK, jmp L8<<

        .End_If

    ..Else_If D@Message = &WM_INITDIALOG
        move D$ShowGUIDsHandle D@Adressee
        call 'USER32.GetDlgItem' D@Adressee, 10
        call InitGUIDsView eax | On B$GUIDsInit = &FALSE, jmp L7<<

        If B$SourceReady = &FALSE
            call Disable D@Adressee 100
            call Disable D@Adressee 101
        End_If

        On D$GUIDsPastingType = 0, mov D$GUIDsPastingType 101

        If D$GUIDsPastingType = 100
            call 'User32.SendDlgItemMessageA' D@Adressee, 100, &BM_SETCHECK, &TRUE, 0
        Else
            call 'User32.SendDlgItemMessageA' D@Adressee, 101, &BM_SETCHECK, &TRUE, 0
        End_If

    ..Else_If D@Message = &WM_VKEYTOITEM
            If W@wParam = &VK_RETURN
                jmp L8<<

            Else_If W@wParam = &VK_ESCAPE
                jmp L7<<

            End_If

    ..Else_If D@Message = &WM_CTLCOLORLISTBOX
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    ..Else
        popad | mov eax &FALSE | jmp L9>

    ..End_If

    popad | mov eax &TRUE
L9: EndP
____________________________________________________________________________________________

[GUIDsFilePath: B$ ? #&MAXPATH]

[GUIDsFileNamePointer: ?  GUIDsFileHandle: ?  GUIDsFileLength: ?
 GUIDsFileMemory: ?  GUIDsInit: ?]

[MissingGUIDsFile: B$ "
Before using this Tool,
you have to save the GUIDs File(s)
in the RosAsmFiles Directory
(aside Equates.equ)
", 0]

Proc InitGUIDsView:
    Argument @Handle

    mov esi IncludeFileName, edi GUIDsFilePath
    While B$esi <> 0 | movsb | End_While
    While B$edi-1 <> '\' | dec edi | End_While
    mov D$GUIDsFileNamePointer edi
    mov W$edi '*.', D$edi+2 'GUD'

    call 'KERNEL32.FindFirstFileA' GUIDsFilePath, FindFile

    ...If eax <> &INVALID_HANDLE_VALUE
        call 'KERNEL32.FindClose' eax

        mov esi FindFile.cFileName, edi D$GUIDsFileNamePointer
        While B$esi <> 0 | movsb | End_While | mov B$edi 0

        call 'KERNEL32.CreateFileA' GUIDsFilePath, &GENERIC_READ,
                                    &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL, 0
        mov D$GUIDsFileHandle eax

        call 'KERNEL32.GetFileSize' eax, 0 | mov D$GUIDsFileLength eax

        VirtualAlloc GUIDsFileMemory eax

        call 'KERNEL32.ReadFile' D$GUIDsFileHandle, D$GUIDsFileMemory,
                                 D$GUIDsFileLength, NumberOfReadBytes, 0

        call 'KERNEL32.CloseHandle' D$GUIDsFileHandle

        mov esi D$GUIDsFileMemory, edx esi | add edx D$GUIDsFileLength

        .While esi < edx
            .If B$esi = '['
                inc esi
                If B$esi = '&'
                    ;While B$esi <> '_' | inc esi | End_While |
                    inc esi
                    mov edi TrashString
                    While B$esi <> ':' | movsb | End_While | mov B$edi 0
                    push edx
                        call 'USER32.SendMessageA' D@Handle, &LB_ADDSTRING, 0, TrashString
                    pop edx
                End_If
            .End_If

            inc esi

        .End_While

        mov B$GUIDsInit &TRUE

    ...Else
        call 'USER32.MessageBoxA', 0, MissingGUIDsFile, {'File not found', 0}, 0

    ...End_If
EndP
____________________________________________________________________________________________

[GUID_MotherNamePointer: ?   SourceComment: ?  GUIDsPastingType: ?]

Proc GetGUID:
    Argument @Length

    mov D$SourceComment 0
    mov esi D$GUIDsFileMemory, edx esi | add edx D$GUIDsFileLength

    .While esi < edx
        .If B$esi = '['
            mov ebx esi
            inc esi
            If B$esi = '&' ;'IID_'
                ;While B$esi <> '_' | inc esi | End_While |
                inc esi
                mov D$GUID_MotherNamePointer TrashString
                mov edi TrashString, ecx D@Length | repe cmpsb | je L5>

            End_If

        .Else_If B$esi = ';'
          ; Example: "; SOURCE FILE -> strmf.h"
            If D$esi+2 = 'SOUR'
                On D$esi+6 = 'CE F', mov D$SourceComment esi
            End_If

        .End_If

        inc esi

    .End_While

    ExitP

L5:

  ; ebx pointing to the wanted GUID.
    mov esi ebx, edi Trash

    If D$SourceComment <> 0
        push esi
            mov esi D$SourceComment
            While B$esi <> CR | movsb | End_While
            mov D$edi CRLF2 | add edi 4
        pop esi
    End_If

  ; Copy the GUID Data, with the Sizes Markers:
    mov B$edi '[' | inc edi | add esi 2
    While B$esi <> ':' | movsb | End_While | Movsb

    mov D$edi ' D$ ' | add edi 4
    While B$esi = ' ' | inc esi | End_While
    call MovsbHexa

    mov D$edi ' W$ ' | add edi 4
    While B$esi = ' ' | inc esi | End_While
    call MovsbHexa

    mov D$edi ' W$ ' | add edi 4
    While B$esi = ' ' | inc esi | End_While
    call MovsbHexa

    mov D$edi ' B$ ' | add edi 4
    .While B$esi <> ']'
        While B$esi = ' ' | inc esi | End_While
        call MovsbHexa
        mov B$edi ' ' | inc edi
    .End_While
    mov B$edi-1 ']'
    While B$esi <> CR | inc esi | End_While

    mov D$edi CRLF2 | add edi 4
    While B$esi <= ' '  | inc esi | End_While

  ; Copy the other stuff:
    .While esi < edx
        If W$esi = '[.'
            push edx
              ; Skip the "IID_" thingies:
                mov eax D$GUID_MotherNamePointer
                While B$eax <> '_' | inc eax | End_While | inc eax
                mov D$GUID_MotherNamePointer eax
                call BuildGUIDvTable | call InsertGUIDsObjectHandle
            pop edx
        Else_If W$esi = '[&'
            jmp L5>
        Else_If B$esi = ';'
            While B$esi <> CR | inc esi | End_While | add esi 2
        Else
            movsb
        End_If
    .End_While

L5: mov B$edi 0

    push D$BlockInside, D$BlockEndTextPtr, D$BlockStartTextPtr
        mov B$BlockInside &TRUE, D$BlockStartTextPtr Trash
        dec edi | mov D$BlockEndTextPtr edi

        call ControlC

        If D$GUIDsPastingType = 101
            mov B$BlockInside &FALSE
            call ControlV | call AskForRedrawNow
        End_If

    pop D$BlockStartTextPtr, D$BlockEndTextPtr, D$BlockInside
EndP


InsertGUIDsObjectHandle:
  ; Insert the Object Handle Declaration:
    mov D$edi CRLF2 | add edi 4

    mov B$edi '[' | inc edi
    push esi
        mov esi D$GUID_MotherNamePointer
        ;While B$esi <> '_' | inc esi | End_While | inc esi
        While B$esi <> 0 | movsb | End_While
        mov B$edi ':' | inc edi
    pop esi
    mov D$edi ' ?]' | add edi 3
ret
____________________________________________________________________________________________

; Just to turn all GUIDs' hexa numbers upper cases:

MovsbHexa:
L0: lodsb
    .If al > ' '
        If al = ']'
            dec esi | ret
        Else_If al < 'Z'

        Else
            sub al ' '
        End_If

        stosb | jmp L0<
    .End_If
ret
____________________________________________________________________________________________

[vTableQueryInterface: '.QueryInterface', 0
 vTableAddRef: '.AddRef', 0
 vTableRelease: '.Release', 0]

BuildGUIDvTable:
    mov D$GUIDDisplacementEquate 0
  ; Copy the '[':
    movsb
    push esi
        zCopy D$GUID_MotherNamePointer, vTableQueryInterface
        call WriteGUIDDisplacementEquate
        mov B$edi ' ' | inc edi
        zCopy D$GUID_MotherNamePointer, vTableAddRef
        call WriteGUIDDisplacementEquate
        mov B$edi ' ' | inc edi
        zCopy D$GUID_MotherNamePointer, vTableRelease
        call WriteGUIDDisplacementEquate
    pop esi

    .While B$esi <> ']'
        mov B$edi ' ' | inc edi
        push esi | zCopy D$GUID_MotherNamePointer | pop esi
        While B$esi <> CR
            mov al B$esi, B$edi al | inc edi | inc esi
            If al = ']'
                dec edi | call WriteGUIDDisplacementEquate
                sub edi 2 | mov B$edi ']' | inc edi | ret
            End_If
        End_While

        call WriteGUIDDisplacementEquate

        While B$esi <= ' ' | inc esi | End_While
    .End_While
ret
____________________________________________________________________________________________

[GUIDDisplacementEquate: ?]

WriteGUIDDisplacementEquate:
    push ebx, edx, esi
        mov B$edi ' ' | inc edi
        mov eax D$GUIDDisplacementEquate
        call WriteEax
        add D$GUIDDisplacementEquate 4
    pop esi, edx, ebx
    mov W$edi CRLF | add edi 2
ret
____________________________________________________________________________________________


































TITLE Dialog

 _______________________________________________________________________________________
 _______________________________________________________________________________________

DialogMenuComment:
;;
 Main at: 'InitDialogEdition' / 'EditDialogBoxProc' / 'EditedDialogBoxProc'
          'CloseDialogEdition'
          'HelpDialog' / 'HelpDialogProc'

'InstallHook' 'MouseProc' 'ShowDialogResult'


                                  Dialog Editor

 Menus in Dialogs are stored either as "0" (no menu) or as, for exemple, "FFFF 0D8F"
 (menu with ID 0D8F). When Win runs a Dialog, it read the ID according menu in resources.
 As the "runing resources" in RosAsm Dialog Editor is nothing but RosAsm resources itselves
 (and not the futur resources of the futur PE we are writing), we can't set the wished
 value in the edited dialog template. Instead, we have to "LoadMenuIndirectA" / "SetMenu"
 inside the "EditedDialogBoxProc". (So do we in 'WhatMenu' > 'WhatMenuProc' > 'SetTestMenu'
 routine). So, we have a difficult job to do with 2 menus IDs instead of one (and hide any
 in "EditedDialogBoxData"):

 - When an existing Dialog is loaded, we save the true menu ID in D$DialogMenuTrueID.
   Then we ask Win for a handle for the menu template (for "SetMenu")
   The Dialog box template, then, has menu set at "0"...
 - In the Dialog-Main-Edit-Control (Editor), we show to the user the 'true' ID
 - As Menu are usually choosen by "WhatMenu" routine, we store the 'runing ID' in
   'D$ActualMenutestID'.

 So:  >  ActualMenutestID = Menu ID used by RosAsm to activate a menu.
      >  DialogMenuTrueID = Menu ID really saved in Editied PE Resources.

 A similar problem arises for Dialog Class. As soon as a class is written by user inside
 the template, the Dialog would desappear from screen (as not registered by RosAsm...).
 So, have we to hide this record from the editor internal Template and restore it before
 saving either in ClipBoard or in Resources. As the record is a string -and not a number-
 i choose to simply save it in a string table ('ClassRecord'), to restored it at saving
 time.
;;
 _______________________________________________________________________________________
 _______________________________________________________________________________________
 _______________________________________________________________________________________

[DialogMenuTrueID: ?]

[TypeFace: 'Arial', 0    Helv: 'Helv' 0]

[MyFontHandle: ?]

CreateFontForDialogEdition:
    call 'GDI32.CreateFontA' 10, 5, 0, 0, 400, 0, 0, 0, 1,   ;  DEFAULT_CHARSET 1  OEM_CHARSET 255
                             0, 0, 0, 0, TypeFace
    mov D$MyFontHandle eax
ret

_______________________________________________________________________________________
_______________________________________________________________________________________

[MaxTemplateText 0FFFF]

[D_button 080  D_Edit 081  D_Static 082  D_ListBox 083  D_ScrollBar 084  D_ComboBox 085]

[ID_Ilist 101  ID_IpopUpMenu 102]

; 080=button / 081=Edit / 082=Static / 083=ListBox / 084=ScrollBar / 085=ComboBox

; This is the text default template that user can see in in the main editor list:

[NewDialogTemplateText: D$ 0] [ClassRecord: ? #20]

[DefaultDialogTemplateText:
 B$
 'D$ 90C408C2 0 ; Style' 0               ; style / extended style
 'U$ 0000 0000 0000 00DC 00C8 ; Dim' 0   ; control-number, x, y, width, hight
 '0 ;      no Menu' 0                    ; no menu >>> 0. If Menu > 0FFFF ID
 '"" 0 ; Class' 0                        ; class 0 > default
 '"New Dialog" 0 ; Title' 0              ; title
 '08 "Helv" 0 ; Font'  0 0 255           ; font

 DefaultDialogTemplateTextLen: len]

[CommentDialogStyle:  ' ; Style' 0
 CommentDialogDim:    ' ; Dim' 0
 CommentDialogMenu:   ' ; Menu' 0
 CommentDialogClass:  ' ; Class' 0
 CommentDialogTitle:  ' ; Title' 0
 CommentDialogFont:   ' ; Font'  0
 CommentControlStyle: ' ; Style' 0
 CommentControlDim:   ' ; Dim' 0
 CommentControlID:    ' ; ID' 0
 CommentControlClass: ' ; Class' 0
 CommentControlTitle: ' ; Title' 0
 CommentControlCData: ' ; No creation data' 0]


; Default Visible text in Editor when adding/inserting a new Control:

[NewDialogControlText: B$
 'D$ 50000000 0 ; Style' 0          ; style / extended style
 'U$ 0000 0000 0038 0018 ; Dim' 0   ; x y w h
 '0000 ; ID' 0                      ; ID
 'FFFF 0080 ; Class' 0              ; Predefined class / 080=button
 '"New Control" 0 ; Title' 0        ; title
 '0 ; No creation data' 0 0 255     ; no creation data
 DefaultControlLenght: len]
; len = 07E 126 Octets // 'D$NewDialogTemplateText' = 010000 // 010000/07E = 520

; This is the template for edition (THE Editor):

[DialogBoxData:
 DialogStyle:
 D$ &WS_VISIBLE+&WS_THICKFRAME+&DS_SYSMODAL+&DS_SETFONT+&DS_3DLOOK+&DS_MODALFRAME+&WS_POPUP+&WS_CAPTION
 DialogExtStyle: 0

 ControlsNumber: U$ 1
 DialogX: 3
 DialogY: 3
 DialogW: 100
 DialogH: 340                       ; control-number, x, y, width, hight
    0                               ; no menu
    0                               ; class 0 > default
 DialogTitle: 'Dialogs Editor' 0    ; title
 DialogFontSize: 8  DialogFont: 'Helv' 0

; controls:
; main editor list:

D$ &WS_CHILD&WS_VISIBLE+&LBS_HASSTRINGS+&LBS_NOTIFY+&WS_VSCROLL+&WS_HSCROLL+&ES_AUTOVSCROLL+&ES_AUTOHSCROLL+&WS_BORDER+&WS_THICKFRAME

    0                        ; style / ext.style
   U$ 2 2  96 84             ; x y w h
     ID_Ilist                ; ID
     0FFFF                   ; Predefined class
     D_ListBox               ; List control for main editor
    '  ' 0 0                 ; button title
     0]


[DialogBoundingRectangle: DBRX1: ?  DBRY1: ?  DBRX2: ?  DBRY2: ?]
[BaseUnits: BaseUnitX1: ?   BaseUnitY1: ?   BaseUnitX2: ?   BaseUnitY2: ?]

[IDFstring: B$ "

    You must set the ID number of last created control.

    Unlike the Menu Editor, the Dialog Editor will not do this for you    
    and let you free of your equates choices.

    1) You are allowed to give the same ID number to several controls

    2) The Dialog Editor have no way to save your Equates Names
        nor to set them for you as the names MUST be unique.

    So >>> paper / pencil...

    ", 0]

;;
 Of no use now, but of some interrest:

 I wrote this at a time when the two dialogs (editior and edited) were redrawn after
 each modification. Now, only edited dialog is redrawn and all this is of no more use.
 But, as it have been some work..., i let it here (in case of need). This is a trick
 that gives the base unit (absolute need if we want to know where to set a dialog, but
 the direct function do NOT exist in Win api (!!!!!!!!)).
;;

;SaveDialogUserPosition:
;    ; MapDialog do this to BaseUnits values:
;    ;
;    ; left   = (left   * baseunitX) / 4
;    ; right  = (right  * baseunitX) / 4
;    ; top    = (top    * baseunitY) / 8
;    ; bottom = (bottom * baseunitY) / 8
;    ;
;    ; i only want to know baseUnits. So:
;
;    mov D$BaseUnitX1 4, D$BaseUnitY1 8, D$BaseUnitX2 0, D$BaseUnitY2, 0     ; <<< the
;    call 'User32.MapDialogRect' D$Adressee BaseUnits                        ; <<< trick
;
;    call 'User32.GetWindowRect' D$Adressee DialogBoundingRectangle
;   ; call 'User32.GetDialogBaseUnits'   ; of no need
;
;   ; dialogUnitX = (pixelX * 4) / baseunitX
;   ; dialogUnitY = (pixelY * 8) / baseunitY
;
;    mov eax D$DBRX1, edx 0
;    shl eax 2 | div D$BaseUnitX1
;    mov W$DialogX ax
;
;    mov eax D$DBRY1, edx 0
;    shl eax 3 | div D$BaseUnitY1
;    mov W$DialogY ax
;ret


[PreviousControlID: 0FFFF]

; If user selected a blank separator line, we do not add > we insert:

AddOneControl:
    If W$PreviousControlID = 0
        call 'USER32.MessageBoxA' D$hwnd, IDFstring, CCFtitle, &MB_SYSTEMMODAL | ret
    Else
        mov W$PreviousControlID 0            ; for next time test (filled -or not- by user)
    End_If

    call 'User32.SendMessageA' D$DialogListHandle &LB_GETCURSEL eax 0
    mov D$DialogListIndex eax

    On D$DialogListIndex > 0FFFF, mov D$DialogListIndex 0      ; no sel. > OK  > add

    mov eax D$DialogListIndex
    While eax >= 7 | sub eax 7 | End_While

    Push eax

    If eax = 6
      ; Insert 'DefaultControlLenght' of 'NewDialogControlText':
        dec D$DefaultControlLenght                                  ; no 255 end mark
        call SearchDialogLine | inc edi | mov edx edi               ; > start of next control
        mov al 255, ecx MaxTemplateText | repne scasb | dec edi     ; actual end
        mov esi edi | add edi D$DefaultControlLenght                ; new end
        mov ecx esi | sub ecx edx | inc ecx                         ; count moveable chars
        std | rep movsb | cld                                       ; make room
        mov edi edx, esi NewDialogControlText                       ; ready for copy
        mov ecx D$DefaultControlLenght                              ; how much
        rep movsb                                                   ; copy default control
        inc D$DefaultControlLenght                                  ; restore full lenght
    Else
      ; add:
        mov edi D$NewDialogTemplateText, al 255, ecx MaxTemplateText
        repne scasb | dec edi
        mov esi NewDialogControlText, ecx D$DefaultControlLenght
        rep movsb
    End_If

    call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
    pop eax

    If eax = 6                                                      ; if "insert":
        call ScrollToInsertedControl
    Else                                                            ; if "add":
        call ScrollDownToLastControl
    End_If

    mov edi D$NewDialogTemplateText, al 0, ecx 200 | repne scasb
    mov al '0' | repne scasb | add edi 2 | inc B$edi
    On B$edi > '9', add B$edi 7
    .If B$edi > 'F'
        mov B$edi '0' | inc B$edi-1
        On B$edi-1 > '9', add B$edi-1 7
        If B$edi-1 > 'F'
            mov B$edi-1 '0' | inc B$edi-2
            On B$edi-2 > '9', add B$edi-2 7       ; >>> up to FFF (4095 controls -enough?-)
        End_If
    .End_If
ret


ShowDialogResult:
  ; Under 98, impossible to destroy the old Window *after* having created the new one.
  ; (Works fine under 2000... too bad... ).

    mov eax D$EditedDialogBoxData
    push D$eax
        and D$eax 0FFF_FFFF | or D$eax &WS_VISIBLE__&WS_POPUP

        call 'User32.DestroyWindow' D$EditedDialogHandle
        call 'User32.CreateDialogIndirectParamA' D$hinstance, D$EditedDialogBoxData,
                                                 D$hwnd, EditedDialogBoxProc, 0
        mov D$EditedDialogHandle eax

        mov eax D$EditedDialogBoxData
    pop D$eax
ret

________________________________________________________________________________________

; This is the default 'StartUp' Dialog Data you see when cliclng on [New Dialog]:
; WS_THICKFRAME turns it 'sizeable' (for editing only, striped from savings).

[EditedDialogBoxData: D$ ?]

[DefaultEditedDialogBoxData:
 D$ &WS_VISIBLE+&WS_THICKFRAME+&DS_SETFONT+&DS_SYSMODAL+&DS_MODALFRAME+&WS_POPUP+&WS_CAPTION+&DS_CENTER
    0                       ; style / extended style
 U$ 0 0 0 220 200           ; control-number, x, y, width, hight
    0                       ; no menu
    0                       ; class 0 > default
    "New Dialog" 0          ; title
    8 "Helv" 0              ; font

 DefaultEditedDialogBoxDataLenght: len]


;;
 Dialog proc for the result of edition. Clicking on a control select the dim record
 of the according Main list template part. Works only with controls that send
 some WM_COMMAND message > doesn't work on static controls. Another problem is that
 selection must not run at initialisation time > Nothing works at all until user didn't
 click on a Button. Exemple: if user first click on an Edit Control, nothing happends.
 see if we can do better later.
;;

[DialogEditorHandle: ?    EditedDialogHandle: ?    EditionInitFlag: ?]
[ArrowCursor: ?]

Proc EditedDialogBoxProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

  ; while opening and closing this dialog to show work progress to user, after
  ; some time, the menu seems destroyed (must be by Win -as bound to dialog-)
  ; > so, reinitialise. But then, the menu (visible) do not work any more
  ; in the editor. Saved data work fine....
    ...If D@Message = &WM_INITDIALOG
        move D$EditedDialogHandle D@Adressee
        call MakeControlIDList
        mov B$EditionInitFlag &TRUE

        call GetDialoBaseUnits

        If D$ActualMenutestID <> 0
            call 'User32.DestroyMenu' D$ActualMenutestID
            mov eax D$MenuListPtr | add eax 4
            call 'User32.LoadMenuIndirectA' D$eax
            mov D$ActualMenutestID eax
            call 'User32.SetMenu' D@Adressee eax
        End_If

  ;  ...Else_If D@Message = &WM_CLOSE
  ;      call 'User32.DestroyWindow' D@Adressee

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP


[Text12345: '1234567890', 0] [DialogUnitX: ?    DialogUnitY: ?]

UpdateControlDims:
    mov eax D$Control.rcNormalPosition.left, edx 0
    shl eax 2 | div D$BaseUnitX1
    On edx >= 5, inc eax
    mov edi Text12345 | call FromBinaryToDecimalAscii
    call 'USER32.SendMessageA' D$DialogControlsHandles+4, &WM_SETTEXT, 0, Text12345
    mov ecx D$DialogControlsHandles+4 | call WriteDimOnly

    mov eax D$Control.rcNormalPosition.Top, edx 0
    shl eax 3 | div D$BaseUnitY1
    On edx >= 5, inc eax
    mov edi Text12345 | call FromBinaryToDecimalAscii
    call 'USER32.SendMessageA' D$DialogControlsHandles+12+4, &WM_SETTEXT, 0, Text12345
    mov ecx D$DialogControlsHandles+12+4 | call WriteDimOnly

    mov eax D$Control.rcNormalPosition.Right, edx 0
    sub eax D$Control.rcNormalPosition.left
    shl eax 2 | div D$BaseUnitX1
    On edx >= 5, inc eax
    mov edi Text12345 | call FromBinaryToDecimalAscii
    call 'USER32.SendMessageA' D$DialogControlsHandles+24+4, &WM_SETTEXT, 0, Text12345
    mov ecx D$DialogControlsHandles+24+4 | call WriteDimOnly

    mov eax D$Control.rcNormalPosition.Bottom, edx 0
    sub eax D$Control.rcNormalPosition.Top
    shl eax 3 | div D$BaseUnitY1
    On edx >= 5, inc eax
    mov edi Text12345 | call FromBinaryToDecimalAscii
    call 'USER32.SendMessageA' D$DialogControlsHandles+36+4, &WM_SETTEXT, 0, Text12345
    mov ecx D$DialogControlsHandles+36+4 | call WriteDimOnly

    call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
ret


;;
  For the Dialog itself, only Sizing modifications are allowed. We only set the Hight
  and width.
;;

UpdateDialogDims:
    mov B$ModifiedControl &FALSE

    call 'USER32.GetClientRect' D$EditedDialogHandle, Control.rcNormalPosition.left

  ; Result of '.GetClientRect' >>> right > Weidth // Bottom > Hight:
    mov eax D$Control.rcNormalPosition.Right, edx 0
    shl eax 2 | div D$BaseUnitX1
    On edx >= 5, inc eax
    mov edi Text12345 | call FromBinaryToDecimalAscii
    call 'USER32.SendMessageA' D$DialogControlsHandles+24+4, &WM_SETTEXT, 0, Text12345
    mov ecx D$DialogControlsHandles+24+4 | call WriteDimOnly

    mov eax D$Control.rcNormalPosition.Bottom, edx 0
    shl eax 3 | div D$BaseUnitY1
    On edx >= 5, inc eax
    mov edi Text12345 | call FromBinaryToDecimalAscii
    call 'USER32.SendMessageA' D$DialogControlsHandles+36+4, &WM_SETTEXT, 0, Text12345
    mov ecx D$DialogControlsHandles+36+4 | call WriteDimOnly

    call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
ret


;;
  This is the trick for retrieving the Values needed for translating Screen Coordinates
  into DialogBoxes coordinates. It take account of the Font.
  
  For X Dim, the formula is:   shl eax 2 | div D$BaseUnitX1
  For Y Dim, the formula is:   shl eax 3 | div D$BaseUnitY1
;;

GetDialoBaseUnits:
    mov D$BaseUnitX1 4, D$BaseUnitY1 8, D$BaseUnitX2 0, D$BaseUnitY2, 0
    call 'User32.MapDialogRect' D$EditedDialogHandle BaseUnits
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

HookComments:
;;
  'InstallHook' is called from the Init of 'ReInitDialogEdition'. Its purpose is to
  install a Mouse Hook Procedure, 'MouseProc', that enable the Direct Mouse Edition
  of Dialog Controls Coordinates.
  
  The Coordinates of the target Cotrol are directely modified by 'MouseProc' and, for
  avoiding blinckering they are made effective only when user release the Button.
  
  Left Button is for Pos. Right Button is for Dim.
  
  When moving a Control, the Cursor is confined to the Dialog Client Rectangle.
  (not when re-sizing).
  
  As this would not mean a thing, if user left-Click on the Dialog (instead of a Control)
  Right-Click is silently subtituted, in that case.
  
  'KickDims' is run when the user releases the Mouse Button. It first select the proper
  ListBox Item for Dims, according with the target Control or with the Dialog. Then it
  runs 'SetDialogTools', that shows the Size and Pos Edition Controls in the Editor,
  and finaly calls either for 'UpdateControlDims' or for 'UpdateDialogDims'.
  
  When drawing a Control, it is replaced by a Static Control with SS_BLACKFRAME Style.
  This is for viewing, for example, the real sizes of Radio Buttons.
;;

[Control:
 Control.iLength: D$ len
 Control.flags: D$ 0
 Control.showCmd: D$ 0
 Control.ptMinPosition.x: D$ 0
 Control.ptMinPosition.y: D$ 0
 Control.ptMaxPosition.x: D$ 0
 Control.ptMaxPosition.y: D$ 0
 Control.rcNormalPosition.left: D$ 0
 Control.rcNormalPosition.top: D$ 0
 Control.rcNormalPosition.right: D$ 0
 Control.rcNormalPosition.bottom: D$ 0]

[oControl:
 oControl.iLength: D$ len
 oControl.flags: D$ 0
 oControl.showCmd: D$ 0
 oControl.ptMinPosition.x: D$ 0
 oControl.ptMinPosition.y: D$ 0
 oControl.ptMaxPosition.x: D$ 0
 oControl.ptMaxPosition.y: D$ 0
 oControl.rcNormalPosition.left: D$ 0
 oControl.rcNormalPosition.top: D$ 0
 oControl.rcNormalPosition.right: D$ 0
 oControl.rcNormalPosition.bottom: D$ 0]

[hHook: ?  HookedHandle: ?
 UserClickedOnControl: ?    UserRightClickedOnControl: ?
 FromPointX: ?    FromPointY: ? ? ?
 ClickFromPointX: ?    ClickFromPointY: ?
 ModifiedControl: ?]

[EditedDialogRectangle: ? ? ? ?]

; 'HookComments'.


Proc MouseProc:
    Arguments @nCode, @wParam, @lParam
;;
  Win Doc: 
  
  * If nCode is less than zero, the hook procedure must pass the message 
  to the CallNextHookEx function without further processing and should return the 
  value returned by CallNextHookEx. 
  
  * To enable the system to process the message, the return value must be zero. 
  To discard the message, the return value must be a nonzero value. 
  
  * If the 'CallNextHookEx' function succeeds, the return value is the value returned
  by the next hook procedure in the chain. The current hook procedure must also
  return this value.
  __________________
  
  In fact, under 98, if the MouseProc processes the Message, it *must* return a non
  zero value. Otherwise, the App hangs randomaly.
;;
    pushad

    ..If D@nCode > 07FFF_FFFF
        jmp L9>>

    ..Else_If D$EditedDialogHandle = 0
      ; All of this should be no use. Just added security...
L0:     mov al B$UserClickedOnControl | or al B$UserRightClickedOnControl
        If al <> &FALSE
            mov B$UserClickedOnControl &FALSE, B$UserRightClickedOnControl &FALSE
            call 'USER32.ClipCursor' &NULL
        End_If
        jmp L9>>

    ..Else
        mov al B$UserClickedOnControl | or al B$UserRightClickedOnControl
        .If al = &FALSE
            mov ebx D@lParam, eax D$ebx, ebx D$ebx+4
            mov D$FromPointX eax, D$FromPointY ebx
            mov D$ClickFromPointX eax, D$ClickFromPointY ebx
            call 'USER32.WindowFromPoint' eax, ebx | On eax = &FALSE, jmp L0<<
            If eax <> D$EditedDialogHandle
                call 'USER32.IsChild' D$EditedDialogHandle, eax | On eax = &FALSE, jmp L0<<
            End_If
        .End_If

    ..End_If
    _______________________________

    If D@wParam = &WM_LBUTTONDOWN
        call SearchForWhatControl

    Else_If D@wParam = &WM_RBUTTONDOWN
        call SearchForWhatControl

    End_If

    ...If D$HookedHandle <> 0
        ..If D@wParam = &WM_LBUTTONDOWN
            mov ebx D@lParam, eax D$ebx, ebx D$ebx+4
            mov D$FromPointX eax, D$FromPointY ebx
            mov D$ClickFromPointX eax, D$ClickFromPointY ebx

            mov eax D$EditedDialogHandle
            If D$HookedHandle = eax
                mov B$UserRightClickedOnControl &TRUE
            Else
                mov B$UserClickedOnControl &TRUE
            End_If

            call 'USER32.GetWindowPlacement' D$HookedHandle, Control

            call ClipCursorInDialog

            popad | mov eax &TRUE | ExitP

        ..Else_If D@wParam = &WM_RBUTTONDOWN
            mov ebx D@lParam, eax D$ebx, ebx D$ebx+4
            mov D$FromPointX eax, D$FromPointY ebx
            mov D$ClickFromPointX eax, D$ClickFromPointY ebx

            mov B$UserRightClickedOnControl &TRUE

            call 'USER32.GetWindowPlacement' D$HookedHandle, Control

            call ClipCursorInSelected

            popad | mov eax &TRUE | ExitP

        ..Else_If D@wParam = &WM_LBUTTONUP
            mov B$UserClickedOnControl &FALSE, B$UserRightClickedOnControl &FALSE
            call KickDims
            mov D$HookedHandle 0
            call 'USER32.ClipCursor' &NULL

            popad | mov eax &TRUE | ExitP

        ..Else_If D@wParam = &WM_RBUTTONUP
L1:         mov B$UserRightClickedOnControl &FALSE, B$UserClickedOnControl &FALSE
            call KickDims
            mov D$HookedHandle 0
            call 'USER32.ClipCursor' &NULL

            popad | mov eax &TRUE | ExitP

        ..Else_If D@wParam = &WM_MOUSEMOVE
            mov ebx D@lParam, eax D$ebx, ebx D$ebx+4
            mov D$FromPointX eax, D$FromPointY ebx

            .If B$UserClickedOnControl = &TRUE
                mov eax D$FromPointX | sub eax D$ClickFromPointX
                add D$Control.rcNormalPosition.left eax
                add D$Control.rcNormalPosition.right eax
                add D$ClickFromPointX eax

                mov ebx D$FromPointY | sub ebx D$ClickFromPointY
                add D$Control.rcNormalPosition.Top ebx
                add D$Control.rcNormalPosition.Bottom ebx
                add D$ClickFromPointY ebx

                call 'USER32.SetWindowPlacement' D$HookedHandle, Control
                mov B$ModifiedControl &TRUE

            .Else_If B$UserRightClickedOnControl = &TRUE
                mov eax D$FromPointX | sub eax D$ClickFromPointX
                add D$Control.rcNormalPosition.right eax
                add D$ClickFromPointX eax

                mov eax D$FromPointY | sub eax D$ClickFromPointY
                add D$Control.rcNormalPosition.Bottom eax
                add D$ClickFromPointY eax

                call 'USER32.SetWindowPlacement' D$HookedHandle, Control
                mov B$ModifiedControl &TRUE

            .End_If

            popad | mov eax &TRUE | ExitP

        ..End_If

    ...End_If

L9: popad
    call 'USER32.CallNextHookEx' D$hHook D@nCode D@wParam D@lParam
EndP


; User Left-Clicked on the Edited Dialog. The 'Control' Structure contains the
; 'HookedHandle' Window dimentions.

ClipCursorInDialog:
    call 'USER32.GetClientRect' D$EditedDialogHandle RECT
    call 'USER32.ClientToScreen' D$EditedDialogHandle RECTleft
    call 'USER32.ClientToScreen' D$EditedDialogHandle RECTright

    mov eax D$HookedHandle
    If eax = D$EditedDialogHandle
      ; Target = Dialog >>> Bottom-Right limits = Screen limits, (for resizing Dialog):
        call 'USER32.GetSystemMetrics' &SM_CXSCREEN | mov D$RECTright eax
        call 'USER32.GetSystemMetrics' &SM_CYSCREEN | mov D$RECTbottom eax

    Else
      ; Target = Control
      ; >>> Bottom-Right limits = Dialog limits
      ; >>> Top-Left limits = Dialog limits - (Mouse Pos - Control Top-Left)
        move D$PointX D$Control.rcNormalPosition.left
        move D$PointY D$Control.rcNormalPosition.top
        call 'USER32.ClientToScreen' D$EditedDialogHandle POINT
        mov eax D$FromPointX | sub eax D$PointX
        mov ebx D$FromPointY | sub ebx D$PointY
        add D$RECTleft eax | add D$RECTtop ebx

    End_If

    call 'USER32.ClipCursor' RECT
ret


[POINT: PointX: ? PointY: ?] [EditedDialogX: ?   EditedDialogY: ?]
[SlideBarX: ?    SlideBarY: ?]

ClipCursorInSelected:
    mov eax D$HookedHandle | On eax = D$EditedDialogHandle, jmp ClipCursorInDialog

  ; Dialog Dims:
    call 'USER32.GetClientRect' D$EditedDialogHandle RECT
    move D$EditedDialogX D$RECTleft, D$EditedDialogY D$RECTtop
    call 'USER32.ClientToScreen' D$EditedDialogHandle EditedDialogX

  ; Control Left-Top Dims:
    move D$RECTleft D$Control.rcNormalPosition.left
    move D$RECTtop D$Control.rcNormalPosition.top
    call 'USER32.ClientToScreen' D$EditedDialogHandle RECTleft
    call 'USER32.ClientToScreen' D$EditedDialogHandle RECTright

  ; Target = Control >>> Limit resizing to 25/25:
    move D$PointX D$Control.rcNormalPosition.right
    move D$PointY D$Control.rcNormalPosition.bottom
    call 'USER32.ClientToScreen' D$EditedDialogHandle POINT
;;
  For sizing, if the user Right-Clicks rigth upon the lower right corner, OK, but, if
  he Clicks, say, in the middle of the Control, we have to substract that 'Half-Size'
  of the control from the upper-left limit of the ClipCursor call, to let the modification
  go down to the minimum allowed size:
;;
    mov ebx D$EditedDialogX
    mov eax D$PointX | sub eax D$FromPointX
    sub eax D$MinimumX
    sub D$RECTleft eax ;| add D$RECTleft 25
  ; Don't let the Mouse go outside the Dialog, in cases of compensation.
    On D$RECTleft < ebx, mov D$RECTleft ebx

    mov ebx D$EditedDialogY
    mov eax D$PointY | sub eax D$FromPointY
    sub eax D$MinimumY
    sub D$RECTtop eax ;| add D$RECTtop 25
  ; Don't let the Mouse go outside the Dialog, in cases of compensation.
    On D$RECTtop < ebx, mov D$RECTtop ebx

    call 'USER32.ClipCursor' RECT
ret

____________________________________________________________________________________________

; 'HookComments'

Proc InstallHook:
    call 'KERNEL32.GetCurrentThreadId'
    call 'USER32.SetWindowsHookExA' &WH_MOUSE, MouseProc, &NULL, eax
    mov D$hHook eax
EndP


Proc UninstallHook:
    On D$hHook <> 0, call 'USER32.UnhookWindowsHookEx' D$hHook
    mov D$hHook 0
EndP


;;
  Force the New Dims and Pos (by Mouse action) to be displayed and updated (by calling
  either 'UpdateControlDims' or 'UpdateDialogDims':
;;

KickDims:
    mov eax D$HookedHandle

    .If eax <> D$EditedDialogHandle
        call 'USER32.GetDlgCtrlID' D$HookedHandle

        mov edi ControlsIDlist, ecx ControlsIDlistdWords
        repne scasd

L1:     If ecx > 0
            mov eax ControlsIDlistdWords
            sub eax ecx                        ; eax = ID list position (in ControlsIDlist)
            mov ecx eax | shl eax 3
            sub eax ecx                        ; what control dim (eax = eax + (ebx*7))
            push eax | dec eax
            call 'User32.SendMessageA' D$DialogListHandle &LB_SETTOPINDEX eax 0 ; Pos
            pop eax | inc eax
            call 'User32.SendMessageA' D$DialogListHandle &LB_SETCURSEL eax 0    ; select
            call SetDialogTools
            On B$ModifiedControl = &TRUE, call UpdateControlDims
        End_If

    .Else
        call 'User32.SendMessageA' D$DialogListHandle &LB_SETTOPINDEX 0 0
        call 'User32.SendMessageA' D$DialogListHandle &LB_SETCURSEL 1 0

        call SetDialogTools

        On B$ModifiedControl = &TRUE, call UpdateDialogDims
    .End_If
ret

____________________________________________________________________________________________

;;
  User has Clicked down on a Control in the Edited Dialog. We search in 
  'D$EditedDialogBoxData' for what Control.
  
  D$FromPointX, D$FromPointY hold the Mouse coordinates.
;;

[HookedID: ?
 HookedControlStyle: ?    HookedControlClass: ?][ClassTail: ? #10]
[HookedControlStylePtr: ?    HookedControlClassPtr: ?
 ClassNameInside: ?]

SearchForWhatControl:
    push D$FromPointX, D$FromPointY

        call 'USER32.GetWindowRect' D$EditedDialogHandle EditedDialogRectangle

        mov eax D$FromPointX
        cmp eax D$EditedDialogRectangle | jb L9>>
        cmp eax D$EditedDialogRectangle+8 | ja L9>>
        mov eax D$FromPointY
        cmp eax D$EditedDialogRectangle+4 | jb L9>>
        cmp eax D$EditedDialogRectangle+12 | ja L9>>

        mov eax D$EditedDialogRectangle | sub D$FromPointX eax
        mov eax D$EditedDialogRectangle+4 | sub D$FromPointY eax
        mov ebx D$EditedDialogRectangle+12 | sub ebx eax
        push ebx
        call 'USER32.GetClientRect' D$EditedDialogHandle EditedDialogRectangle
        pop ebx
        sub ebx D$EditedDialogRectangle+12 | sub D$FromPointY ebx


        mov D$BaseUnitX1 4, D$BaseUnitY1 8, D$BaseUnitX2 0, D$BaseUnitY2, 0     ; <<< the

        call 'User32.MapDialogRect' D$EditedDialogHandle BaseUnits               ; <<< trick

        mov eax D$FromPointX, edx 0 | shl eax 2 | div D$BaseUnitX1 | mov D$FromPointX eax
        mov eax D$FromPointY, edx 0 | shl eax 3 | div D$BaseUnitY1 | mov D$FromPointY eax

        mov D$HookedID 0, D$HookedHandle 0

        mov esi D$EditedDialogBoxData

        add esi 8  ; Style // Extended Style.

        mov eax 0 | lodsw | mov ecx eax | cmp ecx 0 | je L8>>   ; How many Controls
        add esi (4*2)                                           ; Dims
        While W$esi <> 0 | add esi 2 | End_While | add esi 2    ; Menu.
        While W$esi <> 0 | add esi 2 | End_While | add esi 2    ; Class.
        While W$esi <> 0 | add esi 2 | End_While | add esi 2    ; Title.
        While W$esi <> 0 | add esi 2 | End_While | add esi 2    ; Font.

        Align_on 4, esi

      ; Parse Controls (last good one = top one at that coordinate):

L0:     add esi 8  ; Style // Extended Style.

      ; Here are the searched Dims: X, Y, W, H (Words).
        mov ax W$esi   | cmp D$FromPointX eax | jb L2>>
        mov ax W$esi+2 | cmp D$FromPointY eax | jb L2>>
        mov ax W$esi+4 | add ax W$esi | cmp D$FromPointX eax | ja L2>
        mov ax W$esi+6 | add ax W$esi+2 | cmp D$FromPointY eax | ja L2>
            move W$HookedID W$esi+8

            mov eax esi | sub eax 8 | mov D$HookedControlStylePtr eax
            move D$HookedControlStyle D$eax

            add eax 18 | mov D$HookedControlClassPtr eax
            move D$HookedControlClass D$eax

            mov B$ClassNameInside &FALSE
            If W$eax <> 0FFFF
                push esi
                    mov esi eax, edi HookedControlClass
                    While W$esi <> 0
                        movsw
                    End_While
                    movsw
                pop esi
                mov B$ClassNameInside &TRUE
            End_If

            mov eax 0

L2:     call NextControl | dec ecx | jnz L0<<

        If D$HookedID <> 0
            push ebx | call GetSmallerReSize | pop ebx

            mov ebx D$HookedControlStylePtr
            mov D$ebx &BS_PUSHBUTTON__&BS_BITMAP__&BS_FLAT__&WS_CHILD__&WS_VISIBLE
            mov ebx D$HookedControlClassPtr, D$ebx 080_FFFF ; Button.
            On B$ClassNameInside = &TRUE, call AdjustTitle
            call ShowDialogResult
            call 'USER32.GetDlgItem' D$EditedDialogHandle, D$HookedID
            mov D$HookedHandle eax

        Else
L8:         move D$HookedHandle D$EditedDialogHandle
            mov D$MinimumX 200, D$MinimumY 50

        End_If

L9:     pop D$FromPointY, D$FromPointX
ret


[MinimumX: ?    MinimumY: ?]

GetSmallerReSize:
    mov D$MinimumX 10, D$MinimumY 10

    mov esi D$HookedControlStylePtr

    .If D$esi+18 = 0_81_FFFF  ; +18 >>> Class = 0FFFF 081 >>> Edit Control
        test D$esi &WS_VSCROLL | jz L1>
            add D$MinimumX 30
L1:     test D$esi &WS_HSCROLL | jz L2>
            add D$MinimumY 30
    .Else_If D$esi+18 = 0_83_FFFF  ; +18 >>> Class = 0FFFF 083 >>> ListBox
        add D$MinimumX 30 | add D$MinimumY 30
    .Else_If D$esi+18 = 0_85_FFFF  ; +18 >>> Class = 0FFFF 083 >>> ComboBox
        add D$MinimumX 30 | add D$MinimumY 30
    .End_If

L2: ret



; jump over Dims and search for end of Control Data. Pointer in esi:

NextControl:
  ; esi > Dims: X, Y, W, H (Words)
  ;             ID
  ;             0FFFF 0080 ou "msctls_progress32", 0
  ;             "Title", 0
  ;             0
    add esi 10

    If W$esi = 0FFFF
        add esi 4
    Else
        While W$esi <> 0 | add esi 2 | End_While | add esi 2
    End_If

    While W$esi <> 0 | add esi 2 | End_While | add esi 4

    Align_on 4, esi
ret


; If Class Name, recover the whole length with a simulated Title (the old part of the
; Classe Name, is simply made one sigle Title with the real Title, by inserting an 'X'
; instead of the zero Class string termination:

AdjustTitle:
    mov ebx D$HookedControlClassPtr
    While W$ebx <> 0 | add ebx 2 | End_While | mov B$ebx 'X'
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; This is for the edited dialog proc. Used to know what control user clicked on, and
; after, make the according "dim" controls appear in the editor:

[ControlsIDlist: ? #1000] [ControlsIDlistdWords 1000]

MakeControlIDList:
    mov edi ControlsIDlist, eax 0, ecx ControlsIDlistdWords | rep stosd ; clear ID table
    mov ebx ControlsIDlist
    mov edi D$EditedDialogBoxData
    mov edx 0, dx W$edi+8                       ; number of controls in edx
    On edx = 0, ret
    add edi 22
    mov ax 0, ecx 100 | repne scasw
    mov ecx 100 | repne scasw                   ; edi > end of dialog data
L0: test edi 00_11 | jz L1>
        add edi 2                               ; > start of Control data
L1: On edx = 0, jmp L9>
    add edi 16                                  ; > ID number
    move W$ebx W$edi | add ebx 4 | add edi 2
    If W$edi = 0FFFF                            ; type by number
        add edi 4
    Else
        mov ax 0, ecx 100 | repne scasw         ; type by name
    End_If
    mov ax 0, ecx 100 | repne scasw             ; control title
    add edi 2                                   ; > end of Control data
    dec edx | jmp L0<
L9: ret

_______________________________________________________________________________

; Menu for Dialog-Edition Dialog:

[DialogMenuHandle: ? DialogPopUpMenuTemplate: ? DialogPopUpMenuExit: ?]

[DETemplates: 'Templates', 0
    DEadd: 'Add Control' 0
    DEdel: 'Delete Control' 0

    DEdelMenu: 'Delete Menu', 0
    DEreplaceMenu: 'Replace Menu', 0

    DEreset: 'New Dialog' 0

 DEExit: 'Exit', 0
    DEsaveToResources: 'Save to Resources and Exit', 0
    DEsaveToClipBoard: 'Save to Clipboard and Exit', 0
    DEsaveToDisk: 'Save to Disk and Exit', 0

    DEabort: 'Abort', 0

 DEhelp: 'Help', 0]

[ID_DETemplates 500
    ID_DEadd 501
    ID_DEdel 502

    ID_DEdelMenu 503
    ID_DEreplaceMenu 504

    ID_DEreset 505

 ID_DEExit 510
    ID_DEsaveToResources 511
    ID_DEsaveToClipBoard 512
    ID_DEsaveToDisk 513

    ID_DEabort 514

 ID_DEhelp 520]

; Creates and Dispatch the menu for Dialog Edition:

CreateDialogMenu:
  ; Main Menu:
    call 'USER32.CreateMenu' | mov D$DialogMenuHandle eax

  ; Templates PopUp:
    call 'USER32.CreatePopupMenu' | mov D$DialogPopUpMenuTemplate eax

    call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, 0, ID_DEadd, DEadd
    call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, 0, ID_DEdel, DEdel
    call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, &MF_SEPARATOR, &NULL, &NUll
    call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, 0, ID_DEdelMenu, DEdelMenu
    call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, 0, ID_DEreplaceMenu, DEreplaceMenu
    call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, &MF_SEPARATOR, &NULL, &NUll
    call 'USER32.AppendMenuA' D$DialogPopUpMenuTemplate, 0, ID_DEreset, DEreset

    call 'USER32.InsertMenuA' D$DialogMenuHandle, 0,
                              &MF_BYCOMMAND__&MF_POPUP__&MF_STRING,
                              D$DialogPopUpMenuTemplate, DETemplates

  ; Exit PopUp:
    call 'USER32.CreatePopupMenu' | mov D$DialogPopUpMenuExit eax

    call 'USER32.AppendMenuA' D$DialogPopUpMenuExit, 0, ID_DEsaveToResources, DEsaveToResources
    call 'USER32.AppendMenuA' D$DialogPopUpMenuExit, 0, ID_DEsaveToClipBoard, DEsaveToClipBoard
    call 'USER32.AppendMenuA' D$DialogPopUpMenuExit, 0, ID_DEsaveToDisk, DEsaveToDisk
    call 'USER32.AppendMenuA' D$DialogPopUpMenuExit, &MF_SEPARATOR, &NULL, &NUll
    call 'USER32.AppendMenuA' D$DialogPopUpMenuExit, 0, ID_DEabort, DEabort

    call 'USER32.InsertMenuA' D$DialogMenuHandle, 1,
                              &MF_BYCOMMAND__&MF_POPUP__&MF_STRING,
                              D$DialogPopUpMenuExit, DEExit

  ; Menu Help:
    call 'USER32.AppendMenuA' D$DialogMenuHandle, 0, ID_DEhelp, DEhelp

    call 'USER32.SetMenu' D$DialogEditorHandle, D$DialogMenuHandle
ret

_______________________________________________________________________________
________________________________________________________________________________


FillDialogListBox:
    ; preserv Pos and Selection
    call 'User32.SendMessageA' D$DialogListHandle &LB_GETTOPINDEX D$DialogListIndex 0
    push eax

    call 'User32.SendMessageA' D$DialogListHandle &LB_GETCURSEL D$DialogListIndex 0
    push eax

    call 'User32.SendMessageA' D$DialogListHandle &LB_RESETCONTENT 0 0     ; makes list empty

    mov edi D$NewDialogTemplateText

L1: push edi
      call 'User32.SendMessageA' D$DialogListHandle &LB_ADDSTRING  0  edi   ; fill
    pop edi
    mov al 0, ecx 200 | repne scasb
    cmp B$edi 255 | jne L1<

    ; restore Selection and Pos:
    pop ebx, eax
    push ebx
    call 'User32.SendMessageA' D$DialogListHandle &LB_SETTOPINDEX eax 0
    pop eax
    call 'User32.SendMessageA' D$DialogListHandle &LB_SETCURSEL eax 0
L9: ret


; Restore end mark, in case of second run:

ResetDialogListBox:
    mov edi D$NewDialogTemplateText, ecx 7, al 0

L0: push ecx
        mov ecx 200 | repne scasb
    pop ecx
    loop L0<

    mov B$edi 255
ret

____________________________________________________________________________________
___________________________________________________________________________________

; Main routines for dialog edition.
_____________________________________________________________________________________
_____________________________________________________________________________________

ReleaseDialogMemories:
    VirtualFree D$NewDialogTemplateText, D$EditedDialogBoxData
ret


InitDialogMemory:
    VirtualFree D$NewDialogTemplateText
    VirtualAlloc NewDialogTemplateText 010000

    VirtualFree D$EditedDialogBoxData
    VirtualAlloc EditedDialogBoxData 010000
ret


; missing the &ICC_LINK_CLASS ?
InitDialogEdition:

    call 'ComCtl32.InitCommonControlsEx' CodeAddressFormClassName@Init_All_Common_Controls ; added by Guga

    If B$OnDialogEdition = &TRUE
        Beep | ret
    End_If
    call InitDialogMemory

    mov edi D$NewDialogTemplateText,
        esi DefaultDialogTemplateText,
        ecx D$DefaultDialogTemplateTextLen
    rep movsb
    mov D$edi 0FFFFFFFF                          ; End mark

    mov edi D$EditedDialogBoxData,
        esi DefaultEditedDialogBoxData,
        ecx D$DefaultEditedDialogBoxDataLenght
    rep movsb

    mov edi DialogList, eax 0, ecx 300
    repne scasd | sub edi 4
    mov D$DialogListPtr edi

    mov D$DialogMenutrueID 0, D$ActualMenutestID 0

ReInitDialogEdition:
    call InstallHook

    call FromTextToBinTemplate
;;
 Little difficulty: User can check either "POPUP" or "CHILD". Results visible dialog
 must remain "POPUP/VISIBLE" because created with "CreateDialogIndirectParamA"
 (either "CHILD" or not "VISIBLE" would make it unvisible for edition. So do we
 save true Dialog Style value and set the fitting one for edition:
;;
    mov eax D$EditedDialogBoxData
    push D$eax
        and D$eax 0FFF_FFFF | or D$eax 0_9000_0000

        call 'User32.CreateDialogIndirectParamA' D$hinstance, D$EditedDialogBoxData,
                                                 D$EditWindowHandle, EditedDialogBoxProc, 0
        mov D$EditedDialogHandle eax

        call 'User32.DialogBoxIndirectParamA' D$hinstance,      ; "create..." > modeless
                    DialogBoxData, 0, EditDialogBoxProc, 0      ; "Dialog..." > modal
      ; Editor Handle in 'DialogEditorHandle'.

        mov eax D$EditedDialogBoxData
    pop D$eax

    mov W$PreviousControlID 0FFFF

    call UninstallHook

    call SortDialogs
ret


[DoubleID: B$ ? #20]

SortDialogs:
  ; ID / Ptr / Size // ...
L0: mov esi DialogList, edi esi | add edi 12

    While D$edi <> 0
        mov eax D$esi
        If eax > D$edi
            Exchange D$esi D$edi
            Exchange D$esi+4 D$edi+4
            Exchange D$esi+8 D$edi+8 | jmp L0<
        End_If
        add esi 12 | add edi 12
    End_While
ret

; Verify that all Dialogs have unique IDs:

[SameIdAllowed: ?]

Proc CheckNotUsedId:
    Argument @ID, @Parent
    Uses esi

        On B$SameIdAllowed = &TRUE, ExitP

L0:     mov esi DialogList

        While D$esi <> 0
            mov eax D$esi
            If eax = D@ID
                call WriteDecimalID, eax, DoubleID
                call 'USER32.MessageBoxA' D@Parent, {'This Dialog ID already exist', 0},
                                          DoubleID, &MB_OK
                mov eax &IDCANCEL | ExitP
            Else
                add esi 12 | add edi 12
            End_If
        End_While

        mov eax &IDOK
EndP


Proc WriteDecimalID:
    Argument @Value, @Destination

    pushad
        mov eax D@Value, edi D@Destination, ecx 10

        mov D$edi ' ID ' | add edi 4

        push 0-1
L0:     mov edx 0 | div ecx | push edx | cmp eax 0 | ja L0<

L0:     pop eax | cmp eax 0-1 | je L9>
        add al '0' | stosb | jmp L0<

L9:     mov B$edi 0
    popad
EndP

____________________________________________________________________________________________



[DialogListHandle: ?    LastDialogListItem: ?]

ScrollDownToLastControl:
  ; Scroll full down to last new added control edition:
    call 'User32.SendMessageA' D$DialogListHandle &LB_GETCOUNT 0 0
    dec eax | mov D$LastDialogListItem eax
    push eax
        call 'User32.SendMessageA' D$DialogListHandle &LB_SETTOPINDEX eax 0
    pop eax
    sub eax 2
    call 'User32.SendMessageA' D$DialogListHandle &LB_SETCURSEL  eax 0
ret


ScrollToInsertedControl:
    call 'User32.SendMessageA' D$DialogListHandle &LB_GETCOUNT 0 0
    dec eax | mov D$LastDialogListItem eax
    mov eax D$DialogListIndex | add eax 5
    call 'User32.SendMessageA' D$DialogListHandle &LB_SETCURSEL  eax 0  ; select title
ret

[UpDownEndScroll 8]

[UserModifiedDim: ?] [OnDialogEdition: B$ ?  DialogLoadedFromResources: ?]

; D$ControlIndex values (set by "SetDialogTools"):
;   0 > Style   1 > Dim    2> ID    3 > Class    4 > Title    5 > Font
;   0_FFFF_FFFF if not yet or blank line.

[ProposedUpDowmChange: ?] ; The UDN_DELTAPOS WM_NOTIFY Message is sent before the
; Edit Control update. I use this Message to ease differenciating between all the
; Various Edit Controls. Immidiately after 'WriteDim' has used it, it reset it to
; zero. The Value is a signed dWord.

Proc EditDialogBoxProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    .If B$OnMenuEdition = &TRUE
        If D@Message = &WM_NOTIFY
            jmp L1>
        Else_If D@Message = &WM_VSCROLL
            jmp L1>
        Else_If D@Message = &WM_COMMAND
L1:         call 'User32.SendMessageA' D$MenuEditorHandle, &WM_COMMAND, &IDCANCEL, 0
        End_If
    .End_If

    If D$UserModifiedDim <> &FALSE
        mov ecx D$UserModifiedDim | call WriteDim
        mov D$UserModifiedDim &FALSE
    End_If

    ...If D@Message = &WM_NOTIFY
        mov ebx D@lParam, eax D$ebx+8     ; user click and hold on Updown in Dim edition
        If eax = &UDN_DELTAPOS
            mov eax D$ebx, edi DialogControlsHandles, ecx 12 | repne scasd
            sub edi 8 | mov ecx D$edi               ; each "dim": string / edit / UpDown
            move D$ProposedUpDowmChange D$ebx+16    ; This is the proposed change (signed dWord)
            call WriteDim
            call 'User32.SetForegroundWindow' D$DialogEditorHandle
            popad | mov eax &FALSE | jmp L9>>
        End_If

    ...Else_If D@Message = &WM_VSCROLL        ; user clicked and release Updown in Dim edition
        mov eax D@wParam | and eax UpDownEndScroll | jz C9>
          mov eax D@lParam, edi DialogControlsHandles, ecx 12 | repne scasd
          sub edi 8 | mov ecx D$edi           ; each "dim": string / edit / UpDown
          mov D$UserModifiedDim ecx
          call WriteDim
          call 'User32.SetForegroundWindow' D$DialogEditorHandle

; ID_DEadd 3  ID_DEdel 4  ID_DEreset 5  ID_DEexit 6  ID_DEhelp 7

; D$StyleHelpButtonsHandles > List of Styles Help
C9:
    ...Else_If D@Message = &WM_COMMAND
        .If D@wParam = ID_DEadd
            call AddOneControl
            call 'User32.SendMessageA' D$DialogListHandle, &LB_GETCURSEL, 0, 0
            sub eax 2
            call 'User32.SendMessageA' D$DialogListHandle, &LB_SETCURSEL, eax, 0
            call SetDialogTools
            call 'User32.SetForegroundWindow' D$DialogEditorHandle
            jmp L7>>

        .Else_If D@wParam = ID_DEdel
            call DelOneControl
            call 'User32.SetForegroundWindow' D$DialogEditorHandle
            jmp L7>>

        .Else_If D@wParam = ID_DEdel_Menu
            call SearchDialogLine
            If D$edi = 'FFFF'
                mov D$ActualMenutestID 0, D$DialogMenuTrueID 0
                push esi | ZCopy {"0 ;      no Menu", 0} | pop esi
                call FromTextToBinTemplate | call ShowDialogResult
                call FillDialogListBox
            Else
                call NoDialogMenu
            End_If
            jmp L7>>

        .Else_If D@wParam = ID_DEreplaceMenu
            call SearchDialogLine
            If D$edi = 'FFFF'
                call AddMenuToDialog
            Else
                call NoDialogMenu
            End_If
            jmp L7>>

        .Else_If D@wParam = ID_DEreset
            call ResetDialogListBox | call FillDialogListBox
            call 'User32.SetForegroundWindow' D$DialogEditorHandle
            mov W$PreviousControlID 0FFFF
            call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
            jmp L7>>

        .Else_If D@wParam = ID_DEhelp
L1:         call Help, B_U_AsmName, DialogHelp, ContextHlpMessage | jmp L7>>

        .Else_If D@wParam = ID_DEsaveToResources
            mov ebx 4 | call ExitDialog | jmp L7>>

        .Else_If D@wParam = ID_DEsaveToClipBoard
            mov ebx 0 | call ExitDialog | jmp L7>>

        .Else_If D@wParam = ID_DEsaveToDisk
            mov ebx 8 | call ExitDialog | jmp L7>>

        .Else_If D@wParam = ID_DEabort
            mov ebx 12 | call ExitDialog | jmp L7>>

        .Else_If D@wParam = &IDCANCEL
            call 'User32.EndDialog' D@Adressee 0
            call 'User32.DestroyWindow' D$EditedDialogHandle
            mov D$DialogEditorHandle 0, D$EditedDialogHandle 0
            mov B$OnDialogEdition &FALSE, B$DialogLoadedFromResources &FALSE | jmp L7>>
        .End_If

        mov eax D@wParam, ebx eax, ecx D@lParam
      ; buttons handles in ecx
        shr eax 16 | and ebx 0FFFF

        ..If ecx = D$DialogListHandle
            On eax = &LBN_SELCHANGE, call SetDialogTools

        ..Else
            .If eax = &BN_CLICKED
              ; Check button?
                On ebx = 1, jmp L7>>
              ; case of user hit [Return]
                mov esi DialogControlsHandles, ebx 0
L0:             lodsd
                If eax = ecx
                   call WriteStyle
                Else_If eax <> 0
                  ; stop on 0 (user click, but not on a 'moveable' control)
                    add ebx 4 | jmp L0<
                End_If

                On ecx = 0, jmp L2>
                    mov esi StyleHelpButtonsHandles, ebx 0
L0:                 lodsd

              ; Ready for Styles Help ('RunDialogHelp' / 'HelpDialogProc'):
                    If eax = ecx
                        call ShowStyleInfo
                    Else_If eax <> 0      ; stop on 0 (user click, but not on a 'moveable' control)
                        add ebx 4 | jmp L0<
                    End_If
                ;  call 'User32.SetForegroundWindow' D$DialogEditorHandle

            .Else_If eax = &EN_CHANGE           ; Edit Box?
                If D$ControlIndex = 4
                    call WriteTitle
                Else_If D$ControlIndex = 2
                    call WriteID
                Else_If D$ControlIndex = 3
                    call WriteTitle              ; reuse for Dialog Class
                End_If
L2:             call 'User32.SetForegroundWindow' D$DialogEditorHandle

            .Else_If eax = &LBN_SELCHANGE       ; List Box >>> font syze or type, or Class
                If D$DialogControlsHandles+4 = 0
                    call WriteClass
                Else_If ecx = D$DialogControlsHandles
                    call WriteFontType
                Else
                    call WriteFontSize
                End_If
                call 'User32.SetForegroundWindow' D$DialogEditorHandle

            .Else_If eax = &EN_UPDATE                  ; direct input in Dim edit control
                On D$ControlIndex = 1, call WriteDim
                call 'User32.SetForegroundWindow' D$DialogEditorHandle

            .End_If

        ..End_If

    ...Else_If D@Message = &WM_INITDIALOG
        move D$DialogEditorHandle D@Adressee

        call 'User32.GetDlgItem' D@Adressee ID_Ilist | mov D$DialogListHandle eax

        call CreateDialogMenu

        If B$OnClipDialog = &FALSE
            call ResetDialogListBox | call FillDialogListBox
            call ScrollDownToLastControl
        Else
            call FillDialogListBox | call ScrollDownToLastControl
            mov B$OnClipDialog &FALSE
        End_If
        mov B$OnDialogEdition &TRUE

        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon

    ...Else_If D@Message = &WM_CTLCOLORLISTBOX
        jmp L1>

    ...Else_If D@Message = &WM_CTLCOLOREDIT
L1:     call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>
    ...End_If

L7: popad | mov eax &TRUE

L9: EndP

_____________________________________________________________________________________
_____________________________________________________________________________________

; Routine to show particular controls on the editor dialog, depending on what main list
; line user click.
_____________________________________________________________________________________
_____________________________________________________________________________________

[DialogControlsHandles: ? #40] [StyleHelpButtonsHandles: ? #40]
[EditClass: 'EDIT', 0]

; these tables are used to set contents and pos of controls for style edition:

; Dialog window styles:

[DialogCheckingMask:
 0 0 0 0
 0 0
 0 0
 0 0 0 0
 0 0 0 0 0 0 0 0 0]

[DialogExcludeBitTable:
 0C0000000  0C0000000 0 0
 0 0
 0 0
 0 0 0 0
 0 0 0 0 0 0 0 0 0]

[DialogMustHaveBItTable:
 0 0 0 0
 0 0
 0 0
 0C00000 0C80000 0C80000 0C80000
 0 0 0 0 0 0 0 0 0]

[DialogTextTable: B$
 'WS_CHILD', 0     'WS_POPUP', 0        'WS_VISIBLE', 0       'WS_DISABLED', 0
 'WS_BORDER', 0    'WS_CAPTION', 0
 'WS_HSCROLL', 0  'WS_VSCROLL', 0
 'WS_SYSMENU', 0   'WS_MAXIMIZEBOX', 0  'WS_MINIMIZEBOX', 0   'DS_CONTEXTHELP', 0
 'DS_ABSALING', 0
 'DS_CENTER', 0
 'WS_THICKFRAME', 0
 'DS_CONTROL', 0
 'DS_MODALFRAME', 0
 'DS_NOFAILCREATE', 0
 'DS_NOIDLEMSG', 0
 'DS_SETFOREGROUND', 0
 'DS_SYSMODAL', 0 0]

[DialogBitTable:
 &WS_CHILD    &WS_POPUP        &WS_VISIBLE      &WS_DISABLED
 &WS_BORDER   &WS_CAPTION
 &WS_HSCROLL  &WS_VSCROLL
 &WS_SYSMENU  &WS_MAXIMIZEBOX  &WS_MINIMIZEBOX  &DS_CONTEXTHELP
 &DS_ABSALIGN
 &DS_CENTER
 &WS_THICKFRAME
 &DS_CONTROL
 &DS_MODALFRAME
 &DS_NOFAILCREATE
 &DS_NOIDLEMSG
 &DS_SETFOREGROUND
 &DS_SYSMODAL] ; &DS_CENTERMOUSE

[WS_CHILDhelp: "WS_CHILD:

> Child window.

Cannot be used with the WS_POPUP style.", 0
 WS_POPUPhelp: "WS_POPUP:

> Pop-up window.

Cannot be used with the WS_CHILD style.", 0
 WS_VISIBLEhelp: "WS_VISIBLE:

window is initially visible.", 0
 WS_DISABLEDhelp: "WS_DISABLED:

The window is initially disabled and can't receive input from the user.", 0
 WS_BORDERhelp: "WS_BORDER:

The window has a thin-line border.", 0
 WS_CAPTIONhelp: "WS_CAPTION:

The window has a title bar (includes WS_BORDER).", 0
 WS_HSCROLLhelp: "WS_HSCROLL:

The window has an horizontal scroll bar.", 0
 WS_VSCROLLhelp: "WS_VSCROLL:

The window has a vertical scroll bar.", 0
 WS_SYSMENUhelp: "WS_SYSMENU:

The window has a System-menu box in the title bar.

Must be WS_CAPTION too.", 0
 WS_MAXIMIZEBOXhelp: "WS_MAXIMIZEBOX:

Adds the Maximize button to the title bar.", 0
 WS_MINIMIZEBOXhelp: "WS_MINIMIZEBOX:

Adds the Minimize button to the title bar.", 0
 DS_CONTEXTHELPhelp: "DS_CONTEXTHELP:

Adds a question mark in the title bar", 0
 DS_ABSALINGhelp: "DS_ABSALIGN:

The coordinates of the dialog box will be screen coordinates instead of client area ones.", 0
 DS_CENTERhelp: "DS_CENTER:

Centers the dialog box in the working area.", 0
 WS_THICKFRAMEhelp: "WS_THICKFRAME:

The window has a sizing border.

Same as WS_SIZEBOX.", 0
 DS_CONTROLhelp: "DS_CONTROL:

The dialog will works as a child window of another dialog (example: A page in a Tabbed Dialog).", 0
 DS_MODALFRAMEhelp: "DS_MODALFRAME:

The dialog will have a modal dialog-box frame.", 0
 DS_NOFAILCREATEhelp: "DS_NOFAILCREATE:

Creates the dialog even if an error occur, for example, if a child window cannot be created.", 0
 DS_NOIDLEMSGhelp: "DS_NOIDLEMSG:

Blocks the WM_ENTERIDLE messages that Windows would otherwise send to the owner of the dialog box when the dialog box is displayed.", 0
 DS_SETFOREGROUNDhelp: "DS_SETFOREGROUND:

Brings the dialog box to the foreground, like it could be done with a call to SetForegroundWindow", 0
 DS_SYSMODALhelp: "DS_SYSMODAL:

> System-modal dialog box.

The dialog will have the WS_EX_TOPMOST style.", 0
 0]


[DialogStylesHelp: WS_CHILDhelp WS_POPUPhelp WS_VISIBLEhelp WS_DISABLEDhelp
 WS_BORDERhelp WS_CAPTIONhelp WS_HSCROLLhelp WS_VSCROLLhelp
 WS_SYSMENUhelp WS_MAXIMIZEBOXhelp WS_MINIMIZEBOXhelp DS_CONTEXTHELPhelp
 DS_ABSALINGhelp DS_CENTERhelp WS_THICKFRAMEhelp DS_CONTROLhelp DS_MODALFRAMEhelp
 DS_NOFAILCREATEhelp DS_NOIDLEMSGhelp DS_SETFOREGROUNDhelp DS_SYSMODALhelp 0]

___________________________________________________________________________________

ShowDialogStyleControl:
    ShowSetOfCheckBoxes DialogTextTable
ret

__________________________________________________________________________________

; very simplified version of TranslateHexa
; (esi >>> first text hexa number char after leading '0'):

TranslateDialogHexa:
    mov ebx 0
L0: lodsb | cmp al ' ' | je L9>
            cmp al ';' | je L9>
            cmp al CR | jbe L9>
      sub al '0' | On al > 9, sub al 7
      shl ebx 4 | or bl al | jmp L0<
L9: ret                                     ; >>> ebx = binary value

TranslateDialogText8:
    mov ecx 8
L0: mov eax ebx | and eax 0_F000_0000 | shr eax 28
    add al '0' | On al > '9', add al 7
    shl ebx 4
    stosb | loop L0<
ret

TranslateDialogText4:
    shl ebx 16
    mov ecx 4 | jmp L0<

TranslateDialogText2:
    shl ebx 24
    mov ecx 2 | jmp L0<

____________________________________________________________________________________

ShowDialogStyles:
    mov esi D$NewDialogTemplateText | add esi 3
    call TranslateDialogHexa | mov D$CheckActual ebx

    move D$CheckingMask DialogCheckingMask
    mov esi DialogBitTable

    push ebp
        call CheckControlStyles
    pop ebp
ret


[CheckBit: ?  CheckActual: ?  CheckExclude: ?  CheckMust: ?  CheckBitPtr: ?
 CheckResult: ?  CheckingMask: ?]

____________________________________________________________________________________


CheckControlStyles:
;;
 check / uncheck the controls:

 Set by caller (WriteStyle):

      D$CheckActual = Actual value for style (full value)
      D$CheckingMask = Bits table adress of checking masks (the main difficulty)

      esi = ptr to Style Bits table
;;
    mov edi DialogControlsHandles, ecx 0
    While D$edi > 0
       add edi 4 | inc ecx                ; number of check boxes at screen in ecx
    End_While
;;
 Very killing problem: This routine MUST be able to Check/UnCheck the edition CheckBoxes
 according with the value of "Style" (D$CheckActual). The fact is that we can have, for
 exemple, for buttons styles, values sets like:

 BS_3STATE 5         BS_AUTO3STATE 6     BS_AUTOCHECKBOX 3  BS_AUTORADIOBUTTON 9
 BS_CHECKBOX 2       BS_DEFPUSHBUTTON 1  BS_GROUPBOX 7      BS_PUSHBUTTON 0
 BS_RADIOBUTTON 4

 ... what makes it impossible to trust any bit value for checking. For exemple, if user
 click on "BS_GROUPBOX" (= 00_111), we must not check 00_001 (BS_DEFPUSHBUTTON), 00_010
 (BS_CHECKBOX), and so on... Sorry, next lines are very very difficult to understand. The
 only readable solution would be to write a no end cases selections routine for each
 control class, but i have choosen this shorter way. A second difficulty is that zero
 may be significant - and Check / UnCheck- (exemple: BS_PUSHBUTTON) and that we have to
 discriminate 00_10 (BS_CHECKBOX, for exemple) from 00_10... Killing:
;;
    mov edx D$CheckingMask, ebp 0              ; ebp = handles index for 'SendMessage'

L0: lodsd                                      ; loads one style value from Styles list
    pushad
      mov edx D$edx                            ; CheckingMask  !!!!!!!!!!!!!!!!!!!!!!!!
      ; eax Style bit value from list
        ; (Style and eax) <> eax >>> false?:
      mov ebx D$CheckActual | and ebx eax | cmp eax ebx | jne L6>
        ; (eax and CheckingMask) = 0  > next line
      mov ebx eax | and ebx edx | cmp ebx 0 | jne L4>
        ; check only if really 0 wanted:
        cmp eax 0 | jne L5>
          ; true zero?:
          mov eax D$CheckActual | and eax 00_111 | cmp eax 0 | je L5>
            jmp L6>
        ; last test for 'true', only if: bit value = (Bit value and CheckingMask):
L4:     mov eax D$CheckActual | and eax edx | cmp ebx eax | jne L6>

L5:   mov eax &TRUE | jmp L7>    ; check

L6:   mov eax &FALSE             ; UnCheck

L7:   call 'User32.SendMessageA' D$DialogControlsHandles+ebp &BM_SETCHECK eax 0
    popad | add ebp 4 | add edx 4 | loop L0<
ret


; Same as above, but for showing the checkboxes set at first time (user did'nt yet click
; at any check box, we just need actual style value and according checking mask table):

ShowControlStyles:
    call SearchDialogLine | mov esi edi | add esi 3
    call TranslateDialogHexa | mov D$CheckActual ebx

    add D$DialogListIndex 3
        call SearchWhatControlClass             ; ebx = indice of class (0 / 1 / 2 / 3...)
    sub D$DialogListIndex 3

    ..If edi = ControlClassByNumber             ; >>> class by Number
        .If ebx = 0
            move D$CheckingMask ButtonCheckingMask
            mov esi ButtonBitTable
        .Else_If ebx = 1
            move D$CheckingMask EditCheckingMask
            mov esi EditBitTable
        .Else_If ebx = 2
            move D$CheckingMask StaticCheckingMask
            mov esi StaticBitTable
        .Else_If ebx = 3
            move D$CheckingMask ListCheckingMask
            mov esi ListBitTable
        .Else_If ebx = 4
            move D$CheckingMask ScrollCheckingMask
            mov esi ScrollBitTable
        .Else_If ebx = 5
            move D$CheckingMask ComboCheckingMask
            mov esi ComboBitTable
        .End_If
    ..Else                                      ; >>> class by Name
        .If ebx = 0
            move D$CheckingMask UpDownCheckingMask
            mov esi UpDownBitTable
        .Else_If ebx = 1
            ret                                 ; msctls_progress32 (no controls)
        .Else_If ebx = 2
            move D$CheckingMask TrackCheckingMask
            mov esi TrackBitTable
        .Else_If ebx = 3
            move D$CheckingMask TreeCheckingMask
            mov esi TreeBitTable
        .Else_If ebx = 4
            move D$CheckingMask TabCheckingMask
            mov esi TabBitTable
        .Else_If ebx = 5
            move D$CheckingMask ListViewCheckingMask
            mov esi ListViewBitTable
        .Else_If ebx = 6
            move D$CheckingMask ToolBarCheckingMask
            mov esi ToolBarBitTable
        .Else_If ebx = 7
            move D$CheckingMask RichEdit20aCheckingMask
            mov esi RichEdit20aBitTable
        .Else_If ebx = 8
            move D$CheckingMask SysHeader32CheckingMask
            mov esi SysHeader32BitTable
        .Else_If ebx = 9
            move D$CheckingMask ReBarWindow32CheckingMask
            mov esi ReBarWindow32BitTable
        .Else_If ebx = 10
            move D$CheckingMask Tooltips_class32CheckingMask
            mov esi Tooltips_class32BitTable
        .Else_If ebx = 11
            move D$CheckingMask msctls_statusbar32CheckingMask
            mov esi msctls_statusbar32BitTable
        .Else_If ebx = 12
            move D$CheckingMask msctls_hotkey32CheckingMask
            mov esi msctls_hotkey32BitTable
        .Else_If ebx = 13
            move D$CheckingMask ComboBoxEx32CheckingMask
            mov esi ComboBoxEx32BitTable
        .Else_If ebx = 14
            move D$CheckingMask SysAnimate32CheckingMask
            mov esi SysAnimate32BitTable
        .Else_If ebx = 15
            move D$CheckingMask SysMonthCal32CheckingMask
            mov esi SysMonthCal32BitTable
        .Else_If ebx = 16
            move D$CheckingMask SysDateTimePick32CheckingMask
            mov esi SysDateTimePick32BitTable
        .Else_If ebx = 17
            move D$CheckingMask SysIPAddress32CheckingMask
            mov esi SysIPAddress32BitTable
        .Else_If ebx = 18
            move D$CheckingMask SysPagerCheckingMask
            mov esi SysPagerBitTable
        .Else_If ebx = 19
            move D$CheckingMask SysLinkCheckingMask
            mov esi SysLinkBitTable
        .End_If
    ..End_If

    call CheckControlStyles
ret

_______________________________________________________________________________________

[XdimText: 'X position:', 0  YdimText: 'Y position:', 0
 WdimText: 'Width:', 0       HdimText: 'Hight:', 0]

; This Table is an array of 2 UDACCEL structures. First dWord is the delay before next
; Array runing, dWord 2 is the displacement:
[UDACCEL: n1Sec: D$ 0    n1Inc: 1
          n2Sec:    2    n2Inc: 5]

[DialogDimTable: XdimText 200 0,  YdimText 240 0,  WdimText 280 0,  HdimText 320 0]
;;
 In "display edit box", ES_RIGHT (to align text number to the left, works only with
 ES_MULTILINE edit control style. (the box is de facto mono-line, of course). Without
 this, it sends a EN_CHANGE message at first display.
;;
ShowDimControls:
  ; First retrieve values from user text dim:
    call SearchDialogLine
    mov al ' ' | mov ecx 200 | repne scasb  ; space used as separator > count of data
    If D$DimIsForDialogWindow = &TRUE
        repne scasb                         ; jump over n (number of controls)
    End_If
    mov esi edi | inc esi
    call TranslateDialogHexa | mov D$DialogDimTable+ 8 ebx

    call TranslateDialogHexa | mov D$DialogDimTable+20 ebx

    call TranslateDialogHexa | mov D$DialogDimTable+32 ebx

    call TranslateDialogHexa | mov D$DialogDimTable+44 ebx

    mov ecx 4, esi DialogDimTable, ebx 0
L0: push ecx
      ; display text:
        push esi, ebx
            mov eax D$esi+4 | add eax 6
            call 'User32.CreateWindowExA'  0, StaticClassName, 0,
                                           &WS_CHILD+&WS_VISIBLE+&SS_SIMPLE, 2, eax,
                                           120 20, D$DialogEditorHandle 0 D$hInstance 0
        pop ebx, esi
        mov D$DialogControlsHandles+ebx eax
        push esi, ebx
            call 'User32.SendMessageA' eax &WM_SETFONT D$MyFontHandle &FALSE
            call 'User32.SetWindowTextA' D$DialogControlsHandles+ebx D$esi
        pop ebx esi

      ; display edit box:
        push esi, ebx
            call 'User32.CreateWindowExA'  0  EditClass  0,
                      &WS_CHILD+&WS_VISIBLE+&WS_BORDER+&ES_NUMBER+&ES_RIGHT+&ES_MULTILINE,
                      80 D$esi+4  45 20, D$DialogEditorHandle 0 D$hInstance 0
        pop ebx, esi
        mov D$DialogControlsHandles+ebx+4 eax

      ; display Up and down control:                     +&UDS_ARROWKEYS
        push esi, ebx
            call 'Comctl32.CreateUpDownControl',
              &WS_CHILD+&WS_BORDER+&WS_VISIBLE+&UDS_SETBUDDYINT+&UDS_NOTHOUSANDS+&UDS_HORZ,
                      130 D$esi+4 20 20, D$DialogEditorHandle, 102, D$Hinstance,
                      eax  2000 0  D$esi+8
        pop ebx, esi
        mov D$DialogControlsHandles+ebx+8 eax

      ; Set the speed (repeat speeds) of the UpDown Controls:
        push esi, eax, ebx
            call 'User32.SendMessageA' eax &UDM_SETACCEL 2 UDACCEL
        pop ebx, eax, esi

        push esi, ebx
            call 'User32.SendMessageA' eax &UDM_SETBUDDY D$DialogControlsHandles+ebx+4 0
        pop ebx, esi

        add ebx 12 | add esi 12
    pop ecx

    sub ecx 1 | jnz L0<<
ret

____________________________________________________________________________________

[ActualFontName: B$ ? #20] [ActualFontSize: ? ?]

; +ES_MULTILINE because it work better at message flow point of view.
; (used as mono-line, of course). Without this, it sends a EN_CHANGE message
; at first display.

ShowTitleControl:
    call 'User32.CreateWindowExA' 0  EditClass  0,
                     &WS_CHILD+&WS_VISIBLE+&WS_BORDER+&ES_AUTOHSCROLL+&ES_MULTILINE,
                                 2 200 145 20, D$DialogEditorHandle 0 D$hInstance 0
    mov D$DialogControlsHandles eax

  ; Copy data title (without quotes and comments) in TitleEditText:
    call SearchDialogLine | inc edi | mov esi edi
    mov al '"', ecx 200, ebx 200 | repne scasb                      ; search "Text lenght"
    sub ebx ecx | xchg ecx ebx | dec ecx
    mov edi ActualFontName | rep movsb | mov al 0 | stosb           ; copy + end mark

    call 'User32.GetDlgCtrlID' D$DialogControlsHandles
    call 'User32.SetDlgItemTextA' D$DialogEditorHandle eax ActualFontName  ; show edition text
    call 'User32.SetFocus' D$DialogControlsHandles
    call 'User32.SendMessageA' D$DialogControlsHandles  &EM_SETSEL  0  0-1
ret

[ComboClass: 'COMBOBOX', 0]  ; EditClass


; table of fonts names for dialog fonts:

[DialogFonts: B$ 'Arial', 0            'Arial Black', 0  'Comic Sans MS', 0
                 'Courier', 0          'Courier New', 0  'Fixedsys', 0
                 'Helv' 0
                 'Impact', 0           'Marlett', 0      'Modern', 0
                 'MS Sans Serif', 0    'MS Serif', 0     'Small Fonts', 0
                 'Symbol', 0           'System', 0       'Terminal', 0
                 'Times New Roman', 0  'Verdana', 0      'Webdings', 0
                 'Wingdings', 0 0

; Differents set of fonts sizes available for upper fonts list:

 T1F:  '08' 0  '09' 0  '0A' 0  '0B' 0  '0C' 0  '0E' 0  '10' 0  '12' 0
               '14' 0  '16' 0  '18' 0  '1A' 0  '1C' 0  '24' 0  '30' 0  '48' 0  0
 T2F:  '0A' 0  '0C' 0  '0F' 0 0
 T3F:  '09' 0  0
 T4F:  '08' 0  '0A' 0  '0C' 0  '0E' 0  '12' 0  '18' 0  0
 T5F:  '06' 0  '07' 0  '08' 0  '0A' 0  '0C' 0  '0E' 0  '12' 0  '18' 0  0
 T6F:  '02' 0  '03' 0  '04' 0  '05' 0  '06' 0  '07' 0  0
 T7F:  '0A' 0  0

; Table of pointers: font index of upper names >>> pointer to upper sizes table:

 FontSizesTable:
 D$ T1F T1F T1F T2F T1F T3F  T4F  T1F T1F T1F T4F T5F T6F T7F T3F T1F T1F T1F T1F]


; Search for the actual font in font name list to retrieve the index for sizes table:

SearchFontIndex:
    mov edi DialogFonts, edx 0-4

    While B$edi > 0
        mov esi ActualFontName | add edx 4
        push edi
            mov ecx 200, ebx 200, al 0 | repne scasb | sub ebx ecx | dec ebx
        pop edi
        If ebx = D$ComboFontNameLenght
            mov esi edi, ecx ebx | repe cmpsb | je L9>
                mov edi esi | add edi ebx | inc edi
        Else
            add edi ebx | inc edi
        End_If
    End_While
    mov eax 0 | ret

L9: mov eax edx | ret


[FontComboHandle: ?  FontComboID: ?  ComboFontNameLenght: ?]

ShowFontControls:
  ; Font Type edition combo box:
    call 'User32.CreateWindowExA'  0, ComboClass, 0,
&WS_CHILD+&WS_VISIBLE+&WS_BORDER+&CBS_HASSTRINGS+&CBS_AUTOHSCROLL+&CBS_DROPDOWNLIST+&WS_VSCROLL+&ES_AUTOVSCROLL,
                      2, 240, 145, 220, D$DialogEditorHandle, 0, D$hInstance, 0
    mov D$DialogControlsHandles eax

  ; Copy data font text (without quotes and comments) in TitleEditText:
    call SearchDialogLine
    mov esi edi, edi ActualFontSize
    while B$esi > ' '
        movsb
    End_While
    mov al 0 | stosb
    add esi 2 | mov edi esi
    mov al '"', ecx 200, ebx 200 | repne scasb                      ; search "Text lenght"
    sub ebx ecx | xchg ecx ebx | dec ecx
    mov D$ComboFontNameLenght ecx
    mov edi ActualFontName | rep movsb | mov al 0 | stosb           ; copy + end mark

    mov edi DialogFonts
    While B$edi > 0
        push edi
            call 'User32.SendMessageA' D$DialogControlsHandles &CB_ADDSTRING 0  edi
        pop edi
        mov al 0, ecx 200 | repne scasb
    End_While

    call 'User32.SendMessageA' D$DialogControlsHandles &CB_SELECTSTRING  0  ActualFontName

  ; Font size edition box:
    call 'User32.CreateWindowExA'  0, ComboClass  0,
    &WS_CHILD+&WS_VISIBLE+&WS_BORDER+&CBS_HASSTRINGS+&CBS_AUTOHSCROLL+&CBS_DROPDOWNLIST+&WS_VSCROLL+&ES_AUTOVSCROLL,
                                  100, 200, 47, 150, D$DialogEditorHandle, 0, D$hInstance, 0
    mov D$DialogControlsHandles+4 eax

    call SearchFontIndex

    If eax > 0
        mov edi D$FontSizesTable+eax
        While B$edi > 0
            push edi
                call 'User32.SendMessageA' D$DialogControlsHandles+4 &CB_ADDSTRING 0  edi
            pop edi
            mov al 0, ecx 200 | repne scasb
        End_While
    End_If

    call 'User32.SendMessageA' D$DialogControlsHandles+4  &CB_SELECTSTRING  0  ActualFontSize
ret

________________________________________________________________________________________
________________________________________________________________________________________
;;
 All the controls specificaly used for one record edition have these data tables
 associated with: (one for equates), one for texts proposed as different choices, one
 for the bit values of each possible choice, one for the bit values that can not be
 fitting with a choice and one for the bits that must be associated with one choice.

 Some win equates are not bit values but ordinals values (1, 2, 3, ..., 0100, 0200, 0300,...)
 in one same set of equates. This is to say that, having the binary value for some 'Style',
 it is impossible to find the signification by simply analysing each bit of 'Style' value.
 So must we have an additionnal set of mask to be able to Check / UnCheck the check
 boxes, either at first screen show or after user modifications, according with
 exclusions and 'must have' rules. These additionnal tables are named 'xxxxCheckingMask'.

 "xxxxExcludeBitTable" is used by 'WriteStyle' to compute the style value (only one value
 per operation)
 "xxxxCheckingMask" is used by 'CheckControlStyles' to set the check boxes (all the set
 per operation).
;;
________________________________________________________________________________________
________________________________________________________________________________________
; Button tables:


[ButtonCheckingMask:
 0F 0F
 0F 0F 0F 0F
 0F 0F
 0F
 0F0
 &BS_CENTER &BS_CENTER &BS_CENTER
 &BS_VCENTER &BS_VCENTER &BS_VCENTER
 0F 0F0 0F0
 &BS_MULTILINE
 &BS_NOTIFY
 &BS_PUSHLIKE
 &BS_FLAT
 010000
 020000
 08000000
 &WS_CHILD &WS_VISIBLE &WS_BORDER &WS_CLIPSIBLINGS]

[ButtonExcludeBitTable:
 0FFFF  0FFFF
 0FFFF 0FFFF 0FFFF 0FFFF
 0FFFF 0FFFF
 0FFFF
 0
 &BS_CENTER &BS_CENTER &BS_CENTER
 &BS_VCENTER &BS_VCENTER &BS_VCENTER
 0F   0F0  0F0
 0 0 0 0 0 0 0
 0 0 0
 0]

[ButtonTextTable: B$
 'BS_PUSHBUTTON' 0   'BS_DEFPUSHBUTTON' 0
 'BS_CHECKBOX' 0     'BS_3STATE' 0           'BS_AUTOCHECKBOX' 0    'BS_AUTO3STATE' 0
 'BS_RADIOBUTTON' 0  'BS_AUTORADIOBUTTON' 0
 'BS_GROUPBOX' 0
 'BS_LEFTTEXT' 0
 'BS_LEFT' 0         'BS_RIGHT' 0            'BS_CENTER' 0
 'BS_BOTTOM' 0       'BS_TOP' 0              'BS_VCENTER' 0
 'BS_OWNERDRAW' 0    'BS_BITMAP' 0           'BS_ICON' 0
 'BS_MULTILINE' 0
 'BS_NOTIFY' 0
 'BS_PUSHLIKE' 0
 'BS_FLAT' 0
 'WS_TABSTOP' 0
 'WS_GROUP' 0
 'WS_DISABLED' 0
 'WS_CHILD' 0
 'WS_VISIBLE' 0
 'WS_BORDER',0
 'WS_CLIPSIBLINGS', 0 0]

[ButtonBitTable:
 &BS_PUSHBUTTON      &BS_DEFPUSHBUTTON
 &BS_CHECKBOX        &BS_3STATE              &BS_AUTOCHECKBOX    &BS_AUTO3STATE
 &BS_RADIOBUTTON     &BS_AUTORADIOBUTTON
 &BS_GROUPBOX
 &BS_LEFTTEXT
 &BS_LEFT            &BS_RIGHT               &BS_CENTER
 &BS_BOTTOM          &BS_TOP                 &BS_VCENTER
 &BS_OWNERDRAW       &BS_BITMAP              &BS_ICON
 &BS_MULTILINE
 &BS_NOTIFY
 &BS_PUSHLIKE
 &BS_FLAT
 &WS_TABSTOP &WS_GROUP &WS_DISABLED
 &WS_CHILD &WS_VISIBLE &WS_BORDER
 &WS_CLIPSIBLINGS] ; &BS_RIGHTBUTTON &BS_TEXT

[ButtonMustHaveBitTable: 0 0 0 0   0 0 0 0   0 0 0 0   0 0 0 0   0 0 0 0   0 0 0 0  0 0     0 0 0   0]

[BS_PUSHBUTTONhelp: "BS_PUSHBUTTON:

The button posts a WM_COMMAND message to its parent when pushed.", 0
 BS_DEFPUSHBUTTONhelp: "BS_DEFPUSHBUTTON:

The button behaves like with BS_PUSHBUTTON, but has a enhanced border and reacts as default OK, when user hits Return.", 0
 BS_CHECKBOXhelp: "BS_CHECKBOX: 

Empty check box with text.

The default text Pos (at right) may be changed with BS_LEFTTEXT.", 0
 BS_3STATEhelp: "BS_3STATE:

Same as check box, but it can be grayed, checked or unchecked.", 0
 BS_AUTOCHECKBOXhelp: "BS_AUTOCHECKBOX:

Same as check box, but the state automatically toggles on user action.", 0
 BS_AUTO3STATEhelp: "BS_AUTO3STATE:

Same as Three-state check box, but the state automatically toggles on user action.", 0
 BS_RADIOBUTTONhelp: "BS_RADIOBUTTON:

Small circle with text. The default text Pos (at right) may be changed with BS_LEFTTEXT.", 0
 BS_AUTORADIOBUTTONhelp: "BS_AUTORADIOBUTTON:

Same as a radio button, but the state automatically toggles on user action.", 0
 BS_GROUPBOXhelp: "BS_GROUPBOX:

Not really a button. Creates a rectangle in which other controls can be grouped, with eventually a common title.

If you want, for example to have several sets of Auto-Radio-Buttons, you may also need the WS_GROUP style", 0
 BS_LEFTTEXThelp: "BS_LEFTTEXT:

Places text on the left side of the radio button or check box.", 0
 BS_LEFThelp: "BS_LEFT:

Left-justified the text in the button rectangle.

Note: If the button is a check box or radio button without BS_RIGHTBUTTON, the text is left justified on the right side of the control.", 0
 BS_RIGHThelp: "BS_RIGHT:

Right-justified text in the button rectangle.

Note: If the button is a check box or radio button without BS_RIGHTBUTTON, the text is right justified on the right side of the control.", 0
 BS_CENTERhelp: "BS_CENTER:

Centers the text horizontally in the button rectangle.", 0
 BS_BOTTOMhelp: "BS_BOTTOM:

Places the text at the bottom of the button rectangle.", 0
 BS_TOPhelp: "BS_TOP:

Places the text at the top of the button rectangle.", 0
 BS_VCENTERhelp: "BS_VCENTER:

Centers vertically the text on the button rectangle.", 0
 BS_OWNERDRAWhelp: "BS_OWNERDRAW:

The owner window will receives a WM_MEASUREITEM message at creation time and a WM_DRAWITEM message after the visual aspect change is done.

Can't be combined with any other button styles.", 0
 BS_BITMAPhelp: "BS_BITMAP:

The button will display a bitmap. You set it in your Proc.", 0
 BS_ICONhelp: "BS_ICON:

The button will display an Icon. You set it in your Proc.", 0
 BS_MULTILINEhelp: "BS_MULTILINE:

Allows multiple lines if the text string is too long to fit with the button width.", 0
 BS_NOTIFYhelp: "BS_NOTIFY:

The button will send BN_DBLCLK / BN_KILLFOCUS / BN_SETFOCUS notification messages to its parent. 

Note: BN_CLICKED is always send, even without this style. ", 0
 BS_PUSHLIKEhelp: "BS_PUSHLIKE:

Makes a check box or a radio button look like a button, with a state holding behaviour.", 0
 BS_FLAThelp: "BS_FLAT:

The button borders are visible only when activated", 0

WS_GROUPhelp: "WS_GROUP:

To be used with BS_GROUPBOX.

The next coming Controls, for example, a serie of Radio Buttons will behave as a group", 0]

[ButtonStylesHelp: BS_PUSHBUTTONhelp BS_DEFPUSHBUTTONhelp BS_CHECKBOXhelp
 BS_3STATEhelp BS_AUTOCHECKBOXhelp BS_AUTO3STATEhelp BS_RADIOBUTTONhelp
 BS_AUTORADIOBUTTONhelp BS_GROUPBOXhelp BS_LEFTTEXThelp BS_LEFThelp BS_RIGHThelp
 BS_CENTERhelp BS_BOTTOMhelp BS_TOPhelp BS_VCENTERhelp BS_OWNERDRAWhelp
 BS_BITMAPhelp BS_ICONhelp BS_MULTILINEhelp BS_NOTIFYhelp BS_PUSHLIKEhelp
 BS_FLAThelp WS_TABSTOPhelp WS_GROUPhelp WS_DISABLEDhelp WS_CHILDhelp WS_VISIBLEhelp WS_BORDERhelp]


____________________________________

; Edit control tables:



[EditCheckingMask: 03 03 03 0   0 0 0 0   0 0 0 0   0 0 0 0   0 0]

[EditTextTable: B$
 'ES_LEFT' 0         'ES_CENTER' 0        'ES_RIGHT' 0       'ES_MULTILINE' 0
 'ES_AUTOVSCROLL' 0  'ES_AUTOHSCROLL' 0   'ES_LOWERCASE' 0   'ES_UPPERCASE' 0
 'ES_PASSWORD' 0     'ES_OEMCONVERT' 0    'ES_NOHIDESEL' 0   'ES_READONLY' 0
 'ES_NUMBER' 0       'ES_WANTRETURN' 0    'WS_VSCROLL' 0     'WS_HSCROLL' 0
 'WS_TABSTOP' 0      'WS_BORDER' 0 0]

[EditBitTable:
 &ES_LEFT             &ES_CENTER            &ES_RIGHT           &ES_MULTILINE
 &ES_AUTOVSCROLL      &ES_AUTOHSCROLL       &ES_LOWERCASE       &ES_UPPERCASE
 &ES_PASSWORD         &ES_OEMCONVERT        &ES_NOHIDESEL       &ES_READONLY
 &ES_NUMBER           &ES_WANTRETURN        &WS_VSCROLL         &WS_HSCROLL
 &WS_TABSTOP          &WS_BORDER]

[EditExcludeBitTable:
 03  02   01   0
 0   0   08  010
 0   0   0   0
 0   0   0   0
 0   0]

[EditMustHaveBitTable:
 0 0 0 0
 &WS_VSCROLL &WS_HSCROLL 0 0
 0 0 0 0
 0 0 0 0
 0 0]

[ES_LEFThelp: "ES_LEFT:

Text will be Left-aligned.", 0
 ES_CENTERhelp: "ES_CENTER:

For multiline edit control:

Text will be centered", 0
 ES_RIGHThelp: "ES_RIGHT:

For multiline edit control:

Text wil be right-aligned.", 0
 ES_MULTILINEhelp: "ES_MULTILINE:

Multiline edit control. Default is single-line. Whith multi-lines, by default, when pressing ENTER, the default button is activated. To use the ENTER key as a real carriage return, add the ES_WANTRETURN style.

With the ES_AUTOHSCROLL style, the multiline edit control automatically scrolls horizontally when the caret reaches the right edge. To start a new line, the user must press the ENTER key. Without ES_AUTOHSCROLL, the control automatically wraps the words to the beginning of the next line when needed. A new line is also started if the user presses the ENTER key. The word wrap vary with the window size.

With multiline edit you can have scroll bars, and the edit control will process its own scroll bar messages.", 0
 ES_AUTOVSCROLLhelp: "ES_AUTOVSCROLL:

Automatically scrolls text up or down on user action.", 0
 ES_AUTOHSCROLLhelp: "ES_AUTOHSCROLL:

Automatically scrolls text to the right by 10 chars when needed (on user action).", 0
 ES_LOWERCASEhelp: "ES_LOWERCASE:

Converts all imputs to lowercase.", 0
 ES_UPPERCASEhelp: "ES_UPPERCASE:

Converts all Inputs to uppercase.", 0
 ES_PASSWORDhelp: "ES_PASSWORD:

Shows asterisks instead of imputed chars. You can change the (*)s to something else with the EM_SETPASSWORDCHAR message.", 0
 ES_OEMCONVERThelp: "ES_OEMCONVERT:

Converts text entered, from the Windows character set to the OEM character set and then back to the Windows set. This ensures proper character conversion when the application calls the CharToOem function to convert a string to OEM. Useful for retrieving filenames.", 0
 ES_NOHIDESELhelp: "ES_NOHIDESEL:

The selected text will remain selected, even if the control looses the focus. (as opposed to the default behaviour).", 0
 ES_READONLYhelp: "ES_READONLY:

User can't modify the actual text.", 0
 ES_NUMBERhelp: "ES_NUMBER:

Allows only decimal digits inputs.", 0
 ES_WANTRETURNhelp: "ES_WANTRETURN:

For multi-lines edit: The carriage return be inserted in response to ENTER.

Otherwise, ENTER would be considered as a default push button actions.", 0
; WS_VSCROLLhelp: '', 0
; WS_HSCROLLhelp: '', 0
 WS_TABSTOPhelp: "WS_TABSTOP:

Pressing the TAB key changes the keyboard focus to the next control having this style. 

The order of Controls is the one in the Dialog Data.", 0]

; WS_BORDERhelp: '', 0


[EditStylesHelp: ES_LEFThelp ES_CENTERhelp ES_RIGHThelp ES_MULTILINEhelp
  ES_AUTOVSCROLLhelp
 ES_AUTOHSCROLLhelp ES_LOWERCASEhelp ES_UPPERCASEhelp ES_PASSWORDhelp
 ES_OEMCONVERThelp ES_NOHIDESELhelp ES_READONLYhelp ES_NUMBERhelp ES_WANTRETURNhelp
 WS_VSCROLLhelp WS_HSCROLLhelp WS_TABSTOPhelp WS_BORDERhelp]
____________________________________


; Static Controls tables:

[StaticCheckingMask:
 0F 0FFF 0FFF  0FFF
 0FFF 0FFF 0FFF 0FFF
 0FFF 03 03 03
 0 0 0 0
 0 0]

[StaticTextTable: B$
 'SS_SIMPLE' 0        'SS_BITMAP' 0           'SS_ICON' 0        'SS_BLACKRECT' 0
 'SS_GRAYRECT' 0      'SS_WHITERECT' 0        'SS_BLACKFRAME' 0  'SS_GRAYFRAME' 0
 'SS_WHITEFRAME' 0    'SS_CENTER' 0           'SS_LEFT' 0        'SS_RIGHT' 0
 'SS_CENTERIMAGE' 0   'SS_LEFTNOWORDWRAP' 0   'SS_NOPREFIX' 0    'SS_NOTIFY' 0
 'WS_TABSTOP' 0       'WS_BORDER' 0 0]

[StaticBitTable:
 &SS_SIMPLE            &SS_BITMAP             &SS_ICON          &SS_BLACKRECT
 &SS_GRAYRECT          &SS_WHITERECT          &SS_BLACKFRAME    &SS_GRAYFRAME
 &SS_WHITEFRAME        &SS_CENTER             &SS_LEFT          &SS_RIGHT
 &SS_CENTERIMAGE       &SS_LEFTNOWORDWRAP     &SS_NOPREFIX      &SS_NOTIFY
 &WS_TABSTOP           &WS_BORDER] ; &SS_METAPICT &SS_RIGHTIMAGE

[StaticExcludeBitTable:
 0FFF  0FF  0FFF  0FF
 0FF   0FF  0FF   0FF
 0FF   03   03    03
 0      0   0     0
 0 0]

[StaticMustHaveBitTable:
 0  0  0  0
 0  0  0  0
 0  0  0  0
 0  0  0  0
 0  0]

[SS_SIMPLEhelp: "SS_SIMPLE:

A simple short line of left-aligned text in a rectangle.", 0
 SS_BITMAPhelp: "SS_BITMAP:

Room where to display a bitmap.

The Name (Title), when given is for targetting a Bitmap Resource save by Name. Actually RosAsm does not assume this way for saving Resources (only Resources by Number).

You have to defined your BitMap at Run Time from your CallBack Initialisation.

The width and Hight of the Control are dummy: The control automatically resizes to accommodate to the bitmap size.", 0
 SS_ICONhelp: "SS_ICON:

Room where to display an icon.

The Name (Title), when given is for targetting a Bitmap Resource save by Name. Actually RosAsm does not assume this way for saving Resources (only Resources by Number).

You have to defined your BitMap at Run Time from your CallBack Initialisation.

The width and Hight of the Control are dummy: The control automatically resizes to accommodate to the bitmap size", 0
 SS_BLACKRECThelp: "SS_BLACKRECT:

A rectangle filled with the current window frame color.

Default is black.", 0
 SS_GRAYRECThelp: "SS_GRAYRECT:

A rectangle filled with the current screen background color.

Default is gray.", 0
 SS_WHITERECThelp: "SS_WHITERECT:

A rectangle filled with the current window background color.

Defauilt is white.", 0
 SS_BLACKFRAMEhelp: "SS_BLACKFRAME:

A box with a frame drawn in the color of window frames.

Default is black.", 0
 SS_GRAYFRAMEhelp: "SS_GRAYFRAME:

A box with a frame drawn in the color of screen background.

Default is gray.", 0
 SS_WHITEFRAMEhelp: "SS_WHITEFRAME:

A box with a frame drawn with the color of window backgrounds.

Default is white.", 0
 SS_CENTERhelp: "SS_CENTER: 

A rectangle with centered text inside.

Includes wordwrap.", 0
 SS_LEFThelp: "SS_LEFT:

A rectangle with left-aligned text inside.

Includes wordwrap.", 0
 SS_RIGHThelp: "SS_RIGHT:

A rectangle with right-aligned text inside.

Includes wordwrap.", 0
 SS_CENTERIMAGEhelp: "SS_CENTERIMAGE:

With SS_BITMAP or SS_ICON, when resizing to accomodate the image size, the control pos will refer to its center instead of its upper rigth corner.", 0
 SS_LEFTNOWORDWRAPhelp: "SS_LEFTNOWORDWRAP:

Clips past extended text instead of wrapping when too long", 0
 SS_NOPREFIXhelp: "SS_NOPREFIX:

By default ampersand (&) indicates the next Char as a hot key (accelerator). This style negates this behaviour.

You can do the same by simply stating 2 ampersands (&&) instead.", 0
 SS_NOTIFYhelp: "SS_NOTIFY:

Sends STN_CLICKED and STN_DBLCLK notification messages to the parent when the user clicks or double clicks the control.", 0
 ;WS_BORDERhelp: '', 0
]
;
[StaticStylesHelp: SS_SIMPLEhelp SS_BITMAPhelp SS_ICONhelp SS_BLACKRECThelp
 SS_GRAYRECThelp SS_WHITERECThelp SS_BLACKFRAMEhelp SS_GRAYFRAMEhelp
 SS_WHITEFRAMEhelp SS_CENTERhelp SS_LEFThelp SS_RIGHThelp SS_CENTERIMAGEhelp
 SS_LEFTNOWORDWRAPhelp SS_NOPREFIXhelp SS_NOTIFYhelp WS_TABSTOPhelp WS_BORDERhelp]
____________________________________


; List box tables:

[ListCheckingMask:
 0 0 0
 0_FF_FFFF 0 0
 0 0 0
 0
 0 0 0
 0 030 030
 0 0 0 0]

[ListTextTable: B$
 'LBS_HASSTRINGS' 0         'LBS_NOTIFY' 0          'LBS_SORT' 0
 'LBS_STANDARD' 0           'LBS_USETABSTOPS' 0     'LBS_WANTKEYBOARDINPUT' 0
 'LBS_DISABLENOSCROLL' 0    'LBS_EXTENDEDSEL' 0     'LBS_MULTICOLUMN' 0
 'LBS_MULTIPLESEL' 0        'LBS_NODATA' 0          'LBS_NOINTEGRALHEIGHT' 0
 'LBS_NOSEL' 0
 'LBS_NOREDRAW' 0           'LBS_OWNERDRAWFIXED' 0  'LBS_OWNERDRAWVARIABLE' 0
 'WS_TABSTOP' 0             'WS_BORDER' 0           'WS_VSCROLL' 0
 'WS_HSCROLL' 0 0]

[ListBitTable:
 &LBS_HASSTRINGS             &LBS_NOTIFY             &LBS_SORT
 &LBS_STANDARD               &LBS_USETABSTOPS        &LBS_WANTKEYBOARDINPUT
 &LBS_DISABLENOSCROLL        &LBS_EXTENDEDSEL        &LBS_MULTICOLUMN
 &LBS_MULTIPLESEL            &LBS_NODATA             &LBS_NOINTEGRALHEIGHT
 &LBS_NOSEL
 &LBS_NOREDRAW               &LBS_OWNERDRAWFIXED     &LBS_OWNERDRAWVARIABLE
 &WS_TABSTOP                 &WS_BORDER              &WS_VSCROLL        &WS_HSCROLL]

[ListExcludeBitTable:
 02000      0    0
 0FF_FFFF 0    0
 0          0    0
 0          042  0
 0808
 0          030  030
 0            0  0   0]

[ListMustHaveBitTable:
 0  0  0
 0  0  0
 0  0  0
 0  0  0
 0
 0  0  0
 0  0  0 0]

[LBS_HASSTRINGShelp: "LBS_HASSTRINGS:

List of strings.", 0
 LBS_NOTIFYhelp: "LBS_NOTIFY:

Notifies the parent, when the user clicks or double-clicks on a listed item.", 0
 LBS_SORThelp: "LBS_SORT:

Auto-Sorts the strings in alphabetic order.", 0
 LBS_STANDARDhelp: "LBS_STANDARD:

Auto-Sorts the strings in alphabetic order.

Notify parent of user cicks and double-clicks.

Plus side borders", 0
 LBS_USETABSTOPShelp: "LBS_USETABSTOPS:

Tab are drawn with the string, if any.", 0
 LBS_WANTKEYBOARDINPUThelp: "LBS_WANTKEYBOARDINPUT:

Send the owner of the box a WM_VKEYTOITEM messages when user depresses a key.

Enables an application to control keyboard inputs.", 0
 LBS_DISABLENOSCROLLhelp: "LBS_DISABLENOSCROLL:

When the vertical scroll bar is not required for viewing all of the ListBox Items, this style negates the default behaviour, which is to *not* display the scroll bar.", 0
 LBS_EXTENDEDSELhelp: "LBS_EXTENDEDSEL:

Allows multiple items selections by use of the SHIFT key or of the mouse.", 0
 LBS_MULTICOLUMNhelp: "LBS_MULTICOLUMN:

Multicolumn list box, scrolled horizontally.

You set the columns width with LB_SETCOLUMNWIDTH message.", 0
 LBS_MULTIPLESELhelp: "LBS_MULTIPLESEL:

Turns string selection on or off at each clicks on a string. 

The user can select several strings.", 0
 LBS_NODATAhelp: "LBS_NODATA:

Does not work with LBS_SORT or LBS_HASSTRINGS style. A no-data list box is to be used when the number of items is over 1000. Must have the LBS_OWNERDRAWFIXED style. 

See Win Help for more information. You should not use this.", 0
 LBS_NOINTEGRALHEIGHThelp: "LBS_NOINTEGRALHEIGHT:

Block the adaption of the list box size on the Items length.", 0
 LBS_NOSELhelp: "LBS_NOSEL:
 
 The Items viewed in list box cannot be selected", 0
 LBS_NOREDRAWhelp: "LBS_NOREDRAW:

Prevents from updating when changes are made. May be changed with WM_SETREDRAW message.", 0
 LBS_OWNERDRAWFIXEDhelp: "LBS_OWNERDRAWFIXED:

The items are fixed height.

The owner of the list box redraws its contents when it receives the WM_MEASUREITEM (on creation) or WM_DRAWITEM (on change) messages.", 0
 LBS_OWNERDRAWVARIABLEhelp: "LBS_OWNERDRAWVARIABLE:

Items are variable heights.

The owner of the list box redraws its contents when it receives the WM_MEASUREITEM (on creation) or WM_DRAWITEM (on change) messages.", 0
; WS_BORDERhelp: ' ', 0
; WS_VSCROLLhelp: ' ', 0
; WS_HSCROLLhelp: ' ', 0
]

[ListBoxStyles: LBS_HASSTRINGShelp LBS_NOTIFYhelp LBS_SORThelp LBS_STANDARDhelp
 LBS_USETABSTOPShelp LBS_WANTKEYBOARDINPUThelp LBS_DISABLENOSCROLLhelp
 LBS_EXTENDEDSELhelp LBS_MULTICOLUMNhelp LBS_MULTIPLESELhelp LBS_NODATAhelp
 LBS_NOINTEGRALHEIGHThelp
 LBS_NOSELhelp
 LBS_NOREDRAWhelp LBS_OWNERDRAWFIXEDhelp LBS_OWNERDRAWVARIABLEhelp
 WS_TABSTOPhelp WS_BORDERhelp WS_VSCROLLhelp WS_HSCROLLhelp]

____________________________________


; Scroll Controls tables:

[ScrollCheckingMask:
 01 06 06
 01 06 06
 010 08 06 06
 0]

[ScrollTextTable: B$
 'SBS_HORZ' 0      'SBS_TOPALIGN' 0    'SBS_BOTTOMALIGN' 0
 'SBS_VERT' 0      'SBS_LEFTALIGN' 0   'SBS_RIGHTALIGN' 0
 'SBS_SIZEBOX' 0   'SBS_SIZEGRIP' 0    'SBS_SIZEBOXBOTTOMRIGHTALIGN' 0
 'SBS_SIZEBOXTOPLEFTALIGN' 0
 'WS_TABSTOP' 0 0]

[ScrollBitTable:
 &SBS_HORZ       &SBS_TOPALIGN     &SBS_BOTTOMALIGN
 &SBS_VERT       &SBS_LEFTALIGN    &SBS_RIGHTALIGN
 &SBS_SIZEBOX    &SBS_SIZEGRIP     &SBS_SIZEBOXBOTTOMRIGHTALIGN
 &SBS_SIZEBOXTOPLEFTALIGN
 &WS_TABSTOP]

[ScrollExcludeBitTable:
 019    019  019
 018    018  018
 010     08    0 0 0]

[ScrollMustHaveBitTable:
 0 0 0
 0 1 1
 0 0 8
 8 0]

[SBS_HORZhelp: "SBS_HORZ:

The scroll bar will be horizontal.", 0
 SBS_TOPALIGNhelp: "SBS_TOPALIGN:

To be used with SBS_HORZ, to align the scroll bar top edge with the bounding rectangle.", 0
 SBS_BOTTOMALIGNhelp: "SBS_BOTTOMALIGN:

To be used with SBS_HORZ, to align the scroll bar bottom edge with the bounding rectangle.", 0
 SBS_VERThelp: "SBS_VERT:

The scroll bar will be vertical.", 0
 SBS_LEFTALIGNhelp: "SBS_LEFTALIGN:

To be used with SBS_VERT, to align the scroll bar left edge with the bounding rectangle.", 0
 SBS_RIGHTALIGNhelp: "SBS_RIGHTALIGN:

To be used with SBS_VERT, to align the scroll bar right edge with the bounding rectangle.", 0
 SBS_SIZEBOXhelp: "SBS_SIZEBOX:

Features the scroll bar with a size box style.

Does not seem to work, at least under 95.

See SBS_SIZEGRIP.", 0
 SBS_SIZEGRIPhelp: "SBS_SIZEGRIP:

Adds a resize bitmap left bottom corner of the scroll bar.", 0
 SBS_SIZEBOXBOTTOMRIGHTALIGNhelp: "SBS_SIZEBOXBOTTOMRIGHTALIGN:

to be used with SBS_SIZEBOX.

Like SBS_SIZEBOX, does not seem to work.", 0
 SBS_SIZEBOXTOPLEFTALIGNhelp: "SBS_SIZEBOXBOTTOMRIGHTALIGN:

To be used with SBS_SIZEBOX.

Like SBS_SIZEBOX, does not seem to work.", 0
 ]

[ScrollStylesHelp: SBS_HORZhelp SBS_TOPALIGNhelp SBS_BOTTOMALIGNhelp SBS_VERThelp SBS_LEFTALIGNhelp
 SBS_RIGHTALIGNhelp SBS_SIZEBOXhelp SBS_SIZEGRIPhelp SBS_SIZEBOXBOTTOMRIGHTALIGNhelp
 SBS_SIZEBOXTOPLEFTALIGNhelp WS_TABSTOPhelp]
____________________________________


; Combo Box tables:

[ComboCheckingMask:
 &CBS_DROPDOWNLIST 0 0
 0 0 0F000
 0F000 &CBS_DROPDOWNLIST &CBS_DROPDOWNLIST
 0 0 0F0 0F0 0 0 0]

[ComboTextTable: B$
 'CBS_SIMPLE' 0            'CBS_HASSTRINGS' 0         'CBS_SORT' 0
 'CBS_AUTOHSCROLL' 0       'CBS_DISABLENOSCROLL' 0    'CBS_LOWERCASE' 0
 'CBS_UPPERCASE' 0         'CBS_DROPDOWN' 0           'CBS_DROPDOWNLIST' 0
 'CBS_NOINTEGRALHEIGHT' 0  'CBS_OEMCONVERT' 0         'CBS_OWNERDRAWFIXED' 0
 'CBS_OWNERDRAWVARIABLE' 0 'WS_VSCROLL' 0             'WS_HSCROLL' 0
 'WS_TABSTOP' 0 0]

[ComboBitTable:
 &CBS_SIMPLE                 &CBS_HASSTRINGS            &CBS_SORT
 &CBS_AUTOHSCROLL            &CBS_DISABLENOSCROLL       &CBS_LOWERCASE
 &CBS_UPPERCASE              &CBS_DROPDOWN              &CBS_DROPDOWNLIST
 &CBS_NOINTEGRALHEIGHT       &CBS_OEMCONVERT            &CBS_OWNERDRAWFIXED
 &CBS_OWNERDRAWVARIABLE      &WS_VSCROLL                &WS_HSCROLL
 &WS_TABSTOP]

[ComboExcludeBitTable:
 0FF     0   0
 0       0   &CBS_UPPERCASE
 &CBS_LOWERCASE  &CBS_DROPDOWNLIST   0
 0       0   &CBS_OWNERDRAWVARIABLE
 &CBS_OWNERDRAWFIXED     0   0
 0]

[ComboMustHaveBitTable:
 0     0     0
 0     &CBS_AUTOHSCROLL  &CBS_HASSTRINGS
 &CBS_HASSTRINGS  0     0
 0     0     0
 0     0     0
 0]

[CBS_SIMPLEhelp: "CBS_SIMPLE:

The list box is always displayed.

The current selection is displayed in the edit control.", 0
 CBS_HASSTRINGShelp: "CBS_HASSTRINGS:

The combo box items are strings.

The application makes use of CB_GETLBTEXT for retrieving one text item.", 0
 CBS_SORThelp: "CBS_SORT:

When you will fill the list box, the items will be Automatically sorted.", 0
 CBS_AUTOHSCROLLhelp: "CBS_AUTOHSCROLL:

In the edit control, the text will scroll Automatically when needed.", 0
 CBS_DISABLENOSCROLLhelp: "CBS_DISABLENOSCROLL:

Does not hide the scroll bar when it is useless.", 0
 CBS_LOWERCASEhelp: "CBS_LOWERCASE:

All Chars entered in the edit control will be turned lower case.", 0
 CBS_UPPERCASEhelp: "CBS_UPPERCASE:

All Chars entered in the edit control will be turned upper case.", 0
 CBS_DROPDOWNhelp: "CBS_DROPDOWN:

Same as CBS_SIMPLE, but the list box will only be displayed after the user selects the down arrow of the edit control.", 0
 CBS_DROPDOWNLISThelp: "CBS_DROPDOWNLIST:

Same as CBS_SIMPLE, but the list box will only be displayed after the user selects the down arrow of the edit control, just like with CBS_DROPDOWN, but the Edit Control is replaced by a static control.", 0
 CBS_NOINTEGRALHEIGHThelp: "CBS_NOINTEGRALHEIGHT:

Blocks automatic resizing depending on the size of items.", 0
 CBS_OEMCONVERThelp: "CBS_OEMCONVERT:

Converts text entered, from the Windows character set to the OEM character set and then back to the Windows set. This ensures proper character conversion when the application calls the CharToOem function to convert a string to OEM.

Useful for retrieving filenames.", 0
 CBS_OWNERDRAWFIXEDhelp: "CBS_OWNERDRAWFIXED:

All items are same hight.

The owner of the list box redraws its contents when it receives the WM_MEASUREITEM (on creation) or WM_DRAWITEM (on change) messages.", 0
 CBS_OWNERDRAWVARIABLEhelp: "CBS_OWNERDRAWVARIABLE:

The items are variable hights.

The owner of the list box redraws its contents when it receives the WM_MEASUREITEM (on creation) or WM_DRAWITEM (on change) messages.", 0
; WS_VSCROLLhelp:
; WS_HSCROLLhelp:
 ]

[ComboStylesHelp: CBS_SIMPLEhelp CBS_HASSTRINGShelp CBS_SORThelp CBS_AUTOHSCROLLhelp
 CBS_DISABLENOSCROLLhelp CBS_LOWERCASEhelp CBS_UPPERCASEhelp CBS_DROPDOWNhelp
 CBS_DROPDOWNLISThelp CBS_NOINTEGRALHEIGHThelp CBS_OEMCONVERThelp CBS_OWNERDRAWFIXEDhelp
 CBS_OWNERDRAWVARIABLEhelp WS_VSCROLLhelp WS_HSCROLLhelp WS_TABSTOPhelp]

____________________________________


; UpDown controls tables:

[UpDownCheckingMask:
 0 0 0 0   0 0 0 0  0]

[UpDownTextTable: B$
 'UDS_ALIGNLEFT' 0  'UDS_ALIGNRIGHT' 0  'UDS_SETBUDDYINT' 0  'UDS_NOTHOUSANDS' 0
 'UDS_ARROWKEYS' 0  'UDS_HORZ' 0        'UDS_WRAP' 0         'UDS_AUTOBUDDY', 0
 'WS_TABSTOP' 0 0]

[UpDownBitTable:
 &UDS_ALIGNLEFT      &UDS_ALIGNRIGHT   &UDS_SETBUDDYINT   &UDS_NOTHOUSANDS
 &UDS_ARROWKEYS      &UDS_HORZ         &UDS_WRAP          &UDS_AUTOBUDDY
 &WS_TABSTOP]

[UpDownExcludeBitTable:
 4  8  0  0
 0  0  0  0
 0]

[UpDownMustHaveBitTable:
 0  0  0  0
 0  0  0  0
 0]

[UDS_ALIGNLEFThelp: "UDS_ALIGNLEFT:

The up-down control will be at the left edge of the buddy window.", 0
 UDS_ALIGNRIGHThelp: "UDS_ALIGNRIGHT:

The up-down control will be at the right edge of the buddy window.", 0
 UDS_SETBUDDYINThelp: "UDS_SETBUDDYINT:

The up-down control will set the text of the buddy window when needed (numbers only).

The buddy window may be set by UDS_AUTOBUDDY.", 0
 UDS_NOTHOUSANDShelp: "UDS_NOTHOUSANDS:

Reverses default, which is to insert a thousands'separator between each three digits.", 0
 UDS_ARROWKEYShelp: "UDS_ARROWKEYS:

Allows keyboard UP ARROW and DOWN ARROW keys alternate inputs.", 0
 UDS_HORZhelp: "UDS_HORZ:

Default is vertical...", 0
 UDS_WRAPhelp: "UDS_WRAP:

Restarts at other end, when moving out of range.", 0
 UDS_AUTOBUDDYhelp: "UDS_AUTOBUDDY:
 
Automatically selcts the previous Z order window as the associated buddy window.
The 'previous Z order Window' is the previous one in the Template.", 0]

[UpDownStylesHelp: UDS_ALIGNLEFThelp UDS_ALIGNRIGHThelp UDS_SETBUDDYINThelp
 UDS_NOTHOUSANDShelp UDS_ARROWKEYShelp UDS_HORZhelp UDS_WRAPhelp UDS_AUTOBUDDYhelp
 WS_TABSTOPhelp]
____________________________________


; Progress bar have nothing to edit:

[ProgressTextTable: 0 0]
____________________________________

; Track Bars controls tables:

[TrackCheckingMask:
 0 0 0   0 0 0  0 0 0  0 0 0
 0]

[TrackTextTable: B$
 'TBS_HORZ' 0            'TBS_BOTTOM' 0        'TBS_TOP' 0
 'TBS_VERT' 0            'TBS_RIGHT' 0         'TBS_LEFT' 0
 'TBS_AUTOTICKS' 0       'TBS_NOTICKS' 0       'TBS_BOTH' 0
 'TBS_ENABLESELRANGE' 0  'TBS_FIXEDLENGTH' 0   'TBS_NOTHUMB' 0
 'WS_TABSTOP' 0 0]

[TrackBitTable:
 &TBS_HORZ                 &TBS_BOTTOM            &TBS_TOP
 &TBS_VERT                 &TBS_RIGHT             &TBS_LEFT
 &TBS_AUTOTICKS            &TBS_NOTICKS           &TBS_BOTH
 &TBS_ENABLESELRANGE       &TBS_FIXEDLENGTH       &TBS_NOTHUMB
 &WS_TABSTOP]

[TrackExcludeBitTable:
 2  2  2
 0  0  0
 0  0  0
 0  0  0
 0]

[TrackMustHaveBitTable:
 0  0  0
 0  2  2
 0  0  0
 0  0  0
 0]

[TBS_HORZhelp: "TBS_HORZ:

The trackbar will be horizontal.", 0
 TBS_BOTTOMhelp: "TBS_BOTTOM:

Position of the tick marks in an horizontal trackbar.", 0
 TBS_TOPhelp: "TBS_TOP:

Position of the tick marks in an horizontal trackbar.", 0
 TBS_VERThelp: "TBS_VERT:

The trackbar will be vertical.", 0
 TBS_RIGHThelp: "TBS_RIGHT:

Position of the tick marks in a vertical trackbar.", 0
 TBS_LEFThelp: "TBS_LEFT:

Position of the tick marks in a vertical trackbar.", 0
 TBS_AUTOTICKShelp: "TBS_AUTOTICKS:

The tick mark will be added automatically when your application will send the TBM_SETRANGE message.

Otherwise, you can send the TBM_SETTIC and TBM_SETTICFREQ, to specify these positions.", 0
 TBS_NOTICKShelp: "TBS_NOTICKS:

Does not display the tick marks.", 0
 TBS_BOTHhelp: "TBS_BOTH:

Displays tick marks on both side of the track bar (left/right with TBS_VERT.Down top with TBS_HORZ).", 0
 TBS_ENABLESELRANGEhelp: "TBS_ENABLESELRANGE:

Displays edge ticks as triangles and the selection range is highlighted.", 0
 TBS_FIXEDLENGTHhelp: "TBS_FIXEDLENGTH:

The slider size will not vary with the size of range, as it does by default.", 0
 TBS_NOTHUMBhelp: "TBS_NOTHUMB:

Disables the slider.", 0]

[TrackStylesHelp: TBS_HORZhelp TBS_BOTTOMhelp TBS_TOPhelp TBS_VERThelp TBS_RIGHThelp
 TBS_LEFThelp TBS_AUTOTICKShelp TBS_NOTICKShelp TBS_BOTHhelp TBS_ENABLESELRANGEhelp
 TBS_FIXEDLENGTHhelp TBS_NOTHUMBhelp WS_TABSTOPhelp]
____________________________________

; TreeView Controls tables:

[TreeCheckingMask:
 0 0 0 0
 0 0 0 0
 0 0 0 0
 0 0 0 0
 0]

[TreeTextTable: B$
 'TVS_HASLINES' 0  'TVS_LINESATROOT' 0  'TVS_HASBUTTONS' 0  'TVS_EDITLABELS' 0
 'TVS_SHOWSELALWAYS' 0 'TVS_DISABLEDRAGDROP ', 0 'TVS_RTLREADING ', 0 'TVS_NOTOOLTIPS ', 0
 'TVS_CHECKBOXES ', 0 'TVS_TRACKSELECT ', 0 'TVS_SINGLEEXPAND ', 0 'TVS_INFOTIP ', 0
 'TVS_FULLROWSELECT ', 0 'TVS_NOSCROLL ', 0 'TVS_NONEVENHEIGHT ', 0 'TVS_NOHSCROLL ', 0
 'WS_TABSTOP' 0, 0]

[TreeBitTable: &TVS_HASLINES  &TVS_LINESATROOT  &TVS_HASBUTTONS  &TVS_EDITLABELS
 &TVS_SHOWSELALWAYS &TVS_DISABLEDRAGDROP &TVS_RTLREADING &TVS_NOTOOLTIPS
 &TVS_CHECKBOXES &TVS_TRACKSELECT &TVS_SINGLEEXPAND &TVS_INFOTIP
 &TVS_FULLROWSELECT &TVS_NOSCROLL &TVS_NONEVENHEIGHT &TVS_NOHSCROLL
 &WS_TABSTOP]

 [TreeExcludeBitTable: &TVS_FULLROWSELECT 0 0 0
 0 0 0 &TVS_INFOTIP
 0 0 0 &TVS_NOTOOLTIPS
 &TVS_HASLINES 0 0 0
 0]

[TreeMustHaveBitTable: 0 0 0 0
 0 0 0 0
 0 0 0 0
 0 0 0 0
 0]

[TVS_HASLINEShelp: "TVS_HASLINES:

Draws lines showing the items hierarchy.", 0
 TVS_LINESATROOThelp: "TVS_LINESATROOT:

Draws lines between root and items.

Does not work with TVS_HASLINES.", 0
 TVS_HASBUTTONShelp: "TVS_HASBUTTONS:

Displays plus and minus buttons aside the parent items.

They are used to open / close the lists of  child items.", 0
 TVS_EDITLABELShelp: "TVS_EDITLABELS:

Allows edition of the items by user.", 0
 TVS_SHOWSELALWAYShelp: "TVS_SHOWSELALWAYS:

When lossing the focus, the tree-view will maintain the actual selection.", 0

TVS_DISABLEDRAGDROPhelp: "TVS_DISABLEDRAGDROP:

Prevents the tree-view control from sending TVN_BEGINDRAG notification messages. ", 0

TVS_RTLREADINGhelp: "TVS_RTLREADING:

Version 4.70. Causes text to be displayed from right-to-left (RTL).
Usually, windows display text left-to-right (LTR). Windows can be mirrored to display languages such
as Hebrew or Arabic that read RTL. Typically, tree-view text is displayed in the same direction as the text
in its parent window. If TVS_RTLREADING is set, tree-view text reads in the opposite direction from the text in
the parent window.", 0

TVS_NOTOOLTIPShelp: "TVS_NOTOOLTIPS:

Version 4.70. Disables ToolTips.", 0

TVS_CHECKBOXEShelp: "TVS_CHECKBOXES:

Version 4.70. Enables check boxes for items in a tree-view control. A check box is displayed only if an image is
associated with the item. When set to this style, the control effectively uses DrawFrameControl to create and set
a state image list containing two images. State image 1 is the unchecked box and state image 2 is the checked box.
Setting the state image to zero removes the check box altogether.

Version 5.80. Displays a check box even if no image is associated with the item. Once a tree-view control is created
with this style, the style cannot be removed. Instead, you must destroy the control and create a new one in its place.
Destroying the tree-view control does not destroy the check box state image list. You must destroy it explicitly.
Get the handle to the state image list by sending the tree-view control a TVM_GETIMAGELIST message.
Then destroy the image list with ImageList_Destroy.
     
If you want to use this style, you must set the TVS_CHECKBOXES style with SetWindowLong after you create the
treeview control, and before you populate the tree. Otherwise, the checkboxes might appear unchecked, depending
on timing issues.", 0

TVS_TRACKSELECThelp: "TVS_TRACKSELECT:

Version 4.70. Enables hot tracking in a tree-view control.", 0

TVS_SINGLEEXPANDhelp: "TVS_SINGLEEXPAND:

Version 4.71. Causes the item being selected to expand and the item being unselected to collapse upon selection
in the tree view. If the mouse is used to single-click the selected item and that item is closed, it will be expanded.
If the user holds down the CTRL key while selecting an item, the item being unselected will not be collapsed.

Version 5.80. Causes the item being selected to expand and the item being unselected to collapse upon selection in
the tree view. If the user holds down the CTRL key while selecting an item, the item being unselected will not be
collapsed.", 0

TVS_INFOTIPhelp: "TVS_INFOTIP:

Version 4.71. Obtains ToolTip information by sending the TVN_GETINFOTIP notification.", 0

TVS_FULLROWSELECThelp: "TVS_FULLROWSELECT:

Version 4.71. Enables full-row selection in the tree view. The entire row of the selected item is highlighted,
and clicking anywhere on an item's row causes it to be selected. This style cannot be used in conjunction with
the TVS_HASLINES style.", 0

TVS_NOSCROLLhelp: "TVS_NOSCROLL:

Version 5.80. Disables horizontal scrolling in the control. The control will not display any horizontal scroll bars.", 0

TVS_NONEVENHEIGHThelp: "TVS_NONEVENHEIGHT:

Version 4.71 Sets the height of the items to an odd height with the TVM_SETITEMHEIGHT message. By default, the height
of items must be an even value.", 0

TVS_NOHSCROLLhelp: "TVS_NOHSCROLL:

Version 5.80. Disables horizontal scrolling in the control. The control will not display any horizontal scroll bars.", 0]

[TreeViewStylesHelp: TVS_HASLINEShelp TVS_LINESATROOThelp  TVS_HASBUTTONShelp
 TVS_EDITLABELShelp TVS_SHOWSELALWAYShelp TVS_DISABLEDRAGDROPhelp TVS_RTLREADINGhelp
 TVS_NOTOOLTIPShelp TVS_CHECKBOXEShelp TVS_TRACKSELECThelp TVS_SINGLEEXPANDhelp TVS_INFOTIPhelp
 TVS_FULLROWSELECThelp TVS_NOSCROLLhelp TVS_NONEVENHEIGHThelp TVS_NOHSCROLLhelp
 WS_TABSTOPhelp]

____________________________________

; Tabs Controls tables:

[TabCheckingMask:   0 0 0
                    0 0 0
                    0 0 0
                    0 0 0
                    0 0 0
                    0 0 0
                    0]

[TabTextTable:  B$ 'TCS_SCROLLOPPOSITE' 0  'TCS_RIGHT/TCS_BOTTOM' 0   'TCS_MULTISELECT' 0
                'TCS_FLATBUTTONS' 0     'TCS_FORCEICONLEFT' 0   'TCS_FORCELABELLEFT' 0
                'TCS_HOTTRACK' 0        'TCS_VERTICAL' 0        'TCS_BUTTONS' 0
                'TCS_MULTILINE' 0       'TCS_FIXEDWIDTH' 0      'TCS_RAGGEDRIGHT' 0
                'TCS_FOCUSONBUTTONDOWN' 0   'TCS_OWNERDRAWFIXED' 0      'TCS_TOOLTIPS' 0
                'TCS_FOCUSNEVER' 0      'WS_TABSTOP' 0      'WS_CHILD' 0
                'WS_VISIBLE' , 0, 0]

[TabBitTable:   &TCS_SCROLLOPPOSITE     &TCS_RIGHT              &TCS_MULTISELECT
                &TCS_FLATBUTTONS        &TCS_FORCEICONLEFT      &TCS_FORCELABELLEFT
                &TCS_HOTTRACK           &TCS_VERTICAL           &TCS_BUTTONS
                &TCS_MULTILINE          &TCS_FIXEDWIDTH         &TCS_RAGGEDRIGHT
                &TCS_FOCUSONBUTTONDOWN  &TCS_OWNERDRAWFIXED     &TCS_TOOLTIPS
                &TCS_FOCUSNEVER         &WS_TABSTOP             &WS_CHILD
                &WS_VISIBLE]


[TabExcludeBitTable:    0 0 0
                        0 &TCS_FORCELABELLEFT 0
                        0 0 0
                        0 0 0
                        &TCS_FOCUSNEVER 0 0
                        &TCS_FOCUSONBUTTONDOWN 0 0
                        0]

[TabMustHaveBitTable:   0 0 0
                        &TCS_BUTTONS &TCS_FIXEDWIDTH &TCS_FIXEDWIDTH__&TCS_FORCEICONLEFT
                        0 0 0
                        0 &TCS_FORCELABELLEFT 0
                        &TCS_BUTTONS 0 0
                        0 0 0
                        0]


[TCS_SCROLLOPPOSITEhelp: " TCS_SCROLLOPPOSITE:

Scrolls the Tab Control", 0

TCS_RIGHThelp: "TCS_RIGHT:

Places the Tab control vertically at the right corner of the control. It must be used with TCS_VERTICAL to display the tabs at the right corner.

This equate is the same as TCS_BOTTOM. But if it is used alone, the tab itens are placed horizontally at the bottom of the control.", 0

TCS_MULTISELECThelp: "TCS_MULTISELECT:

Enables multi-selection mode of the tab itens", 0

TCS_FLATBUTTONShelp: "TCS_FLATBUTTONS:

The tab itens are in Flat mode", 0

TCS_FORCEICONLEFThelp: "TCS_FORCEICONLEFT:

Only with TCS_FIXEDWIDTH.

Icons will be aligned to the left of each tab.", 0
TCS_FORCELABELLEFThelp: "TCS_FORCELABELLEFT:

Only with TCS_FIXEDWIDTH.

Labels will be be aligned to the left of each tab.", 0

TCS_HOTTRACKhelp: "TCS_HOTTRACK:

Highlite the Text Label of the Tab.", 0

TCS_VERTICALhelp: "TCS_VERTICAL:

Places the Tab itens vertically. By default the itens are places in the left corner of the Control. To display them in the right corner, use this equate with TCS_RIGHT.", 0


TCS_BUTTONShelp: "TCS_BUTTONS:

Tabs are shown in the form of buttons.", 0


TCS_MULTILINEhelp: "TCS_MULTILINE:

Allows multiple rows of tabs, when needed.", 0


TCS_FIXEDWIDTHhelp: "TCS_FIXEDWIDTH:

Cannot be combined with TCS_RIGHTJUSTIFY.

All tabs will be the same width.", 0

TCS_RAGGEDRIGHThelp: "TCS_RAGGEDRIGHT:

By default, Tabs are extended to entire fill the with of their control.

TCS_RAGGEDRIGHT prevents from this if unwanted.", 0

TCS_FOCUSONBUTTONDOWNhelp: "CS_FOCUSONBUTTONDOWN:

Tabs receive the focus when clicked.", 0

TCS_OWNERDRAWFIXEDhelp: "TCS_OWNERDRAWFIXED:

The parent window will draw the tabs.", 0

TCS_TOOLTIPShelp: "TCS_TOOLTIPS:

The tabs control will display tooltips.

See Tooltip Controls in Win Help.", 0


TCS_FOCUSNEVERhelp: "TCS_FOCUSNEVER:

Tabs never receive the focus (the Dialog does).", 0

CCS_BOTTOMhelp: "CCS_BOTTOM:

Common Controls style:

Inverts the vertical apearance of the control.", 0]


[TabStylesHelp: TCS_SCROLLOPPOSITEhelp  TCS_RIGHThelp   TCS_MULTISELECThelp
                TCS_FLATBUTTONShelp     TCS_FORCEICONLEFThelp   TCS_FORCELABELLEFThelp
                TCS_HOTTRACKhelp        TCS_VERTICALhelp        TCS_BUTTONShelp
                TCS_MULTILINEhelp       TCS_FIXEDWIDTHhelp      TCS_RAGGEDRIGHThelp
                TCS_FOCUSONBUTTONDOWNhelp       TCS_OWNERDRAWFIXEDhelp  TCS_TOOLTIPShelp
                TCS_FOCUSNEVERhelp      WS_TABSTOPhelp          WS_CHILDhelp
                WS_VISIBLEhelp]

____________________________________


; ListView Controls tables:

;[ListViewCheckingMask: &LVS_LIST &LVS_LIST &LVS_LIST &LVS_LIST 0
[ListViewCheckingMask: 0 03 03 03 0
 0F0 0F0 0
 0F000
 0 0
 0 0
 0
 0 0
 ;0F0 0
 0
 0F000
 0]

[ListViewTextTable: B$
 'LVS_ICON' 0  'LVS_SMALLICON' 0  'LVS_LIST' 0  'LVS_REPORT' 0  'LVS_NOCOLUMNHEADER' 0
 'LVS_SORTASCENDING' 0  'LVS_SORTDESCENDING' 0  'LVS_NOSORTHEADER' 0
 'LVS_AUTOARRANGE' 0
 'LVS_OWNERDRAWFIXED' 0 'LVS_OWNERDATA' 0
 'LVS_EDITLABELS' 0 'LVS_NOLABELWRAP' 0
 'LVS_NOSCROLL' 0
 'LVS_SINGLESEL' 0 'LVS_SHOWSELALWAYS' 0
 'LVS_SHAREIMAGELISTS' 0
 'LVS_ALIGNLEFT' 0
 'WS_TABSTOP' 0 0]

[ListViewBitTable: &LVS_ICON  &LVS_SMALLICON  &LVS_LIST  &LVS_REPORT  &LVS_NOCOLUMNHEADER
 &LVS_SORTASCENDING &LVS_SORTDESCENDING &LVS_NOSORTHEADER
 &LVS_AUTOARRANGE
 &LVS_OWNERDRAWFIXED &LVS_OWNERDATA
 &LVS_EDITLABELS &LVS_NOLABELWRAP
 &LVS_NOSCROLL
 &LVS_SINGLESEL &LVS_SHOWSELALWAYS
 &LVS_SHAREIMAGELISTS
 &LVS_ALIGNLEFT
 &WS_TABSTOP]
; &LVS_ALIGNLEFT &LVS_ALIGNTOP &LVS_AUTOARRANGE &LVS_BUTTON &LVS_EDITLABELS &LVS_NOLABELWRAP
; &LVS_NOSCROLL &LVS_NOSORTHEADER &LVS_OWNERDRAWFIXED &LVS_SHAREIMAGELISTS &LVS_SHOWSELALWAYS
; &LVS_SINGLESEL &LVS_SORTASCENDING &LVS_SORTDESCENDING

;[ListViewExcludeBitTable: &LVS_LIST  &LVS_LIST  &LVS_LIST  &LVS_LIST__&LVS_ALIGNLEFT  0
[ListViewExcludeBitTable:
 &LVS_SMALLICON__&LVS_LIST__&LVS_REPORT
 &LVS_LIST__&LVS_REPORT__&LVS_ICON
 &LVS_SMALLICON__&LVS_REPORT__&LVS_ICON
 &LVS_ICON__&LVS_SMALLICON__&LVS_LIST__&LVS_ALIGNLEFT  0

 &LVS_SORTDESCENDING__&LVS_NOSORTHEADER__&LVS_AUTOARRANGE &LVS_SORTASCENDING__&LVS_NOSORTHEADER__&LVS_AUTOARRANGE &LVS_SORTASCENDING__&LVS_SORTDESCENDING
 &LVS_SORTASCENDING__&LVS_SORTDESCENDING
 0 0
 0 0
 0
 0 0
 0
 &LVS_REPORT
 0]

[ListViewMustHaveBitTable: 0 0 0 0 0
 0 0 0
 0
 0 0
 0 0
 0
 0 0
 0
 0
 0]

[LVS_ICONhelp: "LVS_ICON:

Indicates an Icon view.", 0
 LVS_SMALLICONhelp: "LVS_SMALLICON:

Indicates a small Icon view.", 0
 LVS_LISThelp: "LVS_LIST:

Simple list view.", 0
 LVS_REPORThelp: "LVS_REPORT:

Report view: The first column is always left-aligned, and you cannot use LVCFMT_RIGHT to change this.", 0
 LVS_NOCOLUMNHEADERhelp: "LVS_NOCOLUMNHEADER:

A column header is not displayed (as it would be by default).", 0

 LVS_SORTASCENDINGhelp: "LVS_SORTASCENDING:

Sorts the List View in ascendent order accordying to the 1st item of your list view.", 0

 LVS_SORTDESCENDINGhelp: "LVS_SORTDESCENDING:

Sorts the List View in descendent order.", 0

 LVS_NOSORTHEADERhelp: "LVS_NOSORTHEADER:

Disables the Sort ordering of the header of the ListView Control.", 0

 LVS_AUTOARRANGEhelp: "LVS_AUTOARRANGE:

Auto-Organize the List View Control Itens. This is used by default.", 0

 LVS_OWNERDRAWFIXEDhelp: "LVS_OWNERDRAWFIXED:
The items are fixed height.

The owner of the list box redraws its contents when it receives the WM_MEASUREITEM (on creation) or WM_DRAWITEM (on change) messages.", 0

 LVS_OWNERDATAhelp: "LVS_OWNERDATA:
The owner of the list box redraws its contents when it receives the WM_MEASUREITEM (on creation) or WM_DRAWITEM (on change) messages.", 0

 LVS_EDITLABELShelp: "LVS_EDITLABELS:
Allows editing the item Label. To allow edition all you have to do is press the left button of the mouse over a selected item for a couple of seconds to allow the edition mode", 0

 LVS_NOLABELWRAPhelp: "LVS_NOLABELWRAP:
Disables the wrapping mode of the item label", 0

 LVS_NOSCROLLhelp: "LVS_NOSCROLL:
Disables the scrollbar of the ListView Control", 0

 LVS_SINGLESELhelp: "LVS_SINGLESEL:
Allows selection of a row", 0

 LVS_SHOWSELALWAYShelp: "LVS_SHOWSELALWAYS:
Always displays the selection mode", 0

 LVS_SHAREIMAGELISTShelp: "LVS_SHAREIMAGELISTS:
Allows using images or icons with the ListView Control", 0]

[ListViewStylesHelp: LVS_ICONhelp LVS_SMALLICONhelp LVS_LISThelp LVS_REPORThelp
 LVS_NOCOLUMNHEADERhelp LVS_SORTASCENDINGhelp LVS_SORTDESCENDINGhelp LVS_NOSORTHEADERhelp
 LVS_AUTOARRANGEhelp LVS_OWNERDRAWFIXEDhelp LVS_OWNERDATAhelp LVS_EDITLABELShelp
 LVS_NOLABELWRAPhelp LVS_NOSCROLLhelp LVS_SINGLESELhelp LVS_SHOWSELALWAYShelp
 LVS_SHAREIMAGELISTShelp WS_TABSTOPhelp]


____________________________________


; ToolBar Control Tables:

[ToolBarCheckingMask:
0F  0F  0F  0F
0F  0F  0F0 0F0
0F0 0F0 0   0
0   0   0   0
0   0   0F  0F
0F0 0F0 0F  0F
0F  0F  0F  0F
0F  0F  0F  0F
0F  0   0   0
0   0   0   0]

[ToolBarTextTable: B$
'TBSTYLE_BUTTON' 0  'TBSTYLE_SEP' 0 'TBSTYLE_CHECK' 0   'TBSTYLE_GROUP' 0
'TBSTYLE_CHECKGROUP' 0  'TBSTYLE_DROPDOWN' 0    'TBSTYLE_AUTOSIZE' 0    'TBSTYLE_NOPREFIX' 0
'BTNS_SHOWTEXT' 0   'BTNS_WHOLEDROPDOWN' 0  'TBSTYLE_TOOLTIPS' 0    'TBSTYLE_WRAPABLE' 0
'TBSTYLE_ALTDRAG' 0 'TBSTYLE_FLAT' 0    'TBSTYLE_LIST' 0    'TBSTYLE_CUSTOMERASE' 0
'TBSTYLE_REGISTERDROP' 0    'TBSTYLE_TRANSPARENT' 0
'TBSTYLE_EX_DRAWDDARROWS' 0 'TBSTYLE_EX_MIXEDBUTTONS' 0 'TBSTYLE_EX_HIDECLIPPEDBUTTONS' 0   'TBSTYLE_EX_DOUBLEBUFFER' 0
'CCS_TOP' 0 'CCS_NOMOVEY' 0 'CCS_BOTTOM' 0  'CCS_NORESIZE' 0
'CCS_NOPARENTALIGN' 0   'CCS_ADJUSTABLE' 0  'CCS_NODIVIDER' 0   'CCS_VERT' 0
'CCS_LEFT' 0    'CCS_NOMOVEX' 0 'CCS_RIGHT' 0

'WS_TABSTOP' 0  'WS_GROUP' 0    'WS_DISABLED' 0 'WS_CHILD' 0
'WS_VISIBLE' 0  'WS_BORDER',0   'WS_CLIPSIBLINGS', 0 0]

[ToolBarBitTable:
&TBSTYLE_BUTTON     &TBSTYLE_SEP        &TBSTYLE_CHECK      &TBSTYLE_GROUP
&TBSTYLE_CHECKGROUP &TBSTYLE_DROPDOWN   &TBSTYLE_AUTOSIZE   &TBSTYLE_NOPREFIX
&BTNS_SHOWTEXT      &BTNS_WHOLEDROPDOWN &TBSTYLE_TOOLTIPS   &TBSTYLE_WRAPABLE
&TBSTYLE_ALTDRAG    &TBSTYLE_FLAT       &TBSTYLE_LIST       &TBSTYLE_CUSTOMERASE
&TBSTYLE_REGISTERDROP   &TBSTYLE_TRANSPARENT
&TBSTYLE_EX_DRAWDDARROWS    &TBSTYLE_EX_MIXEDBUTTONS    &TBSTYLE_EX_HIDECLIPPEDBUTTONS  &TBSTYLE_EX_DOUBLEBUFFER
&CCS_TOP    &CCS_NOMOVEY    &CCS_BOTTOM &CCS_NORESIZE
&CCS_NOPARENTALIGN  &CCS_ADJUSTABLE &CCS_NODIVIDER  &CCS_VERT
&CCS_LEFT   &CCS_NOMOVEX    &CCS_RIGHT

&WS_TABSTOP &WS_GROUP   &WS_DISABLED    &WS_CHILD
&WS_VISIBLE &WS_BORDER  &WS_CLIPSIBLINGS]

[ToolBarExcludeBitTable:
0FFFF   0FFFF   0FFFF   0FFFF
0FFFF   0FFFF   0FFFF   0FFFF
0FFFF   0FFFF   0   0
0   0   0   0
0   0
0FFFF   0FFFF   0FFFF   0FFFF
0FFFF   0FFFF   0FFFF   0FFFF
0FFFF   0FFFF   0FFFF   0FFFF
0FFFF   0FFFF   0FFFF
0   0   0   0
0   0   0]

[ToolBarMustHaveBitTable:
0   0   0   0
0   0   0   0
&TBSTYLE_LIST+&TBSTYLE_EX_MIXEDBUTTONS  0   0   0
&CCS_ADJUSTABLE 0   0   0
0   0   0   0
0   0   0   0
0   0   0   0
0   0   0   0
0   0   0   0
0   0   0   0]


[TBSTYLE_BUTTONhelp: "TBSTYLE_BUTTON:

Default ToolBar Style. Initialize the Control as a Button.", 0]

[CCS_TOPhelp: "CCS_TOP:

Common Controls style:

Inverts the Horizontal appearance of the control.", 0]

[TBSTYLE_CHECKhelp: "TBSTYLE_CHECK:

Allows using a CheckBox on the ToolBar.", 0]
;;
CCS_BOTTOMhelp: "CCS_BOTTOM:
 
Common Controls style:

Inverts the vertical appearance of the control.", 0
;;
[TBSTYLE_GROUPhelp: "TBSTYLE_GROUP:

Uses the ToolBar as Group.", 0]

[TBSTYLE_CHECKGROUPhelp: "TBSTYLE_CHECKGROUP:

Uses the ToolBar as a CheckBox Group.", 0]

[TBSTYLE_DROPDOWNhelp: "TBSTYLE_DROPDOWN:

 Enables the dropdown mode on the ToolBar.", 0]

[TBSTYLE_AUTOSIZEhelp: "TBSTYLE_AUTOSIZE:

AutoSize the ToolBar to fit the window width.", 0]

[CCS_ADJUSTABLEhelp: "CCS_ADJUSTABLE:
 
Common Controls style:

Enables the customization mode of the control.", 0]

[CCS_LEFThelp: "CCS_LEFT:
 
Common Controls style:

Place the Control at the Left Corner of the window.", 0]

[CCS_RIGHThelp: "CCS_RIGHT:
 
Common Controls style:

Place the Control at the Right Corner of the window.", 0]

[TBSTYLE_TOOLTIPShelp: "TBSTYLE_TOOLTIPS:
 
Enables showing tooltips on the ToolBar.", 0]

[TBSTYLE_WRAPABLEhelp: "TBSTYLE_WRAPABLE:
 
Allows warp mode on the ToolBar.", 0]

[TBSTYLE_ALTDRAGhelp: "TBSTYLE_ALTDRAG:
 
Allows dragging and drop the ToolBar.

To do this, press the key Alt and the left mouse button and drag a certain Button in the ToolBar.", 0]

[TBSTYLE_FLAThelp: "TBSTYLE_FLAT:

Shows the ToolBar as Flat.", 0]

[TBSTYLE_LISThelp: "TBSTYLE_LIST:
 
Enables using a List Control on the ToolBar.", 0]

[TBSTYLE_CUSTOMERASEhelp: "TBSTYLE_CUSTOMERASE:
 
Allows customizatino of the ToolBar.", 0]

[TBSTYLE_REGISTERDROPhelp: "TBSTYLE_REGISTERDROP:


Allows registering the drag and drop mode.", 0]


[TBSTYLE_TRANSPARENThelp: "TBSTYLE_TRANSPARENT:
 

Shows the toolbar button as transparent to insert masked images.", 0]


[TBSTYLE_SEPhelp: "TBSTYLE_SEP:


version 4.72 and earlier. This is equivalent to BTNS_SEP (for version 5.80 and later).

Creates a separator, providing a small gap between button groups.

A button that has this style does not receive user input.", 0]


[TBSTYLE_NOPREFIXhelp: "TBSTYLE_NOPREFIX:


version 4.72 and earlier. This is equivalent to BTNS_NOPREFIX  (for version 5.80 and later).

Specifies that the button text will not have an accelerator prefix associated with it.", 0]


[BTNS_SHOWTEXThelp: "BTNS_SHOWTEXT:


Version 5.81. Specifies that button text should be displayed.

All buttons can have text, but only those buttons with the BTNS_SHOWTEXT button style will display it.

This button style must be used with the TBSTYLE_LIST style and the TBSTYLE_EX_MIXEDBUTTONS extended style.

If you set text for buttons that do not have the BTNS_SHOWTEXT style, the toolbar control will automatically display it as a ToolTip when the cursor hovers over the button.

This feature allows your application to avoid handling the TBN_GETINFOTIP notification for the toolbar.", 0]


[BTNS_WHOLEDROPDOWNhelp: "BTNS_WHOLEDROPDOWN:


Version 5.80. Specifies that the button will have a drop-down arrow, but not as a separate section.

Buttons with this style behave the same, regardless of whether the TBSTYLE_EX_DRAWDDARROWS extended style is set.", 0]


[TBSTYLE_EX_DRAWDDARROWShelp: "TBSTYLE_EX_DRAWDDARROWS:


Version 4.71. This style allows buttons to have a separate dropdown arrow.

Buttons that have the BTNS_DROPDOWN style will be drawn with a drop-down arrow in a separate section, to the right of the button.

If the arrow is clicked, only the arrow portion of the button will depress, and the toolbar control will send a TBN_DROPDOWN notification to prompt the application to display the dropdown menu.

If the main part of the button is clicked, the toolbar control sends a WM_COMMAND message with the button's ID. The application normally responds by launching the first command on the menu.

There are many situations where you may want to have only some of the dropdown buttons on a toolbar with separated arrows. To do so, set the TBSTYLE_EX_DRAWDDARROWS extended style. Give those buttons that will not have separated arrows the BTNS_WHOLEDROPDOWN style. Buttons with this style will have an arrow displayed next to the image.

However, the arrow will not be separate and when any part of the button is clicked, the toolbar control will send a TBN_DROPDOWN notification.

To prevent repainting problems, this style should be set before the toolbar control becomes visible.

Note :

    To set an extended style, send the toolbar control a TB_SETEXTENDEDSTYLE message. To determine what extended styles are currently set, send a TB_GETEXTENDEDSTYLE message.", 0]


[TBSTYLE_EX_HIDECLIPPEDBUTTONShelp: "TBSTYLE_EX_HIDECLIPPEDBUTTONS:

Version 5.81. This style hides partially clipped buttons.

The most common use of this style is for toolbars that are part of a rebar control. If an adjacent band covers part of a button, the button will not be displayed.
However, if the rebar band has the RBBS_USECHEVRON style, the button will be displayed on the chevron's dropdown menu.

Note :

    To set an extended style, send the toolbar control a TB_SETEXTENDEDSTYLE message. To determine what extended styles are currently set, send a TB_GETEXTENDEDSTYLE message.", 0]

[TBSTYLE_EX_DOUBLEBUFFERhelp: "TBSTYLE_EX_DOUBLEBUFFER:

Version 6. This style requires the toolbar to be double buffered. Double buffering is a mechanism that detects when the toolbar has changed.
Comctl32.dll version 6 is not redistributable but it is included in Microsoft Windows XP or later. To use Comctl32.dll version 6, specify it in a manifest.

Note :

    To set an extended style, send the toolbar control a TB_SETEXTENDEDSTYLE message. To determine what extended styles are currently set, send a TB_GETEXTENDEDSTYLE message.", 0]

[TBSTYLE_EX_MIXEDBUTTONShelp: "TBSTYLE_EX_MIXEDBUTTONS:


Version 5.81. This style allows you to set text for all buttons, but only display it for those buttons with the BTNS_SHOWTEXT button style.

The TBSTYLE_LIST style must also be set. Normally, when a button does not display text, your application must handle TBN_GETINFOTIP to display a ToolTip.

With the TBSTYLE_EX_MIXEDBUTTONS extended style, text that is set but not displayed on a button will automatically be used as the button's ToolTip text.

Your application only needs to handle TBN_GETINFOTIP if it needs more flexibility in specifying the ToolTip text.

Note :

    To set an extended style, send the toolbar control a TB_SETEXTENDEDSTYLE message. To determine what extended styles are currently set, send a TB_GETEXTENDEDSTYLE message.", 0]

[CCS_NOMOVEYhelp: "CCS_NOMOVEY:

Causes the control to resize and move itself horizontally, but not vertically, in response to a WM_SIZE message.

Header windows have this style by default. This style does not apply if your control has the CCS_NORESIZE style.", 0]

[CCS_NORESIZEhelp: "CCS_NORESIZE:
 
Prevents the control from using the default width and height when setting its initial size or a new size.

Instead, the control uses the width and height that is specified in the request for creation or sizing.", 0]

[CCS_NOPARENTALIGNhelp: "CCS_NOPARENTALIGN:
 
Prevents the control from automatically moving to the top or bottom of the parent window.

Instead, the control keeps its position within the parent window despite changes to the size of the parent.
If the application also uses the CCS_TOP or CCS_BOTTOM styles, it adjusts the height to the default, but does not change the position and width of the control.", 0]

[CCS_NODIVIDERhelp: "CCS_NODIVIDER:

Prevents a 2-pixel highlight from being drawn at the top of the control.", 0]

[CCS_VERThelp: "CCS_VERT:

Causes the control to display vertically.", 0]

[CCS_NOMOVEXhelp: "CCS_NOMOVEX:

Version 4.70. Causes the control to resize and move itself vertically, but not horizontally, in response to a WM_SIZE message.

If CCS_NORESIZE is used, this style does not apply.", 0]


[WS_CLIPSIBLINGShelp: "WS_CLIPSIBLINGS:

Clips child windows relative to each other; that is, when a particular child window receives a paint message, the WS_CLIPSIBLINGS style clips all other overlapped child windows out of the region of the child window to be updated.
(If WS_CLIPSIBLINGS is not given and child windows overlap, when you draw within the client area of a child window, it is possible to draw within the client area of a neighboring child window.) For use with the WS_CHILD style only.", 0]


[ToolBarStylesHelp:
TBSTYLE_BUTTONhelp  TBSTYLE_SEPhelp TBSTYLE_CHECKhelp   TBSTYLE_GROUPhelp
TBSTYLE_CHECKGROUPhelp  TBSTYLE_DROPDOWNhelp    TBSTYLE_AUTOSIZEhelp    TBSTYLE_NOPREFIXhelp
BTNS_SHOWTEXThelp   BTNS_WHOLEDROPDOWNhelp  TBSTYLE_TOOLTIPShelp    TBSTYLE_WRAPABLEhelp
TBSTYLE_ALTDRAGhelp TBSTYLE_FLAThelp    TBSTYLE_LISThelp    TBSTYLE_CUSTOMERASEhelp
TBSTYLE_REGISTERDROPhelp    TBSTYLE_TRANSPARENThelp TBSTYLE_EX_DRAWDDARROWShelp TBSTYLE_EX_MIXEDBUTTONShelp
TBSTYLE_EX_HIDECLIPPEDBUTTONShelp   TBSTYLE_EX_DOUBLEBUFFERhelp CCS_TOPhelp CCS_NOMOVEYhelp
CCS_BOTTOMhelp  CCS_NORESIZEhelp    CCS_NOPARENTALIGNhelp   CCS_ADJUSTABLEhelp
CCS_NODIVIDERhelp   CCS_VERThelp    CCS_LEFThelp    CCS_NOMOVEXhelp
CCS_RIGHThelp   WS_TABSTOPhelp  WS_GROUPhelp    WS_DISABLEDhelp
WS_CHILDhelp    WS_VISIBLEhelp  WS_BORDERhelp   WS_CLIPSIBLINGShelp]


; &CCS_VERT We don't need this because when it is set to Left or Right, it already uses the CCS_VERT
; &TBSTYLE_SEP The same as TBSTYLE_SEP
; &TBSTYLE_NOPREFIX iS THE SAME AS &CCS_ADJUSTABLE

____________________________________

; RichEdit20a control tables:



[RichEdit20aCheckingMask: 03 03 03 0   0 0 0 0   0 0 0 0   0 0 0 0   0 0 0 0]

[RichEdit20aTextTable: B$
 'ES_LEFT' 0         'ES_CENTER' 0        'ES_RIGHT' 0       'ES_MULTILINE' 0
 'ES_AUTOVSCROLL' 0  'ES_AUTOHSCROLL' 0   'ES_LOWERCASE' 0   'ES_UPPERCASE' 0
 'ES_PASSWORD' 0     'ES_OEMCONVERT' 0    'ES_NOHIDESEL' 0   'ES_READONLY' 0
 'ES_NUMBER' 0       'ES_WANTRETURN' 0    'WS_VSCROLL' 0     'WS_HSCROLL' 0
 'WS_TABSTOP' 0      'WS_BORDER' 0        'WS_VISIBLE' 0     'WS_CHILD' 0 0]

[RichEdit20aBitTable:
 &ES_LEFT             &ES_CENTER            &ES_RIGHT           &ES_MULTILINE
 &ES_AUTOVSCROLL      &ES_AUTOHSCROLL       &ES_LOWERCASE       &ES_UPPERCASE
 &ES_PASSWORD         &ES_OEMCONVERT        &ES_NOHIDESEL       &ES_READONLY
 &ES_NUMBER           &ES_WANTRETURN        &WS_VSCROLL         &WS_HSCROLL
 &WS_TABSTOP          &WS_BORDER            &WS_VISIBLE         &WS_CHILD]

[RichEdit20aExcludeBitTable:
 03  02   01   0
 0   0   08  010
 0   0   0   0
 0   0   0   0
 0   0   0   0]

[RichEdit20aMustHaveBitTable:
 0 0 0 0
 &WS_VSCROLL &WS_HSCROLL 0 0
 0 0 0 0
 0 0 0 0
 0 0 0 0]

[RichEdit20aStylesHelp: ES_LEFThelp ES_CENTERhelp ES_RIGHThelp ES_MULTILINEhelp
  ES_AUTOVSCROLLhelp
 ES_AUTOHSCROLLhelp ES_LOWERCASEhelp ES_UPPERCASEhelp ES_PASSWORDhelp
 ES_OEMCONVERThelp ES_NOHIDESELhelp ES_READONLYhelp ES_NUMBERhelp ES_WANTRETURNhelp
 WS_VSCROLLhelp WS_HSCROLLhelp WS_TABSTOPhelp WS_BORDERhelp  WS_VISIBLEhelp WS_CHILDhelp]

____________________________________

; SysHeader32 control tables:

; use this on: ShowControlStyles ,  ShowControlStyleControl , ControlClassByNames , SearchWhatControlClass , WriteStyle,
; ShowStyleInfo
  ;&WS_GROUP &WS_DISABLED
  ; &BS_RIGHTBUTTON &BS_TEXT

[SysHeader32CheckingMask:
    0 0 0 0
    0 0 0 0
    0 0 0
    0 0 0 0
    0 0 0 0]


[SysHeader32TextTable: B$
'HDS_BUTTONS' 0 'HDS_DRAGDROP' 0 'HDS_FILTERBAR' 0 'HDS_FLAT' 0
'HDS_FULLDRAG' 0 'HDS_HIDDEN' 0  'HDS_HORZ' 0 'HDS_HOTTRACK' 0
'HDS_CHECKBOXES' 0 'HDS_NOSIZING' 0     'HDS_OVERFLOW' 0
'WS_VSCROLL' 0 'WS_HSCROLL' 0 'WS_TABSTOP' 0 'WS_BORDER' 0
'WS_VISIBLE' 0 'WS_CHILD' 0 'WS_GROUP' 0 'WS_DISABLED' 0 0]

[SysHeader32BitTable:
 &HDS_BUTTONS       &HDS_DRAGDROP   &HDS_FILTERBAR  &HDS_FLAT
 &HDS_FULLDRAG      &HDS_HIDDEN     &HDS_HORZ       &HDS_HOTTRACK
 &HDS_CHECKBOXES    &HDS_NOSIZING   &HDS_OVERFLOW
 &WS_VSCROLL        &WS_HSCROLL     &WS_TABSTOP     &WS_BORDER
 &WS_VISIBLE        &WS_CHILD       &WS_GROUP       &WS_DISABLED]

[SysHeader32ExcludeBitTable:
    &HDS_CHECKBOXES 0 0 0
    0 0 0 0
    &HDS_BUTTONS 0 0
    0 0 0 0
    0 0 0 0]

[SysHeader32MustHaveBitTable:
    0 0 0 0
    0 0 0 0
    0 0 0
    0 0 0 0
    0 0 0 0]

[SysHeader32StylesHelp:
HDS_BUTTONShelp     HDS_DRAGDROPhelp    HDS_FILTERBARhelp   HDS_FLAThelp
HDS_FULLDRAGhelp    HDS_HIDDENhelp      HDS_HORZhelp        HDS_HOTTRACKhelp
HDS_CHECKBOXEShelp  HDS_NOSIZINGhelp    HDS_OVERFLOWhelp
WS_VSCROLLhelp      WS_HSCROLLhelp      WS_TABSTOPhelp      WS_BORDERhelp
WS_VISIBLEhelp      WS_CHILDhelp        WS_GROUPhelp        WS_DISABLEDhelp]


[HDS_BUTTONShelp: "HDS_BUTTONS:

Each item in the control looks and behaves like a push button.
This style is useful if an application carries out a task when the user clicks an item in the header control.
For example, an application could sort information in the columns differently depending on which item the user clicks.", 0]

[HDS_DRAGDROPhelp: "HDS_DRAGDROP:

Version 4.70. Allows drag-and-drop reordering of header items.", 0]

[HDS_FILTERBARhelp: "HDS_FILTERBAR:

Version 5.80. Include a filter bar as part of the standard header control.
This bar allows users to conveniently apply a filter to the display.
Calls to HDM_LAYOUT will yield a new size for the control and cause the list view to update.", 0]

[HDS_FLAThelp: "HDS_FLAT:

Version 6.0. Causes the header control to be drawn flat when Microsoft Windows XP is running in classic mode.

Note:  Comctl32.dll version 6 is not redistributable but it is included in Windows XP or later.
To use Comctl32.dll version 6, specify it in a manifest windows style", 0]

[HDS_FULLDRAGhelp: "HDS_FULLDRAG:

Version 4.70. Causes the header control to display column contents even while the user resizes a column.", 0]

[HDS_HIDDENhelp: "HDS_HIDDEN:

Indicates a header control that is intended to be hidden.
This style does not hide the control.
Instead, when you send the HDM_LAYOUT message to a header control with the HDS_HIDDEN style, the control returns zero in the cy member of the WINDOWPOS structure.
You would then hide the control by setting its height to zero.
This can be useful when you want to use the control as an information container instead of a visual control.", 0]

[HDS_HORZhelp: "HDS_HORZ:

Creates a header control with a horizontal orientation.", 0]

[HDS_HOTTRACKhelp: "HDS_HOTTRACK:

Version 4.70. Enables hot tracking.", 0]

[HDS_CHECKBOXEShelp: "HDS_CHECKBOXES:

(0x0400)", 0]

[HDS_NOSIZINGhelp: "HDS_NOSIZING:

(0x0800)", 0]

[HDS_OVERFLOWhelp: "HDS_OVERFLOW:

(0x1000)", 0]


____________________________________

; ReBarWindow32 controls

[ReBarWindow32CheckingMask:
 &CCS_BOTTOM  &CCS_VERT__&CCS_BOTTOM
 0  0
 0  0   0
 0  0   0   &CCS_VERT

 &CCS_RIGHT &CCS_LEFT

 0  0   0]


[ReBarWindow32TextTable: B$
 'CCS_TOP' 0  'CCS_BOTTOM' 0
 'RBS_AUTOSIZE' 0   'CCS_ADJUSTABLE' 0
 'RBS_BANDBORDERS' 0 'RBS_DBLCLKTOGGLE' 0    'RBS_FIXEDORDER' 0
 'RBS_REGISTERDROP' 0    'RBS_TOOLTIPS' 0        'RBS_VARHEIGHT' 0   'RBS_VERTICALGRIPPER' 0

 'CCS_LEFT' 0  'CCS_RIGHT' 0

 'WS_BORDER' 0  'WS_VISIBLE' 0  'WS_CHILD' 0 0]

[ReBarWindow32BitTable:
&CCS_TOP &CCS_BOTTOM
&RBS_AUTOSIZE   &CCS_ADJUSTABLE
&RBS_BANDBORDERS    &RBS_DBLCLKTOGGLE   &RBS_FIXEDORDER
&RBS_REGISTERDROP   &RBS_TOOLTIPS   &RBS_VARHEIGHT  &RBS_VERTICALGRIPPER

&CCS_LEFT &CCS_RIGHT

&WS_BORDER &WS_VISIBLE &WS_CHILD]


[ReBarWindow32ExcludeBitTable:
 &CCS_VERT__&CCS_BOTTOM  &CCS_VERT__&CCS_TOP
 0  0
 0  0   0
 0  0   0   0

 &CCS_RIGHT+&CCS_BOTTOM+&CCS_TOP  &CCS_LEFT+&CCS_TOP+&CCS_BOTTOM

 0  0   0]

[ReBarWindow32MustHaveBitTable:
 0  0
 0  0
 0  0   0
 0  0   0   0

 0  0

 0  0   0]

[ReBarWindow32StylesHelp:
CCS_TOPhelp CCS_BOTTOMhelp  RBS_AUTOSIZEhelp    CCS_ADJUSTABLEhelp
RBS_BANDBORDERShelp RBS_DBLCLKTOGGLEhelp        RBS_FIXEDORDERhelp  RBS_REGISTERDROPhelp
RBS_TOOLTIPShelp    RBS_VARHEIGHThelp   RBS_VERTICALGRIPPERhelp CCS_LEFThelp
CCS_RIGHThelp   WS_BORDERhelp   WS_VISIBLEhelp  WS_CHILDhelp]


[RBS_AUTOSIZEhelp: "RBS_AUTOSIZE:

Version 4.71. The rebar control will automatically change the layout of the bands when the size or position of the control changes. An RBN_AUTOSIZE notification will be sent when this occurs.", 0]

[RBS_BANDBORDERShelp: "RBS_BANDBORDERS:

Version 4.71. The rebar control displays narrow lines to separate adjacent bands.", 0]

[RBS_DBLCLKTOGGLEhelp: "RBS_DBLCLKTOGGLE:

Version 4.71. The rebar band will toggle its maximized or minimized state when the user double-clicks the band. Without this style, the maximized or minimized state is toggled when the user single-clicks on the band.", 0]

[RBS_FIXEDORDERhelp: "RBS_FIXEDORDER:

Version 4.70. The rebar control always displays bands in the same order. You can move bands to different rows, but the band order is static.", 0]

[RBS_REGISTERDROPhelp: "RBS_REGISTERDROP:

Version 4.71. The rebar control generates RBN_GETOBJECT notification messages when an object is dragged over a band in the control. To receive the RBN_GETOBJECT notifications, initialize OLE with a call to OleInitialize or CoInitialize.", 0]

[RBS_TOOLTIPShelp: "RBS_TOOLTIPS:

Version 4.71. Not yet supported.", 0]

[RBS_VARHEIGHThelp: "RBS_VARHEIGHT:

Version 4.71. The rebar control displays bands at the minimum required height, when possible. Without this style, the rebar control displays all bands at the same height, using the height of the tallest visible band to determine the height of other bands.", 0]

[RBS_VERTICALGRIPPERhelp: "RBS_VERTICALGRIPPER:

Version 4.71. The size grip will be displayed vertically instead of horizontally in a vertical rebar control. This style is ignored for rebar controls that do not have the CCS_VERT style.", 0]

____________________________________

; tooltips_class32
;note: A ToolTip control always has the WS_POPUP and WS_EX_TOOLWINDOW window styles,
; regardless of whether you specify them when creating the control.

[Tooltips_class32CheckingMask:
 0  0   0   0
 0  0   0
 0  0   0
 0  0]
 ;&WS_POPUP  &WS_EX_TOOLWINDOW]

[Tooltips_class32TextTable: B$
 'TTS_ALWAYSTIP', 0     'TTS_BALLOON', 0        'TTS_NOANIMATE', 0      'TTS_NOFADE', 0
 'TTS_NOPREFIX', 0      'TTS_USEVISUALSTYLE', 0     'TTS_CLOSE', 0
 'WS_BORDER', 0         '&WS_VISIBLE', 0     'WS_CHILD', 0
 'WS_POPUP', 0          'WS_EX_TOOLWINDOW', 0 0]



[Tooltips_class32BitTable:
 &TTS_ALWAYSTIP     &TTS_BALLOON    &TTS_NOANIMATE  &TTS_NOFADE
 &TTS_NOPREFIX      &TTS_USEVISUALSTYLE     &TTS_CLOSE
 &WS_BORDER         &WS_VISIBLE     &WS_CHILD
 &WS_POPUP          &WS_EX_TOOLWINDOW]


[Tooltips_class32ExcludeBitTable:
 0  0   0   0
 0  0   0
 0  0   0
 0  0]


[Tooltips_class32MustHaveBitTable:
 &WS_POPUP+&WS_EX_TOOLWINDOW  &WS_POPUP+&WS_EX_TOOLWINDOW   &WS_POPUP+&WS_EX_TOOLWINDOW   &WS_POPUP+&WS_EX_TOOLWINDOW
 &WS_POPUP+&WS_EX_TOOLWINDOW  &WS_POPUP+&WS_EX_TOOLWINDOW   &WS_POPUP+&WS_EX_TOOLWINDOW
 0  0   0
 0  0];&WS_POPUP  &WS_EX_TOOLWINDOW];  0]

[Tooltips_class32StylesHelp:
 TTS_ALWAYSTIPHelp  TTS_BALLOONHelp TTS_NOANIMATEHelp   TTS_NOFADEHelp
 TTS_NOPREFIXHelp    TTS_USEVISUALSTYLEHelp  TTS_CLOSEHelp
 WS_BORDERhelp      WS_VISIBLEhelp WS_CHILDhelp
 WS_POPUPhelp       WS_EX_TOOLWINDOWhelp]


[TTS_ALWAYSTIPHelp: "TTS_ALWAYSTIP:

Indicates that the ToolTip control appears when the cursor is on a tool, even if the ToolTip control's owner window is inactive.
Without this style, the ToolTip appears only when the tool's owner window is active.", 0]

[TTS_BALLOONHelp: "TTS_BALLOON:

Version 5.80. Indicates that the ToolTip control has the appearance of a cartoon 'balloon,' with rounded corners and a stem pointing to the item.", 0]

[TTS_NOANIMATEHelp: "TTS_NOANIMATE:

Version 5.80. Disables sliding ToolTip animation on Microsoft Windows 98 and Windows 2000 systems.
This style is ignored on earlier systems.", 0]

[TTS_NOFADEHelp: "TTS_NOFADE:

Version 5.80. Disables fading ToolTip animation on Windows 2000 systems.
This style is ignored on earlier Microsoft Windows NT systems, and on Windows 95 and Windows 98.", 0]

[TTS_NOPREFIXHelp: "TTS_NOPREFIX:

Prevents the system from stripping the ampersand character from a string.
Without this style, the system automatically strips ampersand characters.
This allows an application to use the same string as both a menu item and as text in a ToolTip control.", 0]

[TTS_USEVISUALSTYLEHelp: "TTS_USEVISUALSTYLE:

Uses themed hyperlinks. The theme will define the styles for any links in the tooltip.
This style always requires TTF_PARSELINKS to be set.", 0]

[TTS_CLOSEHelp: "TTS_CLOSE:

Displays a Close button on the tooltip.", 0]

[WS_EX_TOOLWINDOWhelp: "WS_EX_TOOLWINDOW:

Creates a tool window; that is, a window intended to be used as a floating toolbar.
A tool window has a title bar that is shorter than a normal title bar, and the window title is drawn using a smaller font.
A tool window does not appear in the taskbar or in the dialog box that appears when the user presses ALT+TAB.
If a tool window has a system menu, its icon is not displayed on the title bar.
However, you can display the system menu by typing ALT+SPACE.", 0]


____________________________________

; msctls_statusbar32

[msctls_statusbar32CheckingMask:
 0  0
 0  0   0
 0]

[msctls_statusbar32TextTable: B$
 'SBARS_SIZEGRIP', 0     'SBT_TOOLTIPS', 0
 'WS_BORDER', 0         '&WS_VISIBLE', 0     'WS_CHILD', 0
 'WS_POPUP', 0 0]



[msctls_statusbar32BitTable:
 &SBARS_SIZEGRIP    &SBT_TOOLTIPS
 &WS_BORDER         &WS_VISIBLE     &WS_CHILD
 &WS_POPUP]


[msctls_statusbar32ExcludeBitTable:
 0  0
 0  0   0
 0]


[msctls_statusbar32MustHaveBitTable:
 0  0
 0  0  0
 0]

[msctls_statusbar32StylesHelp:
 SBARS_SIZEGRIPHelp  SBT_TOOLTIPSHelp
 WS_BORDERhelp      WS_VISIBLEhelp WS_CHILDhelp
 WS_POPUPhelp]


[SBARS_SIZEGRIPHelp: "SBARS_SIZEGRIP:

The status bar control will include a sizing grip at the right end of the status bar.
A sizing grip is similar to a sizing border; it is a rectangular area that the user can click and drag to resize the parent window.", 0]

[SBT_TOOLTIPSHelp: "SBT_TOOLTIPS:

Version 4.71.Use this style to enable ToolTips.
This is exactly the same as SBARS_TOOLTIPS", 0]


____________________________________

; msctls_hotkey32

[msctls_hotkey32CheckingMask:
 0  0]

[msctls_hotkey32TextTable: B$
 'WS_BORDER', 0         'WS_TABSTOP', 0 0]


[msctls_hotkey32BitTable:
 &WS_BORDER         &WS_TABSTOP]


[msctls_hotkey32ExcludeBitTable:
 0  0]


[msctls_hotkey32MustHaveBitTable:
 0  0]

[msctls_hotkey32StylesHelp:
 WS_BORDERhelp      WS_TABSTOPhelp]


____________________________________

; ComboBoxEx32

[ComboBoxEx32CheckingMask:
 0
 0  0
 0  0
 0  ;0
 0  0   0]

[ComboBoxEx32TextTable: B$

'CBS_OWNERDRAWFIXED', 0

'CBES_EX_CASESENSITIVE', 0         'CBES_EX_NOEDITIMAGE', 0

'CBES_EX_NOEDITIMAGEINDENT', 0         'CBES_EX_NOSIZELIMIT', 0

'CBES_EX_PATHWORDBREAKPROC', 0         ;'CBES_EX_TEXTENDELLIPSIS', 0

 'WS_TABSTOP', 0    'WS_VSCROLL' 0   'WS_HSCROLL' 0 0]


[ComboBoxEx32BitTable:
&CBS_OWNERDRAWFIXED
&CBES_EX_CASESENSITIVE  &CBES_EX_NOEDITIMAGE
&CBES_EX_NOEDITIMAGEINDENT  &CBES_EX_NOSIZELIMIT
&CBES_EX_PATHWORDBREAKPROC  ;  &CBES_EX_TEXTENDELLIPSIS (For Windows Vista. we need this equate later :) )
&WS_TABSTOP   &WS_VSCROLL   &WS_HSCROLL]

[ComboBoxEx32ExcludeBitTable:
 0
 0  0
 0  0
 0  ;0
 0  0  0]


[ComboBoxEx32MustHaveBitTable:
 0
 0  0
 0  0
 0  ;0
 0  0  0]

[ComboBoxEx32StylesHelp:
 CBS_OWNERDRAWFIXEDhelp
 CBES_EX_CASESENSITIVEhelp      CBES_EX_NOEDITIMAGEhelp
 CBES_EX_NOEDITIMAGEINDENThelp   CBES_EX_NOSIZELIMIThelp
 CBES_EX_PATHWORDBREAKPROChelp ; CBES_EX_TEXTENDELLIPSIShelp
 WS_TABSTOPhelp     WS_VSCROLLhelp  WS_HSCROLLhelp]


[CBES_EX_CASESENSITIVEhelp: "CBES_EX_CASESENSITIVE:

BSTR searches in the list will be case sensitive.
This includes searches as a result of text being typed in the edit box and the CB_FINDSTRINGEXACT message.", 0]

[CBES_EX_NOEDITIMAGEhelp: "CBES_EX_NOEDITIMAGE:

The edit box and the dropdown list will not display item images.", 0]

[CBES_EX_NOEDITIMAGEINDENThelp: "CBES_EX_NOEDITIMAGEINDENT:

The edit box and the dropdown list will not display item images.", 0]

[CBES_EX_NOSIZELIMIThelp: "CBES_EX_NOSIZELIMIT:

Allows the ComboBoxEx control to be vertically sized smaller than its contained combo box control.
If the ComboBoxEx is sized smaller than the combo box, the combo box will be clipped.", 0]

[CBES_EX_PATHWORDBREAKPROChelp: "CBES_EX_PATHWORDBREAKPRO:

Microsoft Windows NT only.
The edit box will use the slash (/), backslash (\), and period (.) characters as word delimiters.
This makes keyboard shortcuts for word-by-word cursor movement () effective in path names and URLs.", 0]

[CBES_EX_TEXTENDELLIPSIShelp: "CBES_EX_TEXTENDELLIPSIS:

Windows Vista and later.
Causes items in the drop-down list and the edit box (when the edit box is read only) to be truncated with an ellipsis ('...') rather than just clipped by the edge of the control.
This is useful when the control needs to be set to a fixed width, yet the entries in the list may be long.", 0]

____________________________________

;SysAnimate32


[SysAnimate32CheckingMask:
 0  0  0  0
 0  0  0  0]

[SysAnimate32TextTable: B$
 'ACS_AUTOPLAY', 0   'ACS_CENTER', 0  'ACS_TIMER', 0  'ACS_TRANSPARENT', 0
 'WS_BORDER', 0      'WS_TABSTOP', 0    'WS_VSCROLL' 0   'WS_HSCROLL' 0 0]


[SysAnimate32BitTable:
 &ACS_AUTOPLAY   &ACS_CENTER  &ACS_TIMER   &ACS_TRANSPARENT
 &WS_BORDER &WS_TABSTOP   &WS_VSCROLL   &WS_HSCROLL]

[SysAnimate32ExcludeBitTable:
 0  0  0  0
 0  0  0  0]


[SysAnimate32MustHaveBitTable:
 0  0  0  0
 0  0  0  0]

[SysAnimate32StylesHelp:
 ACS_AUTOPLAYhelp   ACS_CENTERhelp  ACS_TIMERhelp   ACS_TRANSPARENThelp
 WS_BORDERhelp WS_TABSTOPhelp     WS_VSCROLLhelp  WS_HSCROLLhelp]


[ACS_AUTOPLAYhelp: "ACS_AUTOPLAY:

Starts playing the animation as soon as the AVI clip is opened.", 0]

[ACS_CENTERhelp: "ACS_CENTER:

Centers the animation in the animation control's window.", 0]

[ACS_TIMERhelp: "ACS_TIMER:

By default, the control creates a thread to play the AVI clip.
If you set this flag, the control plays the clip without creating a thread; internally the control uses a Win32 timer to synchronize playback.
Comctl32.dll version 6 and later: This style is not supported. By default, the control plays the AVI clip without creating a thread.
Note:  Comctl32.dll version 6 is not redistributable, but it is included in Microsoft Windows XP.
To use Comctl32.dll version 6, specify it in a manifest.", 0]

[ACS_TRANSPARENThelp: "ACS_TRANSPARENT:

Allows you to match an animation's background color to that of the underlying window, creating a 'transparent' background.
The parent of the animation control must not have the WS_CLIPCHILDREN style.
The control sends a WM_CTLCOLORSTATIC message to its parent.
Use SetBkColor to set the background color for the device context to an appropriate value.
The control interprets the upper-left pixel of the first frame as the animation's default background color.
It will remap all pixels with that color to the value you supplied in response to WM_CTLCOLORSTATIC.", 0]

____________________________________

; SysMonthCal32

[SysMonthCal32CheckingMask:
 0  0  0  0
 0  ;0  0  0
 0  0  0  0]

[SysMonthCal32TextTable: B$
 'MCS_DAYSTATE', 0   'MCS_MULTISELECT', 0  'MCS_WEEKNUMBERS', 0  'MCS_NOTODAYCIRCLE', 0
 'MCS_NOTODAY', 0   ; 'MCS_NOTRAILINGDATES', 0 'MCS_SHORTDAYSOFWEEK', 0     'MCS_NOSELCHANGEONNAV', 0
 'WS_BORDER', 0      'WS_TABSTOP', 0    'WS_VSCROLL' 0   'WS_HSCROLL' 0 0]


[SysMonthCal32BitTable:
 &MCS_DAYSTATE   &MCS_MULTISELECT  &MCS_WEEKNUMBERS  &MCS_NOTODAYCIRCLE
 &MCS_NOTODAY   ; &MCS_NOTRAILINGDATES &MCS_SHORTDAYSOFWEEK     &MCS_NOSELCHANGEONNAV (these are Vista equates.. need to get them later)
 &WS_BORDER &WS_TABSTOP   &WS_VSCROLL   &WS_HSCROLL]

[SysMonthCal32ExcludeBitTable:
 0  0  0  0
 0  ;0  0  0
 0  0  0  0]


[SysMonthCal32MustHaveBitTable:
 0  0  0  0
 0  ;0  0  0
 0  0  0  0]

[SysMonthCal32StylesHelp:
 MCS_DAYSTATEhelp   MCS_MULTISELECThelp  MCS_WEEKNUMBERShelp  MCS_NOTODAYCIRCLEhelp
 MCS_NOTODAYhelp    ;MCS_NOTRAILINGDATEShelp MCS_SHORTDAYSOFWEEKhelp     MCS_NOSELCHANGEONNAVhelp
 WS_BORDERhelp WS_TABSTOPhelp     WS_VSCROLLhelp  WS_HSCROLLhelp]


[MCS_DAYSTATEhelp: "MCS_DAYSTATE:

Version 4.70. The month calendar will send MCN_GETDAYSTATE notifications to request information about which days should be displayed in bold.", 0]

[MCS_MULTISELECThelp: "MCS_MULTISELECT:

Version 4.70. The month calendar will allow the user to select a range of dates within the control.
By default, the maximum range is one week. You can change the maximum range that can be selected by using the MCM_SETMAXSELCOUNT message.", 0]

[MCS_WEEKNUMBERShelp: "MCS_WEEKNUMBERS:

Version 4.70. The month calendar control will display week numbers (1-52) to the left of each row of days.
Week 1 is defined as the first week that contains at least four days.", 0]

[MCS_NOTODAYCIRCLEhelp: "MCS_NOTODAYCIRCLE:

Version 4.70. The month calendar control will not circle the 'today' date.", 0]

[MCS_NOTODAYhelp: "MCS_NOTODAY:

Version 4.70.The month calendar control will not display the 'today' date at the bottom of the control.", 0]

[MCS_NOTRAILINGDATEShelp: "MCS_NOTRAILINGDATES:

Microsoft Windows Vista. This flag disables displaying the dates from the previous/next month in the current calendar.", 0]

[MCS_SHORTDAYSOFWEEKhelp: "MCS_SHORTDAYSOFWEEK:

Microsoft Windows Vista. This flag uses the CAL_SSHORTESTDAYNAME* names to display for the day of the week column header.", 0]

[MCS_NOSELCHANGEONNAVhelp: "MCS_NOSELCHANGEONNAV:

Microsoft Windows Vista. This flag does not change the selection when the user navigates next or previous in the calendar.
This allows the user to select a range larger than what they can currently see.", 0]

____________________________________

; SysDateTimePick32

[SysDateTimePick32CheckingMask:
 &DTS_APPCANPARSE
 &DTS_LONGDATEFORMAT
 &DTS_RIGHTALIGN
 &DTS_SHOWNONE
 &DTS_SHORTDATEFORMAT
 &DTS_SHORTDATECENTURYFORMAT
 &DTS_TIMEFORMAT
 &DTS_UPDOWN

 0  0  0  0]

[SysDateTimePick32TextTable: B$
'DTS_APPCANPARSE', 0
'DTS_LONGDATEFORMAT', 0
'DTS_RIGHTALIGN', 0
'DTS_SHOWNONE', 0
'DTS_SHORTDATEFORMAT', 0
'DTS_SHORTDATECENTURYFORMAT', 0
'DTS_TIMEFORMAT', 0
'DTS_UPDOWN', 0
'WS_BORDER', 0      'WS_TABSTOP', 0    'WS_VSCROLL' 0   'WS_HSCROLL' 0 0]


[SysDateTimePick32BitTable:
 &DTS_APPCANPARSE
 &DTS_LONGDATEFORMAT
 &DTS_RIGHTALIGN
 &DTS_SHOWNONE
 &DTS_SHORTDATEFORMAT
 &DTS_SHORTDATECENTURYFORMAT
 &DTS_TIMEFORMAT
 &DTS_UPDOWN
 &WS_BORDER &WS_TABSTOP   &WS_VSCROLL   &WS_HSCROLL]

[SysDateTimePick32ExcludeBitTable:
 &DTS_LONGDATEFORMAT+&DTS_RIGHTALIGN+&DTS_SHOWNONE+&DTS_SHORTDATEFORMAT+&DTS_SHORTDATECENTURYFORMAT+&DTS_TIMEFORMAT+&DTS_UPDOWN
 &DTS_APPCANPARSE+&DTS_RIGHTALIGN+&DTS_SHOWNONE+&DTS_SHORTDATEFORMAT+&DTS_SHORTDATECENTURYFORMAT+&DTS_TIMEFORMAT+&DTS_UPDOWN
 &DTS_APPCANPARSE+&DTS_LONGDATEFORMAT+&DTS_SHOWNONE+&DTS_SHORTDATEFORMAT+&DTS_SHORTDATECENTURYFORMAT+&DTS_TIMEFORMAT+&DTS_UPDOWN
 &DTS_APPCANPARSE+&DTS_LONGDATEFORMAT+&DTS_RIGHTALIGN+&DTS_SHORTDATEFORMAT+&DTS_SHORTDATECENTURYFORMAT+&DTS_TIMEFORMAT+&DTS_UPDOWN
 &DTS_APPCANPARSE+&DTS_LONGDATEFORMAT+&DTS_RIGHTALIGN+&DTS_SHOWNONE+&DTS_SHORTDATECENTURYFORMAT+&DTS_TIMEFORMAT+&DTS_UPDOWN
 &DTS_APPCANPARSE+&DTS_LONGDATEFORMAT+&DTS_RIGHTALIGN+&DTS_SHOWNONE+&DTS_SHORTDATEFORMAT+&DTS_TIMEFORMAT+&DTS_UPDOWN
 &DTS_APPCANPARSE+&DTS_LONGDATEFORMAT+&DTS_RIGHTALIGN+&DTS_SHOWNONE+&DTS_SHORTDATEFORMAT+&DTS_SHORTDATECENTURYFORMAT+&DTS_UPDOWN
 &DTS_APPCANPARSE+&DTS_LONGDATEFORMAT+&DTS_RIGHTALIGN+&DTS_SHOWNONE+&DTS_SHORTDATEFORMAT+&DTS_SHORTDATECENTURYFORMAT+&DTS_TIMEFORMAT
 0  0  0  0]

[SysDateTimePick32MustHaveBitTable:
 0
 0
 0
 0
 0
 0
 0
 0
 0  0  0  0]

[SysDateTimePick32StylesHelp:
 DTS_APPCANPARSEhelp    DTS_LONGDATEFORMAThelp  DTS_RIGHTALIGNhelp  DTS_SHOWNONEhelp
 DTS_SHORTDATEFORMAThelp DTS_SHORTDATECENTURYFORMAThelp  DTS_TIMEFORMAThelp DTS_UPDOWNhelp
 WS_BORDERhelp WS_TABSTOPhelp     WS_VSCROLLhelp  WS_HSCROLLhelp]

[DTS_APPCANPARSEhelp: "DTS_APPCANPARSE:

Allows the owner to parse user input and take necessary action.
It enables users to edit within the client area of the control when they press the F2 key.
The control sends DTN_USERSTRING notification messages when users are finished.", 0]

[DTS_LONGDATEFORMAThelp: "DTS_LONGDATEFORMAT:

Displays the date in long format.
The default format string for this style is defined by LOCALE_SLONGDATEFORMAT, which produces output like 'Friday, April 19, 1996'.", 0]

[DTS_RIGHTALIGNhelp: "DTS_RIGHTALIGN:

The drop-down month calendar will be right-aligned with the control instead of left-aligned, which is the default.", 0]

[DTS_SHOWNONEhelp: "DTS_SHOWNONE:

It is possible to have no date currently selected in the control.
With this style, the control displays a check box that users can check once they have entered or selected a date.
Until this check box is checked, the application will not be able to retrieve the date from the control because, in essence, the control has no date.
This state can be set with the DTM_SETSYSTEMTIME message or queried with the DTM_GETSYSTEMTIME message.", 0]

[DTS_SHORTDATEFORMAThelp: "DTS_SHORTDATEFORMAT:

Displays the date in short format.
The default format string for this style is defined by LOCALE_SSHORTDATE, which produces output like '4/19/96'.", 0]

[DTS_SHORTDATECENTURYFORMAThelp: "DTS_SHORTDATECENTURYFORMAT:

Version 5.80. Similar to the DTS_SHORTDATEFORMAT style, except the year is a four-digit field.
The default format string for this style is based on LOCALE_SSHORTDATE. The output looks like: '4/19/1996'.", 0]

[DTS_TIMEFORMAThelp: "DTS_TIMEFORMAT:

Displays the time. The default format string for this style is defined by LOCALE_STIMEFORMAT, which produces output like '5:31:42 PM'.", 0]

[DTS_UPDOWNhelp: "DTS_UPDOWN:

Places an up-down control to the right of the DTP control to modify date-time values.
This style can be used in place of the drop-down month calendar, which is the default style.", 0]

____________________________________

; SysIPAddress32 . No ipaddress style exists.. we must set the minimum of WS_CHILD.

[SysIPAddress32CheckingMask:
 0
 0  0  0  0]

[SysIPAddress32TextTable: B$
 'WS_CHILD', 0
 'WS_BORDER', 0      'WS_TABSTOP', 0    'WS_VSCROLL' 0   'WS_HSCROLL' 0 0]


[SysIPAddress32BitTable:
 &WS_CHILD
 &WS_BORDER &WS_TABSTOP   &WS_VSCROLL   &WS_HSCROLL]

[SysIPAddress32ExcludeBitTable:
 0
 0  0  0  0]


[SysIPAddress32MustHaveBitTable:
 0
 0  0  0  0]

[SysIPAddress32StylesHelp:
 WS_CHILDhelp
 WS_BORDERhelp WS_TABSTOPhelp     WS_VSCROLLhelp  WS_HSCROLLhelp]

____________________________________

; SysPager

[SysPagerCheckingMask:
 0
 0
 0
 0
 0
 0  0  0  0]

[SysPagerTextTable: B$
 'PGS_AUTOSCROLL', 0
 'PGS_DRAGNDROP', 0
 'PGS_HORZ', 0
 'PGS_VERT', 0

 'WS_CHILD', 0
 'WS_BORDER', 0      'WS_TABSTOP', 0    'WS_VSCROLL' 0   'WS_HSCROLL' 0 0]


[SysPagerBitTable:
 &PGS_AUTOSCROLL
 &PGS_DRAGNDROP
 &PGS_HORZ
 &PGS_VERT

 &WS_CHILD
 &WS_BORDER &WS_TABSTOP   &WS_VSCROLL   &WS_HSCROLL]

[SysPagerExcludeBitTable:
 0
 0
 &PGS_VERT
 &PGS_HORZ
 0
 0  0  0  0]


[SysPagerMustHaveBitTable:
 0
 0
 0
 0
 0
 0  0  0  0]

[SysPagerStylesHelp:
 PGS_AUTOSCROLLhelp
 PGS_DRAGNDROPhelp
 PGS_HORZhelp
 PGS_VERThelp

 WS_CHILDhelp
 WS_BORDERhelp WS_TABSTOPhelp     WS_VSCROLLhelp  WS_HSCROLLhelp]

[PGS_AUTOSCROLLhelp: "PGS_AUTOSCROLL:

The pager control will scroll when the user hovers the mouse over one of the scroll buttons.", 0]

[PGS_DRAGNDROPhelp: "PGS_DRAGNDROP:

The contained window can be a drag-and-drop target.
The pager control will automatically scroll if an item is dragged from outside the pager over one of the scroll buttons.", 0]

[PGS_HORZhelp: "PGS_HORZ:

Creates a pager control that can be scrolled horizontally.
This style and the PGS_VERT style are mutually exclusive and cannot be combined.", 0]

[PGS_VERThelp: "PGS_VERT:

Creates a pager control that can be scrolled vertically.
This is the default direction if no direction style is specified.
This style and the PGS_HORZ style are mutually exclusive and cannot be combined.", 0]

____________________________________

; SysLink

; Guga note:
; missing the &ICC_LINK_CLASS ? . The dialog is not showing.
; InitDialogEdition:

[SysLinkCheckingMask:
 ;0  0  0
 0  0
 0  0  0  0]

[SysLinkTextTable: B$
; 'LIS_FOCUSED', 0  'LIS_ENABLED', 0   'LIS_VISITED', 0
 'WS_VISIBLE', 0    'WS_CHILD', 0
 'WS_BORDER', 0      'WS_TABSTOP', 0    'WS_VSCROLL' 0   'WS_HSCROLL' 0 0]


[SysLinkBitTable:
 ;&LIS_FOCUSED   &LIS_ENABLED   &LIS_VISITED
 &WS_VISIBLE    &WS_CHILD
 &WS_BORDER &WS_TABSTOP   &WS_VSCROLL   &WS_HSCROLL]

[SysLinkExcludeBitTable:
 ;0  0   0
 0  0
 0  0  0  0]


[SysLinkMustHaveBitTable:
 ;0  0   0
 0  0
 0  0  0  0]

[SysLinkStylesHelp:
 ;LIS_FOCUSEDhelp     LIS_ENABLEDhelp     LIS_VISITEDhelp
 WS_VISIBLEhelp WS_CHILDhelp
 WS_BORDERhelp WS_TABSTOPhelp     WS_VSCROLLhelp  WS_HSCROLLhelp]

[LIS_FOCUSEDhelp: "LIS_FOCUSED:

The link is surrounded by a dashed box. Pressing ENTER launches the link.", 0]

[LIS_ENABLEDhelp: "LIS_ENABLED:

 The link is displayed in blue or purple text, depending on LIS_VISITED. Clicking the link launches it.", 0]

[LIS_VISITEDhelp: "LIS_VISITED:
 
 The link is displayed in purple text. The user has already visited the URL represented by the link.", 0]
____________________________________

[QuestionMark: B$ '?' 0]
; General routine for showing the checkboxes under the main edition:

SSCkeckBoxes:
    mov eax 170, ebx 0

    .While B$esi > 0
        push eax, ebx, esi
            call 'User32.CreateWindowExA' 0, ButtonClassName, esi,
                           &WS_CHILD__&WS_VISIBLE__&BS_AUTOCHECKBOX,
                           16, eax, 140, 10, D$DialogEditorHandle, 0, D$hInstance, 0
            pop esi, ebx | push ebx, esi
            mov D$DialogControlsHandles+ebx eax
            call 'User32.SendMessageA' eax &WM_SETFONT D$MyFontHandle &TRUE
        pop esi, ebx, eax

        push eax, ebx, esi
          ; This is the little Style [?] Buttons:
            call 'User32.CreateWindowExA' 0, ButtonClassName, QuestionMark,
                           &WS_CHILD__&WS_VISIBLE,
                           2, eax, 12, 12, D$DialogEditorHandle, 0, D$hInstance, 0
            mov D$StyleHelpButtonsHandles+ebx eax
            call 'User32.SendMessageA' eax &WM_SETFONT D$MyFontHandle &TRUE
        pop edi
            mov al 0, ecx 200 | repne scasb | mov esi edi
        pop ebx, eax

        add eax 14 | add ebx 4
    .End_While
ret

____________________________________________________________________________________________

; Little Dialog for viewing the Styles Help:

[HelpDialog: D$ 0900C00C2 0   ;  090CC00C2 0 ; Style
 U$ 01 09 08 0DB 033        ; Dim 01 040 090
 0                          ;      no Menu
 0                          ; Class
 0                          ; Title
 08 'Helv' 0]               ; Font

[HelpDialogEdit: D$
 &WS_VISIBLE__&WS_CHILD__&ES_CENTER__&ES_MULTILINE__&ES_AUTOVSCROLL__&WS_VSCROLL__&WS_BORDER
 0

 U$ 0 0 0DB 033             ; Dim
 01                         ; ID
 0FFFF 081                  ; Class
 0                          ; Title
 0]                         ; No creation data

____________________________________________________________________________________________

Proc HelpDialogProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    .If D@Message = &WM_INITDIALOG
      ; lParam >>> InitValue >>> set Text...
        call 'USER32.SetDlgItemTextA' D@Adressee 1 D@lParam

    .Else_If D@Message = &WM_CTLCOLOREDIT
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        call 'USER32.SendMessageA' D@lParam &EM_SETSEL 0 0
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>>

    .Else_If D@Message = &WM_PARENTNOTIFY
        jmp L4>

    .Else_If D@Message = &WM_LBUTTONDOWN
        jmp L4>

    .Else_If D@Message = &WM_RBUTTONDOWN
        jmp L4>

    .Else_If D@Message = &WM_COMMAND
        mov eax D@wParam, ebx eax | shr eax 16 | and ebx 0FFFF

        If ebx = &IDCANCEL
            jmp L4>
        Else_If eax = &EN_CHANGE
            jmp L4>
        Else_If eax = &EN_UPDATE
L4:         call 'USER32.SetFocus' D$DialogListHandle
            jmp L5>
        Else_If eax = &EN_KILLFOCUS
L5:         call 'User32.EndDialog' D@Adressee 0
        End_If

    .Else
L8:     popad | mov eax &FALSE | jmp L9>
    .End_If

    popad | mov eax &TRUE

L9: EndP


[ShowSetOfCheckBoxes | mov esi #1 | call SSCkeckBoxes]

[CCFstring: B$
"

  Style settings depend on what Class you choose    
  (line 4 of each control).

  Set the Class first

  ", 0

    CCFtitle: "Arghhhhhh!!!!... " 0]


ControlClassFirst:
    call 'USER32.MessageBoxA' D$hwnd, CCFstring, CCFtitle, &MB_SYSTEMMODAL
ret

; from line pointed by user, searches what class and return in edi:ebx
; adress_of_table: index_of_string:

ShowControlStyleControl:
    push D$DialogListIndex
       add D$DialogListIndex 3 | call SearchWhatControlClass

       ..If edi = ControlClassByNumber
            If ebx = 0      | ShowSetOfCheckBoxes ButtonTextTable
            Else_If ebx = 1 | ShowSetOfCheckBoxes EditTextTable
            Else_If ebx = 2 | ShowSetOfCheckBoxes StaticTextTable
            Else_If ebx = 3 | ShowSetOfCheckBoxes ListTextTable
            Else_If ebx = 4 | ShowSetOfCheckBoxes ScrollTextTable
            Else_If ebx = 5 | ShowSetOfCheckBoxes ComboTextTable
            Else
                call ControlClassFirst
            End_If
       ..Else                                                   ; (edi = ControlClassByNames)
            .If ebx = 0      | ShowSetOfCheckBoxes UpDownTextTable
            .Else_If ebx = 1 | ShowSetOfCheckBoxes ProgressTextTable
            .Else_If ebx = 2 | ShowSetOfCheckBoxes TrackTextTable
            .Else_If ebx = 3 | ShowSetOfCheckBoxes TreeTextTable
            .Else_If ebx = 4 | ShowSetOfCheckBoxes TabTextTable
            .Else_If ebx = 5 | ShowSetOfCheckBoxes ListViewTextTable
            .Else_If ebx = 6 | ShowSetOfCheckBoxes ToolBarTextTable
            .Else_If ebx = 7 | ShowSetOfCheckBoxes RichEdit20aTextTable
            .Else_If ebx = 8 | ShowSetOfCheckBoxes SysHeader32TextTable
            .Else_If ebx = 9 | ShowSetOfCheckBoxes ReBarWindow32TextTable
            .Else_If ebx = 10 | ShowSetOfCheckBoxes Tooltips_class32TextTable
            .Else_If ebx = 11 | ShowSetOfCheckBoxes msctls_statusbar32TextTable
            .Else_If ebx = 12 | ShowSetOfCheckBoxes msctls_hotkey32TextTable
            .Else_If ebx = 13 | ShowSetOfCheckBoxes ComboBoxEx32TextTable
            .Else_If ebx = 14 | ShowSetOfCheckBoxes SysAnimate32TextTable
            .Else_If ebx = 15 | ShowSetOfCheckBoxes SysMonthCal32TextTable
            .Else_If ebx = 16 | ShowSetOfCheckBoxes SysDateTimePick32TextTable
            .Else_If ebx = 17 | ShowSetOfCheckBoxes SysIPAddress32TextTable
            .Else_If ebx = 18 | ShowSetOfCheckBoxes SysPagerTextTable
            .Else_If ebx = 19 | ShowSetOfCheckBoxes SysLinkTextTable
            .End_If
       ..End_If

    pop D$DialogListIndex
ret

[ID_Message: "==== Set the ID first ====





==== Mouse Edition ====


    Move: Left button.

    Resize: Right Button.", 0]

ShowIDcontrols:
    call SearchDialogLine | mov esi edi | call TranslateDialogHexa
    push ebx
        call 'USER32.CreateWindowExA' 0, EditClass, 0,
             &WS_CHILD+&WS_VISIBLE+&WS_BORDER+&ES_NUMBER+&ES_RIGHT+&ES_MULTILINE,
             80, 200, 45, 20, D$DialogEditorHandle, 0, D$hInstance, 0
        mov D$DialogControlsHandles eax
        call 'User32.GetDlgCtrlID' eax
    pop ebx

    call 'USER32.SetDlgItemInt' D$DialogEditorHandle, eax, ebx, &FALSE

    call 'USER32.CreateWindowExA' 0, EditClass, 0,
             &WS_CHILD+&WS_VISIBLE+&ES_MULTILINE+&ES_READONLY,
             4, 250, 140, 200, D$DialogEditorHandle, 0, D$hInstance, 0
    mov D$DialogControlsHandles+4 eax
    call 'USER32.SendMessageA' eax, &WM_SETTEXT, 0, ID_Message
    call 'USER32.SendMessageA' D$DialogControlsHandles+4, &WM_SETFONT, D$MyFontHandle, &TRUE

    call 'USER32.SetFocus' D$DialogControlsHandles
    call 'USER32.SendMessageA' D$DialogControlsHandles ,&EM_SETSEL, 0, 0-1
ret


[ControlClassByNumber: B$ 'Button' 0,  'Edit control' 0,  'Static Control' 0,  'ListBox' 0
                          'ScrollBar' 0,  'ComboBox' 0 0]
;[D_button 080  D_Edit 081  D_Static 082  D_ListBox 083  D_ScrollBar 084  D_ComboBox 085]

[ControlClassByNames: B$ 'msctls_updown32' 0,
                         'msctls_progress32' 0,
                         'msctls_trackbar32' 0,
                         'SysTreeView32' 0,
                         'SysTabControl32' 0,
                         'SysListView32' 0,
                         'ToolbarWindow32' 0,
                         'RichEdit20A' 0,
                         'SysHeader32' 0,
                         'ReBarWindow32' 0,
                         'tooltips_class32' 0,
                         'msctls_statusbar32' 0,
                         'msctls_hotkey32' 0,
                         'ComboBoxEx32' 0,
                         'SysAnimate32' 0,
                         'SysMonthCal32' 0,
                         'SysDateTimePick32' 0,
                         'SysIPAddress32' 0,
                         'SysPager' 0,
                         'SysLink' 0 0]
[ActualClassName: ? #10]

; From line pointed by user, searches what class and return in edi:ebx
; adress_of_table: index_of_string. ebx value is 0 to 5, edi either "ControlClassByNumber"
; or "ControlClassByNumber" (6 classes 'by number', 6 classes 'by name'):

SearchWhatControlClass:
    call SearchDialogLine
    ..If D$edi = 'FFFF'
        mov esi edi | add esi 5 | call TranslateDialogHexa  ; > ebx = 080 / 081 / ...
        sub ebx 080 | mov edi ControlClassByNumber          ; > ebx = 0 / 1 / 2...
    ..Else
        mov eax D$edi+8
        .If D$edi+8 = 'updo'         ; msctls_updown32
            mov ebx 0
        .Else_If D$edi+8 = 'prog'    ; msctls_progress32
            mov ebx 1
        .Else_If D$edi+8 = 'trac'    ; msctls_trackbar32
            mov ebx 2
        .Else_If D$edi+4 = 'Tree'    ; SysTreeView32
            mov ebx 3
        .Else_If D$edi+4 = 'List'    ; SysListView32
            mov ebx 5
        .Else_If D$edi+8 = 'ontr'    ; SysTabControl32
            mov ebx 4
        .Else_If D$edi+1 = 'Tool'    ; ToolbarWindow32
            mov ebx 6
        .Else_If D$edi+8 = 't20A'    ; RichEdit20a
            mov ebx 7
        .Else_If D$edi+1 = 'SysH'    ; SysHeader32
            mov ebx 8
        .Else_If D$edi+1 = 'ReBa'   ; ReBarWindow32
            mov ebx 9
        .Else_If D$edi+5 = 'tips'  ;tooltips_class32
            mov ebx 10
        .Else_If D$edi+8 = 'stat' ; msctls_statusbar32
            mov ebx 11
        .Else_If D$edi+8 = 'hotk'; msctls_hotkey32
            mov ebx 12
        .Else_If D$edi+1 = 'Comb' ;ComboBoxEx32
            mov ebx 13
        .Else_If D$edi+1 = 'SysA'; SysAnimate32
            mov ebx 14
        .Else_If D$edi+1 = 'SysM' ;SysMonthCal32
            mov ebx 15
        .Else_If D$edi+1 = 'SysD' ;SysDateTimePick32
            mov ebx 16
        .Else_If D$edi+1 = 'SysI' ;SysIPAddress32
            mov ebx 17
        .Else_If D$edi+1 = 'SysP'  ;SysPager
            mov ebx 18
        .Else_If D$edi+1 = 'SysL'  ; SysLink
            mov ebx 19
        .End_If

      mov edi ControlClassByNames
    ..End_If
ret


ShowClassControls:
    call 'User32.CreateWindowExA'  0, ComboClass, 0,
&WS_CHILD+&WS_VISIBLE+&WS_BORDER+&CBS_HASSTRINGS+&CBS_AUTOHSCROLL+&CBS_DROPDOWNLIST+&WS_VSCROLL+&ES_AUTOVSCROLL,
                                  2, 200, 145, 320, D$DialogEditorHandle, 0, D$hInstance, 0
    mov D$DialogControlsHandles eax

    ; Copy data font text (without quotes and comments) in TitleEditText:

    call SearchWhatControlClass

    mov al 0, ecx 0FFFF
    While ebx > 0                       ; setting edi > start of whatever class
        repne scasb | dec ebx           ; name, either by number or by name
    End_While
    mov esi edi, ecx 200 , al 0
    mov edi ActualClassName

L0: lodsb | stosb | cmp al 0 | ja L0<   ; copying actual name for next 'CB_SELECTSTRING'

    mov edi ControlClassByNumber        ; build list name from class by numbers:
    While B$edi > 0
        push edi
            call 'User32.SendMessageA' D$DialogControlsHandles &CB_ADDSTRING 0  edi
        pop edi
        mov al 0, ecx 200 | repne scasb
    End_While

    mov edi ControlClassByNames         ; build list name from class by names:
    While B$edi > 0
        push edi
            call 'User32.SendMessageA' D$DialogControlsHandles &CB_ADDSTRING 0  edi
        pop edi
        mov al 0, ecx 200 | repne scasb
    End_While

  ; setting actual choice in edit control of ComboBox:
    call 'User32.SendMessageA' D$DialogControlsHandles &CB_SELECTSTRING  0  ActualClassName
ret
____________________________________________________________________________________

; used by many 'user modifications' writting inside the edited template:

SearchDialogLine:
    mov ecx MaxTemplateText, edi D$NewDialogTemplateText, ebx 0, al 0

    While ebx < D$DialogListIndex
        repne scasb | inc ebx
    End_While
ret


NoDialogMenu:
    call 'USER32.MessageBoxA', 0, {'There is no Menu in this Dialog', 0},
                              {' Dialog Menu', 0}, &MB_SYSTEMMODAL
ret


; At same time: reset the table of controls handles and close these controls:

KillPreviousDialogControls:
    mov esi DialogControlsHandles
    While D$esi > 0
        lodsd | mov D$esi-4 0
        push esi
            call 'USER32.DestroyWindow' eax
        pop esi
    End_While

    mov esi StyleHelpButtonsHandles
    While D$esi > 0
        lodsd | mov D$esi-4 0
        push esi
            call 'USER32.DestroyWindow' eax
        pop esi
    End_While
ret

;;
;[NewMenuForDialog: "
;    Do you want to create a new menu?    
;     ", 0]

OldAddMenuToDialog:
    mov esi MenuList

   ..If D$esi = 0                               ; no Menu:
        call 'USER32.MessageBoxA'  0  NewMenuForDialog  argh,
                                &MB_SYSTEMMODAL+&MB_ICONQUESTION+&MB_YESNO
        If eax = &IDYES
            call NewMenu
            mov eax D$MenuListPtr               ; either 0 or ID
        Else
            mov eax 0
        End_If
   ..Else                                       ; menu(s) exist in rsrc:
        call 'USER32.MessageBoxA'  0  NewMenuForDialog  argh,
                                &MB_SYSTEMMODAL+&MB_ICONQUESTION+&MB_YESNO
        .If eax = &IDYES
            call NewMenu | mov D$ActualMenutestID 0
            mov esi D$MenuListPtr
            If D$esi = 0
                mov eax 0
            Else
                mov eax D$MenuListPtr
            End_If
        .Else
            mov D$MenuListPtr MenuList,  B$UserTellWhatMenu &FALSE
            While B$UserTellWhatMenu = &FALSE   ; even if only 1 menu because we do
                call WhatMenu                   ; not set here the true user menu ID but
            End_While                           ; intead the 'D$ActualMenutestID'
            If D$MenuListPtr = 0
                mov eax 0
            Else
                mov eax D$MenuListPtr
            End_If
        .End_If
   ..End_If

   ; now, eax = Menu ID or 0.
   .If eax = 0
        mov D$ActualMenutestID 0, D$DialogMenuTrueID 0
   .Else
        move D$DialogMenuTrueID D$eax
        If D$DialogMenuTrueID <> 0              ; happends if user abort menu edition
            add eax 4 | call 'User32.LoadMenuIndirectA' D$eax ; menu Id (from resources)
            mov D$ActualMenutestID eax
            call SearchDialogLine
            mov eax 'FFFF' | stosd | mov al ' ' | stosb
            mov ebx D$DialogMenuTrueID
            call TranslateDialogText4 | mov al ' ' | stosb | mov ax '; ' | stosw
            call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
        End_If
   .End_If
ret
;;

AddMenuToDialog:
    call 'USER32.DialogBoxParamA' D$hinstance 31555 &NULL NewOrExistingMenuProc &NULL

    .If B$NewOrExistingMenuChoice = 6           ; New.
        call NewMenu | mov D$ActualMenutestID 0
        mov esi D$MenuListPtr
        If D$esi = 0
            mov eax 0
        Else
            mov eax D$MenuListPtr
        End_If

    .Else_If B$NewOrExistingMenuChoice = 5       ; Existing.
        mov D$MenuListPtr MenuList,  B$UserTellWhatMenu &FALSE
        While B$UserTellWhatMenu = &FALSE   ; even if only 1 menu because we do
            call WhatMenu                   ; not set here the true user menu ID but
        End_While                           ; intead the 'D$ActualMenutestID'
        If D$MenuListPtr = 0
            mov eax 0
        Else
            mov eax D$MenuListPtr
        End_If

    .End_If

 ; now, eax = Menu ID or 0.
   .If eax = 0
        mov D$ActualMenutestID 0, D$DialogMenuTrueID 0
   .Else
        move D$DialogMenuTrueID D$eax
        If D$DialogMenuTrueID <> 0              ; happends if user abort menu edition
            add eax 4 | call 'User32.LoadMenuIndirectA' D$eax ; menu Id (from resources)
            mov D$ActualMenutestID eax
            call SearchDialogLine
            mov eax 'FFFF' | stosd | mov al ' ' | stosb
            mov ebx D$DialogMenuTrueID
            call TranslateDialogText4 | mov al ' ' | stosb | mov ax '; ' | stosw
            call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
        End_If
   .End_If
ret


[NewOrExistingMenuChoice: ?]

Proc NewOrExistingMenuProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_INITDIALOG
      ; If no Menu >>> Disable the [Load Existing] Button:
        mov esi MenuList
        If D$esi = 0
            call 'User32.GetDlgItem' D@adressee, 5
            call 'User32.EnableWindow' eax &FALSE
        End_If

    ...Else_If D@Message = &WM_COMMAND
        mov eax D@wParam | and D@wParam 0FFFF | shr eax 16

        If D@wParam = &IDCANCEL
            mov B$NewOrExistingMenuChoice 0
            call 'User32.DestroyWindow' D@Adressee

        Else_If D@wParam = 5            ; Existing.
            mov B$NewOrExistingMenuChoice 5
            call 'User32.DestroyWindow' D@Adressee

        Else_If D@wParam = 6            ; New.
            mov B$NewOrExistingMenuChoice 6
            call 'User32.DestroyWindow' D@Adressee

        Else_If D@wParam = &IDHELP
            call Help, B_U_AsmName, DialogHelp, ContextHlpMessage

        End_If

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE
L9: EndP
____________________________________________________________________________________________



EditDialogMenu:
    push D$DialogMenuTrueID
        mov esi MenuList, eax D$DialogMenuTrueID
        While D$esi <> eax
            add esi 12
        End_While
        mov D$MenuListPtr esi | call ReEditExistingMenu
    pop eax

    If D$uMenu_ID <> eax
      move D$DialogMenuTrueID D$uMenu_ID
    End_If

    mov eax D$MenuListPtr | add eax 4          ; ptr to menu data
    call 'User32.LoadMenuIndirectA' D$eax | mov D$ActualMenutestID eax
    call SearchDialogLine
    mov eax 'FFFF' | stosd | mov al ' ' | stosb
    mov ebx D$DialogMenuTrueID
    call TranslateDialogText4 | mov al ' ' | stosb | mov ax '; ' | stosw
    call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
ret

______________________________________________________________________________________
;;
 Setting of the wished controls under main list box for editing user dialog. (User
 have click on some item >>> which one >>> what controls to be set). As these controls
 may be many or few (or none), i choose a dynamic storage for the handles, whatever
 they are: One simgle table ("DialogControlsHandles") is used to store all the handles
 as they come, without any visible symbolic name for further identification. To know
 what user is doing, we use the index (selected item) of the main list. In some cases
 (Dialog Callback checking), we scan the number of handles written in the List.
;;

[DialogListIndex: ?           ; true 0 based line number in main list
 ControlIndex: ?]             ; 0 based index of line in one control

[NoDialogControl | mov D$DialogListIndex 0_FFFF_FFFF | mov D$ControlIndex 0_FFFF_FFFF]

[EditingMenuFromDialog: ?]

SetDialogTools:
    call KillPreviousDialogControls
    NoDialogControl
    call 'User32.SendMessageA' D$DialogListHandle, &LB_GETCURSEL, eax, 0
    mov D$DialogListIndex eax

    ..If eax < 6
        mov D$ControlIndex eax
        .If eax = 0
            call ShowDialogStyleControl | call ShowDialogStyles
        .Else_If eax = 1
            mov D$DimIsForDialogWindow &TRUE | call ShowDimControls
        .Else_If eax = 2
            call SearchDialogLine
            If D$edi = 'FFFF'
                call EditDialogMenu
            Else
                call AddMenuToDialog
            End_If
        .Else_If eax = 3
            call ShowTitleControl          ; reuse for dialog class
         ;  NoDialogControl  ; not yet
        .Else_If eax = 3
            NoDialogControl  ; not yet
        .Else_If eax = 4
            call ShowTitleControl
        .Else_If eax = 5
            call ShowFontControls
        .End_If
    ..Else_If eax = 6
        NoDialogControl    ; separator
    ..Else_If eax < D$LastDialogListItem
L1:     sub eax 7 | cmp eax 7 | jae L1<
        mov D$ControlIndex eax
        If eax = 0
            call ShowControlStyleControl | call ShowControlStyles
        Else_If eax = 1
            mov D$DimIsForDialogWindow &FALSE | call ShowDimControls
        Else_If eax = 2
            call ShowIDcontrols
        Else_If eax = 3
            call ShowClassControls
        Else_If eax = 4
            call ShowTitleControl
        Else_If eax = 5
            NoDialogControl   ; not yet
        End_If
    ..End_If
ret

____________________________________________________________________________________
____________________________________________________________________________________

; Showing user modifications result:
____________________________________________________________________________________
____________________________________________________________________________________


[NextTemplateLine | push edi | mov edi esi, al 0, ecx 200 | repne scasb
                    mov esi edi | pop edi]

[ControlNumberPtr: 0]            ; user doesn't have to set this record (before Dims)

; Translate the text template (visible in Editor Edit Control) into a Binary Template
; run by RosAsm (without the menu and the class, if any). (see 'DialogMenuComment')
;
; 'FromBinToTextTemplate' doesn't do the reverse operation...

FromTextToBinTemplate:
    mov esi D$NewDialogTemplateText, edi D$EditedDialogBoxData

    add esi 3 | call TranslateDialogHexa | mov eax ebx | stosd  ; Style
    mov eax 0 | stosd | NextTemplateLine | add esi 3            ; extended style
    mov D$ControlNumberPtr edi                                  ; used down there to
    call TranslateDialogHexa | mov eax 0 | stosw                ; set dummy control number
    call TranslateDialogHexa | mov eax ebx | stosw              ; X pos
    call TranslateDialogHexa | mov eax ebx | stosw              ; Y pos
    call TranslateDialogHexa | mov eax ebx | stosw              ; width
    call TranslateDialogHexa | mov eax ebx | stosw              ; hight
    NextTemplateLine | call TranslateDialogHexa
  ; Why the commented out lines? >>> DialogMenuComment
  ;  If ebx = 0
      mov ax 0 | stosw                                          ; no menu
  ;  Else
  ;    mov eax ebx | stosw                                      ; 0FFFF in ebx > menu
  ;    call TranslateDialogHexa
  ;    mov eax ebx | stosw                                      ; menu ID
  ;  End_If
    NextTemplateLine | inc esi
    mov eax 0 | stosw                                           ; no class in edition
    mov al 0FF
    push edi
        mov edi ClassRecord
L0:     cmp B$esi '"' | je L1>
        cmp B$esi "'" | je L1>
            lodsb | stosb                                       ; preserve Class for savings
        jmp L0<
L1:     mov eax 0 | stosd                                       ; end mark at our string
    pop edi
    NextTemplateLine | inc esi | mov eax 0
L0: cmp B$esi '"' | je L1>
    cmp B$esi "'" | je L1>
        lodsb | stosw                                            ; title
    jmp L0<
L1: mov ax 0 | stosw |  NextTemplateLine
    call TranslateDialogHexa | mov eax ebx | stosw               ; font size
    inc esi | mov ax 0
L0: cmp B$esi '"' | je L1>
    cmp B$esi "'" | je L1>
        lodsb | stosw                                            ; font name
    jmp L0<
L1: mov ax 0 | stosw
    Test edi 00_11 | jz L1>                                      ; Dword aligned?
        stosw                                                    ; no > align!
L1: NextTemplateLine | NextTemplateLine                          ; + 1 blank line in text

    .While B$esi <> 255                                          ; Controls data:
        mov ebx D$ControlNumberPtr | inc W$ebx
        add esi 3
        call TranslateDialogHexa | mov eax ebx | stosd           ; style
        mov eax 0 | stosd | NextTemplateLine | add esi 3         ; extended style
        call TranslateDialogHexa | mov eax ebx | stosw           ; X pos
        call TranslateDialogHexa | mov eax ebx | stosw           ; Y pos
        call TranslateDialogHexa | mov eax ebx | stosw           ; width
        call TranslateDialogHexa | mov eax ebx | stosw           ; hight
        NextTemplateLine
        call TranslateDialogHexa | mov eax ebx | stosw           ; ID
        NextTemplateLine
        If D$esi = 'FFFF'                                        ; class by number:
            mov ax 0FFFF | stosw | add  esi 5
            call TranslateDialogHexa | mov eax ebx | stosw       ; class
        Else
            inc esi | mov eax 0
L0:         cmp B$esi '"' | je L1>
            cmp B$esi "'" | je L1>
            lodsb | stosw
            jmp L0<
L1:         mov ax 0 | stosw
        End_If
        NextTemplateLine | inc esi | mov ax 0
L0:     cmp B$esi '"' | je L1>
        cmp B$esi "'" | je L1>
            lodsb | stosw                                       ; title
        jmp L0<
L1:     mov ax 0 | stosw                                        ; end mark
        NextTemplateLine | stosw                                ; no creation dat
        Test edi 00_11 | jz L1>                                 ; Dword aligned?
            stosw                                               ; no > align!
L1:     NextTemplateLine  | NextTemplateLine                    ; + 1 blank line in text

    .End_While
ret
______________________________________________________________________________________

; User have click some 'Style' CheckBox. Called by 'EditDialogBoxProc' with
;  buttons handles in ecx, tables index in ebx

[ClickedCheckBoxHandle: ?  FlagCheck: ?]

WriteStyle:
    mov eax D$DialogListIndex, D$ClickedCheckBoxHandle ecx

    ...If eax = D$ControlIndex              ; >>> this is for Dialog Style:
        move D$CheckMust D$DialogMustHaveBitTable+ebx
        move D$CheckExclude D$DialogExcludeBitTable+ebx
        move D$CheckingMask DialogCheckingMask
        move D$CheckBit D$DialogBitTable+ebx
        mov esi DialogBitTable

    ...Else                                  ; >>> this is for Control Style:
        push ebx                                ; table indice (0 / 4 / 8 / 12...)
            add D$DialogListIndex 3
            call SearchWhatControlClass             ; ebx = indice of class (0 / 1 / 2 / 3...)
            sub D$DialogListIndex 3
        pop eax                                       ; table indice in eax
        ..If edi = ControlClassByNumber               ; >>> class by Number
            .If ebx = 0
                move D$CheckMust D$ButtonMustHaveBitTable+eax      ; Button
                move D$CheckExclude D$ButtonExcludeBitTable+eax
                move D$CheckingMask ButtonCheckingMask
                move D$CheckBit D$ButtonBitTable+eax
                mov esi ButtonBitTable
            .Else_If ebx = 1
                move D$CheckMust D$EditMustHaveBitTable+eax        ; Edit control
                move D$CheckExclude D$EditExcludeBitTable+eax
                move D$CheckingMask EditCheckingMask
                move D$CheckBit D$EditBitTable+eax
                mov esi EditBitTable
            .Else_If ebx = 2
                move D$CheckMust D$StaticMustHaveBitTable+eax      ; Static Control
                move D$CheckExclude D$StaticExcludeBitTable+eax
                move D$CheckingMask StaticCheckingMask
                move D$CheckBit D$StaticBitTable+eax
                mov esi StaticBitTable
            .Else_If ebx = 3
                move D$CheckMust D$ListMustHaveBitTable+eax        ; ListBox
                move D$CheckExclude D$ListExcludeBitTable+eax
                move D$CheckingMask ListCheckingMask
                move D$CheckBit D$ListBitTable+eax
                mov esi ListBitTable
            .Else_If ebx = 4
                move D$CheckMust D$ScrollMustHaveBitTable+eax      ; ScrollBar
                move D$CheckExclude D$ScrollExcludeBitTable+eax
                move D$CheckingMask ScrollCheckingMask
                move D$CheckBit D$ScrollBitTable+eax
                mov esi ScrollBitTable
            .Else_If ebx = 5
                move D$CheckMust D$ComboMustHaveBitTable+eax       ; ComboBox
                move D$CheckExclude D$ComboExcludeBitTable+eax
                move D$CheckingMask ComboCheckingMask
                move D$CheckBit D$ComboBitTable+eax
                mov esi ComboBitTable
            .End_If
        ..Else                                         ; >>> class by Name
            .If ebx = 0
                move D$CheckMust D$UpDownMustHaveBitTable+eax      ; msctls_updown32
                move D$CheckExclude D$UpDownExcludeBitTable+eax
                move D$CheckingMask UpDownCheckingMask
                move D$CheckBit D$UpDownBitTable+eax
                mov esi UpDownBitTable
            .Else_If ebx = 1
                ret                                    ; msctls_progress32 (no controls)
            .Else_If ebx = 2
                move D$CheckMust D$TrackMustHaveBitTable+eax       ; msctls_trackbar32
                move D$CheckExclude D$TrackExcludeBitTable+eax
                move D$CheckingMask TrackCheckingMask
                move D$CheckBit D$TrackBitTable+eax
                mov esi TrackBitTable
            .Else_If ebx = 3
                move D$CheckMust D$TreeMustHaveBitTable+eax        ; SysTreeView32
                move D$CheckExclude D$TreeExcludeBitTable+eax
                move D$CheckingMask TreeCheckingMask
                move D$CheckBit D$TreeBitTable+eax
                mov esi TreeBitTable
            .Else_If ebx = 4
                move D$CheckMust D$TabMustHaveBitTable+eax         ; SysTabControl32
                move D$CheckExclude D$TabExcludeBitTable+eax
                move D$CheckingMask TabCheckingMask
                move D$CheckBit D$TabBitTable+eax
                mov esi TabBitTable
            .Else_If ebx = 5
                move D$CheckMust D$ListViewMustHaveBitTable+eax    ; SysListView32
                move D$CheckExclude D$ListViewExcludeBitTable+eax
                move D$CheckingMask ListViewCheckingMask
                move D$CheckBit D$ListViewBitTable+eax
                mov esi ListViewBitTable
            .Else_If ebx = 6
                move D$CheckMust D$ToolBarMustHaveBitTable+eax    ; ToolbarWindow32
                move D$CheckExclude D$ToolBarExcludeBitTable+eax
                move D$CheckingMask ToolBarCheckingMask
                move D$CheckBit D$ToolBarBitTable+eax
                mov esi ToolBarBitTable

            .Else_If ebx = 7
                move D$CheckMust D$RichEdit20aMustHaveBitTable+eax    ; RichEdit20a
                move D$CheckExclude D$RichEdit20aExcludeBitTable+eax
                move D$CheckingMask RichEdit20aCheckingMask
                move D$CheckBit D$RichEdit20aBitTable+eax
                mov esi RichEdit20aBitTable

            .Else_If ebx = 8
                move D$CheckMust D$SysHeader32MustHaveBitTable+eax    ; SysHeader32
                move D$CheckExclude D$SysHeader32ExcludeBitTable+eax
                move D$CheckingMask SysHeader32CheckingMask
                move D$CheckBit D$SysHeader32BitTable+eax
                mov esi SysHeader32BitTable

            .Else_If ebx = 9
                move D$CheckMust D$ReBarWindow32MustHaveBitTable+eax    ; ReBarWindow32
                move D$CheckExclude D$ReBarWindow32ExcludeBitTable+eax
                move D$CheckingMask ReBarWindow32CheckingMask
                move D$CheckBit D$ReBarWindow32BitTable+eax
                mov esi ReBarWindow32BitTable

            .Else_If ebx = 10
                move D$CheckMust D$tooltips_class32MustHaveBitTable+eax    ; tooltips_class32
                move D$CheckExclude D$tooltips_class32ExcludeBitTable+eax
                move D$CheckingMask tooltips_class32CheckingMask
                move D$CheckBit D$tooltips_class32BitTable+eax
                mov esi tooltips_class32BitTable

            .Else_If ebx = 11
                move D$CheckMust D$msctls_statusbar32MustHaveBitTable+eax    ; msctls_statusbar32
                move D$CheckExclude D$msctls_statusbar32ExcludeBitTable+eax
                move D$CheckingMask msctls_statusbar32CheckingMask
                move D$CheckBit D$msctls_statusbar32BitTable+eax
                mov esi msctls_statusbar32BitTable

            .Else_If ebx = 12
                move D$CheckMust D$msctls_hotkey32MustHaveBitTable+eax    ; msctls_hotkey32
                move D$CheckExclude D$msctls_hotkey32ExcludeBitTable+eax
                move D$CheckingMask msctls_hotkey32CheckingMask
                move D$CheckBit D$msctls_hotkey32BitTable+eax
                mov esi msctls_hotkey32BitTable

            .Else_If ebx = 13
                move D$CheckMust D$ComboBoxEx32MustHaveBitTable+eax    ; ComboBoxEx32
                move D$CheckExclude D$ComboBoxEx32ExcludeBitTable+eax
                move D$CheckingMask ComboBoxEx32CheckingMask
                move D$CheckBit D$ComboBoxEx32BitTable+eax
                mov esi ComboBoxEx32BitTable

            .Else_If ebx = 14
                move D$CheckMust D$SysAnimate32MustHaveBitTable+eax    ; SysAnimate32
                move D$CheckExclude D$SysAnimate32ExcludeBitTable+eax
                move D$CheckingMask SysAnimate32CheckingMask
                move D$CheckBit D$SysAnimate32BitTable+eax
                mov esi SysAnimate32BitTable

            .Else_If ebx = 15
                move D$CheckMust D$SysMonthCal32MustHaveBitTable+eax    ; SysMonthCal32
                move D$CheckExclude D$SysMonthCal32ExcludeBitTable+eax
                move D$CheckingMask SysMonthCal32CheckingMask
                move D$CheckBit D$SysMonthCal32BitTable+eax
                mov esi SysMonthCal32BitTable

            .Else_If ebx = 16
                move D$CheckMust D$SysDateTimePick32MustHaveBitTable+eax    ; SysDateTimePick32
                move D$CheckExclude D$SysDateTimePick32ExcludeBitTable+eax
                move D$CheckingMask SysDateTimePick32CheckingMask
                move D$CheckBit D$SysDateTimePick32BitTable+eax
                mov esi SysDateTimePick32BitTable

            .Else_If ebx = 17
                move D$CheckMust D$SysIPAddress32MustHaveBitTable+eax    ; SysIPAddress32
                move D$CheckExclude D$SysIPAddress32ExcludeBitTable+eax
                move D$CheckingMask SysIPAddress32CheckingMask
                move D$CheckBit D$SysIPAddress32BitTable+eax
                mov esi SysIPAddress32BitTable

            .Else_If ebx = 18
                move D$CheckMust D$SysPagerMustHaveBitTable+eax    ; SysPager
                move D$CheckExclude D$SysPagerExcludeBitTable+eax
                move D$CheckingMask SysPagerCheckingMask
                move D$CheckBit D$SysPagerBitTable+eax
                mov esi SysPagerBitTable

            .Else_If ebx = 19
                move D$CheckMust D$SysLinkMustHaveBitTable+eax    ; SysLink
                move D$CheckExclude D$SysLinkExcludeBitTable+eax
                move D$CheckingMask SysLinkCheckingMask
                move D$CheckBit D$SysLinkBitTable+eax
                mov esi SysLinkBitTable
            .End_If
        ..End_If

    ...End_If

    push esi
        call SearchDialogLine | add edi 3           ; edi > "NewDialogTemplateText": Style
        mov esi edi | call TranslateDialogHexa      ; Style value in ebx
    pop esi
;;
 Now: D$CheckBit = bit value of the clicked checkbox
      ebx            = previous value for style
      D$CheckExclude = Excluded Bits
      D$CheckMust    = Must Have Bits
      esi            = ptr to Bit table
      edi            = "NewDialogTemplateText" concerned line +3 ("D$ "xxxxxxxx)

 We take care of "required" / "exclude" bits only if we are setting the bits:
;;
    push esi, edi, ebx
        call 'User32.SendMessageA' D$ClickedCheckBoxHandle &BM_GETCHECK 0 0
        mov D$FlagCheck eax
    pop ebx, edi, esi


    On B$FlagCheck = &FALSE, jmp L1>                    ; Only if user is "checking"
        or ebx D$CheckExclude | xor ebx D$CheckExclude  ; excluded bit(s)
        or ebx D$CheckMust                              ; required bit(s)
L1: xor ebx D$CheckBit                                  ; new set bit

; or ebx &WS_THICKFRAME  (for my tests)

    mov D$CheckActual ebx
    pushad
        call TranslateDialogText8  ; write ebx (text) at "NewDialogTemplateText": Style
    popad

    call CheckControlStyles

    call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
ret

____________________________________________________________________________________________

; esi just found a valid [?] Help Butoon Handle:

ShowStyleInfo:
    .If D$CheckingMask = DialogCheckingMask
        mov eax DialogStylesHelp
    .Else_If D$CheckingMask = ButtonCheckingMask
        mov eax ButtonStylesHelp
    .Else_If D$CheckingMask = EditCheckingMask
        mov eax EditStylesHelp
    .Else_If D$CheckingMask = StaticCheckingMask
        mov eax StaticStylesHelp
    .Else_If D$CheckingMask = ListCheckingMask
        mov eax ListBoxStyles
    .Else_If D$CheckingMask = ScrollCheckingMask
        mov eax ScrollStylesHelp
    .Else_If D$CheckingMask = ComboCheckingMask
        mov eax ComboStylesHelp
    .Else_If D$CheckingMask = UpDownCheckingMask
        mov eax UpDownStylesHelp
    .Else_If D$CheckingMask = TrackCheckingMask
        mov eax TrackStylesHelp
    .Else_If D$CheckingMask = TreeCheckingMask
        mov eax TreeViewStylesHelp
    .Else_If D$CheckingMask = TabCheckingMask
        mov eax TabStylesHelp
    .Else_If D$CheckingMask = ListViewCheckingMask
        mov eax ListViewStylesHelp
    .Else_If D$CheckingMask = ToolBarCheckingMask
        mov eax ToolBarStylesHelp
    .Else_If D$CheckingMask = RichEdit20aCheckingMask
        mov eax RichEdit20aStylesHelp
    .Else_If D$CheckingMask = SysHeader32CheckingMask
        mov eax SysHeader32StylesHelp
    .Else_If D$CheckingMask = ReBarWindow32CheckingMask
        mov eax ReBarWindow32StylesHelp
    .Else_If D$CheckingMask = tooltips_class32CheckingMask
        mov eax tooltips_class32StylesHelp
    .Else_If D$CheckingMask = msctls_statusbar32CheckingMask
        mov eax msctls_statusbar32StylesHelp
    .Else_If D$CheckingMask = msctls_hotkey32CheckingMask
        mov eax msctls_hotkey32StylesHelp
    .Else_If D$CheckingMask = ComboBoxEx32CheckingMask
        mov eax ComboBoxEx32StylesHelp
    .Else_If D$CheckingMask = SysAnimate32CheckingMask
        mov eax SysAnimate32StylesHelp
    .Else_If D$CheckingMask = SysMonthCal32CheckingMask
        mov eax SysMonthCal32StylesHelp
    .Else_If D$CheckingMask = SysDateTimePick32CheckingMask
        mov eax SysDateTimePick32StylesHelp
    .Else_If D$CheckingMask = SysIPAddress32CheckingMask
        mov eax SysIPAddress32StylesHelp
    .Else_If D$CheckingMask = SysPagerCheckingMask
        mov eax SysPagerStylesHelp
    .Else_If D$CheckingMask = SysLinkCheckingMask
        mov eax SysLinkStylesHelp
    .End_If

    sub esi 4 | sub esi StyleHelpButtonsHandles | add esi eax

    call 'USER32.CreateDialogIndirectParamA' D$hinstance, HelpDialog, ecx,
                                             HelpDialogProc, D$esi

ret
____________________________________________________________________________________

; Called by next routine only (to suppress the class by number before wirting a new
; class by name. edi, ecx set by caller:

StripFFFF0080:
    mov B$edi '"' | inc edi
    push edi
        add edi 8                                   ; edi after 'FFFF 0080'
        push edi
            mov al 255 | repne scasb | mov ecx edi  ; edi > End of template
        pop esi
        sub ecx esi                                 ; how many char to move backward
    pop edi                                         ; esi > first char
    rep movsb
ret


[DefaultNumberClass: 'xxxx', 0]

WriteClass:
    call 'User32.SendMessageA' D$DialogControlsHandles, &CB_GETCURSEL, 0, 0 | mov ebx eax

    mov edx D$DialogListIndex, edi D$NewDialogTemplateText, al 0, ecx MaxTemplateText
    sub edx 3

L0: repne scasb | dec edx | jnz L0<                          ; to point to upper Style
    add edi 4 | mov B$edi-1 '5', al '0', ecx 7 | rep stosb   ; reset Style record to default
    mov edx 3, al 0, ecx 0FFFFFFFF
L0: repne scasb | dec edx | jnz L0<                          ; point to Class record

    ..If D$edi = 'FFFF'
        .If ebx < 6
            add edi 8 | mov B$edi '0' | add B$edi bl         ; new 'FFFF 008x' value
        .Else
          ; strip "text", make 9 chars room, copy 'FFFF 008x' value:
            push edi
                push ebx
                    call StripFFFF0080
                pop ebx
                sub ebx 6
                mov edi ControlClassByNames, ecx 0FFFF, al 0
                While ebx > 0
                    repne scasb | dec ebx
                End_While                                ; edi > choosen Class by name text
            pop esi
            inc esi                     ; "StripFFFF0080" have written first quote
            call ResetTemplateClass
        .End_If
    ..Else                              ; edi point to "msctls_...."
      ; Strip "text":
        push ebx, edi
            inc edi | call StripTemplateText
        pop edi, ebx
        .If ebx < 6
          ; make 9 chars room (including <" 0>, copy 'FFFF 008x' value):
            push ebx
                mov esi edi, edi DefaultNumberClass | call ResetTemplateClass
                sub edi 7 | mov D$edi 'FFFF', D$edi+4 ' 008'
            pop ebx
            add bl '0' | mov B$edi+8 bl, B$edi+9 ' '
        .Else
            push edi
                sub ebx 6
              ; make whished lenght room, copy new Class text
                mov edi ControlClassByNames, ecx 0FFFF, al 0
                While ebx > 0
                    repne scasb | dec ebx
                End_While
            pop esi
            inc esi
            call ResetTemplateClass
        .End_If
    ..End_If

    call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
ret
_________________________________________________________________________________

WriteFontSize:
    mov edi D$NewDialogTemplateText al 0, ecx MaxTemplateText
    repne scasb | repne scasb | repne scasb | repne scasb | repne scasb
    push edi
        call 'User32.SendMessageA' D$DialogControlsHandles+4  &CB_GETCURSEL  0  0
    pop edi
    push edi
        call 'User32.SendMessageA' D$DialogControlsHandles+4 &CB_GETLBTEXT eax edi
    pop edi
    mov B$edi+2 ' '
    call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
ret
_____________________________________________________________________________________

; 2 routines to replace some text inside template:

StripTemplateText:
    push edi
        mov al '"', ecx MaxTemplateText | repne scasb | dec edi ; edi > lasting '"'
        push edi
            mov al 255 | repne scasb                            ; edi > End of template
            mov ecx edi
        pop esi
        sub ecx esi                                    ; how many char to move backward
    pop edi                                                     ; esi > first char
    rep movsb
ret


ResetTemplateText:
    push edi
        push esi                                                ; > where to write
            mov al 0, ecx 120, ebx 120 | repne scasb
            sub ecx 120 | neg ecx | mov ebx ecx                 ; new string lenght
            mov edi D$NewDialogTemplateText, al 255, ecx MaxTemplateText
            repne scasb | mov esi edi | add edi ebx             ; edi, esi ready for room
        pop eax
        push eax
            mov ecx esi | sub ecx eax | dec edi
            std
                rep movsb                   ; make empty room
            cld
        pop edi
    pop esi                                 ; adress of new string

L0: lodsb | cmp al 0 | je L9>
    stosb | jmp L0<                         ; write new string

L9: mov al '"' | stosb
ret
______________________________________________________________________________________

ResetTemplateClass:
    push edi
        push esi                                                   ; > where to write
            mov al 0, ecx 120, ebx 120 | repne scasb
            sub ecx 120 | neg ecx | mov ebx ecx                    ; new string lenght
            add ebx 2                                              ; for ' 0'
            mov edi D$NewDialogTemplateText, al 255, ecx MaxTemplateText
            repne scasb | mov esi edi | add edi ebx                ; edi, esi ready for room
        pop eax
        push eax
            mov ecx esi | sub ecx eax | dec edi
            std
                rep movsb                ; make empty room
            cld
        pop edi
    pop esi                              ; adress of new string set in edi by caller.

L0: lodsb | cmp al 0 | je L9>
    stosb | jmp L0<                      ; write new string

L9: mov al '"' | stosb
    mov ax ' 0' | stosw
ret

__________________________________________________________________________________

[LBbuffer: ? #30] ;[LBbufferLen 120]

ClearLBbuffer:
    mov eax 0, ecx 30, edi LBbuffer | rep stosd
ret


WriteFontType:
    call ClearLBbuffer
    mov edi D$NewDialogTemplateText al 0, ecx MaxTemplateText
    repne scasb | repne scasb | repne scasb | repne scasb | repne scasb
    add edi 4
    push edi
        call StripTemplateText
        call 'User32.SendMessageA' D$DialogControlsHandles  &CB_GETCURSEL  0  0
        call 'User32.SendMessageA' D$DialogControlsHandles &CB_GETLBTEXT eax LBbuffer
    pop esi
    mov edi LBbuffer | call ResetTemplateText
    call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
ret
________________________________________________________________________________________
;;
 For some unknown reason, none of the usual working messages to retrieve text or
 value from an edit control (what work everywhere else in this source) doesn't
 work with these boxes. So i have to use "WM_GETTEXT" instead, translate it to Bin,
 then to hexa, then to hexa text !!!!!!!!............ These Edit boxes no not seam to
 have a valid ID. They are created by:

     call 'User32.CreateWindowExA'  0  EditClass  0,
             WS_CHILD+WS_VISIBLE+WS_BORDER+ES_NUMBER+ES_RIGHT+ES_MULTILINE,
             80 D$esi+4  45 20, D$EDBPadressee 0 D$hInstance 0

 ... just like any other ones...
;;

[DimIsForDialogWindow: ?] ; used as +0 / +1 (true / false) to jump over n (number of controls)

WriteDimOnly:
    push ecx                          ; edit control handle ( > edx )
        call 'User32.SendMessageA' ecx, &WM_GETTEXT, 0F, LBbuffer
    pop edx
    call SearchDialogLine           ; Edi is set there.
    mov esi DialogControlsHandles, ebx 1
    while D$esi <> edx | add esi 4 | inc ebx | End_While  ; search for what control
  ; 3 handles (text, edit, UpDown). So: 2 > 1   5 > 2   8 > 3   11 > 4
    shr ebx 1 | On ebx > 2, dec ebx
    add ebx D$DimIsForDialogWindow                       ; jump over n (number of controls)
    mov al ' '
    While ebx > 0 | repne scasb | dec ebx | End_While    ; edi > dim to overwrite
    push edi

      ; Translate decimal to binary (simplified version):
        mov eax 0, ecx 0, esi LBbuffer
L2:     mov cl B$esi | inc  esi              ; (eax used for result > no lodsb)
        cmp cl 0 | jbe  L9>
            mov edx 10 | mul edx | sub  ecx '0'
            add  eax ecx | jmp  L2<          ; >>> number in EAX
L9:         mov ebx eax
            add ebx D$ProposedUpDowmChange | mov D$ProposedUpDowmChange 0
      ; Store text hexa at "DimTempo":
        mov edi LBbuffer | call TranslateDialogText8 | mov al 0 | stosb
    pop edi
    mov eax '0000' | stosd | dec edi | mov esi LBbuffer
    While B$esi+1 > 0 | inc esi | End_While
    std | mov ecx 4
L0:     lodsb
        stosb | On esi < LBbuffer, jmp L9>
        loop L0<
L9: cld
ret

WriteDim:
    call WriteDimOnly
    call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
ret
__________________________________________________________________________________

WriteTitle:
    call SearchDialogLine | inc edi        ; points to Class record
    push edi
        call StripTemplateText
        call 'User32.GetDlgCtrlID' D$DialogControlsHandles
        call 'User32.GetDlgItemTextA' D$DialogEditorHandle eax LBbuffer 100
                                        ; fix limit (100) here
                                        ; (sendmessage for text limitation doesn't work)
    pop esi

    mov edi LBbuffer | call ResetTemplateText

    call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
ret
_____________________________________________________________________________________

WriteID:
    call SearchDialogLine

    push edi
      call 'User32.GetDlgCtrlID' D$DialogControlsHandles
      call 'User32.GetDlgItemInt' D$DialogEditorHandle eax  0  0
    pop edi

    mov ebx eax, ecx 4  | On eax > 0, mov W$PreviousControlID ax

L0: mov eax ebx | and eax 0_F000 | shr eax 12
    add al '0' | On al > '9', add al 7
    shl ebx 4
    stosb | loop L0<

    call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox
ret
____________________________________________________________________________________

[DelMessage:"

    To delete a control:

      Select any record in the control you want to delete.       
      Do not select a separator empty line.
      Do not select a Dialog box record.
    ", 0

 Wahoo: ' Whahooo!!!...', 0]

OutDelOneControl:
    call 'USER32.MessageBoxA' D$hwnd, DelMessage, Wahoo, &MB_SYSTEMMODAL
ret


DelOneControl:
    call 'User32.SendMessageA' D$DialogListHandle &LB_GETCURSEL eax 0
    mov D$DialogListIndex eax

    .If D$DialogListIndex < 7
        jmp OutDelOneControl

    .Else_If D$DialogListIndex > 0FFFF
        jmp OutDelOneControl

    .Else
        call SearchDialogLine
        On B$edi = 0, jmp OutDelOneControl

        mov al 0, ecx MaxTemplateText          ; edi > one record inside one control
        While B$edi > 0
            repne scasb
        End_While
        mov esi edi | sub edi 2                ; esi > end of control records
        std
            While B$edi > 0
                repne scasb
            End_While
        cld
        add edi 2                              ; edi > start of control records

; If user delete some control before defining the ID, we reset the flag for new "Add":
        push edi
            repne scasb | repne scasb
            On D$edi = '0000', mov W$PreviousControlID 0FFFF  ; ID at +52 octets from start

            mov al 255, edi esi | repne scasb  ; search for the end
            mov ecx edi
        pop edi | dec edi | sub ecx edi        ; ecx = lenght of data to move upward
        rep movsb
        call FromTextToBinTemplate | call ShowDialogResult | call FillDialogListBox

    .End_If
ret
____________________________________________________________________________________

; Called by Dialog Edition CallBack with buttons handles in ecx, controls table index in ebx:

ExitDialog:
    .If ebx = 0
        call SaveClipDialog | call CloseDialogEdition
    .Else_If ebx = 4
        If B$DialogLoadedFromResources = &TRUE
            call SaveResourceDialog | call CloseDialogEdition
        Else
            call SaveNewResourceDialog | call CloseDialogEdition
        End_If
        mov B$SourceHasChanged &TRUE
    .Else_If ebx = 8
       call CloseDialogEdition |  call SaveDialogToDisk
    .Else   ;_If ebx = 12
       call CloseDialogEdition
    .End_If
ret

CloseDialogEdition:
    call 'USER32.ClipCursor' &NULL
    call UninstallHook
    call 'User32.EndDialog' D$DialogEditorHandle 0
    call 'User32.DestroyWindow' D$EditedDialogHandle
    mov D$DialogEditorHandle 0, D$EditedDialogHandle 0
    mov B$OnDialogEdition &FALSE, B$DialogLoadedFromResources &FALSE
ret

_______________________________________________________________________________________
;;
 saving the template in ClipBoard. The main job is to make it clean and pretty source.
 (aligned comments, formated hexa numbers, ...). "B$InsideText" is used to know where
 to set leading hexa zeros (to preserve both texts and comments).
;;

[ClipTemplate: ?   ClipTemplateLength: ?]
[DialogName: 'Dialog: ' 0  ControlName: 'Control0' 0]


BuildDialogTemplate:
    VirtualAlloc ClipTemplate 60_000

    mov edi D$ClipTemplate , esi D$NewDialogTemplateText
    mov al '[' | stosb
    mov eax 'Dial' | stosd | mov eax 'og: ' | stosd
    mov ebx 0, edx 8, B$InsideText &FALSE

L0: lodsb
    ..If al = 0                                     ; line end:
        mov edx 0
        .If B$esi = 0                               ; block end (dialog or control)
            inc esi
            push edi
                std
                    mov al ';', ecx 200 | repne scasb      ; write ']' before comment
                    mov al ' ' | repe scasb | add edi 2    ; search last non space char
                    mov al ']' | stosb
                cld
            pop edi
            mov al CR, ah LF | stosw | stosw
            On B$esi = 255, jmp L9>>
            mov al '[' | stosb
            mov eax 'Cont' | stosd | mov eax 'rol0' | stosd | dec edi
            push ebx
                call TranslateDialogText4
            pop ebx
            inc ebx
            mov ax ': ' | stosw | add edx 10
        .Else
            mov al CR, ah LF | stosw | mov al ' ' | stosb
        .End_If
        mov B$InsideText &FALSE

    ..Else
        .If al = '"'
            mov al "'" | mov B$InsideText &TRUE
        .End_If
        .If al <> '0'
            If al = ';'
                mov ecx 30 | cmp edx 28 | ja L2>
                sub ecx edx | mov al ' ' | rep stosb
                mov al ';', B$InsideText &TRUE
            End_If
            On B$InsideText = &TRUE, jmp L2>
            If B$esi <> '$'                         ; set a leading '0'
                cmp B$edi-1 ' ' | jne L2>           ; for naked hexa
                cmp al '1' | jb L2>
                cmp al 'F' | ja L2>
                    mov B$edi '0' | inc edi | inc edx  ; numbers (not before 'U$'/'D$')
            End_If
L2:         stosb | inc edx
        .Else
            If W$edi-2 <> ' 0'
                stosb | inc edx                     ; no double zeros for hexa numbers
            End_If
        .End_If

    ..End_If
    jmp L0<<

L9: sub edi D$ClipTemplate | mov D$ClipTemplateLength edi
ret


SaveClipDialog:
    push D$BlockStartTextPtr, D$BlockEndTextPtr, D$BlockInside

        call BuildDialogTemplate
        move D$BlockStartTextPtr D$ClipTemplate

L9:     mov eax D$BlockStartTextPtr | add eax D$ClipTemplateLength | dec eax
        mov D$BlockEndTextPtr eax

        mov B$BlockInside &TRUE | call ControlC | mov B$BlockInside &FALSE

        VirtualFree D$ClipTemplate
        mov B$InsideText &FALSE

    pop D$BlockInside, D$BlockEndTextPtr, D$BlockStartTextPtr
ret


[DlgFilesFilters: B$ 'RosAsm Dialog Template',  0,   '*.dlgl', 0, 0]
[RcFilesFilters: B$ 'RosAsm RC Template',  0,   '*.*', 0, 0]
[SaveDlgFilter: ? #&MAX_PATH] [ChoosenDlgFile: ? #&MAX_PATH]

[OpenDlg:
 OpenDlg.lStructSize: D$ len
 OpenDlg.hwndOwner: D$ 0
 OpenDlg.hInstance: D$ 0
 OpenDlg.lpstrFilter: D$ DlgFilesFilters

 OpenDlg.lpstrCustomFilter: D$ &NULL ; uFileFilter
 OpenDlg.nMaxCustFilter: D$ 0 ; 260
 OpenDlg.nFilterIndex: D$ 1
 OpenDlg.lpstrFile: D$ SaveDlgFilter
 OpenDlg.nMaxFile: D$ 260
 OpenDlg.lpstrFileTitle: D$ ChoosenDlgFile
 OpenDlg.nMaxFileTitle: D$ 260
 OpenDlg.lpstrInitialDir: D$ 0
 OpenDlg.lpstrTitle: D$ SaveDlgNameTitle
 OpenDlg.Flags: D$ &OFN_CREATEPROMPT__&OFN_EXPLORER__&OFN_HIDEREADONLY__&OFN_LONGNAMES__&OFN_NONETWORKBUTTON__&OFN_OVERWRITEPROMPT__&OFN_PATHMUSTEXIST
 ; 0281804
 ; &OFN_CREATEPROMPT__&OFN_EXPLORER__&OFN_HIDEREADONLY__&OFN_LONGNAMES
 ; &OFN_NONETWORKBUTTON__&OFN_OVERWRITEPROMPT__&OFN_PATHMUSTEXIST
 ;  0_2000
 ; 08_0000
 ;       4
 ; 20_0000
 ;  2_0000
 ;       2
 ;     800
 OpenDlg.nFileOffset: W$ 0
 OpenDlg.nFileExtension: W$ 0
 OpenDlg.lpstrDefExt: D$ 0
 OpenDlg.lCustData: D$ 0
 OpenDlg.lpfnHook: D$ 0
 OpenDlg.lpTemplateName: D$ 0]

;[OpenPEStruc: len
; hwndPEFileOwner: 0  OPESInstance: 0  PEFilesFilters  uFileFilter  260
; 1 SaveFilter  260  ChoosenFile  260  0
; OpenPEFileTitle  OpenPEStrucFlags: 0281804
; 0  0  0  0  0]

SaveDialogToDisk:
    call BuildDialogTemplate

    mov edi SaveFilter, eax 0, ecx 65 | rep stosd
    mov D$SaveDlgFilter 'New.', D$SaveDlgFilter+3 '.dlg', D$SaveDlgFilter+7 0

    call 'Comdlg32.GetSaveFileNameA' OpenDlg | On eax = &FALSE, jmp L9>>

    call ForceExtension SaveDlgFilter, '.dlg'

    call 'KERNEL32.CreateFileA' SaveDlgFilter &GENERIC_WRITE,
                               &FILE_SHARE_READ__&FILE_SHARE_WRITE, 0,
                               &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
        mov eax D$BusyFilePtr | call MessageBox | jmp L9>>
    End_If

    mov D$DestinationHandle eax, D$NumberOfReadBytes 0

    call 'KERNEL32.WriteFile' D$DestinationHandle, D$ClipTemplate, D$ClipTemplateLength,
                              NumberOfReadBytes  0

    call 'KERNEL32.CloseHandle' D$DestinationHandle | mov D$DestinationHandle 0

L9: VirtualFree D$ClipTemplate
    mov B$InsideText &FALSE
ret


Proc ForceExtension:
    Argument @FileName, @Ext

        mov eax D@FileName, ebx D@Ext
        While B$eax <> 0 | inc eax | End_While | sub eax 4

        ..If D$eax <> ebx
            .If B$eax = '.'
L1:             mov D$eax ebx, B$eax+4 0
            .Else
                If B$eax+1 = '.'
                    inc eax | jmp L1<
                Else_If B$eax+2 = '.'
                    add eax 2 | jmp L1<
                Else_If B$eax+3 = '.'
                    add eax 3 | jmp L1<
                Else
                    add eax 4 | jmp L1<
                End_If
            .End_If
        ..End_If
EndP

; Reuse of the ClipBoard Naming because reuse of the Routine for Loading from ClipBoard.

OpenDlgFile:
    mov D$OtherFilesFilters DialogFilesFilters
    mov D$OpenOtherFileTitle DialogFilesTitle

    move D$OtherhwndFileOwner D$hwnd, D$OtherhInstance D$hInstance

    mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc

    If D$OtherSaveFilter = 0
        pop eax | ret
    End_If

    call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
      mov eax D$BusyFilePtr | call MessageBox | pop eax | ret  ; return to caller of caller
    Else
      mov D$OtherSourceHandle eax
    End_If

    call 'KERNEL32.GetFileSize'  eax 0 | mov D$ClipBoardLen eax

    If eax > 0
        VirtualAlloc ClipBoardPTR eax

        mov eax D$ClipBoardPTR | add eax D$ClipBoardLen | mov D$ClipBoardEnd eax

        mov D$NumberOfReadBytes 0
        call 'KERNEL32.ReadFile' D$OtherSourceHandle D$ClipBoardPTR,
                                 D$ClipBoardLen NumberOfReadBytes 0
    End_If

    call 'KERNEL32.CloseHandle' D$OtherSourceHandle
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[argh: 'Arghhh!!!...', 0]

[ClipBoardEnd: ?  OnClipDialog: ?]

___________________________________________________________________________________
;;
 Saving the template for .rsrc:

 'DialogList' table holds the records for each Dialog resource (ID / Ptr / Size). This
 table is used at building time by 'TemporaryFillRsrcList' to prepare the Resource tree
 construction.
;;

SearchLenghtOfDialogData:
    mov ebx D$LastDialogListItem, esi D$EditedDialogBoxData
    inc ebx                                     ; ex: 7+7+7+6 (last line not account)
    lodsd | lodsd                               ; styles
    lodsw | lodsw | lodsw | lodsw | lodsw       ; n, X, Y, W, H
    lodsw                                       ; menu?
    On ax > 0, lodsw                            ; menu ID
    lodsw                                       ; class? > 0 for edition

    mov edi esi
        mov ax 0, ecx 200 | repne scasw | repne scasw   ; title / font
    mov esi edi

    sub ebx 7
    while ebx > 0
        test esi 00_11 | jz L1>
            lodsw                               ; align
L1:     lodsd | lodsd                           ; styles
        lodsw | lodsw | lodsw | lodsw           ; X, Y, W, H
        lodsw | lodsw                           ; ID / Class
        If ax <> 0FFFF
            mov edi esi
                mov ax 0, ecx 200 | repne scasw ; Text form Class (zero ended)
            mov esi edi
        End_If
        mov edi esi
            mov ax 0, ecx 200 | repne scasw     ; title
        mov esi edi
        lodsw

        sub ebx 7
    End_While

    mov ecx esi | sub ecx D$EditedDialogBoxData ; lenght of dialog data

    mov esi ClassRecord
    While B$esi > 0
        lodsb | add ecx 2
    End_While
ret


[WhatDialogIDData: D$ 090C408C2 0  ; Style
 U$ 03 0 0 09C 01A             ; Dim
 0                             ; Menu
 0                             ; Class
 'Give an ID number for this Dialog' 0 ; Title
 08 'Helv' 0]                  ; Font

[WDIDC1: D$ 050042000 0        ; Style
 U$ 02A 05 049 0F              ; Dim
 0DE                           ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data

[WDIDC2: D$ 050000001 0        ; Style
 U$ 075 05 023 0E              ; Dim
 0DF                           ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data

[WDIDC3: D$ 050000000 0        ; Style
 U$ 03 05 024 0F               ; Dim
 0E0                           ; ID
 0FFFF 080                     ; Class
 'Abort' 0                     ; Title
 0]                            ; No creation data


[OK_ID 0DF  IDNumberEdit 0DE  Abort_ID 0E0]


[EIDNMessage: "

    Dialog ID numbers can't be greater than 0FFFF (65535)    

", 0]


ErrorIDnumber:
    call 'USER32.MessageBoxA' D$hwnd, EIDNMessage, Wahoo, &MB_SYSTEMMODAL
ret


[UserAbortID: 0] [IDstring: '        ' 0]

Proc WhatDialogIdProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_INITDIALOG
        mov B$UserAbortID &FALSE
        call 'User32.GetDlgItem' D@Adressee, IDNumberEdit
        push eax
            call 'User32.SendMessageA' eax, &EM_SETLIMITTEXT, 5, 0
        pop eax
        If B$DialogLoadedFromResources = &TRUE
            mov eax D$WhatDialogListPtr, edi IDString, ebx 10          ; translate ID to
            sub eax 4 | mov eax D$eax
            add edi 9                                                    ; decimal text
L0:         mov edx 0 | div ebx
            dec edi | add dl '0' | mov B$edi dl | cmp eax 0 | ja L0<
            call 'User32.SetDlgItemTextA' D@Adressee, IDNumberEdit, edi

        Else
            mov esi DialogList
            While D$esi+12 > 0
                add esi 12
            End_While
            mov D$DialogListPtr esi | On D$esi <> 0, add D$DialogListPtr 12

            lodsd | add eax 10
            mov edi IDString, ebx 10 | add edi 9 | jmp L0<
        End_If

        call 'USER32.SetClassLongA' D@Adressee, &GCL_HICON, D$wc_hIcon

    ...Else_If D@Message = &WM_COMMAND
        ..If W@wParam = OK_ID
            call 'USER32.GetDlgItemInt' D@Adressee, IDNumberEdit, 0, 0

            .If eax > 0FFFF
                call ErrorIDnumber
            .Else
                If B$DialogLoadedFromResources = &FALSE
                    push eax
                        call CheckNotUsedId eax, D@Adressee
                    pop ebx
                    On eax = &IDCANCEL, jmp L5>
                    mov eax ebx
                End_If

                If B$DialogLoadedFromResources = &TRUE
                    mov edi D$WhatDialogListPtr | sub edi 4 | stosd
                Else
                    mov edi D$DialogListPtr | stosd | add D$DialogListPtr 4
                End_If
                call 'User32.EndDialog' D@Adressee, 0
            .End_If

        ..Else_If W@wParam = Abort_ID
            mov B$UserAbortID &TRUE
            call 'User32.EndDialog' D@Adressee, 0
        ..End_If

    ...Else
        popad | mov eax &FALSE | jmp L9>

    ...End_If

L5: popad | mov eax &TRUE

L9: EndP
____________________________________________________________________________________________
;;
 this does only save temporary a resource template in a fitting memory. It will
 remain there until compile time fills the resource tree. "ExitDialog" clear the
 editions chunks of memory. "ReleaseResourceDialogMemory" will be called by "MainWindowProc"
 exit case
;;

SaveNewResourceDialog:
    call SearchLenghtOfDialogData
    push ecx
        VirtualAlloc TempoMemPointer ecx                ; new memory for dialog data

        call 'User32.DialogBoxIndirectParamA' D$hinstance,
               WhatDialogIDData, 0, WhatDialogIdProc, 0 ; write ID in list <<<<<<<<

        If B$UserAbortID = &TRUE
            VirtualFree D$TempoMemPointer
            pop eax, eax  | ret                 ; return to caller of 'ExitDialog'
        End_If

        mov eax D$TempoMemPointer
        mov edi D$DialogListPtr | stosd         ; write ptr to data in list <<<<<<<<
        add D$DialogListPtr 4
        mov edi eax                             ; ready for fill
    pop ecx
    mov esi D$DialogListPtr | mov D$esi ecx     ; write size in list <<<<<<<<
    add D$DialogListPtr 4
    call SaveDialogDataToResources
ret

____________________________________________________________________________________________
; In with ecx = Length as given by 'SearchLenghtOfDialogData'.
;         edi = Ptr to a Mem in DialogList.

SaveDialogDataToResources:
    mov esi D$EditedDialogBoxData

    movsd | movsd                           ; Style / Ext.Style

    movsw | movsw | movsw | movsw | movsw   ; n / X / Y / W / H

    lodsw                                   ; +2 for '0' menu in edition

    sub ecx 20                              ; >>> 20 Bytes read / 18 Bytes written

    If D$DialogMenuTrueID = 0
        stosw                               ; '0' menu
    Else
        mov eax 0FFFF | stosw
        mov eax D$DialogMenuTrueID | stosw  ; See comments at 'DialogMenuComment'
    End_If

    lodsw
    push esi
        mov esi ClassRecord, eax 0
        Do
            lodsb | stosw                   ; write preserved Class
        loop_Until al = 0
    pop esi
    sub ecx 2

    Do
        lodsw | stosw | sub ecx 2           ; write Title
    loop_Until ax = 0

    Do
        lodsw | stosw | sub ecx 2           ; write Font
    loop_Until ax = 0

;;
    Now, if edi is un-aligned, we have to align for the next Control.

    But: If esi is also un-aligned, the required alignement has already be done previously
        (at least for viewing the Dialog, when Editing). So:

    * esi un-aligned // edi un-aligned  >>> do nothing.
    * esi aligned    // edi aligned     >>> do nothing.
    * esi unaligned  // edi aligned     >>> kill previous alignment.
    * esi aligned    // edi un-aligned  >>> do the alignment.

   (The difference between esi and edi may come from addition of the Class
    Record, which is cleared off from the 'EditedDialogBoxData' for edition).
;;
    jecxz L9>

    mov eax esi, ebx edi | and eax 00_11 | and ebx 00_11
    .If eax <> ebx
        If eax = 0
            mov W$edi 0 | add edi 2
        Else
            lodsw | sub ecx 2 | jecxz L9>
        End_If
    .End_If

    rep movsb                               ; Write all Controls at once.
L9: ret

____________________________________________________________________________________________


SaveResourceDialog:
    call 'User32.DialogBoxIndirectParamA' D$hinstance,
              WhatDialogIDData  0  WhatDialogIdProc 0   ; write ID in list <<<<<<<<

    If B$UserAbortID = &TRUE
          pop eax | ret
    End_If

    mov eax D$WhatDialogListPtr, eax D$eax
    VirtualFree eax                                     ; free previous mem ptr in List

    call SearchLenghtOfDialogData
    push ecx
        VirtualAlloc TempoMemPointer ecx
        mov eax D$TempoMemPointer
        mov edi D$WhatDialogListPtr | stosd             ; write ptr to data in list <<<<<<<<
        mov edi eax                                     ; ready for fill
    pop ecx
    mov esi D$WhatDialogListPtr | add esi 4
    mov D$esi ecx                                       ; write size in list <<<<<<<<

    call SaveDialogDataToResources
ret


ReleaseResourceMemory:
  ; All Lists are: ID / Pointer to Mem / Size.

    mov esi DialogList, D$DialogListPtr DialogList
    call ReleaseOneResourceMemory

    mov esi MenuList, D$MenuListPtr MenuList
    call ReleaseOneResourceMemory

    mov esi IconList, D$IconListPtr IconList
    call ReleaseOneResourceMemory

    mov esi GroupIconList, D$GroupIconListPtr GroupIconList
    call ReleaseOneResourceMemory

    mov esi CursorList, D$CursorListPtr CursorList
    call ReleaseOneResourceMemory

    mov esi GroupCursorList, D$GroupCursorListPtr GroupCursorList
    call ReleaseOneResourceMemory

    mov esi BitMapList, D$BitMapListPtr BitMapList
    call ReleaseOneResourceMemory

    mov esi WaveList, D$WaveListPtr WaveList
    call ReleaseOneResourceMemory

    mov esi AviList, D$AviListPtr AviList
    call ReleaseOneResourceMemory

    mov esi RcDataList, D$RcDataListPtr RcDataList
    call ReleaseOneResourceMemory

 ;   mov esi OtherList, D$OtherListPtr OtherList
 ;   call ReleaseOneResourceMemory

    mov edi uRsrcList, D$uRsrcListPtr uRsrcList, eax 0, ecx 1000
    rep | stosd                             ; Clear uRsrcList
ret


ReleaseOneResourceMemory:
L0: lodsd | On eax = 0, ret                 ; ID
        mov D$esi-4 0                       ; (and clear BitMapList table)
        lodsd | mov D$esi-4 0               ; ptr
        push esi
            VirtualFree eax
        pop esi
        lodsd | mov D$esi-4 0 | jmp L0<     ; size

____________________________________________________________________________________

SearchResourceType:  ; in:  ebx = type (&RT_DIALOG, &RT_MENU, ...)
    mov esi D$UserPEStartOfResources | cmp esi 0 | je L8>

    add esi 14                          ; > points to number of resources
    mov eax 0 | lodsw | mov ecx eax     ; > in ecx
    On eax = 0, ret                     ; if no resources at all

  ; search RT_MENU, ... in resource general header:

L0: lodsd | cmp eax ebx | je L1>
        lodsd | loop L0<
            jmp L8>                     ; no whished resource found (possible naked PE)

L1: lodsd                               ; menu "Level2Rt_Menu-StartOfRsrc+NodeFlag" in eax
    and eax 0FFFFFFF                    ; strip node flag (0_80000000)
    add eax D$UserPEStartOfResources

  ; edx will be the Number of Resources in a Type:
    add eax 14 | mov esi eax | movzx edx W$esi
  ; If the Resource is registered by name instead of by ID:

    ;.If edx = 0

    .If W$esi-2 <> 0
        call StoreNameToID esi
        mov dx W$esi-2      ; Number of Resource for a given Type
        push esi, edx
            dec dx | add esi 8
            While dx > 0 | call StoreNameToID esi | dec dx | add esi 8 | End_While
        pop edx, esi

        movzx edx W$esi-2 | add dx W$esi
  ;  .Else
  ;      If ebx = &RT_ICON
  ;          On B$FirstIconDone = &FALSE, call StoreNameToID esi
  ;      End_If

    .End_If
    add esi 2 | ret

L8: mov eax 0 | ret


; 'NamedIdList' Records are: [NumberID / StringLength with 2 "'" / 'String'] / [...] / ...

[NamedIdList: ?] [NamedIdListPtr: ?    FirstIconDone: ?]

Proc StoreNameToID:
    Argument @Pointer
    Uses esi, edi, ebx, ecx, edx

        If D$NamedIDList = 0
            pushad
                VirtualAlloc NamedIDList D$ResourcesSize
                mov D$NamedIdListPtr eax
            popad
        End_If

        mov eax D@Pointer | add eax 2 ; Points now to Name Pointer (+ 0_8000_0000 mark)
        mov eax D$eax | and eax 0_FFFF
       ; .If ebx = RT_ICON
       ;     If B$FirstIconDone = &FALSE
       ;         mov eax 1, B$FirstIconDone &TRUE
       ;     End_If
       ; .End_If
        mov edi D$NamedIdListPtr | stosd                        ; ID


        mov esi eax | add esi D$UserPEStartOfResources

        lodsw | movzx eax ax | mov ecx eax | add eax 2 | stosd  ; Length

        mov B$edi '"' | inc edi

L0:     lodsw | stosb | loop L0<
        mov B$edi '"' | inc edi | mov D$edi 0                   ; String

        mov D$NamedIdListPtr edi
EndP

____________________________________________________________________________________________

;;
  1) Search the Data 'Name'
  2) Get Back and read the Data Label
  3) Replace all Evocations of this Label by the Direct Numbered ID
;;
NamedIdSubstitution:  ; 'SymbolicAnalyzes' 'FRproc' 'StringReplaceAll'
    ...If D$NamedIdList <> 0
        mov esi D$NamedIdList
        mov B$DownSearch &TRUE, B$CaseSearch &FALSE, B$SilentSearch &TRUE

        ..While D$esi <> 0
          ; Create a Copy of the NumberID in Text form:
            lodsd | mov edi ReplaceWithString | call WriteEax | mov B$edi 0

          ; Copy the User Source IDName into the 'SearchString' Buffer:
            lodsd | mov D$LenOfSearchedString eax, ecx eax
            mov edi SearchString | rep movsb | mov al 0 | stosb

          ; esi ready for next Record:
            add esi ebx
            push esi
                mov D$NextSearchPos 0
                move D$CurrentWritingPos D$CodeSource
                call StringSearch
                ..If B$BlockInside = &TRUE
                  ; The Text of the IdName has been found. Search back for the Data Label:
                    mov esi D$BlockStartTextPtr
                    While D$esi <> 'Data' | dec esi | End_While

                  ; Copy the 'DATAXXXXXX' into the 'SearchString' Buffer:
                    mov edi SearchString, ecx 0
                    While B$esi <> ':' | movsb | inc ecx | End_While | mov al 0 | stosb
                    mov D$LenOfSearchedString ecx

                  ; Search Evocations of 'DATAXXXXXX', replace by the ID Number Text:
L0:                 call StringSearch
                    If B$BlockInside = &TRUE
                        mov eax D$BlockEndTextPtr
                        On B$eax+1 <> ':', call IDReplace
                        jmp L0<
                    End_If

                ..End_If
            pop esi
        ..End_While

        VirtualFree D$NamedIDList
    ...End_If
ret


IDReplace:
    mov esi ReplaceWithString, edi D$BlockStartTextPtr

    While B$esi <> 0 | movsb | End_While
    While B$edi > ' ' | mov B$edi ' ' | inc edi | End_While
ret


SearchResourceNamedType:   ; in:  edi = Named Type pointer ('WAVE', 'AVI', ...), edx = len
    mov esi D$UserPEStartOfResources | cmp esi 0 | je L8>>  ; retire >>

    add esi 14                            ; > points to number of resources
    mov eax 0 | lodsw | mov ecx eax       ; > in ecx
    On eax = 0, ret                    ; if no resources at all

  ; search Ptr to Name, ... in resource general header:

L0: lodsd | test eax 0_8000_0000 | jz L2>
    pushad
        xor eax 0_8000_0000 | add eax D$UserPEStartOfResources
        mov ecx edx, esi eax | lodsw | cmp al dl | jne L1>
        repe cmpsw | je L3>
L1: popad
L2: lodsd | loop L0<
      jmp L8>                             ; no whished resource found (possible naked PE)

L3: popad
    lodsd                                 ; menu "Level2Rt_Menu-StartOfRsrc+NodeFlag" in eax
    and eax 0FFFFFFF                      ; strip node flag (0_80000000)
    add eax D$UserPEStartOfResources

    add eax 14 | mov esi eax, edx 0, dx W$esi
    If edx = 0
        call StoreNameToID esi
        mov dx W$esi-2
    End_If
    add esi 2 | ret

L8: mov eax 0 | ret


; Read all Dialogs in RosAsm PE. Same routine as the ones for icon / menu.

ReadRosAsmPeDialogs:
    mov edi DialogList, eax 0, ecx 300 | rep stosd
    mov ebx RT_DIALOG | call SearchResourceType | On eax = 0, ret
    mov D$DialogListPtr DialogList,  ebx DialogListPtr | call ReadResourcesRecord
  ret

 ______________________________________

  ; resource TYPEs dir:

  ; Resources (ID / Ptr / Size)

; in: ebx = Prt variable to a List (DialogListPtr, MenuListPtr, ...)
; (ebx is the adress, not the value -we move it in here-)
; edx is the Number of Resources in a Type

ReadResourcesRecord:
    lodsd | and eax 0FFFF | mov edi D$ebx | stosd   ; Write ID.
    mov D$ebx edi                                   ; Adjust D$XxxxxxListPtr.
    lodsd                                  ; "Level3Rt_Menu-StartOfRsrc+NodeFlag" in eax

    push esi, edx
        test eax 08000_0000 | jnz L1>
            add eax D$UserPEStartOfResources | mov esi eax | jmp L5>>

L1:     and eax 0FFFFFFF | add eax D$UserPEStartOfResources | add eax 20 | mov esi eax
      ; Language. dir:
        lodsd                    ; "Level4Rt_Menu-StartOfRsrc" in eax (no NodeFlag here
                                 ; next one is leafe ptr to true resources)
        add eax D$UserPEStartOfResources
        mov esi eax

      ; Records of each resource:
L5:     lodsd                                   ; ptr to menu data (but RVA - startOfResource)
L1:     mov ecx D$esi
        sub eax D$ResourcesRVA                  ; - RVA
        add eax D$UserPEStartOfResources        ; eax now points to true menu data

        If eax < D$UserPeStart
            jmp DisFail
        Else_If eax > D$UserPeEnd
            jmp DisFail
        End_If

        push eax
            push ebx, ecx
                VirtualAlloc TempoMemPointer ecx
            pop ecx, ebx
        pop esi

        mov edi D$TempoMemPointer
        push edi, ecx
            rep movsb                           ; copy bin template to temporary mem
        pop ecx, eax

        mov edi D$ebx | stosd
        mov eax ecx | stosd | mov D$ebx edi

    pop edx, esi
    dec edx | cmp edx 0 | ja ReadResourcesRecord; next resource TYPEs dir record > ID ready
L9: mov eax &TRUE
ret
_____________________________________________________________________________________
;;
 All routines for dialog edition are first based on text version of templates. Here,
 we got first a bin template > translation back to text needed. All dialog resources
 have been uploaded in memories chuncks stored in "DialogList" (/ID/Ptr/Size). The
 Naming "LoadFromResouce" is only to echoe what user clicked on in main menu, but,
 in fact, upload job was previously done by "ReadRosAsmPeDialogs" when file is open.
 We now simply translate to text version before runing edition:
;;

[NoResourceDialog: "

    There is no Resources Dialog in this PE      

", 0]


LoadFromResources:
    If B$OnDialogEdition = &TRUE
        Beep | ret  ; prevents from multi-runs
    End_If
    call InitDialogMemory

    mov esi DialogList
    .If D$esi  = 0                    ; empty? > out
        call 'USER32.MessageBoxA' D$hwnd, NoResourceDialog, Argh, &MB_SYSTEMMODAL | ret

    .Else_If D$esi+12 = 0               ; only one resource? > OK
        mov D$WhatDialogListPtr DialogList+4

        mov ebx D$WhatDialogListPtr, ebx D$ebx
        If W$ebx+18 = 0
            mov D$ActualMenutestID 0, D$DialogMenuTrueID 0
        Else
            movzx eax W$ebx+20 | mov D$DialogMenuTrueID eax
            mov esi MenuList
            While D$esi <> eax
                add esi 12
            End_While
            mov D$MenuListPtr esi
            add esi 4
            call 'User32.LoadMenuIndirectA' D$esi | mov D$ActualMenutestID eax
        End_If

    .Else                               ; several resources? > wich one?
        mov D$DialogListHandle 0, D$DialogEditorHandle 0
        call WhatResourceTemplate       ; > D$WhatDialogListPtr > Data pointer

    .End_If

    mov B$DialogLoadedFromResources &TRUE
    call FromBinToTextTemplate
    call ReInitDialogEdition
ret

____________________________________________________________________________________________

; The following routines have been rewritten to loose the dependency on the old routines.
; They are not rewritten in an intelligent way. They are just rewritten so they will do
; exactly the same thing as before (no matter how stupid that was/is).
____________________________________________________________________________________________

[DialogFromFile: ?]

LoadDialogFromFile:
    If B$OnDialogEdition = &TRUE
        Beep | ret
    End_If

    mov B$DialogFromFile &TRUE

    call InitDialogMemory

    call OpenDlgFile | jmp L0>


LoadDialogFromClipBoard:
    If B$OnDialogEdition = &TRUE
        Beep | ret
    End_If

    mov B$DialogFromFile &FALSE

    call InitDialogMemory

    call OpenClipBoard


L0: On D$ClipBoardPtr = 0, ret
    On D$ClipBoardlen = 0, ret

    mov B$WeAreInTheCodeBox &TRUE
    mov eax esp, D$OldStackPointer eax

    push D$CodeSourceA, D$CodeSourceB

        mov ecx D$ClipBoardlen | add ecx 010
        VirtualAlloc CodeSourceA, ecx | add D$CodeSourceA 010
        mov ecx D$ClipBoardlen | add ecx 010
        VirtualAlloc CodeSourceB, ecx | add D$CodeSourceB 010

        call NewCopyToCodeSourceA D$ClipBoardPtr, D$ClipBoardlen

        If B$DialogFromFile = &TRUE
            VirtualFree D$ClipBoardPTR
        Else
            call CloseClipBoard
        End_If

        mov esi D$CodeSourceA | While B$esi > 0 | inc esi | End_While
        mov W$esi CRLF | add esi 2 | add D$StripLen 2

        call ClearQwordCheckSum

        call CoolParsers

        call NewCountStatements | On B$CompileErrorHappend = &TRUE, jmp L9>>

        call HotParsers | On B$CompileErrorHappend = &TRUE, jmp L9>>

        call InitIndex1 | call InitIndex2

        Exchange D$CodeSourceA D$CodesourceB

        push D$SourceLen
            move D$SourceLen D$StripLen
            move D$AsmTablesLength D$SourceLen
            call ReuseSourceAForCodeList
        pop D$SourceLen

        ;call ClearQwordCheckSum

        call InitIndex3

        call SaveCheckSumTable

        mov eax D$CodeListPtr | mov D$DataList eax | mov D$DataListPtr eax
        call StoreDatas

        call RestoreCheckSumTable

L9:     mov B$WeAreInTheCodeBox &FALSE | On B$CompileErrorHappend = &TRUE, jmp L9>>

        mov B$OnClipDialog &TRUE

        mov esi D$DataList, edi D$NewDialogTemplateText, D$ActualEditedDialogID 0
        mov eax D$DataListPtr | sub eax D$DataList | inc eax
        mov D$ResourceDialogSize eax

        .If W$esi+18 = 0FFFF
            movzx eax W$esi+20 | mov D$DialogMenuTrueID eax
            push esi
                mov esi MenuList
                While D$esi <> eax
                    add esi 12
                    If D$esi = 0
                        pop esi | call NoSuchMenu | jmp L9>
                    End_If
                End_While
            pop esi
        .End_If

        call FromClipBoardBinToText | call ReInitDialogEdition

L9:     VirtualFree D$CodeSourceA, D$CodeSourceB
    pop D$CodeSourceB, D$CodeSourceA
ret
____________________________________________________________________________________________

[NoMenuMessage: "
This Dialog Template cannot be loaded because it    
includes a Menu that is not found in the actual
Resources.

                            Menu"

MissingMenuID: "         ", 0]

NoSuchMenu:
    call WriteDecimalID eax, MissingMenuID
    call 'USER32.MessageBoxA' D$hwnd, NoMenuMessage, Argh, &MB_OK
ret
____________________________________________________________________________________________


[WhatDialogListPtr: ?  OkDialogFlag: ?  ChoiceDialogHandle: ?]

WhatResourceTemplate:
  ; 'DialogList' structure is (dWords): ID / Ptr / Size // ...
  ; D$WhatDialogListPtr >>> Ptr to Dialog Mem in the form of 'DefaultDialogTemplateText').
    mov D$OkDialogFlag &FALSE, D$WhatDialogListPtr DialogList+4
    .While B$OkDialogFlag = &FALSE

        mov ebx D$WhatDialogListPtr, ebx D$ebx
        If W$ebx+18 = 0
            mov D$ActualMenutestID 0, D$DialogMenuTrueID 0
        Else
          ; If Menu, W$ebx+18 = 0FFFF // W$ebx+20 = ID Number.
            movzx eax W$ebx+20 | mov D$DialogMenuTrueID eax
            mov esi MenuList
            While D$esi <> eax
                add esi 12
            End_While
            mov D$MenuListPtr esi | add esi 4
            call 'User32.LoadMenuIndirectA' D$esi | mov D$ActualMenutestID eax
        End_If

        call FromBinToTextTemplate | call FromTextToBinTemplate

        call 'User32.CreateDialogIndirectParamA' D$hinstance, D$EditedDialogBoxData,
                                                 D$EditWindowHandle, EditedDialogBoxProc, 0
        mov D$ChoiceDialogHandle eax

        call SetNextChoiceID
        call 'User32.DialogBoxIndirectParamA' D$hinstance, ChoiceBar, D$hwnd, ChoiceDialogBoxProc, DialogList
      ; This is the deletion of the viewed Dialog (not of the Choice Bar Dialog):
        call 'User32.EndDialog' D$ChoiceDialogHandle 0

        .If B$OkDialogFlag = &VK_ESCAPE
            pop eax | ret                          ; abort "LoadFromResources" caller
        .Else_If D$WhatDialogListPtr < DialogList
            mov D$WhatDialogListPtr DialogList+4
            call SetNextChoiceID
        .Else
            mov esi D$WhatDialogListPtr
            If D$esi = 0
                sub D$WhatDialogListPtr 12 | mov esi D$WhatDialogListPtr
                call SetNextChoiceID
            End_If
        .End_If
    .End_While
ret
____________________________________________________________________________________________
;                       _______   _______   _______
; The tool:            [  <<<  ] [  OK   ] [  >>>  ]       at 'ChoiceBar'
;                       -------   -------   -------

[ChoiceDialogBoxHandle: ?    UserIsChoosing: ?]
[ChoiceBackHandle: ?    ChoiceOKHandle: ?    ChoiceForthHandle: ?]

SetNextChoiceID:
L1: mov eax D$WhatDialogListPtr, eax D$eax-4
    mov ecx 10, edi ChoiceDecimalID+10, D$edi 0200020, D$edi+4 0200020,
    D$edi+8 0200020, D$edi+12 0200020
    add edi 18
L2: mov edx 0 | div ecx | dec edi | add dl '0'
    mov B$edi 0 | dec edi | mov B$edi dl | cmp eax 0 | ja L2<
ret

[ListOrigin: ?]
Proc ChoiceDialogBoxProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND
        mov eax D@wParam | and eax 0FFFF
        .If eax = CHOICEFORTH
            add D$WhatDialogListPtr 12 | call SetNextChoiceID

        .Else_If eax = CHOICEBACK
            sub D$WhatDialogListPtr 12 | call SetNextChoiceID

        .Else_If eax = CHOICEFIRST
            move D$WhatDialogListPtr D$ListOrigin  ;DialogList+4 |
            add D$WhatDialogListPtr 4
            call SetNextChoiceID

        .Else_If eax = CHOICELAST
L0:         add D$WhatDialogListPtr 12 | mov eax D$WhatDialogListPtr
            cmp D$eax 0 | ja L0<
            sub D$WhatDialogListPtr 12 | call SetNextChoiceID

        .Else_If eax = CHOICEOK
            mov B$OkDialogFlag &TRUE

        .Else_If eax = &IDCANCEL
            mov B$OkDialogFlag &VK_ESCAPE

        .Else
            jmp L8>>
        .End_If

        mov D$ChoiceDialogBoxHandle 0
        call 'User32.EndDialog' D@Adressee 0

    ...Else_If D@Message = &WM_INITDIALOG
        move D$ChoiceDialogBoxHandle D@Adressee, D$ListOrigin D@lParam

        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        call 'USER32.GetWindowPlacement' D@Adressee Control
        mov eax D$Control.rcNormalPosition.top | shr eax 2
        add D$Control.rcNormalPosition.top eax
        add D$Control.rcNormalPosition.bottom eax
        call 'USER32.SetWindowPlacement' D@Adressee Control

    ...Else
        If D$ChoiceDialogBoxHandle <> 0
            call 'USER32.GetFocus'
            On eax <> D@Adressee, call 'User32.SetForegroundWindow' D@Adressee
        End_If
        popad | mov eax &FALSE | jmp L9>

    ...End_If

L8: popad | mov eax &TRUE

L9: EndP



[SureDeleteDialog: 'Kill this Dialog?', 0]

DeleteDialog:
    If B$OnDialogEdition = &TRUE
        Beep | ret                    ; prevents from multi-runs
    End_If
    call InitDialogMemory
    mov esi DialogList
    .If D$esi  = 0                                          ; empty? > out
        call 'USER32.MessageBoxA' D$hwnd, NoResourceDialog, Argh, &MB_SYSTEMMODAL | ret
    .Else                                                   ; Wich resources to kill?
        call WhatResourceTemplate
    .End_If
    mov eax D$WhatDialogListPtr
    call 'User32.CreateDialogIndirectParamA' D$hinstance, D$eax, D$hwnd, EditedDialogBoxProc 0
        mov D$ChoiceDialogHandle eax

    call 'USER32.MessageBoxA' D$hwnd, SureDeleteDialog, Argh, &MB_SYSTEMMODAL+&MB_YESNO
    push eax
        call 'User32.DestroyWindow' D$ChoiceDialogHandle
    pop eax

    If eax = &IDYES
        sub D$WhatDialogListPtr 4                       ; > ID / Ptr /Size
        mov esi D$WhatDialogListPtr, edi esi
        add esi 12
        mov eax esi | sub eax DialogList | shr eax 2

        mov ecx MAXDIALOG | sub ecx eax                 ; tail to move
        rep movsd                                       ; scratch
    End_If

    VirtualFree D$NewDialogTemplateText, D$EditedDialogBoxData
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

SimplyGetDialog:
    call InitDialogMemory

    mov esi DialogList
    If D$esi  = 0
        call 'USER32.MessageBoxA' D$hwnd, NoResourceDialog, Argh, &MB_SYSTEMMODAL
        mov eax 0 | ret
    Else
        call WhatResourceTemplate
    End_If
ret


SaveToBinaryFile:
  ; Prevent from Multiple Instances:
    If B$OnDialogEdition = &TRUE
        Beep | ret
    End_If

    call SimplyGetDialog | On B$OkDialogFlag = &VK_ESCAPE, ret

  ; Similar to SaveDialogToDisk:

    mov edi SaveFilter, eax 0, ecx 65 | rep stosd
    mov D$SaveDlgFilter 'New.', D$SaveDlgFilter+3 '.dlf', D$SaveDlgFilter+7 0

    call 'Comdlg32.GetSaveFileNameA' OpenDlg | On eax = &FALSE, ret

    call ForceExtension SaveDlgFilter, '.bdf'

    call 'KERNEL32.CreateFileA' SaveDlgFilter &GENERIC_WRITE,
                               &FILE_SHARE_READ__&FILE_SHARE_WRITE, 0,
                               &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0

    If eax = &INVALID_HANDLE_VALUE
        mov eax D$BusyFilePtr | call MessageBox | ret
    End_If

    mov D$DestinationHandle eax, D$NumberOfReadBytes 0

    mov esi D$WhatDialogListPtr | sub esi 4 | mov ecx D$esi+8, esi D$esi+4

    call 'KERNEL32.WriteFile' D$DestinationHandle, esi, ecx, NumberOfReadBytes  0

    call 'KERNEL32.CloseHandle' D$DestinationHandle | mov D$DestinationHandle 0
ret


[BinDialogMemory: ? BinDialogLength: ?]

LoadFromBinaryFile:
    If B$OnDialogEdition = &TRUE
        Beep | ret
    End_If

    mov D$OtherFilesFilters BinDialogFilesFilters
    mov D$OpenOtherFileTitle DialogFilesTitle

    move D$OtherhwndFileOwner D$hwnd, D$OtherhInstance D$hInstance

    mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc

    On D$OtherSaveFilter = 0, ret

    call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
      mov eax D$BusyFilePtr | call MessageBox | ret  ; return to caller of caller
    Else
      mov D$OtherSourceHandle eax
    End_If

    call 'KERNEL32.GetFileSize' eax, 0 | mov D$BinDialogLength eax

    If eax > 0
        VirtualAlloc BinDialogMemory eax

        mov D$NumberOfReadBytes 0
        call 'KERNEL32.ReadFile' D$OtherSourceHandle, D$BinDialogMemory,
                                 D$BinDialogLength, NumberOfReadBytes, 0
    Else
        ret
    End_If

    call 'KERNEL32.CloseHandle' D$OtherSourceHandle

    mov esi DialogList | While D$esi <> 0 | add esi 12 | End_While
    mov D$DialogListPtr esi
    mov eax D$BinDialogMemory, D$esi+4 eax
    mov eax D$BinDialogLength, D$esi+8 eax

    mov B$DialogLoadedFromResources &FALSE
    call 'User32.DialogBoxIndirectParamA' D$hinstance, WhatDialogIDData, 0,
                                          WhatDialogIdProc, 0

    If B$UserAbortID = &TRUE
        mov esi DialogList | While D$esi+4 <> 0 | add esi 12 | End_While
        mov D$esi-4 0, D$esi-8 0, D$esi-12 0
        VirtualFree D$BinDialogMemory
    End_If
ret


ReplaceFromBinaryFile:
    If B$OnDialogEdition = &TRUE
        Beep | ret
    End_If

    call SimplyGetDialog | On B$OkDialogFlag = &VK_ESCAPE, ret

    mov D$OtherFilesFilters BinDialogFilesFilters
    mov D$OpenOtherFileTitle DialogFilesTitle

    move D$OtherhwndFileOwner D$hwnd, D$OtherhInstance D$hInstance

    mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc

    On D$OtherSaveFilter = 0, ret

    call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
      mov eax D$BusyFilePtr | call MessageBox | ret  ; return to caller of caller
    Else
      mov D$OtherSourceHandle eax
    End_If

    call 'KERNEL32.GetFileSize' eax, 0 | mov D$BinDialogLength eax

    If eax > 0
        VirtualAlloc BinDialogMemory eax

        mov D$NumberOfReadBytes 0
        call 'KERNEL32.ReadFile' D$OtherSourceHandle, D$BinDialogMemory,
                                 D$BinDialogLength, NumberOfReadBytes, 0
    Else
        ret
    End_If

    call 'KERNEL32.CloseHandle' D$OtherSourceHandle

    mov edi D$WhatDialogListPtr | sub edi 4
    VirtualFree D$edi+4
    mov eax D$BinDialogMemory, D$edi+4 eax
    mov eax D$BinDialogLength, D$edi+8 eax
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[SureReplaceDialog: B$ 'Replace with this Dialog ?', 0]

ReplaceDialogFromFile:  ; DeleteDialog // LoadDialogFromFile


    ____________________________

  ; LoadDialogFromFile

    call OpenDlgFile | On D$ClipBoardPtr = 0, ret
                       On D$ClipBoardlen = 0, ret

    call 'USER32.MessageBoxA' D$hwnd, SureReplaceDialog, Argh, &MB_SYSTEMMODAL+&MB_YESNO

    If eax = &IDYES
        mov esi D$ClipBoardPtr, edi D$WhatDialogListPtr, ecx D$ClipBoardlen
        mov D$edi+4 ecx, edi D$edi
        rep movsb
    End_If

    call CloseClipBoard

    mov B$DialogLoadedFromResources &TRUE
    call FromBinToTextTemplate
    call ReInitDialogEdition
ret
____________________________________________________________________________________________


[CHOICEBACK 0136  CHOICEOK 01  CHOICEFORTH 0138  CHOICEID 010   CHOICEFIRST 037
 CHOICELAST 038]

[ChoiceBar: D$ 0900408C2 0        ; Style
 U$ 06 0 0 0C7 017             ; Dim
 0                             ;      no Menu
 '' 0                          ; Class
 'New Dialog' 0                ; Title
 08 'Helv' 0]                  ; Font

[CGroup: D$ 050000307 0      ; Style
 U$ 0 0 0C8 019                ; Dim
 010                           ; ID
 0FFFF 080                     ; Class
 ChoiceDecimalID:
 'ID =          ' 0            ; Title
 0]                            ; No creation data

[CBack: D$ 050000000 0      ; Style
 U$ 0E 09 038 0E               ; Dim
 0136                          ; ID
 0FFFF 080                     ; Class
 '<<<<<' 0                     ; Title
 0]                            ; No creation data

[COK: D$ 050000000 0      ; Style
 U$ 047 09 038 0E              ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data

[CForth: D$ 050000000 0      ; Style
 U$ 080 09 038 0E              ; Dim
 0138                          ; ID
 0FFFF 080                     ; Class
 '>>>>>' 0                     ; Title
 0]                            ; No creation data

[Cfirst: D$ 050000000 0      ; Style
 U$ 02 09 0B 0E                ; Dim
 037                           ; ID
 0FFFF 080                     ; Class
 '[<' 0                        ; Title
 0]                            ; No creation data

[Clast: D$ 050000000 0      ; Style
 U$ 0B9 09 0B 0E               ; Dim
 038                           ; ID
 0FFFF 080                     ; Class
 '>]' 0                        ; Title
 0]                            ; No creation data


;;
"Load_Dialog_from_Resources" effective Translation for bin to text template.
 Called only in case of 'Load Existing Resource Dialog' and 'Search for what Dialog '.
 So we can find in the Dialog data some menu ID. We set it in 'D$DialogMenuTrueID'
 (to see DialogMenuComment, < Right Click).

 'FromTextToBinTemplate' doesn't do the reverse operation...
;;

[ActualEditedDialogID: 0  ResourceDialogSize: 0  DialogNcontrol: 0]

FromBinToTextTemplate:
    call InitDialogMemory
    mov B$OnClipDialog &TRUE              ; reuse of this flag for initialisation in proc

    mov eax D$WhatDialogListPtr, esi D$eax, edi D$NewDialogTemplateText  ; esi > ptr
    move D$ActualEditedDialogID D$eax-4                                  ; ID
    move D$ResourceDialogSize D$eax+4                                    ; size

FromClipBoardBinToText:
    mov eax 'D$  ' | stosd | dec edi
    lodsd | mov ebx eax | call TranslateDialogText8                      ; (does write)
    mov eax ' 0 ;' | stosd | mov eax ' Sty' | stosd
    mov ax 'le' | stosw | mov al 0 | stosb

    lodsd

    mov eax 'U$  ' | stosd | dec edi
    lodsw | mov W$DialogNcontrol ax
            mov ebx eax | call TranslateDialogText4 | mov al ' '| stosb  ; n
    lodsw | mov ebx eax | call TranslateDialogText4 | mov al ' '| stosb  ; X
    lodsw | mov ebx eax | call TranslateDialogText4 | mov al ' '| stosb  ; Y
    lodsw | mov ebx eax | call TranslateDialogText4 | mov al ' '| stosb  ; W
    lodsw | mov ebx eax | call TranslateDialogText4 | mov al ' '| stosb  ; H
    mov eax ' ; D' | stosd | mov ax 'im' | stosw | mov al 0 | stosb

    lodsw    ; always 0 in RosAsm edition but 0 or 'FFFF ID' in resources:

    If D$DialogMenuTrueID = 0
        mov eax '0 ; ' | stosd | mov eax '    ' | stosd |
        mov eax ' no ' | stosd | mov eax 'Menu' | stosd | mov al 0 | stosb  ; No menu
      ; beware: this is room for "FFFF ID ; menu" when menu added!
    Else
        mov ebx 0FFFF | call TranslateDialogText4 | mov al ' ' | stosb       ; Menu
        lodsw
        mov ebx D$DialogMenuTrueID |  call TranslateDialogText4
        mov eax ' ; M' | stosd | mov ax 'en' | stosw | mov al 'u' | stosb | mov al 0 | stosb
    End_If

    mov al '"' | stosb
L0: lodsw | cmp ax 0 | je L1>
        stosb | jmp L0<
L1: mov al '"' | stosb
    mov eax ' 0 ;' | stosd | mov eax ' Cla' | stosd | mov ax 'ss' | stosw
    mov al 0 | stosb

    mov al '"' | stosb
L0: lodsw | cmp ax 0 | je L1>
        stosb | jmp L0<
L1: mov al '"' | stosb
    mov eax ' 0 ;' | stosd | mov eax ' Tit' | stosd | mov ax 'le' | stosw
    mov al 0 | stosb

    lodsw | mov ebx eax | call TranslateDialogText2
    mov ax ' "' | stosw
L0: lodsw | cmp ax 0 | je L1>
        stosb | jmp L0<
L1: mov al '"' | stosb
    mov eax ' 0 ;' | stosd | mov eax ' Fon' | stosd | mov al 't' | stosb
    mov al 0 | stosb | stosb

    Test esi 00_11 | jz L1>
        lodsw

L1: .While W$DialogNcontrol > 0
        dec W$DialogNcontrol
        mov eax 'D$  ' | stosd | dec edi
        lodsd
        mov ebx eax | call TranslateDialogText8                 ; (does write)
        mov eax ' 0 ;' | stosd | mov eax ' Sty' | stosd
        mov ax 'le' | stosw | mov al 0 | stosb

        lodsd                                                   ; dummy ext. style

        mov eax 'U$  ' | stosd | dec edi
        lodsw | mov ebx eax | call TranslateDialogText4 | mov al ' '| stosb ; X
        lodsw | mov ebx eax | call TranslateDialogText4 | mov al ' '| stosb ; Y
        lodsw | mov ebx eax | call TranslateDialogText4 | mov al ' '| stosb ; W
        lodsw | mov ebx eax | call TranslateDialogText4 | mov al ' '| stosb ; H
        mov eax ' ; D' | stosd | mov ax 'im' | stosw | mov al 0 | stosb

        lodsw | mov ebx eax | call TranslateDialogText4
        mov eax ' ; I' | stosd | mov al 'D' | stosb | mov al 0 | stosb

        lodsw
        If ax = 0FFFF
            mov ebx eax | call TranslateDialogText4 | mov al ' '| stosb
            lodsw | mov ebx eax | call TranslateDialogText4
        Else
            sub esi 2 | mov al '"' | stosb
L0:         lodsw | cmp ax 0 | je L1>
            stosb | jmp L0<

L1:         mov al '"' | stosb | mov ax ' 0' | stosw
      End_If

      mov eax ' ; C' | stosd | mov eax 'lass' | stosd | mov al 0 | stosb

      mov al '"' | stosb
L0:   lodsw | cmp ax 0 | je L1>
      stosb | jmp L0<
L1:   mov al '"' | stosb
      mov eax ' 0 ;' | stosd | mov eax ' Tit' | stosd | mov ax 'le' | stosw
      mov al 0 | stosb

      lodsw
      mov eax '0 ; ' | stosd | mov eax 'No c' | stosd | mov eax 'reat' | stosd
      mov eax 'ion ' | stosd | mov eax 'data' | stosd | mov al 0 | stosb | stosb

      Test esi 00_11 | jz L1>
            lodsw
L1:
    .End_While
    mov al 255 | stosb
ret


; Set a working ID for a Menu in Resources Upload Menu (see: DialogMenuComment):

SetMenuToLoadWithDialog:
    pushad
        mov eax D$DialogMenuTrueID, esi MenuList
        While D$esi <> eax
            If D$esi = 0
                mov D$DialogMenuTrueID 0, D$ActualMenutestID 0
                popad | mov eax 0 | ret
            End_If
            add esi 12
        End_While
        add esi 4
        call 'User32.LoadMenuIndirectA' D$esi
        mov D$ActualMenutestID eax
    popad
ret






TITLE BitMap
___________________________________________________________________________________________
___________________________________________________________________________________________
;;
                                 BitMaps jobs.

 All-in-One organisation have some limits: I do not see what interrest it could be to
 implement a full BitMap Editor inside RosAsm... Maybe one day. Now, as we NEED BitMaps
 and as there are so many BitMaps Editors available for free, i only implement a BitMaps
 Import feature.
;;
___________________________________________________________________________________________
___________________________________________________________________________________________

;Reads Bitmaps, if any, in new load RosAsm PE (just like "ReadRosAsmMenus" / "ReadRosAsmDialogs":

ReadRosAsmBitMaps:
    mov edi BitMapList, eax 0, ecx 300 | rep stosd
    mov ebx &RT_BITMAP | call SearchResourceType | On eax = 0, ret
    mov D$BitMapListPtr BitMapList, ebx BitMapListPtr | call ReadResourcesRecord
ret


[BmStartOfResources: 0  BmExePtr: 0  BmFileLen: 0  BmFileHandle: 0
 BmFilterPtr: 1
 BmFilesFilters:  B$ 'BitMap files'     0  '*.bmp'   0  0
 OpenBitMapFileTitle: 'Choose a BitMap File to open'  0]


[BmuFileFilter: ? #262] [BmSaveFilter: ? #262] [BmChoosenFile: ? #262]

[BmOpenStruc: len
 BmhwndFileOwner: 0  BmOpenInstance: 0  BmFilesFilters  BmuFileFilter  260
 BmFilterPtr  BmSaveFilter  260  BmChoosenFile  260  0
 OpenBitMapFileTitle  0281804
 0  0  0  0  0]

[PointerToData: ?]

LoadBitMap:
  ; Opening a .bmp file:
    call SearchEmptyBitMapListRecord

    mov edi BmSaveFilter, ecx 260, eax 0 | rep stosd
    call 'Comdlg32.GetOpenFileNameA' BmOpenStruc | On D$BmSaveFilter = 0,  ret

    On D$BmFileHandle > 0, call 'KERNEL32.CloseHandle' D$BmFileHandle

    call 'KERNEL32.CreateFileA' BmSaveFilter, &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
        mov eax D$BusyFilePtr | call MessageBox | ret
    Else
        mov D$BmFileHandle eax
    End_If

    call 'KERNEL32.GetFileSize' eax 0 | sub eax 14
    mov edi D$BitMapListPtr | add edi 8 | stosd         ; write BitMap lenght in List
    add eax 14
    mov D$BmFileLen eax                                 ; > eax = adress for asked memory
    VirtualAlloc TempoMemPointer eax
    mov edi D$BitMapListPtr | add edi 4 | mov D$edi eax ; write BitMap mem adress in List
    push edi
        mov D$NumberOfReadBytes 0
        call 'KERNEL32.ReadFile' D$BmFileHandle D$TempoMemPointer,
                              14 NumberOfReadBytes 0    ; jump over BitMapFile header.
    pop edi

    mov esi D$edi
    lodsw | cmp ax 'BM' | jne BadBitMapFileHeader
    lodsd | cmp eax D$BmFileLen | jne BadBitMapFileHeader
    lodsd | cmp eax 0 | jne BadBitMapFileHeader
    lodsd | mov D$PointerToData eax

  ; Load BitMap Data in same table (overwrite no more use header):
    mov ecx D$BmFileLen | sub ecx 14  ; 14 Bytes = len of File Header
  ; (File header is: W$ Style // D$ Size // D$ 0 // D$ Ptr to Data).

    push edi
        call 'KERNEL32.ReadFile' D$BmFileHandle D$edi ecx NumberOfReadBytes 0
    pop edi

  ; Ajust image size if this record is missing:
    mov edi D$edi
    If D$edi+20 = 0
        mov eax D$BmFileLen | sub eax D$PointerToData
        mov D$edi+20 eax
    End_If

  ; Ask user for what BitMap ID number:
L1: call 'USER32.DialogBoxIndirectParamA' D$hinstance  BMIDDialog  0  BMIDDialogProc  0

    If B$UserValidateBitMap = &TRUE
        call ReOrderBitMapList
    Else
        mov edi D$BitMapListPtr, eax 0 | stosd | stosd | stosd
    End_If
ret


[ConflictIDs: B$ 'This ID number is already in Use', 0  ReorderFlag: 0]

ReOrderBitMapList:
    mov B$ReorderFlag &FALSE
    mov esi BitMapList, edi esi | add edi 12
    While D$edi > 0
        mov eax D$esi
        If eax > D$edi
            Exchange D$esi D$edi, D$esi+4 D$edi+4, D$esi+8 D$edi+8
            mov B$ReorderFlag &TRUE
        End_If
        add esi 12 | add edi 12
    End_While
    cmp B$ReorderFlag &TRUE | je ReOrderBitMapList
ret

SearchEmptyBitMapListRecord:
    push esi
        mov esi BitMapList
        While D$esi > 0
            add esi 12
        End_While
        mov D$BitMapListPtr esi
    pop esi
ret


[BadBitMapFile: 'Bad BitMap file header', 0]

BadBitMapFileHeader:
    call 'USER32.MessageBoxA' D$hwnd, BadBitMapFile, Argh, &MB_SYSTEMMODAL
L8: mov edi D$BitMapListPtr, eax 0, ecx 3 | rep stosd
ret


[BMIDDialog: D$ 090C408C2 0    ; Style
 U$ 03 0 0 0B9 018             ; Dim
 0                             ; no Menu
 '' 0                          ; Class
 'What ID number for new BitMap?' 0 ; Title
 08 'Helv' 0]                  ; Font

[BMID0: D$ 050000000 0         ; Style
 U$ 07E 03 038 013             ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data

[BMID1: D$ 050000000 0         ; Style
 U$ 03 03 038 013              ; Dim
 02                            ; ID
 0FFFF 080                     ; Class
 'Abort' 0                     ; Title
 0]                            ; No creation data

[BMID2: D$ 050802000 0         ; Style
 U$ 040 05 038 0F              ; Dim
 03                            ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data


[BMIDeditHandle: 0  uBitMapID: '                   ', 0]

; Previously, i had set a test to prevent from IDs numbers smaller than 1000 and bigger than
; 32000. I do not remember why. May be an old wrong idea about unique IDs across Types.
; Suppress...

Proc BMIDDialogProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND
       ..If D@wParam = &IDCANCEL
            call 'User32.EndDialog' D@Adressee 0

       ..Else_If D@wParam = &IDOK
           call 'User32.GetDlgItem' D@Adressee 3 | mov D$BMIDeditHandle eax
           call 'User32.SendMessageA' D$BMIDeditHandle &WM_GETTEXTLENGTH 0 0 | inc eax
           call 'User32.SendMessageA' D$BMIDeditHandle &WM_GETTEXT eax uBitMapID
           TranslateAsciiToDword uBitMapID
           mov D$uBitMapID 0                         ; just for abort tests in callers:
           .If eax > 0FFFF    ; 32000                 ; 'StoreMenuEdition' / 'MenuEditProc'
             mov eax D$IdTooBigPtr | call MessageBox
           .Else_If eax < 1   ; 000
             mov eax D$IdTooSmallPtr | call MessageBox
           .Else
                mov esi BitMapList
                While D$esi > 0
                    On D$esi = eax, mov eax 0
                    add esi 12
                End_While
                If eax = 0
                    call 'USER32.MessageBoxA' D$hwnd, ConflictIDs, Argh, &MB_SYSTEMMODAL
                Else
                    mov edi D$BitMapListPtr, D$edi eax
                    mov B$UserValidateBitMap &TRUE
                    call 'User32.EndDialog' D@Adressee 0
                End_If
           .End_If

       ..End_If

    ...Else_If D@Message = &WM_INITDIALOG
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        mov B$UserValidateBitMap &FALSE
        call 'User32.GetDlgItem' D@Adressee 3
        call 'User32.SendMessageA' eax &EM_SETLIMITTEXT 5  0
           mov esi D$BitMapListPtr | On esi > BitMapList, sub esi 12
           If D$esi = 0
             mov eax 1   ; 30000
           Else
             lodsd | inc eax
           End_If
           call 'USER32.SetDlgItemInt' D@Adressee 3 eax 0

    ...Else
       popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP



[hMemDC: 0    BitmapHandle: 0    hBitmap: 0]

[BMP: 0    BMPw: 0    BMPh: 0    BMPline: 011C    BMPplane: 0    BMPpixBits: 0   BMPptr: 0
 BitMapInfoHeader: 0    FileHeaderOffset: 0    BipMapCopyPtr: 0]

BitMapViewer:
    .If D$BitMapListPtr > BitMapList
        mov W$BitMapDialogControlsNumber 2
        call 'USER32.DialogBoxIndirectParamA' D$hinstance BitMapDialog  0  BitMapProc  0
        If B$UserValidateBitMap = &FALSE
            mov edi D$BitMapListPtr, eax 0 | stosd | stosd | stosd
        End_If
    .End_If
ret


[NoBitMap: B$ 'No BitMap in This file', 0]

[DeleteBitMapTitle: U$ 'Delete'  ShowBitMapTitle: 'Exit  ']

DeleteBitMap:
    mov edi BMPEXIT, esi DeleteBitMapTitle, ecx 12 | rep movsb
    mov W$BitMapDialogControlsNumber 5 | call BitMapView

    If B$UserValidateBitMap = &TRUE
        mov edi D$BitMapListPtr, esi edi | add esi 12
        While D$edi > 0
            movsd | movsd |movsd
        End_While
    End_If
ret


ShowBitMapsIds:
    mov edi BMPEXIT, esi ShowBitMapTitle, ecx 12 | rep movsb
    mov W$BitMapDialogControlsNumber 4 | call BitMapView
ret


BitMapView:
    mov D$BitMapListPtr BitMapList, eax D$BitMapListPtr

    If D$eax = 0
        mov B$UserValidateBitMap &FALSE
        call 'USER32.MessageBoxA' D$hwnd, NoBitMap, Argh, &MB_SYSTEMMODAL
    Else
        call 'USER32.DialogBoxIndirectParamA' D$hinstance, BitMapDialog, 0, BitMapProc, 0
    End_If
ret


[UserValidateBitMap: ?] [BitMapIdText: ? ? ? ?]

Proc BitMapProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND
         ..If D@wParam = &IDOK
             mov B$UserValidateBitMap &TRUE
             call 'User32.EndDialog' D@Adressee 0

         ..Else_If D@wParam = &IDCANCEL
             mov B$UserValidateBitMap &FALSE
             call 'User32.EndDialog' D@Adressee 0

         ..Else_If D@wParam = 3                        ; >>>>
             mov eax D$BitMapListPtr | add eax 12
             mov ebx MAXBITMAP | shl ebx 2 | add ebx BitMapList
             .If eax < ebx                             ; ebx = end of BitMapList
                If D$eax > 0
                    mov D$BitMapListPtr eax
                    call 'USER32.RedrawWindow' D@Adressee 0  0,
                                           &RDW_ERASE+&RDW_INVALIDATE+&RDW_INTERNALPAINT
                End_If
             .End_If

         ..Else_If D@wParam = 4                        ; <<<<
             If D$BitMapListPtr > BitMapList
                 sub D$BitMapListPtr 12
                 call 'USER32.RedrawWindow' D@Adressee 0  0,
                                           &RDW_ERASE+&RDW_INVALIDATE+&RDW_INTERNALPAINT
             End_If
       ..End_If

    ...Else_If D@Message = &WM_PAINT

         call 'User32.BeginPaint'  D@Adressee  PAINTSTRUCT
             mov D$hdc eax
             call 'GDI32.CreateCompatibleDC' D$hdc | mov D$hMemDC eax

             mov esi D$BitMapListPtr | lodsd          ; ID
             call SetBitMapIdText D@Adressee
             lodsd | mov edi eax                      ; > edi > adress
             lodsd                                    ; eax = lenght
             mov esi edi, ebx D$esi+20                ; ebx = image size
             sub eax ebx | add eax edi                ; eax > ptr to bmp data

             call 'GDI32.CreateDIBitmap' D$hdc  edi  &CBM_INIT  eax  edi  &DIB_RGB_COLORS
                 mov D$hBitmap eax
                 call 'GDI32.SelectObject' D$hMemDC D$hBitmap
                 call 'User32.GetClientRect' D@Adressee RECT
                 call 'GDI32.BitBlt' D$hdc 0 0 D$Rect_Right D$Rect_bottom D$hMemDC 0 0 &SRCCOPY
             call 'GDI32.DeleteDC' D$hMemDC
         call 'User32.EndPaint' D@Adressee PAINTSTRUCT
         call 'GDI32.DeleteObject' D$hBitmap

    ...Else_If D@Message = &WM_INITDIALOG
        mov D$BitMapListPtr BitMapList
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon

    ...Else
       popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP


Proc SetBitMapIdText:
    Argument @Adressee

    pushad
        push 0_FFFF_FFFF
        mov edi BitMapIdText, ecx 10
L0:     mov edx 0 | div ecx | cmp eax 0 | je L2>
            push edx | jmp L0<
L2:         push edx
L2:     pop eax | cmp eax 0_FFFF_FFFF | je L3>
            add al '0' | stosb | jmp L2<
L3:     mov al 0 | stosb
        call 'USER32.GetDlgItem' D@Adressee 5
        call 'USER32.SetWindowTextA' eax BitMapIdText
    popad
EndP


[BitMapDialog: D$ 0900408C2 0  ; Style
 BitMapDialogControlsNumber:
 U$ 02 0 0 0DC 0C8             ; Dim
 0                             ; Menu
 '' 0                           ; Class
 'New Dialog' 0                ; Title
 08 'Helv' 0]                  ; Font

[BMD0: D$ 050000001 0      ; Style
 U$ 0AB 0B9 030 0F             ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 BMPEXIT:
 'Delete' 0                        ; Title
 0]                            ; No creation data

[BMD2: D$ 050000000 0      ; Style
 U$ 04E 0B9 029 0F             ; Dim
 03                            ; ID
 0FFFF 080                     ; Class
 '>>>>' 0                      ; Title
 0]                            ; No creation data

[BMD3: D$ 050000000 0      ; Style
 U$ 0 0B8 029 010              ; Dim
 04                            ; ID
 0FFFF 080                     ; Class
 '<<<<' 0                      ; Title
 0]                            ; No creation data

[BMD4: D$ 050000307 0      ; Style
 U$ 02B 0B7 01F 010            ; Dim
 05                            ; ID
 0FFFF 080                     ; Class
 '65000' 0                     ; Title
 0]                            ; No creation data

[BMD1: D$ 050000000 0      ; Style
 U$ 079 0B9 030 0F             ; Dim
 02                            ; ID
 0FFFF 080                     ; Class
 'Abort' 0                     ; Title
 0]                            ; No creation data





TITLE Command

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  Allows to pass commandlines to the debuggee. Command line options are loaded from text 
  files that have the same path and filename (with the extension '.CLO') as the destination 
  file. If there is no such file the app path is just copied to the buffer. 

  e.g. If DestinationFile is "D:\ping.EXE" and 'D:\ping.CLO' contains 
  "111.42.23.17" then CommandLine is set to "D:\ping.EXE 111.42.23.17". 
  If no CLO file exists CommandLine is set to "D:\ping.EXE".
  
  23-Oct-03 Ludwig Haehne - wkx@gmx.li
  
  28-Jun-04 - ExeName put in brackets
  
  11-Nov-04 - Complete rewrite - no 16k limit, deals with dll's
  
  26-Dec-04 - Separate the command line from the executable path and filename
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

; Setup the command line. The address of the string or zero is returned in eax.
; The buffer for the command line is allocated by SetupCommandLine and must be freed by the
; caller after use. Attention: Only free CommandLinePtr! The address returned in eax
; might point to a static buffer!

[CommandLinePtr: ?]
[ScreensaverCommandLine: '/S' 0]
[BytesTransfered: ?]

Proc SetupCommandLine:
    Local @hFile, @Size
    Uses esi edi

        call GetCLOFilename
        call 'Kernel32.CreateFileA' CommandLineFile, &GENERIC_READ, &FILE_SHARE_READ,
                        &NULL, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, &NULL

        ; In general no clo file will be provided, if we deal with a screensaver put
        ; a /S command as a default command and exit proc
        .If eax = &INVALID_HANDLE_VALUE
            If D$SavingExtension = '.SCR'
                mov eax ScreensaverCommandLine
            Else
                mov eax 0
            EndIf
            ExitP
        .EndIf

        mov D@hFile eax

        ; Allocate buffer for commandline (must be freed by caller)
        call 'KERNEL32.GetFileSize' D@hFile, 0
        If eax = 0_FFFF_FFFF
            call ReportWinError {'SetupCommandLine: GetFileSize' 0}
            call 'Kernel32.CloseHandle' D@hFile
            mov eax 0
            ExitP
        EndIf
        mov D@Size eax

        VirtualAlloc CommandLinePtr D@Size
        mov edi D$CommandLinePtr

        ; Read the command line parameters from the file
        call 'Kernel32.ReadFile' D@hFile, edi, D@Size, BytesTransfered, &NULL
        add edi D$BytesTransfered
        mov B$edi 0

        call 'Kernel32.CloseHandle' D@hFile
        mov eax D$CommandLinePtr
EndP
____________________________________________________________________________________________

[CommandLineFile: B$ ? #&MAXPATH]

GetCLOFilename:
    mov esi MainName, edi CommandLineFile
    While B$esi <> 0
        movsb
    End_While
    mov D$edi '.clo', B$edi+4 0 ; append extension
ret
____________________________________________________________________________________________

; To allow to set the commandline inside the IDE I added an edit control in the output
; dialog and this code in section Format.
;
; These two are called at 'InitOutputDialog' and 'SaveOutputFormat':

Proc LoadCommandLine:
    Local @hFile, @Size

        call GetCLOFilename ; Copy filename to buffer
        call 'Kernel32.CreateFileA' CommandLineFile, &GENERIC_READ, &FILE_SHARE_READ,
                        &NULL, &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, &NULL
        mov D@hFile eax
        .If eax = &INVALID_HANDLE_VALUE
            call 'User32.SetDlgItemTextA' D$OutputHandle, 214, 0 ; clear edit
        .Else
            call 'KERNEL32.GetFileSize' D@hFile, 0
            On eax = 0_FFFF_FFFF, ExitP
            mov D@Size eax

            VirtualAlloc CommandLinePtr D@Size

                call 'Kernel32.ReadFile' D@hFile, D$CommandLinePtr, D@Size, BytesTransfered, &NULL
                mov eax D$CommandLinePtr | add eax D$BytesTransfered | mov B$eax 0
                call 'Kernel32.CloseHandle' D@hFile
                call 'User32.SetDlgItemTextA' D$OutputHandle, 214, D$CommandLinePtr

            VirtualFree D$CommandLinePtr
        .End_If

EndP
____________________________________________________________________________________________

Proc SaveCommandLine:
    Local @hFile, @Size

        ; If string is empty, delete CLO file if it exists
        call 'User32.SendDlgItemMessageA' D$OutputHandle, 214, &WM_GETTEXTLENGTH, 0, 0
        mov D@Size eax
        If eax = 0
            call GetCLOFilename
            call 'Kernel32.DeleteFileA' CommandLineFile
            ExitP
        End_If

        VirtualAlloc CommandLinePtr D@Size

        call GetCLOFilename ; Copy filename
        call 'Kernel32.CreateFileA' CommandLineFile, &GENERIC_WRITE, &FILE_SHARE_READ,
                        &NULL, &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, &NULL
        mov D@hFile eax
        If eax <> &INVALID_HANDLE_VALUE
            ; Copy commandline from edit to buffer and write it into the file
            mov eax D@Size | inc eax
            call 'User32.GetDlgItemTextA' D$OutputHandle, 214, D$CommandLinePtr, eax
            call 'Kernel32.WriteFile' D@hFile, D$CommandLinePtr, eax, BytesTransfered, &NULL
            call 'Kernel32.CloseHandle' D@hFile
        End_If

        VirtualFree D$CommandLinePtr
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________




TITLE DebugGUI

;;
_____________________________________________________________________________________________

                                  Debugger GUI - Ludwig Haehne
 
 Split from the debugger title for better readability.
   
 TODO:

    * Save upper & lower tab selection
    * Memory inspector address edit should handle expressions (mouse hint code reuse)    
    * Hints for toolbar buttons    
    * Context menu in address space tree (?)
    * Next instruction indicator in source editor    
    * Separate the debug dialog from the main window (but stay on top)
    * Log Exceptions (also auto-forwarded)
    * Save to file for log (from context menu)
    * Watch tab (expression-entry; add,remove&clear button; list/tree view)
    * Disassembly tab
    * Restore defaults (set flag to delete debug.cfg at the end)
    * Recover toolbar when all bands are hidden
    * Nice FPU box
    * Nice CPU Info
    * Review code address form
    * Q$ / X$ / U$ (+string) support in mousehint
    * Sane menu/combo font (registry?) (test under wine)    
    * Address Space Tree vs. Nessie
____________________________________________________________________________________________

 Paragraphs
  
  * 'CreateDebugWindow' 'DebuggerMENU' 'DebuggerTOOLBAR' 'DebuggerMOUSEHINT' 
    'DebuggerSTRINGS'
  
 Dialogs
 
  * 'DebugDlgProc', 'DataViewProc', 'MemoryInspectorProc', 'PageTableProc', 'CallStackProc',
    'MouseOverDataHint', 'ExceptionInfoProc', 'AddressSpaceFormProc', 'LogFormProc'
 
 Window handling
 
  * 'AdjustControlSize', 'AdjustControlPos', 'SelectTab', 'ReportWinError'
  
 Misc routines
 
  * 'SourceDebugPos', 'NextInstructionDecode', 'IsMultiStepInstruction', 'TestCPUFeatures'    
   
 Format Conversion Procs
 
  * 'toHex', ...

;;
____________________________________________________________________________________________

; GENERAL WINDOW HANDLING PROCS
____________________________________________________________________________________________

[WINDOW_RESIZE  &SWP_NOMOVE+&SWP_NOZORDER+&SWP_NOACTIVATE]
[WINDOW_MOVE    &SWP_NOSIZE+&SWP_NOZORDER+&SWP_NOACTIVATE]

Proc AdjustControlSize:
    Arguments @Handle, @ID, @dX, @dY
    Structure @RECT 16, @left 0, @top 4, @right 8, @bottom 12
    Uses ebx, esi, edi

        mov edi D@RECT
        call 'USER32.GetDlgItem' D@Handle D@ID | mov ebx eax
        ; Compute current width (eax) & height (esi) and add delta's
        call 'USER32.GetWindowRect' ebx edi
        mov eax D@right
        sub eax D@left
        add eax D@dX
        mov esi D@bottom
        sub esi D@top
        add esi D@dY
        call 'USER32.SetWindowPos' ebx, 0, 0, 0, eax, esi, WINDOW_RESIZE
        ; Return height error for listboxes.
        call 'USER32.GetWindowRect' ebx edi
        mov eax D@bottom
        sub eax D@top
        sub eax esi
EndP
____________________________________________________________________________________________

Proc AdjustControlPos:
    Arguments @Handle, @ID, @dX, @dY
    Structure @RECT 16, @left 0, @top 4, @right 8, @bottom 12
    Uses ebx, edi

        mov edi D@RECT
        call 'USER32.GetDlgItem' D@Handle D@ID | mov ebx eax
        ; Compute current xpos (eax) & ypos (ecx) and add delta's
        call 'USER32.GetWindowRect' ebx, edi
        call 'USER32.ScreenToClient' D@Handle, edi
        mov eax D@left
        add eax D@dX
        mov ecx D@top
        add ecx D@dY
        call 'USER32.SetWindowPos' ebx, 0, eax, ecx, 0, 0, WINDOW_MOVE
EndP
____________________________________________________________________________________________

Proc ReportWinError:
    Arguments @Caption
    Local @String

        call 'Kernel32.GetLastError'
        mov edx (&SUBLANG_DEFAULT shl 16 or &LANG_NEUTRAL)
        lea ecx D@String
        call 'Kernel32.FormatMessageA' &FORMAT_MESSAGE_ALLOCATE_BUFFER+&FORMAT_MESSAGE_FROM_SYSTEM,
            &NULL, eax, edx, ecx, 256, &NULL
        call 'User32.MessageBoxA' D$hwnd, D@String, D@Caption, &MB_ICONERROR
        call 'Kernel32.LocalFree' D@String
EndP
____________________________________________________________________________________________

Proc SelectTab:
    Arguments @DlgHandle, @TabCtrlID, @Index
    Structure @NotifyMsg 12, @Handle 0, @ID 4, @Code 8
    Uses ebx

        call 'User32.GetDlgItem' D@DlgHandle, D@TabCtrlID
        mov ebx eax

        SendMessage ebx, &TCM_SETCURSEL, D@Index, 0
        mov D@Handle ebx
        move D@ID D@TabCtrlID
        mov D@Code &TCN_SELCHANGE
        SendMessage D@DlgHandle, &WM_NOTIFY, D@TabCtrlID, D@NotifyMsg ; for Win9x!
        call 'User32.PostMessageA' D@DlgHandle, &WM_NOTIFY, D@TabCtrlID, D@NotifyMsg
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; ADDRESS SPACE TREE
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc CreateNewForm_AddressSpaceForm:
    Arguments @Parent

    call 'User32.RegisterClassExA' ASFormClass
    call 'User32.CreateWindowExA',
        &WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
        ASFormClassName,
        {"Main Window",0},
        &WS_CHILD,
        0,0,100,200,
        D@Parent,
        0,
        D$hInstance,
        0
    mov D$ASForm_handle eax
    [ASForm_handle: ?]

    call 'User32.CreateWindowExA',
        &WS_EX_CLIENTEDGE+&WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
        {"SysTreeView32",0},
        {"New Control",0},
        &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE+&TVS_FULLROWSELECT+&TVS_HASBUTTONS+&TVS_HASLINES+&TVS_LINESATROOT+&TVS_TRACKSELECT,
        0,0,100,200,
        D$ASForm_handle,
        2,
        D$hInstance,
        0

    mov D$ASForm.Tree_handle eax
    [ASForm.Tree_handle: ?]

EndP

[ASFormClass:
 @cbSize:        D$ len
 @style:         D$ 0
 @lpfnWndProc:   D$ AddressSpaceFormProc
 @cbClsExtra:    D$ 0
 @cbWndExtra:    D$ 0
 @hInstance:     D$ 0
 @hIcon:         D$ 0
 @hCursor:       D$ 0
 @hbrBackground: D$ 1
 @lpszMenuName:  D$ 0
 @lpszClassName: D$ ASFormClassName
 @hIconSm:       D$ 0]
[ASFormClassName: B$ "AddressSpaceForm" 0]

Proc AddressSpaceFormProc:
    Arguments @handle @Message @wParam @lParam
    Uses esi edi ebx

    .If D@Message = &WM_CREATE
        mov D$AddressSpace.TVProc 0
        mov eax 0

    .Else_If D@Message = &WM_CLOSE
        call 'USER32.DestroyWindow' D@handle

    .Else_if D@Message = &WM_SIZE
        movzx ecx W@lParam
        movzx edx W@lParam+2

        call 'USER32.SetWindowPos' D$ASForm.TreeHandle, 0, 0, 0, ecx, edx, WINDOW_RESIZE

    .Else_if D@Message = &WM_SETFONT
        SendMessage D$ASForm.TreeHandle, &WM_SETFONT, D@wParam, D@lParam

    .Else_if D@Message = WM_REFRESH_CONTENT
        call AddressSpaceTree_Build

    .Else_if D@Message = &WM_SHOWWINDOW
        If D$AddressSpace.TVProc = 0
            call AddressSpaceForm_OverrideTreeProc
        EndIf
        If D@wParam = &TRUE
            call AddressSpaceTree_Build
        EndIf

    .Else_if D@Message = &WM_NOTIFY
        mov eax D@lParam, edx D$ASForm.TreeHandle
        If D$eax = edx
            call AddressSpaceForm_OnTreeNavigate eax
        EndIf
        mov eax 0

    .Else
        call 'User32.DefWindowProcA' D@handle D@Message D@wParam D@lParam
    .End_If
EndP
____________________________________________________________________________________________

[ASForm.CurrentItem: ? ASForm.CurrentAddress: ?]

Proc AddressSpaceForm_OnTreeNavigate:
    Arguments @NotifyInfo
    Uses esi ebx

    mov esi D@NotifyInfo
    On D$esi+8 <> &TVN_SELCHANGED, ExitP
    add esi 12 ; skip notify header
    add esi 4 ; skip action flag
    add esi 40 ; skip old item
    mov eax D$esi+4 ; hItem
    mov D$ASForm.CurrentItem eax
    mov ebx D$esi+36 ; lParam of new item
    mov D$ASForm.CurrentAddress ebx

EndP

____________________________________________________________________________________________

; To allow rightclick inside the treeview we override the window proc.

AddressSpaceForm_OverrideTreeProc:
    mov D$AddressSpace.TVProc 0
    call 'User32.SetWindowLongA' D$ASForm.Tree_handle, &GWL_WNDPROC, AddressSpace_HandleMouseProc
    mov D$AddressSpace.TVProc eax
ret

[AddressSpace.TVProc: ?]

Proc AddressSpace_HandleMouseProc:
    Arguments @Handle, @Message, @wParam, @lParam
    Uses ebx esi edi

    .If D@Message = &WM_LBUTTONDBLCLK
      ; Simulate left click (select item) before showing the popup menu
        SendMessage D@Handle, &WM_LBUTTONDOWN, D@wParam, D@lParam
        SendMessage D@Handle, &WM_LBUTTONUP, D@wParam, D@lParam
      ; Is this a page item?
        cmp D$ASForm.CurrentAddress 0 | je L0>
      ; Check if the user clicked onto the item
        move D$DebugRect D$ASForm.CurrentItem
        SendMessage D@Handle, &TVM_GETITEMRECT, 1, DebugRect
        movzx eax W@lParam
        cmp eax D$DebugRect@left  | jl L0>
        cmp eax D$DebugRect@right | ja L0>
        movzx eax W@lParam+2
        cmp eax D$DebugRect@top    | jl L0>
        cmp eax D$DebugRect@bottom | ja L0>
      ; Show the popup menu at the position of the mouse-click
        SendMessage D$MemoryInspectorHandle, WM_SET_PAGE, D$ASForm.CurrentAddress, 0
    .EndIf
L0: call 'User32.CallWindowProcA' D$AddressSpace.TVProc, D@Handle, D@Message, D@wParam, D@lParam
EndP
____________________________________________________________________________________________

[PageDesc: B$ ? #64]

Proc AddressSpaceTree_WritePageDescription:
    Arguments @Address, @Protect
    Uses esi, edi

      ; Write address
        mov eax D@Address, edi PageDesc, ecx 4
        DwordToHex eax

      ; Write protection "XRWC GN"
        mov al ' ' | stosb
        mov ecx D@Protect

        mov D$edi '----', D$edi+4 ' -- '
        If ecx = &PAGE_READONLY
            mov B$edi+1 'R'
        Else_if ecx = &PAGE_READWRITE
            mov W$edi+1 'RW'
        Else_if ecx = &PAGE_EXECUTE
            mov B$edi 'X'
        Else_if ecx = &PAGE_EXECUTE_READ
            mov W$edi 'XR'
        Else_if ecx = &PAGE_EXECUTE_READWRITE
            mov D$edi 'XRW-'
        Else_if ecx = &PAGE_EXECUTE_WRITECOPY
            mov D$edi 'XRWC'
        Else_if ecx = &PAGE_WRITECOPY
            mov D$edi '-RWC'
        EndIf
        test ecx &PAGE_GUARD | jz L0>
        mov B$edi+5 'G'
L0:     test ecx &PAGE_NOCACHE | jz L0>
        mov B$edi+6 'N'

L0:     add edi 8
        mov D$edi 0
EndP
____________________________________________________________________________________________

Proc AddressSpaceTree_AddPages:
    Arguments @Base, @Size, @Protect, @Type
    Uses esi, edi

      ; Add item for each commited page in region
        mov esi D@Base, edi esi
        add edi D@Size

        While esi < edi
            call AddressSpaceTree_WritePageDescription esi, D@Protect
            mov D$TVI.Item.lParam esi
            mov D$TVI.Item.pszText PageDesc
            SendMessage D$ASForm.Tree_handle, &TVM_INSERTITEM, 0, TVI
            add esi 01000
        EndWhile
EndP
____________________________________________________________________________________________

Proc AddressSpaceTree_AddModule:
    Arguments @ModEntry
    Local @LowerBound, @UpperBound, @hModItem
    Uses esi, ebx

        mov esi D@ModEntry

        mov D$TVI.hParent &TVI_ROOT
        mov eax D$esi+ME_Name
        mov D$TVI.Item.pszText eax
        move D$TVI.Item.lParam 0

        SendMessage D$ASForm.Tree_handle, &TVM_INSERTITEM, 0, TVI
        mov D@hModItem eax

        mov eax D$esi+ME_Base
        mov D@LowerBound eax
        add eax D$esi+ME_Size
        mov D@UpperBound eax

        mov ebx D@LowerBound
        .While ebx < D@UpperBound
            call VirtualQuery ebx
            .If eax = &TRUE
                If ebx = D$esi+ME_CodeBase
                    mov D$TVI.Item.pszText {'Code Section' 0}
                    mov D$TVI.Item.lParam 0
                    SendMessage D$ASForm.Tree_handle, &TVM_INSERTITEM, 0, TVI
                    mov D$TVI.hParent eax
                Else
                    move D$TVI.hParent D@hModItem
                EndIf
                call AddressSpaceTree_AddPages ebx, D$MemoryInformation@RegionSize, D$MemoryInformation@Protect, D$MemoryInformation@Type
            .ElseIf eax = 0-1
                ExitP
            .EndIf
            add ebx D$MemoryInformation@RegionSize
        .EndWhile

;;
        mov D$TVI.Item.pszText {'Code Section' 0}
        move D$TVI.Item.lParam D$esi+ME_CodeBase
        

        mov D$TVI.Item.pszText {'Export Section' 0}
        mov eax D$esi+ME_ExportBase
        add eax D$esi+ME_Base
        mov D$TVI.Item.lParam eax
        SendMessage D$ASForm.Tree_handle, &TVM_INSERTITEM, 0, TVI
;;

      ; The AS scanner should continue behind the module mapping area
        move D$MemoryInformation@RegionSize D$esi+ME_Size
EndP
____________________________________________________________________________________________

Proc AddressSpaceTree_AddGeneralRegion:
    Arguments @Base, @Size, @Protect, @Type

    [@LastAllocBase: ?]

      ; Check if the region belongs to the last added allocation block, otherwise
      ; add a new top-level item.
        mov eax D$MemoryInformation@AllocationBase
        If D@LastAllocBase <> eax
            mov D@LastAllocBase eax
            call IntToHexString
            mov D$TVI.hParent &TVI_ROOT
            mov D$TVI.Item.pszText HexString
            mov D$TVI.Item.lParam 0
            SendMessage D$ASForm.Tree_handle, &TVM_INSERTITEM, 0, TVI
            mov D$TVI.hParent eax
        EndIf

      ; Add item for each commited page in region
        call AddressSpaceTree_AddPages D@Base, D@Size, D@Protect, D@Type
EndP
____________________________________________________________________________________________

; Add a memory region returned by VirtualQuery

Proc AddressSpaceTree_AddRegion:
    Arguments @Base, @Size, @Protect, @Type

        mov eax D$MemoryInformation@BaseAddress
        mov D$TVI.Item.lParam eax

      ; Check if this region is a mapped module
        call GetModuleName eax
        If eax <> 0
            call AddressSpaceTree_AddModule edx
        Else
            call AddressSpaceTree_AddGeneralRegion D@Base, D@Size, D@Protect, D@Type
        EndIf
EndP
____________________________________________________________________________________________

Proc AddressSpaceTree_Build:

    SendMessage D$ASForm.TreeHandle, &TVM_DELETEITEM, 0, &TVI_ROOT
    SendMessage D$ASForm.Tree_handle, &WM_SETREDRAW, 0, 0

    mov D$TVI.hParent &TVI_ROOT
    mov D$TVI.hInsertAfter &TVI_LAST
    mov D$TVI.Item.imask &TVIF_TEXT+&TVIF_PARAM

    mov esi D$AddressLowerBound
    While esi < D$AddressUpperBound
        call VirtualQuery esi
        If eax = 1
            call AddressSpaceTree_AddRegion esi, ecx,
                D$MemoryInformation@Protect, D$MemoryInformation@Type
        ElseIf eax = 0-1
            ExitP
        EndIf
        add esi D$MemoryInformation@RegionSize
    EndWhile

    SendMessage D$ASForm.Tree_handle, &WM_SETREDRAW, 1, 0
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; EVENT LOG
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc CreateNewForm_LogForm:
    Arguments @Parent

    call 'User32.RegisterClassExA' LogFormClass
    call 'User32.CreateWindowExA',
        &WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
        LogFormClassName,
        {"Main Window",0},
        &WS_CHILD+&WS_VISIBLE,
        0,0,100,200,
        D@Parent,
        0,
        D$hInstance,
        0
    mov D$LogForm_handle eax
    [LogForm_handle: ?]

    call 'User32.CreateWindowExA',
        &WS_EX_CLIENTEDGE+&WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
        {"LISTBOX",0},
        {"New Control",0},
        &WS_CHILD+&WS_CLIPSIBLINGS+&WS_OVERLAPPED+&WS_VISIBLE+&WS_VSCROLL+&LBS_NOINTEGRALHEIGHT,
        0,0,100,200,
        D$LogForm_handle,
        2,
        D$hInstance,
        0
    mov D$LogForm.List_handle eax
    [LogForm.List_handle: ?]

EndP
____________________________________________________________________________________________
[LogFormClass:
 @cbSize:        D$ len
 @style:         D$ 0
 @lpfnWndProc:   D$ LogFormProc
 @cbClsExtra:    D$ 0
 @cbWndExtra:    D$ 0
 @hInstance:     D$ 0
 @hIcon:         D$ 0
 @hCursor:       D$ 0
 @hbrBackground: D$ 1
 @lpszMenuName:  D$ 0
 @lpszClassName: D$ LogFormClassName
 @hIconSm:       D$ 0]
[LogFormClassName: B$ "LogForm" 0]
____________________________________________________________________________________________

Proc LogFormProc:
    Arguments @handle @Message @wParam @lParam
    Uses esi edi ebx

    .If D@Message = &WM_CREATE
        mov eax 0

    .Else_If D@Message = &WM_CLOSE
        call 'USER32.DestroyWindow' D@handle

    .Else_if D@Message = &WM_SIZE
        movzx ecx W@lParam
        movzx edx W@lParam+2

        call 'USER32.SetWindowPos' D$LogForm.ListHandle, 0, 0, 0, ecx, edx, WINDOW_RESIZE

    .Else_If D@Message = WM_LOG

        mov edi LogString
        call TimeToStr
        mov al ' ' | stosb

        mov esi D@wParam, ecx D@lParam
        On ecx > 255, mov ecx 255
        If ecx = 0
            While B$esi+ecx <> 0 | inc ecx | EndWhile
        EndIf
        While ecx > 0
            lodsb
            On al <> 0A, stosb
            dec ecx
        EndWhile
        ;rep movsb
        mov B$edi 0
        SendMessage D$LogForm.ListHandle, &LB_ADDSTRING, 0, LogString
        SendMessage D$LogForm.ListHandle, &LB_SETCURSEL, eax, 0

    .Else_If D@Message = &WM_DESTROY

    .Else_if D@Message = &WM_SETFONT
        SendMessage D$LogForm.ListHandle, &WM_SETFONT, D@wParam, D@lParam

    .Else
        call 'User32.DefWindowProcA' D@handle D@Message D@wParam D@lParam
    .End_If
EndP

[LogString: B$ ? #256]
____________________________________________________________________________________________
____________________________________________________________________________________________

; ADDRESS INPUT
____________________________________________________________________________________________
____________________________________________________________________________________________

; Tag Wizard Form "J:\Projects\RosAsm\WizardFiles\WZRDForm0000.wwf"
CreateNewForm_CodeAddressForm:
    call 'ComCtl32.InitCommonControlsEx' CodeAddressFormClassName@Init_All_Common_Controls
    call 'User32.RegisterClassExA' CodeAddressFormClass
    call 'User32.CreateWindowExA',
        &WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
        CodeAddressFormClassName,
        {"Show code at address ...",0},
        &WS_BORDER+&WS_CAPTION+&WS_DLGFRAME+&WS_OVERLAPPED+&WS_POPUP+&WS_VISIBLE+&NULL,
        82,35,282,100,
        0,
        0,
        D$hInstance,
        0
    mov D$CodeAddressForm_handle eax
    [CodeAddressForm_handle: ?]
    call 'GDI32.CreateFontIndirectA' CodeAddressForm_LOGFONTSTRUCT | mov D$CodeAddressFormFont_handle eax
    call 'User32.SendMessageA' D$CodeAddressForm_handle  &WM_SETFONT eax &TRUE
    [CodeAddressFormFont_handle: ?]
    [CodeAddressForm_LOGFONTSTRUCT:  0  0  0  0  0  0  536870912 'MS Sans Serif' 0 0 0 0 0 0 ]
    CodeAddressForm:

    call 'User32.CreateWindowExA',
        &WS_EX_CLIENTEDGE+&WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
        {"BUTTON",0},
        {"Show statement",0},
        &WS_CHILD+&WS_CLIPSIBLINGS+&WS_OVERLAPPED+&WS_VISIBLE+&BS_PUSHBUTTON+&BS_TEXT,
        159,22,101,28,
        D$CodeAddressForm_handle,
        2,
        D$hInstance,
        0
    mov D$CodeAddressForm.GotoButton_handle eax
    [CodeAddressForm.GotoButton_handle: ?]
    call 'GDI32.CreateFontIndirectA' CodeAddressForm.GotoButton_LOGFONTSTRUCT | mov D$CodeAddressForm.GotoButtonFont_handle eax
    call 'User32.SendMessageA' D$CodeAddressForm.GotoButton_handle  &WM_SETFONT eax &TRUE
    [CodeAddressForm.GotoButtonFont_handle: ?]
    [CodeAddressForm.GotoButton_LOGFONTSTRUCT:  -11  0  0  0  400  0  570491393 'MS Sans Serif' 0 0 0 0 0 0 ]

    call 'User32.CreateWindowExA',
        &WS_EX_CLIENTEDGE+&WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
        {"EDIT",0},
        {"",0},
        &WS_CHILD+&WS_CLIPSIBLINGS+&WS_OVERLAPPED+&WS_VISIBLE+&ES_LEFT+&ES_RIGHT+&ES_UPPERCASE,
        22,25,125,21,
        D$CodeAddressForm_handle,
        3,
        D$hInstance,
        0
    mov D$CodeAddressForm.AddressEdit_handle eax
    [CodeAddressForm.AddressEdit_handle: ?]
    call 'GDI32.CreateFontIndirectA' CodeAddressForm.AddressEdit_LOGFONTSTRUCT | mov D$CodeAddressForm.AddressEditFont_handle eax
    call 'User32.SendMessageA' D$CodeAddressForm.AddressEdit_handle  &WM_SETFONT eax &TRUE
    [CodeAddressForm.AddressEditFont_handle: ?]
    [CodeAddressForm.AddressEdit_LOGFONTSTRUCT:  -13  0  0  0  400  0  822149635 'Courier New' 0 0 0 0 0 0 ]

ret
____________________________________________________________________________________________
[CodeAddressFormClass:
 @cbSize:        D$ len
 @style:         D$ 0
 @lpfnWndProc:   D$ CodeAddressFormProc
 @cbClsExtra:    D$ 0
 @cbWndExtra:    D$ 0
 @hInstance:     D$ 0
 @hIcon:         D$ 0
 @hCursor:       D$ 0
 @hbrBackground: D$ 1
 @lpszMenuName:  D$ 0
 @lpszClassName: D$ CodeAddressFormClassName
 @hIconSm:       D$ 0]
[CodeAddressFormClassName: B$ "CodeAddressForm" 0]
[@Init_All_Common_Controls:
 @Init_All_Common_Controls_dwSize: D$ len
 @Init_All_Common_Controls_dwICC:  D$ &ICC_COOL_CLASSES+&ICC_DATE_CLASSES+&ICC_INTERNET_CLASSES+&ICC_NATIVEFNTCTL_CLASS,
             +&ICC_PAGESCROLLER_CLASS+&ICC_USEREX_CLASSES+&ICC_WIN95_CLASSES]
____________________________________________________________________________________________

Proc CodeAddressFormProc:
    Arguments @handle @Message @wParam @lParam

    pushad

    ...If D@Message = &WM_CREATE

    ...Else_If D@Message = &WM_CLOSE
        call 'GDI32.DeleteObject' D$CodeAddressFormFont_handle
        call 'GDI32.DeleteObject' D$CodeAddressForm.GotoButtonFont_handle
        call 'GDI32.DeleteObject' D$CodeAddressForm.AddressEditFont_handle
        call 'USER32.DestroyWindow' D@handle

    ...Else_if D@Message = &WM_COMMAND
        mov eax D@lParam
        If eax = D$CodeAddressForm.GotoButton_handle
            call CodeAddressForm_Goto
        EndIf

    ...Else
        popad
        call 'User32.DefWindowProcA' D@handle D@Message D@wParam D@lParam
        ExitP

    ...End_If

    popad
    mov eax &FALSE

EndP
; Tag End
;;
    ...Else_if D@Message = &WM_COMMAND
        mov eax D@lParam
        If eax = D$CodeAddressForm.GotoButton_handle
            call CodeAddressForm_Goto
        EndIf
;;


CodeAddressForm_Goto:
    call 'User32.GetWindowTextA' D$CodeAddressForm.AddressEdit_handle, HexString, 10
    mov esi HexString
    call HexStringToInt
    mov ebx eax

    call IsProcessCode ebx
    If eax = &TRUE
        call SourceDebugPos ebx
    Else
        call 'User32.MessageBoxA' D$CodeAddressForm_Handle, {'This is not a valid code address!' 0},
            {'Invalid address' 0}, &MB_ICONWARNING
    EndIf
    SendMessage D$CodeAddressForm_Handle, &WM_CLOSE, 0, 0
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; CALL STACK
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc CreateNewForm_CallStackForm:
    Arguments @Parent

    call 'User32.RegisterClassExA' CSFormClass
    call 'User32.CreateWindowExA',
        &WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
        CSFormClassName,
        {"Callstack",0},
        &WS_CHILD,
        0,0,100,200,
        D@Parent,
        0,
        D$hInstance,
        0

    mov D$CallStackFormHandle eax

    call 'User32.CreateWindowExA',
        &WS_EX_CLIENTEDGE+&WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
        {"SysTreeView32",0},
        {"New Control",0},
        &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE+&TVS_FULLROWSELECT+&TVS_HASBUTTONS+&TVS_HASLINES+&TVS_LINESATROOT+&TVS_TRACKSELECT,
        0,0,100,200,
        D$CallStackFormHandle,
        CALLSTACK_TREE,
        D$hInstance,
        0

    mov D$CallStackTreeHandle eax

    call CallStack_OverrideTreeProc
EndP

[CSFormClass:
 @cbSize:        D$ len
 @style:         D$ 0
 @lpfnWndProc:   D$ CallStackProc
 @cbClsExtra:    D$ 0
 @cbWndExtra:    D$ 0
 @hInstance:     D$ 0
 @hIcon:         D$ 0
 @hCursor:       D$ 0
 @hbrBackground: D$ 1
 @lpszMenuName:  D$ 0
 @lpszClassName: D$ CSFormClassName
 @hIconSm:       D$ 0]
[CSFormClassName: B$ "CallStackForm" 0]
____________________________________________________________________________________________

; Process WM_CREATE message.

Proc CallStackDialog_OnCreate:
    Arguments @Handle

        move D$CallStackFormHandle D@Handle

        call 'USER32.GetClientRect' D@Handle, DebugRect
        move W$CallStackForm.Width W$DebugRect@width
        move W$CallStackForm.Height W$DebugRect@height

        call CallStack_CreatePopupMenu

        mov eax &TRUE
EndP
____________________________________________________________________________________________

; Process WM_SIZE message.

Proc CallStackDialog_OnSize:
    Arguments @Handle, @WidthHeight

        movzx eax W$CallStackForm.Width
        movzx esi W@WidthHeight
        sub esi eax
        movzx eax W$CallStackForm.Height
        movzx edi W@WidthHeight+2
        sub edi eax
        call AdjustControlSize D@Handle, CALLSTACK_TREE, esi, edi
        ;call AdjustControlPos D@Handle, CALLSTACK_SHOWDECLARATION, 0, edi
        ;call AdjustControlPos D@Handle, CALLSTACK_SHOWEVOKE, 0, edi
        call 'USER32.InvalidateRect' D@Handle, &NULL, &TRUE

        move D$CallStackFormSize D@WidthHeight
        mov eax 0
EndP
____________________________________________________________________________________________

; Process WM_COMMAND message.

Proc CallStackDialog_OnCommand:
    Arguments @Handle, @wParam, @lParam

        movzx ecx W@wParam
        movzx eax W@wParam+2
        mov ebx D$CallStack.PopupMenu

        .If ecx = MCS_SHOW_INVOKE
            call CallStackForm_ShowEvoke

        .Else_if ecx = MCS_SHOW_DECL
            call CallStackForm_ShowDeclaration

        .ElseIf ecx = MCS_SHOW_ALL
            mov D$CallStackFilter ecx
            call 'USER32.CheckMenuRadioItem' ebx, MCS_SHOWALL, MCS_HIDE_INTRA,
               ecx, &MF_BYCOMMAND
            call CallStackForm_Refresh

        .ElseIf ecx = MCS_HIDE_EXTERNAL
            mov D$CallStackFilter ecx
            call 'USER32.CheckMenuRadioItem' ebx, MCS_SHOWALL, MCS_HIDE_INTRA,
               ecx, &MF_BYCOMMAND
            call CallStackForm_Refresh

        .ElseIf ecx = MCS_HIDE_INTRA
            mov D$CallStackFilter ecx
            call 'USER32.CheckMenuRadioItem' ebx, MCS_SHOWALL, MCS_HIDE_INTRA,
               ecx, &MF_BYCOMMAND
            call CallStackForm_Refresh

        .ElseIf ecx = MCS_SHOWLOCALS
            xor B$CallStackShowLocal 1
            mov eax D$CallStackShowLocal | shl eax 3
            call 'USER32.CheckMenuItem' ebx, MCS_SHOWLOCALS, eax
            call CallStackForm_Refresh

        .EndIf
        mov eax 0
EndP
____________________________________________________________________________________________

; Process CDDS_ITEMPREPAINT notification. ebx > NMTVCUSTOMDRAW

CallStackDialog_OnPaintItem:
    mov eax D$ebx+44 ; item param
    If eax <> 0

        mov al B$eax+CSE_Flags
        test al CSEF_EXTERNAL | jz L0>

        mov D$ebx+48 0_66_66_66 ; set text color to gray
    EndIf
L0: mov eax &CDRF_NEWFONT
ret
____________________________________________________________________________________________

; Process WM_NOTIFY message.

Proc CallStackDialog_OnNotify:
    Arguments @NotifyMsg

        mov ebx D@NotifyMsg

        .If D$ebx+8 = &NM_CUSTOMDRAW

            mov eax D$ebx+12 ; draw stage
            If eax = &CDDS_PREPAINT
                mov eax &CDRF_NOTIFYITEMDRAW
            Else eax = &CDDS_ITEMPREPAINT
                call CallStackDialog_OnPaintItem
            Else
                mov eax 0
            EndIf

        .ElseIf D$ebx+8 = &TVN_SELCHANGED
            call CallStackForm_OnTreeNavigate ebx
            mov eax 0

        .Else
            mov eax 0
        .EndIf
EndP
____________________________________________________________________________________________

; Tag Dialog 1015

[CallStackFormSize:
 CallStackForm.Width: W$ ?
 CallStackForm.Height: W$ ?]

[CallStackFormHandle: ? CallStackTreeHandle: ?
 CallStackShowDeclarationHandle: ? CallStackShowEvokeHandle: ?]

[CALLSTACK_TREE 20]

Proc CallStackProc:
    Arguments @handle @Message @wParam @lParam
    Uses ebx, esi, edi

    .If D@Message = &WM_CREATE
        call CallStackDialog_OnCreate D@Handle
        mov eax 0

    .Else_if D@Message = &WM_SHOWWINDOW
        If D@wParam = &TRUE
            call CallStackForm_Refresh
        EndIf

    .Else_if D@Message = &WM_CLOSE
        call 'USER32.DestroyWindow' D@Handle

    .Else_If D@Message = &WM_DESTROY
        call DestroyCallStack
        mov D$CallStackFormHandle 0

    .Else_If D@Message = &WM_SIZE
        call CallStackDialog_OnSize D@Handle, D@lParam

    .Else_if D@Message = &WM_COMMAND
        call CallStackDialog_OnCommand D@Handle, D@wParam, D@lParam

    .Else_if D@Message = &WM_NOTIFY
        call CallStackDialog_OnNotify D@lParam

    .Else_if D@Message = WM_REFRESH_CONTENT
        call CallStackForm_Refresh

    .Else_if D@Message = &WM_SETFONT
        SendMessage D$CallStackTreeHandle, &WM_SETFONT, D@wParam, D@lParam

    .Else_if D@Message = &WM_DRAWITEM
        If D@wParam = 0
            call DebugDialog_OnDrawMenuItem D@lParam
        EndIf
        mov eax 1

    .Else_if D@Message = &WM_MEASUREITEM
        mov eax D@lParam
        If D@wParam = 0
          ; menu
            call DebugDialog_OnMeasureMenuItem D@lParam
        EndIf
        mov eax 1

    .Else
        call 'User32.DefWindowProcA' D@handle D@Message D@wParam D@lParam
    .EndIf
EndP
____________________________________________________________________________________________

; To allow rightclick inside the treeview we override the window proc.

CallStack_OverrideTreeProc:
    mov D$CallStack.TVProc 0
    call 'User32.SetWindowLongA' D$CallStackTreeHandle, &GWL_WNDPROC, CallStack_InterceptRightClick
    mov D$CallStack.TVProc eax
ret

[CallStack.TVProc: ?]

Proc CallStack_InterceptRightClick:
    Arguments @Handle, @Message, @wParam, @lParam
    Uses ebx esi edi

    .If D@Message = &WM_RBUTTONDOWN
      ; Simulate left click (select item) before showing the popup menu
        SendMessage D@Handle, &WM_LBUTTONDOWN, D@wParam, D@lParam
        SendMessage D@Handle, &WM_LBUTTONUP, D@wParam, D@lParam
      ; Is this a proc name item? (don't show menu for sub items)
        cmp D$CallStackForm.CurrentEntry 0 | jz L0>>
      ; Check if the user right-clicked onto the item
        move D$DebugRect D$CallStackForm.CurrentItem
        SendMessage D@Handle, &TVM_GETITEMRECT, 1, DebugRect
        movzx eax W@lParam
        cmp eax D$DebugRect@left  | jl L0>
        cmp eax D$DebugRect@right | ja L0>
        movzx eax W@lParam+2
        cmp eax D$DebugRect@top    | jl L0>
        cmp eax D$DebugRect@bottom | ja L0>
      ; Show the popup menu at the position of the mouse-click
        movzx eax W@lParam
        movzx ecx W@lParam+2
        mov D$PointX eax, D$PointY ecx
        call 'USER32.ClientToScreen' D@Handle, Point
        call 'USER32.TrackPopupMenu' D$CallStack.PopupMenu, &TPM_LEFTALIGN, D$PointX, D$PointY, 0, D$CallStackFormHandle, 0 ; << TODO
    .ElseIf D@Message = &WM_LBUTTONDBLCLK
        call CallStackForm_ShowDeclaration ; *TODO* strange effect in source editor
    .EndIf
L0: call 'User32.CallWindowProcA' D$CallStack.TVProc, D@Handle, D@Message, D@wParam, D@lParam
EndP
____________________________________________________________________________________________

[CallStack.PopupMenu: ?]

[MCS_SHOW_INVOKE    3200
 MCS_SHOW_DECL      3201
 MCS_SHOW_ALL       3202
 MCS_HIDE_EXTERNAL  3203
 MCS_HIDE_INTRA     3204
 MCS_SHOW_LOCALS    3205]

;[CALLSTACK_SHOWALL 30 CALLSTACK_HIDE_EXTERNAL 31 CALLSTACK_HIDE_INTRA 32
; CALLSTACK_SHOWLOCALS 35]

CallStack_CreatePopupMenu:
    call 'USER32.CreatePopupMenu' | mov ebx eax, D$CallStack.PopupMenu eax
    call AppendMenu ebx, &MF_OWNERDRAW, MCS_SHOW_INVOKE, D$StrShowInvokePtr
    call AppendMenu ebx, &MF_OWNERDRAW, MCS_SHOW_DECL, D$StrShowDeclPtr
    call 'User32.AppendMenuA' ebx, &MF_SEPARATOR, 0, 0
    call AppendMenu ebx, &MF_OWNERDRAW, MCS_SHOW_ALL, D$StrShowAllCallsPtr
    call AppendMenu ebx, &MF_OWNERDRAW, MCS_HIDE_EXTERNAL, D$StrHideModCallsPtr
    call AppendMenu ebx, &MF_OWNERDRAW, MCS_HIDE_INTRA, D$StrHideIMCallsPtr
    call 'User32.AppendMenuA' ebx, &MF_SEPARATOR, 0, 0
    call AppendMenu ebx, &MF_OWNERDRAW+&MF_CHECKED, MCS_SHOWLOCALS, D$StrShowLocalsPtr

    call 'USER32.CheckMenuRadioItem' ebx, MCS_SHOWALL, MCS_HIDE_INTRA,
        MCS_SHOWALL, &MF_BYCOMMAND
ret

Proc CallStack_UpdatePopupMenu:
    ; TODO
EndP
____________________________________________________________________________________________

[TVI:
 TVI.hParent: ?
 TVI.hInsertAfter: ?
 TVI.Item:
 TVI.Item.imask: ?
 TVI.Item.hItem: ?
 TVI.Item.state: ?
 TVI.Item.stateMask: ?
 TVI.Item.pszText: ?
 TVI.Item.cchTextMax: ?
 TVI.Item.iImage: ?
 TVI.Item.iSelectedImage: ?
 TVI.Item.cChildren: ?
 TVI.Item.lParam: ?]
____________________________________________________________________________________________

; ebx = dword parameter / local number (starts with zero)
; edi > Param string (must have room for 100 bytes)

SearchLocalName:
  ; The first local is the parent frame pointer at offset 0.
    lea eax D$ebx*4
    If eax <> 0
        neg eax | jmp SearchStackFrameSymbol
    Else
        mov eax ' [Ca' | stosd
        mov eax 'ller' | stosd
        mov eax ' EBP' | stosd
        mov eax ']'    | stosd
    EndIf
ret

SearchParameterName:
  ; The first param is at EBP+8
    lea eax D$ebx*4+8

SearchStackFrameSymbol:
    mov edx StackFrameSymbols, ecx D$NumStackFrameSymbols
    jecxz L9>

  ; Search correspondance table - cmp the offset
L0: cmp D$edx+4 eax | je L1>
        add edx 8
    loop L0<
    jmp L9>

  ; Copy the name to the buffer at EDI > " [name]"
L1: mov edx D$edx
    mov ecx 97
    mov al ' ' | stosb
    mov al '['
    Do
        stosb
        mov al B$edx
        inc edx
        dec ecx | jz L8>
    Loop_Until al < LowSigns
L8: mov al ']' | stosb
L9: ret
____________________________________________________________________________________________

; edi > CSE (CallStack Entry)

Proc CallStackForm_InsertParameters:

  ; Parameter string reserved on stack
    sub esp 128

    mov D$TVI.Item.pszText {'Parameter' 0}, D$TVI.Item.lParam 0
    SendMessage D$CallStackTreeHandle, &TVM_INSERTITEM, 0, TVI
    mov D$TVI.hParent eax

    mov ebx 0
    mov esi D$edi+CSE_Address

  ; esi > first parameter
    While ebx < D$edi+CSE_NumParams
        lodsd
        push edi
            lea edi D$esp+4
            DwordToHex eax
            call SearchParameterName
            mov al 0 | stosb
        pop edi
        mov D$TVI.Item.pszText esp
        SendMessage D$CallStackTreeHandle, &TVM_INSERTITEM, 0, TVI
        inc ebx
    EndWhile

    SendMessage D$CallStackTreeHandle, &TVM_EXPAND, &TVE_EXPAND, D$TVI.hParent
EndP
____________________________________________________________________________________________

; edi > CSE (CallStack Entry)

Proc CallStackForm_InsertLocals:

  ; Local string reserved on stack
    sub esp 128

    mov D$TVI.Item.pszText {'Local data' 0}, D$TVI.Item.lParam 0
    SendMessage D$CallStackTreeHandle, &TVM_INSERTITEM, 0, TVI
    mov D$TVI.hParent eax

    mov ebx 0
    mov esi D$edi+CSE_Address | sub esi 8

  ; esi > caller ebp
    While ebx < D$edi+CSE_NumLocals
        mov eax D$esi | sub esi 4
        push edi
            lea edi D$esp+4
            DwordToHex eax
            call SearchLocalName
            mov al 0 | stosb
        pop edi
        mov D$TVI.Item.pszText esp
        SendMessage D$CallStackTreeHandle, &TVM_INSERTITEM, 0, TVI
        inc ebx
    EndWhile

    SendMessage D$CallStackTreeHandle, &TVM_EXPAND, &TVE_EXPAND, D$TVI.hParent
EndP
____________________________________________________________________________________________

; Check equate contents at ESI for stack frame symbols (relative to EBP). ECX is length.
; Return the signed offset in EAX if a string of the form "EBP+xx" / "EBP-xx" was found,
; zero otherwise. All registers are preserved (messy).

; Note: Only simple expressions with one offset and one op (+/-) are supported (not "EBP+8-4")

ParseFrameOffset:
    mov eax 0
    cmp ecx 5 | jb L9>

    lodsd | sub ecx 4
    cmp eax 'EBP'+0A00_0000 | je L0>
    cmp eax 'EBP'+0900_0000 | je L0>

L9: ret

L0: shr eax 24 ; move operator (+/-) in AL

    push edi ebx edx
      ; Save the byte behind the string in AH and replace with 0
        mov ah B$esi+ecx, B$esi+ecx 0
        push eax
            push esi ecx
                call TranslateAny
            pop ecx esi
        pop edx
      ; DL = operator, DH = saved byte
        mov B$esi+ecx dh
        On dl = subSign, neg eax
    pop edx ebx edi
ret
____________________________________________________________________________________________

; Scan the equates table for symbols local to the current callstack entry at EDI and
; fill the table 'StackFrameSymbols'.

[StackFrameSymbols: D$ ? #128 ; correspondance table [ Symbol name | signed offset ] (dwords)
 NumStackFrameSymbols: ?]     ; number of table entries
[MAX_STACK_FRAME_SYMBOLS 64]

Proc FindStackFrameSymbols:
    Local @PlainLabel, @LabelLen
    Uses edi

    mov D$NumStackFrameSymbols 0

    mov al B$edi+CSE_FLAGS

    test al CSEF_HAS_STACKFRAME | jz  P9>>
    ;test al CSEF_FUZZY_ADDRESS  | jnz P9>>
    test al CSEF_EXTERNAL       | jnz P9>>

  ; Get symbol name / len
    mov edi D$edi+CSE_ProcName, D@PlainLabel edi
    mov ecx 0-1, al 0
    repne scasb
    mov eax 0-2 | sub eax ecx
    mov D@LabelLen eax

  ; search the label list for symbols "THISLABEL@..."
    mov edi D$EquateList, edx D$EquateListLimit
    add edi 5
    While edi < edx
        mov esi D@PlainLabel, ecx D@LabelLen
        repe cmpsb | jne L0>

            cmp B$edi '@' | jne L0>
            inc edi

          ; Save address of local name without preceding '@'
            mov ebx D$NumStackFrameSymbols
            mov D$StackFrameSymbols+ebx*8 edi

          ; Scan to the end of the label name
            mov al EOI
            mov ecx edx | sub ecx edi
            repne scasb

          ; Parse equate contents
            mov esi D$edi, ecx D$edi+4
            call ParseFrameOffset
            cmp eax 0 | je L1>

          ; Save entry in correspondance table
            mov D$StackFrameSymbols+ebx*8+4 eax
            inc D$NumStackFrameSymbols

            On D$NumStackFrameSymbols = MAX_STACK_FRAME_SYMBOLS, ExitP

            jmp L1>

L0:     mov al EOI
        mov ecx edx | sub ecx edi
        repne scasb
L1:     add edi 10
    EndWhile
EndP
____________________________________________________________________________________________

Proc CallStackForm_BuildTree:
    Local @hProcItem
    Uses edi, ebx, esi

    call GenerateCallStack

    SendMessage D$CallStackTreeHandle, &WM_SETREDRAW, &FALSE, 0
    SendMessage D$CallStackTreeHandle, &TVM_DELETEITEM, 0, &TVI_ROOT

    mov D$TVI.hParent &TVI_ROOT
    mov D$TVI.hInsertAfter &TVI_LAST
    mov D$TVI.Item.imask &TVIF_TEXT+&TVIF_PARAM

    mov edi D$FirstCallStackEntry
    .While edi <> 0

        If D$CallStackFilter = MCS_HIDE_EXTERNAL
            test B$edi+CSE_Flags CSEF_EXTERNAL | jnz L0>>
        ElseIf D$CallStackFilter = MCS_HIDE_INTRA
          ; filter module internal calls, this is when the current CSE was called
          ; by a function in the same (external) module
            test B$edi+CSE_Flags CSEF_EXTERNAL | jz L1>
            mov eax D$edi+CSE_Next
            test B$eax+CSE_Flags CSEF_EXTERNAL | jz L1>
            call IsModuleCode D$eax+CSE_ProcAddress
            mov ebx eax
            call IsModuleCode D$edi+CSE_ProcAddress
            cmp eax ebx | je L0>>
        EndIf

L1:     mov D$TVI.hParent &TVI_ROOT
        mov D$TVI.Item.lParam edi
        mov eax D$edi+CSE_ProcName
        mov D$TVI.Item.pszText eax
        SendMessage D$CallStackTreeHandle, &TVM_INSERTITEM, 0, TVI
        mov D$TVI.hParent eax, D@hProcItem eax

        call FindStackFrameSymbols
        On D$edi+CSE_NumParams > 0,
            call CallStackForm_InsertParameters

        move D$TVI.hParent D@hProcItem

        If D$CallStackShowLocal = 1
            On D$edi+CSE_NumLocals > 0,
                call CallStackForm_InsertLocals
        EndIf

        test B$edi+CSE_Flags CSEF_EXTERNAL | jnz L0>
            SendMessage D$CallStackTreeHandle, &TVM_EXPAND, &TVE_EXPAND, D@hProcItem
L0:     mov edi D$edi+CSE_Next
    .EndWhile

    SendMessage D$CallStackTreeHandle, &WM_SETREDRAW, &TRUE, 0
    call 'USER32.InvalidateRect' D$CallStackTreeHandle, &NULL, &TRUE

EndP

Proc CallStackForm_OnTreeNavigate:
    Arguments @NotifyInfo
    Uses esi ebx

    mov esi D@NotifyInfo
    On D$esi+8 <> &TVN_SELCHANGED, ExitP
    add esi 12 ; skip notify header
    add esi 4 ; skip action flag
    add esi 40 ; skip old item
    mov eax D$esi+4 ; hItem
    mov D$CallStackForm.CurrentItem eax
    mov ebx D$esi+36 ; lParam of new item
    mov D$CallStackForm.CurrentEntry ebx

    mov eax 0
    On ebx <> 0, mov eax D$ebx+CSE_ProcAddress
    call IsProcessCode eax
    xor eax 1
    call 'USER32.EnableMenuItem' D$CallStack.PopupMenu, MCS_SHOW_DECL, eax
    If ebx <> 0
        mov ebx D$ebx+CSE_Address
        On ebx <> 0, mov ebx D$ebx-4
    EndIf
    call IsProcessCode ebx
    xor eax 1
    call 'USER32.EnableMenuItem' D$CallStack.PopupMenu, MCS_SHOW_INVOKE, eax

EndP

[CallStackShowLocal: 1
 CallStackFilter: MCS_SHOWALL]

Proc CallStackForm_Refresh:

    call CallStackForm_BuildTree
EndP

[CallStackForm.CurrentEntry: ? CallStackForm.CurrentItem: ?]

Proc CallStackForm_ShowEvoke:

    mov eax D$CallStackForm.CurrentEntry
    On eax = 0, ExitP
    mov edx D$eax
    mov ecx D$edx-4 ; get return address from the stack-copy
    dec ecx
    call SourceDebugPos ecx
EndP

Proc CallStackForm_ShowDeclaration:

    mov eax D$CallStackForm.CurrentEntry
    On eax = 0, ExitP
    call SourceDebugPos D$eax+4
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; DEBUGGER MAIN DIALOG (Registers & Execution Control)
____________________________________________________________________________________________
____________________________________________________________________________________________


[SendMessage | #=4 | call 'User32.SendMessageA' #1 #2 #3 #4]
[CopyString | #=1 | mov esi #1 | R9: | cmp B$esi 0 | je R9> | movsb | jmp R9< | R9:]
____________________________________________________________________________________________

[GPRRegMap: C.regEax C.regEbx C.regEcx C.regEdx C.regEsi C.regEdi C.regEbp C.regEsp]
[SegRegMap: C.regCs C.regDs C.regEs C.regFs C.regGs C.regSs]
[DbgRegMap: C.regEip C.iDr0 C.iDr1 C.iDr2 C.iDr3 C.iDr6 C.iDr7]

; Format / Conversion tables
[GPRFormats: D$ 9 FmtHexPtr FmtUDecPtr FmtSDecPtr FmtBinaryPtr FmtPUBPtr FmtPSBPtr FmtPUWPtr FmtPSWPtr FmtAsciiPtr]
[GPRConvert: toHex toUDword toSDword toBinary toUByte toSByte toUWord toSWord toAscii]
[FPUFormats: D$ 3 FmtFloatPtr FmtHexPtr FmtBinaryPtr]
[FPUConvert: toExtended toHex toBinary]
[MMXFormats: D$ 9 FmtHexPtr FmtBinaryPtr FmtPUBPtr FmtPSBPtr FmtPUWPtr FmtPSWPtr FmtPUDPtr FmtPSDPtr FmtPFPtr]
[MMXConvert: toHex toBinary toUByte toSByte toUWord toSWord toUDword toSDword toFloat]
[SSEFormats: D$ 10 FmtHexPtr FmtBinaryPtr FmtPFPtr FmtPDPtr FmtPUBPtr FmtPSBPtr FmtPUWPtr FmtPSWPtr FmtPUDPtr FmtPSDPtr FmtPUQPtr FmtPSQPtr]
[SSEConvert: toHex toBinary toFloat toDouble toUByte toSByte toUWord toSWord toUDword toSDword toHex toHex]
[SegFormats: D$ 1 FmtHexPtr]
[SegConvert: toSegHex]
[DbgFormats: D$ 1 FmtHexPtr]
[DbgConvert: toHex]
[MemFormats: D$ 5 FmtHexAnsiPtr FmtHexDWPtr FmtHexWPtr FmtFloatsPtr FmtHexCookedPtr]
[MemConvert: toHexWithAnsi toHexDwords toHexWords toFloats toHexWithCookedAnsi]

; Buffers that hold the converted strings, used as sources while drawing the items
[ValueReg0: B$ ? #256
 ValueReg1: B$ ? #256
 ValueReg2: B$ ? #256
 ValueReg3: B$ ? #256
 ValueReg4: B$ ? #256
 ValueReg5: B$ ? #256
 ValueReg6: B$ ? #256
 ValueReg7: B$ ? #256]

[RegValues: ValueReg0 ValueReg1 ValueReg2 ValueReg3 ValueReg4 ValueReg5 ValueReg6 ValueReg7]

Proc DebugDialog_OnFormatChange:
    Arguments @Handle @Index

        mov B$HexSeparator 1
        mov ebx 0
        .While ebx < 8
            mov eax D$TabID, edx D@Index
            .If eax = 0 ; GPR
                mov esi D$GPRRegMap+ebx*4
                mov ecx 4
                call D$GPRConvert+edx*4
            .ElseIf eax = 1 ; FPU
                ; test for empty register slots
                mov eax D$C.FloatSave.TagWord
                ; get top of stack (ecx = TOS * 2)
                mov ecx D$C.FloatSave.StatusWord
                shr ecx 10 | and ecx 00_1110
                lea ecx D$ebx*2+ecx
                and ecx 0F
                shr eax cl | and eax 3
                ;shl eax 2 | lea ecx D$ebx*2 | shl eax cl
                ;shr eax 16 | and eax 3 ; eax = TagBits for register (11: empty)
                If eax = 0011
                    mov edi StringBuf
                    mov D$edi 'EMPT', W$edi+4 'Y'
                Else
                    mov esi C.FloatSave.RegisterArea
                    imul eax ebx 10
                    add esi eax
                    mov ecx 10
                    call D$FPUConvert+edx*4
                EndIf
            .ElseIf eax = 2 ; MMX [V2.1b]
                imul esi ebx 10
                add esi C.FloatSave.RegisterArea
                ;mov esi ebx | shl esi 4
                ;add esi C.regMM
                mov ecx 8
                call D$MMXConvert+edx*4
            .ElseIf eax = 3 ; SSE
                mov esi ebx | shl esi 4
                add esi C.regXMM
                mov ecx 16
                call D$SSEConvert+edx*4
            .ElseIf eax = 4 ; Segment
                If ebx < 6
                    mov esi D$SegRegMap+ebx*4
                    lea edi D$LinearSegmentAddresses+ebx*8
                    call toSegHex
                    ;call D$SegConvert+edx*4
                Else
                    mov edi StringBuf
                    mov B$edi 0
                EndIf
            .Else_if eax = 5 ; Debug & EIP
                If ebx < 7
                    mov esi D$DbgRegMap+ebx*4
                    mov ecx 4
                    call D$DbgConvert+edx*4
                Else
                    mov edi StringBuf
                    mov B$edi 0
                EndIf
            .EndIf

            mov esi edi, edi D$RegValues+ebx*4
            Do | movsb | Loop_Until B$esi-1 = 0

            inc ebx
        .End_While

        mov ecx D$TabID, eax D@Index, D$TabFormats+ecx*4 eax
        call 'USER32.InvalidateRect' D$RegListHandle, &NULL, &TRUE
        call DebugDialog_RedrawRegisterButtons D@Handle
EndP
____________________________________________________________________________________________

; Output register-name/value pair. The name is chosen by the tab-index, the value
; by the index provided in the DrawItemStructure passed by WM_DRAWITEM.

[GPRegs: B$ 'EAX' 0 'EBX' 0 'ECX' 0 'EDX' 0 'ESI' 0 'EDI' 0 'EBP' 0 'ESP' 0]
[STRegs: B$ 'ST0' 0 'ST1' 0 'ST2' 0 'ST3' 0 'ST4' 0 'ST5' 0 'ST6' 0 'ST7' 0]
[MMXRegs: B$ 'MM0' 0 'MM1' 0 'MM2' 0 'MM3' 0 'MM4' 0 'MM5' 0 'MM6' 0 'MM7' 0]
[SSERegs: B$ 'XMM0' 0 'XMM1' 0 'XMM2' 0 'XMM3' 0 'XMM4' 0 'XMM5' 0 'XMM6' 0 'XMM7' 0]
[SegRegs: B$ 'CS' 0 'DS' 0 'ES' 0 'FS' 0 'GS' 0 'SS' 0 ' ' 0 ' ' 0]
[DbgRegs: B$ 'EIP' 0 'DR0' 0 'DR1' 0 'DR2' 0 'DR3' 0 'DR6' 0 'DR7' 0 ' ' 0]

[RegSets: GPRegs STRegs MMXRegs SSERegs SegRegs DbgRegs]

[ItemRect: @x1: ? @y1: ? @x2: ? @y2: ?]
[ItemString: B$ ? #128]

[BackgroundCol:
 @Name:  0BB_BBBB 0CC_CCCC 0CC_FFFF
 @Value: 0DD_DDDD 0FF_FFFF 0CC_0000]

[DRAWITEM_CTLTYPE 0
 DRAWITEM_CTLID 4
 DRAWITEM_ITEMID 8
 DRAWITEM_ITEMACTION 12
 DRAWITEM_ITEMSTATE 16
 DRAWITEM_HWNDITEM 20
 DRAWITEM_HDC 24
 DRAWITEM_RCITEM_LEFT 28
 DRAWITEM_RCITEM_TOP 32
 DRAWITEM_RCITEM_RIGHT 36
 DRAWITEM_RCITEM_BOTTOM 40
 DRAWITEM_ITEMDATA 44]

Proc DebugDialog_OnDrawRegisterItem:
    Arguments @DrawItemStruc
    Local @Brush
    Uses ebx edi

    mov ebx D@DrawItemStruc

    call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0

  ; Print Register name
    mov eax D$ebx+DRAWITEM_RCITEM_LEFT | mov D$ItemRect@x1 eax
    add eax 35 | mov D$ItemRect@x2 eax
    move D$ItemRect@y1 D$ebx+DRAWITEM_RCITEM_TOP
    move D$ItemRect@y2 D$ebx+DRAWITEM_RCITEM_BOTTOM

    mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    call 'GDI32.CreateSolidBrush' D$BackgroundCol@Name+edi*4 | mov D@Brush eax
    call 'USER32.FillRect' D$ebx+DRAWITEM_HDC, ItemRect, D@Brush
    call 'GDI32.DeleteObject' D@Brush
    call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, D$BackgroundCol@Name+edi*4

    mov ecx D$TabID, edi D$RegSets+ecx*4
    mov edx 0, al 0
    While edx < D$ebx+DRAWITEM_ITEMID ; item index
        mov ecx 0-1
        repne scasb
        inc edx
    EndWhile

    call 'User32.DrawTextA' D$ebx+DRAWITEM_HDC, edi, 0-1, ItemRect,
         (&DT_SINGLELINE+&DT_CENTER+&DT_VCENTER)

  ; Hilite changed regs
    If D$TabId = 0 ; GPR
        mov ecx D$ebx+DRAWITEM_ITEMID
        bt D$GPR_Modified_Mask ecx | jnc L0>
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0C0
L0: EndIf

  ; Print value
    move D$ItemRect@x1 D$ItemRect@x2
    move D$ItemRect@x2 D$ebx+DRAWITEM_RCITEM_RIGHT

    mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    call 'GDI32.CreateSolidBrush' D$BackgroundCol@Value+edi*4 | mov D@Brush eax
    call 'USER32.FillRect' D$ebx+DRAWITEM_HDC, ItemRect, D@Brush
    call 'GDI32.DeleteObject' D@Brush
    call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, D$BackgroundCol@Value+edi*4

    mov ecx D$ebx+DRAWITEM_ITEMID | mov edi D$RegValues+ecx*4
    call 'User32.DrawTextA' D$ebx+DRAWITEM_HDC, edi, 0-1, ItemRect,
         (&DT_SINGLELINE+&DT_CENTER+&DT_VCENTER)

EndP
____________________________________________________________________________________________

; Create the tabs for the different register types. First check if they are available.

[RegGeneral: 'General' 0 RegFPU: 'FPU' 0 RegMMX: 'MMX' 0 RegSSE: 'SSE' 0 RegSSE2: 'SSE2' 0
 RegSegment: 'Segment' 0 RegDebug: 'Debug' 0]

[DebugRegTabHandle: ?]
[DebugFormatComboHandle: ?]

Proc DebugDialog_CreateRegisterTabs:
    Arguments @Handle
    Local @Index
    ; Tag Dialog 1010

      ; Create register listbox
        movzx ecx W$DebugDialog.Width | sub ecx 6
        mov edx 53 ;mov edx D$DebugDialog.RebarHeight | add edx 50

        call 'User32.CreateWindowExA',
            &WS_EX_CLIENTEDGE,
            {'LISTBOX' 0},
            {'Register' 0},
            &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE+&LBS_NOSEL+&LBS_OWNERDRAWFIXED,
            3, edx, ecx, 138,
            D$DebugDialogHandle,
            DEBUGDLG_REG_LIST,
            D$hInstance,
            0

        mov D$RegListHandle eax

      ; Create format combo
        movzx ecx W$DebugDialog.Width | sub ecx 122
        mov edx 29 ;mov edx D$DebugDialog.RebarHeight | add edx 26

        call 'User32.CreateWindowExA',
            0,
            {'COMBOBOX' 0},
            {'Representation' 0},
            &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE+&CBS_DROPDOWNLIST+&CBS_HASSTRINGS,
            120, edx, ecx, 200,
            D$DebugDialogHandle,
            DEBUGDLG_FORMAT_COMBO,
            D$hInstance,
            0

        mov D$DebugFormatComboHandle eax
        SendMessage eax, &WM_SETFONT, D$DialogFontHandle, &TRUE

      ; Create static control
        mov edx 32 ;mov edx D$DebugDialog.RebarHeight | add edx 29

        call 'User32.CreateWindowExA',
            0,
            {'STATIC' 0},
            D$StrDataFmtPtr,
            &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE+&SS_LEFT,
            7, edx, 140, 16,
            D$DebugDialogHandle,
            3,
            D$hInstance,
            0

        SendMessage eax, &WM_SETFONT, D$DialogFontHandle, &TRUE

      ; Create tab control
        movzx ecx W$DebugDialog.Width
        mov edx 6 ;mov edx D$DebugDialog.RebarHeight | add edx 4

        call 'User32.CreateWindowExA',
            0,
            {"SysTabControl32",0},
            {"RegisterTab",0},
            &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE, ;+&TCS_FLATBUTTONS+&TCS_HOTTRACK+&TCS_BUTTONS,
            0, edx, ecx, 184,
            D$DebugDialogHandle,
            DEBUGDLG_REGISTER_TAB,
            D$hInstance,
            0

        mov D$DebugRegTab_handle eax
        mov ebx eax
        SendMessage eax, &WM_SETFONT, D$DialogFontHandle, &TRUE

      ; Add tabs
        mov D@Index 0
        mov D$TabItem@imask &TCIF_TEXT+&TCIF_PARAM

        mov D$TabItem@pszText RegGeneral
        mov D$TabItem@lParam 0
        SendMessage ebx, &TCM_INSERTITEM, D@Index, TabItem
        On eax = 0-1, call ReportWinError {'TCM_INSERTITEM' 0}
        inc D@Index

        test D$CPUFlags FLAG_FPU | jz L0>

        mov D$TabItem@pszText RegFPU
        mov D$TabItem@lParam 1
        SendMessage ebx, &TCM_INSERTITEM, D@Index, TabItem
        inc D@Index

L0:     test D$CPUFlags FLAG_MMX | jz L0>

        mov D$TabItem@pszText RegMMX
        mov D$TabItem@lParam 2
        SendMessage ebx, &TCM_INSERTITEM, D@Index, TabItem
        inc D@Index

L0:     test D$CPUFlags FLAG_SSE | jz L0>

        mov D$TabItem@pszText RegSSE
        mov D$TabItem@lParam 3
        SendMessage ebx, &TCM_INSERTITEM, D@Index, TabItem
        inc D@Index

L0:     call SelectTab ebx, DEBUGDLG_REGISTER_TAB, 0

        call DebugDialog_InitRegisterListBox D@Handle
        call DebugDialog_CreateRegisterButtons D@Handle
EndP
____________________________________________________________________________________________

; Show/Hide tabs for advanced registers (segments, debug).

Proc DebugDialog_ShowAdvancedTabs:
    Arguments @Handle @Show
    Local @TabHandle @Index

        call 'USER32.GetDlgItem' D@Handle, DEBUGDLG_REGISTER_TAB
        mov D@TabHandle eax

        SendMessage D@TabHandle, &TCM_GETITEMCOUNT, 0, 0
        mov D@Index eax

        .If D@Show = &TRUE
            mov D$TabItem@imask &TCIF_TEXT+&TCIF_PARAM

            mov D$TabItem@pszText RegSegment
            mov D$TabItem@lParam 4
            SendMessage D@TabHandle, &TCM_INSERTITEM, D@Index, TabItem
            inc D@Index

            mov D$TabItem@pszText RegDebug
            mov D$TabItem@lParam 5
            SendMessage D@TabHandle, &TCM_INSERTITEM, D@Index, TabItem
        .Else
            SendMessage D@TabHandle, &TCM_GETCURSEL, 0, 0 | mov ebx eax
            dec D@Index
            SendMessage D@TabHandle, &TCM_DELETEITEM, D@Index, 0
            dec D@Index
            SendMessage D@TabHandle, &TCM_DELETEITEM, D@Index, 0
            On ebx >= D@Index, mov ebx 0
            call SelectTab D@Handle, DEBUGDLG_REGISTER_TAB, ebx
        .EndIf
        call 'USER32.InvalidateRect' D@Handle &NULL &TRUE
EndP
____________________________________________________________________________________________

; Initially fill the listbox with eight items. The listbox does NOT contain strings, so
; we just set the address of the buffer as item data. Another issue: When the listbox
; is enabled it blocks the mouse from clicking on the register buttons, therefore it is
; disabled.

Proc DebugDialog_InitRegisterListBox:
    Arguments @Handle

        mov eax D$RegListHandle
        call 'User32.EnableWindow' eax, &FALSE
        mov esi RegValues, ebx 0
        While ebx < 8
            lodsd
            mov B$eax 0
            SendMessage D$RegListHandle, &LB_ADDSTRING, 0, eax
            inc ebx
        EndWhile
EndP
____________________________________________________________________________________________

; Create the buttons for the general purpose registers.

Proc DebugDialog_CreateRegisterButtons:
    Arguments @Handle

        mov ebx 0, esi GPRegs
        .While ebx < 8
            ; Get position of item and transform in debug dialogs client coordinates
            SendMessage D$RegListHandle, &LB_GETITEMRECT, ebx, DebugRect
            mov ecx D$DebugRect@bottom
            sub ecx D$DebugRect@top
            mov D$DebugRect@height ecx
            call 'USER32.ClientToScreen' D$RegListHandle, DebugRect
            call 'USER32.ScreenToClient' D@Handle, DebugRect
            ; Create a button
            mov eax DEBUGDLG_FIRSTREG_BUTTON
            add eax ebx
            call 'User32.CreateWindowExA' 0, ButtonClassName, esi,
                                        &WS_CHILD,
                                        D$DebugRect@left, D$DebugRect@top, 35, D$DebugRect@height,
                                        D@Handle, eax,
                                        D$hinstance, &NULL
            add esi 4
            inc ebx
        .EndWhile
EndP
____________________________________________________________________________________________

; The dialog has been resized, adjust the width and height of the controls.

Proc DebugDialog_OnSize:
    Arguments @Handle, @WidthHeight

      ; calculate the delta values (pixel difference old -> new size)
        movzx eax W$DebugDialog.Width
        movzx esi W@WidthHeight
        sub esi eax
        movzx eax W$DebugDialog.Height
        movzx edi W@WidthHeight+2
        sub edi eax

        move D$DebugDialogSize D@WidthHeight

        call AdjustControlSize D@Handle, DEBUGDLG_REGISTER_TAB, esi, 0
        call AdjustControlSize D@Handle, DEBUGDLG_FORMAT_COMBO, esi, 0
        call AdjustControlSize D@Handle, DEBUGDLG_REG_LIST, esi, 0
        call AdjustControlSize D@Handle, DEBUGDLG_DATA_TAB, esi, edi
        call DebugDialog_AdjustDataTabSize D@Handle
        call 'USER32.InvalidateRect' D@Handle &NULL &TRUE

      ; notify rebar
        movzx eax W$DebugDialog.Width
        SendMessage D$Debug_RebarHandle, &WM_SIZE, eax, 0

        mov eax 0
EndP
____________________________________________________________________________________________

; The tab-selection has changed, refill format combo.

[TabFormats: D$ 0 #6]
[RegFormats: GPRFormats FPUFormats MMXFormats SSEFormats SegFormats DbgFormats]
[TabID: ?]

Proc DebugDialog_OnChangeRegisterTab:
    Arguments @Handle

    call 'User32.GetDlgItem' D@Handle, DEBUGDLG_REGISTER_TAB | mov ebx eax
    SendMessage ebx, &TCM_GETCURSEL, 0, 0
    SendMessage ebx, &TCM_GETITEM, eax, TabItem
    move D$TabID D$TabItem@lParam

    call DebugDialog_UpdateRegisterButtons D@Handle

    ; Refill format/representation combo
    mov ebx D$DebugFormatComboHandle
    SendMessage ebx, &CB_RESETCONTENT, 0, 0
    mov ecx D$TabID, esi D$RegFormats+ecx*4
    lodsd | mov ecx eax
D0:     push ecx
            lodsd
            If D$UnicodeStrings = 0
                SendMessage ebx, &CB_ADDSTRING, 0, D$eax
            Else
                call 'User32.SendMessageW' ebx, &CB_ADDSTRING, 0, D$eax
            EndIf
        pop ecx
    loop D0<

    mov ecx D$TabID
    SendMessage ebx, &CB_SETCURSEL, D$TabFormats+ecx*4, 0
    SendMessage D@Handle, &WM_COMMAND, (&CBN_SELCHANGE shl 16 or DEBUGDLG_FORMAT_COMBO), ebx
EndP
____________________________________________________________________________________________

[DataViewHandle: ? MemoryInspectorHandle: ? CurrentDataPageHandle: ?]

Proc DebugDialog_CreateDataTab:
    Arguments @Handle

      ; Create tab control
        movzx ecx W$DebugDialog.Width
        movzx edx W$DebugDialog.Height | sub edx 195

        call 'User32.CreateWindowExA',
            0,
            {"SysTabControl32",0},
            {"DataTab",0},
            &WS_CHILD+&WS_CLIPSIBLINGS+&WS_VISIBLE+&TCS_FLATBUTTONS, ;+&TCS_FLATBUTTONS+&TCS_HOTTRACK+&TCS_BUTTONS,
            0, 195, ecx, edx,
            D$DebugDialogHandle,
            DEBUGDLG_DATA_TAB,
            D$hInstance,
            0

        mov ebx eax
        SendMessage eax &WM_SETFONT, D$DialogFontHandle, &TRUE

      ; Add tabs
        mov D$TabItem@imask &TCIF_TEXT
        mov D$TabItem@pszText DataView
        SendMessage ebx, &TCM_INSERTITEM, 0, TabItem
        mov D$TabItem@pszText MemoryInspector
        SendMessage ebx, &TCM_INSERTITEM, 1, TabItem
        mov D$TabItem@pszText CallStack
        SendMessage ebx, &TCM_INSERTITEM, 2, TabItem
        mov D$TabItem@pszText Log
        SendMessage ebx, &TCM_INSERTITEM, 3, TabItem
        mov D$TabItem@pszText AddressSpace
        SendMessage ebx, &TCM_INSERTITEM, 4, TabItem

      ; Create sub windows
        call 'User32.CreateDialogParamA' D$hinstance, 1011, ebx, DataViewProc, 0
        mov D$DataViewHandle eax
        mov D$CurrentDataPageHandle eax
        call 'User32.CreateDialogParamA' D$hinstance, 1012, ebx, MemoryInspectorProc, 0
        mov D$MemoryInspectorHandle eax
        call 'USER32.ShowWindow' eax, &SW_HIDE

        ;call 'user32.CreateDialogParamA' D$hinstance, 1015, ebx, CallStackProc, 0
        call CreateNewForm_CallStackForm ebx
        call 'USER32.ShowWindow' D$CallStackFormHandle, &SW_HIDE

        call CreateNewForm_LogForm ebx
        call 'USER32.ShowWindow' D$LogForm_handle, &SW_HIDE

        call CreateNewForm_AddressSpaceForm ebx
        call 'USER32.ShowWindow' D$ASForm_handle, &SW_HIDE

        call DebugDialog_AdjustDataTabSize D@Handle
EndP
____________________________________________________________________________________________

[FPURndModes: FPURndNearest FPURndDown FPURndUp FPURndTrunc]

[FPUPrec24: '24 bits (single)' 0
 FPUPrec53: '53 bits (double)' 0
 FPUPrec64: '64 bits (extended)' 0]

[FPUPrecModes: FPUPrec24 0 FPUPrec53 FPUPrec64]

[NoException: 'No Exception' 0]

DebugDialog_GetFPUStatus:

    ; Output tag word
    CopyString FPUTagWord
    push edi
        mov esi C.FloatSave.TagWord, ecx 2 | call toBinary
        mov ecx StringBufTail | sub ecx edi
        mov esi edi
    pop edi
    rep movsb

    mov W$edi 0A0D | add edi 2

    ; Output control word
    CopyString FPUControlWord
    push edi
        mov esi C.FloatSave.ControlWord, ecx 2 | call toBinary
        mov ecx StringBufTail | sub ecx edi
        mov esi edi
    pop edi
    rep movsb

    mov W$edi 0A0D | add edi 2

    ; Rounding mode
    CopyString FPURoundingMode
    movzx eax W$C.FloatSave.ControlWord
    shr eax 10 | and eax 3
    CopyString D$FPURndModes+eax*4

    mov W$edi 0A0D | add edi 2

    ; Precision
    CopyString FPUPrecision
    movzx eax W$C.FloatSave.ControlWord
    shr eax 8 | and eax 3
    CopyString D$FPUPrecModes+eax*4
    mov W$edi 0A0D | add edi 2

    ; Output statusword
    CopyString FPUStatusWord
    push edi
        mov esi C.FloatSave.Statusword, ecx 2 | call toBinary
        mov ecx StringBufTail | sub ecx edi
        mov esi edi
    pop edi
    rep movsb

    mov W$edi 0A0D | add edi 2

    movzx eax W$C.FloatSave.StatusWord
    mov esi NoException
    test al 01 | jz L0>
    mov esi FLT_INVALID_OPERATION
L0: test al 02 | jz L0>
    mov esi FLT_DENORMAL_OPERAND
L0: test al 04 | jz L0>
    mov esi FLT_DIVIDE_BY_ZERO
L0: test al 08 | jz L0>
    mov esi FLT_OVERFLOW
L0: test al 010 | jz L0>
    mov esi FLT_UNDERFLOW
L0: test al 020 | jz L0>
    mov esi FLT_INEXACT_RESULT
L0: test al 040 | jz L0>
    mov esi FLT_STACK_CHECK
L0: While B$esi <> 0
        movsb
    End_While
    mov B$edi 0

ret

____________________________________________________________________________________________

[CPUFeatures: 'CPU Features:' 0]
[ConditionMove: 'Conditional Move Instructions (CMOV / FCMOV / FCOMI)' 0]

DebugDialog_GetCPUInfo:

    CopyString CPUVendor
    mov W$edi 0A0D | add edi 2

    mov esi CPUName
    While B$esi = ' '
        inc esi
    EndWhile
    While B$esi <> 0
        movsb
    EndWhile
    mov D$edi 0A0D0A0D | add edi 4

    CopyString CPUFeatures
    mov W$edi 0A0D | add edi 2

  ; Scan the general flags
    mov edx D$CPUFlags

    test edx FLAG_MMX | jz L0>
    mov D$edi 'MMX,', B$edi+4 ' '
    add edi 5

L0: test edx FLAG_SSE | jz L0>
    mov D$edi 'SSE,', B$edi+4 ' '
    add edi 5

L0: test edx FLAG_SSE2 | jz L0>
    mov D$edi 'SSE2', W$edi+4 ', '
    add edi 6
L0: sub edi 2
    mov W$edi 0A0D | add edi 2

    test edx FLAG_CMOV | jz L0>
    CopyString ConditionMove
L0: mov W$edi 0A0D | add edi 2

  ; Scan extended flags
    mov edx D$CPUFlagsEx

    test edx FLAG_EX_MMX | jz L0>
    mov D$edi 'AMD ', D$edi+4 'MMX ', D$edi+8 'Exte', D$edi+12 'nsio', D$edi+16 'ns, '
    add edi 20
L0: test edx FLAG_EX_3DNOW | jz L0>
    mov D$edi '3dno', D$edi+4 'w,  '
    add edi 7
L0: test edx FLAG_EX_3DNOWEX | jz L0>
    mov D$edi '3dno', D$edi+4 'w Ex', D$edi+8 'tens', D$edi+12 'ions', W$edi+16 ', '
    add edi 18
L0: sub edi 2
    mov W$edi 0A0D | add edi 2

    mov B$edi 0
ret
____________________________________________________________________________________________

; Set the flag checkboxes (button-style) according to the flag register

[FlagMasks: 0800 080 040 01 04 0400 0200 0100 010]
[FPUFlagMasks: 04000 0400 0200 0100]

Proc DebugDialog_UpdateFlags:
    Arguments @Handle

        ; update the eflags
        mov ebx D$C.regFlag, edi 90, esi FlagMasks
        Do
            mov edx &FALSE
            lodsd
            test ebx eax | jz L0>
            inc edx
L0:         SendMessage D$Debug_FlagBarHandle, &TB_CHECKBUTTON, edi, edx
            ;call 'User32.SendDlgItemMessageA' D@Handle, edi, &BM_SETCHECK, edx, 0
            inc edi
        Loop_Until edi > 98

        ; update FPU flags
        mov ebx D$C.FloatSave.StatusWord, edi 101, esi FPUFlagMasks
        Do
            mov edx &FALSE
            lodsd
            test ebx eax | jz L0>
            inc edx
L0:         SendMessage D$DebugFPUbarHandle, &TB_CHECKBUTTON, edi, edx
            ;call 'User32.SendDlgItemMessageA' D@Handle, edi, &BM_SETCHECK, edx, 0
            inc edi
        Loop_Until edi > 104
EndP
____________________________________________________________________________________________

Proc DebugDialog_UpdateRegisterButtons:
    Arguments @Handle

        On B$DebuggerReady = &FALSE, ExitP

        .If D$TabID = 0
            mov ebx 0
            While ebx < 8
                mov eax D$GPRRegMap+ebx*4
                call IsProcessMemory D$eax
                mov edi eax

                mov eax ebx
                add eax DEBUGDLG_FIRSTREG_BUTTON
                call 'USER32.GetDlgItem' D@Handle, eax
                mov esi eax
                call 'USER32.ShowWindow' esi, &SW_SHOW
                call 'USER32.EnableWindow' esi, edi
                inc ebx
            EndWhile
        .Else
            mov ebx DEBUGDLG_FIRSTREG_BUTTON
            While ebx <= DEBUGDLG_LASTREG_BUTTON
                call 'USER32.GetDlgItem' D@Handle, ebx
                call 'USER32.ShowWindow' eax, &SW_HIDE
                inc ebx
            EndWhile
        .EndIf
EndP

Proc DebugDialog_RedrawRegisterButtons:
    Arguments @Handle

        mov ebx DEBUGDLG_FIRSTREG_BUTTON
        While ebx <= DEBUGDLG_LASTREG_BUTTON
            call 'USER32.GetDlgItem' D@Handle, ebx
            call 'USER32.InvalidateRect' eax, &NULL, &TRUE
            inc ebx
        EndWhile
EndP
____________________________________________________________________________________________

Proc DebugDialog_AdjustDataTabSize:
    Arguments @Handle
    Local @TabHandle
    Uses ebx

        call 'USER32.GetDlgItem' D@Handle, DEBUGDLG_DATA_TAB
        mov D@TabHandle eax

        call 'USER32.GetClientRect' D@TabHandle, DebugRect
        SendMessage D@TabHandle, &TCM_ADJUSTRECT, &FALSE, DebugRect
        mov eax D$DebugRect@left
        mov ebx D$DebugRect@top
        mov ecx D$DebugRect@right
        mov edx D$DebugRect@bottom
        sub ecx eax
        sub edx ebx
        call 'USER32.SetWindowPos' D$CurrentDataPageHandle, 0, eax, ebx, ecx, edx, &SWP_NOZORDER
EndP
____________________________________________________________________________________________

[CONTINUE_RUN 0 CONTINUE_STEP 1 CONTINUE_STEPOVER 2 CONTINUE_RETURNTOCALLER 3]

[ContinueMode: ?] ; is used by debug thread

Proc DebugDialog_ContinueDebuggee:
    On B$IsDebugEvent = &FALSE, ExitP

    call DebugDialog_EnableContinueMenu &FALSE

    move D$ContinueMode D$UserWants

    If B$ContinueMode = CONTINUE_STEPOVER
        call NextInstructionDecode ; decode again - might be overwritten by callstackscanner
        call IsMultiStepInstruction
        On eax = &FALSE, mov B$ContinueMode CONTINUE_STEP
    ElseIf B$ContinueMode = CONTINUE_RUN
        mov D$LastSourcePos 0
    EndIf

    call 'User32.SetWindowTextA' D$DebugDialogHandle, {'Running ...' 0}

    call 'Kernel32.SetEvent' D$UserInputEvent
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; Debug dialog image list initialisation & finalization.

[DebugDialog_ImageList: ?]

Proc DebugDialog_CreateImageList:
    Local @Image, @Mask

  ; Create the images
    call 'User32.LoadImageA' D$hInstance, 10, &IMAGE_BITMAP, 0, 0, 0
    If eax = 0
        call ReportWinError {'DebugDialog_CreateImageList: LoadImage (1)' 0}
    EndIf
    mov D@Image eax

    call 'User32.LoadImageA' D$hInstance, 11, &IMAGE_BITMAP, 0, 0, 0
    If eax = 0
        call ReportWinError {'DebugDialog_CreateImageList: LoadImage (2)' 0}
    EndIf
    mov D@Mask eax

    call 'ComCtl32.ImageList_Create' 16, 16, &ILC_COLOR8+&ILC_MASK, 8, 8
    mov D$DebugDialog_ImageList eax

    call 'ComCtl32.ImageList_Add' D$DebugDialog_ImageList, D@Image, D@Mask
    If eax = 0-1
        call ReportWinError {'Debug TB: ImageList_Add' 0}
    EndIf

    call 'GDI32.DeleteObject' D@Image
    call 'GDI32.DeleteObject' D@Mask
EndP
____________________________________________________________________________________________

DebugDialog_DestroyImageList:
    call 'COMCTL32.ImageList_Destroy' D$DebugDialog_ImageList
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

DebuggerMENU: ; Create the MENU of the main debugger window.
____________________________________________________________________________________________
____________________________________________________________________________________________

[DebugMenuTable: 29
 ; ID             | String           | Shortcut      | Imageindex
 M02_Run            StrRunPtr          StrF6           0
 M02_Step_into      StrStepIntoPtr     StrF7           3
 M02_Step_Over      StrStepOverPtr     StrF8           4
 M02_ReturnToCaller StrReturnPtr       StrCtrlF7       5
 M02_Terminate      StrTerminatePtr    StrCtrlF6       1
 M02_Pause          StrPausePtr        StrCtrlF12      2
 M02_HoldOnBP       StrHoldOnBPPtr     0               7
 M02_Inst_Level     StrInstStepPtr     0               7
 M02_Source_Level   StrSrcStepPtr      0               7
 M02_ShowAll        StrShowAllPtr      0               7
 M02_Font           StrFontPtr         0               0-1
 M02_CPU_Info       StrCPUInfoPtr      0               0-1
 M02_FPU_Status     StrFPUStatusPtr    0               0-1
 M02_ShowCodeAt     StrShowCodeAtPtr   0               0-1
 M02_About          StrAboutPtr        0               0-1
 M02_Help           StrDbgHelpPtr      StrF1           0-1

 M03_SHOW_MEM       StrShowInMemInspPtr  0             0-1
 M03_SHOW_PMEM      StrShowPInMemInspPtr 0             0-1
 M03_SHOW_DECL      StrShowDeclPtr       0             0-1
 M03_WATCH_W        StrBreakOnWPtr       0             7
 M03_WATCH_RW       StrBreakOnRWPtr      0             7
 M03_SORTBYNAME     StrSortByNamePtr     0             7
 M03_SORTBYADDRESS  StrSortByAddrPtr     0             7

 MCS_SHOW_INVOKE    StrShowInvokePtr    0              0-1
 MCS_SHOW_DECL      StrShowDeclPtr      0              0-1
 MCS_SHOW_ALL       StrShowAllCallsPtr  0              7
 MCS_HIDE_EXTERNAL  StrHideModCallsPtr  0              7
 MCS_HIDE_INTRA     StrHideIMCallsPtr   0              7
 MCS_SHOWLOCALS     StrShowLocalsPtr    0              7]
____________________________________________________________________________________________

[M02_Menu  3000                  M02_Run  3001                   M02_Step_Into  3002
 M02_Step_Over  3003             M02_Return_to_Caller  3004      M02_Pause  3005
 M02_Terminate  3006             M02_Hold_on_BP  3007            M02_Inst_Level 3008
 M02_Source_Level 3009           M02_Show_All 3010
 M02_Font  3011                  M02_CPU_Info  3012              M02_FPU_Status  3013
 M02_Show_code_at  3014          M02_About  3015                 M02_Help  3016]
____________________________________________________________________________________________

[DebugMenubarButtons:
 ; iBitmap D, idCommand D, fsState B, fsStyle B, wPad1 W, Data D, iString D
 D$ 0-2 0              B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE+&BTNS_DROPDOWN W$ 0 D$ 0 0
 D$ 0-2 1              B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE+&BTNS_DROPDOWN W$ 0 D$ 0 0
 D$ 0-2 2              B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE+&BTNS_DROPDOWN W$ 0 D$ 0 0
 D$ 0-2 3              B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE+&BTNS_DROPDOWN W$ 0 D$ 0 0
 D$ 0-2 4              B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE+&BTNS_DROPDOWN W$ 0 D$ 0 0]

[ContinueMenu: ? BreakMenu: ? SettingsMenu: ? ExtrasMenu: ? HelpMenu: ?]
[NUM_MENUBAR_ENTRIES 5]

Proc DebugWindow_CreateMenu:
    Structure @Item 44,
        @Size 0,  @Mask 4,  @Type 8,  @State 12,  @ID 16,  @SubMenu 20,
        @bmpChecked 24,  @bmpUnchecked 28,  @ItemData 32,  @Data 36,  @cch 40

  ; Store menu handle in ebx
;    call 'User32.CreateMenu' | mov ebx eax

  ; Create menu-bar (toolbar)
    call 'User32.CreateWindowExA' 0, {'ToolbarWindow32' 0}, 0,
        DEBUG_TOOLBAR_STYLE,
        0, 0, 200, 0, D$DebugDialogHandle, DEBUGDLG_MENUBAR, D$hInstance, 0

    mov ebx eax
    SendMessage ebx, &WM_SETFONT, D$DialogFont_handle, 0
    SendMessage ebx, &TB_BUTTONSTRUCTSIZE, 20, 0

    move D$DebugMenubarButtons+16   D$StrContinuePtr
    move D$DebugMenubarButtons+36   D$StrBreakPtr
    move D$DebugMenubarButtons+56   D$StrSettingsPtr
    move D$DebugMenubarButtons+76   D$StrInformationPtr
    move D$DebugMenubarButtons+96   D$StrHelpPtr

    If D$UnicodeStrings = 0
        SendMessage ebx, &TB_ADDBUTTONSA, 5, DebugMenubarButtons
    Else
        SendMessage ebx, &TB_ADDBUTTONSW, 5, DebugMenubarButtons
    EndIf

  ; Add the bands
    mov D$DebugRebarBand@hwndChild ebx
    ;or D$DebugRebarBand@fStyle &RBBS_BREAK
    SendMessage ebx, &TB_GETMAXSIZE, 0, Point
    ;call 'user32.GetClientRect'  D$Debug_ToolbarHandle, DebugRect
    ;mov eax D$DebugRect@right | sub eax D$DebugRect@left
    mov eax D$PointX | add eax 10
    mov D$DebugRebarBand@cx eax
    SendMessage D$DebugRebarHandle, &RB_INSERTBAND, BAND_MENUBAR, DebugRebarBand
    SendMessage D$DebugRebarHandle, &RB_SHOWBAND, BAND_MENUBAR, 1
    ;and D$DebugRebarBand@fStyle (not &RBBS_BREAK)
    ________________________________________________________________________________________

    mov D@Size 44
    mov D@Mask &MIIM_ID+&MIIM_TYPE
    mov D@Type &MFT_OWNERDRAW

  ; Continue menu
    call 'USER32.CreatePopupMenu' | mov edi eax | mov D$ContinueMenu eax
    ;call AppendMenu ebx, &MF_STRING+&MF_POPUP, edi, D$StrContinuePtr

    mov D@ID M02_Run
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item

    mov D@ID M02_Step_Into
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item

    mov D@ID M02_Step_Over
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item

    mov D@Mask &MIIM_TYPE
    mov D@Type &MFT_SEPARATOR
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item

    mov D@Mask &MIIM_ID+&MIIM_TYPE
    mov D@Type &MFT_OWNERDRAW
    mov D@ID M02_Return_To_Caller
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item

  ; Break menu
    call 'USER32.CreatePopupMenu' | mov edi eax, D$BreakMenu eax
    ;call AppendMenu ebx, &MF_STRING+&MF_POPUP, edi, D$StrBreakPtr

    mov D@ID M02_Pause
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item

    mov D@ID M02_Terminate
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item

  ; Settings menu
    call 'USER32.CreatePopupMenu' | mov edi eax, D$SettingsMenu eax
    ;call AppendMenu ebx, &MF_STRING+&MF_POPUP, edi, D$StrSettingsPtr

    mov D@ID M02_Hold_on_BP
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item
    mov D@ID M02_Inst_Level
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item
    mov D@ID M02_Source_Level
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item
    mov D@ID M02_Show_All
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item
    mov D@ID M02_Font
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item

    mov D@Mask &MIIM_TYPE
    mov D@Type &MFT_SEPARATOR
    call 'User32.InsertMenuItemA' edi, 4, 1, D@Item
    call 'User32.InsertMenuItemA' edi, 3, 1, D@Item
    call 'User32.InsertMenuItemA' edi, 1, 1, D@Item
;;
  ; Toolbar sub menu
    call 'USER32.CreatePopupMenu' | mov esi eax, D$Debug_ToolbarMenu eax
    call 'User32.AppendMenuA' edi, &MF_STRING+&MF_POPUP, esi, {'Toolbar' 0}
    ;call 'User32.AppendMenuA' ebx, &MF_STRING, DEBUGDLG_TB_CONFIGURE, {'Configure ...' 0}
    call 'User32.AppendMenuA' esi, &MF_STRING, DEBUGDLG_TB_SHOW_TEXT, {'Show text' 0}
    call 'User32.AppendMenuA' esi, &MF_SEPARATOR, 0, 0
    call 'User32.AppendMenuA' esi, &MF_STRING+&MF_CHECKED, DEBUGDLG_TB_SHOW_CMDS, {'Show commands' 0}
    call 'User32.AppendMenuA' esi, &MF_STRING+&MF_CHECKED, DEBUGDLG_TB_SHOW_FLAGS, {'Show flags' 0}
    call 'User32.AppendMenuA' esi, &MF_STRING, DEBUGDLG_TB_SHOW_FPU, {'Show FPU flags' 0}
;;
  ; Information menu
    call 'USER32.CreatePopupMenu' | mov edi eax, D$ExtrasMenu eax
    ;call AppendMenu ebx, &MF_STRING+&MF_POPUP, edi, D$StrInformationPtr

    mov D@Mask &MIIM_ID+&MIIM_TYPE
    mov D@Type &MFT_OWNERDRAW

    mov D@ID M02_CPU_Info
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item
    mov D@ID M02_FPU_Status
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item
    mov D@ID M02_Show_code_at
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item

    mov D@Mask &MIIM_TYPE
    mov D@Type &MFT_SEPARATOR
    call 'User32.InsertMenuItemA' edi, 2, 1, D@Item

  ; Help menu
    call 'USER32.CreatePopupMenu' | mov edi eax, D$HelpMenu eax
    ;call AppendMenu ebx, &MF_STRING+&MF_POPUP, edi, D$StrHelpPtr

    mov D@Mask &MIIM_ID+&MIIM_TYPE
    mov D@Type &MFT_OWNERDRAW

    mov D@ID M02_About
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item
    mov D@ID M02_Help
    call 'User32.InsertMenuItemA' edi, -1, 1, D@Item

  ; Return menu handle
    mov D$MenuBarHandle ebx
    mov eax ebx
EndP
____________________________________________________________________________________________

[MenubarHook: ? CurrentMenubarIndex: ?]

; Observe mouse messages to close the popup menu when the user clicks outside the menu area
; and to switch to other submenus when the mouse hovers above another menubar item.

Proc MenubarHookProc:
    Arguments @Code, @wParam, @Msg
    Uses ebx, edi

    call 'USER32.CallNextHookEx' D$MenubarHook, D@Code, D@wParam, D@Msg
    push eax

        mov ebx D@Msg
        mov eax D$ebx+4

        .If eax = &WM_LBUTTONDOWN
          ; Collapse menu if clicked outside menu area.
            If D@Code <> &MSGF_MENU
                call 'User32.PostMessageA' D$DebugDialogHandle, WM_COLLAPSEMENU, 0, 0
            EndIf

        .ElseIf eax = &WM_RBUTTONDOWN
          ; Collapse menu if clicked outside menu area.
            If D@Code <> &MSGF_MENU
                call 'User32.PostMessageA' D$DebugDialogHandle, WM_COLLAPSEMENU, 0, 0
            EndIf

        .ElseIf eax = &WM_MOUSEMOVE
          ; Check if mouse hovered above different menubar item. Perform hittest to
          ; identify which item is selected and if selection has changed collapse the
          ; old menu and track the new menu.
            movzx eax W$ebx+12
            movzx edx W$ebx+14
            mov D$PointX eax
            mov D$PointY edx
            call 'USER32.ScreenToClient' D$MenuBarHandle, Point
            call 'User32.SendMessageA' D$MenuBarHandle, &TB_HITTEST, 0, Point
            test eax eax | js L0>
            cmp eax NUM_MENUBAR_ENTRIES | jae L0>
            mov edi eax
            If D$CurrentMenubarIndex <> eax
                call 'User32.PostMessageA' D$DebugDialogHandle, WM_COLLAPSEMENU, 0, 0
                call 'User32.PostMessageA' D$DebugDialogHandle, WM_POPUPMENU, edi, 0
            EndIf
L0:
        .ElseIf eax = &WM_KEYDOWN
          ; Select the next submenu when user presses left/right.
          ; Note: This does *not* work when the mouse is over the menubar as
          ; it continously receives WM_MOUSEMOVE messages (why?) which makes it
          ; switch back to the former menu immediately.
            If D$ebx+8 = &VK_LEFT
                call 'User32.PostMessageA' D$DebugDialogHandle, WM_COLLAPSEMENU, 0, 0
                mov eax D$CurrentMenubarIndex
                dec eax | jns L1>
                mov eax (NUM_MENUBAR_ENTRIES-1)
L1:             call 'User32.PostMessageA' D$DebugDialogHandle, WM_POPUPMENU, eax, 0
            ElseIf D$ebx+8 = &VK_RIGHT
                call 'User32.PostMessageA' D$DebugDialogHandle, WM_COLLAPSEMENU, 0, 0
                mov eax D$CurrentMenubarIndex
                inc eax | cmp eax NUM_MENUBAR_ENTRIES | jb L1>
                mov eax 0
L1:             call 'User32.PostMessageA' D$DebugDialogHandle, WM_POPUPMENU, eax, 0
            EndIf

        .EndIf

    pop eax
EndP
____________________________________________________________________________________________

[HotTracking: ? HotTrackMenu: ?]

; Track popup menu and prepare the GUI for menu navigation (install hook).
; TODO: Fix alignment of the rightmost popup menus.

Proc DebugDialog_OnPopupMenu:
    Arguments @Item
    Structure @Rect 16, @left 0,  @top 4,  @right 8,  @bottom 12

    SendMessage D$MenuBarHandle, &TB_GETRECT, D@Item, D@Rect
    move D$PointX D@left
    move D$PointY D@bottom
    call 'USER32.ClientToScreen' D$MenuBarHandle, Point

    mov edx D@Item
    If edx = 0
        mov eax D$ContinueMenu
    ElseIf edx = 1
        mov eax D$BreakMenu
    ElseIf edx = 2
        mov eax D$SettingsMenu
    ElseIf edx = 3
        mov eax D$ExtrasMenu
    ElseIf edx = 4
        mov eax D$HelpMenu
    EndIf
    mov D$HottrackMenu eax, D$CurrentMenuBarIndex edx

  ; How can I measure the width of a popup menu before it is tracked?
    call 'USER32.GetWindowRect' D$HotTrackMenu, D@Rect
    call 'USER32.GetSystemMetrics' &SM_CXSCREEN
    mov ecx D@right | sub ecx D@left
    mov edx D$PointX
    add edx ecx
    If edx > eax
        sub eax ecx
        mov D$PointX eax
    EndIf

    SendMessage D$MenuBarHandle, &TB_PRESSBUTTON, D@Item, 1

    mov D$HotTracking 1

  ; Install mouse hook
    If D$MenubarHook <> 0
        call 'OutputDebugStringA' {'Unhook (!)' 0}
        call 'USER32.UnhookWindowsHookEx' D$MenubarHook
        mov D$MenubarHook 0
    EndIf

    call 'Kernel32.GetCurrentThreadId'
    call 'User32.SetWindowsHookExA' &WH_MSGFILTER, MenubarHookProc, D$hInstance, eax
    mov D$MenubarHook eax

    PRINTLN 'SetHook'

  ; Open the menu. Note: The call doesn't return until the menu is closed!
    call 'USER32.TrackPopupMenu' D$HotTrackMenu, &TPM_LEFTBUTTON, D$PointX, D$PointY, 0, D$DebugDialogHandle, 0

    SendMessage D$MenuBarHandle, &TB_PRESSBUTTON, D@Item, 0

    If D$MenuBarHook <> 0
        PRINTLN 'Unhook'
        call 'USER32.UnhookWindowsHookEx' D$MenubarHook
        mov D$MenubarHook 0
    EndIf

    mov D$HotTracking 0
EndP
____________________________________________________________________________________________
[PRINTLN | call 'OutputDebugStringA' {#1 0}]

; Collapse menu.
; TODO: Check if WM_CANCELMODE works under Windows NT.

DebugDialog_OnCollapseMenu:
    SendMessage D$DebugDialogHandle, &WM_CANCELMODE, 0, 0
    mov D$HotTracking 0
    If D$MenubarHook <> 0
        PRINTLN 'Unhook (C)'
        call 'USER32.UnhookWindowsHookEx' D$MenubarHook
        mov D$MenubarHook 0
    EndIf
ret
____________________________________________________________________________________________

; Show menu when user clicks on menubar item.

Proc DebugDialog_MenubarNotify:
    Arguments @NotifyMsg, @Code, @Item

    mov eax 0

    If D@Code = &TBN_DROPDOWN
        call 'User32.PostMessageA' D$DebugDialogHandle, WM_POPUPMENU, D@Item, 0
        mov eax &TBDDRET_DEFAULT
    EndIf
EndP
____________________________________________________________________________________________

; Handle key commands [F10, ALT+x]

[PrevFocusWindow: ?]

Proc DebugDialog_OnSysCommand:
    Arguments @Handle, @Type, @lParam

    ..If D@Type = &SC_KEYMENU

        .If D$HotTracking = 0

            mov eax D@lParam
            If eax = 0 ; F10
                ;SendMessage D$MenuBarHandle, &TB_PRESSBUTTON, 0, 0
                SendMessage D$MenuBarHandle, &TB_SETHOTITEM, 0, 0
                call 'USER32.SetFocus' D$MenuBarHandle
                ;mov D$PrevFocusWindow eax
            EndIf

        .EndIf

        mov eax 0

    ..Else
        call 'User32.DefWindowProcA' D@Handle, &WM_SYSCOMMAND, D@Type, D@lParam
    ..EndIf
EndP
____________________________________________________________________________________________

; Handle keyboard menu navigation [Arrow keys, ESC]

Proc DebugDialog_OnKeyDown:
    Arguments @Handle, @Key, @lParam

    SendMessage D$MenuBarHandle, &TB_GETHOTITEM, 0, 0

    .If eax <> 0-1
        If D@Key = &VK_RIGHT
            inc eax
            On eax = NUM_MENUBAR_ENTRIES,
                mov eax 0

        ElseIf D@Key = &VK_LEFT
            dec eax
            On eax = 0-1
                mov eax NUM_MENUBAR_ENTRIES-1

        ElseIf D@Key = &VK_ESCAPE
            ;call 'USER32.SetFocus' D$PrevFocusWindow
            mov eax 0-1
        EndIf

        SendMessage D$MenuBarHandle, &TB_SETHOTITEM, eax, 0
    .EndIf

    mov eax 0
EndP
____________________________________________________________________________________________
; Call (indeed jump to) either to the ansi or unicode taste of API functions.

AppendMenu:
    cmp B$UnicodeStrings 1 | je L0>
    jmp 'User32.AppendMenuA'
L0: jmp 'User32.AppendMenuW'

DrawText:
    cmp B$UnicodeStrings 1 | je L0>
    jmp 'User32.DrawTextA'
L0: jmp 'User32.DrawTextW'
____________________________________________________________________________________________

____________________________________________________________________________________________

; Enable / Gray-out execution control commands.

Proc DebugDialog_EnableContinueMenu:
    Arguments @Enable

    If D@Enable = 1
        mov ebx &MF_ENABLED
    Else
        mov ebx &MF_GRAYED
    EndIf

    call 'USER32.EnableMenuItem' D$ContinueMenu, M02_Run, ebx
    call 'USER32.EnableMenuItem' D$ContinueMenu, M02_Step_Into, ebx
    call 'USER32.EnableMenuItem' D$ContinueMenu, M02_Step_Over, ebx
    call 'USER32.EnableMenuItem' D$ContinueMenu, M02_Return_to_Caller, ebx

    SendMessage D$Debug_ToolbarHandle, &TB_ENABLEBUTTON, M02_Run, D@Enable
    SendMessage D$Debug_ToolbarHandle, &TB_ENABLEBUTTON, M02_Step_Into, D@Enable
    SendMessage D$Debug_ToolbarHandle, &TB_ENABLEBUTTON, M02_Step_over, D@Enable
    SendMessage D$Debug_ToolbarHandle, &TB_ENABLEBUTTON, M02_Return_to_Caller, D@Enable

  ; Invert
    If D@Enable = 1
        mov ebx &MF_GRAYED
        mov D@Enable 0
    Else
        mov ebx &MF_ENABLED
        mov D@Enable 1
    EndIf
    call 'USER32.EnableMenuItem' D$BreakMenu, M02_Pause, ebx
    SendMessage D$Debug_ToolbarHandle, &TB_ENABLEBUTTON, M02_Pause, D@Enable

    call 'USER32.DrawMenuBar' D$DebugDialogHandle
EndP
____________________________________________________________________________________________

DebugDialog_InitDbgMenu:
    call 'USER32.CheckMenuItem' D$SettingsMenu, M02_Hold_on_BP, &MF_CHECKED
    call 'USER32.CheckMenuRadioItem' D$SettingsMenu,
        M02_Inst_Level, M02_Source_Level, M02_Inst_Level, &MF_BYCOMMAND

    call DebugDialog_EnableContinueMenu 0
ret
____________________________________________________________________________________________

; Process WM_DRAWITEM message for owner-drawn menu items.

Proc DebugDialog_OnDrawMenuItem:
    Arguments @DrawItemStruc
    Local @Brush

    mov ebx D@DrawItemStruc

    mov esi DebugMenuTable
    lodsd | mov ecx eax ; number of entries
    mov eax D$ebx+DRAWITEM_ITEMID
    While D$esi <> eax
        add esi 16
        dec ecx | jz L9>>
    EndWhile

    call 'GDI32.SelectObject' D$ebx+DRAWITEM_HDC, D$DialogFont_handle
    push eax

    Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_GRAYED
        call 'USER32.GetSysColor' &COLOR_GRAYTEXT
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax
        jmp L1>
    Test_Else_If D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED
        call 'USER32.GetSysColor' &COLOR_HIGHLIGHTTEXT
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax

        call 'USER32.GetSysColor' &COLOR_HIGHLIGHT
        call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, eax

        call 'USER32.GetSysColorBrush' &COLOR_HIGHLIGHT
    Test_Else
        call 'USER32.GetSysColor' &COLOR_MENUTEXT
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax

L1:     call 'USER32.GetSysColor' &COLOR_MENU
        call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, eax

        call 'USER32.GetSysColorBrush' &COLOR_MENU
    Test_End

    lea edx D$ebx+DRAWITEM_RCITEM_LEFT
    call 'USER32.FillRect' D$ebx+DRAWITEM_HDC, edx, eax

    mov eax D$esi+12 ; image index
    If eax <> 0-1
        mov ecx D$ebx+DRAWITEM_RCITEM_LEFT | add ecx 2
        mov edx D$ebx+DRAWITEM_RCITEM_TOP  | add edx 2
        Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_GRAYED
            mov edi &ILD_MASK
        Test_Else_If D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED
            mov edi &ILD_NORMAL
        Test_Else
            mov edi &ILD_TRANSPARENT
        Test_End

        Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_CHECKED
            mov eax 6
        Test_End

L0:     call 'COMCTL32.ImageList_Draw' D$DebugDialog_ImageList, eax, D$ebx+DRAWITEM_HDC, ecx, edx, edi
    EndIf

    add D$ebx+DRAWITEM_RCITEM_LEFT 22

    mov eax D$esi+4
    call DrawMenuItemText D$eax, &DT_LEFT

    mov eax D$esi+8
    If eax <> 0
      ; Draw shortcut rightaligned
        dec D$ebx+DRAWITEM_RCITEM_RIGHT
        call DrawMenuItemTextA eax, &DT_RIGHT
    EndIf

    pop eax
    call 'GDI32.SelectObject' D$ebx+DRAWITEM_HDC, eax

L9: mov eax 1
EndP
____________________________________________________________________________________________

; ebx > DRAWITEMSTRUCT

Proc DrawMenuItemText: ; Localized (ANSI or Unicode)
    Arguments @Text, @Align

  ; Grayed text is drawn white overlayed by gray (shifted 1 pixel in both directions)
    Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_GRAYED

        inc D$ebx+DRAWITEM_RCITEM_TOP
        inc D$ebx+DRAWITEM_RCITEM_BOTTOM
        inc D$ebx+DRAWITEM_RCITEM_LEFT
        inc D$ebx+DRAWITEM_RCITEM_RIGHT

        call 'USER32.GetSysColor' &COLOR_3DHIGHLIGHT
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax
        lea edx D$ebx+DRAWITEM_RCITEM_LEFT
        mov eax &DT_SINGLELINE+&DT_VCENTER | or eax D@Align
        call DrawText D$ebx+DRAWITEM_HDC, D@Text, 0-1, edx, eax

        dec D$ebx+DRAWITEM_RCITEM_TOP
        dec D$ebx+DRAWITEM_RCITEM_BOTTOM
        dec D$ebx+DRAWITEM_RCITEM_LEFT
        dec D$ebx+DRAWITEM_RCITEM_RIGHT

        call 'USER32.GetSysColor' &COLOR_GRAYTEXT
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax
        call 'GDI32.SetBkMode' D$ebx+DRAWITEM_HDC, &TRANSPARENT

    Test_End

    lea edx D$ebx+DRAWITEM_RCITEM_LEFT
    mov eax &DT_SINGLELINE+&DT_VCENTER | or eax D@Align
    call DrawText D$ebx+DRAWITEM_HDC, D@Text, 0-1, edx, eax

EndP
____________________________________________________________________________________________

; ebx > DRAWITEMSTRUCT

Proc DrawMenuItemTextA: ; ANSI only
    Arguments @Text, @Align

  ; Grayed text is drawn white overlayed by gray (shifted 1 pixel in both directions)
    Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_GRAYED

        inc D$ebx+DRAWITEM_RCITEM_TOP
        inc D$ebx+DRAWITEM_RCITEM_BOTTOM
        inc D$ebx+DRAWITEM_RCITEM_LEFT
        inc D$ebx+DRAWITEM_RCITEM_RIGHT

        call 'USER32.GetSysColor' &COLOR_3DHIGHLIGHT
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax
        lea edx D$ebx+DRAWITEM_RCITEM_LEFT
        mov eax &DT_SINGLELINE+&DT_VCENTER | or eax D@Align
        call 'User32.DrawTextA' D$ebx+DRAWITEM_HDC, D@Text, 0-1, edx, eax

        dec D$ebx+DRAWITEM_RCITEM_TOP
        dec D$ebx+DRAWITEM_RCITEM_BOTTOM
        dec D$ebx+DRAWITEM_RCITEM_LEFT
        dec D$ebx+DRAWITEM_RCITEM_RIGHT

        call 'USER32.GetSysColor' &COLOR_GRAYTEXT
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax
        call 'GDI32.SetBkMode' D$ebx+DRAWITEM_HDC, &TRANSPARENT

    Test_End

    lea edx D$ebx+DRAWITEM_RCITEM_LEFT
    mov eax &DT_SINGLELINE+&DT_VCENTER | or eax D@Align
    call 'User32.DrawTextA' D$ebx+DRAWITEM_HDC, D@Text, 0-1, edx, eax

EndP
____________________________________________________________________________________________

Proc DebugDialog_OnMeasureMenuItem:
    Arguments @MeasureItem

    mov ebx D@MeasureItem
    mov edx D$ebx+8 ; item id
    mov esi DebugMenuTable
    lodsd ; eax = num entries
    While D$esi <> edx
        add esi 16
        dec eax | jz L9>
    EndWhile

    mov eax D$esi+4
    call MeasureStringWidth D$eax, D$DialogFontHandle

    On D$esi+8 <> 0,
        add eax 50 ; shortcut

    add eax 22 ; icon+padding

    mov D$ebx+12 eax ; width
    mov D$ebx+16 20 ; height
L9:
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

DebuggerToolbar: ; TOOLBAR and coolbar (REBAR) of debugger main window.
____________________________________________________________________________________________
____________________________________________________________________________________________

[DEBUGDLG_REBAR 331 DEBUGDLG_TOOLBAR 332 DEBUGDLG_MENUBAR 333
 DEBUGDLG_FLAGS 334 DEBUGDLG_FPUFLAGS 335]

; Flow control buttons
[DebugToolbarButtons:
 ; iBitmap D, idCommand D, fsState B, fsStyle B, wPad1 W, Data D, iString D
 D$ 0 M02_Run              B$ 0                &BTNS_AUTOSIZE W$ 0 D$ 0 0
 D$ 1 M02_Terminate        B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE W$ 0 D$ 0 0
 D$ 2 M02_Pause            B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE W$ 0 D$ 0 0
 D$ 3 M02_Step_Into        B$ 0                &BTNS_AUTOSIZE W$ 0 D$ 0 0
 D$ 4 M02_Step_Over        B$ 0                &BTNS_AUTOSIZE W$ 0 D$ 0 0
 D$ 5 M02_Return_to_Caller B$ 0                &BTNS_AUTOSIZE W$ 0 D$ 0 0]
 ; Strings

[FlagStr:
    @O: 'O'   0 @S: 'S'    0 @Z: 'Z'   0 @C: 'C'   0 @P: 'P' 0 @D: 'Dir' 0
    @I: 'Int' 0 @T: 'Trap' 0 @A: 'Aux' 0
    @C3: 'C3' 0 @C2: 'C2'  0 @C1: 'C1' 0 @C0: 'C0' 0]

; Standard flag buttons
[DebugFlagButtons:
 D$ 0-2 90 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@O
 D$ 0-2 91 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@S
 D$ 0-2 92 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@Z
 D$ 0-2 93 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@C
 D$ 0-2 94 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@P
 D$ 0-2 95 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@D
 D$ 0-2 96 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@I
 D$ 0-2 97 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@T
 D$ 0-2 98 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@A]

; FPU flag buttons
[DebugFPUButtons:
 D$ 0-2 101 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@C3
 D$ 0-2 102 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@C2
 D$ 0-2 103 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@C1
 D$ 0-2 104 B$ &TBSTATE_ENABLED &BTNS_AUTOSIZE__&BTNS_CHECK W$ 0 D$ 0 FlagStr@C0]

[DebugToolbarHandle: ? Debug_FlagBarHandle: ? Debug_FPUBarHandle: ? DebugRebarHandle: ? Debug_ToolbarMenu: ?]

[DebugRebarBand:
   @cbSize:     D$ len
   @fMask:      D$ &RBBIM_CHILD+&RBBIM_STYLE+&RBBIM_CHILDSIZE+&RBBIM_SIZE+&RBBIM_IDEALSIZE+&RBBIM_HEADERSIZE
   @fStyle:     D$ &RBBS_CHILDEDGE+&RBBS_GRIPPERALWAYS ;+&RBBS_BREAK
   0 0 0 0 0
   @hwndChild:  D$ 0
   @cxMinChild: D$ 10
   @cyMinChild: D$ 22
   @cx:         D$ 0 0
   @wID:        D$ 0
   @cyChild:    D$ 0
   @cyMaxChild: D$ 0
   @cyIntegral: D$ 0
   @cxIdeal:    D$ 0 0
   @cxHeader:   D$ 6 ]


[Init_Common_Controls:
 @dwSize: D$ len
 @dwICC:  D$ &ICC_COOL_CLASSES+&ICC_BAR_CLASSES]
____________________________________________________________________________________________

[DEBUG_TOOLBAR_STYLE &WS_CHILD+&CCS_ADJUSTABLE+&TBSTYLE_FLAT+&TBSTYLE_LIST+&TBSTYLE_AUTOSIZE+&TBSTYLE_TRANSPARENT+&CCS_NOPARENTALIGN+&CCS_NODIVIDER+&CCS_NORESIZE]

[DebugShowTBText: ?]

Proc DebugDialog_CreateCommandTB:
  ; Save states & clear if toolbar is REcreated
    .If D$Debug_ToolbarHandle <> 0
        SendMessage D$DebugToolbarHandle, &TB_GETSTATE, M02_Run, 0
        mov B$DebugToolbarButtons+8 al
        SendMessage D$DebugToolbarHandle, &TB_GETSTATE, M02_Terminate, 0
        mov B$DebugToolbarButtons+28 al
        SendMessage D$DebugToolbarHandle, &TB_GETSTATE, M02_Pause, 0
        mov B$DebugToolbarButtons+48 al
        SendMessage D$DebugToolbarHandle, &TB_GETSTATE, M02_Step_Into, 0
        mov B$DebugToolbarButtons+68 al
        SendMessage D$DebugToolbarHandle, &TB_GETSTATE, M02_Step_Over, 0
        mov B$DebugToolbarButtons+88 al
        SendMessage D$DebugToolbarHandle, &TB_GETSTATE, M02_Return_to_Caller, 0
        mov B$DebugToolbarButtons+108 al
        SendMessage D$Debug_RebarHandle, &RB_DELETEBAND, 1, 0
        call 'USER32.DestroyWindow' D$Debug_ToolbarHandle
    .EndIf

  ; Create toolbar
    call 'User32.CreateWindowExA' 0, {'ToolbarWindow32' 0}, 0,
        DEBUG_TOOLBAR_STYLE,
        0, 0, 120, 0, D$DebugDialogHandle, DEBUGDLG_TOOLBAR, D$hInstance, 0

    mov D$DebugToolbarHandle eax
    SendMessage eax, &WM_SETFONT, D$DialogFont_handle, 0

    SendMessage D$Debug_ToolbarHandle, &TB_BUTTONSTRUCTSIZE, 20, 0
    SendMessage D$Debug_ToolbarHandle, &TB_SETIMAGELIST, 0, D$DebugDialog_ImageList

  ; Activate / Deactivate Text
    If D$DebugShowTBText = 1
        move D$DebugToolbarButtons+16   D$StrRunPtr
        move D$DebugToolbarButtons+36   D$StrTerminatePtr
        move D$DebugToolbarButtons+56   D$StrPausePtr
        move D$DebugToolbarButtons+76   D$StrStepPtr
        move D$DebugToolbarButtons+96   D$StrStepOverPtr
        move D$DebugToolbarButtons+116  D$StrRetPtr
    Else
        mov D$DebugToolbarButtons+16   0
        mov D$DebugToolbarButtons+36   0
        mov D$DebugToolbarButtons+56   0
        mov D$DebugToolbarButtons+76   0
        mov D$DebugToolbarButtons+96   0
        mov D$DebugToolbarButtons+116  0
    EndIf

    If D$UnicodeStrings = 0
        SendMessage D$Debug_ToolbarHandle, &TB_ADDBUTTONSA, 6, DebugToolbarButtons
    Else
        SendMessage D$Debug_ToolbarHandle, &TB_ADDBUTTONSW, 6, DebugToolbarButtons
    EndIf

  ; Add band
    move D$DebugRebarBand@hwndChild D$DebugToolbarHandle
    SendMessage D$Debug_ToolbarHandle, &TB_GETMAXSIZE, 0, Point
    ;call 'user32.GetClientRect'  D$Debug_ToolbarHandle, DebugRect
    ;mov eax D$DebugRect@right | sub eax D$DebugRect@left
    mov eax D$PointX | add eax 10
    mov D$DebugRebarBand@cx eax
    ;mov D$DebugRebarBand@cxIdeal eax
    ;mov D$DebugRebarBand@cxMinChild eax

    SendMessage D$DebugRebarHandle, &RB_INSERTBAND, BAND_COMMANDBAR, DebugRebarBand
    SendMessage D$DebugRebarHandle, &RB_SHOWBAND, BAND_COMMANDBAR, 1
EndP
____________________________________________________________________________________________

[BAND_MENUBAR 0 BAND_COMMANDBAR 1 BAND_FLAGS 2 BAND_FPUFLAGS 3]

Proc DebugDialog_CreateToolbar:

    call 'ComCtl32.InitCommonControlsEx' Init_Common_Controls

  ; Create rebar
    call 'User32.CreateWindowExA',
        &WS_EX_TOOLWINDOW, {'ReBarWindow32' 0}, 0,
        &WS_VISIBLE+&WS_CHILD+&RBS_VARHEIGHT+&RBS_FIXEDORDER+&RBS_BANDBORDERS+&WS_BORDER+&RBS_VERTICALGRIPPER, ;+&CCS_NODIVIDER,
        0, 0, 0, 0,
        D$DebugDialogHandle, DEBUGDLG_REBAR,
        D$hInstance, 0

    mov D$DebugRebarHandle eax

  ; Create menubar
    call DebugWindow_CreateMenu

  ; Create flag toolbar
    call 'User32.CreateWindowExA' 0, {'ToolbarWindow32' 0}, 0,
        DEBUG_TOOLBAR_STYLE,
        0, 0, 80, 0, D$DebugDialogHandle, DEBUGDLG_FLAGS, D$hInstance, 0

    mov D$Debug_FlagBarHandle eax
    SendMessage eax, &WM_SETFONT, D$DialogFont_handle, 0

  ; Create FPU flag toolbar
    call 'User32.CreateWindowExA' 0, {'ToolbarWindow32' 0}, 0,
        DEBUG_TOOLBAR_STYLE,
        0, 0, 80, 0, D$DebugDialogHandle, DEBUGDLG_FPUFLAGS, D$hInstance, 0

    mov D$Debug_FPUBarHandle eax
    SendMessage eax, &WM_SETFONT, D$DialogFont_handle, 0

  ; Send the TB_BUTTONSTRUCTSIZE message, which is required for
  ; backward compatibility.
    SendMessage D$Debug_FlagBarHandle, &TB_BUTTONSTRUCTSIZE, 20, 0
    SendMessage D$Debug_FPUBarHandle, &TB_BUTTONSTRUCTSIZE, 20, 0

    call DebugDialog_CreateCommandTB

  ; Add buttons
    SendMessage D$Debug_FlagBarHandle, &TB_ADDBUTTONS, 9, DebugFlagButtons
    SendMessage D$Debug_FPUBarHandle, &TB_ADDBUTTONS, 4, DebugFPUButtons

  ; Add the bands
    move D$DebugRebarBand@hwndChild D$Debug_FlagbarHandle
    SendMessage D$Debug_FlagbarHandle, &TB_GETMAXSIZE, 0, Point
    mov eax D$PointX ;| add eax 8
    ;call 'user32.GetClientRect'  D$Debug_FlagbarHandle, DebugRect
    ;mov eax D$DebugRect@right | sub eax D$DebugRect@left

    ;mov  D$DebugRebarBand@cxIdeal eax
    mov  D$DebugRebarBand@cx eax
    ;mov  D$DebugRebarBand@cxMinChild eax
    SendMessage D$DebugRebarHandle, &RB_INSERTBAND, BAND_FLAGS, DebugRebarBand
    SendMessage D$DebugRebarHandle, &RB_SHOWBAND, BAND_FLAGS, 1

    move D$DebugRebarBand@hwndChild D$Debug_FPUbarHandle
    SendMessage D$Debug_FPUbarHandle, &TB_GETMAXSIZE, 0, Point
    mov eax D$PointX ;| add eax 8
    ;call 'user32.GetClientRect'  D$Debug_FPUbarHandle, DebugRect
    ;mov eax D$DebugRect@right | sub eax D$DebugRect@left

    ;mov  D$DebugRebarBand@cxIdeal eax
    mov  D$DebugRebarBand@cx eax
    ;mov  D$DebugRebarBand@cxMinChild eax
    or   D$DebugRebarBand@fStyle &RBBS_HIDDEN
    SendMessage D$DebugRebarHandle, &RB_INSERTBAND, 0-1, DebugRebarBand

  ; Create the context menu
    call 'USER32.CreatePopupMenu' | mov ebx eax, D$Debug_ToolbarMenu eax
    ;call 'User32.AppendMenuA' ebx, &MF_STRING, DEBUGDLG_TB_CONFIGURE, {'Configure ...' 0}
    call 'User32.AppendMenuA' ebx, &MF_STRING, DEBUGDLG_TB_SHOW_TEXT, {'Show text' 0}
    call 'User32.AppendMenuA' ebx, &MF_SEPARATOR, 0, 0
    call 'User32.AppendMenuA' ebx, &MF_STRING+&MF_CHECKED, DEBUGDLG_TB_SHOW_CMDS, {'Show commands' 0}
    call 'User32.AppendMenuA' ebx, &MF_STRING+&MF_CHECKED, DEBUGDLG_TB_SHOW_FLAGS, {'Show flags' 0}
    call 'User32.AppendMenuA' ebx, &MF_STRING, DEBUGDLG_TB_SHOW_FPU, {'Show FPU flags' 0}

;;
    SendMessage D@TbHandle, &TB_GETITEMRECT, 0, DebugRect    
    mov eax D$DebugRect@width | shl eax 16
    SendMessage D@TbHandle, &TB_SETBUTTONWIDTH, 0, eax
;;
;;
    SendMessage D$Debug_ToolbarHandle, &TB_AUTOSIZE, 0, 0 
    SendMessage D$Debug_FlagbarHandle, &TB_AUTOSIZE, 0, 0 
    SendMessage D$Debug_FPUbarHandle,  &TB_AUTOSIZE, 0, 0 
;;
    ;call 'User32.ShowWindow' D@TbHandle, &SW_SHOW
EndP
____________________________________________________________________________________________

DebugDialog_DestroyToolbar:
    call 'USER32.DestroyWindow' D$DebugToolbarHandle
    mov D$DebugToolbarHandle 0
    call 'USER32.DestroyWindow' D$DebugRebarHandle
    mov D$DebugRebarHandle 0
    call 'USER32.DestroyMenu' D$Debug_ToolbarMenu
    mov D$Debug_ToolbarMenu 0
    mov D$DebugDialog.RebarHeight 0
ret
____________________________________________________________________________________________

; User rightclicked on the dialog. Test if it is in the rebar and show context menu.
; Position is given in screen coordinates.

Proc DebugDialog_RebarHitTest:
    Arguments @X @Y
    Structure @RBHitTest 16, @pt.x 0,  @pt.y 4,  @flags 8,  @iBand 12

  ; Hittest expects client coordinates
    move D@pt.x D@X, D@pt.y D@Y
    call 'USER32.ScreenToClient' D$Debug_RebarHandle, D@RBHitTest
    SendMessage D$Debug_RebarHandle, &RB_HITTEST, 0, D@RBHitTest

  ; Show context menu
    If D@iBand <> 0-1
        call 'USER32.TrackPopupMenu' D$Debug_ToolbarMenu, 0, D@X, D@Y, 0, D$DebugDialogHandle, 0
    EndIf
EndP
____________________________________________________________________________________________

; Show / Hide rebar-band containing a toolbar.
; Command references the menu item clicked.

Proc DebugDialog_ToggleToolbar:
    Arguments @Command

  ; store band index in ebx
    If D@Command = DEBUGDLG_TB_SHOW_CMDS
        mov ebx 1
    ElseIf D@Command = DEBUGDLG_TB_SHOW_FLAGS
        mov ebx 2
    ElseIf D@Command = DEBUGDLG_TB_SHOW_FPU
        mov ebx 3
    EndIf

  ; get check state of menu item, invert, toggle band and set inverted check state
    call 'User32.GetMenuState' D$Debug_ToolbarMenu, D@Command, &MF_BYCOMMAND
    push eax
        xor edx edx | test eax &MF_CHECKED | setz dl
        SendMessage D$Debug_RebarHandle, &RB_SHOWBAND, ebx, edx
    pop eax
    xor eax &MF_CHECKED | and eax &MF_CHECKED
    call 'USER32.CheckMenuItem' D$Debug_ToolbarMenu, D@Command, eax
EndP
____________________________________________________________________________________________

Proc DebugDialog_ToggleToolbarText:
    Structure @TBButtonInfo 32, @Size 0, @Mask 4, @Text 24

    mov D@Size 32, D@Mask &TBIF_TEXT

  ; get check state of menu item, invert, toggle band and set inverted check state
    call 'User32.GetMenuState' D$Debug_ToolbarMenu, DEBUGDLG_TB_SHOWTEXT, &MF_BYCOMMAND
    push eax
        xor edx edx | test eax &MF_CHECKED | setz dl
        mov B$DebugShowTBText dl
        call DebugDialog_CreateCommandTB
;;
      ; TODO show text
        mov ebx 0
        While ebx < 6
            mov D@Text 0
            SendMessage D$Debug_ToolbarHandle, &TB_SETBUTTONINFOA, ebx, D@TBButtonInfo
            If eax = 0
                call ReportWinError {'SetButtonInfo' 0}
            EndIf
            inc ebx
        EndWhile
;;
    pop eax
    xor eax &MF_CHECKED | and eax &MF_CHECKED
    call 'USER32.CheckMenuItem' D$Debug_ToolbarMenu, DEBUGDLG_TB_SHOWTEXT, eax
    SendMessage D$Debug_ToolbarHandle, &TB_AUTOSIZE, 0, 0

EndP
____________________________________________________________________________________________

[DebugDialog.RebarHeight: ?]

Proc DebugDialog_RebarNotify:
    Arguments @Message

  ; Reposition all other child windows
    .If D@Message = &RBN_HEIGHTCHANGE
        SendMessage D$DebugRebarHandle, &RB_GETBARHEIGHT, 0, 0
        mov edx D$DebugDialog.RebarHeight
        mov D$DebugDialog.RebarHeight eax
        sub eax edx | mov ebx eax

        call AdjustControlPos D$DebugDialogHandle, DEBUGDLG_REGISTER_TAB, 0, ebx
        call AdjustControlPos D$DebugDialogHandle, DEBUGDLG_FORMAT_COMBO, 0, ebx
        call AdjustControlPos D$DebugDialogHandle, DEBUGDLG_REG_LIST, 0, ebx
        call AdjustControlPos D$DebugDialogHandle, DEBUGDLG_DATA_TAB, 0, ebx
        call AdjustControlPos D$DebugDialogHandle, 3, 0, ebx
        mov esi 71
        While esi < 79
            call AdjustControlPos D$DebugDialogHandle, esi, 0, ebx
            inc esi
        EndWhile
        neg ebx
        call AdjustControlSize D$DebugDialogHandle, DEBUGDLG_DATA_TAB, 0, ebx
        call DebugDialog_AdjustDataTabSize D$DebugDialogHandle

        call 'USER32.InvalidateRect' D$DebugDialogHandle, &NULL, &TRUE
    .EndIf
EndP
____________________________________________________________________________________________

Proc DebugDialog_SaveToolbarSettings:
    Arguments @FileHandle
    Structure @Tbar 36, @Id 0, @Size 4, @Flags 8, @X1 12, @X2 16, @X3 20, @Style1 24, @Style2 28, @Style3 32

    mov D@Id 'TBar', D@Size 28

    mov al B$DebugShowTBText | mov B@Flags al

    SendMessage D$DebugRebarHandle, &RB_GETBANDINFO, 1, DebugRebarBand
    move D@Style1 D$DebugRebarBand@fStyle
    move D@X1 D$DebugRebarBand@cx

    SendMessage D$DebugRebarHandle, &RB_GETBANDINFO, 2, DebugRebarBand
    move D@Style2 D$DebugRebarBand@fStyle
    move D@X2 D$DebugRebarBand@cx

    SendMessage D$DebugRebarHandle, &RB_GETBANDINFO, 3, DebugRebarBand
    move D@Style3 D$DebugRebarBand@fStyle
    move D@X3 D$DebugRebarBand@cx

    call 'KERNEL32.WriteFile' D@FileHandle, D@Tbar, 36, BytesTransfered, 0
EndP
____________________________________________________________________________________________

Proc DebugDialog_LoadToolbarSettings:
    Arguments @FileHandle @Size
    Structure @Tbar 28, @Flags 0, @X1 4, @X2 8, @X3 12, @Style1 16, @Style2 20, @Style3 24

    mov eax 0
    On D@Size <> 28, ExitP

    call 'KERNEL32.ReadFile' D@FileHandle, D@Tbar, D@Size, BytesTransfered, 0

    On B@Flags <> 0,
        call DebugDialog_ToggleToolbarText

    mov ebx D$DebugRebarBand@fMask
    mov D$DebugRebarBand@fMask &RBBIM_STYLE+&RBBIM_SIZE

    move D$DebugRebarBand@fStyle D@Style1
    move D$DebugRebarBand@cx D@X1
    SendMessage D$DebugRebarHandle, &RB_SETBANDINFO, 1, DebugRebarBand

    move D$DebugRebarBand@fStyle D@Style2
    move D$DebugRebarBand@cx D@X2
    SendMessage D$DebugRebarHandle, &RB_SETBANDINFO, 2, DebugRebarBand

    move D$DebugRebarBand@fStyle D@Style3
    move D$DebugRebarBand@cx D@X3
    SendMessage D$DebugRebarHandle, &RB_SETBANDINFO, 3, DebugRebarBand

    xor eax eax | test D@Style1 &RBBS_HIDDEN | setz al | shl al 3
    call 'USER32.CheckMenuItem' D$Debug_ToolbarMenu, DEBUGDLG_TB_SHOW_CMDS, eax
    xor eax eax | test D@Style2 &RBBS_HIDDEN | setz al | shl al 3
    call 'USER32.CheckMenuItem' D$Debug_ToolbarMenu, DEBUGDLG_TB_SHOW_FLAGS, eax
    xor eax eax | test D@Style3 &RBBS_HIDDEN | setz al | shl al 3
    call 'USER32.CheckMenuItem' D$Debug_ToolbarMenu, DEBUGDLG_TB_SHOW_FPU, eax

    mov D$DebugRebarBand@fMask ebx

    mov eax 1
EndP
____________________________________________________________________________________________

____________________________________________________________________________________________
____________________________________________________________________________________________

[DEBUGLOGFONT:
 DEBUGLOGFONT.lfHeight: D$ 0_FFFF_FFF5
 DEBUGLOGFONT.lfWidth: D$ 0
 DEBUGLOGFONT.lfEscapement: D$ 0
 DEBUGLOGFONT.lfOrientation: D$ 0
 DEBUGLOGFONT.lfWeight: D$ 0190
 DEBUGLOGFONT.lfItalic: B$ 0
 DEBUGLOGFONT.lfUnderline: B$ 0
 DEBUGLOGFONT.lfStrikeOut: B$ 0
 DEBUGLOGFONT.lfCharSet: B$ 0
 DEBUGLOGFONT.lfOutPrecision: B$ 03
 DEBUGLOGFONT.lfClipPrecision: B$ 02
 DEBUGLOGFONT.lfQuality: B$ 01
 DEBUGLOGFONT.lfPitchAndFamily: B$ 031]
[DEBUGLOGFONT.lfFaceName: B$ 'Courier New' 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]

[DEBUGCHOOSEFONT:
 DEBUGCHOOSEFONT.lStructSize: D$ len
 DEBUGCHOOSEFONT.hwndOwner: D$ 0
 DEBUGCHOOSEFONT.hDC: D$ 0
 DEBUGCHOOSEFONT.lpLogFont: D$ DEBUGLOGFONT
 DEBUGCHOOSEFONT.iPointSize: D$ 0
 DEBUGCHOOSEFONT.Flags: D$ &CF_SCREENFONTS__&CF_FIXEDPITCHONLY
 DEBUGCHOOSEFONT.rgbColors: D$ 0
 DEBUGCHOOSEFONT.lCustData: D$ 0
 DEBUGCHOOSEFONT.lpfnHook: D$ 0
 DEBUGCHOOSEFONT.lpTemplateName: D$ 0
 DEBUGCHOOSEFONT.hInstance: D$ 0
 DEBUGCHOOSEFONT.lpszStyle: D$ 0
 DEBUGCHOOSEFONT.nFontType: W$ 0
 DEBUGCHOOSEFONT.Alignment: W$ 0
 DEBUGCHOOSEFONT.nSizeMin: D$ 0
 DEBUGCHOOSEFONT.nSizeMax: D$ 0]

[DebugFontHandle: ?]

Proc DebugDialog_SetFont:
    Arguments @Handle

        On D$DebugFontHandle <> 0,
            call 'GDI32.DeleteObject' D$DebugFontHandle
        call 'GDI32.CreateFontIndirectA' DEBUGLOGFONT
        mov D$DebugFontHandle eax
        call MeasureFont
        SendMessage D@Handle, &WM_SETFONT, D$DebugFontHandle, &TRUE
EndP
____________________________________________________________________________________________

; Get character extents for the owner-drawn lists.
; Create a temporary device context, set the font & measure string sizes.
; (only deals with fixed sized fonts)

[DebugFontCharWidth: ?]

Proc MeasureFont:
    Local @DC

    call 'GDI32.CreateDCA' {'DISPLAY' 0}, 0, 0, 0
    mov D@DC eax

    call 'GDI32.SelectObject' D@DC, D$DebugFontHandle
    call 'GDI32.GetTextExtentPoint32A' D@DC, {'M' 0}, 1, Point

    move D$DebugFontCharWidth D$PointX

    call 'GDI32.DeleteDC' D@DC
EndP
____________________________________________________________________________________________

MeasureStringWidth:
    cmp B$UnicodeStrings 1 | je L0>
    jmp MeasureStringWidthA
L0: jmp MeasureStringWidthW

; General purpose string measurement for owner-drawn controls

Proc MeasureStringWidthA:
    Arguments @String, @Font
    Local @DC
    Uses edi

    call 'GDI32.CreateDCA' {'DISPLAY' 0}, 0, 0, 0
    mov D@DC eax

    call 'GDI32.SelectObject' D@DC, D@Font

    mov edi D@String, ecx 0-1, al 0
    repne scasb
    mov eax 0-2 | sub eax ecx

    call 'GDI32.GetTextExtentPoint32A' D@DC, D@String, eax, Point
    call 'GDI32.DeleteDC' D@DC

    mov eax D$PointX
EndP
____________________________________________________________________________________________

Proc MeasureStringWidthW:
    Arguments @String, @Font
    Local @DC
    Uses edi

    call 'GDI32.CreateDCA' {'DISPLAY' 0}, 0, 0, 0
    mov D@DC eax

    call 'GDI32.SelectObject' D@DC, D@Font

    mov edi D@String, ecx 0-1, ax 0
    repne scasw
    mov eax 0-2 | sub eax ecx

    call 'GDI32.GetTextExtentPoint32W' D@DC, D@String, eax, Point
    call 'GDI32.DeleteDC' D@DC

    mov eax D$PointX
EndP
____________________________________________________________________________________________

; Present font dialog

Proc DebugDialog_ChangeFont:
    Arguments @Handle

        move D$DEBUGCHOOSEFONT.hwndOwner D@Handle
        call 'COMDLG32.ChooseFontA' DEBUGCHOOSEFONT    ; user sets the font:
        If eax > 0
            call DebugDialog_SetFont D@Handle
        End_If
EndP
____________________________________________________________________________________________

; Compare the register contents (general purpose) for changed values since last tag.
; Mark changed registers in the bit mask (e.g. bit0=1 means: EAX has changed)

[OldGPR_Values: ? #8 GPR_Modified_Mask: ? GPR_FirstTime: ?]

Proc TagGPRModified:
    Uses esi edi

    mov ecx 0, edx 0
    mov esi GPRRegMap, edi OldGPR_Values
    Do
        lodsd | mov eax D$eax
        cmp eax D$edi | je L0>
            bts edx ecx ; tag as changed
L0:     stosd
        inc ecx
    Loop_Until ecx = 8

    If D$GPR_FirstTime = 1
        mov edx 0
        mov D$GPR_FirstTime 0
    EndIf

    mov D$GPR_Modified_Mask edx
EndP
____________________________________________________________________________________________

[DebugConfig: 'debug.cfg' 0]

; Load debugger configuration from file (in RosAsmFiles folder) if available

Proc LoadDebugConfig:
    Local @File, @Value, @Size, @Id
    Uses edi, esi

    call GetRosAsmFilesPath

    mov edi RosAsmFilesPath, eax 0, ecx 0-1
    repne scasb | dec edi
    mov esi DebugConfig, ecx 13
    rep movsb

    call 'Kernel32.CreateFileA' RosAsmFilesPath, &GENERIC_READ, &FILE_SHARE_READ, 0,
        &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0

    mov B$edi 0

    On eax = &INVALID_HANDLE_VALUE, ExitP
    mov D@File eax

L0: lea eax D@Id
    call 'KERNEL32.ReadFile' D@File, eax, 8, BytesTransfered, 0
    ..If D$BytesTransfered = 8
        .If D@Id = 'RegX'
          ; Show seg&debug regs (0=No [default]; 1=Show)
            lea eax D@Value
            call 'KERNEL32.ReadFile' D@File, eax, 4, BytesTransfered, 0
            On D@Value = 1,
                SendMessage D$DebugDialogHandle, &WM_COMMAND, M02_Show_All, 0
        .ElseIf D@Id = 'Step'
          ; Stepping mode (0=instruction level [default]; 1=source level)
            lea eax D@Value
            call 'KERNEL32.ReadFile' D@File, eax, 4, BytesTransfered, 0
            On D@Value = 1,
                SendMessage D$DebugDialogHandle, &WM_COMMAND, M02_Source_Level, 0
        .ElseIf D@Id = 'Font'
            call 'KERNEL32.ReadFile' D@File, DebugLogFont, D@Size, BytesTransfered, 0
            call DebugDialog_SetFont D$DebugDialogHandle
        .ElseIf D@Id = 'Rect'
            call 'KERNEL32.ReadFile' D@File, DebugRect, D@Size, BytesTransfered, 0
            mov eax D$DebugRect@right | sub eax D$DebugRect@left
            mov edx D$DebugRect@bottom | sub edx D$DebugRect@top
            call 'USER32.MoveWindow' D$DebugDialogHandle, D$DebugRect@left, D$DebugRect@top, eax, edx, &TRUE
        .ElseIf D@Id = 'TBar'
            call DebugDialog_LoadToolbarSettings D@File, D@Size
            cmp eax 0 | je L9>
        .ElseIf D@Id = 'LaLa'
            call DataView_LoadSettings D@File, D@Size
        .Else
          ; Unknown chunk, skip it
L9:         call 'KERNEL32.SetFilePointer' D@File, D@Size, 0, &FILE_CURRENT
        .EndIf
        jmp L0<<
    ..EndIf

    call 'KERNEL32.CloseHandle' D@File
EndP
____________________________________________________________________________________________

; Write debugger configuration to a file

Proc SaveDebugConfig:
    Local @File, @Value, @Size, @Id
    Uses edi, esi

    call GetRosAsmFilesPath

    mov edi RosAsmFilesPath, eax 0, ecx 0-1
    repne scasb | dec edi
    mov esi DebugConfig, ecx 13
    rep movsb

    call 'Kernel32.CreateFileA' RosAsmFilesPath, &GENERIC_WRITE, &FILE_SHARE_READ, 0,
        &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0

    mov B$edi 0

    On eax = &INVALID_HANDLE_VALUE, ExitP
    mov D@File eax

  ; Show segment & debug regs
    call 'User32.GetMenuState' D$SettingsMenu, M02_Show_All, &MF_BYCOMMAND
    and eax &MF_CHECKED
    If eax <> 0
        mov D@Value 1
    Else
        mov D@Value 0
    EndIf
    mov D@Id 'RegX'
    mov D@Size 4
    lea eax D@Id
    call 'KERNEL32.WriteFile' D@File, eax, 12, BytesTransfered, 0

  ; Stepping Mode
    mov D@Id 'Step'
    move D@Value D$Stepping
    lea eax D@Id
    call 'KERNEL32.WriteFile' D@File, eax, 12, BytesTransfered, 0

  ; Font
    mov D@Id 'Font'
    mov D@Size 60
    lea eax D@Id
    call 'KERNEL32.WriteFile' D@File, eax, 8, BytesTransfered, 0
    call 'KERNEL32.WriteFile' D@File, DebugLogFont, D@Size, BytesTransfered, 0

  ; Position
    mov D@Id 'Rect'
    mov D@Size 16
    call 'USER32.GetWindowRect' D$DebugDialogHandle, DebugRect
    lea eax D@Id
    call 'KERNEL32.WriteFile' D@File, eax, 8, BytesTransfered, 0
    call 'KERNEL32.WriteFile' D@File, DebugRect, D@Size, BytesTransfered, 0

    call DebugDialog_SaveToolbarSettings D@File
    call DataView_SaveSettings D@File

    call 'KERNEL32.CloseHandle' D@File
EndP
____________________________________________________________________________________________

[CurrentStackPointer: ?]

Proc DebugDialog_ShowCaller:
    If D$CurrentStackPointer = 0
        move D$CurrentStackPointer D$C.regEsp
    EndIf

    call ScanStackForCodePointer D$CurrentStackPointer
    add edx 4
    add D$CurrentStackPointer edx

    dec eax
    call SourceDebugPos eax
EndP
____________________________________________________________________________________________

; Process WM_DEBUGEVENT message.

Proc DebugDialog_OnDebugEvent:
    Arguments @Handle
    Local @Inside

      ; Find changed registers
        call TagGPRModified

      ; Find position in source
        call SourceDebugPos D$SourcePosCodeAddress
        call IsProcessCode D$C.regEip | mov D@Inside eax

      ; Copy exception description
        mov edi DebugCaption
        .If D$DebugEventType = DET_BP
            mov D$edi 'BP  ' | add edi 3
        .ElseIf D$DebugEventType = DET_STEP
            mov D$edi 'STEP', B$edi+4 ' ' | add edi 5
        .ElseIf D$DebugEventType = DET_WP
            mov D$edi 'WP  ' | add edi 3
        .ElseIf D$DebugEventType = DET_EXCEPTION
            mov D$edi 'EXCE', D$edi+4 'PTIO', W$edi+8 'N ' | add edi 10
        .EndIf

        ;mov esi D$BreakTitle, edi DebugCaption
        ;While B$esi <> 0 | movsb | EndWhile

        ; Under 95 we cannot access the process memory after an exception has occurred
        ; Step-Over and InstructionDecode wouldn't work for that reason. (really?)
        ...If D$ExceptionFlags = 0
            call NextInstructionDecode
            ; For source level stepping, compare the last source pos with the current
            ; if it hasn't changed, continue to step into/over.
            ; UPDATE: Only when stepping inside the process code
            mov eax D$SourcePos
            ..If eax = D$LastSourcePos
                .If D@Inside = &TRUE
                    If B$Stepping = 1
                        call DebugDialog_ContinueDebuggee
                        ExitP
                    EndIf
                .EndIf
            ..Else
                mov D$LastSourcePos eax
            ..EndIf
            ; Show next instruction in caption, e.g. "BREAKPOINT - [push eax]"
            ;mov eax ' - [' | stosd
            mov al '[' | stosb
            mov esi D$NextInstructionPtr
            While B$esi <> 0 | movsb | EndWhile
            mov al ']' | stosb
        ...End_If

        On D$ExceptionFlags = 0,
            call DebugDialog_EnableContinueMenu &TRUE
;;
        test D$ExceptionFlags E_MUSTEXIT | jnz L0>
            call DebugDialog_EnableContinueMenu &TRUE
L0:
        test D$ExceptionFlags E_OUTSIDE | jnz L0>
L0:     
;;

      ; Show current module name
        If D$CurrentModule <> 0
            push esi
                mov esi D$CurrentModule
                mov B$edi ' ' | inc edi
                While B$esi <> 0 | movsb | EndWhile
            pop esi
        EndIf

      ; Show caption
        mov B$edi 0
        SendMessage D@Handle, &WM_SETTEXT, 0, DebugCaption

        ; Refresh register content output & flags
        call DebugDialog_OnChangeRegisterTab D@Handle
        call DebugDialog_UpdateFlags D@Handle
        call DebugDialog_UpdateRegisterButtons D@Handle
        call 'User32.IsIconic' D$hwnd
        If eax = &TRUE
            call 'USER32.ShowWindow' D$hwnd, &SW_RESTORE
        EndIf
        call 'USER32.ShowWindow' D@Handle, &SW_RESTORE
        call 'USER32.SetForegroundWindow' D$hwnd
        call 'USER32.SetForegroundWindow' D@Handle

      ; Refresh the data dialogs - they shall reload the displayed data from the debuggee
        SendMessage D$CurrentDataPageHandle, WM_REFRESH_CONTENT, 0, 0

        On D$DebugEventType = DET_WP,
            SendMessage D$DataViewHandle, WM_SELECT_SYMBOL, D$WatchedAddress, 0

        On D$ExceptionFlags <> 0,
            call ShowExceptionInfo

        mov D$CurrentStackPointer 0

        ;test D$ExceptionFlags E_OUTSIDE | jz L0>
        ;    call 'USER32.MessageBoxA' D$hwnd, ErrorOutside, ErrorOutsideTitle, &MB_ICONEXCLAMATION
L0:     mov eax 0
EndP
____________________________________________________________________________________________

; Kill Debugger

Proc DebugDialog_KillDebugger:
  ; Tried to kill debug-dialog while debugger is still running
    mov D$TerminateDebuggee &TRUE, D$DialogKillsDebugger &TRUE

    .If D$IsDebugEvent = 1
      ; If the debug-thread waits for an user input event, simulate that the user pressed
      ; "Terminate Debuggee". If we don't do that, the debugger will wait forever--
        call DebugDialog_ContinueDebuggee
    .Else
      ; Wait for the debug-thread to terminate. After a few seconds the debuggee and the
      ; debugger thread is terminated if the debugger thread does not exit voluntarily.
        call 'KERNEL32.WaitForSingleObject' D$DebugThreadHandle, 5000
        If eax = &WAIT_TIMEOUT
            call 'User32.MessageBoxA' D$hwnd, DebugThreadHangs, CriticalError, &MB_ICONEXCLAMATION
            call CloseProcess
            call 'KERNEL32.TerminateThread' D$DebugThreadHandle, 0
        EndIf
        mov D$DebugThreadHandle &NULL
    .EndIf
EndP
____________________________________________________________________________________________

; Process WM_CREATE message. Create child windows and load configuration.

Proc DebugDialog_OnCreate:
    Arguments @Handle

        move D$DebugDialogHandle D@Handle
        ;call 'USER32.GetMenu' D@Handle | mov D$DebugMenuHandle eax

      ; Hide tree
        On D$ShowTreeHandle <> 0, call 'USER32.ShowWindow' D$ShowTreeHandle &SW_HIDE

      ; Init the flags
        mov D$GPR_FirstTime 1, D$GPR_Modified_Mask 0
        mov D$TerminateDebuggee &FALSE, D$DialogKillsDebugger &FALSE
        mov D$HoldOnBreakpoints &TRUE, D$PauseThreads &FALSE

        call 'User32.GetClientRect' D@Handle, DebugRect
        move W$DebugDialog.Width W$DebugRect@width
        move W$DebugDialog.Height W$DebugRect@height

      ; Place dialog in upper right corner of the source editor.
      ; The position is overwritten when the configuration file is loaded so it
      ; only has any effect when no config file is available.
        call 'User32.GetClientRect' D$Hwnd, DebugRect
        mov esi D$DebugRect@width
        mov edi D$DebugRect@height
        call 'User32.GetWindowRect' D@Handle, DebugRect
        mov eax D$DebugRect@left
        sub D$DebugRect@right eax ; width
        sub esi D$DebugRect@width
        mov D$DebugRect@left esi ; xpos
        mov eax D$DebugRect@top
        sub D$DebugRect@bottom eax ; height
        If edi > D$DebugRect@bottom
            mov D$DebugRect@bottom edi
        EndIf
        mov D$DebugRect@top 0
        call 'USER32.ClientToScreen' D$Hwnd, DebugRect
        call 'USER32.MoveWindow' D@Handle, D$DebugRect@left, D$DebugRect@top,
                                 D$DebugRect@right, D$DebugRect@bottom, &TRUE

      ; Key mapping
        call 'User32.CreateAcceleratorTableA' DbgAccels, DbgAccelsNum
        mov D$DbgAccelHandle eax

      ; Create default font
        mov eax D$NationalFontHandle
        If eax <> 0
            mov D$DialogFont_handle eax
        Else
            call 'GDI32.CreateFontA' 8 4 0 0 400 0 0 0 1,   ;  DEFAULT_CHARSET 1  OEM_CHARSET 255
                                     0 0 0 0 Helv
            mov D$DialogFont_handle eax
        EndIf

        ;SendMessage eax, &WM_SETFONT, D$DialogFont_handle, 1
        ;SendMessage eax, &WM_SETFONT, D@Handle, 1

      ; Create the image list
        call DebugDialog_CreateImageList

      ; Create the child windows / menu, toolbar, tabs
        call DebugDialog_CreateRegisterTabs D@Handle
        call DebugDialog_CreateDataTab D@Handle
        call DebugDialog_CreateToolbar
        call DebugDialog_InitDbgMenu

      ; Create the monospace font
        call DebugDialog_SetFont D@Handle

        call 'User32.SetWindowTextA' D@Handle, {'Running ...' 0}

      ; Create the mouse hint form and timer
        call InitMouseOverDataHints

      ; Finally load configuration from file if available. All windows must be created
      ; at this point.
        call LoadDebugConfig

        mov eax 0 ;&TRUE
EndP
____________________________________________________________________________________________

; Process WM_CLOSE message. Save configuration & send destroy message.

Proc DebugDialog_OnClose:
    Arguments @Handle

      ; Save configuration
        call SaveDebugConfig

      ; Terminate debugger if it is still running.
        mov D$DebuggerReady &FALSE
        If D$IsDebugging = &TRUE
            call DebugDialog_KillDebugger
        End_If

      ; Kill timer and destroy mouse hint window
        call DeleteMouseOverDataHints

      ; Destroy dialog
        call 'User32.DestroyWindow' D@Handle
        mov D$DebugDialogHandle 0

      ; Restore RosAsm windows
        On D$ShowTreeHandle <> 0, call 'USER32.ShowWindow' D$ShowTreeHandle, &SW_SHOW
        call 'User32.IsIconic' D$hwnd
        If eax = &TRUE
            call 'USER32.ShowWindow' D$hwnd, &SW_RESTORE
        EndIf
        call 'USER32.SetForegroundWindow' D$hwnd
        mov eax 0
EndP
____________________________________________________________________________________________

; Process WM_DESTROY message. Free resources, destroy child windows.

Proc DebugDialog_OnDestroy:
    Arguments @Handle

      ; Destroy child windows
        call 'USER32.DestroyWindow' D$DataViewHandle
        call 'USER32.DestroyWindow' D$MemoryInspectorHandle
        call 'USER32.DestroyWindow' D$CallStackFormHandle
        call 'USER32.DestroyWindow' D$LogForm_handle
        call 'USER32.DestroyWindow' D$ASForm_handle
        mov D$CurrentDataPageHandle 0

        call DebugDialog_DestroyToolbar

      ; Free images
        call DebugDialog_DestroyImageList

      ; Destroy key map
        call 'USER32.DestroyAcceleratorTable' D$DbgAccelHandle
        mov D$DbgAccelHandle 0

      ; Delete fonts
        If D$DebugFontHandle <> 0
            call 'GDI32.DeleteObject' D$DebugFontHandle
            mov D$DebugFontHandle 0
        EndIf
        If D$DialogFontHandle <> 0
            On D$NationalFontHandle = 0,
                call 'GDI32.DeleteObject' D$DialogFontHandle
            mov D$DialogFontHandle 0
        EndIf

        mov eax 0
EndP
____________________________________________________________________________________________

; Process WM_COMMAND message. Menu, accelerator (key-press) and button notifications.

Proc DebugDialog_OnCommand:
    Arguments @Handle, @wParam, @lParam

        movzx eax W@wParam
        movzx edx W@wParam+2

        .If eax = M02_Hold_on_BP
            call 'User32.GetMenuState' D$SettingsMenu, M02_Hold_on_BP, &MF_BYCOMMAND
            xor B$HoldOnBreakpoints 1 ; bool toggle
            xor eax &MF_CHECKED | and eax &MF_CHECKED
            call 'USER32.CheckMenuItem' D$SettingsMenu, M02_Hold_on_BP, eax

        .Else_if eax = M02_Show_All
            call 'User32.GetMenuState' D$SettingsMenu, M02_Show_All, &MF_BYCOMMAND
            push eax
                xor edx edx | test eax &MF_CHECKED | setz dl
                call DebugDialog_ShowAdvancedTabs D@Handle edx
            pop eax
            xor eax &MF_CHECKED | and eax &MF_CHECKED
            call 'USER32.CheckMenuItem' D$SettingsMenu, M02_Show_All, eax

        .Else_if eax = M02_Run
            mov B$UserWants CONTINUE_RUN
            call DebugDialog_ContinueDebuggee

        .Else_if eax = M02_Step_Over
            mov B$UserWants CONTINUE_STEPOVER
            call DebugDialog_ContinueDebuggee

        .Else_if eax = M02_Step_Into
            mov B$UserWants CONTINUE_STEP
            call DebugDialog_ContinueDebuggee

        .Else_if eax = M02_Return_to_Caller
            mov B$UserWants CONTINUE_RETURNTOCALLER
            call DebugDialog_ContinueDebuggee

        .Else_if eax = M02_Terminate
            mov B$TerminateDebuggee &TRUE
            call DebugDialog_ContinueDebuggee

        .Else_if eax = M02_Pause
            mov B$PauseThreads &TRUE

        .Else_If eax = M02_Show_code_at
            call CreateNewForm_CodeAddressForm

        .Else_if eax = M02_Inst_Level
            call 'USER32.CheckMenuRadioItem' D$SettingsMenu, M02_Inst_Level, M02_Source_Level,
                                             M02_Inst_Level, &MF_BYCOMMAND
            mov B$Stepping 0

        .Else_if eax = M02_Source_Level
            call 'USER32.CheckMenuRadioItem' D$SettingsMenu, M02_Inst_Level, M02_Source_Level,
                                             M02_Source_Level, &MF_BYCOMMAND
            mov B$Stepping 1

        .Else_if eax = M02_Font
            call DebugDialog_ChangeFont D@Handle

        .Else_if eax = M02_CPU_Info
            VirtualAlloc DebugTextBuffer 4096
            mov edi D$DebugTextBuffer
            call DebugDialog_GetCPUInfo
            call 'User32.MessageBoxA' D@Handle, D$DebugTextBuffer, {'CPU Information' 0}, &MB_OK__&MB_ICONINFORMATION
            VirtualFree D$DebugTextBuffer

        .Else_if eax = M02_FPU_Status
            VirtualAlloc DebugTextBuffer 4096
            mov edi D$DebugTextBuffer
            call DebugDialog_GetFPUStatus
            call 'User32.MessageBoxA' D@Handle, D$DebugTextBuffer, {'FPU Status' 0}, &MB_OK__&MB_ICONINFORMATION
            VirtualFree D$DebugTextBuffer

        .Else_if eax = M02_Help
            call Help, B_U_AsmName, {'Debugger' 0}, ContextHlpMessage

        .Else_if eax = M02_About
            call 'User32.MessageBoxA' D@Handle, AboutDebugger, DebuggerVersion, &MB_OK__&MB_ICONINFORMATION

        .Else_If eax = DEBUGDLG_FORMAT_COMBO ; Representation Combo
            If edx = &CBN_SELCHANGE
                SendMessage D@lParam, &CB_GETCURSEL, 0, 0
                On eax <> &CB_ERR, call DebugDialog_OnFormatChange D@Handle eax
            End_If

        .Else_if eax = DEBUGDLG_TB_CONFIGURE
            ; TODO
        .Else_If eax = DEBUGDLG_TB_SHOW_CMDS
            call DebugDialog_ToggleToolbar eax
        .Else_If eax = DEBUGDLG_TB_SHOW_FLAGS
            call DebugDialog_ToggleToolbar eax
        .Else_If eax = DEBUGDLG_TB_SHOW_FPU
            call DebugDialog_ToggleToolbar eax
        .Else_If eax = DEBUGDLG_TB_SHOW_TEXT
            call DebugDialog_ToggleToolbarText

        .Else_if eax >= DEBUGDLG_FIRSTREG_BUTTON
            If eax <= DEBUGDLG_LASTREG_BUTTON
                sub eax DEBUGDLG_FIRSTREG_BUTTON
                mov eax D$GPRRegMap+eax*4
                mov ecx D$eax
                and ecx 0_FFFF_F000
                SendMessage D$MemoryInspectorHandle, WM_SET_PAGE, ecx, D$eax
            End_if
        .End_If
        mov eax 0
EndP
____________________________________________________________________________________________

; Process WM_NOTIFY message. Handles tab selection changes and rebar height change.

Proc DebugDialog_OnNotify:
    Arguments @Handle, @Notification

        mov ebx D@Notification
        mov edx D$ebx+4
        mov eax D$ebx+8
        ..If edx = DEBUGDLG_REGISTER_TAB
            If eax = &TCN_SELCHANGE
                SendMessage D$ebx, &TCM_GETCURSEL, 0, 0
                mov D$TabItem@imask &TCIF_PARAM
                SendMessage D$ebx, &TCM_GETITEM, eax, TabItem
                call DebugDialog_OnChangeRegisterTab D@Handle
            End_If
            mov eax 0
        ..ElseIf edx = DEBUGDLG_DATA_TAB
            .If eax = &TCN_SELCHANGE
                SendMessage D$ebx, &TCM_GETCURSEL, 0, 0
                If eax = 0
                    mov edi D$DataViewHandle
                ElseIf eax = 1
                    mov edi D$MemoryInspectorHandle
                ElseIf eax = 2
                    mov edi D$CallStackFormHandle
                ElseIf eax = 3
                    mov edi D$LogForm_handle
                ElseIf eax = 4
                    mov edi D$ASForm_handle
                EndIf
                call 'USER32.ShowWindow' D$CurrentDataPageHandle, &SW_HIDE
                call 'USER32.ShowWindow' edi, &SW_SHOW
                mov D$CurrentDataPageHandle edi
                call DebugDialog_AdjustDataTabSize D@Handle
            .End_If
            mov eax 0 ; mandatory for TCN_SELCHANGING !!!
        ..ElseIf edx = DEBUGDLG_REBAR
            call DebugDialog_RebarNotify eax
            mov eax 0
        ..ElseIf edx = DEBUGDLG_MENUBAR
            call DebugDialog_MenubarNotify ebx eax D$ebx+12
        ..Else
            mov eax 0
        ..EndIf

EndP
____________________________________________________________________________________________

; Process WM_SETFONT message. Propagate message to affected child windows.

Proc DebugDialog_OnSetFont:
    Arguments @Handle @hFont, @Redraw

        SendMessage D$RegListHandle, &WM_SETFONT, D@hFont, D@Redraw
        SendMessage D$DataViewHandle, &WM_SETFONT, D@hFont, D@Redraw
        SendMessage D$MemoryInspectorHandle, &WM_SETFONT, D@hFont, D@Redraw
        SendMessage D$CallStackFormHandle, &WM_SETFONT, D@hFont, D@Redraw
        SendMessage D$LogFormHandle, &WM_SETFONT, D@hFont, D@Redraw
        SendMessage D$MouseHintFormHandle, &WM_SETFONT, D@hFont, D@Redraw
        SendMessage D$ASFormHandle, &WM_SETFONT, D@hFont, D@Redraw
        mov ebx DEBUGDLG_FIRSTREG_BUTTON
        While ebx <= DEBUGDLG_LASTREG_BUTTON
            call 'User32.GetDlgItem' D@Handle, ebx
            SendMessage eax, &WM_SETFONT, D@hFont, D@Redraw
            inc ebx
        EndWhile
EndP
____________________________________________________________________________________________


____________________________________________________________________________________________

; Create the main debugger window.

CreateDebugWindow:

    move D$DebugWindowClass@hInstance D$hInstance
    move D$DebugWindowClass@hIcon D$wc_hIcon
    move D$DebugWindowClass@hIconSm D$wc_hIcon
    move D$DebugWindowClass@hCursor D$wc_hCursor

    call 'User32.RegisterClassExA' DebugWindowClass

    ;call 'USER32.LoadMenuA' D$hInstance, M02_MENU
    ;call DebugWindow_CreateMenu

    call 'User32.CreateWindowExA' 0,
        DebugWindowClassName,
        0,
        &WS_OVERLAPPEDWINDOW+&WS_VISIBLE+&WS_POPUP,
        0, 0, 160, 240,
        D$hwnd, 0,
        D$hInstance, 0

    If eax = 0
        call ReportWinError {'Debugger: CreateWindowEx' 0}
        mov eax 0 | ret
    EndIf

    mov D$DebugDialogHandle eax

    mov eax 1
ret
____________________________________________________________________________________________
[DebugWindowClass:
 @cbSize:        D$ len
 @style:         D$ 11
 @lpfnWndProc:   D$ DebugDlgProc
 @cbClsExtra:    D$ 0
 @cbWndExtra:    D$ 0
 @hInstance:     D$ 0
 @hIcon:         D$ 0
 @hCursor:       D$ 0
 @hbrBackground: D$ 1
 @lpszMenuName:  D$ 0
 @lpszClassName: D$ DebugWindowClassName
 @hIconSm:       D$ 0]
[DebugWindowClassName: B$ "RosAsmDebugWindow" 0]
____________________________________________________________________________________________
; Custom events used to interchange informations between the debugger thread and the various
; windows/subwindows.

[WM_DEBUGEVENT      &WM_USER+1  ; debugger thread -> main debug dlg : when debug event occurs
 WM_BEGIN_DEBUG     &WM_USER+2  ; debugger thread -> main debug dlg : debuggee is set up
 WM_SET_PAGE        &WM_USER+3  ; various dlgs -> mem inspector : select virtual page
 WM_REFRESH_CONTENT &WM_USER+4  ; main debug dlg -> data dlgs : refresh data from debuggee
 WM_SELECT_SYMBOL   &WM_USER+5  ; main debug dlg -> data viewer : select symbol by address
 WM_LOG             &WM_USER+6  ; debugger thread -> main debug dlg : to log debug strings
 WM_POPUPMENU       &WM_USER+7  ; hook proc -> main debug dlg : popup menubar sub-menu
 WM_COLLAPSEMENU    &WM_USER+8] ; hook proc -> main debug dlg : collapse menubar sub-menu

; Accelerator table - assign key-combos to menu items

[DbgAccels:
 U$ &FVIRTKEY                   &VK_F6      M02_Run
    &FVIRTKEY                   &VK_F7      M02_Step_Into
    &FVIRTKEY                   &VK_F8      M02_Step_Over
    &FVIRTKEY+&FCONTROL         &VK_F7      M02_Return_to_Caller
    &FVIRTKEY+&FCONTROL         &VK_F12     M02_Pause
    &FVIRTKEY+&FCONTROL         &VK_F6      M02_Terminate]
    ;&FVIRTKEY+&FCONTROL         "F"         M02_FPU_Status


[DbgAccelsNum 6]
[DbgAccelHandle: ?]

;[BreakTitle: ?]
[DebugCaption: B$ ? #64]

; Debuggee is started.
[DebuggerReady: ?]

[TabItem:
 @imask: D$ ? #3
 @pszText: D$ ?
 @cchTextMax: D$ ?
 @iImage: D$ ?
 @lParam: D$ ?]

[DebugRect:
 @left: ?
 @top: ?
 @right: @width: ?
 @bottom: @height: ?]

[UserWants: ?] ; Execution control after debug event (step, run, ...)
[Stepping: ? LastSourcePos: ?]
[DbgLineHeight: 16]

[DebugDialogHandle: ? RegListHandle: ?]; DebugMenuHandle: ?]
[MenubarHandle: ?]
[HoldOnBreakpoints: ? TerminateDebuggee: ? PauseThreads: ? DialogKillsDebugger: ?]

[ExceptionText: 'Exception occurred' 0]

[DebugTextBuffer: ?]

[DebugDialogSize:
 DebugDialog.Width: W$ ?
 DebugDialog.Height: W$ ?]

[DEBUGDLG_REGISTER_TAB 40
 DEBUGDLG_DATA_TAB 200
 DEBUGDLG_FORMAT_COMBO 60
 DEBUGDLG_REG_LIST 70
 DEBUGDLG_FIRSTREG_BUTTON 71
 DEBUGDLG_LASTREG_BUTTON 78
 DEBUGDLG_TB_CONFIGURE 300
 DEBUGDLG_TB_SHOW_CMDS 301
 DEBUGDLG_TB_SHOW_FLAGS 302
 DEBUGDLG_TB_SHOW_FPU 303
 DEBUGDLG_TB_SHOW_TEXT 304]

    [DialogFontHandle: ?]
    [DialogLOGFONTSTRUCT:  0  0  0  0  0  0  536870912 'MS Sans Serif' 0 0 0 0 0 0 ]

;;
    The main debugger window - related functions (right-click)
    
    'DebugDialog_InitDbgMenu', 'DebugDialog_CreateRegisterTabs', 'DebugDialog_CreateDataTab',
    'DebugDialog_InitRegisterListBox', 'DebugDialog_CreateRegisterButtons',
    'DebugDialog_SetFont', 'DebugDialog_ChangeFont', 'DebugDialog_ContinueDebuggee',
    'DebugDialog_OnChangeRegisterTab', 'DebugDialog_OnDrawRegisterItem', 'DebugDialog_OnFormatChange',
    'DebugDialog_UpdateFlags', 'DebugDialog_UpdateRegisterButtons', 
    'DebugDialog_ShowAdvancedTabs', 'DebugDialog_GetCPUInfo', 'DebugDialog_GetFPUStatus',
    'DebugDialog_AdjustDataTabSize', 'DebugDialog_ShowCaller'
;;

Proc DebugDlgProc:
    Arguments @Handle @Message @wParam @lParam
    Uses ebx, esi, edi

    .If D@Message = &WM_CREATE
        call DebugDialog_OnCreate D@Handle

    .Else_If D@Message = &WM_CONTEXTMENU
        movzx eax W@lParam
        movzx ecx W@lParam+2
        call DebugDialog_RebarHitTest eax ecx

    .Else_if D@Message = WM_BEGIN_DEBUG
        mov D$DebuggerReady &TRUE
        mov eax 0

    .Else_If D@Message = WM_LOG
        SendMessage D$LogForm_Handle, D@Message, D@wParam, D@lParam

    .Else_If D@Message = WM_DEBUGEVENT
        call DebugDialog_OnDebugEvent D@Handle

    .Else_If D@Message = WM_POPUPMENU
        call DebugDialog_OnPopupMenu D@wParam

    .Else_If D@Message = WM_COLLAPSEMENU
        call DebugDialog_OnCollapseMenu

    .Else_If D@Message = &WM_CLOSE
        call DebugDialog_OnClose D@Handle

    .Else_If D@Message = &WM_DESTROY
        call DebugDialog_OnDestroy D@Handle

    .Else_If D@Message = &WM_COMMAND
        call DebugDialog_OnCommand D@Handle, D@wParam, D@lParam

    .Else_If D@Message = &WM_SYSCOMMAND
        call DebugDialog_OnSysCommand D@Handle, D@wParam, D@lParam

    .Else_if D@Message = &WM_KEYDOWN
        call DebugDialog_OnKeyDown D@Handle, D@wParam, D@lParam

    .Else_If D@Message = &WM_NOTIFY
        call DebugDialog_OnNotify D@Handle, D@lParam

    .Else_if D@Message = &WM_GETMINMAXINFO
        mov eax D@lParam
        mov D$eax+24 200
        mov D$eax+28 480
        mov eax 0

    .Else_if D@Message = &WM_SIZE
        If D@wParam <> &SIZE_MINIMIZED
            call DebugDialog_OnSize D@Handle, D@lParam
        EndIf

    .Else_if D@Message = &WM_ACTIVATEAPP
        mov eax 0

    .Else_if D@Message = &WM_SETFONT
        call DebugDialog_OnSetFont D@Handle, D@wParam, D@lParam

    .Else_if D@Message = &WM_DRAWITEM
        If D@wParam = 0
            call DebugDialog_OnDrawMenuItem D@lParam
        Else
            call DebugDialog_OnDrawRegisterItem D@lParam
        EndIf
        mov eax &TRUE

    .Else_if D@Message = &WM_MEASUREITEM
        mov eax D@lParam
        If D@wParam = 0
          ; menu
            call DebugDialog_OnMeasureMenuItem D@lParam
        Else
          ; listbox
            move D$eax+16 D$DbgLineHeight
        EndIf
        mov eax &TRUE

    .Else
        call 'User32.DefWindowProcA' D@Handle, D@Message, D@wParam, D@lParam
    .End_If

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; MEMORY INSPECTOR
____________________________________________________________________________________________
____________________________________________________________________________________________

[MemInspectorSize:
 MemInspector.Width: W$ ?
 MemInspector.Height: W$ ?]

[MEMINSPECTOR_DATA_LIST 150
 MEMINSPECTOR_PAGE_EDIT 160
 MEMINSPECTOR_PREV_BUTTON 151
 MEMINSPECTOR_NEXT_BUTTON 152
 MEMINSPECTOR_TABLE_BUTTON 153
 MEMINSPECTOR_FORMAT_COMBO 170]

[MemFormatConversionProc: ?]

[CurrentPageAddress: ? CurrentPage: ?]

Proc MemoryInspector_OnDrawItem:
    Arguments @DrawItemStruc
    Local @Brush @Offset @Selected

    mov ebx D@DrawItemStruc
    call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0

    mov D@Selected 0
    test D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED
    setz al
    xor al 1
    mov B@Selected al

    ; Print Offset
    mov edx D$DebugFontCharWidth | shl edx 2 | add edx PADDING ; 4 chars
    mov eax D$ebx+DRAWITEM_RCITEM_LEFT | mov D$ItemRect@x1 eax
    add eax edx | mov D$ItemRect@x2 eax
    move D$ItemRect@y1 D$ebx+DRAWITEM_RCITEM_TOP
    move D$ItemRect@y2 D$ebx+DRAWITEM_RCITEM_BOTTOM

    mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    On B@Selected = 1, mov edi 2
    call 'GDI32.CreateSolidBrush' D$BackgroundCol@Name+edi*4 | mov D@Brush eax
    call 'USER32.FillRect' D$ebx+DRAWITEM_HDC ItemRect D@Brush
    call 'GDI32.DeleteObject' D@Brush
    call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC D$BackgroundCol@Name+edi*4

    mov ecx D$ebx+DRAWITEM_ITEMDATA ; offset into page
    lea edi D@Offset
    mov B$edi '+'
    mov al ch | and al 0F
    add al '0'
    On al > '9', add al 7
    mov B$edi+1 al
    mov al cl | shr al 4
    add al '0'
    On al > '9', add al 7
    mov B$edi+2 al
    mov al cl | and al 0F
    add al '0'
    On al > '9', add al 7
    mov B$edi+3 al

    call 'User32.DrawTextA' D$ebx+DRAWITEM_HDC, edi, 4, ItemRect,
         (&DT_SINGLELINE+&DT_LEFT+&DT_VCENTER)
        ; (&DT_SINGLELINE+&DT_CENTER+&DT_VCENTER)
;;
  Modification proposed by AKar, because the &CENTER+&DT is causing some miss-alignments,
  in the Memory-View, when showing chinese Unicode.
;;

    ; Print value
    move D$ItemRect@x1 D$ItemRect@x2
    move D$ItemRect@x2 D$ebx+DRAWITEM_RCITEM_RIGHT

    mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    On B@Selected = 1, mov edi 2
    call 'GDI32.CreateSolidBrush' D$BackgroundCol@Value+edi*4 | mov D@Brush eax
    call 'USER32.FillRect' D$ebx+DRAWITEM_HDC, ItemRect, D@Brush
    call 'GDI32.DeleteObject' D@Brush
    call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, D$BackgroundCol@Value+edi*4

    If B@Selected = 1
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0FF_FFFF
    EndIf

    mov esi D$CurrentPage
    add esi D$ebx+DRAWITEM_ITEMDATA
    mov edi ItemString
    mov ecx 8
    call D$MemFormatConversionProc

    call 'User32.DrawTextA' D$ebx+DRAWITEM_HDC, ItemString, 0-1, ItemRect,
         (&DT_SINGLELINE+&DT_CENTER+&DT_VCENTER)

    ; Draw focus rect if selected
    If B@Selected = 1
        lea eax D$ebx+DRAWITEM_RCITEM_LEFT
        call 'USER32.DrawFocusRect' D$ebx+DRAWITEM_HDC, eax
    EndIf
EndP

____________________________________________________________________________________________

; Converts string in Hexadecimal (uppercase) notation to a 32 bit integer. (no leading zeros)
;   esi : String
; Output
;   eax : Integer

HexStringToInt:
    mov edx 0
    While B$esi <> 0

        lodsb

        ; Sort out invalid chars
        sub al '0' | js L6>  ; FAIL:    [esi] < '0'
        cmp al 9   | jle L0> ; SUCCESS: [esi] = '0'..'9'
        cmp al 17  | jl L6>  ; FAIL:    [esi] < 'A'
        sub al 7
        cmp al 16  | jae L6> ; FAIL:    [esi] > 'F'

L0:     shl edx 4
        or dl al

    EndWhile
    mov eax edx
ret
; Invalid character error
L6: call 'User32.MessageBoxA' 0, {'Hexadecimal notation: Only 0-9 and A-F allowed!' 0},
        {'Invalid character' 0}, &MB_ICONWARNING
    mov eax 0-1
ret
____________________________________________________________________________________________

; Converts 32 bit integer to string in hexadecimal notation. (no leading zeros)
;   eax : Integer
; Output is stored in 'HexString'.

[HexString: B$ ? #10]

IntToHexString:
    push edi
        mov ecx 8, edx eax, edi HexString

L0:     mov eax 0
        shld eax edx 4
        shl edx 4

        add al '0'
        On al > '9', add al 7
        stosb
        loop L0<

        mov B$edi 0
    pop edi
ret
____________________________________________________________________________________________

; When the user enters an address by hand and presses enter or the 'go' button, this
; proc is called. The string is converted to an integer. Then it is verified if it is
; a valid address. If the address is valid WM_SET_PAGE is sent to the dialog.
; Otherwise the old value is restored.

Proc MemInspector_OnGoToAddress:
    Arguments @Handle
    Local @Address, @SegBase, @SegLimit
    Uses esi, edi

        call 'USER32.GetDlgItemTextA' D@Handle, MEMINSPECTOR_PAGEEDIT, HexString, 10
        mov esi HexString
      ; Segment override?
        If W$esi = 'FS'
            move D@SegBase D$FS.Linear
            move D@SegLimit D$FS.Limit
            add esi 3
        Else
            mov D@SegBase 0
            mov D@SegLimit 0_FFFF_FFFF
        EndIf
        call HexStringToInt
        If eax > D@SegLimit
            call 'User32.MessageBoxA' D@Handle, {'The offset is beyond the segment limit!' 0},
                {'Invalid address' 0}, &MB_ICONWARNING
            jmp L0>
        EndIf

        add eax D@SegBase
        mov D@Address eax

        call IsProcessMemory D@Address
        If eax > 0
            mov eax D@Address
            and eax PageBaseMask
            SendMessage D@Handle, WM_SET_PAGE, eax, D@Address
        Else
            call 'User32.MessageBoxA' D@Handle, {'This is not a valid address!' 0},
                {'Invalid address' 0}, &MB_ICONWARNING
L0:         mov eax D$CurrentPageAddress
            call IntToHexString
            call 'User32.SetDlgItemTextA' D@Handle, MEMINSPECTOR_PAGEEDIT, HexString
        EndIf
EndP
____________________________________________________________________________________________

; Tag Dialog 1012

Proc MemoryInspectorProc:
    Arguments @Handle @Message @wParam @lParam
    Uses ebx, esi, edi

    ...If D@Message = &WM_INITDIALOG
        VirtualAlloc CurrentPage 4096
        mov D$CurrentPageAddress 0

        call 'USER32.GetClientRect' D@Handle, DebugRect
        move W$MemInspector.Width W$DebugRect@width
        move W$MemInspector.Height W$DebugRect@height

        call 'USER32.GetDlgItem' D@Handle, MEMINSPECTOR_DATA_LIST | mov ebx eax
        mov esi 0
        While esi < 4096
            SendMessage ebx, &LB_ADDSTRING, 0, esi
            add esi 8
        EndWhile

        call 'USER32.GetDlgItem' D@Handle, MEMINSPECTOR_FORMAT_COMBO | mov ebx eax
        SendMessage ebx, &CB_RESETCONTENT, 0, 0
        mov esi MemFormats
        lodsd
        mov edi eax
        While edi > 0
            lodsd
            If D$UnicodeStrings = 0
                SendMessage ebx, &CB_ADDSTRING, 0, D$eax
            Else
                call 'User32.SendMessageW' ebx, &CB_ADDSTRING, 0, D$eax
            EndIf
            dec edi
        EndWhile
        SendMessage ebx, &CB_SETCURSEL, 0, 0
        move D$MemFormatConversionProc D$MemConvert

        call 'USER32.GetDlgItem' D@Handle, MEMINSPECTOR_PREV_BUTTON
        call 'USER32.EnableWindow' eax, &FALSE
        call 'USER32.GetDlgItem' D@Handle, MEMINSPECTOR_NEXT_BUTTON
        call 'USER32.EnableWindow' eax, &FALSE

        call 'USER32.GetDlgItem' D@Handle, MEMINSPECTOR_PAGE_EDIT
        SendMessage eax, &EM_SETLIMITTEXT, 8, 0

        mov eax &TRUE

    ...ElseIf D@Message = WM_REFRESH_CONTENT
        If D$CurrentPageAddress <> 0
            call 'KERNEL32.ReadProcessMemory' D$PI.hProcess,
                D$CurrentPageAddress, D$CurrentPage, PageSize, &NULL
            call 'USER32.GetDlgItem' D@Handle, MEMINSPECTOR_DATA_LIST
            call 'USER32.InvalidateRect' eax, &NULL, &TRUE
        EndIf

        mov eax 0

    ...ElseIf D@Message = WM_SET_PAGE
        mov eax D@wParam
        If eax <> D$CurrentPageAddress
            mov D$CurrentPageAddress eax
            call 'KERNEL32.ReadProcessMemory' D$PI.hProcess, D@wParam, D$CurrentPage, 01000, &NULL
        EndIf
      ; Write Base address of page into an edit
        mov eax D@wParam
        call IntToHexString
        call 'User32.SetDlgItemTextA' D@Handle, MEMINSPECTOR_PAGE_EDIT, HexString
      ; Switch to memory inspector tab
        call SelectTab D$DebugDialogHandle, DEBUGDLG_DATA_TAB, 1
      ; Scroll list to address (lParam) and redraw list entries
        call 'USER32.GetDlgItem' D@Handle, MEMINSPECTOR_DATA_LIST
        mov ebx eax
        mov edi D@lParam
        and edi 0FFF
        shr edi 3
        SendMessage ebx, &LB_SETTOPINDEX, edi, 0
        SendMessage ebx, &LB_SETCURSEL, edi, 0
        call 'USER32.SetFocus' ebx
      ; Activate / Deactivate Prev & Next Buttons
        call 'USER32.GetDlgItem' D@Handle, MEMINSPECTOR_PREV_BUTTON
        mov ebx eax
        call FindPrevPage D$CurrentPageAddress
        On eax > 0, mov eax &TRUE
        call 'USER32.EnableWindow' ebx, eax
        call 'USER32.GetDlgItem' D@Handle, MEMINSPECTOR_NEXT_BUTTON
        mov ebx eax
        call FindNextPage D$CurrentPageAddress
        On eax > 0, mov eax &TRUE
        call 'USER32.EnableWindow' ebx, eax

        mov eax 0

    ...ElseIf D@Message = &WM_DESTROY
        VirtualFree D$CurrentPage
        mov eax 0
;;
    ...Else_if D@Message = &WM_KEYDOWN
        call 'USER32.GetFocus'
        call 'USER32.GetDlgCtrlID' eax
        ;.If eax = MEMINSPECTOR_PAGE_EDIT
            If W@wParam = &VK_RETURN
                nop
            EndIf
        ;.EndIf
;;
    ...Else_if D@Message = &WM_COMMAND
        ..If W@wParam = MEMINSPECTOR_FORMAT_COMBO
            .If W@wParam+2 = &CBN_SELCHANGE
                SendMessage D@lParam, &CB_GETCURSEL, 0, 0
                If eax <> &CB_ERR
                    move D$MemFormatConversionProc D$MemConvert+eax*4
                    call 'USER32.GetDlgItem' D@Handle, MEMINSPECTOR_DATA_LIST
                    call 'USER32.InvalidateRect' eax, &NULL, &TRUE
                EndIf
            .End_If
        ..Else_if W@wParam = MEMINSPECTOR_PREV_BUTTON
            call FindPrevPage D$CurrentPageAddress
            If eax > 0
                SendMessage D@Handle, WM_SET_PAGE, eax, eax
            EndIf
        ..Else_if W@wParam = MEMINSPECTOR_NEXT_BUTTON
            call FindNextPage D$CurrentPageAddress
            If eax > 0
                SendMessage D@Handle, WM_SET_PAGE, eax, eax
            EndIf
        ..Else_if W@wParam = MEMINSPECTOR_TABLE_BUTTON
            call 'User32.DialogBoxParamA' D$hinstance, 1013, D$DebugDialogHandle,
                                          PageTableProc, D$CurrentPageAddress
            If eax >= 01000
                SendMessage D@Handle, WM_SET_PAGE, eax, eax
            EndIf
        ..Else_if W@wParam = MEMINSPECTOR_PAGE_EDIT
            movzx eax W@wParam+2
        ..Else_if W@wParam = &IDOK
            call MemInspector_OnGoToAddress D@Handle
        ..End_If
        mov eax 0

    ...ElseIf D@Message = &WM_SIZE
        movzx eax W$MemInspector.Width
        movzx esi W@lParam
        sub esi eax
        movzx eax W$MemInspector.Height
        movzx edi W@lParam+2
        sub edi eax
        call AdjustControlSize D@Handle, MEMINSPECTOR_DATA_LIST, esi, edi
        call AdjustControlSize D@Handle, MEMINSPECTOR_FORMAT_COMBO, esi, 0
        call AdjustControlPos D@Handle, MEMINSPECTOR_PREV_BUTTON, 0, edi
        call AdjustControlPos D@Handle, MEMINSPECTOR_NEXT_BUTTON, esi, edi
        call AdjustControlPos D@Handle, MEMINSPECTOR_TABLE_BUTTON, 0, edi
        call AdjustControlSize D@Handle, MEMINSPECTOR_TABLE_BUTTON, esi, 0
        call 'USER32.InvalidateRect' D@Handle, &NULL, &TRUE
        move D$MemInspectorSize D@lParam
        mov eax 0

    ...Else_if D@Message = &WM_SETFONT
        call 'USER32.GetDlgItem' D@Handle, MEMINSPECTOR_DATA_LIST
        SendMessage eax, &WM_SETFONT, D@wParam, D@lParam
        call 'USER32.GetDlgItem' D@Handle, MEMINSPECTOR_PAGE_EDIT
        SendMessage eax, &WM_SETFONT, D@wParam, D@lParam

    ...Else_if D@Message = &WM_DRAWITEM
        call MemoryInspector_OnDrawItem D@lParam
        mov eax &TRUE

    ...Else_if D@Message = &WM_MEASUREITEM
        mov eax D@lParam
        mov D$eax+16 15
        mov eax &TRUE

    ...Else
        mov eax &FALSE
    ...EndIf

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; PAGE TABLE
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc PageTable_WritePageDescription:
    Arguments @Address, @Protect
    Uses esi, edi

        ; Write address
        mov eax D@Address
        mov edi PageDesc, ecx 4, edx eax
        test eax 0FFFF | jz L0>
        mov D$edi ' >> '
        add edi 4
L0:     add edi 8

L0:     mov al dl
        mov ah al | and ah 0F | shr al 4

        add ah '0'
        On ah > '9', add ah 7
        dec edi | mov B$edi ah
        add al '0'
        On al > '9', add al 7
        dec edi | mov B$edi al

        shr edx 8
        loop L0<

        ; Write protection "XRWC GN"
        mov edi Pagedesc+9, ecx D@Protect
        On B$Pagedesc = ' ', add edi 4
        mov B$edi-1 9
        mov D$edi '----', D$edi+4 ' -- '
        If ecx = &PAGE_READONLY
            mov B$edi+1 'R'
        Else_if ecx = &PAGE_READWRITE
            mov W$edi+1 'RW'
        Else_if ecx = &PAGE_EXECUTE
            mov B$edi 'X'
        Else_if ecx = &PAGE_EXECUTE_READ
            mov W$edi 'XR'
        Else_if ecx = &PAGE_EXECUTE_READWRITE
            mov D$edi 'XRW-'
        Else_if ecx = &PAGE_EXECUTE_WRITECOPY
            mov D$edi 'XRWC'
        Else_if ecx = &PAGE_WRITECOPY
            mov D$edi '-RWC'
        EndIf
        test ecx &PAGE_GUARD | jz L0>
        mov B$edi+5 'G'
L0:     test ecx &PAGE_NOCACHE | jz L0>
        mov B$edi+6 'N'
L0:
        ; Write module filename (dll/exe), if available
        mov edi Pagedesc+17
        On B$Pagedesc = ' ', add edi 4
        mov eax 0
        call GetModuleName D@Address
        If eax <> 0
            mov esi eax
L0:         movsb | cmp B$esi 0 | jne L0<
        EndIf
        mov D$edi 0
EndP

Proc PageTable_AddItem:
    Arguments @Base, @Size, @Protect, @Type
    Uses esi, edi

        mov esi D@Base, edi esi
        add edi D@Size

        While esi < edi
            call PageTable_WritePageDescription esi, D@Protect
            SendMessage ebx, &LB_ADDSTRING, 0, PageDesc
            SendMessage ebx, &LB_SETITEMDATA, eax, esi
            add esi 01000
        EndWhile
EndP
____________________________________________________________________________________________

Proc PageTable_Build:
    Uses esi

        mov esi D$AddressLowerBound
        While esi < D$AddressUpperBound
            call VirtualQuery esi
            If eax = 1
                call PageTable_AddItem esi, ecx,
                    D$MemoryInformation@Protect, D$MemoryInformation@Type
            ElseIf eax = 0-1
                ExitP
            EndIf
            add esi D$MemoryInformation@RegionSize
        EndWhile
EndP
____________________________________________________________________________________________

; Tag Dialog 1013

Proc PageTableProc:
    Arguments @Handle, @Message, @wParam, @lParam
    Uses ebx, esi, edi

    ..If D@Message = &WM_INITDIALOG
        call 'User32.GetDlgItem' D@Handle, 10
        mov ebx eax
        SendMessage ebx, &LB_RESETCONTENT, 0, 0
        SendMessage ebx, &WM_SETFONT, D$DebugFontHandle, &TRUE
        call PageTable_Build
        mov eax &TRUE

    ..Else_if D@Message = &WM_COMMAND
        .If D@wParam = 1
            call 'User32.GetDlgItem' D@Handle, 10
            mov ebx eax
            SendMessage ebx, &LB_GETCURSEL, 0, 0
            SendMessage ebx, &LB_GETITEMDATA, eax, 0
            call 'USER32.EndDialog' D@Handle, eax
        .Else_if W@wParam = 10
            If W@wParam+2 = &LBN_DBLCLK
                SendMessage D@lParam, &LB_GETCURSEL, 0, 0
                SendMessage D@lParam, &LB_GETITEMDATA, eax, 0
                call 'USER32.EndDialog' D@Handle, eax
            EndIf
        .EndIf
        mov eax 0

    ..Else_if D@Message = &WM_CLOSE
        call 'User32.EndDialog' D@Handle, 0
        mov eax 0
    ..Else
        mov eax &FALSE
    ..EndIf
EndP
____________________________________________________________________________________________

; Tag Dialog 1014

ShowExceptionInfo:
    call 'User32.CreateDialogParamA' D$hInstance, 1014, D$hwnd, ExceptionInfoProc, D$E.ExceptionCode
ret

[EXCEPTINFO_DESC 10 EXCEPTINFO_ADDRESS 15 EXCEPTINFO_INSTRUCTION 20 EXCEPTINFO_INFO 25]

[ExceptionMap:
 &EXCEPTION_ACCESS_VIOLATION ACCESS_VIOLATION
 &EXCEPTION_ARRAY_BOUNDS_EXCEEDED ARRAY_BOUNDS_EXCEEDED
 &EXCEPTION_DATATYPE_MISALIGNMENT DATATYPE_MISALIGNMENT
 &EXCEPTION_FLT_DENORMAL_OPERAND FLT_DENORMAL_OPERAND
 &EXCEPTION_FLT_DIVIDE_BY_ZERO FLT_DIVIDE_BY_ZERO
 &EXCEPTION_FLT_INEXACT_RESULT FLT_INEXACT_RESULT
 &EXCEPTION_FLT_INVALID_OPERATION FLT_INVALID_OPERATION
 &EXCEPTION_FLT_OVERFLOW FLT_OVERFLOW
 &EXCEPTION_FLT_STACK_CHECK FLT_STACK_CHECK
 &EXCEPTION_FLT_UNDERFLOW FLT_UNDERFLOW
 &EXCEPTION_ILLEGAL_INSTRUCTION ILLEGAL_INSTRUCTION
 &EXCEPTION_IN_PAGE_ERROR IN_PAGE_ERROR
 &EXCEPTION_INT_DIVIDE_BY_ZERO INT_DIVIDE_BY_ZERO
 &EXCEPTION_INT_OVERFLOW INT_OVERFLOW
 &EXCEPTION_PRIV_INSTRUCTION PRIV_INSTRUCTION
 &EXCEPTION_STACK_OVERFLOW STACK_OVERFLOW
 &EXCEPTION_INVALID_DISPOSITION INVALID_DISPOSITION
 &EXCEPTION_NONCONTINUABLE_EXCEPTION NONCONTINUABLE_EXCEPTION
 0 UNKNOWN_EXCEPTION]

[ExceptionCaption: B$ ? #128]

Proc ExceptionInfoProc:
    Arguments @Handle, @Message, @wParam, @lParam
    Uses ebx, esi, edi

    ..If D@Message = &WM_INITDIALOG

      ; Output module in caption
        If D$CurrentModule <> 0
            mov eax D$CurrentModule
        Else
            mov eax {'Exception in Non-Code Section' 0}
        EndIf
        call 'User32.SetWindowTextA' D@Handle, eax

      ; Output exception description
        mov eax D$E.ExceptionCode
        mov esi ExceptionMap
        While D$esi <> 0
            cmp eax D$esi | je L0>
            add esi 8
        EndWhile
        mov edx eax, ecx 4, edi D$esi+4
        call IntToHex
L0:     call 'USER32.GetDlgItem' D@Handle, EXCEPTINFO_DESC | mov ebx eax
        SendMessage ebx, &WM_SETFONT, D$DebugFontHandle, &TRUE
        call 'User32.SetWindowTextA' ebx, D$esi+4

      ; Output troubling instruction and its address
        mov eax D$E.ExceptionAddress
        call IntToHexString
        call 'USER32.GetDlgItem' D@Handle, EXCEPTINFO_ADDRESS | mov ebx eax
        SendMessage ebx, &WM_SETFONT, D$Font1Handle, &TRUE
        call 'User32.SetWindowTextA' ebx, HexString

        call NextInstructionDecode
        call 'USER32.GetDlgItem' D@Handle, EXCEPTINFO_INSTRUCTION | mov ebx eax
        SendMessage ebx, &WM_SETFONT, D$Font1Handle, &TRUE
        call 'User32.SetWindowTextA' ebx, D$NextInstructionPtr

      ; Output further information for protection faults
        .If D$E.ExceptionCode = &EXCEPTION_ACCESS_VIOLATION
            mov eax D$E.ExceptionInfo ; read/write
            If eax = 0
                mov D$AV_ReadWrite 'read', D$AV_ReadWrite+4 ' fro', B$AV_ReadWrite+8 'm'
            Else
                mov D$AV_ReadWrite 'writ', D$AV_ReadWrite+4 'e at', B$AV_ReadWrite+8 ' '
            EndIf
            mov edx D$E.ExceptionInfo+4 ; inaccessible address
            mov ecx 4, edi AV_Address
            call IntToHex
            call 'User32.SetDlgItemTextA' D@Handle, EXCEPTINFO_INFO, Exception_AV
        .EndIf

      ; If the exception can be continued hand to the SEH
        call 'USER32.GetDlgItem' D@Handle, 2
        mov edx D$ExceptionFlags | and edx E_MUSTEXIT
        If edx <> 0
            mov edx 0
        Else
            mov edx 1
        EndIf
        call 'USER32.EnableWindow' eax, edx

        call 'USER32.GetDlgItem' D@Handle, 1
        call 'USER32.SetFocus' eax
        mov eax 0

    ..Else_if D@Message = &WM_CTLCOLORSTATIC
        call 'USER32.GetDlgItem' D@Handle, EXCEPTINFO_DESC
        If eax = D@lParam
            call 'GDI32.SetBkColor' D@wParam, D$DialogsBackColor
            mov eax D$DialogsBackGroundBrushHandle
            ExitP
        EndIf
        call 'USER32.GetDlgItem' D@Handle, EXCEPTINFO_INSTRUCTION
        If eax = D@lParam
            call 'GDI32.SetTextColor' D@wParam, 099
            call 'GDI32.SetBkColor' D@wParam, D$DialogsBackColor
            mov eax D$DialogsBackGroundBrushHandle
            ExitP
        EndIf
        call 'USER32.GetDlgItem' D@Handle, EXCEPTINFO_ADDRESS
        If eax = D@lParam
            call 'GDI32.SetBkColor' D@wParam, D$DialogsBackColor
            mov eax D$DialogsBackGroundBrushHandle
            ExitP
        EndIf
        mov eax 0

    ..Else_if D@Message = &WM_COMMAND
        .If D@wParam = 1
            call 'USER32.EndDialog' D@Handle, 0
            mov B$TerminateDebuggee &TRUE
            call DebugDialog_ContinueDebuggee
            ;SendMessage D$DebugDialogHandle, &WM_CLOSE, 0, 0
        .ElseIf D@wParam = 2
            call 'USER32.EndDialog' D@Handle, 0
            call DebugDialog_ContinueDebuggee
        .EndIf
        mov eax 0

    ..Else_if D@Message = &WM_CLOSE
        call 'User32.EndDialog' D@Handle, 0
        mov eax 0
    ..Else
        mov eax &FALSE
    ..EndIf
EndP


____________________________________________________________________________________________
____________________________________________________________________________________________

; DATA LABEL VIEWER
____________________________________________________________________________________________
____________________________________________________________________________________________

[PADDING 4]

Proc DataView_OnDrawItem:
    Arguments @DrawItemStruc
    Local @Brush @Address @Selected

    mov ebx D@DrawItemStruc
    call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0

    mov D@Selected 0
    test D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED
    setz al
    xor al 1
    mov B@Selected al

  ; Print Offset
    mov edx D$DebugFontCharWidth | shl edx 3 | add edx PADDING ; 8 chars
    mov eax D$ebx+DRAWITEM_RCITEM_LEFT | mov D$ItemRect@x1 eax
    add eax edx | mov D$ItemRect@x2 eax
    move D$ItemRect@y1 D$ebx+DRAWITEM_RCITEM_TOP
    move D$ItemRect@y2 D$ebx+DRAWITEM_RCITEM_BOTTOM

    mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    On B@Selected = 1, mov edi 2
    call 'GDI32.CreateSolidBrush' D$BackgroundCol@Name+edi*4 | mov D@Brush eax
    call 'USER32.FillRect' D$ebx+DRAWITEM_HDC ItemRect D@Brush
    call 'GDI32.DeleteObject' D@Brush
    call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC D$BackgroundCol@Name+edi*4

    call IsWatchPoint D$ebx+DRAWITEM_ITEMDATA
    If eax = 1
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0CC
    ElseIf eax = 3
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 066CC
    EndIf

    mov eax D$ebx+DRAWITEM_ITEMDATA
    call IntToHexString
    call 'User32.DrawTextA' D$ebx+DRAWITEM_HDC, HexString, 8, ItemRect,
         (&DT_SINGLELINE+&DT_CENTER+&DT_VCENTER)

  ; Print value
    move D$ItemRect@x1 D$ItemRect@x2
    move D$ItemRect@x2 D$ebx+DRAWITEM_RCITEM_RIGHT

    mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    On B@Selected = 1, mov edi 2
    call 'GDI32.CreateSolidBrush' D$BackgroundCol@Value+edi*4 | mov D@Brush eax
    call 'USER32.FillRect' D$ebx+DRAWITEM_HDC ItemRect D@Brush
    call 'GDI32.DeleteObject' D@Brush
    call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, D$BackgroundCol@Value+edi*4

    If B@Selected = 1
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0FF_FFFF
    EndIf

    SendMessage D$ebx+DRAWITEM_HWNDITEM, &CB_GETLBTEXT, D$ebx+DRAWITEM_ITEMID, ItemString

    add D$ItemRect@x1 5
    call 'User32.DrawTextA' D$ebx+DRAWITEM_HDC, ItemString, 0-1, ItemRect,
         (&DT_SINGLELINE+&DT_LEFT+&DT_VCENTER)

    ; Draw focus rect if selected
    If B@Selected = 1
        lea eax D$ebx+DRAWITEM_RCITEM_LEFT
        call 'USER32.DrawFocusRect' D$ebx+DRAWITEM_HDC, eax
    EndIf
EndP
____________________________________________________________________________________________

Proc DataView_OnDrawValueItem:
    Arguments @DrawItemStruc
    Local @Brush @Address @Selected

    mov ebx D@DrawItemStruc
    On D$ebx+DRAWITEM_ITEMID = 0-1, ExitP

    call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, 0

    mov D@Selected 0
    test D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED
    setz al
    xor al 1
    mov B@Selected al

  ; Print size
    mov edx D$DebugFontCharWidth | shl edx 3 | add edx PADDING ; 8 chars
    mov eax D$ebx+DRAWITEM_RCITEM_LEFT | mov D$ItemRect@x1 eax
    add eax edx | mov D$ItemRect@x2 eax
    move D$ItemRect@y1 D$ebx+DRAWITEM_RCITEM_TOP
    move D$ItemRect@y2 D$ebx+DRAWITEM_RCITEM_BOTTOM

    mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    ;On B@Selected = 1, mov edi 2
    call 'GDI32.CreateSolidBrush' D$BackgroundCol@Name+edi*4 | mov D@Brush eax
    call 'USER32.FillRect' D$ebx+DRAWITEM_HDC ItemRect D@Brush
    call 'GDI32.DeleteObject' D@Brush
    call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC D$BackgroundCol@Name+edi*4

    mov eax D$ebx+DRAWITEM_ITEMDATA
    If al = 'D'
        mov eax {'32bit' 0}
    ElseIf al = 'W'
        mov eax {'16bit' 0}
    ElseIf al = 'B'
        mov eax {'8bit' 0}
    ElseIf al = 'S'
        mov eax {'ASCII' 0}
    ElseIf al = 'F'
        mov eax {'32bit FP' 0}
    ElseIf al = 'R'
        mov eax {'64bit FP' 0}
    ElseIf al = 'T'
        mov eax {'80bit FP' 0}
    EndIf
    call 'User32.DrawTextA' D$ebx+DRAWITEM_HDC, eax, -1, ItemRect, (&DT_SINGLELINE+&DT_CENTER+&DT_VCENTER)

  ; Print value
    move D$ItemRect@x1 D$ItemRect@x2
    move D$ItemRect@x2 D$ebx+DRAWITEM_RCITEM_RIGHT

    mov edi D$ebx+DRAWITEM_ITEMID | and edi 1
    ;On B@Selected = 1, mov edi 2
    call 'GDI32.CreateSolidBrush' D$BackgroundCol@Value+edi*4 | mov D@Brush eax
    call 'USER32.FillRect' D$ebx+DRAWITEM_HDC ItemRect D@Brush
    call 'GDI32.DeleteObject' D@Brush
    call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC D$BackgroundCol@Value+edi*4

    mov B$HexSeparator 3

    mov eax D$ebx+DRAWITEM_ITEMDATA, esi DataBuffer
    If al = 'D'
        mov ecx 4 | call toHex
        sub edi 2 | mov W$edi '0x'
    ElseIf al = 'W'
        mov ecx 2 | call toHex
        sub edi 2 | mov W$edi '0x'
    ElseIf al = 'B'
        mov ecx 1 | call toHex
        sub edi 2 | mov W$edi '0x'
    ElseIf al = 'S'
        mov edi DataBuffer
    ElseIf al = 'F'
        mov ecx 4 | call toFloat
    ElseIf al = 'R'
        mov ecx 8 | call toDouble
    ElseIf al = 'T'
        mov ecx 10 | call toExtended
    EndIf

    add D$ItemRect@x1 5
    call 'User32.DrawTextA' D$ebx+DRAWITEM_HDC, edi, 0-1, ItemRect,
         (&DT_SINGLELINE+&DT_LEFT+&DT_VCENTER)

    mov eax D$ItemRect@x2 | sub eax D$ItemRect@x1
    mov edx 0, ecx 3 | div ecx
    push eax
        add D$ItemRect@x1 eax

        mov eax D$ebx+DRAWITEM_ITEMDATA, esi DataBuffer
        If al = 'D'
            mov ecx 4 | call toUDWord
        ElseIf al = 'W'
            mov ecx 2 | call toUWord
        ElseIf al = 'B'
            mov ecx 1 | call toUByte
        Else
            pop eax | jmp L0>
        EndIf
        call 'User32.DrawTextA' D$ebx+DRAWITEM_HDC, edi, 0-1, ItemRect, (&DT_SINGLELINE+&DT_LEFT+&DT_VCENTER)
    pop eax
    add D$ItemRect@x1 eax

    mov eax D$ebx+DRAWITEM_ITEMDATA, esi DataBuffer
    If al = 'D'
        mov ecx 4 | call toSDWord
    ElseIf al = 'W'
        mov ecx 2 | call toSWord
    ElseIf al = 'B'
        mov ecx 1 | call toSByte
    Else
        pop eax | jmp L0>
    EndIf
    call 'User32.DrawTextA' D$ebx+DRAWITEM_HDC, edi, 0-1, ItemRect, (&DT_SINGLELINE+&DT_LEFT+&DT_VCENTER)

    ; Draw focus rect if selected
L0: If B@Selected = 1
        lea eax D$ebx+DRAWITEM_RCITEM_LEFT
        call 'USER32.DrawFocusRect' D$ebx+DRAWITEM_HDC, eax
    EndIf
EndP
____________________________________________________________________________________________

; Insert data label sorted by address. Brute force search.

Proc DataView_InsertDataLabel:
    Arguments @ComboHandle, @Name, @Address
    Uses ebx

    mov ebx 0

L0: SendMessage D@ComboHandle, &CB_GETITEMDATA, ebx, 0
    cmp eax &CB_ERR | je L1> ; EOL or highest address > append

    If eax > D@Address
L1:     SendMessage D@ComboHandle, &CB_INSERTSTRING, ebx, D@Name
        ExitP
    Endif

    inc ebx | jmp L0<
EndP
____________________________________________________________________________________________

; Filling the ComboBox with the Data Label Names (as string) / Addresses (as data)

[DataLabelComboHandle: ?]

Proc DataView_FillDataLabelCombo:
    Arguments @ComboHandle @SortByName

    SendMessage D@ComboHandle, &CB_RESETCONTENT, 0, 0
    move D$DataLabelComboHandle D@ComboHandle

    mov esi D$PlainLabelList
    lodsd | mov edx D$PlainLabelList | add edx eax

L0: inc esi ; '|'

L0: mov ebx esi
    While B$esi <> 2
        inc esi
    End_While
    test B$esi+5 DataLabelFlag | jz L2>

        mov edi ItemString, esi ebx
        While B$esi <> 2
            movsb
        End_While
        mov B$edi 0
        push edx
            mov ebx D$esi+1 | add ebx D$DataAjust
            If D@SortByName = 1
                SendMessage D@ComboHandle, &CB_ADDSTRING, 0, ItemString
            Else
                call DataView_InsertDataLabel D@ComboHandle, ItemString, ebx
            EndIf
            SendMessage D@ComboHandle, &CB_SETITEMDATA, eax, ebx
        pop edx
        add esi 7
        cmp esi edx | jb L0<
    ExitP

L2: add esi 7 | cmp esi edx | jb L0<
EndP
____________________________________________________________________________________________

Proc DataView_LoadSettings:
    Arguments @FileHandle @Size

  ; Copy label to stack
    mov eax D@Size | add eax 4 | and eax 0_FFFF_FFFC ; reserve for \0 and dw-align stack
    sub esp eax | mov edi esp
    call 'KERNEL32.ReadFile' D@FileHandle, edi, D@Size, BytesTransfered, 0
    mov ecx D@Size | mov B$edi+ecx 0 ; terminate string

  ; Search and select
    SendMessage D$DataLabelComboHandle, &CB_FINDSTRING, 0-1, edi
    SendMessage D$DataLabelComboHandle, &CB_SETCURSEL, eax, 0

    mov eax 1
EndP
____________________________________________________________________________________________

Proc DataView_SaveSettings:
    Arguments @FileHandle
    Structure @Settings 8, @Id 0, @Size 4

    mov D@Id 'LaLa' ; LAst LAbel

  ; Get currently selected label
    SendMessage D$DataLabelComboHandle, &CB_GETCURSEL, 0, 0
    On eax = 0-1, ExitP
    mov ebx eax
    SendMessage D$DataLabelComboHandle, &CB_GETLBTEXTLEN, ebx, 0
    mov D@Size eax

  ; Copy label to stack
    add eax 4 | and eax 0_FFFF_FFFC ; reserve for \0 and dw-align stack
    sub esp eax | mov edi esp
    SendMessage D$DataLabelComboHandle, &CB_GETLBTEXT, ebx, edi

    call 'KERNEL32.WriteFile' D@FileHandle, D@Settings, 8, BytesTransfered, 0
    call 'KERNEL32.WriteFile' D@FileHandle, edi, D@Size, BytesTransfered, 0
EndP
____________________________________________________________________________________________

[DataBuffer: B$ ? #64]
[DataValue: B$ ? #32]
[DataPointer: ?]

Proc DataView_OnSelectDataLabel:
    Arguments @DlgHandle @ComboHandle
    Local @LabelLen @ListHandle

        SendMessage D@ComboHandle, &CB_GETCURSEL, 0, 0
        On eax = &CB_ERR, ExitP
        SendMessage D@ComboHandle, &CB_GETITEMDATA, eax, 0
        mov D$DataPointer eax

        call 'USER32.GetDlgItem' D@DlgHandle, DATAVIEW_VALUE_LIST
        mov D@ListHandle eax

        SendMessage D@ListHandle, &LB_RESETCONTENT, 0, 0

        ; Read a block of memory with a max size of 64 byte
        call IsProcessMemory D$DataPointer
        On eax = 0, ExitP
        mov ebx 64
        If eax < ebx
            mov ebx eax
        EndIf
        call 'KERNEL32.ReadProcessMemory' D$PI.hProcess, D$DataPointer, DataBuffer, ebx, &NULL

        ; DWord Size
        On ebx >= 4, SendMessage D@ListHandle, &LB_ADDSTRING, 0, 'D'
        ; Word Size
        On ebx >= 2, SendMessage D@ListHandle, &LB_ADDSTRING, 0, 'W'
        ; Byte size
        SendMessage D@ListHandle, &LB_ADDSTRING, 0, 'B'
        ; String
        call IsString DataBuffer 64
        If ah = 1
            mov B$DataBuffer+63 0
            SendMessage D@ListHandle, &LB_ADDSTRING, 0, 'S'
        EndIf
        ; Float
        On ebx >= 4, SendMessage D@ListHandle, &LB_ADDSTRING, 0, 'F'
        ; Double
        On ebx >= 8, SendMessage D@ListHandle, &LB_ADDSTRING, 0, 'R'
        ; Extended
        On ebx >= 10, SendMessage D@ListHandle, &LB_ADDSTRING, 0, 'T'

        ; Activate 'More' button
        call 'USER32.GetDlgItem' D@DlgHandle, M03_SHOW_MEM
        call 'USER32.EnableWindow' eax, &TRUE
        ; Activate/Deactivate 'More From Pointer' button
        .If ebx >= 4
            call IsProcessMemory D$DataBuffer
            If eax > 0
                mov ebx &TRUE
            Else
                mov ebx &FALSE
            EndIf
            call 'User32.GetDlgItem' D@DlgHandle, M03_SHOW_PMEM
            call 'USER32.EnableWindow' eax, ebx
            If ebx = &TRUE
                mov eax &MF_ENABLED
            Else
                mov eax &MF_GRAYED
            EndIf
            call 'USER32.EnableMenuItem' D$DataView.PopupMenu, M03_SHOW_PMEM, eax
        .EndIf
EndP
____________________________________________________________________________________________

Proc DataView_SelectSymbol:
    Arguments @DlgHandle, @Address
    Local @ComboHandle

        call SelectTab D$DebugDialogHandle, DEBUGDLG_DATA_TAB, 0
        call 'USER32.GetDlgItem' D@DlgHandle, DATAVIEW_LABEL_COMBO
        mov D@ComboHandle eax
        SendMessage D@ComboHandle, &CB_GETCOUNT, 0, 0
        mov edi eax, esi 0, ebx D@Address
        While esi < edi
            SendMessage D@ComboHandle, &CB_GETITEMDATA, esi, 0
            If eax = ebx
                SendMessage D@ComboHandle, &CB_SETCURSEL, esi, 0
                ExitP
            EndIf
            inc esi
        EndWhile
EndP

____________________________________________________________________________________________

Proc DataView_ShowDeclaration:
    Arguments @DlgHandle
    Local @ComboHandle, @LabelLen

        call 'USER32.GetDlgItem' D@DlgHandle, DATAVIEW_LABEL_COMBO
        mov D@ComboHandle eax

        SendMessage D@ComboHandle, &CB_GETCURSEL, 0, 0
        On eax = &CB_ERR, ExitP
        SendMessage D@ComboHandle, &CB_GETLBTEXT, eax, ItemString
        mov D@LabelLen eax

        call RestoreRealSource

        mov edx ItemString, ebx D@LabelLen
        call InternSearch
        If B$BlockInside = &TRUE
            mov B$BlockInside &FALSE
            mov esi D$CurrentWritingPos | dec esi | call InternalRightClick
        End_If

        call SetPartialEditionFromPos
EndP
____________________________________________________________________________________________

[DataView.PopupMenu: ?]

[M03_SHOW_MEM       3100
 M03_SHOW_PMEM      3101
 M03_SHOW_DECL      3102
 M03_WATCH_W        3103
 M03_WATCH_RW       3104
 M03_SORTBYNAME     3105
 M03_SORTBYADDRESS  3106]

Proc DataView_CreatePopupMenu:
    Arguments @DlgHandle

    call 'USER32.CreatePopupMenu' | mov ebx eax, D$DataView.PopupMenu eax
    call AppendMenu ebx, &MF_OWNERDRAW, M03_SHOW_MEM, 0
    call AppendMenu ebx, &MF_OWNERDRAW, M03_SHOW_PMEM, 0
    call AppendMenu ebx, &MF_OWNERDRAW, M03_SHOW_DECL, 0
    call AppendMenu ebx, &MF_SEPARATOR, 0, 0
    call AppendMenu ebx, &MF_OWNERDRAW, M03_WATCH_W, 0
    call AppendMenu ebx, &MF_OWNERDRAW, M03_WATCH_RW, 0
    call AppendMenu ebx, &MF_SEPARATOR, 0, 0
    call AppendMenu ebx, &MF_OWNERDRAW, M03_SORTBYNAME, 0
    call AppendMenu ebx, &MF_OWNERDRAW, M03_SORTBYADDRESS, 0

    call 'USER32.CheckMenuRadioItem' D$DataView.PopupMenu, M03_SORTBYNAME, M03_SORTBYADDRESS,
        M03_SORTBYNAME, &MF_BYCOMMAND
EndP
____________________________________________________________________________________________

Proc DataView_UpdatePopupMenu:
    call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_RW, &MF_UNCHECKED
    call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_W, &MF_UNCHECKED
    call IsWatchPoint D$DataPointer
    If eax = 0011
        call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_RW, &MF_CHECKED
    ElseIf eax = 1
        call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_W, &MF_CHECKED
    EndIf
EndP
____________________________________________________________________________________________

; Process WM_DRAWITEM message for owner-drawn menu items.
;;
Proc DebugDialog_OnDrawMenuItem:
    Arguments @DrawItemStruc
    Local @Brush

    mov ebx D@DrawItemStruc

    mov esi DebugMenuTable
    lodsd | mov ecx eax ; number of entries
    mov eax D$ebx+DRAWITEM_ITEMID
    While D$esi <> eax
        add esi 16
        dec ecx | jz L9>>
    EndWhile

    call 'GDI32.SelectObject' D$ebx+DRAWITEM_HDC, D$DialogFont_handle
    push eax

    Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_GRAYED
        call 'USER32.GetSysColor' &COLOR_GRAYTEXT
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax
        jmp L1>
    Test_Else_If D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED
        call 'USER32.GetSysColor' &COLOR_MENUTEXT
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax

        call 'USER32.GetSysColor' &COLOR_HIGHLIGHTTEXT
        call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, eax

        call 'USER32.GetSysColorBrush' &COLOR_HIGHLIGHTTEXT
    Test_Else
        call 'USER32.GetSysColor' &COLOR_MENUTEXT
        call 'GDI32.SetTextColor' D$ebx+DRAWITEM_HDC, eax

L1:     call 'USER32.GetSysColor' &COLOR_MENU
        call 'GDI32.SetBkColor' D$ebx+DRAWITEM_HDC, eax

        call 'USER32.GetSysColorBrush' &COLOR_MENU
    Test_End

    lea edx D$ebx+DRAWITEM_RCITEM_LEFT
    call 'USER32.FillRect' D$ebx+DRAWITEM_HDC, edx, eax

    mov eax D$esi+12 ; image index
    If eax <> 0-1
        mov ecx D$ebx+DRAWITEM_RCITEM_LEFT | add ecx 2
        mov edx D$ebx+DRAWITEM_RCITEM_TOP  | add edx 2
        Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_GRAYED
            mov edi &ILD_MASK
        Test_Else_If D$ebx+DRAWITEM_ITEMSTATE &ODS_SELECTED
            mov edi &ILD_NORMAL
        Test_Else
            mov edi &ILD_TRANSPARENT
        Test_End

        Test_If D$ebx+DRAWITEM_ITEMSTATE &ODS_CHECKED
            mov eax 6
        Test_End

L0:     call 'COMCTL32.ImageList_Draw' D$DebugDialog_ImageList, eax, D$ebx+DRAWITEM_HDC, ecx, edx, edi
    EndIf

    add D$ebx+DRAWITEM_RCITEM_LEFT 22

    mov eax D$esi+4
    call DrawMenuItemText D$eax, &DT_LEFT

    mov eax D$esi+8
    If eax <> 0
      ; Draw shortcut rightaligned
        dec D$ebx+DRAWITEM_RCITEM_RIGHT
        call DrawMenuItemTextA eax, &DT_RIGHT
    EndIf

    pop eax
    call 'GDI32.SelectObject' D$ebx+DRAWITEM_HDC, eax

L9: mov eax 1
EndP
;;
____________________________________________________________________________________________

; To allow rightclick inside the list of a combobox we override the window proc of the list.
; The listbox is a child window of the combobox from which the handle is retrieved through
; enumerating.

[ComboListClass: 'ComboLBox' 0] ; consistent among all win OS's ?
[ComboChildClass: B$ ? #32]

Proc EnumComboChilds:
    Arguments @Handle, @Param
    Uses esi, edi

    call 'User32.GetClassNameA' D@Handle, ComboChildClass, 32
    mov edi ComboListClass, esi ComboChildClass, ecx eax
    repe cmpsb | je L1>
    mov eax 1 | ExitP ; continue search

  ; Listbox of the combo
L1: call 'User32.SetWindowLongA' D@Handle, &GWL_WNDPROC, DataView_InterceptRightClick
    mov D$DataView.LBProc eax
    mov eax 0 ; finish search
EndP
____________________________________________________________________________________________

Proc DataView_OverrideComboProc:
    Arguments @DlgHandle

    mov D$DataView.LBProc 0
    call 'USER32.GetDlgItem' D@DlgHandle, DATAVIEW_LABEL_COMBO | mov ebx eax
    call 'USER32.EnumChildWindows' ebx, EnumComboChilds, 0
    If D$DataView.LBProc = 0
        call 'User32.MessageBoxA' 0,
            {'Listbox not found in combo! Please report this problem and your OS version on the board.' 0},
            {'EnumChildWindows' 0}, &MB_OK+&MB_ICONWARNING
    EndIf
EndP

[DataView.LBProc: ?]

Proc DataView_InterceptRightClick:
    Arguments @Handle, @Message, @wParam, @lParam
    Uses ebx esi edi

    If D@Message = &WM_RBUTTONDOWN
      ; Simulate left click (select item) before showing the popup menu
        SendMessage D@Handle, &WM_LBUTTONDOWN, D@wParam, D@lParam
        SendMessage D@Handle, &WM_LBUTTONUP, D@wParam, D@lParam
      ; Show the popup menu at the position of the mouse-click
        movzx eax W@lParam
        movzx ecx W@lParam+2
        mov D$PointX eax, D$PointY ecx
        call 'USER32.ClientToScreen' D@Handle, Point
        call 'USER32.TrackPopupMenu' D$DataView.PopupMenu, &TPM_LEFTALIGN, D$PointX, D$PointY, 0, D$DataViewHandle, 0
    ElseIf D@Message = &WM_LBUTTONDBLCLK
      ; Show more
        mov eax D$DataPointer | and eax 0_FFFF_F000
        SendMessage D$MemoryInspectorHandle, WM_SET_PAGE, eax, D$DataPointer
    EndIf
    call 'User32.CallWindowProcA' D$DataView.LBProc, D@Handle, D@Message, D@wParam, D@lParam
EndP
____________________________________________________________________________________________

; Process WM_INITDIALOG message.

Proc DataViewDialog_OnCreate:
    Arguments @Handle

        call 'USER32.GetClientRect' D@Handle, DebugRect
        move W$DataView.Width W$DebugRect@width
        move W$DataView.Height W$DebugRect@height

        call 'USER32.GetDlgItem' D@Handle, DATAVIEW_LABEL_COMBO
        call DataView_FillDataLabelCombo eax 1

        call DataView_CreatePopupMenu D@Handle
        call DataView_OverrideComboProc D@Handle

        mov eax &TRUE
EndP
____________________________________________________________________________________________

; Process WM_SIZE message.

Proc DataViewDialog_OnSize:
    Arguments @Handle, @WidthHeight

        movzx eax W$DataView.Width
        movzx esi W@WidthHeight
        sub esi eax
        movzx eax W$DataView.Height
        movzx edi W@WidthHeight+2
        sub edi eax
        call AdjustControlSize D@Handle, DATAVIEW_LABEL_COMBO, esi, edi
        call AdjustControlSize D@Handle, DATAVIEW_VALUE_LIST, esi, 0
        call AdjustControlPos D@Handle, DATAVIEW_VALUE_LIST, 0, edi
        call 'USER32.InvalidateRect' D@Handle, &NULL, &TRUE

        move D$DataViewSize D@WidthHeight
        mov eax 0
EndP
____________________________________________________________________________________________

; Process WM_COMMAND message.

Proc DataViewDialog_OnCommand:
    Arguments @Handle, @wParam, @lParam

        movzx ecx W@wParam
        movzx eax W@wParam+2
        .If ecx = DATAVIEW_LABEL_COMBO
            If eax = &CBN_SELCHANGE
                call DataView_OnSelectDataLabel D@Handle, D@lParam
                call DataView_UpdatePopupMenu
            EndIf
        .ElseIf ecx = M03_SHOW_MEM
            mov eax D$DataPointer
            and eax 0_FFFF_F000
            SendMessage D$MemoryInspectorHandle, WM_SET_PAGE, eax, D$DataPointer
        .ElseIf ecx = M03_SHOW_PMEM
            mov eax D$DataBuffer
            and eax 0_FFFF_F000
            SendMessage D$MemoryInspectorHandle, WM_SET_PAGE, eax, D$DataBuffer
        .ElseIf ecx = M03_SHOW_DECL
            call DataView_ShowDeclaration D@Handle
        .ElseIf ecx = M03_WATCH_W
            call 'USER32.GetMenuState' D$DataView.PopupMenu, M03_WATCH_W, 0
            and eax &MF_CHECKED
            If eax = 0
                call SetWatchPoint D$DataPointer, 4, 1
                call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_W, &MF_CHECKED
            Else
                call DeleteWatchPoint
                call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_W, &MF_CHECKED
            EndIf
            call 'USER32.GetDlgItem' D@Handle, DATAVIEW_LABEL_COMBO
            call 'USER32.InvalidateRect' eax, 0, &FALSE
        .ElseIf ecx = M03_WATCH_RW
            call 'USER32.GetMenuState' D$DataView.PopupMenu, M03_WATCH_RW, 0
            and eax &MF_CHECKED
            If eax = 0
                call SetWatchPoint D$DataPointer, 4, 3
                call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_RW, &MF_CHECKED
            Else
                call DeleteWatchPoint
                call 'USER32.CheckMenuItem' D$DataView.PopupMenu, M03_WATCH_RW, &MF_CHECKED
            EndIf
            call 'USER32.GetDlgItem' D@Handle, DATAVIEW_LABEL_COMBO
            call 'USER32.InvalidateRect' eax, 0, &FALSE
        .ElseIf ecx = M03_SORTBYNAME
            call 'USER32.CheckMenuRadioItem' D$DataView.PopupMenu, M03_SORTBYNAME, M03_SORTBYADDRESS,
                                             M03_SORTBYNAME, &MF_BYCOMMAND
            call DataView_FillDataLabelCombo D$DataLabelComboHandle 1

        .ElseIf ecx = M03_SORTBYADDRESS
            call 'USER32.CheckMenuRadioItem' D$DataView.PopupMenu, M03_SORTBYNAME, M03_SORTBYADDRESS,
                                             M03_SORTBYADDRESS, &MF_BYCOMMAND
            call DataView_FillDataLabelCombo D$DataLabelComboHandle 0
        .EndIf

        mov eax 0
EndP
____________________________________________________________________________________________

[DataViewSize:
 DataView.Width: W$ ?
 DataView.Height: W$ ?]

[DATAVIEW_LABEL_COMBO 50
 DATAVIEW_VALUE_LIST 120]

; Tag Dialog 1011

Proc DataViewProc:
    Arguments @Handle, @Message, @wParam, @lParam
    Uses ebx, esi, edi

    .If D@Message = &WM_INITDIALOG
        call DataViewDialog_OnCreate D@Handle

    .Else_If D@Message = &WM_SIZE
        call DataViewDialog_OnSize D@Handle, D@lParam

    .Else_If D@Message = &WM_COMMAND
        call DataViewDialog_OnCommand D@Handle, D@wParam, D@lParam

    .Else_if D@Message = WM_REFRESH_CONTENT
        call 'USER32.GetDlgItem' D@Handle, DATAVIEW_LABEL_COMBO
        call DataView_OnSelectDataLabel D@Handle, eax

    .Else_if D@Message = WM_SELECT_SYMBOL
        call DataView_SelectSymbol D@Handle, D@wParam

    .Else_if D@Message = &WM_SETFONT
        call 'USER32.GetDlgItem' D@Handle, DATAVIEW_LABEL_COMBO
        SendMessage eax, &WM_SETFONT, D@wParam, D@lParam
        call 'USER32.GetDlgItem' D@Handle, DATAVIEW_VALUE_LIST
        SendMessage eax, &WM_SETFONT, D@wParam, D@lParam

    .Else_if D@Message = &WM_DRAWITEM
        If D@wParam = 0
            call DebugDialog_OnDrawMenuItem D@lParam
        ElseIf D@wParam = DATAVIEW_LABEL_COMBO
            call DataView_OnDrawItem D@lParam
        Else
            call DataView_OnDrawValueItem D@lParam
        EndIf
        mov eax &TRUE

    .Else_if D@Message = &WM_MEASUREITEM
        mov eax D@lParam
        If D@wParam = 0
          ; menu
            call DebugDialog_OnMeasureMenuItem D@lParam
        Else
          ; listbox
            mov D$eax+16 15
        EndIf
        mov eax &TRUE

    .Else
        mov eax &FALSE
    .EndIf
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; Conversion Routines
;   esi : Address of Register (in Context)
;   ecx : Size in Bytes
; Output
;   edi : Address of Ascii String

[HexSeparator: ?]

toHex:
    mov edi StringBufTail
    mov eax 0, B$edi 0

L0: lodsb
    mov ah al | and ah 0F | shr al 4

    add ah '0'
    On ah > '9', add ah 7
    dec edi | mov B$edi ah

    add al '0'
    On al > '9', add al 7
    dec edi | mov B$edi al

    dec ecx
    jecxz L1>

    test B$HexSeparator cl | jnz L0<
    dec edi | mov B$edi ' '

    jmp L0<

L1: ret

toAscii:
    mov edi StringBuf
    rep movsb
    mov B$edi 0
    mov edi StringBuf
ret
____________________________________________________________________________________________

; Convert dword value to hex-string onto specified buffer
;   ecx : size of value (1 | 2 | 4)
;   edx : source value (dl | dx | edx)
;   edi : address of destination
; Output
;   edi : address behind hex-string
; Uses
;   eax, edx

[DwordToHex | mov ecx 4 | mov edx #1 | call IntToHex]
[WordToHex  | mov ecx 2 | mov  dx #1 | call IntToHex]
[ByteToHex  | mov ecx 1 | mov  dl #1 | call IntToHex]

IntToHex:
    mov eax ecx | add eax eax
    add edi eax
    mov eax 0 ;, B$edi 0

    push edi

L0:     mov al dl | shr edx 8
        mov ah al | and ah 0F | shr al 4

        add ah '0'
        On ah > '9', add ah 7
        dec edi | mov B$edi ah

        add al '0'
        On al > '9', add al 7
        dec edi | mov B$edi al

        dec ecx | jnz L0<

    pop edi
ret
____________________________________________________________________________________________

; Special routine to output meaningful information for segment regs.
; The format is "ssss Base: bbbbbbbb Limit: llllllll"
;   esi: Address of Register
;   edi: Address of Base+Limit
; Output
;   edi: Ascii String

[SegInfo: 'xxxx Base: ' SegInfo.Base: 'xxxxxxxx Limit: ' SegInfo.Limit: 'xxxxxxxx' 0]

toSegHex:
    push edx
        mov ecx 2, dx W$esi
        mov esi edi
        mov edi SegInfo
        call IntToHex

        mov ecx 4, edx D$esi
        mov edi SegInfo.Base
        call IntToHex

        mov ecx 4, edx D$esi+4
        mov edi SegInfo.Limit
        call IntToHex
    pop edx
    mov edi SegInfo
ret
____________________________________________________________________________________________

Proc toBinary:
    Uses edx

        mov edi StringBufTail, B$edi 0

L0:     mov dl 1
        lodsb

L1:     mov ah '0'
        test al dl | jz L2>
        inc ah
L2:     dec edi | mov B$edi ah
        shl dl 1
        jnc L1<

        dec edi | mov B$edi ' '
        loop L0<
        inc edi
EndP
____________________________________________________________________________________________

Proc toSByte:
    Uses ebx, edx

        mov edi StringBufTail, B$edi 0, ebx 10

L0:     lodsb
        mov dl al
        test dl 0_80 | jz L1>
        neg al

L1:     mov ah 0
        div bl
        add ah '0'
        dec edi | mov B$edi ah
        cmp al 0 | jnz L1<

        test dl 0_80 | jz L2>
        dec edi | mov B$edi '-'

L2:     dec edi | mov B$edi ' '
        loop L0<

        inc edi
EndP

Proc toUByte:
    Uses ebx

        mov edi StringBufTail, B$edi 0, ebx 10

L0:     lodsb

L1:     mov ah 0
        div bl
        add ah '0'
        dec edi | mov B$edi ah
        cmp al 0 | jnz L1<

        dec edi | mov B$edi ' '
        loop L0<

        inc edi
EndP
____________________________________________________________________________________________

Proc toSWord:
    Uses ebx, edx

        mov edi StringBufTail, B$edi 0, ebx 10
        shr ecx 1

L0:     lodsw

        test B$esi-1 0_80 | jz L4>
        neg ax

L4:     movzx eax ax
L1:     mov edx 0
        div ebx
        add dl '0'
        dec edi | mov B$edi dl
        cmp eax 0 | jnz L1<

        test B$esi-1 0_80 | jz L2>
        dec edi | mov B$edi '-'

L2:     dec edi | mov B$edi ' '
        loop L0<

        inc edi
EndP

Proc toUWord:
    Uses ebx, edx

        mov edi StringBufTail, B$edi 0, ebx 10
        shr ecx 1

L0:     lodsw
        movzx eax ax

L1:     mov edx 0
        div ebx
        add dl '0'
        dec edi | mov B$edi dl
        cmp eax 0 | jnz L1<

        dec edi | mov B$edi ' '
        loop L0<

        inc edi
EndP
____________________________________________________________________________________________

Proc toSDword:
    Uses ebx, edx

        mov edi StringBufTail, B$edi 0, ebx 10
        shr ecx 2

L0:     lodsd

        test B$esi-1 0_80 | jz L1>
        neg eax

L1:     mov edx 0
        div ebx
        add dl '0'
        dec edi | mov B$edi dl
        cmp eax 0 | jnz L1<

        test B$esi-1 0_80 | jz L2>
        dec edi | mov B$edi '-'

L2:     dec edi | mov B$edi ' '
        loop L0<

        inc edi
EndP

Proc toUDword:
    Uses ebx, edx

        mov edi StringBufTail, B$edi 0, ebx 10
        shr ecx 2

L0:     lodsd

L1:     mov edx 0
        div ebx
        add dl '0'
        dec edi | mov B$edi dl
        cmp eax 0 | jnz L1<

        dec edi | mov B$edi ' '
        loop L0<

        inc edi
EndP
____________________________________________________________________________________________

Proc toFloat:
    Uses edx

        shr ecx 2 | dec ecx
        mov B$StringBuf 0, edx ecx

L0:     fld D$esi+edx*4 | fstp T$FloatBuf
        mov edi StringBuf, al 0, ecx 255
        repne scasb
        mov B$edi-1 ' '
        call FloatToUString FloatBuf edi

        dec edx | jns L0<

        mov edi StringBuf | inc edi
EndP

Proc toDouble:
    Uses edx

        shr ecx 3 | dec ecx
        mov B$StringBuf 0, edx ecx

L0:     fld Q$esi+edx*8 | fstp T$FloatBuf
        mov edi StringBuf, al 0, ecx 255
        repne scasb
        mov B$edi-1 ' '
        call FloatToUString FloatBuf edi

        dec edx | jns L0<

        mov edi StringBuf | inc edi
EndP

toExtended:
    mov edi StringBuf
    call FloatToUString esi edi
ret

[StringBuf: B$ ? #255 StringBufTail: B$ ?]
[FloatBuf: T$ ?]
____________________________________________________________________________________________

toHexWithAnsi:
    push esi, ecx
L0:     lodsb
        mov ah al | and ah 0F | shr al 4
        add al '0'
        On al > '9', add al 7
        mov B$edi al | inc edi
        add ah '0'
        On ah > '9', add ah 7
        mov B$edi ah | inc edi
        mov B$edi ' ' | inc edi
        loop L0<
        mov al '"' | stosb
    pop ecx, esi
L0: lodsb
    If al < ' '
        mov al '.'
    ElseIf al = '&'
        stosb
    EndIf
    stosb
    loop L0<
    mov al '"' | stosb
    mov B$edi 0
ret
____________________________________________________________________________________________

[InversedLowSigns: B$ '.|| ..^/*-+.)(:$.][][,}.{##."...']

toHexWithCookedAnsi:
    push esi, ecx
L0:     lodsb
        mov ah al | and ah 0F | shr al 4
        add al '0'
        On al > '9', add al 7
        mov B$edi al | inc edi
        add ah '0'
        On ah > '9', add ah 7
        mov B$edi ah | inc edi
        mov B$edi ' ' | inc edi
        loop L0<
        mov al '"' | stosb
    pop ecx, esi

    xor eax eax

L0: lodsb
    On al < ' ', mov al B$InversedLowSigns+eax
    and al 07F
    stosb
    On al = '&', stosb
    loop L0<

    mov al '"' | stosb
    mov B$edi 0
ret

____________________________________________________________________________________________

toHexDwords:
    mov edx ecx
L1:     mov ecx 4
L0:         lodsb
            mov ah al | and ah 0F | shr al 4
            add ah '0'
            On ah > '9', add ah 7
            mov B$edi+ecx*2-1 ah
            add al '0'
            On al > '9', add al 7
            mov B$edi+ecx*2-2 al
        loop L0<
        mov B$edi+8 ' '
        add edi 9
        sub edx 4
    jnz L1<
    mov B$edi-1 0
ret
____________________________________________________________________________________________

toHexWords:
    mov edx ecx
L1:     mov ecx 2
L0:         lodsb
            mov ah al | and ah 0F | shr al 4
            add ah '0'
            On ah > '9', add ah 7
            mov B$edi+ecx*2-1 ah
            add al '0'
            On al > '9', add al 7
            mov B$edi+ecx*2-2 al
        loop L0<
        mov B$edi+4 ' '
        add edi 5
        sub edx 2
    jnz L1<
    mov B$edi-1 0
ret
____________________________________________________________________________________________

Proc toFloats:
    Uses edx

        shr ecx 2
        mov edx ecx
        mov ecx 0-1

        While edx > 0
            fld D$esi | fstp T$FloatBuf
            call FloatToUString FloatBuf edi
            add esi 4
            mov al 0, ecx 255
            repne scasb
            mov B$edi-1 ' '
            dec edx
        EndWhile
        mov B$edi-1 0
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

DebuggerMOUSEHINT: ; Show a tooltip(-like) window.
____________________________________________________________________________________________
____________________________________________________________________________________________

; Show a hint when the user holds the mouse over a datalabel in the source-editor

;[DataHintWinHandle: ? DataHintVisible: ? DataHintTimer: ?]

[MouseHintTimer:    ?
 MouseHintVisible:  ?]

InitMouseOverDataHints:
;;
    call 'User32.CreateWindowExA' 0, StaticClassName, 0, &WS_POPUP+&SS_LEFT,
        &CW_USEDEFAULT, &CW_USEDEFAULT, 250, D$FontHeight,
        D$hwnd, 0, D$hInstance, 0

    mov D$DataHintWinHandle eax, D$DataHintVisible 0
    
    SendMessage D$DataHintWinHandle, &WM_SETFONT, D$DebugFontHandle, &TRUE
;;
    call CreateNewForm_MouseHint
    call 'USER32.SetTimer' 0, 2, 1000, MouseOverDataHint
    mov D$MouseHintTimer eax
ret

DeleteMouseOverDataHints:
    call 'USER32.KillTimer' 0, D$MouseHintTimer
    mov D$MouseHintTimer 0
    call 'USER32.DestroyWindow' D$MouseHintFormHandle
    mov D$MouseHintFormHandle 0
ret

Proc MouseOverDataHint:
    Arguments @Handle, @Msg, @id, @Time
    Local @Column, @Row, @Size, @Address
    Uses ebx, esi, edi

    On D$IsDebugging = 0, jmp @Invalid

  ; Check if mouse is inside client space
    call 'USER32.GetCursorPos' Point
    call 'USER32.ScreenToClient' D$hwnd, Point
    mov eax D$PointX
    cmp eax D$RECTleft  | jl @Invalid
    cmp eax D$RECTright | jg @Invalid
    mov edx D$PointY
    cmp edx D$RECTtop    | jl @Invalid
    cmp edx D$RECTbottom | jg @Invalid

    On D$ToolbarWanted = 1, sub edx D$ToolBarPixelsHight

    move W$MousePosX ax, W$MousePosY dx

    call SimpleMouseTextPos

    mov D@Column eax, D@Row ebx
    push D$CaretRow
        call SearchTxtPtr
    pop D$CaretRow
    mov esi eax, ecx 0-1

    call MouseHint@ScanForSeparator
    On eax = 0-1, jmp @Invalid
    Do
        call MouseHint@LookupEquates
    Loop_Until ebx = 0
    call MouseHint@Evaluate
    On eax = 0, jmp @Invalid

    call RowToX D@Column | mov D$PointX eax
    call LineToY D@Row   | add eax D$FontHeight
    On B$ToolbarWanted = 1, add eax D$ToolBarPixelsHight
    mov D$PointY eax
    call 'USER32.ClientToScreen' D$hwnd, Point

    call 'USER32.InvalidateRect' D$MouseHintFormHandle, 0, 1
    call 'USER32.SetWindowPos' D$MouseHintFormHandle, 0, D$PointX, D$PointY, 0, 0, &SWP_NOSIZE+&SWP_SHOWWINDOW+&SWP_NOACTIVATE+&SWP_NOZORDER

    mov D$MouseHintVisible 1
    ExitP

@Invalid:
    If D$MouseHintVisible = 1
        call 'USER32.SetWindowPos' D$MouseHintFormHandle, 0, 0, 0, 0, 0, &SWP_HIDEWINDOW+&SWP_NOMOVE+&SWP_NOSIZE+&SWP_NOACTIVATE+&SWP_NOZORDER
        mov D$MouseHintVisible 0
    EndIf
EndP

____________________________________________________________________________________________

[MouseHintFormHandle: ?]

; Tag Wizard Form "C:\projekte\RosAsm\Work\WizardFiles\WZRDForm0001.wwf"
CreateNewForm_MouseHint:
    call 'User32.RegisterClassExA' MouseHintFormClass
    imul eax D$FontHeight 4
    call 'User32.CreateWindowExA',
        &WS_EX_LEFT+&WS_EX_LTRREADING+&WS_EX_RIGHTSCROLLBAR,
        MouseHintFormClassName,
        0,
        &WS_BORDER+&WS_OVERLAPPED+&WS_POPUP,
        0, 0, 160, eax,
        D$hwnd,
        0,
        D$hInstance,
        0
    mov D$MouseHintFormHandle eax
    call 'User32.SendMessageA' D$MouseHintFormHandle, &WM_SETFONT, D$DebugFontHandle, &TRUE
ret
____________________________________________________________________________________________
[MouseHintFormClass:
 @cbSize:        D$ len
 @style:         D$ 0
 @lpfnWndProc:   D$ MouseHintFormProc
 @cbClsExtra:    D$ 0
 @cbWndExtra:    D$ 0
 @hInstance:     D$ 0
 @hIcon:         D$ 0
 @hCursor:       D$ 0
 @hbrBackground: D$ 1
 @lpszMenuName:  D$ 0
 @lpszClassName: D$ MouseHintFormClassName
 @hIconSm:       D$ 0]
[MouseHintFormClassName: B$ "MouseHintForm" 0]
____________________________________________________________________________________________

[MH_Rect: D$ ? #4]

Proc MouseHintFormProc:
    Arguments @handle @Message @wParam @lParam
    Local @Brush
    Structure @PaintStruct 64 @hdc 0
    Uses esi, edi, ebx

    .If D@Message = &WM_CREATE
        mov eax 0

    .Else_If D@Message = &WM_CLOSE
        call 'USER32.DestroyWindow' D@handle

    .Else_If D@Message = &WM_DESTROY
        mov eax 0

    .Else_If D@Message = &WM_PAINT
        If D$IsDebugging = 1
            call 'User32.BeginPaint' D@handle, D@PaintStruct
            call 'GDI32.SelectObject' D@hdc, D$DebugFontHandle
            call MouseHintDrawWindow D@handle, D@hdc
            call 'User32.EndPaint' D@handle D@PaintStruct
        EndIf
        mov eax 0

    .Else
        call 'User32.DefWindowProcA' D@handle D@Message D@wParam D@lParam
    .End_If

EndP
; Tag End
____________________________________________________________________________________________


Proc MouseHintDrawWindow:
    Arguments @handle @hdc
    Local @Brush
    Structure @Rect 16 @left 0 @top 4 @right 8 @bottom 12

    [@Line1: B$ ? #16
     @Line2: B$ ? #16
     @Line3: B$ ? #16]

    call 'USER32.GetClientRect' D@handle, D@Rect
    move D@bottom D$FontHeight

    call 'GDI32.CreateSolidBrush' 0_FF_FF_FF | mov D@Brush eax
    call 'USER32.FillRect' D@hdc, D@Rect, D@Brush
    call 'GDI32.DeleteObject' D@Brush

    call 'GDI32.SetBkColor' D@hdc, 0_FF_FF_FF

    call 'GDI32.SetTextColor' D@hdc, 0_33_33_33

  ; Output size
    mov edi ItemString
    mov al ' ' | stosb
    mov al B$MouseHint@SizeMarker
    If al = 'D'
        stosb | mov eax 'WORD' | stosd
    ElseIf al = 'W'
        mov eax 'WORD' | stosd
    ElseIf al = 'B'
        mov eax 'BYTE' | stosd
    ElseIf al = 'F'
        stosb | mov eax 'LOAT' | stosd
    ElseIf al = 'R'
        mov eax 'REAL' | stosd
    ElseIf al = 'T'
        mov eax 'EXTE' | stosd
        mov eax 'NDED' | stosd
    EndIf
    mov B$edi 0

    call 'USER32.DrawTextA' D@hdc, ItemString, 0-1, D@Rect,
                            &DT_SINGLELINE+&DT_LEFT+&DT_VCENTER

  ; Output address
    mov edi ItemString
    DwordToHex D$MouseHint@Address
    mov al ' ' | stosb
    mov B$edi 0

    call 'USER32.DrawTextA' D@hdc, ItemString, 0-1, D@Rect,
                            &DT_SINGLELINE+&DT_RIGHT+&DT_VCENTER

  ; Draw background for values
    mov eax D$FontHeight
    lea edx D$eax*4
    move D@Top eax, D@Bottom edx

    call 'GDI32.CreateSolidBrush' 0_DD_EE_EE | mov D@Brush eax
    call 'USER32.FillRect' D@hdc, D@Rect, D@Brush
    call 'GDI32.DeleteObject' D@Brush
    call 'GDI32.SetBkColor' D@hdc, 0_DD_EE_EE

  ; Read a block of memory with a max size of 64 byte
    call IsProcessMemory D$MouseHint@Address
    On eax = 0, jmp @Invalid
    mov ebx 64
    On eax < ebx, mov ebx eax
    call ReadProcessMem D$MouseHint@Address, DataBuffer, ebx

  ; Output value based on size selector (D$ / W$ / ...)
    mov al B$MouseHint@SizeMarker
    mov B@Line1 0, B@Line2 0, B@Line3 0
    .If al = 'D'
L0:     On ebx < 4, jmp @Invalid
        mov edi @Line1
        DwordToHex D$DataBuffer
        mov B$edi 0

        mov esi DataBuffer, ecx 4
        call toUDword
        mov esi edi, edi @Line2
        Do | movsb | LoopUntil B$esi-1 = 0

        mov esi DataBuffer, ecx 4
        call toSDword
        mov esi edi, edi @Line3
        Do | movsb | LoopUntil B$esi-1 = 0
    .ElseIf al = 'W'
        ; Word Size
        On ebx < 2, jmp @Invalid
        mov edi @Line1
        WordToHex W$DataBuffer
        mov B$edi 0

        mov esi DataBuffer, ecx 2
        call toUword
        mov esi edi, edi @Line2
        Do | movsb | LoopUntil B$esi-1 = 0

        mov esi DataBuffer, ecx 2
        call toSword
        mov esi edi, edi @Line3
        Do | movsb | LoopUntil B$esi-1 = 0

    .ElseIf al = 'B'
        ; Byte size
        mov edi @Line1
        ByteToHex B$DataBuffer
        mov B$edi 0

        mov esi DataBuffer, ecx 1
        call toUByte
        mov esi edi, edi @Line2
        Do | movsb | LoopUntil B$esi-1 = 0

        mov esi DataBuffer, ecx 1
        call toSByte
        mov esi edi, edi @Line3
        Do | movsb | LoopUntil B$esi-1 = 0

    .ElseIf al = 'F'
        On ebx < 4, jmp @Invalid
        mov edi @Line2
        fld F$DataBuffer | fstp T$FloatBuf
        call FloatToUString FloatBuf edi
        mov al 0, ecx 0-1 | repne scasb
    .ElseIf al = 'R'
        On ebx < 8, jmp @Invalid
        mov edi @Line2
        fld R$DataBuffer | fstp T$FloatBuf
        call FloatToUString FloatBuf edi
        mov al 0, ecx 0-1 | repne scasb
    .ElseIf al = 'T'
        On ebx < 10, jmp @Invalid
        mov edi @Line2
        call FloatToUString DataBuffer edi
        mov al 0, ecx 0-1 | repne scasb
    .EndIf

    mov eax D$FontHeight
    lea eax D$eax*2
    mov D@bottom eax
    call 'USER32.DrawTextA' D@hdc, @Line1, 0-1, D@Rect,
                            &DT_SINGLELINE+&DT_CENTER+&DT_VCENTER

    mov eax D$FontHeight
    add D@top eax
    add D@bottom eax
    call 'USER32.DrawTextA' D@hdc, @Line2, 0-1, D@Rect,
                            &DT_SINGLELINE+&DT_CENTER+&DT_VCENTER

    mov eax D$FontHeight
    add D@top eax
    add D@bottom eax
    call 'USER32.DrawTextA' D@hdc, @Line3, 0-1, D@Rect,
                            &DT_SINGLELINE+&DT_CENTER+&DT_VCENTER
    ExitP

@Invalid:
    mov eax D$FontHeight
    lea edx D$eax*4
    move D@Top eax, D@Bottom edx
    mov eax {'Invalid address' 0}

    call 'USER32.DrawTextA' D@hdc, eax, 0-1, D@Rect,
                            &DT_SINGLELINE+&DT_CENTER+&DT_VCENTER
EndP
____________________________________________________________________________________________

MouseHint:
____________________________________________________________________________________________

; Get address of data symbol
; Input  :  esi -> name, ecx = len
; Output :  eax = value, edx = valid(1) invalid(0)

@EvaluateDataSymbol:

  ; Search address of data label (reuse information already stored in the label combo)
    mov edx 0
    On D$DataLabelComboHandle = 0, ret
    mov bl B$esi+ecx, B$esi+ecx 0 ; find routine requires zero terminated string!
    push ecx
        SendMessage D$DataLabelComboHandle, &CB_FINDSTRINGEXACT, ecx, esi
    pop ecx
    mov B$esi+ecx bl
    mov edx 0
    On eax = &CB_ERR, ret
    SendMessage D$DataLabelComboHandle, &CB_GETITEMDATA, eax, 0
    mov edx 1
ret
____________________________________________________________________________________________

; Translate number representations
; Input  :  esi -> name, ecx = len
; Output :  eax = value, edx = valid(1) invalid(0)

@EvaluateNumber:
    mov edx 0
    On B$esi < '0', ret
    On B$esi > '9', ret

    push esi ecx
        If W$esi = '00'
            call TranslateBinary
        ElseIf B$esi = '0'
            call TranslateHexa
        Else
            call TranslateDecimal
        EndIf
    pop ecx esi

    mov edx 1
ret
____________________________________________________________________________________________

; Get value of register
; Input  :  esi -> name, ecx = len
; Output :  eax = value, edx = valid(1) invalid(0)

@EvaluateRegister:
    mov edx 0
    On B$esi <> 'E', ret
    On ecx <> 3, ret

    mov eax D$esi
    and eax 0FF_FFFF
    mov edi GPRegs
    mov ecx 0

    While ecx < 8
        If D$GPRegs+ecx*4 = eax
            mov eax D$GPRRegMap+ecx*4
            mov eax D$eax
            mov edx 1
            ret
        EndIf
        inc ecx
    EndWhile

    mov edx 0
ret

@EvaluateSegmentSelector:
    mov edx 0
    On ecx <> 2, ret
    On B$esi+1 <> 'S', ret

    mov edx 1
    mov al B$esi
    cmp al 'F' | jne L0>
        mov eax D$FS.Linear | ret
L0: cmp al 'D' | jne L0>
        mov eax D$DS.Linear | ret
L0: cmp al 'C' | jne L0>
        mov eax D$CS.Linear | ret
L0: cmp al 'E' | jne L0>
        mov eax D$ES.Linear | ret
L0: cmp al 'G' | jne L0>
        mov eax D$GS.Linear | ret
L0: cmp al 'S' | jne L0>
        mov eax D$SS.Linear | ret

L0: mov edx 0 ; invalid seg reg
ret
____________________________________________________________________________________________

; Get value of string token
; Input  :  esi -> name, ecx = len
; Output :  eax = value, edx = success (1) failed (0)

Proc @EvaluateToken:
    Uses esi, edi, ebx, ecx

    call @EvaluateRegister
    On edx = 1, ExitP
    call @EvaluateNumber
    On edx = 1, ExitP
    call @EvaluateDataSymbol
    On edx = 1, ExitP
EndP
____________________________________________________________________________________________

; Output :  eax = address

[@Address: ?]

Proc @Evaluate:

    mov esi @Buffer
    mov D@Address 0
    mov ebx 0
    mov dl addSign ; last operator
    mov ecx 0-1

    .Do
        inc ecx
        .If B$esi+ecx < ' '
          ; operator precedence of '*' e.g. D$eax+ecx*4 -> @Address=eax, ebx=ecx
            If B$esi+ecx = mulSign
                add D@Address ebx
                mov ebx 0
            EndIf

          ; get value of token -> eax. Break up if the token is unknown (e.g. local symbols)
            push edx
                call @EvaluateToken
                If edx = 0
                    mov eax 0
                    ExitP
                EndIf
            pop edx

          ; address arithmetic
            If dl = addSign
                add ebx eax
            ElseIf dl = subSign
                sub ebx eax
            ElseIf dl = mulSign
                imul ebx eax
            EndIf

          ; save operator
            mov dl B$esi+ecx
            add esi ecx
            inc esi
            mov ecx 0-1
        .ElseIf B$esi+ecx = ':'
          ; colon only after segment selector
            call @EvaluateSegmentSelector
            If edx = 0
                mov eax 0
                ExitP
            EndIf
            add ebx eax
            mov dl addSign ; segment base implies addition of the offset
            add esi ecx
            inc esi
            mov ecx 0-1
        .EndIf
    .Loop_Until B$esi+ecx = 0

    add D@Address ebx
    mov eax 1
EndP
____________________________________________________________________________________________

; Get value of equate
; Input  :  esi -> name, ecx = namelen, edx = size of destination buffer
; Output :  eax = valid(1) invalid(0)

Proc @ReplaceEquate:
    Uses esi, ecx

  ; If naked local symbol, check if this belongs to the scope of the current code label.
    If B$esi = '@'
        push edi ecx
            mov edi LabelName
            push ecx
                mov ecx 0-1, al 0
                repne scasb
            pop ecx
            dec edi
            rep movsb
            mov B$edi 0
        pop ecx edi
        mov esi LabelName
    EndIf

    call GetFromQwordCheckSum esi, D$EquateList, D$EquateListLimit

    If eax <> 0
      ; Already copied name (len=ecx) is wiped off the buffer
        add edx ecx

      ; Skip equate name
        While B$eax > LowSigns
            inc eax
        End_While
        inc eax

      ; Store equate contents. First check if there's sufficient room to store it.
        mov esi D$eax, ecx D$eax+4
        sub edx ecx | js L8>
        rep movsb

        mov eax 1
    Else
L8:     mov eax 0
    End_If
EndP
____________________________________________________________________________________________

; Copy the cooked buffer and replace equates by its values. This must be done until no more
; equates are found in the expression (in case of nested equates).

Proc @LookupEquates:

  ; HACK - get current label into labelname
    call IsProcessCode D$C.regEIP
    If eax = 1
        call ScanLabelListForCodeLabel D$C.regEIP, 0
    Else
        mov B$LabelName 0
    EndIf

  ; output buffer on stack
    sub esp 256
    mov edi esp
    mov edx 255

    mov ebx 0
    mov esi @Buffer
    mov ecx 0-1

    Do
        inc ecx
        dec edx | js L8>

        mov al B$esi+ecx
        mov B$edi+ecx al

        .If al < ' '
          ; substitute equate with value
            call @ReplaceEquate
            If eax = 1
                inc ebx
            Else
                add edi ecx
            EndIf

          ; restore operator (might have been overwritten, different len equate<->value)
            add esi ecx
            mov al B$esi | inc esi
            mov B$edi al | inc edi

            mov ecx 0-1
        .EndIf
    Loop_Until B$esi+ecx = 0

L8: mov ecx edi
    sub ecx esp

    mov esi esp
    mov edi @Buffer

    rep movsb

    mov B$@Buffer+255 0

    mov eax ebx ; number of replacements
EndP
____________________________________________________________________________________________

[@Buffer: B$ ? #256]

; Input
;   esi -> $ in expression
; Output
;   @Buffer contains cooked (uppercase with spaces stripped) expression

Proc @CopyAndCook:

  ; scan forward & copy
    mov edi @Buffer, edx 0

L3:   ; next char
        inc esi
        mov al B$esi
        On al = 167, mov al 36

L0:     cmp dl 1 | je L0>

      ; step over legal symbol chars: A..Z a..z 0..9 _ & : @
        cmp al '&' | je L4>
        cmp al '.' | je L4>
        cmp al '0' | jb L0>
        cmp al ':' | jbe L4> ; '0'..'9', ':'
        cmp al '@' | jb L0>
        cmp al 'Z' | jbe L4> ; '@', 'A'..'Z'
        cmp al '_' | je L3<
        cmp al 'a' | jb L0>
        cmp al 'z' | jbe L2> ; 'a' .. 'z'

L0:   ; not a symbol char, check for 'connecting' chars ' ', '+', '-', '*'
        If al = '+'
            mov dl 0-1
            mov al addSign
            jmp L1>
        ElseIf al = '-'
            mov dl 0-1
            mov al subSign
            jmp L1>
        ElseIf al = '*'
            mov dl 0-1
            mov al mulSign
            jmp L1>
        ElseIf al = ' '
            On dl = 0, mov dl 1
            jmp L3<
        EndIf

      ; over
        jmp L9>

L2:   ; a..z -> A..Z
        sub al 020

L4:     mov dl 0

L1:   ; copy
        stosb

        cmp edi @Buffer+255 | je L9>

    jmp L3<


L9: mov B$edi 0
EndP
____________________________________________________________________________________________

; Input
;   esi -> Text Ptr
; Output
;   edi -> Start of string
;   ecx = Size of string
;   eax = Expression (1) | Data declaration (0) | Invalid (-1)

[@SizeMarker: B$ ?]

Proc @ScanForSeparator:

    mov al B$esi
    mov dl 0 ; expect separator=1 symbol=-1

  ; scan backward
    While al <> 36 ;B$ParagraphChar ; '$' ; Dollar
        On al = 167, jmp L7>>

        cmp dl 1 | je L0>

      ; step over legal symbol chars: A..Z a..z 0..9 _ & : @ .
        cmp al '&' | je L3>
        cmp al '.' | je L3>
        cmp al '0' | jb L0>
        cmp al ':' | jbe L3> ; '0'..'9', ':'
        cmp al '@' | jb L0>
        cmp al 'Z' | jbe L3> ; '@', 'A'..'Z'
        cmp al '_' | je L1>
        cmp al 'a' | jb L0>
        cmp al 'z' | jbe L3> ; 'a' .. 'z'

L0:   ; not a symbol char, check for 'connecting' chars ' ', '+', '-', '*'
        If al = '+'
            mov dl 0-1
            jmp L1>
        ElseIf al = '-'
            mov dl 0-1
            jmp L1>
        ElseIf al = '*'
            mov dl 0-1
            jmp L1>
        ElseIf al = ' '
            On dl = 0, mov dl 1
            jmp L1>
        EndIf

      ; not preceded by '$', check for naked local "D@Local"
L5:     inc esi
        cmp B$esi ' ' | je L5<

        cmp B$esi+1 '@' | jne L2>
        mov al B$esi
        mov B@SizeMarker al

        jmp L4>

L3:   ; symbol
        mov dl 0

L1:     dec esi
        mov al B$esi
    EndWhile

L7: mov al B$esi-1
    mov B@SizeMarker al

L4: call @CopyAndCook
    mov eax 1
    ExitP

L2: ; not preceded by '$', check for data declaration
    mov eax 0-1
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; Check if the specified buffer might be a string. It is rejected if it contains
; non-printable chars or is empty (starts with zero).
; Output in AH! [1 (yes) | 0 (no)]

Proc IsString:
    Arguments @Buffer, @Size
    Uses esi

    mov ah 0, esi D@Buffer, ecx D@Size
L0: While B$esi <> 0
        lodsb
        mov ah 1
        dec ecx | jz P9>
        cmp al ' ' | jb L9>
        cmp al 07F | jb L0<
        cmp al 080 | je L0<
        cmp al 091 | je L0<
        cmp al 092 | je L0<
        cmp al 0A0 | jb L9>
    EndWhile
    ExitP

L9: mov ah 0
EndP

____________________________________________________________________________________________

; This is a printf clone for internal use in RosAsm.

[FormatString | &9=0 | C_Call FormatStr #L>1]
[C_Call | &9=&9+4 | push #2 | #+1 | call #F | add esp &9]

; Formats a string
; The stack must be cleared by the caller - use FormatString macro!
; Invokation: call FormatStr PatternString OutputString [Linked parameters in order of occurence]
;
; Link  | Converted to            | Expected parameter
; ______|_________________________|____________________
; %s    | string                  | address of string
; %d    | decimal                 | dword immediate
; %x    | hex with leading 0's    | dword immediate

FormatStr:
    push ebp
    mov ebp esp

    push esi edi ebx edx ; rescue regs

    mov esi D$ebp+12 ; pattern string >> esi
    mov edi D$ebp+8 ; output buffer >> edi
    mov ebx 2 ; paramter count >> ebx

L0: lodsb
    .If al = '%'
        lodsb
        If al = 's'
            ; Copy string to buffer
            push esi
                mov esi D$ebp+8+ebx*4 | inc ebx
                cmp esi 0 | je L3>
                While B$esi <> 0 | movsb | EndWhile
        L3: pop esi
        ElseIf al = 'x'
            ; Convert to hex
            mov eax D$ebp+8+ebx*4 | inc ebx
            mov edx eax | add edi 7
            std
            mov ecx 8
L1:         mov al dl | and al 0F | cmp al 0A | jb L2>
            add al 7
L2:         add al '0' | stosb | shr edx 4 | loop L1<
            cld
            add edi 9
        ElseIf al = 'd'
            ; Convert integer to decimal representation
            mov eax D$ebp+8+ebx*4 | inc ebx
            call IntToStr
        Else
            stosb
        EndIf
    .Else
        stosb
    .EndIf
    cmp al 0 | jne L0<

    ; Return stringlength in ecx
    mov ecx edi
    sub ecx D$ebp+8
    dec ecx

    pop edx ebx edi esi ; restore regs

    pop ebp
ret
____________________________________________________________________________________________

; Outputs the time in format hh:mm:ss
;   parameter : edi -> string (8 chars must fit in)
;   returns   : edi -> string (terminating null-char)
;   uses      : eax, ecx, edx

TimeToStr:
    sub esp 16

        call 'KERNEL32.GetLocalTime' esp
        movzx eax W$esp+8
        mov edx 0, ecx 10 | div ecx
        add al '0'
        stosb
        add dl '0' | mov al dl
        stosb

        mov al ':' | stosb

        movzx eax W$esp+10
        mov edx 0, ecx 10 | div ecx
        add al '0'
        stosb
        add dl '0' | mov al dl
        stosb

        mov al ':' | stosb

        movzx eax W$esp+12
        mov edx 0, ecx 10 | div ecx
        add al '0'
        stosb
        add dl '0' | mov al dl
        stosb

        mov B$edi 0

    add esp 16
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

DebuggerSTRINGS: ; Text visible to the user is collected here.
____________________________________________________________________________________________
____________________________________________________________________________________________

[StrRun:            'Run' 0
 StrStepInto:       'Step Into' 0
 StrStepOver:       'Step Over' 0
 StrStep:           'Step' 0
 StrReturn:         'Return to Caller' 0
 StrRet:            'Return' 0
 StrTerminate:      'Terminate' 0
 StrPause:          'Pause' 0
 StrHoldOnBp:       'Hold on breakpoints' 0
 StrInstStep:       'Instruction level stepping' 0
 StrSrcStep:        'Source level stepping' 0
 StrShowAll:        'Show segment/debug registers' 0
 StrFont:           'Choose font ...' 0
 StrCPUInfo:        'CPU info' 0
 StrFPUStatus:      'FPU status' 0
 StrShowCodeAt:     'Show code at address ...' 0
 StrAbout:          'About Debugger' 0
 StrDbgHelp:        'Debugger Help' 0
 StrContinue:       'Continue' 0
 StrBreak:          'Break' 0
 StrSettings:       'Settings' 0
 StrInformation:    'Information' 0
 StrHelp:           'Help' 0]

[StrDataFmt:        'Data Representation:' 0]

[StrF1:             'F1' 0
 StrF6:             'F6' 0
 StrF7:             'F7' 0
 StrF8:             'F8' 0
 StrCtrlF7:         'Ctrl+F7' 0
 StrCtrlF6:         'Ctrl+F6' 0
 StrCtrlF12:        'Ctrl+F12' 0]

[FPUControlWord:    'Control Word: ' 0
 FPUTagWord:        'Tag Word: ' 0
 FPURoundingMode:   'Rounding Mode: ' 0
 FPUPrecision:      'Precision: ' 0
 FPUStatusWord:     'Status Word: ' 0
 FPURndNearest:     'Nearest or even' 0
 FPURndDown:        'Round down' 0
 FPURndUp:          'Round up' 0
 FPURndTrunc:       'Truncate' 0]

[DataView:          'Data' 0
 MemoryInspector:   'Memory' 0
 CallStack:         'Call Stack' 0
 Log:               'Log' 0
 AddressSpace:      'Address Space' 0]

[FmtHex:            'Hexadecimal' 0
 FmtUDec:           'Unsigned Decimal' 0
 FmtSDec:           'Signed Decimal' 0
 FmtBinary:         'Binary' 0
 FmtFloat:          'Floating Point' 0
 FmtPUB:            'Packed Unsigned Byte' 0
 FmtPSB:            'Packed Signed Byte' 0
 FmtPUW:            'Packed Unsigned Word' 0
 FmtPSW:            'Packed Signed Word' 0
 FmtPUD:            'Packed Unsigned Dword' 0
 FmtPSD:            'Packed Signed Dword' 0
 FmtPUQ:            'Packed Unsigned Qword' 0
 FmtPSQ:            'Packed Signed Qword' 0
 FmtPF:             'Packed Single Precision Float' 0
 FmtPD:             'Packed Double Precision Float' 0
 FmtHexAnsi:        'Hexadecimal / ANSI' 0
 FmtHexDW:          'Hexadecimal Dwords' 0
 FmtHexW:           'Hexadecimal Words' 0
 FmtFloats:         'Single Precision Floats' 0
 FmtDoubles:        'Double Precision Floats' 0
 FmtAscii:          'Ascii Characters' 0
 FmtHexCooked:      'Hexadecimal / Cooked Ascii (RosAsm Development)' 0]

[StrShowInMemInsp:  'Show in memory inspector' 0
 StrShowPInMemInsp: 'Show memory pointed at' 0
 StrShowDecl:       'Show declaration' 0
 StrBreakOnW:       'Break on write access' 0
 StrBreakOnRW:      'Break on read/write access' 0
 StrSortByName:     'Sort by name' 0
 StrSortByAddr:     'Sort by address' 0]

[StrShowInvoke:     'Show invocation' 0
 StrShowAllCalls:   'Show all calls' 0
 StrHideModCalls:   'Hide module calls' 0
 StrHideIMCalls:    'Hide intra-module calls' 0
 StrShowLocals:     'Show Local data' 0]

[ACCESS_VIOLATION: B$      "ACCESS VIOLATION [C0000005]
The thread tried to read from or write to a virtual address for which it does not have the appropriate access." 0
 ARRAY_BOUNDS_EXCEEDED:    "ARRAY BOUNDS EXCEEDED [C000008C]
The thread tried to access an array element that is out of bounds and the underlying hardware supports bounds checking." 0
 DATATYPE_MISALIGNMENT:    "DATATYPE_MISALIGNMENT [80000002]
The thread tried to read or write data that is misaligned on hardware that does not provide alignment. 
For example, 16-bit values must be aligned on 2-byte boundaries; 32-bit values on 4-byte boundaries, and so on." 0
 FLT_DENORMAL_OPERAND:     "FLT DENORMAL OPERAND [C000008D]
One of the operands in a floating-point operation is denormal. 
A denormal value is one that is too small to represent as a standard floating-point value." 0
 FLT_DIVIDE_BY_ZERO:       "FLT DIVIDE BY ZERO [C000008E]
The thread tried to divide a floating-point value by a floating-point divisor of zero." 0
 FLT_INEXACT_RESULT:       "FLT INEXACT RESULT [C000008F]
The result of a floating-point operation cannot be represented exactly as a decimal fraction." 0
 FLT_INVALID_OPERATION:    "FLT INVALID OPERATION [C0000090]" 0
 FLT_OVERFLOW:             "FLT OVERFLOW [C0000091]
The exponent of a floating-point operation is greater than the magnitude allowed by the corresponding type." 0
 FLT_STACK_CHECK:          "FLT STACK CHECK [C0000092]
The stack overflowed or underflowed as the result of a floating-point operation." 0
 FLT_UNDERFLOW:            "FLT UNDERFLOW [C0000093]
The exponent of a floating-point operation is less than the magnitude allowed by the corresponding type." 0
 ILLEGAL_INSTRUCTION:      "ILLEGAL INSTRUCTION [C000001D] 
The thread tried to execute an invalid instruction." 0
 IN_PAGE_ERROR:            "IN PAGE ERROR [C0000006]
The thread tried to access a page that was not present, and the system was unable to load the page.
For example, this exception might occur if a network connection is lost while running a program over the network." 0
 INT_DIVIDE_BY_ZERO:       "INT DIVIDE BY ZERO [C0000094]
The thread tried to divide an integer value by an integer divisor of zero." 0
 INT_OVERFLOW:             "INT OVERFLOW [C0000095]
The result of an integer operation caused a carry out of the most significant bit of the result." 0
 PRIV_INSTRUCTION:         "PRIVILIGED INSTRUCTION [C0000096]
The thread tried to execute an instruction whose operation is not allowed in the current machine mode." 0
 STACK_OVERFLOW:           "STACK OVERFLOW [C00000FD]
The thread used up its stack." 0
 INVALID_DISPOSITION:      "INVALID DISPOSITION [C0000026]
An exception handler returned an invalid disposition to the exception dispatcher." 0
 NONCONTINUABLE_EXCEPTION: "NONCONTINUABLE EXCEPTION [C0000025]
The thread tried to continue execution after a noncontinuable exception occurred." 0
 UNKNOWN_EXCEPTION: "xxxxxxxx 
Unknown exception." 0]

TITLE Debug

[DebuggerVersion: 'RosAsm Debugger V2.2b' 0]

;;
_____________________________________________________________________________________________

                             Debugger [Version 2.2b] - Ludwig Haehne
     
    * [Bugfix] Added security for degenerated call stack cases
    
  RosAsm 2.033b [Debugger V2.2a]
  
    * [Bugfix] FPU flags toolbar was not effective
  
  RosAsm 2.031a [Debugger V2.2]
                 
    * [Feature] Localized user interface
    * [Feature] Recognize stack-frames in Call stack set up by ENTER intruction
    * [Change] Ctrl+F shortcut for FPU info removed (conflict with search feature)
    * [Change] Terminate debuggee immediately when debugger window is closed
    * [Change] Do not inherit startup information to debuggee
    * [Bugfix] Preserve z-order and focus of debuggee's windows across debug events
    * [Bugfix] Minimize/Restore dialog messed up child-window sizes    
    * [Bugfix] Sourceposition was wrong when a breakpoint was set on a single-byte instruction
    * [Bugfix] Error checking for VirtualQuery

  RosAsm 2.027a [Debugger V2.1b]

    * [Bugfix] Menu did not work on Win95
    * [Bugfix] MMX register contents did not show properly on Win9x
    * [Bugfix] Occasional crash when mouse hints showed up behind other windows on Win98

  RosAsm 2.025e [Debugger V2.1a]
  
    * [Bugfix] Thread synch problems fixed when running multiple debugger instances
    * [Bugfix] Logfiles now have application specific names
                             
  RosAsm 2.025a [Debugger V2.1]
  
    * [Feature] Local symbol support for mouse hints and call stack
    * [Feature] New filter capabilities in call stack (context menu)
    * [Feature] Sort data labels by Address or Name (select in context menu)
    * [Feature] Toolbar
    * [Change] Flags moved into toolbar (can be hidden)
    * [Change] General code cleanup
    * [Bugfix] Rare "Invalid path" problem fixed
____________________________________________________________________________________________
          
 Known bugs:
 
    * Check for Invalid parameter counts in callstack computation (MyPNN)
 
    * Two byte breakpoints make the debuggee crash when HoldOnBreakPoints = 0
    * Terminate leaves process and thread handle open    
    * Stepping into int 02e seeds a 'breakpoint' at the return address (TrackPopupMenu)
    * Int 3 in Hook procedures (mouse hooks) hangs the Windows GUI
   
    *   "There is an issue about focus at debug time. "Sometimes" the debuger  set  the 
        focus to main debugee window.
        when the focus was at a second overlaped window (not the main nor a  sysmodal) i want 
        the focus to go back where it was, not to the owner  window. I have a rare efect 
        even without BPs at debug time" (from Marcelo)
        
        >> Find a way to not touch the z-order of the debuggee windows after run/step-over.
        
    * Close debug window when debuggee has message box open  (except.exe)
        -> wait -> "Debug thread does not respond" -> [Ok] 
        -> Unknown exception (C0000008) in CloseHandle called by DebugRsrcManager
        (exception does NOT crash RosAsm also it does not seem to have a SEH attached !?)

 Future ;)
 
    * Window message logger
    * Structured data memory inspector
    * Conditional breakpoints
    * Editable contents (register, memory)
    * Symbolic Profiler
____________________________________________________________________________________________
                          
 Maintainer since November 2003: Ludwig Haehne, wkx@gmx.li
 
 I have almost completely rewritten the existing debugger to introduce new features and 
 have a better UI.
 
 The debugger is now roughly divided into the following sections:
 
 Main Debug Routines
 
  * 'Debugger' is called when you click on [Run] and creates the 'DebugRsrcManagerThread'
  * 'KillDebugger' is called whenever you try to modify your sources
  
 Debugger polling Thread (handles debug events)
 
  * 'DebugThread', 'ShowProcessWindows', 'ScanStackForCodePointer', 'CloseProcess',
    'ReadProcessMem', 'WriteProcessMem', 'SignalDebugEvent', 'EncounterException'
  
 Breakpoint management
 
  * 'CreateBPTable', 'DestroyBPTable', 'AddProcessBreakpoint', 'DeleteProcessBreakpoint', 
    'DisableProcessBreakpoints', 'EnableProcessBreakpoints', 'EncounterBreakpoint', 
    'KillBreakpointGroup'
    
 Breakpoint synchronization with Source editor
  
  * 'CreateBPAnteroom', 'DestroyBPAnteroom', 'InitialFillBPAnteroom', 'AddBPToAnteroom',
    'ClearBPAnteroom'

 Address Space Routines
 
  * 'VirtualQuery', 'IsProcessMemory', 'IsProcessCode', 'FindNextPage', 'FindPrevPage'
  
 Call stack routines
  
  * 'GenerateCallStack', 'DestroyCallStack', 'ReadApplicationStack', 'IsReturnAddress',
    'IsReturnAddressInSource', 'GetCodeLabelFromAddress', 'GetNearestProc', 'CountParametersAndScanStackFrame'
    
 Module management
 
  * 'IsModuleCode'
_____________________________________________________________________________________________

;;

[DEBUG_EVENT:
 DE.dwDebugEventCode: D$ ?
 DE.dwProcessId: D$ ?
 DE.dwThreadId: D$ ?
 DE.u:
    CPDI.hFile:         CTDI.hThread:           E.ExceptionCode:    ODS.DebugString:  LOADDLL.hFile:    UNLOADDLL.Base: D$ ?
    CPDI.hProcess:      CTDI.lpThreadLocalBase: E.ExceptionFlags:   ODS.Unicode:      LOADDLL.Base:     W$ ?
                                                                    ODS.StringLen:    W$ ?
    CPDI.hThread:       CTDI.lpStartAddress:    E.ExceptionRecord:                    LOADDLL.DIOffset: D$ ?
    CPDI.lpBaseOfImage:                         E.ExceptionAddress:                   LOADDLL.DISize:   D$ ?
                                                E.NumParams:                          LOADDLL.Name:     D$ ?
                                                E.ExceptionInfo:                      LOADDLL.Unicode:  D$ ?
                                                                                      D$ ?
    CPDI.lpStartAddress:                                                              D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                                                      D$ ?
                                                E.FirstChance:                        D$ ?]

[DamnedUnionTail: ? #100]


____________________________________________________________________________________________

[CONTEXT:
 C.ContextFlags: D$ ?
 C.iDr0: D$ ?
 C.iDr1: D$ ?
 C.iDr2: D$ ?
 C.iDr3: D$ ?
 C.iDr6: D$ ?
 C.iDr7: D$ ?
 C.FloatSave.ControlWord: D$ ?
 C.FloatSave.StatusWord: D$ ?
 C.FloatSave.TagWord: D$ ?
 C.FloatSave.ErrorOffset: D$ ?
 C.FloatSave.ErrorSelector: D$ ?
 C.FloatSave.DataOffset: D$ ?
 C.FloatSave.DataSelector: D$ ?]
[C.FloatSave.RegisterArea: B$ ? #&SIZE_OF_80387_REGISTERS]
[C.FloatSave.Cr0NpxState: D$ ?
 C.regGs: D$ ?
 C.regFs: D$ ?
 C.regEs: D$ ?
 C.regDs: D$ ?
 C.regEdi: D$ ?
 C.regEsi: D$ ?
 C.regEbx: D$ ?
 C.regEdx: D$ ?
 C.regEcx: D$ ?
 C.regEax: D$ ?
 C.regEbp: D$ ?
 C.regEip: D$ ?
 C.regCs: D$ ?
 C.regFlag: D$ ?
 C.regEsp: D$ ?
 C.regSs: D$ ?]
[C.ExtendedRegisters: B$ ? #32
 C.regMM: B$ ? #128
 C.regXMM: B$ ? #128
 C.UnknownExtendedRegs: B$ ? #224
 EndOfContext: ?]

[ContextSize (EndOfContext-Context)]
____________________________________________________________________________________________

; All user-visible messages are stored here for easier proof-reading / localization.


[ErrorOutside:
"An exception occurred outside the Application. 

This may be due to wrong parameters in an api call or a buggy library.

The debugger highlights the last call of your application before the 
exception has occurred. Verify that the parameters are correctly set.

If the debugger points to the end of the source, either the caller 
couldn't be  identified or the exception occurred after the application 
has terminated. In the latter  case, just test if your application runs 
flawlessly without the debugger.", 0

ErrorOutsideTitle: 'External Error' 0]

[AboutDebugger:
"RosAsm's integrated Win32 debugger.

For bug reports / feature requests use 
RosAsm board or contact me via e-mail. 

Good luck! 

Ludwig Hähne <wkx@gmx.li>" 0]

[DebugThreadHangs:
"The debugger thread does not respond. 
This should not happen! The thread is now terminated!" 0]

[CriticalError: "Critical error" 0]

[MessageKillDebugger:
"You cannot modify the Source in a Debug Session    
    
                     Close the Debugger?" 0]

[DebuggerRunning: "Debugger running ..." 0]
____________________________________________________________________________________________

________________________________________________________________________________________

[Smode: '/S', 0]      ; To run Screen Savers in Saver Mode from the [Run] Button.

[UserHitF9: ?]
____________________________________________________________________________________________

[MY_CONTEXT_FULL &CONTEXT_FULL__&CONTEXT_FLOATING_POINT__&CONTEXT_DEBUG_REGISTERS__&CONTEXT_EXTENDED_REGISTERS]

; Main Routine of the Debugger.

[IsDebugging: &FALSE  Compiling: &FALSE]


[DebugRsrcManagerThreadId: ?]

Proc Debugger:
    On D$IsDebugging = &TRUE, ExitP

    call TestCPUFeatures

    ; Get OS version information - The main difference between Win9x / WinNT
    ; concerning the debugger is the address space layout.
    mov D$OSVersionInfo.Size OSVI_SIZE
    call 'Kernel32.GetVersionExA' OsVersionInfo
    If D$OsVersionInfo.PlatformId = &VER_PLATFORM_WIN32_WINDOWS
        mov D$AddressLowerBound 0
        mov D$AddressUpperBound 0_BFFF_FFFF
    EndIf

    ; Create the debug dialog that displays registers, labels and memory.
    call CreateDebugWindow

    call 'Kernel32.CreateThread' &NULL, 0, DebugRsrcManagerThread, 0,
                                 &THREAD_PRIORITY_NORMAL, DebugRsrcManagerThreadId
    If eax = &NULL
        call ReportWinError {'Debugger: CreateThread (Resource Manager)' 0}
    Else
        ; we don't need the thread handle
        call 'Kernel32.CloseHandle' eax
    EndIf
EndP
____________________________________________________________________________________________

;;
  User attempts to modify the Source in a Debug Session. 
  Impossible > offer him to either close the Debug Session or to abort the Source Edition
;;

KillDebugger:
    call 'USER32.MessageBoxA', D$hwnd, MessageKillDebugger, DebuggerRunning,
        &MB_SYSTEMMODAL__&MB_YESNO

    push eax
        On eax = &IDYES,
            call 'USER32.SendMessageA', D$DebugDialogHandle, &WM_CLOSE, 0, 0
    pop eax
ret
____________________________________________________________________________________________

; Debugger resource manager thread. This thread takes care of initializing and freeing
; all resources (objects, files, memory). It is separated from the polling
; thread to cleanup properly even if the thread hangs (for whatever reason) and must be
; terminated; which (very rarely) caused deadlocks with the past solution.

[DebugThreadHandle: ? DebugThreadId: ?] ; the polling thread
[UserInputEvent: ?] ; synch dialog with polling thread
[ThreadIDHandleTable: ? NumThreads: ?] ; maps thread id's to handles

[PROCESS_INFORMATION: ; the debuggee's process and (main) thread handle & id
 PI.hProcess: ?
 PI.hThread: ?
 PI.dwProcessId: ?
 PI.dwThreadId: ?]

[STARTUPINFO: SI_cb: ?              SI_lpReserved: ?       SI_lpDesktop: ?
              SI_lpTitle: ?         SI_dwX: ?              SI_dwY: ?
              SI_dwXSize: ?         SI_dwYSize: ?          SI_dwXCountChars: ?
              SI_dwYCountChars: ?   SI_dwFillAttribute: ?  SI_dwFlags: ?
              SI_wShowWindow: W$ ?  SI_cbReserved2: W$ ?   SI_lpReserved2: D$ ?
              SI_hStdInput: ?       SI_hStdOutput: ?       SI_hStdError: ?]

DebugRsrcManagerThread:

  ; Create an autoreset event to synchronize the debug dialog with the debugthread.
    call 'Kernel32.CreateEventA' 0, 0, 0, 0
    If eax = &NULL
        call ReportWinError {'Debugger: CreateEvent' 0}
        jmp @Exit
    EndIf
    mov D$UserInputEvent eax

    call CreateBPTable

  ; Create a lookup table to retrieve thread handles. The reason we need this is that
  ; we get a thread handle only with the Create-Thread-Debug-Event. For exception handling
  ; only the thread ID is provided, so the handle and the corresponding ID must be saved.
    VirtualAlloc ThreadIDHandleTable 4096
    mov D$NumThreads 0

    call 'KERNEL32.HeapCreate' 0, 4096, 0 ; Create a growable heap.
    mov D$ModuleNameHeap eax

    VirtualAlloc ModuleList 4096
    mov D$NumModules 0

  ; Create the thread that creates and observes the debuggee.
    call 'Kernel32.CreateThread' &NULL, 0, DebugThread, 0,
                                &THREAD_PRIORITY_NORMAL+&CREATE_SUSPENDED, DebugThreadId
    If eax = &NULL
        call ReportWinError {'Debugger: CreateThread' 0}
        ExitP
    EndIf
    mov D$DebugThreadHandle eax

  ; Create synchronization table (like a printer-spool) for dynamic breakpoints.
    call CreateBPAnteroom
    call InitialFillBPAnteroom

    call InitWatchpointResources

  ; Resume (start) the thread. The thread is created suspended to be sure that the
  ; handle is set correctly.
    call 'Kernel32.ResumeThread' D$DebugThreadHandle

  ; Enter debug event polling
    call 'KERNEL32.WaitForSingleObject' D$DebugThreadHandle, &INFINITE

  ; Now the polling thread is dead- either the debuggee has terminated or the thread
  ; was killed. Clean up.

    call FreeWatchpointResources

    call DestroyBPAnteroom

    call 'Kernel32.CloseHandle' D$DebugThreadHandle
    mov D$DebugThreadHandle 0

  ; Cleanup
    VirtualFree D$ModuleList

    call 'KERNEL32.HeapDestroy' D$ModuleNameHeap
    VirtualFree D$ThreadIDHandleTable

    call 'Kernel32.CloseHandle' D$PI.hThread
    call 'Kernel32.CloseHandle' D$PI.hProcess

    call DestroyBPTable

  ; we post a close signal no matter if the dialog still exists or not
    call 'User32.PostMessageA' D$DebugDialogHandle, &WM_CLOSE, &NULL, &NULL

    call 'Kernel32.CloseHandle' D$UserInputEvent
    mov D$UserInputEvent 0

  ; If the debuggee has called 'Kernel32.OutputDebugString' there is a file in which the
  ; output has been logged. Close the file now.
    If D$DebugLogFile <> 0
        call 'KERNEL32.CloseHandle' D$DebugLogFile
        mov D$DebugLogFile 0
    EndIf

  ; Clear data structures (safety)
    mov ecx EndOfContext | sub ecx Context | shr ecx 2
    mov edi Context, eax 0
    rep stosd

@Exit:
    call 'Kernel32.ExitThread' 0
ret
____________________________________________________________________________________________

[FilterEXE: B$ 'Executables (*.exe)' 0 '*.exe' 0 0]
[HostAppFileName: B$ ? #&MAX_PATH]
[HostAppTitle: B$ 'Host application ...' 0]

[SelectHostAppDialog:
 HostApp.lStructSize: D$ len
 HostApp.hwndOwner: D$ 0
 HostApp.hInstance: D$ 0
 HostApp.lpstrFilter: D$ FilterEXE
 HostApp.lpstrCustomFilter: D$ 0
 HostApp.nMaxCustFilter: D$ 0
 HostApp.nFilterIndex: D$ 0
 HostApp.lpstrFile: D$ DebuggeeExe
 HostApp.nMaxFile: D$ &MAX_PATH
 HostApp.lpstrFileTitle: D$ 0
 HostApp.nMaxFileTitle: D$ 0
 HostApp.lpstrInitialDir: D$ 0
 HostApp.lpstrTitle: D$ HostAppTitle
 HostApp.Flags: D$ &OFN_FILEMUSTEXIST+&OFN_EXPLORER+&OFN_NOCHANGEDIR
 HostApp.nFileOffset: W$ 0
 HostApp.nFileExtension: W$ 0
 HostApp.lpstrDefExt: D$ 0
 HostApp.lCustData: D$ 0
 HostApp.lpfnHook: D$ 0
 HostApp.lpTemplateName: D$ 0]

[DebuggeePath: B$ ? #&MAX_PATH]
[DebuggeeExe: B$ ? #&MAX_PATH]
[DebuggeeExeTitle: D$ ?]
[DebuggeeParams: D$ ?]
[CommandLineString: B$ ? #&MAX_PATH]

Proc CreateDebuggeeProcess:
    Local @Success

    mov D@Success &FALSE

    ; Allocate buffer for the command line, check if a command line file is provided and
    ; create the debuggee with debug rights for RosAsm.

    call 'KERNEL32.GetStartupInfoA' STARTUPINFO
    mov D$SI_dwFlags 0

    ; Setup Path, Executable, Parameters

    mov esi MainName, edi DebuggeePath
    While B$esi <> 0
        movsb
    EndWhile

    On B$edi <> '\', dec edi ; !!!

    While B$edi <> '\'
        mov B$edi 0
        dec edi
    EndWhile

    inc edi
    sub edi DebuggeePath
    mov D$DebuggeeExeTitle edi

    call 'Kernel32.SetCurrentDirectoryA' DebuggeePath

    If D$SavingExtension = '.DLL'
        call 'Comdlg32.GetOpenFileNameA' SelectHostAppDialog
        On eax = &FALSE, ExitP
        movzx eax W$HostApp.nFileOffset
        mov D$DebuggeeExeTitle eax
    Else
        mov edi DebuggeeExe, esi MainName
        While B$esi <> 0
            movsb
        EndWhile
        move D$edi D$SavingExtension
        mov B$edi+4 0
    EndIf

    add D$DebuggeeExeTitle DebuggeeExe

    call SetupCommandLine
    mov D$DebuggeeParams eax

    ; Assemble the commandline
    mov edi CommandLineString, ecx &MAX_PATH
    mov al '"' | stosb | dec ecx
    mov esi DebuggeeExe
    While B$esi <> 0
        movsb | dec ecx
    EndWhile
    mov ax '" ' | stosw | sub ecx 2
    mov esi D$DebuggeeParams
    cmp esi 0 | je L0>
    While B$esi <> 0
        On ecx = 1, jmp L0>
        movsb | dec ecx
    EndWhile
L0: mov B$edi 0

    ; Create the process with debug rights
    call 'KERNEL32.CreateProcessA' 0, CommandLineString, &NULL, &NULL, &FALSE,
                        &DEBUG_PROCESS+&DEBUG_ONLY_THIS_PROCESS+&PROCESS_TERMINATE,
                        &NULL, DebuggeePath, STARTUPINFO, PROCESS_INFORMATION
    mov D@Success eax
    If eax = &FALSE
        call ReportWinError {'Debugger: CreateProcess' 0}
        On eax = &ERROR_DIRECTORY,
            call 'User32.MessageBoxA' 0, DebuggeePath, {'Directory is:' 0}, &MB_OK
    EndIf

    ; Allocated by SetupCommandLine (dirty, but necessary if param-string is static [/S])
    VirtualFree D$CommandLinePtr

    mov eax D@Success
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; Debug (polling) Thread
____________________________________________________________________________________________
____________________________________________________________________________________________

; The actual debug work is done by this thread, it creates the debuggee and waits
; for debug-events. If these occur it transfers control to the user who can decide how to
; proceed.

[IsDebugEvent: ? DebugStart: ?]
[BreakpointsEnabled: ?]
[BreakpointOp: B$ 0CC]
[ByteBuf: B$ ?]
[ContinueStatus: D$ ?]

Proc DebugThread:
    Local @Exit, @CloseSent

    call CreateDebuggeeProcess
    If eax = &FALSE
        jmp L9>>
    EndIf

    mov D$BreakpointsEnabled &TRUE
    mov D$IsDebugging &TRUE
    mov D$IsDebugEvent &FALSE
    mov B$DebugStart &FALSE
    mov B$ExceptionFlags 0

    ; Main loop, as long as we don't want to quit, wait for debug events and process them.
    mov D@Exit &FALSE, B$DebugStart &FALSE, D@CloseSent 0

    .While D@Exit = &FALSE

L0:     call 'KERNEL32.WaitForDebugEvent' DEBUG_EVENT, 100

      ; If we receive false, the timeout occurred. Process any user input that makes sense
      ; while the debuggee is running (e.g. killing it or generating breakpoints)
        ..If eax = &FALSE

          ; The user requested the termination of the debuggee while it was running. Send
          ; WM_CLOSE messages to the main windows and then wait a second. Be sure to process
          ; debug messages (do *not* call WaitForSingleObject) inbetween. If the process is
          ; still alive after a second it is terminated.
            .If D$TerminateDebuggee = &TRUE
;;
                mov D$HoldOnBreakpoints 0
                If D@CloseSent = 0
                    call CloseMainWindows
                    mov D@CloseSent 1
                    jmp L0<
                Else
                    inc D@CloseSent
                    On D@CloseSent < 10, jmp L0<
;;
                    call 'KERNEL32.TerminateProcess' D$PI.hProcess, 0
                    jmp L9>>
                ;EndIf
            .End_If

          ; Check if we either need to enable or disable the breakpoints. (HoldOnBreakpoint
          ; has changed).
            mov eax D$HoldOnBreakpoints
            .If eax <> D$BreakpointsEnabled
                If B$HoldOnBreakpoints = &TRUE
                    call EnableProcessBreakpoints
                Else
                    call DisableProcessBreakpoints
                EndIf
            .EndIf

          ; User requested Pause: Generate breakpoint to halt all threads
            If D$PauseThreads = &TRUE
                mov ebx 0, esi D$ThreadIDHandleTable
                While ebx < D$NumThreads
                    call HaltThread D$esi+ebx*8+4
                    inc ebx
                EndWhile
                mov D$PauseThreads &FALSE
            EndIf

          ; Look for BP changes in the source editor
            call ClearBPAnteroom
            jmp L0<<

        ..End_If

        mov eax D$DE.dwProcessId
        If eax <> D$PI.dwProcessId
          ; If this debug event belongs to an other (child) process, continue execution
            call 'Kernel32.ContinueDebugEvent' D$DE.dwProcessId, D$DE.dwThreadId, &DBG_CONTINUE
            jmp L0<<
        End_If

        mov D$ContinueStatus &DBG_CONTINUE

        .If D$DE.dwDebugEventCode = &EXIT_PROCESS_DEBUG_EVENT
            mov D@Exit &TRUE
        .Else_If D$DE.dwDebugEventCode = &CREATE_THREAD_DEBUG_EVENT
            call Debugger_OnCreateThread
        .Else_If D$DE.dwDebugEventCode = &EXIT_THREAD_DEBUG_EVENT
            call Debugger_OnExitThread
        .Else_If D$DE.dwDebugEventCode = &LOAD_DLL_DEBUG_EVENT
            call Debugger_OnLoadDll D$LOADDLL.Base
        .Else_If D$DE.dwDebugEventCode = &UNLOAD_DLL_DEBUG_EVENT
            call Debugger_OnUnloadDll D$UNLOADDLL.Base
        .Else_If D$DE.dwDebugEventCode = &EXCEPTION_DEBUG_EVENT
            call Debugger_OnException
            mov D@Exit eax
        .Else_If D$DE.dwDebugEventCode = &CREATE_PROCESS_DEBUG_EVENT
            call Debugger_OnCreateProcess
        .Else_If D$DE.dwDebugEventCode = &OUTPUT_DEBUG_STRING_EVENT
            call HandleDebugString
        .Else
            mov D$ContinueStatus &DBG_EXCEPTION_NOT_HANDLED
        .End_If

        call 'KERNEL32.ContinueDebugEvent' D$DE.dwProcessId, D$DE.dwThreadId, D$ContinueStatus

    .End_While

L9: mov B$IsDebugging &FALSE
    call 'Kernel32.ExitThread' 0
EndP
____________________________________________________________________________________________

; When a thread is created in the debuggee. Add Thread ID/Handle pair to table.

Debugger_OnCreateThread:
    mov esi D$ThreadIDHandleTable, ecx D$NumThreads
    move D$esi+ecx*8 D$DE.dwThreadID
    move D$esi+ecx*8+4 D$CTDI.hThread
    inc D$NumThreads

    FormatString DebugLogString, {'Thread ID=%d created' 0}, D$DE.dwThreadId
    call 'User32.PostMessageA' D$DebugDialogHandle, WM_LOG, DebugLogString, ecx
ret
____________________________________________________________________________________________

; Overwrite Thread ID/Handle pair in table with last entry.

Debugger_OnExitThread:
    dec D$NumThreads
    mov ecx D$NumThreads, edx 0
    mov esi D$ThreadIDHandleTable, eax D$DE.dwThreadID
    While D$esi+edx*8 <> eax
        inc edx
    End_While
    move D$esi+edx*8 D$esi+ecx*8
    move D$esi+edx*8+4 D$esi+ecx*8+4

    FormatString DebugLogString, {'Thread ID=%d terminated' 0}, D$DE.dwThreadId
    call 'User32.PostMessageA' D$DebugDialogHandle, WM_LOG, DebugLogString, ecx
ret
____________________________________________________________________________________________

; When process is created. Add main thread ID/handle to table.

[DebugBaseOfCode: ?  DebugCodeSize: ?]

Debugger_OnCreateProcess:
    call 'KERNEL32.CloseHandle' D$CPDI.hFile

    mov D$DebugBaseOfCode 0, D$DebugCodeSize 0

    mov esi D$ThreadIDHandleTable
    move D$esi D$DE.dwThreadID, D$esi+4 D$CPDI.hThread
    inc D$NumThreads

    call ScanPEHeader D$CPDI.lpBaseOfImage

    call GetModuleName D$CPDI.lpBaseOfImage
    FormatString DebugLogString, {'%s ID=%d mapped at 0x%x' 0}, eax, D$DE.dwProcessId, D$CPDI.lpBaseOfImage
    call 'User32.PostMessageA' D$DebugDialogHandle, WM_LOG, DebugLogString, ecx
ret
____________________________________________________________________________________________

; When exception/breakpoint is encountered.

[DebugEventType: ? WatchedAddress: ?]
[DET_BP 1 DET_STEP 2 DET_WP 3 DET_EXCEPTION 4]

; Exception flags
[ExceptionFlags: 0]
[E_HAPPENED 1     E_OUTSIDE 2     E_MUSTEXIT 4]

[CurrentModule: ?]

Proc Debugger_OnException:
    Local @hThread, @Exit

    mov D@Exit &FALSE

    ;mov edi ExceptionTypes, eax D$E.ExceptionCode, ecx 18
    ;repne scasd | jne P9>>
    ;mov eax ExceptionStrings | mov ebx 17 | sub ebx ecx | shl ebx 2 | add eax ebx
    ;mov eax D$eax, D$BreakTitle eax

    ; Retrieve handle of the thread that has thrown the exception
    mov esi D$ThreadIDHandleTable, eax D$DE.dwThreadID
    While D$esi <> eax
        add esi 8
    End_While
    move D@hThread D$esi+4

    ;mov D$C.ContextFlags MY_CONTEXT_FULL
    ;call 'KERNEL32.GetThreadContext' D@hThread, CONTEXT

    ..If B$DebugStart = &TRUE

      ; Take note which window currently has the focus
        call 'USER32.GetForegroundWindow' | mov D$ActiveWindow eax

        mov D$C.ContextFlags MY_CONTEXT_FULL
        call 'KERNEL32.GetThreadContext' D@hThread, CONTEXT

        call IsModuleCode D$C.regEip
        If eax <> 0
            move D$CurrentModule D$eax+ME_Name
        Else
            mov D$CurrentModule 0
        EndIf

        call IsProcessCode D$C.regEip
        If eax = 1
            move D$SourcePosCodeAddress D$C.regEip
        Else
            call ScanStackForCodePointer D$C.regEsp
            dec eax
            mov D$SourcePosCodeAddress eax
        EndIf

        call ResolveSegmentAddresses D@hThread

        ; Write-back dynamic breakpoints. BPPending points at an entry in the
        ; breakpoint table-
        mov ebx D$BPPending
        If ebx <> 0
            call WriteProcessMem D$ebx, BreakpointOp, 1
            mov B$ebx+5 BP_ENABLED
            mov D$BPPending 0
        EndIf

        mov D$ContinueMode CONTINUE_RUN ; default

        .If D$E.ExceptionCode = &EXCEPTION_SINGLE_STEP
            mov D$DebugEventType DET_STEP

            call EncounterWatchPoint

            If D$RunAfterWriteBack = &FALSE
                On D$HoldOnBreakpoints = &TRUE,
                    call SignalDebugEvent        ; <<<<<<<<<<<<<<<<<<<<<<<<<<
            Else
                mov D$ContinueMode CONTINUE_RUN
                mov D$RunAfterWriteBack &FALSE
            EndIf

        .ElseIf D$E.ExceptionCode = &EXCEPTION_BREAKPOINT
            mov D$DebugEventType DET_BP

            call EncounterBreakpoint
            On D$HoldOnBreakpoints = &TRUE,
                call SignalDebugEvent        ; <<<<<<<<<<<<<<<<<<<<<<<<<<

        .Else
            mov D$DebugEventType DET_EXCEPTION

            call EncounterException
            mov D@Exit eax

            ;On D$ContinueStatus <> &DBG_EXCEPTION_NOT_HANDLED,
            ;    call SignalDebugEvent        ; <<<<<<<<<<<<<<<<<<<<<<<<<<

            ;If D$E.ExceptionFlags = 0
            ;    call NextInstructionDecode
            ;    mov eax D$InstructionLength
            ;    add D$C.regEip eax ; TODO this is a dirty hack and no real solution!!
            ;    mov D@Exit 0
            ;EndIf
        .End_If

        .If D@Exit = &FALSE
            ; For step over instructions, we overwrite the process memory after
            ; the next instruction with a breakpoint. The overwritten byte is
            ; preserved with the code address in the breakpoint table.
            If D$ContinueMode = CONTINUE_STEPOVER
                mov ebx D$C.regEip | add ebx D$InstructionLength
                call AddProcessBreakpoint ebx, BP_ONESHOT, BP_ENABLED, 0
            Else_If D$ContinueMode = CONTINUE_RETURNTOCALLER
                call ScanStackForCodePointer D$C.regEsp
                On eax <> 0,
                    call AddProcessBreakpoint eax, BP_ONESHOT, BP_ENABLED, 0
            End_If

            If D$BPPending <> 0
                On D$ContinueMode <> CONTINUE_STEP,
                    mov D$RunAfterWriteBack &TRUE
                mov D$ContinueMode CONTINUE_STEP
            EndIf

            If D$ContinueMode = CONTINUE_STEP
                or D$C.regFlag 0100 ; set trap flag
            Else
                and D$C.regFlag 0_FFFF_FEFF ; in case of Exceptions it's not auto-cleared
            EndIf

            On D$ContinueMode = CONTINUE_RUN,
                call ShowProcessWindows

            On D$TerminateDebuggee = &TRUE,
                mov D@Exit &TRUE

            ; Take care of user-activated/deactivated dynamic breakpoints.
            call ClearBPAnteroom

            call TransferWatchpoints

            mov D$C.ContextFlags MY_CONTEXT_FULL
            call 'Kernel32.SetThreadContext' D@hThread, CONTEXT

        .EndIf

    ..Else

        If D$E.ExceptionCode = &EXCEPTION_BREAKPOINT
            mov B$DebugStart &TRUE
            call ClearBPAnteroom
            call 'User32.PostMessageA' D$DebugDialogHandle, WM_BEGIN_DEBUG, 0, 0
        EndIf

    ..End_If
    mov eax D@Exit

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[LDT_ENTRY: B$ ? #8]

[LinearSegmentAddresses:
 CS.Linear: ? CS.Limit: ? DS.Linear: ? DS.Limit: ? ES.Linear: ? ES.Limit: ?
 FS.Linear: ? FS.Limit: ? GS.Linear: ? GS.Limit: ? SS.Linear: ? SS.Limit: ?]

Proc ResolveSegmentAddresses:
    Arguments @hThread

    mov esi SegRegMap, edi LinearSegmentAddresses, ebx 6

    While ebx > 0
        lodsd
        call 'KERNEL32.GetThreadSelectorEntry' D@hThread, D$eax, LDT_Entry
        If eax = &TRUE
            mov al B$LDT_ENTRY+4, ah B$LDT_ENTRY+7
            shl eax 16
            mov ax W$LDT_ENTRY+2
            stosd
            movzx eax W$LDT_ENTRY
            stosd
        EndIf
        dec ebx
    EndWhile
EndP
____________________________________________________________________________________________

; The 'ModuleList' points at a list of module information entries that are currently
; loaded and mapped into the address space of the debuggee.

; Entry in module list
[ME_Base 0          ; The base VA of the mapped module
 ME_Size 4          ; size in bytes
 ME_Name 8          ; pointer to filename
 ME_CodeBase 12     ; base VA of code section
 ME_CodeSize 16     ; size in bytes of code section
 ME_ExportBase 20   ; base RVA of export section
 ME_ExportSize 24]  ; size in bytes of export section
[SizeOf_ModuleEntry 32]

[ModuleList: ? NumModules: ? ModuleNameHeap: ?]

[new | imul eax D$Num#1s SizeOf_#1Entry | add eax D$#1List | inc D$NumModules | mov #2 eax]
[delete | push esi edi ecx | dec D$Num#1s |
    mov ecx SizeOf_#1Entry | imul esi D$Num#1s SizeOf_#1Entry | add esi D$#1List |
    mov edi #2 | rep movsb |
    pop ecx edi esi]
____________________________________________________________________________________________

; After messing with the toolhelp and psapi and having endless problems enumerating and
; getting module info I finally decided to use none of these evil APIs and read information
; needed directly from the PE image in the debuggee as soon as it is loaded. Most of the
; addresses are stored in the header. Only the module name must be read out of the export
; section or, in case of executables, from the commandline.

Proc ScanPEHeader:
    Arguments @BaseAddress
    Local @Size, @CodeBase, @CodeSize, @ExportBaseRVA, @ExportSize, @Name, @IsExe
    Uses esi, edi, ebx

        ; Read size of image, base-address and size of the code section & export table
        ; from PE image header.
        VirtualAlloc PEBuffer, 0400

            call ReadProcessMem D@BaseAddress, D$PEBuffer, 0400

            call 'KERNEL32.HeapAlloc' D$ModuleNameHeap, 0, 040
            mov D@Name eax

            mov esi D$PEBuffer
            add esi D$esi+03C ; skip DOS header
            test W$esi+016 &IMAGE_FILE_DLL ; characteristics (dll/exe)
            setz B@IsExe
            add esi 018 ; skip file header
            On W$esi <> 010B, jmp @Error ; check optional header ID

            move D@Size D$esi+038

            mov eax D$esi+014 | add eax D@BaseAddress
            mov D@CodeBase eax
            move D@CodeSize D$esi+04
            move D@ExportBaseRVA D$esi+060
            move D@ExportSize D$esi+064

        VirtualFree D$PEBuffer

        ; A PE can be a DLL or an EXE (and some other formats that RosAsm does not deal with yet).
        ; If it is an executable its name is extracted from the commandline. Otherwise (DLL) the
        ; name is expected in the export table.
        .If B@IsExe = &FALSE
            ; A dll without an export table??
            On D@ExportBaseRVA = 0, jmp @Error
            On D@ExportSize = 0, jmp @Error

            ; Load the export table.
            VirtualAlloc PEBuffer, D@ExportSize

                mov eax D@ExportBaseRVA | add eax D@BaseAddress
                call ReadProcessMem eax, D$PEBuffer, D@ExportSize

                mov esi D$PEBuffer, edi D@Name
                ; copy module name
                mov edx D$esi+0C
                sub edx D@ExportBaseRVA
                add edx esi
                Do
                    mov al B$edx
                    stosb
                    inc edx
                Loop_Until al = 0
                mov B$edi 0

            VirtualFree D$PEBuffer

        ; TODO is it possible that exe files are used as library from the actual application exe?
        ; If really possible this branch would be wrong. (ntoskrnl.exe !)
        .Else
            move D@Name D$DebuggeeExeTitle
        .EndIf

        new Module edi

        move D$edi+ME_Base D@BaseAddress
        move D$edi+ME_Size D@Size
        move D$edi+ME_Name D@Name
        move D$edi+ME_CodeBase D@CodeBase
        move D$edi+ME_CodeSize D@CodeSize
        move D$edi+ME_ExportBase D@ExportBaseRVA
        move D$edi+ME_ExportSize D@ExportSize

        mov eax D@BaseAddress, ecx D@CodeSize, edx D@CodeBase
        .If D$SavingExtension = '.DLL'
            If eax = D$LinkerDllDefault
                mov D$DebugBaseOfCode edx
                mov D$DebugCodeSize ecx
            EndIf
        .Else
            If eax = LINKERDEFAULT
                mov D$DebugBaseOfCode edx
                mov D$DebugCodeSize ecx
            EndIf
        .EndIf

        mov eax 1
        ExitP

@Error:
        VirtualFree D$PEBuffer
        mov eax 0
EndP
____________________________________________________________________________________________

Proc Debugger_OnLoadDll:
    Arguments @BaseAddress

        call 'Kernel32.CloseHandle' D$LoadDll.hFile

        call ScanPEHeader D@BaseAddress

        call GetModuleName D@BaseAddress
        FormatString DebugLogString, {'%s mapped at 0x%x' 0}, eax, D@BaseAddress
        call 'User32.PostMessageA' D$DebugDialogHandle, WM_LOG, DebugLogString, ecx

EndP
____________________________________________________________________________________________

Proc Debugger_OnUnloadDll:
    Arguments @BaseAddress
    Uses esi, edi

        call GetModuleName D@BaseAddress
        FormatString DebugLogString, {'%s unmapped' 0}, eax
        call 'User32.PostMessageA' D$DebugDialogHandle, WM_LOG, DebugLogString, ecx

        ; Search module in table
        mov edi D$ModuleList, ecx 0, eax D@BaseAddress
        While ecx < D$NumModules
            On D$edi = eax, jmp L0>
            add edi SizeOf_ModuleEntry
            inc ecx
        EndWhile
        ExitP

L0:
        ; Do cleanup work. Free the memory for the module name.
        call 'KERNEL32.HeapFree' D$ModuleNameHeap, 0, D$edi+ME_Name

        ; Overwrite the entry to delete with last entry in table.
        delete Module edi

EndP
____________________________________________________________________________________________

; Search in the modulelist for the name of the module starting at the base address passed.

GetModuleName:
    mov eax D$esp+4
    mov edx D$ModuleList, ecx D$NumModules
    While ecx > 0 ; bugfix V2.0b
        cmp eax D$edx+ME_Base | je L1>
        add edx SizeOf_ModuleEntry
        dec ecx
    EndWhile
    mov eax 0
ret 4
L1: mov eax D$edx+ME_Name
ret 4
____________________________________________________________________________________________

; Find the module from an address. Return the address of the module entry or NULL if no
; module with such a code address could be found.

Proc IsModuleCode:
    Arguments @CodeAddress
    Uses esi

        mov ecx 0, esi D$ModuleList
        While ecx < D$NumModules
            mov eax D$esi+ME_CodeBase, edx D$esi+ME_CodeSize
            .If D@CodeAddress >= eax
                add edx eax
                If D@CodeAddress < edx
                    mov eax esi
                    ExitP
                EndIf
            .EndIf
            add esi SizeOf_ModuleEntry | inc ecx
        EndWhile
        mov eax 0
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[DebugLogString: B$ ? #256]

; Log debug output to a file. First read debug string from process memory of the debuggee
; to a local buffer (the stack).

[DebugStringBuffer: ? DebugLogFile: ? DebugLogFileName: B$ ? #&MAXPATH]
[DebugLogName: '_dbg.log' 0]

Proc HandleDebugString:
    Local @Size

  ; Get mem on the stack for the debug string
    movzx eax W$ODS.StringLen
    Align_on 4 eax
    mov D@Size eax
    sub esp D@Size
    mov D$DebugStringBuffer esp

  ; Read the debug string
    call ReadProcessMem D$ODS.DebugString, D$DebugStringBuffer, D@Size

    call 'User32.SendMessageA' D$DebugDialogHandle, WM_LOG, D$DebugStringBuffer, D@Size

    .If D$DebugLogFile = 0

      ; Build logfile-name of the form "[Path]\[AppName]_dbg.log"
        mov esi DebuggeeExe, edi DebugLogFileName, ecx 256

      ; Copy full path+filename+extension
L0:     cmp B$esi 0 | je L1>
        movsb
        loop L0<

L1:     neg ecx | add ecx 256
        mov B$edi 0

      ; Strip extension
L0:     cmp B$edi '.' | je L1>
        dec edi
        loop L0<

L1:     neg ecx | add ecx 256
        mov esi DebugLogName

      ; append "_dbg.log"
L0:     cmp B$esi 0 | je L1>
        movsb
        loop L0<

L1:     mov B$edi 0

        call 'Kernel32.CreateFileA' DebugLogFileName, &GENERIC_WRITE, &FILE_SHARE_READ, 0,
            &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0

        If eax = &INVALID_HANDLE_VALUE
            call ReportWinError {'HandleDebugString: CreateFile' 0}
            jmp L9>
        Else
            mov D$DebugLogFile eax
        EndIf

    .EndIf

    movzx eax W$ODS.StringLen | dec eax
    call 'KERNEL32.WriteFile' D$DebugLogFile, D$DebugStringBuffer, eax, BytesTransfered, 0

    mov W$esp 0A0D
    call 'KERNEL32.WriteFile' D$DebugLogFile, D$DebugStringBuffer, 2, BytesTransfered, 0

  ; Free mem from the stack
L9: add esp D@Size
EndP
____________________________________________________________________________________________

; Called when an exception in the debuggee occurs. Check if the exception is continueable.
; Returns 1 if the debuggee must be terminated, otherwise 0.

Proc EncounterException:
    Local @Exit, @Dummy

    mov D$ExceptionFlags E_HAPPENED

    call IsProcessCode D$C.regEip
    If eax = 0
        call ScanStackForCodePointer D$C.regEsp
        dec eax
        mov D$SourcePosCodeAddress eax
    EndIf

    ..If D$E.FirstChance <> 0
      ; check if exception handler is inside debuggee code
        lea eax D@Dummy | call ReadProcessMem D$FS.Linear, eax, 4
        mov ecx D@Dummy | add ecx 4 ; get handler address
        lea eax D@Dummy | call ReadProcessMem ecx, eax, 4
        call IsProcessCode D@Dummy ; handler address
        .If eax = 1
            call IsProcessCode D$C.regEip
            On eax = 0, or D$ExceptionFlags E_OUTSIDE

            call SignalDebugEvent
            If D$TerminateDebuggee = &TRUE
                mov eax 1
            Else
                mov D$ContinueStatus &DBG_EXCEPTION_NOT_HANDLED
                mov D$ContinueMode CONTINUE_RUN
                mov eax 0
            EndIf
        .Else
            mov D$ContinueStatus &DBG_EXCEPTION_NOT_HANDLED
            mov D$ContinueMode CONTINUE_RUN
            mov eax 0
        .EndIf
    ..Else
        or D$ExceptionFlags E_MUSTEXIT

        call SignalDebugEvent
        mov eax 1
    ..EndIf

    mov D$ExceptionFlags 0 ; was only needed for UI, clear it so we could proceed (SEH)

;;
  ; Check if Exception happened outside of application code. 
    call IsProcessCode D$C.regEip
    .If eax = 1
        
        On D$E.FirstChance = 0, 
            or D$ExceptionFlags E_MUSTEXIT
            
        call SignalDebugEvent
        
        If D$TerminateDebuggee = &TRUE
            mov eax 1
        Else
            mov D$ContinueStatus &DBG_EXCEPTION_NOT_HANDLED
            mov D$ContinueMode CONTINUE_RUN
            mov eax 0
        EndIf
        
    .Else
    
        or D$ExceptionFlags E_OUTSIDE
      
      ; Give the module the possibility to handle the exception by its per-thread
      ; exception handler. If it does not catch the exception, show the exception
      ; dialog.
      
        If D$E.FirstChance = 0
            or D$ExceptionFlags E_MUSTEXIT            
            
            call ScanStackForCodePointer D$C.regEsp
            dec eax
            mov D$SourcePosCodeAddress eax
            
            call SignalDebugEvent
          
            mov eax 1
        Else
            mov D$ContinueStatus &DBG_EXCEPTION_NOT_HANDLED
            mov D$ContinueMode CONTINUE_RUN
            mov eax 0
        EndIf
    
    .EndIf    
    
    mov D$ExceptionFlags 0 ; was only needed for UI, clear it so we could proceed (SEH)
                
    .If D$E.FirstChance = 0
        mov D$ExceptionFlags E_HAPPENED

        call IsProcessCode D$C.regEIP
        If eax = &FALSE
            
        EndIf

        ; Exception is continueable?
        If D$E.ExceptionFlags <> 0
            or D$ExceptionFlags E_MUSTEXIT
            mov D@Exit 1
        EndIf

        ;call SignalDebugEvent

        mov eax D@Exit
        On D$TerminateDebuggee = &TRUE, mov eax 1
    .Else
    
      ; try to pass to apps exception handler
        mov D$ContinueStatus &DBG_EXCEPTION_NOT_HANDLED
        mov eax 0
        
    .EndIf
;;
EndP
____________________________________________________________________________________________

; Bring all visible windows of the debuggee to front.

[ActiveWindow: ?]

Proc EnumThreadWindowProc:
    Arguments @Handle, @Param

    call 'USER32.SetWindowPos' D$hwnd, D@Handle, 0, 0, 0, 0, &SWP_NOMOVE+&SWP_NOSIZE

    mov eax D@Handle
    If eax = D$ActiveWindow
        call 'USER32.SetForegroundWindow' D$ActiveWindow
    EndIf

    mov eax 1
EndP

ShowProcessWindows:
    mov ebx 0, esi D$ThreadIDHandleTable
    While ebx < D$NumThreads
        call 'User32.EnumThreadWindows' D$esi+ebx*8, EnumThreadWindowProc, 0
        inc ebx
    EndWhile
ret
____________________________________________________________________________________________

; close all non-child windows. Used when the debuggee is terminated while running.

Proc EnumCloseWindowsProc:
    Arguments @Handle, @Param

    call 'User32.PostMessageA' D@Handle, &WM_CLOSE, 0, 0
    mov eax &TRUE
EndP

CloseMainWindows:
    mov ebx 0, esi D$ThreadIDHandleTable
    While ebx < D$NumThreads
        call 'User32.EnumThreadWindows' D$esi+ebx*8, EnumCloseWindowsProc, 0
        inc ebx
    EndWhile
ret
____________________________________________________________________________________________

; STACK SCANNER
____________________________________________________________________________________________

;;
    The stack has the following structure (for each stackframe)
    
        Parameter n
        [...]
        Parameter 2
    ___ Parameter 1
        Return Address
        Saved EBP (if proc has stackframe)
        Local data
    
  * To differ between procedures we first have to find the return addresses. Then the number
    of parameters must be estimated. Given that information a complete call-stack can
    be generated.
    
  * First, all return addresses on the stack are collected bottom-up. The proc is tried to
    be identified. 
    
  * Note that life would be much easier if every proc was guaranteed to have a stack frame.
    We could just take the saved ebp as a pointer to the callers stack frame. However,
    in Assembly you are free to use ebp for whatever you like, and creating a stack frame is
    optional. Therefore the return addresses are used to identify called procedures.
    
  * Misinterpretation problems arise from "stack pollution", that is procs reserving space on 
    the stack without freeing it (e.g. sub esp 0100). Return addresses from former execution
    pollute the stack in this region. This has been partially solved by validating the stack 
    frames top-down in the third pass (ignore the locals region). The remaining problems
    are due to dynamic stack allocation (e.g. sub esp ecx). 
;;

[BufferOverrun:
"Detected buffer-overrun. 
Contact RosAsm dev team if this happens regularly." 0]

[CallStackDesc: ? CallStackEntries: ? FirstCallStackEntry: ?]
[MAX_CALLSTACK_ENTRIES 512]
[CSE_Address 0      ; points at the ret-address+4 in the LOCAL stack copy
 CSE_ProcAddress 4  ; (estimated) address of the called function
 CSE_ProcName 8     ; points at the name (+estimation info) of the funtion
 CSE_NumParams 12   ; number of paramters (after ret-address)
 CSE_NumLocals 16   ; number of locals (before ret-address)
 CSE_Rating 20      ; probability of correctness
 CSE_Flags 21       ; flags
 CSE_Next 24        ; address of next call-stack entry
 SizeOf_CSE 32]     ; align on cache line

[CSEF_HAS_STACKFRAME 01  ; CSE has a stackframe (push ebp | ...)
 CSEF_FUZZY_ADDRESS  02  ; address of proc is not exact
 CSEF_EXTERNAL       04] ; proc is outside debugged module


[ProcNameHeap: ?]

Proc GenerateCallStack:
    Local @Pointer, @CurrentSize, @ProcAddr, @LastCodeAddr, @Exact, @NumLocals

    call DestroyCallStack

    On D$ProcNameHeap = 0, call 'KERNEL32.HeapCreate' 0, 01000, 0
    mov D$ProcNameHeap eax

    call ReadApplicationStack D$C.regEsp
    On eax = &FALSE, ExitP
    On D$CallStackDesc = 0, VirtualAlloc CallStackDesc, 04000

    call CallStack.Pass1
    If D$CallStackEntries = 0
        mov eax 0
        ExitP
    EndIf
    call CallStack.Pass2
    call CallStack.Pass3
;;
    mov esi D$StackBuffer, edi D$CallStackDesc, D$CallStackEntries 0
    mov D$NextStackFrame 0, D@NumLocals 0
    move D@CurrentSize D$StackSize
    move D@LastCodeAddr D$C.regEip
    .While D@CurrentSize > 0
        lodsd | mov D@Pointer eax

        call IsReturnAddress eax, edi
        .If eax = &TRUE

            mov D$edi+CSE_Address esi

            call 'Kernel32.HeapAlloc' D$ProcNameHeap, 0, 040
            mov D$edi+CSE_ProcName eax

            ; Check if the exact address of the procedure called could be estimated.
            ; If not (call reg / call mem / ...) use the code address which is
            ; somewhere in the proc to find the procedure address and label.
            mov eax D$edi+CSE_ProcAddress
            If eax <> 0
                mov D@ProcAddr eax
                mov D@Exact &TRUE
            Else
                move D@ProcAddr D@LastCodeAddr
                mov D@Exact &FALSE
            EndIf
            call IsProcessCode D@ProcAddr
            If eax = &TRUE
                call ScanLabelListForCodeLabel D@ProcAddr, D@Exact
            Else
                call ScanExportTableForCodeLabel D@ProcAddr, D@Exact
            EndIf

            mov D$edi+CSE_ProcAddress eax

            push esi edi
                mov esi LabelName, edi D$edi+CSE_ProcName
                Do | movsb | Loop_Until B$esi-1 = 0
            pop edi esi

            call CountParametersAndScanStackFrame edi

            ; Local data - Begin to count local data from the last return address.
            ; Therefore NumLocals start with a negative number if parameters were
            ; passed to the last function.
            mov eax D@NumLocals
            On eax l 0, mov eax 0
            mov D$edi+CSE_NumLocals eax

            mov eax D$edi+CSE_NumParams | neg eax
            mov D@NumLocals eax

            move D@LastCodeAddr D@Pointer
            add edi SizeOf_CSE
            inc D$CallStackEntries
        .Else
            inc D@NumLocals
        .EndIf
        sub D@CurrentSize 4
    .EndWhile
;;
    mov eax &TRUE
EndP

____________________________________________________________________________________________

; First pass - search all possible return addresses

Proc Callstack.Pass1:
    Local @CurrentSize, @LastCodeAddr, @Pointer, @ProcAddr, @Exact
    Uses esi, edi

    mov esi D$StackBuffer, edi D$CallStackDesc, D$CallStackEntries 0
    move D@CurrentSize D$StackSize
    move D@LastCodeAddr D$C.regEip
    .While D@CurrentSize > 0
        lodsd | mov D@Pointer eax

        call IsReturnAddress eax, edi
        .If eax = &TRUE
            mov D$edi+CSE_Address esi

            call 'Kernel32.HeapAlloc' D$ProcNameHeap, 0, 040
            mov D$edi+CSE_ProcName eax

          ; Check if the exact address of the procedure called could be estimated.
          ; If not (call reg / ...) use the code address which is
          ; somewhere in the proc to find the procedure address and label.
            mov B$edi+CSE_Flags 0
            mov eax D$edi+CSE_ProcAddress
            If eax <> 0
                mov D@ProcAddr eax
                mov D@Exact &TRUE
            Else
                move D@ProcAddr D@LastCodeAddr
                or B$edi+CSE_Flags CSEF_FUZZY_ADDRESS
                mov D@Exact &FALSE
            EndIf
            call IsProcessCode D@ProcAddr
            If eax = &TRUE
                call ScanLabelListForCodeLabel D@ProcAddr, D@Exact
            Else
                call ScanExportTableForCodeLabel D@ProcAddr, D@Exact
                or B$edi+CSE_Flags CSEF_EXTERNAL
            EndIf

            mov D$edi+CSE_ProcAddress eax

            push esi edi
                mov esi LabelName, edi D$edi+CSE_ProcName
                Do | movsb | Loop_Until B$esi-1 = 0
            pop edi esi

            move D@LastCodeAddr D@Pointer
            add edi SizeOf_CSE
            inc D$CallStackEntries

          ; Prevent buffer overrun
            If D$CallStackEntries >= MAX_CALLSTACK_ENTRIES
                call 'User32.MessageBoxA' D$DebugDialogHandle, BufferOverrun, {'Callstack generation' 0}, &MB_OK+&MB_ICONEXCLAMATION
                mov eax &FALSE
                ExitP
            EndIf
        .EndIf
        sub D@CurrentSize 4
    .EndWhile
    mov eax &TRUE
EndP
____________________________________________________________________________________________

; Second pass - scan stack frames and rate procs

[CSRatingFailed: ?] ; indicate that rating wasn't successful -> don't rely on the ratings

Proc CallStack.Pass2:
    Uses esi, edi, ebx

    mov esi D$StackBuffer, edi D$CallStackDesc, ecx D$CallStackEntries
    mov edx esi | sub edx D$C.regEsp

    mov ebx D$C.regEbp | add ebx edx

L0:     lea eax D$ebx+8
        While eax <> D$edi
            add edi SizeOf_CSE
            dec ecx | jz L9>
        EndWhile
        inc B$edi+CSE_Rating

      ; Check for invalid stackframe ptrs - a stackframe ptr is invalid if it points
      ; to somewhere outside the used stack.
        If ebx < esi
            mov D$CSRatingFailed 1
            ExitP
        EndIf
        mov eax esi | add eax D$StackSize
        If ebx >= eax
            mov D$CSRatingFailed 1
            ExitP
        EndIf

        mov ebx D$ebx | add ebx edx ; next stackframe ptr
    jmp L0<

L9: mov D$CSRatingFailed 0
EndP
____________________________________________________________________________________________

; Third pass - validate, count params, locals, ...

Proc CallStack.Pass3:
    Local @LowerBound, @UpperBound, @LastCSE
    Uses esi, edi, ebx

  ; Traverse the callstack top-down, begin with the last entry
    mov ebx D$CallStackEntries | dec ebx
    imul edi ebx SizeOf_CSE | add edi D$CallStackDesc
    mov esi D$edi+CSE_address ; esi -> params of the root function

    mov eax D$StackBuffer | mov D@LowerBound eax
    add eax D$StackSize   | mov D@UpperBound eax

    mov D@LastCSE 0

    .While ebx ge 0

      ; UpperBound - address of last CSE
      ; LowerBound - limit given through esp

      ; The bounds are stored to detect collisions of CSEs. Collision (or overlaps)
      ; occur if some interpretation mechanism has failed (locals, params) or if the
      ; whole CSE is a ghost entry (old ret addresses in non-overwritten locals)

        mov eax D$edi+CSE_Address
        .If D@UpperBound < eax
            mov edx D@LastCSE | mov al B$edx+CSE_Rating
            If al g B$edi+CSE_Rating
              ; overlapped by local data of a higher rated proc, considered
              ; as stack pollution -> throw away
                jmp L8>
            ElseIf al = B$edi+CSE_Rating
              ; overlapped by local data of equally rated proc, the assumption
              ; about the size of local data of the last CSE might be wrong, correct it (set to zero)
                mov D$edx+CSE_NumLocals 0
                ;mov eax D$edi+CSE_Address | sub eax D@Upperbound | shr eax 2
                ;sub D$edx+CSE_NumLocals eax
                move D@UpperBound D$edi+CSE_Address
            Else
              ; overlapped by local data of lower rated proc (the interpretation failed)
              ; throw away the last(!) CSE
                mov eax D$edx+CSE_Next | mov D@LastCSE eax
            EndIf
        .EndIf

        call CountParametersAndScanStackFrame edi

      ; Check parameters size - the parameter sizes should be ok in most cases.
      ; however, if some ill "ret 086D" statement is somewhere in the source (e.g. MyPNN)
      ; the boundaries are exceeded easily. If this occurs in other apps too, better merge
      ; the validation of param and local sizes and do something more intelligent ...
        mov eax D$edi+CSE_NumParams | shl eax 2
        add eax D$edi+CSE_Address
        If D@UpperBound < eax
          ; MyPNN phenomenon, consider cleaner way to deal with this issue
            mov D$edi+CSE_NumParams 0
        EndIf


        If D$CSRatingFailed = 0
          ; proc with stackframes should be rated if rating was successful
            test B$edi+CSE_Flags CSEF_HAS_STACKFRAME | jz L0>
                cmp B$edi+CSE_Rating 1 | jl L8>
L0:     EndIf

      ; recompute upper bound
        mov eax D$edi+CSE_NumLocals | inc eax | shl eax 2 ; SizeOf(Locals+RetAddress)
        mov edx D$edi+CSE_Address | sub edx eax
        mov D@UpperBound edx

      ; if we just entered the proc the stack might not be fully filled - either we
      ; must handle it or the one who displays it. Otherwise we'd read below the stackptr.
        If edx < D@LowerBound
            sub edx D@Lowerbound ; edx is negative!
            neg edx | shr edx 2
            sub D$edi+CSE_NumLocals edx ; subtract from localnumber
        EndIf

        move D$edi+CSE_Next D@LastCSE
        mov D@LastCSE edi

L8:     sub edi SizeOf_CSE
        dec ebx | js L9>
    .EndWhile

L9: move D$FirstCallStackEntry D@LastCSE

EndP
____________________________________________________________________________________________


____________________________________________________________________________________________

Proc DestroyCallStack:
    mov D$StackSize 0
    VirtualFree D$StackBuffer
    mov D$CallStackEntries 0, D$FirstCallStackEntry 0
    VirtualFree D$CallStackDesc
    If D$ProcNameHeap <> 0
        call 'KERNEL32.HeapDestroy' D$ProcNameHeap
        mov D$ProcNameHeap 0
    EndIf
EndP
____________________________________________________________________________________________

; Copy the complete stack from the address space of the debuggee into our address space.

[StackBuffer: ? StackSize: ?]

Proc ReadApplicationStack:
    Arguments @StackPointer

        ; Get size of current stack
        mov eax D@StackPointer
        On eax = 0, ExitP
        and eax 0_FFFF_FFFC ; dword align
        mov D@StackPointer eax
        call IsProcessMemory D@StackPointer
        On eax = 0, ExitP
        mov D$StackSize eax
        ; Copy stack, starting at the stackpointer
        VirtualAlloc StackBuffer, eax
        call ReadProcessMem D@StackPointer, D$StackBuffer, D$StackSize
EndP
____________________________________________________________________________________________

; Check if the given value is an return address.
; Returns:
;   eax - TRUE / FALSE

; NextStackFrame is the so called ghost-return-address prevention. In external modules
; all procs are assumed to have a stackframe (which is not true). If those procs use the
; stack for local data (sub esp imm) but do not clear/use it, old return addresses might
; still be there (this happens _very_ often).
[NextStackFrame: ?]

Proc IsReturnAddress:
    Arguments @Address, @CSE

    mov eax D@CSE
    mov D$eax+CSE_ProcAddress 0

    call IsProcessCode D@Address
    ..If eax = 1
        call IsReturnAddressInSource D@Address, D@CSE
    ..Else
        mov eax 0
        call IsModuleCode D@Address
        .If eax <> 0
            If edi > D$NextStackFrame
                call IsReturnAddressInModule D@Address, D@CSE, eax
            Else
                mov eax 0
            EndIf
        .EndIf
    ..EndIf
EndP
____________________________________________________________________________________________

; Determine if the given address is a return address which was pushed on the stack by a
; call. We look into process memory if the instruction preceding the address is call.
; There are some different encodings of calls:
;   call Label      >> E8 ## ## ## ##
;   call D$Label    >> FF 15 ## ## ## ##
;   call reg32      >> FF D#
;   call D$reg32    >> FF 1# (eax/ecx/edx/ebx/edi/esi)
;   call D$esp      >> FF 14 24
;   call D$ebp      >> FF 55 00
; And with address arithmetic there are more variants. So we first check for the standard
; call opcode E8. If it is different we scan backward for the opcode FF and try a decode.
; If the decoded instruction is a call and equals the number of bytes searched back
; IsReturnAddress returns 1 otherwise 0 (in eax).

[PrecedingCode: B$ ? #96 PrecedingCodeSize: D$ ?]

Proc IsReturnAddressInModule:
    Arguments @Address, @CSE, @ModuleBase
    Uses ebx, edi

        mov eax D@ModuleBase, ebx D@Address, ecx ebx
        sub ecx D$eax+ME_CodeBase
        If ecx > 8
            mov ecx 8
        ElseIf ecx < 2
            ; the minimum length of a call is two bytes (FF ##)
            jmp L9>>
        Else
            mov D$PrecedingCode 0, D$PrecedingCode+4 0
        EndIf
        mov D$PrecedingCodeSize ecx | sub ebx ecx
        call ReadProcessMem ebx, PrecedingCode, ecx

        mov edi PrecedingCode, ecx D$PrecedingCodeSize
        If B$edi+ecx-5 = 0E8 ; call imm
            mov eax &TRUE
            ; convert the immediate to a virtual address
            mov edx D$edi+ecx-4
            add edx D@Address
            mov ecx D@CSE
            mov D$ecx+CSE_ProcAddress edx
            ExitP
        ElseIf W$edi+ecx-6 = 015FF ; call D$Label
            mov eax D$edi+ecx-4
            call ReadProcessMem eax, PrecedingCode, 4
            mov edx D$PrecedingCode
            mov ecx D@CSE
            mov D$ecx+CSE_ProcAddress edx
            mov eax &TRUE
            ExitP
        EndIf
L1:     mov al 0FF
            repne scasb | jne L9>
            dec edi

            call InstructionDecode edi
            mov eax D$NextInstructionPtr
            .If D$eax = 'call'
                inc ecx
                If ecx = D$InstructionLength
                    mov eax &TRUE
                    ExitP
                EndIf
                dec ecx
            .EndIf
            inc edi
        jmp L1<

L9:     mov eax &FALSE
EndP
____________________________________________________________________________________________

; Simplified version of IsReturnAddress. Here we use the IpTable to find the preceding
; instruction. This is much safer as no data can be mistaken as an opcode.

Proc IsReturnAddressInSource:
    Arguments @Address, @CSE
    Uses ebx, edi, esi

        ; >>> TODO
        ; Most mistaken return addresses are indeed function addresses which are pushed
        ; on the stack (callback functions, window procs). We should take care of the
        ; following case:
        ; Main:
        ; [...]
        ; call 'kernel32.ExitProcess'
        ; Proc MainWindowProc:
        ; [...]
        ; EndP
        ; The address of the window proc is saved on the stack multiple times, therefore
        ; messing up the callstack because it is preceded by call and mistaken as a return
        ; address.
        ; <<< TODO

        mov eax D@Address

      ; Search for return address in the instruction table.
        sub eax D$DebugBaseOfCode
        mov edi D$IpTable, ecx D$IpTablePtr
        sub ecx edi
        shr ecx 2
            jz L9>> ; if IpTable is empty/freed (which should never happen)
        While eax >= D$edi
            dec ecx | jz L9>>
            add edi 4
        EndWhile

      ; Search back for the preceding instruction. We can't just use [edi-8] because
      ; also Labels are recorded in the IpTable.
        sub edi 4
        Do
            On edi < D$IpTable, jmp L9>>
            mov edx D$edi
            sub edi 4
        Loop_Until edx <> eax
        mov ebx eax | sub ebx edx ; statements length
        add edx D$DebugBaseOfCode
        call ReadProcessMem edx, PrecedingCode, ebx

      ; The statement might contain several instruction (call-macro!), so decode
      ; every instruction until we find the last one of that statement.
        mov esi PrecedingCode
        Do
            call InstructionDecode esi
            mov eax D$InstructionLength
            add esi eax
            sub ebx eax
                js L9> ; how is this possible ? it happens... [Bugfix V2.0]
        Loop_Until ebx = 0

        mov eax D$NextInstructionPtr
        .If D$eax = 'call'
            mov eax 1, edx 0
            sub esi D$InstructionLength
            If B$esi = 0E8
                mov edx D$esi+1
                add edx D@Address
                mov ecx D@CSE
                mov D$ecx+CSE_ProcAddress edx
            ElseIf W$esi = 015FF
                mov edx D$esi+2
                call ReadProcessMem edx, PrecedingCode, 4
                mov eax D$PrecedingCode
                mov ecx D@CSE
                mov D$ecx+CSE_ProcAddress eax
                mov eax 1
            EndIf
            ExitP
        .EndIf

L9:     mov eax 0
EndP
____________________________________________________________________________________________

; Lookup the address of the code label after which the given code address follows IOW
; search the procedure which contains the code at the given address.

Proc GetNearestProc:
    Arguments @Address
    Local @NearestProc
    Uses esi, edi, ebx

    mov D@NearestProc 0
    mov edi D$PlainLabelList, ebx D$EndOfPlainLabelList, edx D@Address
    mov ecx D$edi
    add edi 5 | sub ecx 5

    While edi < ebx

        ; address of string
        mov esi edi
        mov al EOI
        repne scasb | jne L9>
        mov eax D$edi | add eax D$CodeAjust
        If eax <= edx
            On eax > D@NearestProc, mov D@NearestProc eax
        EndIf
        add edi 6 | sub ecx 6

    EndWhile

L9: mov eax D@NearestProc
EndP
____________________________________________________________________________________________

[LabelName: B$ ? #128]

CopyStringFromLabelList:
    push esi, edi

        mov edi LabelName
        While B$esi <> EOI
            movsb
        EndWhile
        mov B$edi 0

    pop edi, esi
ret
____________________________________________________________________________________________

; Lookup the label of the procedure starting at the given address.

Proc ScanLabelListForCodeLabel:
    Arguments @Address, @Exact
    Local @NearestProc @NearestProcName
    Uses esi, edi, ebx

    mov edi D$PlainLabelList, ebx D$EndOfPlainLabelList, edx D@Address
    mov ecx D$edi
    add edi 5 | sub ecx 5

    .If D@Exact = &TRUE

        While edi < ebx

            ; address of string
            mov esi edi
            mov al EOI
            repne scasb | jne L9>>
            test B$edi+4 DataLabelFlag | jnz L0>
            mov eax D$edi | add eax D$CodeAjust
            If eax = edx
                call CopyStringFromLabelList
                ExitP
            EndIf
L0:         add edi 6 | sub ecx 6

        EndWhile

    .Else

        mov D@NearestProc 0, D@NearestProcName 0
        While edi < ebx

            ; address of string
            mov esi edi
            mov al EOI
            repne scasb | jne L9>
            mov cl B$edi+4
            test cl DataLabelFlag | jnz L0>
            mov eax D$edi | add eax D$CodeAjust
            If eax <= edx
                On eax > D@NearestProc, mov D@NearestProc eax, D@NearestProcName esi
            EndIf
L0:         add edi 6 | sub ecx 6

        EndWhile

        mov esi D@NearestProcName
        On esi <> 0, call CopyStringFromLabelList
        mov eax D@NearestProc
        On eax <> 0, ExitP

    .EndIf

L9: mov eax D@Address
    call IntToHexString
    move D$LabelName D$HexString, D$LabelName+4, D$HexString+4
    mov B$LabelName+8 0
    mov eax D@Address
EndP
____________________________________________________________________________________________

; Lookup the label of the procedure starting at the given address. The export table of
; the module which is referenced by the code address is scanned.

[PEBuffer: ?]

Proc ScanExportTableForCodeLabel:
    Arguments @CodeAddress, @Exact
    Local @BaseAddress, @ExportBaseRVA, @ExportSize, @NumNames, @ProcAddressRVA, @AddressTableEntry
    Uses ebx, esi, edi

    call IsModuleCode D@CodeAddress
    If eax = 0
        ExitP
    EndIf
    move D@BaseAddress D$eax+ME_Base
    move D@ExportBaseRVA D$eax+ME_ExportBase
    move D@ExportSize D$eax+ME_ExportSize

    On D@ExportBaseRVA = 0, ExitP
    On D@ExportSize = 0, ExitP

    ; Load the export table.
    VirtualAlloc PEBuffer, D@ExportSize

        mov eax D@ExportBaseRVA | add eax D@BaseAddress
        call ReadProcessMem eax, D$PEBuffer, D@ExportSize

        mov esi D$PEBuffer, edi LabelName
        ; address conversion: RVA -> Linear address in copied export-table
        mov eax esi
        sub eax D@ExportBaseRVA
        mov D$ExportTableAdjust eax
        ; copy module name
        mov edx D$esi+0C
        add edx D$ExportTableAdjust
        Do
            mov al B$edx
            If al = 0 ; no library name?
                mov eax '???.'
                stosd
                jmp L0>
            EndIf
            stosb
            inc edx
        Loop_Until al = '.'
        ; number of exported functions
L0:     mov ecx D$esi+014
        move D@NumNames D$esi+018
        ; Convert address table RVA to pointer in local buffer
        mov eax D$esi+01C
        add eax D$ExportTableAdjust
        ; Convert code address to RVA
        mov ebx D@CodeAddress
        sub ebx D@BaseAddress

        ; ebx = Code RVA
        ; eax -> Address table (list of function RVA's)
        ; ecx = Number of functions

        mov D@ProcAddressRVA 0
        .If D@Exact = &TRUE

            mov D@ProcAddressRVA ebx
            While ecx > 0
                If D$eax = ebx
                    call SearchNameInExportTable
                    cmp edx 0 | je L8> ; function has no name (comctl32.dll !)
                    sub edx D@ExportBaseRVA
                    cmp edx D@ExportSize | ja L8> ; ignore invalid function name pointers (does happen!)
                    Do
                        mov al B$esi+edx
                        stosb
                        inc edx
                    Loop_until al = 0
                    jmp L9>>
                EndIf
                add eax 4
                dec ecx
            EndWhile
L8:         DwordToHex D@CodeAddress
            mov B$edi 0

        .Else

            While ecx > 0
                If D$eax <= ebx
                    mov edx D$eax
                    On edx > D@ProcAddressRVA,
                        mov D@ProcAddressRVA edx, D@AddressTableEntry eax
                EndIf
                add eax 4
                dec ecx
            EndWhile
            mov eax D@AddressTableEntry
            call SearchNameInExportTable
            If edx <> 0
                sub edx D@ExportBaseRVA
                cmp edx D@ExportSize | ja L8> ; ignore invalid function name pointers (does happen!)
                Do
                    mov al B$esi+edx
                    stosb
                    inc edx
                Loop_until al = 0
                dec edi
                mov D$edi ' (< ' | add edi 3
                mov edx ebx | sub edx D@ProcAddressRVA
                cmp edx 0_FFFF | ja L8> ; function bigger as 64k ??
                mov ecx 2 | call IntToHex
                mov W$edi ')'
            Else
L8:             mov D@ProcAddressRVA ebx
                mov al '<' | stosb
                DwordToHex D@CodeAddress
                mov B$edi 0
            EndIf
        .EndIf

L9: VirtualFree D$PEBuffer

    mov eax D@ProcAddressRVA
    add eax D@BaseAddress
EndP

[ExportTableAdjust: ?]

; Input
;   esi -> copied Export section
;   eax -> Address table entry
;   ecx = Number of functions
; Output
;   edx = Name RVA  /  zero (no name in export table -ordinal only-)

SearchNameInExportTable:
    mov edx 0
    push eax ecx edi
        sub eax D$ExportTableAdjust ; convert back to RVA
        sub eax D$esi+01C | shr eax 2 ; eax = index of current function
        mov ecx D$esi+018 ; ecx = number of names
        mov edi D$esi+024 | add edi D$ExportTableAdjust ; ordinal table
        repne scasw ; search the ordinal table
            jne L9>
        sub edi D$ExportTableAdjust
        sub edi D$esi+024 | shl edi 1
        add edi D$esi+020
        add edi D$ExportTableAdjust
        mov edx D$edi-4
L9: pop edi ecx eax
ret
____________________________________________________________________________________________

; Try to find out how many parameters are passed to the procedure. If a stackframe is
; found (entry sequence 55 8B EC), the code is scanned for the exit sequence [8B E5]5D | C9.
;
; After that the ret instruction tells how many bytes are removed from the stack, which
; is the number of params multiplied by 4:
;   ret       >> C3 (no params)
;   ret ####  >> C2 ## ##
; If there is a naked ret (C3) then either there are no parameters, or the params get
; removed by the caller (C_Call). Check the code at the return address for:
;   add esp imm >> 83 C4 ##
;
; If no stackframe is found, the assumption is made that no parameters were passed
; on the stack (which may not be true for some asm hardcore code-styles).

[ProcBuffer: ?]

[GUARD_BYTES 4] ; protect from dissassembler reading data below the ip ('op00')

Proc CountParametersAndScanStackFrame:
    Arguments @CSE
    Local @Procedure, @RetAddress, @Result, @Size, @NumLocals
    Uses edi, esi, ebx

    VirtualAlloc ProcBuffer, 01000

        mov D@Result 0

        mov eax D@CSE
        mov D$eax+CSE_NumParams 0
        move D@Procedure D$eax+CSE_ProcAddress
        mov eax D$eax+CSE_Address
        move D@RetAddress D$eax-4

        call IsProcessMemory D@Procedure
        On eax > 01000-GUARD_BYTES, mov eax 01000-GUARD_BYTES
        mov D@Size eax

        mov esi D$ProcBuffer | add esi GUARD_BYTES
        call ReadProcessMem D@Procedure, esi, D@Size
        On eax = &FALSE, jmp @Exit

        mov ecx D@Size
        sub ecx 16 ; guard bytes to prevent from disassembly overflow

      ; Stack frame?
        cmp B$esi 0C8   | je @WithStackFrame ; enter x x
        cmp W$esi 08B55 | jne @WithOutStackFrame
        cmp B$esi+2 0EC | jne @WithOutStackFrame
;;
    the proc-entry has the following structure:
    [in most API calls local and seh section exchanged]
    
    stackframe      push ebp        55
                    mov ebp esp     8B EC
                    
    locals          sub esp imm8/32 83/81 EC im
    
    SEH            (push imm32)     68 imm32 / 6A imm8
                   (push imm32)
                    push imm32
                    mov eax D$fs:0  64 A1 00 00 00 00
                    push eax        50
                    mov D$fs:0 esp  64 89 25 00 00 00 00                 
                   (push ecx)
                   (push ecx)
                   
    save regs       push ebx
                    ...
    
;;

@WithStackFrame:
        mov eax D@CSE | or B$eax+CSE_Flags CSEF_HAS_STACKFRAME

      ; Scan proc entry - size of local data in EBX. Local data is
      ; reserved with "sub esp xx" but also everything that is pushed
      ; _before_ the sub is considered as local data (SEH in Win32 code).

        mov ebx 4, edx 0 ; ebx = sizeof locals, edx = sizeof pushed data
        If B$esi = 0C8 ; enter x x
            add bx W$esi+1
        EndIf

        add esi 3 | sub ecx 3

L0:     call InstructionDecode esi
            If D$eax = 'push'
                add edx 4
            ElseIf D$eax = 'mov '
                ;nop
            ElseIf W$esi = 0EC83 ; sub esp b
                movzx eax B$esi+2
                add ebx eax
                add ebx edx
            ElseIf W$esi = 0EC81 ; sub esp dw
                mov eax D$esi+2
                add ebx eax
                add ebx edx
            Else
                jmp L1>
            EndIf
            mov eax D$InstructionLength
            sub ecx eax | js @Exit
            add esi eax
        jmp L0<

      ; Search exit sequence - might be 'pop ebp' / 'leave'
L1:     dec ecx | jz @Exit ; we need at min 2 bytes left (leave + ret)
            lodsb
            cmp al 05D | je L2> ; pop ebp
            cmp al 0C9 | je L2> ; leave
        jmp L1<

        ; mov esp ebp is not really necessary...
        ;cmp W$esi-3 0E58B | jne L1<

L2:     If B$esi = 0C3 ; ret
            ; C_Call ?
            call ReadProcessMem D@RetAddress, D$ProcBuffer, 4
            mov esi D$ProcBuffer
            cmp W$esi 0C483 | jne @Exit
            movzx eax B$esi+2
            shr eax 2
            mov D@Result eax
            jmp @Exit
        ElseIf B$esi = 0C2 ; ret imm
            movzx eax W$esi+1
            shr eax 2
            mov D@Result eax
            jmp @Exit
        Else ; no ret, maybe data mistaken as exit sequence?
            mov edx 0DEADC0DE ; debug (I-was-here) marker
            jmp L1<
        EndIf
        jmp @Exit

@WithOutStackFrame:
        ; No stack-frame, decode every instruction to find the ret.

L1:     ; Do not scan behind the end of code, may happen if there is a function
        ; without ret (e.g. Main: [...] call 'Kernel32.ExitProcess')

        mov ebx 0
        On D$esi = 0, jmp @Exit
        call InstructionDecode esi
        .If W$eax = 're' ; must be re(t)
            If B$esi = 0C3 ; ret
                ; C_Call ?
                call ReadProcessMem D@RetAddress, D$ProcBuffer, 4
                mov esi D$ProcBuffer
                cmp W$esi 0C483 | jne @Exit
                movzx eax B$esi+2
                shr eax 2
                mov D@Result eax
                jmp @Exit
            ElseIf B$esi = 0C2 ; ret imm
                movzx eax W$esi+1
                shr eax 2
                mov D@Result eax
                jmp @Exit
            Else ; ???
                jmp @Exit
            EndIf
        .EndIf
        add esi D$InstructionLength
        sub ecx D$InstructionLength | jns @WithOutStackFrame
        jmp @Exit

@Exit:
    VirtualFree D$ProcBuffer

    mov eax D@CSE
    move D$eax+CSE_NumParams D@Result
    shr ebx 2
    move D$eax+CSE_NumLocals ebx
EndP
____________________________________________________________________________________________

[StackFragment: B$ ? #32]

Proc ScanStackForCodePointer:
    Arguments @StackPointer
    Local @StackSize, @Pointer, @Offset
    Uses ebx esi edi

        ; Get size of current stack
        mov edi D@StackPointer
        call IsProcessMemory edi
        mov D@StackSize eax
        mov ebx 32
        mov D@Offset 0

        ; Read stack in 32byte fragments
        While D@StackSize >s 0
            On D@StackSize < ebx,
                mov ebx D@StackSize
            call 'KERNEL32.ReadProcessMemory' D$PI.hProcess, edi, StackFragment, ebx, &NULL
            sub D@StackSize ebx
            add edi ebx
            mov ecx ebx
            shr ecx 2 | jecxz L2> ; Bug fix Betov.
            mov esi StackFragment
L1:         lodsd
                mov D@Pointer eax
                ;call IsProcessCode eax
                push ecx ; bugfix V2.0b
                    call CheckReturnAddress eax
                pop ecx
                cmp eax &TRUE | je L2>
                add D@Offset 4
            loop L1<
        End_While
        mov D@Pointer 0

L2:     mov eax D@Pointer
        mov edx D@Offset
EndP

Proc CheckReturnAddress:
    Arguments @Address
    Local @Result
    Structure @Dummy SizeOf_CSE

    call IsProcessCode D@Address
    If eax = 1
        pushad
            call IsReturnAddressInSource D@Address, D@Dummy
            mov D@Result eax
        popad
        mov eax D@Result
    EndIf
EndP
____________________________________________________________________________________________

; Nothing works for fully close the Debuggee. Something remain attached:

CloseProcess:
    call 'KERNEL32.GetExitCodeProcess' D$PI.hProcess, ExitCode
    call 'KERNEL32.TerminateProcess'  D$PI.hProcess, D$ExitCode

    call 'KERNEL32.CloseHandle' D$PI.hThread       ; should be of
    call 'KERNEL32.CloseHandle' D$PI.hProcess      ; no use.
ret
____________________________________________________________________________________________

; TODO
;  * write back real opcodes (into copy!) when reading code sections with dynamic breakpoints inside
;  * reading beyond 2GB in Win9x ? if yes, just return ptr as this section is global

Proc ReadProcessMem:
    Arguments @Source, @Dest, @Size
    Uses ebx esi

    call 'KERNEL32.ReadProcessMemory' D$PI.hProcess, D@Source, D@Dest, D@Size, &NULL
    On eax = 0, ExitP

    ; Iterate through breakpoint-table, write back real opcodes
    mov esi D$BPTable, ecx D$NumBreakpoints
L0: While ecx > 0
        mov eax D$esi
        .If eax >= D@Source
            sub eax D@Source ; eax = offset into buffer
            If eax < D@Size
                mov edx D@Dest
                mov bl B$esi+7
                mov B$edx+eax bl ; restore original byte
            EndIf
        .EndIf
        add esi 8
        dec ecx
    EndWhile

    mov eax 1
EndP
____________________________________________________________________________________________

Proc WriteProcessMem:
    Arguments @Dest @Source @Size

    call 'KERNEL32.WriteProcessMemory' D$PI.hProcess, D@Dest, D@Source, D@Size, &NULL
    If eax = &TRUE
      ; should not be needed on x86
        call 'KERNEL32.FlushInstructionCache' D$PI.hProcess, D@Dest, D@Size
    EndIf
EndP
____________________________________________________________________________________________

[ExitCode: ?]

[NumberOfBytesRead: ?]


;;
SetCodeRVA:
    move D$DebugBaseOfCode D$CPDI.lpBaseOfImage

    VirtualAlloc DebugHeaderImage 0400 | mov D$NumberOfBytesRead 0

    call 'KERNEL32.ReadProcessMemory' D$CPDI.hProcess, D$DebugBaseOfCode,
                                     D$DebugHeaderImage, 0400,  NumberOfBytesRead
    mov edi D$DebugHeaderImage, al '.', ecx 0400
L0: repne scasb | jne L9>
       cmp D$edi 'text' | jne L0<
           dec edi
           mov eax D$edi+0C
           add D$DebugBaseOfCode eax
           move D$DebugCodeSize D$edi+8

L9: VirtualFree D$DebugHeaderImage
ret
;;
____________________________________________________________________________________________

SignalDebugEvent:
    mov B$IsDebugEvent &TRUE
    call 'User32.PostMessageA' D$DebugDialogHandle, WM_DEBUGEVENT, 0, 0
    call 'Kernel32.WaitForSingleObject' D$UserInputEvent, &INFINITE
    mov B$IsDebugEvent &FALSE
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

WATCHPOINTS:

; Watchpoints mean everything in RosAsm that uses the debug registers (DR0-DR7).
____________________________________________________________________________________________

; Mutex to control access to shared WP data structures of debug thread and UI thread.
; To prevent deadlocks, do not make API calls while holding the mutex.

[WPSynchMutex: ?]

; Maps to the debug registers DR0, DR1, DR2, DR3, DR7. All r/w access must be protected
; by WPSynchMutex. These values are written by the UI thread and read by the debug thread.
; Exception is WPChanged which is set to 1 by UI and zeroed by the debugger.

[WPSlot0: ?     ; DR0
 WPSlot1: ?     ; DR1
 WPSlot2: ?     ; DR2
 WPSlot3: ?     ; DR3
 WPControl: ?   ; DR7
 WPChanged: ?]  ; Signal changed data
____________________________________________________________________________________________

; Init data and mutex - called by resource manager thread.

InitWatchpointResources:
    mov eax 0
    mov D$WPSlot0 eax
    mov D$WPSlot1 eax
    mov D$WPSlot2 eax
    mov D$WPSlot3 eax
    mov D$WPControl eax
    mov D$WPChanged eax
    call 'Kernel32.CreateMutexA' 0, 0, 0
    mov D$WPSynchMutex eax
    If eax = 0
        call ReportWinError {'CreateWPMutex' 0}
        mov eax 0
    EndIf
ret
____________________________________________________________________________________________

; Destroy mutex and clear data fields - called by resource manager thread.

FreeWatchpointResources:
    call 'KERNEL32.CloseHandle' D$WPSynchMutex
    mov eax 0
    mov D$WPSlot0 eax
    mov D$WPSlot1 eax
    mov D$WPSlot2 eax
    mov D$WPSlot3 eax
    mov D$WPControl eax
    mov D$WPChanged eax
ret
____________________________________________________________________________________________

; Add watchpoint - called by UI.

Proc SetWatchPoint:
    Arguments @Address, @Size, @ReadWrite

    call 'KERNEL32.WaitForSingleObject' D$WPSynchMutex, &INFINITE

        mov eax D@Address
        mov D$WPSlot0 eax
        and D$WPControl 0_FFF0_FFFF
        or  D$WPControl 1 ; activate DR0
        mov eax D@ReadWrite
        and eax 0011
        shl eax 16
        or  D$WPControl eax
        If eax <> 0
            ; 00 1-byte length
            ; 01 2-byte length
            ; 10 Undefined
            ; 11 4-byte length
            mov eax D@Size | dec eax
            shl eax 18
            or  D$WPControl eax
        EndIf

        mov D$WPChanged 1

    call 'KERNEL32.ReleaseMutex' D$WPSynchMutex
EndP
____________________________________________________________________________________________

; Delete watchpoint - called by UI.

Proc DeleteWatchPoint:
    call 'KERNEL32.WaitForSingleObject' D$WPSynchMutex, &INFINITE

        and D$WPControl 0_FFF0_FFFE
        mov D$WPSlot0 0

        mov D$WPChanged 1

    call 'KERNEL32.ReleaseMutex' D$WPSynchMutex
EndP
____________________________________________________________________________________________

; Take over any changed values into thread context structure - called by debugger.

Proc TransferWatchpoints:
    call 'KERNEL32.WaitForSingleObject' D$WPSynchMutex, &INFINITE

        move D$C.iDr0 D$WPSlot0
        move D$C.iDr1 D$WPSlot1
        move D$C.iDr2 D$WPSlot2
        move D$C.iDr3 D$WPSlot3
        move D$C.iDr7 D$WPControl

        mov D$WPChanged 0

    call 'KERNEL32.ReleaseMutex' D$WPSynchMutex
EndP
____________________________________________________________________________________________

; Test if address is watched - called by UI.
; No need to use the mutual exclusion here as the debug thread doesn't write to the fields.

Proc IsWatchPoint:
    Arguments @Address

    mov eax D@Address
    If eax = D$WPSlot0
        mov eax D$WPControl
        shr eax 16
        and eax 0011
    Else
        mov eax 0
    EndIf
EndP
____________________________________________________________________________________________

; Test if a watched data access has taken place - called by debugger.

Proc EncounterWatchPoint:

    test D$C.iDr6 01 | jz L9>

    mov D$DebugEventType DET_WP
    move D$WatchedAddress D$C.iDr0
    dec D$SourcePosCodeAddress

  ; clear status
    mov D$C.iDr6 0
L9:
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; BREAKPOINTS

; Every breakpoint is saved in the breakpoint table. An entry has the following structure:
; DWORD Address
; BYTE  Type (see type flags)
; BYTE  State (see state flags)
; BYTE  Reserved (can be used for bp-group ids)
; BYTE  Overwritten byte

[BPTable: ? NumBreakpoints: ?]

; Type flags
[BP_STATIC 0 BP_STATIC2BYTE 01 BP_DYNAMIC 02 BP_ONESHOT 04]
; State flags
[BP_ENABLED 1 BP_DISABLED 0 BP_ISPENDING 2]

; BPPending has the address of a dynamic breakpoint that is currently deactivated to
; execute the real code that was overwritten by the bp-op.
; Otherwise it is zero- indicating that no BP must be written back to process mem ATM.
[BPPending: ?]

CreateBPTable:
    VirtualFree D$BPTable
    VirtualAlloc BPTable, 01_0000 ; 64k table
    mov D$NumBreakpoints 0
    mov D$BPPending 0
ret

DestroyBPTable:
    mov D$BPPending 0
    mov D$NumBreakpoints 0
    VirtualFree D$BPTable
ret

[RunAfterWriteBack: ?]
____________________________________________________________________________________________

; Add breakpoint to table and, if enabled, to process memory.

Proc AddProcessBreakpoint:
    Arguments @Address, @Type, @State, @GroupID
    Uses edi

        mov edi D$BPTable, ecx D$NumBreakpoints
        lea edi D$edi+ecx*8

        mov eax D@Address   | stosd
        mov al B@Type       | stosb
        mov al B@State      | stosb
        mov al B@GroupID    | stosb

        .If B@Type <> BP_STATIC
            call ReadProcessMem D@Address, edi, 1
            If B@State = BP_ENABLED
                call WriteProcessMem D@Address, BreakpointOp, 1
            EndIf
        .Else
            If B@State = BP_DISABLED
                mov B$ByteBuf 090
                call WriteProcessMem D@Address, ByteBuf, 1
            EndIf
        .EndIf
        inc D$NumBreakpoints

        ;call 'Kernel32.OutputDebugStringA' {'BP manager: BP added' 0}
EndP
____________________________________________________________________________________________

; Delete breakpoint from table and from process memory.

Proc DeleteProcessBreakpoint:
    Arguments @Address
    Uses esi

        On D$NumBreakpoints = 0, jmp L9>>

        ; save last entry on stack, search for breakpoint in table, do the cleanup
        ; work (write back process memory), and overwrite entry with last one from stack
        mov esi D$BPTable, ecx D$NumBreakpoints, eax D@Address
        dec ecx
        push D$esi+ecx*8, D$esi+ecx*8+4
            While D$esi <> eax
                add esi 8
                dec ecx | js L9>
            EndWhile

            .If B$esi+5 = BP_ENABLED
                If B$esi+4 <> BP_STATIC
                    mov al B$esi+7
                Else
                    mov al 090
                EndIf
                mov B$ByteBuf al
                call WriteProcessMem D@Address, ByteBuf, 1

            .ElseIf B$esi+5 = BP_ISPENDING
                ; fix: if breakpoint is currently deactivated and waits for write-back
                ; the write-back command must be killed with the breakpoint
                mov D$BPPending 0
            .EndIf

        pop D$esi+4, D$esi
        dec D$NumBreakpoints
        ;call 'Kernel32.OutputDebugStringA' {'BP manager: BP deleted' 0}
        ExitP

L9:     call 'User32.MessageBoxA' D$hwnd, {'Tried to delete non-existing breakpoint!' 0},
                                  {'Debugger error' 0}, &MB_ICONERROR
EndP
____________________________________________________________________________________________

; When [Hold On Breakpoint] is deactivated we disable all known breakpoints and delete
; all oneshot breakpoints.

Proc DisableProcessBreakpoints:
    Uses esi, edi

        ; Iterate through breakpoint-table, delete oneshot and disable all other bp's.
        mov esi D$BPTable, edi D$NumBreakpoints
L0:     While edi > 0
            If B$esi+4 = BP_ONESHOT
                call DeleteProcessBreakpoint D$esi
                dec edi
                jmp L0<
            ElseIf B$esi+4 = BP_DYNAMIC
                mov B$esi+5 BP_DISABLED
                lea eax D$esi+7
                call WriteProcessMem D$esi, eax, 1
            ElseIf B$esi+4 = BP_STATIC
                mov B$esi+5 BP_DISABLED
                mov B$ByteBuf 090
                call WriteProcessMem D$esi, ByteBuf, 1
            EndIf
            add esi 8
            dec edi
        EndWhile
        mov B$BreakpointsEnabled &FALSE
EndP
____________________________________________________________________________________________

; When [Hold On Breakpoint] is reactivated we enable all known breakpoints

Proc EnableProcessBreakpoints:
    Uses esi, ebx

        ; Iterate through breakpoint-table, write breakpoint ops to process memory.
        mov esi D$BPTable, ebx D$NumBreakpoints ; bugfix V2.0b
L0:     While ebx > 0
            call WriteProcessMem D$esi, BreakpointOp, 1
            mov B$esi+5 BP_ENABLED
            add esi 8
            dec ebx
        EndWhile
        mov B$BreakpointsEnabled &TRUE
EndP
____________________________________________________________________________________________

; Deal with encountered breakpoints. Adjusts EIP according to breakpoint type.

Proc EncounterBreakpoint:
    Uses esi, ebx

        ; Search breakpoint in table
        mov esi D$BPTable, ecx D$NumBreakpoints
        mov ebx D$C.regEip | dec ebx
        On ecx = 0, jmp L1>>
        While D$esi <> ebx
            add esi 8
            dec ecx | jz L1>>
        EndWhile

        ; One shot breakpoints are set by step-over, step-out and pause. The user will
        ; receive them as normal stepping (well...), so they are deleted as soon as they are hit.
        ; They can be grouped (for pause), so that if one is hit all others in the group
        ; are deleted with it.
        .If B$esi+4 = BP_ONESHOT
            lea eax D$esi+7
            call WriteProcessMem ebx, eax, 1
            If B$esi+6 <> 0
                movzx eax B$esi+6
                call KillBreakpointGroup eax
            Else
                call DeleteProcessBreakpoint ebx
            EndIf
            dec D$C.regEIP, D$SourcePosCodeAddress

        ; Dynamic breakpoints are user-defined which appear as bp-marks in the source
        ; editor. When encountered the original operation must be restored, executed
        ; (single-stepped), and written back when the next SINGLE_STEP Debug event occurs.
        .Else_If B$esi+4 = BP_DYNAMIC
            lea eax D$esi+7
            call WriteProcessMem ebx, eax, 1
            mov B$esi+5 BP_ISPENDING
            If B$HoldOnBreakpoints = &TRUE
                mov D$BPPending esi
            EndIf
            ; Weird case when a 'int 3' is marked with a breakpoint. It would loop into infinity
            ; so we just skip over it.
            On B$esi+7 <> 0CC,
                dec D$C.regEIP, D$SourcePosCodeAddress

        ; Static breakpoints need not to be dealt with. Execution can continue
        .EndIf

        ExitP

L1:     ; New static breakpoint encountered.
        call AddProcessBreakpoint ebx, BP_STATIC, D$HoldOnBreakpoints, 0
EndP
____________________________________________________________________________________________

Proc KillBreakpointGroup:
    Arguments @GroupID
    Uses esi, edi, ebx

        ; Search breakpoint with given group-id in table. If one is found, delete it.
        mov esi D$BPTable, edi D$NumBreakpoints, ebx D@GroupID
L0:     While edi > 0
            If B$esi+6 = bl
                call DeleteProcessBreakpoint D$esi
                dec edi
                jmp L0<
            EndIf
            add esi 8
            dec edi
        EndWhile
EndP
____________________________________________________________________________________________

; Interrupts the execution of a thread by setting a breakpoint at the location pointed at by
; the instruction pointer. If it is outside of process code, the stack is scanned for a
; valid code pointer.

Proc HaltThread:
    Arguments @ThreadHandle

        call 'KERNEL32.SuspendThread' D@ThreadHandle
        mov D$C.ContextFlags MY_CONTEXT_FULL
        call 'KERNEL32.GetThreadContext' D@ThreadHandle, Context
        call IsProcessCode D$C.regEip
        .If eax = &TRUE
            call AddProcessBreakpoint D$C.regEip, BP_ONESHOT, BP_ENABLED, 0
        .Else
            call ScanStackForCodePointer D$C.regEsp
            If eax <> 0
                call AddProcessBreakpoint eax, BP_ONESHOT, BP_ENABLED, 0
            EndIf
        .EndIf
        call 'Kernel32.ResumeThread' D@ThreadHandle
EndP
____________________________________________________________________________________________

; SYNCHRONIZE BREAKPOINTS WITH SOURCE EDITOR

[BPAnteroom: ? BPSyncMutex: ?]

CreateBPAnteroom:
    call 'Kernel32.CreateMutexA' 0, 0, 0
    mov D$BPSyncMutex eax
    VirtualAlloc BPAnteroom 01000

    ;call 'Kernel32.OutputDebugStringA' {'BP synch: Created BP synch objects' 0}
ret

DestroyBPAnteroom:
    VirtualFree D$BPAnteroom
    call 'KERNEL32.CloseHandle' D$BPSyncMutex

    ;call 'Kernel32.OutputDebugStringA' {'BP synch: Destroyed BP synch objects' 0}
ret

; Copy initial set of breakpoints from the "OnTable" to the Anteroom. This proc is
; called before the debugger thread starts so we don't need to sync with the mutex.

InitialFillBPAnteroom:
    On D$BPOnTable = 0, ret
    ;call 'KERNEL32.WaitForSingleObject' D$BPSyncMutex, &INFINITE
    mov esi D$BPOnTable
    mov edi D$BPAnteroom
    While D$esi <> 0
        movsd
        mov eax &TRUE
        stosd
        call 'Kernel32.OutputDebugStringA' {'BP synch: BP set' 0}
    EndWhile
    ;call 'KERNEL32.ReleaseMutex' D$BPSyncMutex
    ;call 'Kernel32.OutputDebugStringA' {'BP synch: Initial fill complete' 0}
ret

; FILL Anteroom: This proc is called by the UI thread (RosAsm's mainthread)

Proc AddBPToAnteroom:
    Arguments @Address @Set

        On edi = 0, ExitP

        call 'KERNEL32.WaitForSingleObject' D$BPSyncMutex, &INFINITE
        mov edi D$BPAnteroom
        While D$edi <> 0
            add edi 8
        EndWhile
        move D$edi D@Address
        move D$edi+4 D@Set
        call 'KERNEL32.ReleaseMutex' D$BPSyncMutex

        ;call 'Kernel32.OutputDebugStringA' {'BP synch: BP set' 0}
EndP

; CLEAR Anteroom: This proc is called by the debugger thread

Proc ClearBPAnteroom:
    call 'KERNEL32.WaitForSingleObject' D$BPSyncMutex, &INFINITE
    mov edi D$BPAnteroom
    While D$edi <> 0
        call GetcodeBreakPointPosFromSourcePointer D$edi
        If D$edi+4 = &TRUE ; add breakpoint
            call AddProcessBreakpoint eax, BP_DYNAMIC, D$HoldOnBreakpoints, 0
        Else
            call DeleteProcessBreakpoint eax
        EndIf
        mov D$edi 0, D$edi+4 0
        add edi 8
    EndWhile
    call 'KERNEL32.ReleaseMutex' D$BPSyncMutex

    ;call 'Kernel32.OutputDebugStringA' {'BP synch: Anteroom cleared' 0}
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; ADDRESS SPACE ROUTINES
____________________________________________________________________________________________
____________________________________________________________________________________________

[PageOffsetMask     PageSize-1]
[PageBaseMask       0_FFFF_F000]

[AddressLowerBound:  0_1000]
[AddressUpperBound:  0_7FFF_0000]

[MemoryInformation:
 @BaseAddress: ?
 @AllocationBase: ?
 @AllocationProtect: ?
 @RegionSize: ?
 @State: ?
 @Protect: ?
 @Type: ?]

; Wrap routine for VirtualQueryEx
;   Parameter
;       Virtual Address
;   Output
;       EAX : 1=commited 0=free -1=error
;       ECX : region size

Proc VirtualQuery:
    Arguments @Address

        mov eax D@Address
        If eax >= D$AddressUpperBound
            mov eax &FALSE
            ExitP
        EndIf

        call 'KERNEL32.VirtualQueryEx' D$PI.hProcess, D@Address, MemoryInformation, 28
        If eax <> 28
            mov eax 0-1
            ;call ReportWinError {'VirtualQueryEx reported error:' 0}
            ExitP
        EndIf

        ; There is a bug in the implementation of VirtualQuery under WinNT.
        ; Jeffrey Richter has written a workaround (see VMMap in his book) which I
        ; implemented here.
        test D$MemoryInformation@AllocationBase 0FFF | jz L0>
        inc D$MemoryInformation@AllocationBase

L0:     test D$MemoryInformation@RegionSize 0FFF | jz L0>
        inc D$MemoryInformation@RegionSize

L0:     .If D$MemoryInformation@State <> &MEM_FREE
            If D$MemoryInformation@AllocationProtect = 0
                mov D$MemoryInformation@AllocationProtect &PAGE_READONLY
            EndIf
        .EndIf

        mov ecx D$MemoryInformation@RegionSize

        If D$MemoryInformation@State = &MEM_COMMIT
            mov eax &TRUE
        Else
            mov eax &FALSE
        Endif
EndP
____________________________________________________________________________________________

; Determines if the address points to a commited page in the debuggees address space.
; Returns the size of the block starting at the given address in eax.

Proc IsProcessMemory:
    Arguments @Address
    Local @Offset

        ; Offset from start of Page
        mov eax D@Address
        and eax PageOffsetMask
        mov D@Offset eax
        ; Page address
        mov edx D@Address
        sub edx eax
        ; Query information for corresponding page:
        ;  * if eax is 1 the page was commited
        ;  * ecx contains the number of commited bytes from the page address
        call VirtualQuery edx
        If eax = 1
            mov eax ecx
            sub eax D@Offset
        Else
            mov eax 0
        EndIf
EndP
____________________________________________________________________________________________

Proc FindNextPage:
    Arguments @Address
    Uses ebx

        ; align address on page boundary
        mov ebx D@Address
        and ebx PageBaseMask
        add ebx PageSize
        If ebx >= D$AddressUpperBound
            mov eax 0
            ExitP
        EndIf
        ; advance the regions until a commited page is found or the upper bound is met
        call VirtualQuery ebx
        While eax = 0
            add ebx ecx
            If ebx >= D$AddressUpperBound
                mov eax 0
                ExitP
            EndIf
            call VirtualQuery ebx
            If eax = 0-1
                xor eax eax
                ExitP
            EndIf
        EndWhile
        If eax = 0-1
            xor eax eax
        Else
            mov eax ebx
        EndIf
EndP
____________________________________________________________________________________________

Proc FindPrevPage:
    Arguments @Address
    Uses ebx

        ; align address on page boundary
        mov ebx D@Address
        and ebx PageBaseMask
        sub ebx PageSize
        If ebx < D$AddressLowerBound
            mov eax 0
            ExitP
        EndIf
        ; advance the regions until a commited page is found or the upper bound is met
        call VirtualQuery ebx
        While eax = 0
            sub ebx PageSize
            If ebx < D$AddressLowerBound
                mov eax 0
                ExitP
            EndIf
            call VirtualQuery ebx
        EndWhile
        If eax = 0-1
            xor eax eax
        Else
            mov eax ebx
        EndIf
EndP
____________________________________________________________________________________________

Proc IsProcessCode:
    Arguments @Address

        mov eax &FALSE
        mov edx D$DebugBaseOfCode
        If D@Address >= edx
            add edx D$DebugCodeSize
            On D@Address < edx, mov eax &TRUE
        EndIf
EndP
____________________________________________________________________________________________

Proc IsProcessStack:
    Arguments @Address

        mov eax D@Address
        .If eax >= D$C.regEsp
            call IsProcessMemory D$C.regEsp
            mov edx D@Address
            sub edx D$C.regEsp
            If edx < eax
                mov eax &TRUE
            Else
                mov eax &FALSE
            EndIf
        .Else
            mov eax &FALSE
        .EndIf
EndP


____________________________________________________________________________________________
____________________________________________________________________________________________

; Source Editor integration
____________________________________________________________________________________________
____________________________________________________________________________________________

OldSourceDebugPos:
    mov ebx D$C.regEip | sub ebx D$DebugBaseOfCode

    mov esi D$IpTable, ecx D$IpTablePtr, D$StatementsCounter 0
    sub ecx esi | shr ecx 2

    If D$E.ExceptionCode = &EXCEPTION_BREAKPOINT
       ; mov W$DD_Dims 0C
    Else_If D$E.ExceptionCode = &EXCEPTION_SINGLE_STEP
       ; mov W$DD_Dims 0C
    Else
      ;  mov W$DD_Dims 0B |
      inc D$StatementsCounter              ; hide [Step]
    End_If


L0: lodsd | inc D$StatementsCounter | cmp eax ebx | je L2>
                                                    ja L1>
    loop L0<

    jmp L2> ; If last one, don't dec!!!

  ; ret  ; Abort if faultive statement  not found (????????!!!!!!!!!)
  ; or >>> point end of source ???

L1: dec D$StatementsCounter

L2: move D$StatementsPtr D$StatementsTable
    mov eax D$StatementsCounter | dec eax ;| dec eax |
    shl eax 2
    add D$StatementsPtr eax

    call SetEndOfErrorText | call SetDebuggeeText | call AskForRedraw
ret
____________________________________________________________________________________________

;[ApiWarningDone: ?]

[SourcePos: ?]

;;
  Two parallel Tables:
  
* 'IpTable': Each Record is the Displacement for the Origin of Code (for each encoded
  Instruction. In case of Labels (That _are_ parsed by the Encoder, the Label and the
  relative Instruction are both recorded, with the same Displacement).
  
* 'StatementsTable': Each Record is a Pointer to Source Statement. For example, in cases
  of
  
  > mov eax 1, ebx 2, ecx 3
  
  there will be only one Pointer, in 'StatementsTable', that is a Pointer to this 'm'
  Char inside the user Source.
;;

[SourcePosCodeAddress: ?]

Proc SourceDebugPos:
    Arguments @CodeAddress

    call RestoreRealSource

    mov ebx D@CodeAddress | sub ebx D$DebugBaseOfCode

    mov esi D$IpTable, ecx D$IpTablePtr | sub ecx esi | shr ecx 2

    move D$StatementsPtr D$StatementsTable
;;
  Cases of critical error: C_regEip is not update (eip yet pointing to the faultive
  instruction).
  
  Cases of Int 3 and Stepping: The instruction is executed and C_regEip is updated
  (pointing to the next Instruction).
;;
    call ActualDebugPos

  ; eax = 'StatementsPtr' >>> Pointing to a Source Pos Record in 'StatementsTable'.
    mov eax D$eax

    mov D$SourcePos eax ; <<< for stepping

    .If eax <> 0
        ;mov B$ApiWarningDone &FALSE
L5:     call SetEndOfErrorText | call SetDebuggeeText | call AskForRedraw

    .Else_If D$E.ExceptionCode <> &EXCEPTION_SINGLE_STEP
      ; Error outside > Point to end of Source:
        sub D$StatementsPtr 4 | jmp L5<

    .End_If

    call SetPartialEditionFromPos
EndP


ActualDebugPos:
L0: lodsd

    .If eax = ebx
      ; Cases of Labels in the 'IpTable':
L1:     While D$esi = eax | add esi 4 | add D$StatementsPtr 4 | End_While
        jmp L2>

    .Else_If eax > ebx
        sub D$StatementsPtr 4 | jmp L2>

    .End_If

    add D$StatementsPtr 4 | loop L0<

L2: mov eax D$StatementsPtr
    If eax < D$StatementsTable
        mov eax D$StatementsTable | add D$StatementsPtr 4
    End_If
ret

PreviousDebugPos:
L0: lodsd

    .If eax => ebx
        sub D$StatementsPtr 4 | jmp L2>
    .End_If

    add D$StatementsPtr 4 | loop L0<

L2: mov eax D$StatementsPtr
    If eax < D$StatementsTable
        mov eax D$StatementsTable | add D$StatementsPtr 4
    End_If
ret
____________________________________________________________________________________________

____________________________________________________________________________________________

[CodeBuf: B$ ? #32]

NextInstructionDecode:
    call 'Kernel32.ReadProcessMemory' D$PI.hProcess, D$C.regEip, CodeBuf,
                                      32, NumberOfBytesRead
    call InstructionDecode CodeBuf
ret
____________________________________________________________________________________________

[InstructionLength: ?]
[DecodedInstruction: B$ ? #50]
[NextInstructionPtr: ?]

Proc InstructionDecode:
    Arguments @CodeBuffer

    pushad

    ; Clear buffer, set disassembler flags for simple decode and feed the disassembler
    ; with the code in the codebuffer.

    mov edi DecodedInstruction, ecx 50, eax 0
    rep stosb

    mov B$SimpleScan &TRUE, D$LastCodeRef 0
    mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
    mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
    mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
    mov B$WithCommentedHexa &FALSE

    mov esi D@CodeBuffer, edi DecodedInstruction
    add edi 10 ; disassembler sometimes writes in front of edi, reserve 10 guard bytes
L0: movzx eax B$esi | inc esi | call D$DisOp1+eax*4
    On B$DisFlag = DISDONE, jmp L0<
    mov D$edi 0
    sub esi D@CodeBuffer | mov D$InstructionLength esi
    mov B$SimpleScan &FALSE

  ; Dirty method to find the real beginning of the instruction string:
    .If D$LastCodeRef <> 0
        If B$edi-1 = '$'
            mov eax D$LastCodeRef | call WriteEax
        End_If
    .End_If

    mov edi DecodedInstruction, ecx 50, eax 0
    repe scasb | dec edi
L1: If B$edi = ' '
        inc edi | jmp L1<
    ElseIf B$edi = '|'
        inc edi | jmp L1<
    EndIf
    mov D$NextInstructionPtr edi

    popad

    mov eax D$NextInstructionPtr
EndP
____________________________________________________________________________________________

IsMultiStepInstruction:
    mov esi D$NextInstructionPtr
    lodsd
    If eax = 'call'
        mov eax 1 | ret
    EndIf
    and eax 0FF_FFFF
    If eax = 'rep'
        mov eax 1 | ret
    EndIf
    mov eax 0
ret
____________________________________________________________________________________________

[CPUName: B$ ? #48]
[CPUVendor: B$ ? #16]
[CPUFlags: ? CPUFlagsEx: ?]

[FLAG_FPU 1 FLAG_CMOV 0_8000 FLAG_MMX 080_0000 FLAG_SSE 0200_0000 FLAG_SSE2 0400_0000]
[FLAG_EX_MMX 040_0000 FLAG_EX_3DNOW 0_4000_0000 FLAG_EX_3DNOWEX 0_8000_0000]

Proc TestCpuFeatures:
    Local @MaxFunc @MaxExFunc

    mov D$CPUFlags 0, D$CPUFlagsEx 0, B$CPUName 0

    ; Check if CPUID instruction is available
    pushfd | pop eax
    mov ebx eax
    xor eax 0200000
    push eax | popfd
    pushfd | pop eax

    .If eax <> ebx
        mov eax 0
        cpuid
        mov D@MaxFunc eax
        mov D$CPUVendor ebx, D$CPUVendor+4 edx, D$CPUVendor+8 ecx, D$CPUVendor+12 0
        ; Get general flags
        If D@MaxFunc >= 1
            mov eax 1
            cpuid
            mov D$CPUFlags edx
        End_If

        mov eax 0_8000_0000
        cpuid
        mov D@MaxExFunc eax
        ; Extended flags
        If D@MaxExFunc >= 0_8000_0001
            mov eax 0_8000_0001
            cpuid
            mov D$CPUFlagsEx edx
        End_If
        ; CPU name
        If D@MaxExFunc >= 0_8000_0004
            mov eax 0_8000_0002
            cpuid
            mov D$CPUName eax, D$CPUName+4 ebx, D$CPUName+8 ecx, D$CPUName+12 edx
            mov eax 0_8000_0003
            cpuid
            mov D$CPUName+16 eax, D$CPUName+20 ebx, D$CPUName+24 ecx, D$CPUName+28 edx
            mov eax 0_8000_0004
            cpuid
            mov D$CPUName+32 eax, D$CPUName+36 ebx, D$CPUName+40 ecx, D$CPUName+44 edx
        End_If
    .End_If
EndP

TITLE Exception

;;
    General exception handler.
    
    October 2004 - Ludwig Haehne - wkx@gmx.li
    
    Reports a description of the exception that occurred, writes a crash.log file
    and tries to save the source before RosAsm is terminated by the system. 
    
    TODO Create a crash dump (data, stack, context) that can be loaded on a different 
    machine to find the problem.
;;
____________________________________________________________________________________________

Proc FinalExceptionHandler:
    Arguments @ExceptionInfo
    Uses ebx esi edi

  ; Save whole source
    On B$RealSourceRestored = &FALSE, call RestoreRealSource
    mov B$WeAreSavingPart &FALSE | call SaveSource

    mov eax D@ExceptionInfo | call GetExceptionInfo D$eax
    mov eax D@ExceptionInfo | call WriteCrashLog D$eax D$eax+4

    call 'User32.MessageBoxA' 0, ExceptionMessage,
        {'RosAsm crashed' 0}, &MB_OK+&MB_ICONEXCLAMATION

    call 'KERNEL32.SetErrorMode' &SEM_NOGPFAULTERRORBOX

    mov eax &EXCEPTION_CONTINUE_SEARCH
EndP
____________________________________________________________________________________________


[ExceptionMessage:
"An exception occurred inside RosAsm. It must terminate now.

                    YOUR WORK IS NOT LOST!
                
Your source has been saved at the path of your application.
To continue working restart RosAsm, open your application
and replace the source.

Please post a bug report describing how to reproduce this
problem along with the crash.log (in the applications folder)
at RosAsm board.

Thank you and sorry for the inconvenience.

" ExceptionInfo: "Exception occurred at address " ExceptionAddress: "########.
" ExceptionDesc: B$ 0 #256]

[Exception_AV: 'Access Violation! Attempt to ' AV_ReadWrite: '######### address ' AV_Address: '########.' 0]
[Exception_other: 'Unknown exception. Code ' Exception_Code: '########' 0]

Proc GetExceptionInfo:
    Arguments @ExceptionRecord

    mov ebx D@ExceptionRecord

    mov edi ExceptionAddress
    DwordToHex D$ebx+12 ; Address

    mov eax D$ebx ; ExceptionCode

    .If eax = &EXCEPTION_ACCESS_VIOLATION
        mov eax D$ebx+20 ; read/write
        If eax = 0
            mov D$AV_ReadWrite 'read', D$AV_ReadWrite+4 ' fro', B$AV_ReadWrite+8 'm'
        Else
            mov D$AV_ReadWrite 'writ', D$AV_ReadWrite+4 'e at', B$AV_ReadWrite+8 ' '
        EndIf
        mov edi AV_Address
        DwordToHex D$ebx+24 ; inaccessible address
        mov esi Exception_AV
    .Else
        mov edi ExceptionCode
        DwordToHex D$ebx ; exc. code
        mov esi Exception_other
    .EndIf

    mov edi ExceptionDesc
    Do
        movsb
    Loop_until B$esi-1 = 0
EndP
____________________________________________________________________________________________

; Write a log-file which is really helpful.
;   * dump exception information (exc code, inaccessible address, access type)
;   * rosasm version
;   * OS information (NT/9x)
;   * register contents

[NewLineSeq: W$ 0A0D]

Proc EmitNewLine:
    Arguments @File

    call 'Kernel32.WriteFile' D@File, NewLineSeq, 2, BytesTransfered, 0
EndP

[RegContent: B$ 'Exx=12345678' 0D 0A]

Proc WriteCrashLog:
    Arguments @ExceptionRecord @Context
    Local @File

    call 'Kernel32.CreateFileA' {'crash.log' 0}, &GENERIC_WRITE, &FILE_SHARE_READ, 0,
        &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
    mov D@File eax

    .If D@File <> &INVALID_HANDLE_VALUE

      ; Output RosAsm version
        mov edi AppName | call StrLen
        mov edx AppName | add edx 2 | sub eax 2
        call 'Kernel32.WriteFile' D@File, edx, eax, BytesTransfered, 0
        call EmitNewLine D@File

      ; Output Windows version
        call GetWindowsVersionString
        mov edi WindowsVersion | call StrLen
        call 'Kernel32.WriteFile' D@File, WindowsVersion, eax, BytesTransfered, 0
        call EmitNewLine D@File
        call EmitNewLine D@File

      ; Output exception info
        mov edi ExceptionInfo | call StrLen
        call 'Kernel32.WriteFile' D@File, ExceptionInfo, eax, BytesTransfered, 0
        call EmitNewLine D@File
        call EmitNewLine D@File

      ; Output reg contents
        mov ebx D@Context

        mov edi RegContent | mov W$edi+1 'AX' | add edi 4
        DwordToHex D$ebx+0B0
        call 'Kernel32.WriteFile' D@File, RegContent, 14, BytesTransfered, 0

        mov edi RegContent | mov W$edi+1 'BX' | add edi 4
        DwordToHex D$ebx+0A4
        call 'Kernel32.WriteFile' D@File, RegContent, 14, BytesTransfered, 0

        mov edi RegContent | mov W$edi+1 'CX' | add edi 4
        DwordToHex D$ebx+0AC
        call 'Kernel32.WriteFile' D@File, RegContent, 14, BytesTransfered, 0

        mov edi RegContent | mov W$edi+1 'DX' | add edi 4
        DwordToHex D$ebx+0A8
        call 'Kernel32.WriteFile' D@File, RegContent, 14, BytesTransfered, 0

        mov edi RegContent | mov W$edi+1 'SI' | add edi 4
        DwordToHex D$ebx+0A0
        call 'Kernel32.WriteFile' D@File, RegContent, 14, BytesTransfered, 0

        mov edi RegContent | mov W$edi+1 'DI' | add edi 4
        DwordToHex D$ebx+09C
        call 'Kernel32.WriteFile' D@File, RegContent, 14, BytesTransfered, 0

        mov edi RegContent | mov W$edi+1 'BP' | add edi 4
        DwordToHex D$ebx+0B4
        call 'Kernel32.WriteFile' D@File, RegContent, 14, BytesTransfered, 0

        mov edi RegContent | mov W$edi+1 'SP' | add edi 4
        DwordToHex D$ebx+0C4
        call 'Kernel32.WriteFile' D@File, RegContent, 14, BytesTransfered, 0

        call 'Kernel32.CloseHandle' D@File
    .EndIf

EndP
____________________________________________________________________________________________

; Get windows version information. Original C code from MSDN converted to RosAsm.

[WindowsVersion: B$ ? #256]

[OSVersionInfo:
 OSVersionInfo.Size: D$ ?
 OSVersionInfo.MajorVersion: D$ ?
 OSVersionInfo.MinorVersion: D$ ?
 OSVersionInfo.BuildNumber: D$ ?
 OSVersionInfo.PlatformId: D$ ?
 OSVersionInfo.CSDVersion: B$ ? #128
 OSVersionInfo.ServicePackMajor: W$ ?
 OSVersionInfo.ServicePackMinor: W$ ?
 OSVersionInfo.SuiteMask: W$ ?
 OSVersionInfo.ProductType: B$ ?
 OSVersionInfo.Reserved: B$ ?]

[OSVI_SIZE 148 OSVI_EX_SIZE 156]

Win2003ServerProductType:
    mov ax W$OSVersionInfo.SuiteMask
    test ax &VER_SUITE_DATACENTER | jz L0>
        mov esi {'Datacenter Edition' 0} | ret
L0: test ax &VER_SUITE_ENTERPRISE | jz L0>
        mov esi {'Enterprise Edition' 0} | ret
L0: test ax 0400 | jz L0> ;&VER_SUITE_BLADE | jz L0>
        mov esi {'Web Edition' 0} | ret
L0: mov esi {'Standard Edition' 0}
ret

Win2000ServerProductType:
    test ax &VER_SUITE_DATACENTER | jz L0>
        mov esi {'Datacenter Server' 0} | ret
L0: test ax &VER_SUITE_ENTERPRISE | jz L0>
        mov esi {'Advanced Server' 0} | ret
L0: mov esi {'Server' 0}
ret

Proc TestWinNTSP6a:
    Local @Key

    .If D$OSVersionInfo.MajorVersion = 4
        lea eax D@Key
        call 'ADVAPI32.RegOpenKeyExA' &HKEY_LOCAL_MACHINE,
            {'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Hotfix\Q246009' 0},
            0, &KEY_QUERY_VALUE, eax

        If eax = &ERROR_SUCCESS
            mov al 'a' | stosb
        EndIf

        call 'ADVAPI32.RegCloseKey' D@Key
    .EndIf
EndP

[WinNTProductType: B$ ? #80 WinNTPTLen: D$ ?]

Proc GetWindowsProductInfo:
    Local @Key

    mov esi 0

    mov D$OSVersionInfo.Size OSVI_EX_SIZE
    call 'Kernel32.GetVersionExA' OSVersionInfo
    ...If eax = 1

      ; workstation
        ..If W$OsVersionInfo.ProductType = &VER_NT_WORKSTATION
            .If D$OSVersionInfo.MajorVersion = 4
                mov esi {'Workstation 4.0' 0}
            .Else
                mov ax W$OSVersionInfo.SuiteMask
                and ax 0200 ;&VER_SUITE_PERSONAL
                If ax <> 0
                    mov esi {'Home Edition' 0}
                Else
                    mov esi {'Professional' 0}
                EndIf
            .EndIf

       ; server
         ..Else
            .If D$OSVersionInfo.MajorVersion = 5
                If D$OSVersionInfo.MinorVersion = 2
                    call Win2003ServerProductType
                ElseIf D$OSVersionInfo.MinorVersion = 0
                    call Win2000ServerProductType
                EndIf
            .Else
                mov ax W$OSVersionInfo.SuiteMask
                and ax &VER_SUITE_ENTERPRISE
                If ax <> 0
                    mov esi {'Server 4.0 Enterprise' 0}
                Else
                    mov esi {'Server 4.0' 0}
                EndIf
            .EndIf
         ..EndIf

    ...Else

        lea eax D@Key
        call 'ADVAPI32.RegOpenKeyExA' &HKEY_LOCAL_MACHINE,
            {'SYSTEM\CurrentControlSet\Control\ProductOptions' 0},
            0, &KEY_QUERY_VALUE, eax

        On eax <> &ERROR_SUCCESS, ExitP

        mov D$WinNTPTLen 80
        call 'ADVAPI32.RegQueryValueExA' D@Key, {'ProductType' 0},
            0, 0, WinNTProductType, WinNTPTLen

        On eax <> &ERROR_SUCCESS, ExitP
        On D$WinNTPTLen > 80, ExitP

        call 'ADVAPI32.RegCloseKey' D@Key

        If D$WinNTProductType = 'WINN'
            mov esi {'Workstation' 0}
        ElseIf D$WinNTProductType = 'LANM'
            mov esi {'Server' 0}
        ElseIf D$WinNTProductType = 'SERV'
            mov esi {'Advanced Server' 0}
        EndIf

    ...EndIf
EndP

IntToStr:
    mov dl 0FF | push edx                       ; Push stack end mark
    mov ecx 10
L0: mov edx 0
    div ecx | push edx | cmp eax 0 | ja L0<     ; Push remainders
L2: pop eax                                     ; Retrieve Backward
    cmp al 0FF | je L9>                         ; Over?
    add al '0' | stosb | jmp L2<             ; Write
L9: ret

Proc GetWindowsVersionString:

    mov D$OSVersionInfo.Size OSVI_SIZE
    call 'Kernel32.GetVersionExA' OSVersionInfo

    mov edi WindowsVersion

    ..If D$OSVersionInfo.PlatformId = &VER_PLATFORM_WIN32_NT

      ; Major versions
        .If D$OSVersionInfo.MajorVersion = 5
            If D$OSVersionInfo.MinorVersion = 2
                mov esi {'MS Windows Server 2003' 0}
            ElseIf D$OSVersionInfo.MinorVersion = 1
                mov esi {'MS Windows XP' 0}
            ElseIf D$OSVersionInfo.MinorVersion = 0
                mov esi {'MS Windows 2000' 0}
            EndIf
        .ElseIf D$OSVersionInfo.MajorVersion <= 4
            mov esi {'MS Windows NT' 0}
        .EndIf

        While B$esi <> 0 | movsb | EndWhile
        mov al ' ' | stosb

      ; Service pack number
        mov esi OSVersionInfo.CSDVersion
        While B$esi <> 0 | movsb | EndWhile
        call TestWinNTSP6a

      ; Build number
        mov esi {' Build ' 0}
        While B$esi <> 0 | movsb | EndWhile
        movzx eax W$OSVersionInfo.BuildNumber
        call IntToStr
        mov al ' ' | stosb

      ; Home / Professional / ...
        call GetWindowsProductInfo
        If esi <> 0
            While B$esi <> 0 | movsb | EndWhile
            mov al ' ' | stosb
        EndIf

    ..ElseIf D$OSVersionInfo.PlatformId = &VER_PLATFORM_WIN32_WINDOWS

      ; Major versions
        .If D$OSVersionInfo.MajorVersion = 4
            mov eax 0
            If D$OSVersionInfo.MinorVersion = 90
                mov esi {'MS Windows ME' 0}
            ElseIf D$OSVersionInfo.MinorVersion = 10
                mov esi {'MS Windows 98' 0}
                On B$OSVersionInfo.CSDVersion+1 = 'A', mov eax ' SE'
            ElseIf D$OSVersionInfo.MinorVersion = 0
                mov esi {'MS Windows 95 ' 0}
                On B$OSVersionInfo.CSDVersion+1 = 'B', mov eax 'OSR2'
                On B$OSVersionInfo.CSDVersion+1 = 'C', mov eax 'OSR2'
            EndIf
            While B$esi <> 0 | movsb | EndWhile
            stosd
        .EndIf

    ..ElseIf D$OSVersionInfo.PlatformId = &VER_PLATFORM_WIN32S

        mov esi {'MS Win32s' 0}
        While B$esi <> 0 | movsb | EndWhile

    ..EndIf

    mov B$edi 0
EndP

























TITLE ShowInfos
___________________________________________________________________________________________
___________________________________________________________________________________________

; Win32 Data Types significations (This is the [Win32 Data Types] from [Help] Menu
; -ShowTypesInfo- and the Right-Click upon Mnemonic feature -ShowMnemonicInfo-):

[TypesTitle: 'Win32 Data Types', 0]

; Tag Dialog 1000

ShowTypes:
    If D$ShowTypesDialogHandle = 0
        call 'USER32.DialogBoxParamA' D$hInstance, 1000, &NULL, ShowTypesInfo, &NULL
    Else
        Beep
    End_If
ret


ShowEquates:
    call SetEquatesEquFileName

    call 'SHELL32.ShellExecuteA' D$hwnd, Open, {'WordPad', 0},
                                 IncludeFileName, &NULL, &SW_SHOWNORMAL
ret


[ShowTypesDialogHandle: ?    FirstCTLCOLOREDIT: ?]

Proc ShowTypesInfo:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    .If D@Message = &WM_COMMAND
         If D@wParam = &IDCANCEL
            mov D$ShowTypesDialogHandle 0
            call 'User32.EndDialog' D@Adressee 0
         End_If

    .Else_If D@Message = &WM_INITDIALOG
        move D$ShowTypesDialogHandle D@Adressee
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        call 'USER32.SetDlgItemTextA' D@Adressee 100 Win32Types
        call 'USER32.SendMessageA' D@Adressee &WM_SETTEXT &NULL TypesTitle
        mov B$FirstCTLCOLOREDIT &TRUE

    .Else_If D@Message = &WM_CTLCOLOREDIT
        If B$FirstCTLCOLOREDIT = &TRUE
            call 'USER32.SendMessageA' D@lParam &EM_SETSEL 0 0
            mov B$FirstCTLCOLOREDIT &FALSE
        End_If
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    .Else
        popad | mov eax &FALSE | jmp L9>

    .End_If

    popad | mov eax &TRUE

L9: EndP


[Win32Types: " ACHAR         B$ ; ansi character
 ATOM          D$ ; string atom
 BOOL          D$ ; boolean variable
 COLORREF      D$ ; rgb color
 DWORDLONG     Q$ ; 8 bytes
 GLOBALHANDLE  D$ ; global handle
 HACCEL        D$ ; accelerator handle
 HANDLE        D$ ; unspecified handle
 HBITMAP       D$ ; bitmap handle
 HBRUSH        D$ ; brush handle
 HCOLORSPACE   D$ ; color space handle
 HCURSOR       D$ ; cursor handle
 HDC           D$ ; device context handle
 HDWP          D$ ; defer win pos handle
 HENHMETAFILE  D$ ; enh. metafile handle
 HFILE         D$ ; file handle
 HFONT         D$ ; font handle
 HGLOBAL       D$ ; global handle
 HHOOK         D$ ; hook handle
 HICON         D$ ; icon handle
 HINSTANCE     D$ ; instance handle
 HINTERNET     D$ ; internet handle
 HLOCAL        D$ ; local handle
 HMENU         D$ ; menu handle
 HMETAFILE     D$ ; metafile handle
 HPALETTE      D$ ; palette handle
 HPEN          D$ ; pen handle
 HRGN          D$ ; region handle
 HRSRC         D$ ; resource handle
 HSTR          D$ ; string handle
 HTASK         D$ ; task handle
 HTREEITEM     D$ ; tree view item handle
 HWND          D$ ; window handle
 INTEGER       D$ ; standard integer
 LOCALHANDLE   D$ ; local handle
 LONG          D$ ; long integer
 LONGINT       D$ ; long integer
 LPARAM        D$ ; long parameter
 LPBOOL        D$ ; long ptr to boolean
 LPBYTE        D$ ; long ptr to byte
 LPCSTR        D$ ; long ptr to string
 LPCTSTR       D$ ; long ptr to string
 LPCVOID       D$ ; long ptr to buffer
 LPDWORD       D$ ; long ptr to dword
 LPFN          D$ ; long ptr to function
 LPINT         D$ ; long ptr to integer
 LPLONG        D$ ; long ptr to long int
 LPMSG         D$ ; long pointer to message
 LPPAINTSTRUCT D$ ; long ptr to paint struc
 LPRECT        D$ ; long pointer to rectangle
 LPSTR         D$ ; long ptr to string
 LPTSTR        D$ ; long ptr to string
 LPVOID        D$ ; long ptr to buffer
 LPWORD        D$ ; long ptr to word
 LRESULT       D$ ; long result
 POINTER       D$ ; pointer to anything
 PVOID         D$ ; pointer to buffer
 SHORTINT      W$ ; short integer
 UINT          D$ ; unsigned integer
 WCHAR         W$ ; unicode character
 WNDPROC       D$ ; window procedure
 WPARAM        D$ ; word parameter", 0]
____________________________________________________________________________________________
____________________________________________________________________________________________


; > in from Caller (RightClick) ah = first ORed 32 char // edx > second char // ebx = lenght

[MnemonicIndex: ?]

OldSearchMneMonic:
    pushad
        mov D$MnemonicIndex 7
        or ah 32 | xor ah 32         ;  > upper case (all Upper case in the list
        mov esi OpcodesList
        .While B$esi > 0
            lodsb
            .If al = ah
                pushad | mov ecx ebx, edi edx
L0:             lodsb | mov ah B$edi | inc edi | or ah 020 | xor ah 020 ; Source upper case.
                cmp ah al | jne L1>
                loop L0<
L1:             popad | jne L3>
                If B$esi+ebx = ' '
                    On D$ShowMnemonicHandle > 0, call 'USER32.EndDialog' D$ShowMnemonicHandle 0
                    call 'USER32.DialogBoxParamA' D$hInstance 1000  &NULL ShowMnemonicInfo  &NULL
                    mov B$MnemonicHelpFound &TRUE | jmp L9>
                End_If
L3:
            .End_If
            While B$esi-1 > LF
                inc esi
            End_While
            inc D$MnemonicIndex
        .End_While
L9:  popad
ret


[MnemonicCopy: ? #4]

; > in from Caller (RightClick):
; ah = first ORed 32 char // edx > second char // ebx = lenght

[MnemonicHelpFound: ?]

SearchMneMonic: On ebx > 14, ret
    pushad
        mov D$MnemonicCopy '    ', D$MnemonicCopy+4 '    ',
            D$MnemonicCopy+8 '    ', D$MnemonicCopy+12 '    '

      ; 1) Make an upper Case copy of the possible Mnemonic (spaces ended):
        dec edx | mov esi edx, edi MnemonicCopy, ecx ebx | inc ecx
L0:     lodsb | On al > 'Z', and eax (not 020) | stosb | loop L0<

      ; Search identical record in 'OpCodeList':
        mov edi MnemonicCopy, esi OpCodeList, ebx D$edi
L0:     lodsd | cmp eax 0 | je L9>>
                cmp eax ebx | je L5>

L4:                 Align_On 16 esi | jmp L0<

L5:                     mov edx edi | add edx 4
                        While B$edx <> ' '
                            lodsd | cmp eax D$edx | jne L4<
L6:                         add edx 4
                        End_While
                        On B$esi <> ' ', jmp L4<

                      ; Step back to Main Mnemonic if '<' encounted:
                        Align_On 16 esi | sub esi 16
                        If B$esi-1 = '<'
                            While B$esi-1 = '<'
                                sub esi 16
                            End_While
                        End_If

                      ; Zero end Case sensitive recopy of the MnemonicCopy for ShellExecute:
                        mov edi MnemonicCopy
                        While B$esi <> ' '
                            movsb
                        End_While
                        mov B$edi 0
                        call Help B_U_AsmName, MnemonicCopy, FileNotFound
                        If eax <= 32
                            jmp L9>
                        Else
                            mov B$MnemonicHelpFound &TRUE
                        End_If
    popad
ret

L9: popad
jmp OldSearchMneMonic


[MnemonicInfoString: ? #40] [MnemonicInfoTitle: ? #10]

[ShowMnemonicHandle: 0    MnemonicsTitle: 'Mnemonics list (More Infos with OpHelp.exe...)', 0]

Proc ShowMnemonicInfo:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    .If D@Message = &WM_COMMAND
         If D@wParam = &IDCANCEL
            call 'User32.EndDialog' D@Adressee 0
         End_If

    .Else_If D@Message = &WM_INITDIALOG
        move D$ShowMnemonicHandle D@Adressee
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        call 'USER32.SetDlgItemTextA' D@Adressee 100 OpcodesListTitle
        call 'USER32.GetDlgItem' D@Adressee 100
        call 'USER32.SendMessageA' eax &EM_LINESCROLL 0  D$MnemonicIndex
        call 'USER32.SendMessageA' D@Adressee &WM_SETTEXT 0 MnemonicsTitle
        mov B$FirstCTLCOLOREDIT &TRUE

    .Else_If D@Message = &WM_CTLCOLOREDIT
        If B$FirstCTLCOLOREDIT = &TRUE
            call 'USER32.SendMessageA' D@lParam &EM_SETSEL 0 0
            mov B$FirstCTLCOLOREDIT &FALSE
        End_If
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    .Else
        popad | mov eax &FALSE | jmp L9>

    .End_If

    popad | mov eax &TRUE

L9: EndP

____________________________________________________________________________________________
____________________________________________________________________________________________


[ApiTitle: 'Api call infos' 0]

; Tag Dialog 1000

Proc ShowApiInfo:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    .If D@Message = &WM_COMMAND
         If D@wParam = &IDCANCEL
            call 'User32.EndDialog' D@Adressee 0
         End_If

    .Else_If D@Message = &WM_INITDIALOG
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        call 'USER32.SetDlgItemTextA' D@Adressee 100  OneApiInfo
        call 'USER32.SendMessageA' D@Adressee &WM_SETTEXT 0 ApiTitle
        mov B$FirstCTLCOLOREDIT &TRUE

    .Else_If D@Message = &WM_CTLCOLOREDIT
        If B$FirstCTLCOLOREDIT = &TRUE
            call 'USER32.SendMessageA' D@lParam &EM_SETSEL 0 0
            mov B$FirstCTLCOLOREDIT &FALSE
        End_If
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    .Else
        popad | mov eax &FALSE | jmp L9>

    .End_If

    popad | mov eax &TRUE

L9: EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[OpcodesListTitle: B$
"            ************************************************
            *  The Complete Pentium Instruction Set Table  *
            *      - Thanks to Sang Cho (SV 1999) -        *
            *==============================================*
            *    Ripped from exe and converted into this   *
            *         text format by Test Department       *
            ************************************************
"


OpcodesList: B$ "
AAA                  37           ASCII adjust AL after addition       
    > mov al 09, bl 02 | add al bl | AAA ; ax = BCD(0101)

AAD                  D5 0A        ASCII adjust AX before division      
    > mov ax 0102 | AAD ; ax = 12

AAM                  D4 0A        ASCII adjust AX after multiplication 
    > mov al 7 | mov cx 8 | mul cx | aam ; ax = 0506

AAS                  3F           ASCII adjust AL after subtraction    
    > sub al bl | aas | jc CarryFlagSet

ADC AL,imm8          14       ib  Add with carry
    > ... To be continued by who wants to...

ADC EAX,imm32        15       id  Add with carry
    > ... Search for 'OpcodesList' Label in RosAsm Source.

ADC r/m8,imm8        80    /2 ib  Add with carry
    > ...

ADC r/m32,imm32      81    /2 id  Add with carry
    > ...

ADC r/m32,imm8       83    /2 ib  Add with carry
    > ...

ADC r/m8,r8          10    /r     Add with carry
    > ...

ADC r/m32,r32        11    /r     Add with carry
ADC r8,r/m8          12    /r     Add with carry 
ADC r32,r/m32        13    /r     Add with carry
ADD AL,imm8          04       ib  Add 
ADD EAX,imm32        05       id  Add 
ADD r/m8,imm8        80    /0 ib  Add 
ADD r/m32,imm32      81    /0 id  Add 
ADD r/m32,imm8       83    /0 ib  Add 
ADD r/m8,r8          00    /r     ADD 
ADD r/m32,r32        01    /r     ADD 
ADD r8,r/m8          02    /r     ADD 
ADD r32,r/m32        03    /r     ADD 
AND AL,imm8          24       ib  AND 
AND EAX,imm32        25       id  AND
AND r/m8,imm8        80    /4 ib  AND
AND r/m32,imm32      81    /4 id  AND
AND r/m32,imm8       83    /4 ib  AND
AND r/m8,r8          20    /r     AND
AND r/m32,r32        21    /r     AND
AND r8,r/m8          22    /r     AND
AND r32,r/m32        23    /r     AND
ARPL r/m16,r16       63    /r     Adjust Request Privilege Level of Sel.
BOUND r32,m32&32     62    /r     Check Array Index Against Bounds
BSF r32,r/m32        0F BC /r     Bit scan forward on r/m32
BSR r32,r/m32        0F BD /r     Bit scan reverse on r/m32
BSWAP r32            0F C8+rd     Reverses the byte order of a r32
BT r/m32,r32         0F A3 /r     Bit Test
BT r/m32,imm8        0F BA /4 ib  Bit Test
BTC r/m32,r32        0F BB /r     Bit Test and Complement
BTC r/m32,imm8       0F BA /7 ib  Bit Test and Complement
BTR r/m32,r32        0F B3 /r     Bit Test and Clear
BTR r/m32,imm8       0F BA /6 ib  Bit Test and Clear
BTS r/m32,r32        0F AB /r     Bit Test and Set
BTS r/m32,imm8       0F BA /5 ib  Bit Test and Set
CALL rel32           E8       cd  Call near, rel to n.inst
CALL r/m32           FF    /2     Call near, abs.ind.add. given in r/m32
CALL ptr16:32        9A       cp  Call far, abs.add. given in operand
CALL m16:32          FF    /3     Call far, abs.ind.add. given in m16:32
CBW                  98           Convert Byte to Word
CWD                  99           Convert Word to Doubleword
CDQ                  99           Convert Doubleword to Quadword 
CLC                  F8           Clear CF flag
CLD                  FC           Clear DF flag
CLI                  FA           Clear interrupt flag
CLTS                 0F 06        Clear Task-Switched Flag in Control Reg. Zero
CMC                  F5           Complement CF flag
CMOVA r32,r/m32      0F 47 /r     Move if above 
CMOVAE r32,r/m32     0F 43 /r     Move if above or equal 
CMOVB r32,r/m32      0F 42 /r     Move if below 
CMOVBE r32,r/m32     0F 46 /r     Move if below or equal 
CMOVC r32,r/m32      0F 42 /r     Move if carry 
CMOVE r32,r/m32      0F 44 /r     Move if equal 
CMOVG r32,r/m32      0F 4F /r     Move if greater 
CMOVGE r32,r/m32     0F 4D /r     Move if greater or equal 
CMOVL r32,r/m32      0F 4C /r     Move if less 
CMOVLE r32,r/m32     0F 4E /r     Move if less or equal 
CMOVNA r32,r/m32     0F 46 /r     Move if not above 
CMOVNAE r32,r/m32    0F 42 /r     Move if not above or equal 
CMOVNB r32,r/m32     0F 43 /r     Move if not below 
CMOVNBE r32,r/m32    0F 47 /r     Move if not below or equal 
CMOVNC r32,r/m32     0F 43 /r     Move if not carry 
CMOVNE r32,r/m32     0F 45 /r     Move if not equal 
CMOVNG r32,r/m32     0F 4E /r     Move if not greater 
CMOVNGE r32,r/m32    0F 4C /r     Move if not greater or equal 
CMOVNL r32,r/m32     0F 4D /r     Move if not less 
CMOVNLE r32,r/m32    0F 4F /r     Move if not less or equal 
CMOVNO r32,r/m32     0F 41 /r     Move if not overflow 
CMOVNP r32,r/m32     0F 4B /r     Move if not parity 
CMOVNS r32,r/m32     0F 49 /r     Move if not sign 
CMOVNZ r32,r/m32     0F 45 /r     Move if not zero 
CMOVO r32,r/m32      0F 40 /r     Move if overflow 
CMOVP r32,r/m32      0F 4A /r     Move if parity 
CMOVPE r32,r/m32     0F 4A /r     Move if parity even 
CMOVPO r32,r/m32     0F 4B /r     Move if parity odd 
CMOVS r32,r/m32      0F 48 /r     Move if sign 
CMOVZ r32,r/m32      0F 44 /r     Move if zero 
CMP AL,imm8          3C       ib  Compare 
CMP EAX,imm32        3D       id  Compare 
CMP r/m8,imm8        80    /7 ib  Compare 
CMP r/m32,imm32      81    /7 id  Compare 
CMP r/m32,imm8       83    /7 ib  Compare 
CMP r/m8,r8          38    /r     Compare 
CMP r/m32,r32        39    /r     Compare 
CMP r8,r/m8          3A    /r     Compare 
CMP r32,r/m32        3B    /r     Compare 
CMPSB                A6           Compare byte at ESI byte at with EDI 
CMPSD                A7           Compare dword  at ESI byte at with EDI
CMPXCHG r/m8,r8      0F B0 /r     Compare and Exchange
CMPXCHG r/m32,r32    0F B1 /r     Compare and Exchange
CMPXCHG8B m64        0F C7 /1 m64 Compare and Exchange
CPUID                0F A2        EAX := Processor id.info.
DAA                  27           Decimal adjust AL after addition
DAS                  2F           Decimal adjust AL after subtraction
DEC r/m8             FE    /1     Decrement r/m8 by 1
DEC r/m32            FF    /1     Decrement r/m32 by 1
DEC r32              48+rd        Decrement r32 by 1
DIV r/m8             F6    /6     Unsigned divide AX by r/m8
DIV r/m16            F7    /6     Unsigned divide DX:AX by r/m16
DIV r/m32            F7    /6     Unsigned divide EDX:EAX by r/m32 
EMMS                 0F 77        Set the FP tag word to empty
ENTER imm16,0        C8     iw 00 Create a stack frame for a procedure
ENTER imm16,1        C8     iw 01 Create a nested stack frame for a proc.
ENTER imm16,imm8     C8     iw ib Create a nested stack frame for a proc.
F2XM1                D9 F0        Replace ST0 with 2**ST0 - 1
FABS                 D9 E1        Replace ST0 with its absolute value
FADD m32real         D8    /0     Add m32real to ST0 and s.r. in ST0
FADD m64real         DC    /0     Add m64real to ST0 and s.r.in ST0
FADD ST(0),ST(i)     D8 C0+i      Add ST0 to STi and s.r.in ST0
FADD ST(i),ST(0)     DC C0+i      Add STi to ST0 and s.r. in STi
FADDP ST(i),ST(0)    DE C0+i      Add ST0 to STi, s.r.in STi,pop r.stack
FADDP                DE C1        Add ST0 to ST1, s.r.in ST1,pop r.stack
FIADD m32int         DA    /0     Add m32int to ST0 and s.r.in ST0
FIADD m16int         DE    /0     Add m16int to ST0 and s.r.in ST0
FBLD m80bcd          DF    /4     Convert m80BCD to real and push 
FBSTP m80bcd         DF    /6     Store ST0 in m80bcd and pop ST0
FCHS                 D9 E0        Complements sign of ST0
FCLEX                9B DB E2     Clear f.e.f. after checking for ..
FNCLEX               DB E2        Clear f.e.f. without checking for ..
FCMOVB ST(0),ST(i)   DA C0+i      Move if below 
FCMOVE ST(0),ST(i)   DA C8+i      Move if equal 
FCMOVBE ST(0),ST(i)  DA D0+i      Move if below or equal 
FCMOVU ST(0),ST(i)   DA D8+i      Move if unordered 
FCMOVNB ST(0),ST(i)  DB C0+i      Move if not below 
FCMOVNE ST(0),ST(i)  DB C8+i      Move if not equal 
FCMOVNBE ST(0),ST(i) DB D0+i      Move if not below or equal 
FCMOVNU ST(0),ST(i)  DB D8+i      Move if not unordered 
FCOM m32real         D8    /2     Compare ST0 with m32real.
FCOM m64real         DC    /2     Compare ST0 with m64real.
FCOM ST(i)           D8 D0+i      Compare ST0 with STi.
FCOM                 D8 D1        Compare ST0 with ST1.
FCOMP m32real        D8    /3     Compare ST0 with m32real,pop r.stack.
FCOMP m64real        DC    /3     Compare ST0 with m64real,pop r.stack.
FCOMP ST(i)          D8 D8+i      Compare ST0 with STi, pop 
FCOMP                D8 D9        Compare ST0 with ST1, pop 
FCOMPP               DE D9        Compare ST0 with ST1, pop pop
FCOMI ST,ST(i)       DB F0+i      Compare ST0 with STi, set status flags
FCOMIP ST,ST(i)      DF F0+i      Compare ST0 with STi, set s.f. ,pop 
FUCOMI ST,ST(i)      DB E8+i      Compare ST0 with STi, check o.v.set s.f.
FUCOMIP ST,ST(i)     DF E8+i      Compare ST0 with STi, check ovssf pop 
FCOS                 D9 FF        Replace ST0 with its cosine
FDECSTP              D9 F6        Decrement TOP field in FPU status word.
FDIV m32real         D8    /6     Divide ST0 by m32real and s.r.in ST0
FDIV m64real         DC    /6     Divide ST0 by m64real and s.r.in ST0
FDIV ST(0),ST(i)     D8 F0+i      Divide ST0 by STi and s.r.in ST0
FDIV ST(i),ST(0)     DC F8+i      Divide STi by ST0 and s.r.in STi
FDIVP ST(i),ST(0)    DE F8+i      Divide STi by ST0, s.r.in STi pop 
FDIVP                DE F9        Divide ST1 by ST0, s.r.in ST1 pop 
FIDIV m32int         DA    /6     Divide ST0 by m32int and s.r.in ST0
FIDIV m16int         DE    /6     Divide ST0 by m64int and s.r.in ST0
FDIVR m32real        D8    /7     Divide m32real by ST0 and s.r.in ST0
FDIVR m64real        DC    /7     Divide m64real by ST0 and s.r.in ST0
FDIVR ST(0),ST(i)    D8 F8+i      Divide STi by ST0 and s.r.in ST0
FDIVR ST(i),ST(0)    DC F0+i      Divide ST0 by STi and s.r.in STi
FDIVRP ST(i),ST(0)   DE F0+i      Divide ST0 by STi, s.r.in STi pop 
FDIVRP               DE F1        Divide ST0 by ST1, s.r.in ST1 pop 
FIDIVR m32int        DA    /7     Divide m32int by ST0 and s.r.in ST0
FIDIVR m16int        DE    /7     Divide m64int by ST0 and s.r.in ST0
FFREE ST(i)          DD C0+i      Sets tag for STi to empty
FICOM m16int         DE    /2     Compare ST0 with m16int
FICOM m32int         DA    /2     Compare ST0 with m32int
FICOMP m16int        DE    /3     Compare ST0 with m16int and pop 
FICOMP m32int        DA    /3     Compare ST0 with m32int and pop 
FILD m16int          DF    /0     Push m16int 
FILD m32int          DB    /0     Push m32int 
FILD m64int          DF    /5     Push m64int 
FINCSTP              D9 F7        Increment the TOP field FPU status r.
FINIT                9B DB E3     Initialize FPU after ...
FNINIT               DB E3        Initialize FPU without ...
FIST m16int          DF    /2     Store ST0 in m16int
FIST m32int          DB    /2     Store ST0 in m32int
FISTP m16int         DF    /3     Store ST0 in m16int and pop 
FISTP m32int         DB    /3     Store ST0 in m32int and pop 
FISTP m64int         DF    /7     Store ST0 in m64int and pop 
FLD m32real          D9    /0     Push m32real 
FLD m64real          DD    /0     Push m64real 
FLD m80real          DB    /5     Push m80real 
FLD ST(i)            D9 C0+i      Push STi 
FLD1                 D9 E8        Push +1.0 
FLDL2T               D9 E9        Push log2 10 
FLDL2E               D9 EA        Push log2 = 
FLDPI                D9 EB        Push pi 
FLDLG2               D9 EC        Push log10 2 
FLDLN2               D9 ED        Push loge 2 
FLDZ                 D9 EE        Push +0.0 
FLDCW m2byte         D9    /5     Load FPU control word from m2byte
FLDENV m14/28byte    D9    /4     Load FPU environment from m14/m28
FMUL m32real         D8    /1     Multiply ST0 by m32real and s.r.in ST0
FMUL m64real         DC    /1     Multiply ST0 by m64real and s.r.in ST0
FMUL ST(0),ST(i)     D8 C8+i      Multiply ST0 by STi and s.r.in ST0
FMUL ST(i),ST(0)     DC C8+i      Multiply STi by ST0 and s.r.in STi
FMULP ST(i),ST(0)    DE C8+i      Multiply STi by ST0, s.r.in STi pop 
FMULP                DE C9        Multiply ST1 by ST0, s.r.in ST1 pop 
FIMUL m32int         DA    /1     Multiply ST0 by m32int and s.r.in ST0
FIMUL m16int         DE    /1     Multiply ST0 by m16int and s.r.in ST0
FNOP                 D9 D0        No operation is performed
FPATAN               D9 F3        Repalces ST1 with arctan(ST1/ST0) pop 
FPREM                D9 F8        Replaces ST0 with rem (ST0/ST1)
FPREM1               D9 F5        Replaces ST0 with IEEE rem(ST0/ST1)
FPTAN                D9 F2        Replaces ST0 with its tangent push 1.0
FRNDINT              D9 FC        Round ST0 to an integer
FRSTOR m94/108byte   DD    /4     Load FPU status from m94 or m108 byte
FSAVE m94/108byte    9B DD /6     Store FPU status to m94 or m108
FNSAVE m94/108byte   DD    /6     Store FPU environment to m94 or m108
FSCALE               D9 FD        Scale ST0 by ST1
FSIN                 D9 FE        Replace ST0 with its sine
FSINCOS              D9 FB        Compute sine and consine of ST0 s push c
FSQRT                D9 FA        square root of ST0
FST m32real          D9    /2     Copy ST0 to m32real
FST m64real          DD    /2     Copy ST0 to m64real
FST ST(i)            DD D0+i      Copy ST0 to STi
FSTP m32real         D9    /3     Copy ST0 to m32real and pop 
FSTP m64real         DD    /3     Copy ST0 to m64real and pop 
FSTP m80real         DB    /7     Copy ST0 to m80real and pop 
FSTP ST(i)           DD D8+i      Copy ST0 to STi and pop 
FSTCW m2byte         9B D9 /7     Store FPU control word
FNSTCW m2byte        D9    /7     Store FPU control word without
FSTENV m14/28byte    9B D9 /6     Store FPU environment
FNSTENV m14/28byte   D9    /6     Store FPU env without
FSTSW m2byte         9B DD /7     Store FPU status word at m2byte after 
FSTSW AX             9B DF E0     Store FPU status word in AX  after 
FNSTSW m2byte        DD    /7     Store FPU status word at m2byte without 
FNSTSW AX            DF E0        Store FPU status word in AX without 
FSUB m32real         D8    /4     Sub m32real from ST0 and s.r.in ST0
FSUB m64real         DC    /4     Sub m64real from ST0 and s.r.in ST0
FSUB ST(0),ST(i)     D8 E0+i      Sub STi from ST0 and s.r.in ST0
FSUB ST(i),ST(0)     DC E8+i      Sub ST0 from STi and s.r.in STi
FSUBP ST(i),ST(0)    DE E8+i      Sub ST0 from STi, s.r.in STi pop
FSUBP                DE E9        Sub ST0 from ST1, s.r.in ST1 pop 
FISUB m32int         DA    /4     Sub m32int from ST0 and s.r.in ST0
FISUB m16int         DE    /4     Sub m16int from ST0 and s.r.in ST0
FSUBR m32real        D8    /5     Sub ST0 from m32real and s.r.in ST0
FSUBR m64real        DC    /5     Sub ST0 from m64real and s.r.in ST0
FSUBR ST(0),ST(i)    D8 E8+i      Sub ST0 from STi and s.r.in ST0
FSUBR ST(i),ST(0)    DC E0+i      Sub STi from ST0 and s.r.in STi
FSUBRP ST(i),ST(0)   DE E0+i      Sub STi from ST0, s.r. in STi) pop 
FSUBRP               DE E1        Sub ST1 from ST0, s.r.in ST1 pop 
FISUBR m32int        DA    /5     Sub ST0 from m32int and s.r.in ST0
FISUBR m16int        DE    /5     Sub ST0 from m16int and s.r.in ST0
FTST                 D9 E4        Compare ST0 with 0.0
FUCOM ST(i)          DD E0+i      Compare ST0 with STi
FUCOM                DD E1        Compare ST0 with ST1
FUCOMP ST(i)         DD E8+i      Compare ST0 with STi and pop 
FUCOMP               DD E9        Compare ST0 with ST1 and pop 
FUCOMPP              DA E9        Compare ST0 with ST1 and pop pop
FXAM                 D9 E5        Classify value or number in ST0
FXCH ST(i)           D9 C8+i      Exchange ST0 and STi
FXCH                 D9 C9        Exchange ST0 and ST1
FXTRACT              D9 F4        Seperate value in ST(0) exp. and sig.
FYL2X                D9 F1        Replace ST1 with ST1*log2(ST0) and pop
FYL2XP1              D9 F9        Replace ST1 with ST1*log2(ST0+1) pop
HLT                  F4           Halt
IDIV r/m8            F6    /7     Divide   
IDIV r/m32           F7    /7     Divide  
IMUL r/m8            F6    /5     Multiply
IMUL r/m32           F7    /5     Multiply
IMUL r32,r/m32       0F AF /r     Multiply
IMUL r32,r/m32,imm8  6B    /r ib  Multiply
IMUL r32,imm8        6B    /r ib  Multiply
IMUL r32,r/m32,imm32 69    /r id  Multiply
IMUL r32,imm32       69    /r id  Multiply
IN AL,imm8           E4       ib  Input byte from imm8 I/O port address into AL
IN EAX,imm8          E5       ib  Input byte from imm8 I/O port address into EAX
IN AL,DX             EC           Input byte from I/O port in DX into AL
IN EAX,DX            ED           Input doubleword from I/O port in DX into EAX
INC r/m8             FE    /0     Increment 1
INC r/m32            FF    /0     Increment 1
INC r32              40+rd        Increment register by 1
INS m8               6C           Input byte from I/O(DX) into  (E)DI
INS m32              6D           Input dw from I/O(DX) into (E)DI
INT 3                CC           Interrupt 3--trap to debugger
INT imm8             CD       ib  Interrupt vector number (imm8)
INTO                 CE           Interrupt 4--if overflow flag is 1
INVD                 0F 08        Flush internal caches
INVLPG m             0F 01 /7     Invalidate TLB Entry for page (m)
IRETD                CF           Interrupt return(32)
JA rel8              77       cb  Jump short if above 
JAE rel8             73       cb  Jump short if above or equal 
JBE rel8             76       cb  Jump short if below or equal 
JC rel8              72       cb  Jump short if carry 
JECXZ rel8           E3       cb  Jump short if ECX register is 0
JE rel8              74       cb  Jump short if equal 
JG rel8              7F       cb  Jump short if greater 
JGE rel8             7D       cb  Jump short if greater or equal 
JL rel8              7C       cb  Jump short if less 
JLE rel8             7E       cb  Jump short if less or equal 
JNE rel8             75       cb  Jump short if not equal 
JNO rel8             71       cb  Jump short if not overflow 
JNS rel8             79       cb  Jump short if not sign 
JO rel8              70       cb  Jump short if overflow 
JPE rel8             7A       cb  Jump short if parity even 
JPO rel8             7B       cb  Jump short if parity odd 
JS rel8              78       cb  Jump short if sign 
JA rel32             0F 87    cd  Jump near if above 
JAE rel32            0F 83    cd  Jump near if above or equal 
JB rel32             0F 82    cd  Jump near if below 
JBE rel32            0F 86    cd  Jump near if below or equal 
JE rel32             0F 84    cd  Jump near if equal 
JG rel32             0F 8F    cd  Jump near if greater 
JGE rel32            0F 8D    cd  Jump near if greater or equal 
JL rel32             0F 8C    cd  Jump near if less 
JLE rel32            0F 8E    cd  Jump near if less or equal 
JNE rel32            0F 85    cd  Jump near if not equal 
JNO rel32            0F 81    cd  Jump near if not overflow 
JNS rel32            0F 89    cd  Jump near if not sign 
JO rel32             0F 80    cd  Jump near if overflow 
JPE rel32            0F 8A    cd  Jump near if parity even 
JPO rel32            0F 8B    cd  Jump near if parity odd 
JS rel32             0F 88    cd  Jump near if sign 
JMP rel8             EB       cb  Jump short, relative, 
JMP rel32            E9       cd  Jump near, relative, 
JMP r/m32            FF    /4     Jump near, abs.ind.in r/m32
JMP ptr16:32         EA       cp  Jump far, abs.add given in operand
JMP m16:32           FF    /r     Jump far, abs.ind.in m16:32
LAHF                 9F           Load Status Flags into AH 
LAR r32,r/m32        0F 02 /r     Load Access Rights Byte     
LDS r32,m16:32       C5    /r     Load DS:r32 with far ptr
LEA r32,m            8D    /r     Load effective address  
LEAVE                C9           Set ESP to EBP, then pop EBP
LES r32,m16:32       C4    /r     Load ES:r32 with far ptr 
LFS r32,m16:32       0F B4 /r     Load FS:r32 with far ptr
LGS r32,m16:32       0F B5 /r     Load GS:r32 with far ptr
LGDT m16&32          0F 01 /2     Load m into GDTR
LIDT m16&32          0F 01 /3     Load m into IDTR
LLDT r/m16           0F 00 /2     Load segment selector r/m16 into LDTR
LMSW r/m16           0F 01 /6     Load r/m16 in machine status word of CR0
LOCK                 F0           Asserts LOCK signal for duration ..
LODSB                AC           Load byte at address ESI into AL
LODSD                AD           Load dword at address ESI into EAX
LODSW                AD           Load word at address ESI into AX
LOOP rel8            E2       cb  Dec count;jump if count # 0
LOOPE rel8           E1       cb  Dec count;jump if count # 0 and ZF=1
LOOPZ rel8           E1       cb  Dec count;jump if count # 0 and ZF=1
LOOPNE rel8          E0       cb  Dec count;jump if count # 0 and ZF=0
LOOPNZ rel8          E0       cb  Dec count;jump if count # 0 and ZF=0
LSL r16,r/m16        0F 03 /r     Load Segment Limit
LSL r32,r/m32        0F 03 /r     Load Segment Limit
LSS r32,m16:32       0F B2 /r     Load SS:r32 with far ptr
LTR r/m16            0F 00 /3     Load Task Register
MOV r/m8,r8          88    /r     Move 
MOV r/m32,r32        89    /r     Move 
MOV r8,r/m8          8A    /r     Move 
MOV r32,r/m32        8B    /r     Move 
MOV r/m16,Sreg**     8C    /r     Move segment register to r/m16
MOV Sreg,r/m16**     8E    /r     Move r/m16 to segment register
MOV AL, moffs8*      A0           Move byte at ( seg:offset) to AL
MOV AX, moffs16*     A1           Move word at ( seg:offset) to AX
MOV EAX, moffs32*    A1           Move dword at ( seg:offset) to EAX
MOV moffs8*,AL       A2           Move AL to ( seg:offset)
MOV moffs16*,AX      A3           Move AX to ( seg:offset)
MOV moffs32*,EAX     A3           Move EAX to ( seg:offset)
MOV r8,imm8          B0+rb        Move imm8 to r8
MOV r32,imm32        B8+rd        Move imm32 to r32
MOV r/m8,imm8        C6    /0 ib  Move imm8 to r/m8
MOV r/m32,imm32      C7    /0 id  Move imm32 to r/m32
MOV CR0, r32         0F 22 /r     Move r32 to CR0
MOV CR2, r32         0F 22 /r     Move r32 to CR2
MOV CR3, r32         0F 22 /r     Move r32 to CR3
MOV CR4, r32         0F 22 /r     Move r32 to CR4
MOV r32,CR0          0F 20 /r     Move CR0 to r32
MOV r32,CR2          0F 20 /r     Move CR2 to r32
MOV r32,CR3          0F 20 /r     Move CR3 to r32
MOV r32,CR4          0F 20 /r     Move CR4 to r32
MOV r32,DR0-DR7      0F 21 /r     Move debug register to r32
MOV DR0-DR7,r32      0F 23 /r     Move r32 to debug register
MOVD mm,r/m32        0F 6E /r     Move doubleword from r/m32 to mm
MOVD r/m32,mm        0F 7E /r     Move doubleword from mm to r/m32
MOVQ mm,mm/m64       0F 6F /r     Move quadword from mm/m64 to mm
MOVQ mm/m64,mm       0F 7F /r     Move quadword from mm to mm/m64
MOVSB                A4           Move byte at ESI to  EDI
MOVSD                A5           Move dword at ESI to  EDI
MOVSW                A5           Move word at ESI to  EDI
MOVSX r32,r/m8       0F BE /r     Move byte to doubleword, sign-extension
MOVSX r32,r/m16      0F BF /r     Move word to doubleword, sign-extension
MOVZX r32,r/m8       0F B6 /r     Move byte to doubleword, zero-extension
MOVZX r32,r/m16      0F B7 /r     Move word to doubleword, zero-extension
MUL r/m8             F6    /4     Unsigned multiply 
MUL r/m32            F7    /4     Unsigned multiply 
NEG r/m8             F6    /3     Two's complement negate r/m8
NEG r/m32            F7    /3     Two's complement negate r/m32
NOP                  90           No operation
NOT r/m8             F6    /2     Reverse each bit of r/m8
NOT r/m32            F7    /2     Reverse each bit of r/m32
OR AL,imm8           0C       ib  OR
OR EAX,imm32         0D       id  OR 
OR r/m8,imm8         80    /1 ib  OR 
OR r/m32,imm32       81    /1 id  OR 
OR r/m32,imm8        83    /1 ib  OR 
OR r/m8,r8           08    /r     OR 
OR r/m32,r32         09    /r     OR 
OR r8,r/m8           0A    /r     OR 
OR r32,r/m32         0B    /r     OR 
OUT imm8,AL          E6       ib  Output byte in AL to I/O(imm8)
OUT imm8,EAX         E7       ib  Output dword in EAX to I/O(imm8)
OUT DX,AL            EE           Output byte in AL to I/O(DX)
OUT DX,EAX           EF           Output dword in EAX to I/O(DX)
OUTS DX,m8           6E           Output byte from (E)SI to I/O(DX)
OUTS DX,m32          6F           Output dword from (E)SI to I/O (DX)
PACKSSWB mm,mm/m64   0F 63 /r     Pack with Signed Saturation
PACKSSDW mm,mm/m64   0F 6B /r     Pack with Signed Saturation
PACKUSWB mm,mm/m64   0F 67 /r     Pack with Unsigned Saturation
PADDB mm,mm/m64      0F FC /r     Add packed bytes 
PADDW mm,mm/m64      0F FD /r     Add packed words 
PADDD mm,mm/m64      0F FE /r     Add packed dwords 
PADDSB mm,mm/m64     0F EC /r     Add signed packed bytes 
PADDSW mm,mm/m64     0F ED /r     Add signed packed words 
PADDUSB mm,mm/m64    0F DC /r     Add unsigned pkd bytes 
PADDUSW mm,mm/m64    0F DD /r     Add unsigned pkd words 
PAND mm,mm/m64       0F DB /r     AND quadword from .. to ..
PANDN mm,mm/m64      0F DF /r     And qword from .. to NOT qw in mm
PCMPEQB mm,mm/m64    0F 74 /r     Packed Compare for Equal
PCMPEQW mm,mm/m64    0F 75 /r     Packed Compare for Equal
PCMPEQD mm,mm/m64    0F 76 /r     Packed Compare for Equal
PCMPGTB mm,mm/m64    0F 64 /r     Packed Compare for GT
PCMPGTW mm,mm/m64    0F 65 /r     Packed Compare for GT
PCMPGTD mm,mm/m64    0F 66 /r     Packed Compare for GT
PMADDWD mm,mm/m64    0F F5 /r     Packed Multiply and Add
PMULHW mm,mm/m64     0F E5 /r     Packed Multiply High
PMULLW mm,mm/m64     0F D5 /r     Packed Multiply Low
POP m32              8F    /0     Pop m32
POP r32              58+rd        Pop r32
POP DS               1F           Pop DS
POP ES               07           Pop ES
POP SS               17           Pop SS
POP FS               0F A1        Pop FS
POP GS               0F A9        Pop GS
POPAD                61           Pop EDI,... and EAX
POPFD                9D           Pop Stack into EFLAGS Register
POR mm,mm/m64        0F EB /r     OR qword from .. to mm
PSLLW mm,mm/m64      0F F1 /r     Packed Shift Left Logical
PSLLW mm,imm8        0F 71 /6 ib  Packed Shift Left Logical
PSLLD mm,mm/m64      0F F2 /r     Packed Shift Left Logical
PSLLD mm,imm8        0F 72 /6 ib  Packed Shift Left Logical
PSLLQ mm,mm/m64      0F F3 /r     Packed Shift Left Logical
PSLLQ mm,imm8        0F 73 /6 ib  Packed Shift Left Logical
PSRAW mm,mm/m64      0F E1 /r     Packed Shift Right Arithmetic
PSRAW mm,imm8        0F 71 /4 ib  Packed Shift Right Arithmetic
PSRAD mm,mm/m64      0F E2 /r     Packed Shift Right Arithmetic
PSRAD mm,imm8        0F 72 /4 ib  Packed Shift Right Arithmetic
PSRLW mm,mm/m64      0F D1 /r     Packed Shift Right Logical 
PSRLW mm,imm8        0F 71 /2 ib  Packed Shift Right Logical 
PSRLD mm,mm/m64      0F D2 /r     Packed Shift Right Logical 
PSRLD mm,imm8        0F 72 /2 ib  Packed Shift Right Logical 
PSRLQ mm,mm/m64      0F D3 /r     Packed Shift Right Logical 
PSRLQ mm,imm8        0F 73 /2 ib  Packed Shift Right Logical 
PSUBB mm,mm/m64      0F F8 /r     Packed Subtract
PSUBW mm,mm/m64      0F F9 /r     Packed Subtract
PSUBD mm,mm/m64      0F FA /r     Packed Subtract
PSUBSB mm,mm/m64     0F E8 /r     Packed Subtract with Saturation
PSUBSW mm,mm/m64     0F E9 /r     Packed Subtract with Saturation
PSUBUSB mm,mm/m64    0F D8 /r     Packed Subtract Unsigned with S.
PSUBUSW mm,mm/m64    0F D9 /r     Packed Subtract Unsigned with S.
PUNPCKHBW mm,mm/m64  0F 68 /r     Unpack High Packed Data
PUNPCKHWD mm,mm/m64  0F 69 /r     Unpack High Packed Data
PUNPCKHDQ mm,mm/m64  0F 6A /r     Unpack High Packed Data
PUNPCKLBW mm,mm/m32  0F 60 /r     Unpack Low Packed Data
PUNPCKLWD mm,mm/m32  0F 61 /r     Unpack Low Packed Data
PUNPCKLDQ mm,mm/m32  0F 62 /r     Unpack Low Packed Data
PUSH r/m32           FF    /6     Push r/m32
PUSH r32             50+rd        Push r32
PUSH imm8            6A       ib  Push imm8
PUSH imm32           68       id  Push imm32
PUSH CS              0E           Push CS
PUSH SS              16           Push SS
PUSH DS              1E           Push DS
PUSH ES              06           Push ES
PUSH FS              0F A0        Push FS
PUSH GS              0F A8        Push GS
PUSHAD               60           Push All g-regs
PUSHFD               9C           Push EFLAGS
PXOR mm,mm/m64       0F EF /r     XOR qword
RCL r/m8,1           D0    /2     Rotate 9 bits left once
RCL r/m8,CL          D2    /2     Rotate 9 bits left CL times
RCL r/m8,imm8        C0    /2 ib  Rotate 9 bits left imm8 times
RCL r/m32,1          D1    /2     Rotate 33 bits left once
RCL r/m32,CL         D3    /2     Rotate 33 bits left CL times
RCL r/m32,imm8       C1    /2 ib  Rotate 33 bits left imm8 times
RCR r/m8,1           D0    /3     Rotate 9 bits right once
RCR r/m8,CL          D2    /3     Rotate 9 bits right CL times
RCR r/m8,imm8        C0    /3 ib  Rotate 9 bits right imm8 times
RCR r/m32,1          D1    /3     Rotate 33 bits right once
RCR r/m32,CL         D3    /3     Rotate 33 bits right CL times
RCR r/m32,imm8       C1    /3 ib  Rotate 33 bits right imm8 times
ROL r/m8,1           D0    /0     Rotate 8 bits r/m8 left once
ROL r/m8,CL          D2    /0     Rotate 8 bits r/m8 left CL times
ROL r/m8,imm8        C0    /0 ib  Rotate 8 bits r/m8 left imm8 times
ROL r/m32,1          D1    /0     Rotate 32 bits r/m32 left once
ROL r/m32,CL         D3    /0     Rotate 32 bits r/m32 left CL times
ROL r/m32,imm8       C1    /0 ib  Rotate 32 bits r/m32 left imm8 times
ROR r/m8,1           D0    /1     Rotate 8 bits r/m8 right once
ROR r/m8,CL          D2    /1     Rotate 8 bits r/m8 right CL times
ROR r/m8,imm8        C0    /1 ib  Rotate 8 bits r/m16 right imm8 times
ROR r/m32,1          D1    /1     Rotate 32 bits r/m32 right once
ROR r/m32,CL         D3    /1     Rotate 32 bits r/m32 right CL times
ROR r/m32,imm8       C1    /1 ib  Rotate 32 bits r/m32 right imm8 times
RDMSR                0F 32        Read from Model Specific Register
RDPMC                0F 33        Read Performance-Monitoring counters
RDTSC                0F 31        Read Time-Stamp Counter
REP INS m8,DX        F3 6C        Input ECX bytes from port DX into [(E)DI]
REP INS m32,DX       F3 6D        Input ECX dwords from port DX into [(E)DI]
REP MOVSB            F3 A4        Move ECX bytes from ESI to EDI
REP MOVSD            F3 A5        Move ECX dwords from ESI to EDI
REP MOVSW            F3 A5        Move ECX words from ESI to EDI
REP OUTS DX,m8       F3 6E        Output ECX bytes from ESI to port DX
REP OUTS DX,m32      F3 6F        Output ECX dwords from ESI to port DX
REP LODSB            F3 AC        Load ECX bytes from ESI to AL
REP LODSD            F3 AD        Load ECX dwords from ESI to EAX
REP LODSW            F3 AD        Load ECX words from ESI to AX
REP STOSB            F3 AA        Fill ECX bytes at EDI with AL
REP STOSD            F3 AB        Fill ECX dwords at EDI with EAX
REP STOSD            F3 AB        Fill ECX words at EDI with AX
REPE CMPSB           F3 A6        Find nonmatching bytes in m and m
REPE CMPSD           F3 A7        Find nonmatching dwords in m and m
REPE CMPSW           F3 A7        Find nonmatching words in m and m
REPE SCASB           F3 AE        Find non-AL byte starting at 
REPE SCASD           F3 AF        Find non-EAX dword starting at
REPE SCASW           F3 AF        Find non-AX dword starting at  
REPNE CMPSB          F2 A6        Find matching bytes in m and m
REPNE CMPSD          F2 A7        Find matching dwords in m and m
REPNE CMPSW          F2 A7        Find matching words in m and m
REPNE SCASB          F2 AE        Find AL, starting at EDI
REPNE SCASD          F2 AF        Find EAX, starting at EDI
REPNE SCASW          F2 AF        Find AX, starting at EDI
RET                  C3           Near return 
RET                  CB           Far return 
RET imm16            C2       iw  Near return, pop imm16 bytes from stack
RET imm16            CA       iw  Far return, pop imm16 bytes from stack
RSM                  0F AA        Resume from System Management
SAHF                 9E           Store AH into Flags
SAL r/m8,1           D0    /4     Shift Arithmetic Left
SAL r/m8,CL          D2    /4     Shift Arithmetic Left
SAL r/m8,imm8        C0    /4 ib  Shift Arithmetic Left
SAL r/m32,1          D1    /4     Shift Arithmetic Left
SAL r/m32,CL         D3    /4     Shift Arithmetic Left
SAL r/m32,imm8       C1    /4 ib  Shift Arithmetic Left
SAR r/m8,1           D0    /7     Shift Arithmetic Right
SAR r/m8,CL          D2    /7     Shift Arithmetic Right
SAR r/m8,imm8        C0    /7 ib  Shift Arithmetic Right
SAR r/m32,1          D1    /7     Shift Arithmetic Right
SAR r/m32,CL         D3    /7     Shift Arithmetic Right
SAR r/m32,imm8       C1    /7 ib  Shift Arithmetic Right
SHL r/m8,1           D0    /4     Shift Logical Left
SHL r/m8,CL          D2    /4     Shift Logical Left
SHL r/m8,imm8        C0    /4 ib  Shift Logical Left
SHL r/m32,1          D1    /4     Shift Logical Left
SHL r/m32,CL         D3    /4     Shift Logical Left
SHL r/m32,imm8       C1    /4 ib  Shift Logical Left
SHR r/m8,1           D0    /5     Shift Logical Right
SHR r/m8,CL          D2    /5     Shift Logical Right
SHR r/m8,imm8        C0    /5 ib  Shift Logical Right
SHR r/m32,1          D1    /5     Shift Logical Right
SHR r/m32,CL         D3    /5     Shift Logical Right
SHR r/m32,imm8       C1    /5 ib  Shift Logical Right
SBB AL,imm8          1C       ib  Subtract with borrow 
SBB EAX,imm32        1D       id  Subtract with borrow 
SBB r/m8,imm8        80    /3 ib  Subtract with borrow 
SBB r/m32,imm32      81    /3 id  Subtract with borrow 
SBB r/m32,imm8       83    /3 ib  Subtract with borrow 
SBB r/m8,r8          18    /r     Subtract with borrow 
SBB r/m32,r32        19    /r     Subtract with borrow 
SBB r8,r/m8          1A    /r     Subtract with borrow 
SBB r32,r/m32        1B    /r     Subtract with borrow 
SCASB                AE           Scan String 
SCASD                AF           Scan String
SCASD                AF           Scan String
SETA r/m8            0F 97 /r     Set byte if above 
SETAE r/m8           0F 93 /r     Set byte if above or equal
SETB r/m8            0F 92 /r     Set byte if below 
SETBE r/m8           0F 96 /r     Set byte if below or equal 
SETE r/m8            0F 94 /r     Set byte if equal 
SETG r/m8            0F 9F /r     Set byte if greater 
SETGE r/m8           0F 9D /r     Set byte if greater or equal
SETL r/m8            0F 9C /r     Set byte if less 
SETLE r/m8           0F 9E /r     Set byte if less or equal 
SETNE r/m8           0F 95 /r     Set byte if not equal 
SETNO r/m8           0F 91 /r     Set byte if not overflow 
SETNS r/m8           0F 99 /r     Set byte if not sign 
SETO r/m8            0F 90 /r     Set byte if overflow 
SETPE r/m8           0F 9A /r     Set byte if parity even 
SETPO r/m8           0F 9B /r     Set byte if parity odd 
SETS r/m8            0F 98 /r     Set byte if sign 
SGDT m               0F 01 /0     Store GDTR to m
SIDT m               0F 01 /1     Store IDTR to m
SHLD r/m32,r32,imm8  0F A4 /r ib  Double Precision Shift Left
SHLD r/m32,r32,CL    0F A5 /r     Double Precision Shift Left
SHRD r/m32,r32,imm8  0F AC /r ib  Double Precision Shift Right
SHRD r/m32,r32,CL    0F AD /r     Double Precision Shift Right
SLDT r/m32           0F 00 /0     Store Local Descriptor Table Register
SMSW r/m32           0F 01 /4     Store Machine Status Word
STC                  F9           Set Carry Flag
STD                  FD           Set Direction Flag
STI                  FB           Set Interrup Flag
STOSB                AA           Store String (byte)
STOSD                AB           Store String (dWord)
STOSW                AB           Store String (word)
STR r/m16            0F 00 /1     Store Task Register
SUB AL,imm8          2C       ib  Subtract 
SUB EAX,imm32        2D       id  Subtract 
SUB r/m8,imm8        80    /5 ib  Subtract 
SUB r/m32,imm32      81    /5 id  Subtract 
SUB r/m32,imm8       83    /5 ib  Subtract 
SUB r/m8,r8          28    /r     Subtract 
SUB r/m32,r32        29    /r     Subtract 
SUB r8,r/m8          2A    /r     Subtract 
SUB r32,r/m32        2B    /r     Subtract 
TEST AL,imm8         A8       ib  Logical Compare
TEST EAX,imm32       A9       id  Logical Compare
TEST r/m8,imm8       F6    /0 ib  Logical Compare
TEST r/m32,imm32     F7    /0 id  Logical Compare
TEST r/m8,r8         84    /r     Logical Compare
TEST r/m16,r16       85    /r     Logical Compare
TEST r/m32,r32       85    /r     Logical Compare
UD2                  0F 0B        Undifined Instruction
VERR r/m16           0F 00 /4     Verify a Segment for Reading
VERW r/m16           0F 00 /5     Verify a Segment for Writing
WAIT                 9B           Wait
FWAIT                9B           Wait
WBINVD               0F 09        Write Back and Invalidate Cache
WRMSR                0F 30        Write to Model Specific Register
XADD r/m8,r8         0F C0 /r     Exchange and Add
XADD r/m16,r16       0F C1 /r     Exchange and Add
XADD r/m32,r32       0F C1 /r     Exchange and Add
XCHG EAX,r32         90+rd        Exchange r32 with EAX
XCHG r32,EAX         90+rd        Exchange EAX with r32
XCHG r/m8,r8         86    /r     Exchange byte 
XCHG r8,r/m8         86    /r     Exchange byte 
XCHG r/m32,r32       87    /r     Exchange doubleword 
XCHG r32,r/m32       87    /r     Exchange doubleword 
XLAT m8              D7           Table Look-up Translation
XOR AL,imm8          34       ib  Logical Exclusive OR
XOR EAX,imm32        35       id  Logical Exclusive OR
XOR r/m8,imm8        80    /6 ib  Logical Exclusive OR
XOR r/m32,imm32      81    /6 id  Logical Exclusive OR
XOR r/m32,imm8       83    /6 ib  Logical Exclusive OR
XOR r/m8,r8          30    /r     Logical Exclusive OR
XOR r/m32,r32        31    /r     Logical Exclusive OR
XOR r8,r/m8          32    /r     Logical Exclusive OR
XOR r32,r/m32        33    /r     Logical Exclusive OR" 0]

;;
  Each Name must be 16 Bytes aligned for the search. Any error breaks all of the
  downward searches down.
  
  A '<' before the Name indicates a substitution. Example, 'AAD' is in the same
  B_U_Asm Description as 'AAA'.
;;
[<16 OldOpCodeList: B$
'AAA            <AAD            <AAM            <AAS             ADC             '
'ADD             ADDPD           ADDPS           ADDSD           ADDSS           '
'ADDSUBP         ADDSUBS         AND             ANDNPS          ANDPD           '
'ANDPS           ARPL            BOUND           BSF            <BSR             '
'BSWAP           BT             <BTC            <BTR            <BTS             '
'CALL            CBW            <CDQ            <CWD            <CWDE            '
'CLC            <CLD            <CLI            <CLTS            CMC             '
'CLFLUSH         '
'CMOVcc         <CMOVA          <CMOVAE         <CVMOVB         <CMOVBE         <'
'CMOVC          <CMOVE          <CMOVG          <CMOVE          <CMOVL          <'
'CMOVLE         <CMOVNA         <CMOVNAE        <CMOVNB         <CMOVNBE        <'
'CMOVNC         <CMOVNE         <CMOVNG         <CMOVNGE        <CMOVNL         <'
'CMOVNLE        <CMOVNO         <CMOVNP         <CMOVNS         <CMOVNZ         <'
'CMOVO          <CMOVP          <CMOVPE         <CMOVPO         <CMOVS          <'
'CMOVZ           '

'CMP             '

'CMPccPD        <CMPEQPD        <CMPLEPD        <CMPLTPD        <CMPNEQPD       <'
'CMPNLEPD       <CMPNLTPD       <CMPORDPD       <CMPPD          <CMPUNORDPD      '

'CMPccPS        <CMPEQPS        <CMPLEPS        <CMPLTPS        <CMPNEQPS       <'
'CMPNLEPS       <CMPNLTPS       <CMPORDPS       <CMPPS          <CMPUNORDPS      '

'CMPccSD        <CMPEQSD        <CMPLESD        <CMPLTSD        <CMPNEQSD       <'
'CMPNLESD       <CMPNLTSD       <CMPORDSD       <CMPSD          <CMPUNORDSD      '

'CMPccSS        <CMPEQSS        <CMPLESS        <CMPLTSS        <CMPNEQSS       <'
'CMPNLESS       <CMPNLTSS       <CMPORDSS       <CMPSS          <CMPUNORDSS      '
'CMPSB          <CMPSD           <CMPSW          '
'CMPXCHG        <CMPXCHG486      CMPXCHG8B       COMISD          COMISS          '

'CVTDQ2PD        CVTDQ2PS        '
'CVTPD2DQ        CVTPD2PI        CVTPD2PS        CVTPI2PD        CVTPI2PS        '
'CVTPS2DQ        CVTPS2PD        CVTPS2PI        '
'CVTSD2SI        CVTSD2SS        CVTSI2SD        CVTSI2SS        '
'CVTSS2SD        CVTSS2SI        '
'CVTTPD2DQ       CVTTPD2PI       CVTTPS2DQ       CVTTPS2PI       '
'CVTTSD2SI       CVTTSS2SI       '

'CPUID           DAA            <'
'DAS             DEC             DIV             DIVPD           DIVPS           '
'DIVSS           '
'EMMS            ENTER           '
'F2XM1           FABS            FADD           <FADDP           FBLD            '
'FBSTP           FCHS            FCLEX          <FNCLEX          '
'FCMOVcc        <FCMOVB         <FCMOVBE        <'
'FCMOVE         <FCMOVNB        <FCMOVNBE       <FCMOVNE        <FCMOVNU        <'
'FCMOVU          FCOM           <FCOMI          <FCOMIP         <FCOMP          <'
'FCOMPP          FCOS            FDECSTP         '
'FDIV           <'
'FDIVP          <FDIVR          <FDIVRP          FEMMS           '

'FFREE           FIADD           FICOM          <FICOMP          FIDIV          <'
'FIDIVR          FIMUL           FINCSTP         FINIT          <FNINIT          '
'FILD           <FIST           <FISTP           FISUB           FISUBR          '
'FLD             '
'FLDxx          <FLD1           <FLDL2E         <FLDL2T         <FLDLG2         <'
'FLDLN2         <FLDZ           <FLDPI           '

'FLDCW           FLDENV          '
'FMUL           <FMULP           '
'FNOP            '
'FPATAN         <FPTAN           FPREM          <FPREM1          FRNDINT         '
'FRSTOR         <FSAVE          <FNSAVE          FSCALE          FSETPM          '
'FSIN           <FSINCOS         '
'FSQRT           FST            <FSTP            FSTCW          <FNSTCW          '
'FSTENV         <FNSTENV         '
'FSTSW           FSUB           <FSUBP          <FSUBR          <FSUBRP          '
'FTST            FUCOM          <FUCOMI         <FUCOMIP        <'

'FUCOMxx        <FUCOMP         <FUCOMPP        <FUCOMI         <FUCOMIP         '

'FXAM            FXCH            FXRSTOR         '
'FXSAVE          FXTRACT         FYL2X          <FYL2XP1         HLT             '
'IBTS            ICEBP           IDIV            IMUL            IN              '
'INC             INCBIN          INSB           <INSD           <INSW            '
'INT             INT01           INT03           INT1            INT3            '
'INTO            INVD            INVLPG          IRET           <IRETD          <'
'IRETW           JCXZ           <JECXZ           JMP             '

'Jcc            <JA             <JAE            <JB             <JBE            <'
'JC             <JE             <JG             <JGE            <JL             <'
'JLE            <JNA            <JNAE           <JNB            <JNBE           <'
'JNC            <JNE            <JNG            <JNGE           <JNL            <'
'JNLE           <JNO            <JNP            <JNS            <JNZ            <'
'JO             <JP             <JPE            <JPO            <JS             <'
'JZ              '

'LAHF            LAR             LDMXCSR         LEA             '
'LDS            <LES            <LGS            <LFS            <LSS             '
'LEAVE           LGDT           <LIDT           <LLDT            '
'LMSW            LOCK            '
'LODSB          <LODSD          <LODSW           LOOP           <LOOPE          <'
'LOOPNE         <LOOPNZ         <LOOPZ           LSL             '
'LTR             MASKMOVQ        MAXPD           MAXPS           MAXSS           '
'MINPS           '
'MINSS           MOV             MOVAPD          MOVAPS          MOVD            '
'MOVDQ2Q         MOVDQA          MOVDQU          '
'MOVHLPS         MOVHPD          '
'MOVHPS          MOVLHPS         MOVLPD          MOVLPS          MOVMSKPS        '
'MOVMSKPD        '
'MOVNTPS         '
'MOVNTQ          MOVQ            MOVQ2DQ         MOVSB           MOVSD           '
'MOVSW           MOVSS           '
'MOVSW           MOVSX           MOVUPS          MOVZX           MUL             '
'MULPD           MULPS           MULSD           '
'MULSS           NEG             NOP             NOT             '
'OR              ORPD            '
'ORPS            OUT             OUTSB           OUTSD           '
'OUTSW           PACKSSDW       <PACKSSWB       <PACKUSWB        '
'PADDB          <PADDW          <PADDD           '
'PADDQ           '
'PADDSB         <PADDSW          PADDSIW         PADDUSB        <'
'PADDUSW         PAND           <PANDN           PAVEB           '
'PAVGB          <PAVGW           PAVGUSB         '

'PCMPxx         <PCMPEQB        <PCMPEQD        <PCMPEQW        <'
'PCMPGTB        <PCMPGTD        <PCMPGTW         '

'PDISTIB         '
'PEXTRW          PF2ID           PFPFACC         PFADD           '

'PFCMPxx        <PFCMPEQ        <PFCMPGE        <PFCMPGT         '

'PFMAX           PFMIN           PFMUL           PFNACC          '
'PFRCP           PFRCPIT1        PFRCPIT2        PFRSQIT1        PFRSQRT         '
'PFSUB           PFSUBR          PI2FD           PINSRW          PMACHRIW        '
'PMADDWD         PMAXSW          PMINSW          '
'PMINUB          PMOVMSKB        PMULHRWA        '
'PMULHUW         PMULHW          PMULLW          '

'POP             POPA           <POPAD          <'
'POPAW           POPF           <POPFD          <POPFW           POR             '
'PREFETCH       <PREFETCHW       '
'PREFETCHh      <PREFETCHNTA    <PREFETCHT0     <PREFETCHT1     <PREFETCHT2      '
'PSADBW          PSLLD           PSLLQ           PSLLW           '
'PSRAD           PSRAW           PSRLD           PSRLQ           PSRLW           '
'PSUBB          <PSUBW          <PSUBD          <PSUBQ           '

'PSUBSB         <PSUBSW          '

'PSUBUSB        <PSUBUSW        <PSUBUSB        <PSUBUSW         '

'PUNPCKxxx      <PUNPCKHBW      <PUNPCKHDQ      <PUNPCKHQDQ     <'
'PUNPCKHWD      <PUNPCKLBW      <PUNPCKLDQ      <PUNPCKLWD      <PUNPCKLQDQ      '

'PUSH            '
'PUSHA          <PUSHAD          PUSHAW          PUSHF          <PUSHFD         <'
'PUSHFW          PXOR            RCL             RCPPS           RCR             '
'RDMSR           RDPMC           RDSHR           RDTSC           '
'RET             '
'RETF            RETN            ROR             RSDC            RSLDT           '
'RSM             RSQRTPS         RSQRTSS         SAHF            SAL             '
'SAR             SBB             SCASB          <SCASD          <'
'SCASW           '

'SETcc          <SETA           <SETAE          <SETB           <SETBE          <'
'SETC           <SETE           <SETG           <SETGE          <SETL           <'
'SETLE          <SETNA          <SETNAE         <SETNB          <SETNC          <'
'SETNE          <SETNG          <SETNL          <SETNLE         <SETNO          <'
'SETNP          <SETNS          <SETNZ          <SETNO          <SETP           <'
'SETPE          <SETPO          <SETS           <SETZ            '

'SFENCE          SGDT            SHL             '
'SHLD            SHR             SHRD            SHUFPS          SIDT            '
'SLDT            SMSW            '
'SQRTPS          SQRTSS          STC             STD             STI             '
'STMXCSR         STOSB          <STOSD          <STOSW           STR             '
'SUB             SUBPS           SUBSS           '
'SYSCALL         SYSENTER        SYSEXIT         SYSRET          '
'TEST            UCOMISS         UD1             UD2             '
'UNPCKHPS        UNPCKLPS        VERR            VERW            WAIT            '
'WBINVD          WRMSR           XADD            '
'XCHG            XLATB           XOR             XORPD           XORPS           '
0 0 0 0  0 0 0 0  0 0 0 0  0 0 0 0]


[<16 OpCodeList: B$

'AAA             AAS             AAM             AAD             ADC             '
'ADD             ADDPD           ADDPS           ADDSD           ADDSS           '
'ADDSUBPD        ADDSUBPS        AND             ANDNPD          ANDNPS          '
'ANDPD           ANDPS           ARPL            '

'BOUND           BSF             BSR             BSWAP           BT              '
'BTC             BTR             BTS             '

'CALL            CBW             CWD             CWDE            CDQ             '
'CLC             CLD             CLI             CLTS            CLFLUSH         '
'CMC             CMP             '
'CMPccPD        <CMPEQPD        <CMPLEPD        <CMPLTPD        <CMPNEQPD       <'
'CMPNLEPD       <CMPNLTPD       <CMPORDPD       <CMPPD          <CMPUNORDPD      '
'CMPccPS        <CMPEQPS        <CMPLEPS        <CMPLTPS        <CMPNEQPS       <'
'CMPNLEPS       <CMPNLTPS       <CMPORDPS       <CMPPS          <CMPUNORDPS      '
'CMPccSD        <CMPEQSD        <CMPLESD        <CMPLTSD        <CMPNEQSD       <'
'CMPNLESD       <CMPNLTSD       <CMPORDSD       <CMPUNORDSD      '
'CMPccSS        <CMPEQSS        <CMPLESS        <CMPLTSS        <CMPNEQSS       <'
'CMPNLESS       <CMPNLTSS       <CMPORDSS       <CMPSS          <CMPUNORDSS      '
'CMPSB           CMPSW           CMPSD           CMPXCHG         CMPXCHG8B       '
'CMOVcc         <FCMOVB         <FCMOVBE        <'
'FCMOVE         <FCMOVNB        <FCMOVNBE       <FCMOVNE        <FCMOVNU        <'
'FCMOVU          '
'COMISD          COMISS          CPUID           '

'CVTDQ2PD        CVTDQ2PS        CVTPD2DQ        CVTPD2PI        CVTPD2PS        '
'CVTPI2PD        CVTPI2PS        CVTPS2DQ        CVTPS2PD        CVTPS2PI        '
'CVTSD2SI        CVTSD2SS        CVTSI2SD        CVTSI2SS        CVTSS2SD        '
'CVTSS2SI        CVTTPD2DQ       CVTTPD2PI       CVTTPS2DQ       CVTTPS2PI       '
'CVTTSD2SI       CVTTSS2SI       '

'DAA             DAS             DEC             DIV             DIVPD           '
'DIVPS           DIVSD           DIVSS           '

'EMMS            ENTER           '

'F2XM1           FABS            FADD            FADDP           FBLD            '
'FBSTP           FCHS            FCLEX           '
'FCMOVcc        <FCMOVB         <FCMOVBE        <'
'FCMOVE         <FCMOVNB        <FCMOVNBE       <FCMOVNE        <FCMOVNU        <'
'FCMOVU          '
'FCOM            FCOMP           FCOMPP          FCOMI           FCOMIP          '
'FCOS            FDECSTP         FDIV            FDIVP           FDIVR           '
'FDIVRP          FEMMS           FFREE           FIADD           FICOM           '
'FICOMP          FIDIV           FIDIVR          FILD            FIST            '
'FISTP           FISTTP          FIMUL           FINCSTP         FINIT           '
'FNINIT          FISUB           FISUBR          FLD             '
'FLDxx          <FLD1           <FLDL2E         <FLDL2T         <FLDLG2         <'
'FLDLN2         <FLDZ           <FLDPI           '
'FLDCW           FLDENV          FMUL            FMULP           FNOP            '
'FNSAVE          FNSTCW          FNSTENV         FPATAN          FPTAN           '
'FNSTSW          '
'FPREM           FPREM1          FRNDINT         FRSTOR          FSAVE           '
'FSCALE          FSETPM          FSIN            FSINCOS         FSQRT           '
'FST             FSTP            FSTCW           FSTENV          FSTSW           '
'FSUB            FSUBP           FSUBR           FSUBRP          FTST            '
'FUCOMxx        <FUCOMP         <FUCOMPP        <FUCOMI         <FUCOMIP         '
'FWAIT           FXAM            FXCH            FXRSTOR         FXSAVE          '
'FXTRACT         FYL2X           FYL2XP1         '

'HADDPD          HADDPS          HSUBPD          HSUBPS          HLT             '

'IDIV            IMUL            INC             IN              INSB            '
'INSD            INSW            INT             INT01           INT1            '
'INT3            ICEBP           INTO            INVD            INVLPG          '
'IRET            IRETW           IRETD           '

'Jcc            <JA             <JAE            <JB             <JBE            <'
'JC             <JE             <JG             <JGE            <JL             <'
'JLE            <JNA            <JNAE           <JNB            <JNBE           <'
'JNC            <JNE            <JNG            <JNGE           <JNL            <'
'JNLE           <JNO            <JNP            <JNS            <JNZ            <'
'JO             <JP             <JPE            <JPO            <JS             <'
'JZ              '
'JCXZ            JECXZ           JMP             '

'LAHF            LAR             LDDQU           LDMXCSR         LDS             '
'LES             LFS             LGS             LSS             LEA             '
'LEAVE           LFENCE          LGDT            LIDT            LLDT            '
'LMSW            LODSB           LODSW           LODSD           LOCK            '
'LOOP            LOOPE           LOOPZ           LOOPNE          LOOPNZ          '
'LSL             LTR             '

'MASKMOVDQU      MASKMOVQ        MAXPD           MAXPS           MAXSD           '
'MAXSS           MFENCE          MINPD           MINPS           MINSD           '
'MINSS           MONITOR         MOV             MOVAPD          MOVAPS          '
'MOVD            MOVDDUP         MOVDQ2Q         MOVDQA          MOVDQU          '
'MOVHLPS         MOVHPD          MOVHPS          MOVLHPS         MOVLPD          '
'MOVLPS          MOVMSKPD        MOVMSKPS        MOVNTDQ         MOVNTI          '
'MOVNTPD         MOVNTPS         MOVNTQ          MOVQ            MOVQ2DQ         '
'MOVSB           MOVSD           MOVSHDUP        MOVSLDUP        MOVSW           '
'MOVSS           MOVSX           MOVUPD          MOVUPS          MOVZX           '
'MUL             MULPD           MULPS           MULSD           MULSS           '
'MWAIT           '

'NEG             NOT             NOP             NOPE            '

'OR              ORPD            ORPS            OUT             OUTSB           '
'OUTSW           OUTSD           '

'PACKSSDW        PACKSSWB        PACKUSWB        PADDB           PADDW           '
'PADDD           PADDQ           PADDSB          PADDSW          PADDUSB         '
'PADDUSW         PAND            PANDN           PAUSE           PAVGB           '
'PAVGW           PAVGUSB         '
'PCMPxxx        <PCMPEQB        <PCMPEQD        <PCMPEQW        <'
'PCMPGTB        <PCMPGTD        <PCMPGTW         '
'PEXTRW          PF2ID           PF2IW           PFACC           PFADD           '
'PFCMPxx        <PFCMPEQ        <PFCMPGE        <PFCMPGT         '
'PFMAX           PFMIN           PFMUL           PFNACC          PFPNACC         '
'PFRCP           PFRCPIT1        PFRCPIT2        PFRSQIT1        PFRSQRT         '
'PFSUB           PFSUBR          PI2FD           PI2FW           PINSRW          '
'PMADDWD         PMAXSW          PMAXUB          PMINSW          PMINUB          '
'PMOVMSKB        PMULHRWA        PMULHUW         PMULHW          PMULLW          '
'PMULUDQ         POP             POPA            POPAD           POPF            '
'POR             PREFETCH        '
'PREFETCHh      <PREFETCHNTA    <PREFETCHT0     <PREFETCHT1     <PREFETCHT2      '
'PSADBW          PSHUFD          PSHUFHW         PSHUFLW         PSHUFW          '
'PSLLDQ          '
'PSLLx          <PSLLW          <PSLLD          <PSLLQ           '
'PSRAx          <PSRAW          <PSRAD          <PSRAQ           '
'PSRLDQ          '
'PSRLx          <PSRLW          <PSRLD          <PSRLQ           '
'PSUBx          <PSUBB          <PSUBW          <PSUBD          <PSUBQ           '
'PSUBxx         <PSUBSB         <PSUBSW         <PSUBUSB        <PSUBUSW         '
'PSWAPD          '
'PUNPCKhxx      <PUNPCKHBW      <PUNPCKHWD      <PUNPCKHDQ      <PUNPCKHQDQ     <'
'PUNPCKLBW      <PUNPCKLWD      <PUNPCKLDQ      <PUNPCKLQDQ      '
'PUSH            PUSHA           PUSHAD          PUSHF           PXOR            '

'RCL             RCR             RCPPS           RCPSS           RDMSR           '
'RDPMC           RDTSC           REP             RET             RETF            '
'RETN            ROL             ROR             '
'RSDC            RSLDT           RSM             RSQRTPS         RSQRTSS         '
'RSTS            '

'SAHF            SAL             SAR             SBB             SCASB           '
'SCASW           SCASD           '
'SETcc           '
'SFENCE          SGDT            SIDT            SLDT            SHL             '
'SHR             SHLD            SHRD            SHUFPD          SHUFPS          '
'SMSW            SQRTPD          SQRTPS          SQRTSD          SQRTSS          '
'STC             STD             STI             STMXCSR         STOSB           '
'STOSW           STOSD           STR             SUB             SUBPD           '
'SUBPS           SUBSD           SUBSS           SYSCALL         SYSENTER        '
'SYSEXIT         SYSRET          '

'TEST            '

'UCOMISD         UCOMISS         UD0             UD1             UD2             '
'UNPCKHPD        UNPCKHPS        UNPCKLPD        UNPCKLPS        '

'VERR            VERW            '

'WAIT            WBINVD          WRMSR           '

'XADD            XCHG            XLATB           XOR             XORPD           '
'XORPS           '

0 0 0 0  0 0 0 0  0 0 0 0  0 0 0 0]


____________________________________________________________________________________________
____________________________________________________________________________________________

[DataToStructureHandle: ?]

DataToStructure:
    If D$DataToStructureHandle > 0
        Beep
    Else
        call 'USER32.DialogBoxParamA' D$hInstance, 32500, &NULL, DataToStructureProc, &NULL
    End_If
ret

____________________________________________________________________________________________


[DataTextTable: ?    StructureTextTable: ?    DataToStructureDialogHandle: ?]

Proc DataToStructureProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND
        mov eax D@wParam | and eax 0FFFF
        If eax = &IDCANCEL
L5:         VirtualFree D$DataTextTable, D$StructureTextTable
            call 'User32.EndDialog' D@Adressee 0
        Else_If eax = &IDOK
            call SaveStructureToClipBoard | jmp L5<
        Else_If eax = &IDHELP
            call Help, B_U_AsmName, StructuresHelp, ContextHlpMessage
        Else_If eax = 5     ; [ >>>>>>>> ]
            call FromDataToStructure
      ;  Else_If eax = 6     ; [ <<<<<<<< ]
      ;      call FromStructureToData
        End_If

    ...Else_If D@Message e &WM_INITDIALOG
        VirtualAlloc DataTextTable 01000, StructureTextTable 01000
        move D$DataToStructureDialogHandle D@Adressee

    ...Else_If D@Message e &WM_CTLCOLOREDIT
        ; Control of output

    ...Else
        popad | mov eax &FALSE | ExitP

    ...End_If

    popad | mov eax &TRUE
EndP


[DisScale: ?    EquateValue: ?   FirstDataLabel: ?]

FromStructureToData:
  ; If wanted, later.
ret

;;
[DataTest:
 Val1: 0
 Val2: 0
 Val3: 0]

[DataXTest: ? #8]

[Data2Test:
 Val21: B$ 0
 Val22: 0
 Val23: 0]
;;

SaveStructureToClipBoard:
    mov eax D$StructureTextTable
    While B$eax > 0 | inc eax | end_While
    sub eax D$StructureTextTable | On eax = 0, ret
    mov D$TheClipLenght eax

    call 'USER32.OpenClipboard' D$hwnd | cmp eax 0 | je L9>>
    call 'USER32.EmptyClipboard' | cmp eax 0 | je L8>>

    mov ecx D$TheClipLenght | shl ecx 2               ; *4 > room for Generic Names
    push ecx
        call 'KERNEL32.GlobalAlloc' &GMEM_DDESHARE ecx | cmp eax 0 | jne L1>  ; > eax = handle
        pop eax | jmp L8>>
L1:     mov D$hBlock eax
        call 'KERNEL32.GlobalLock' eax                                       ; > eax = adress
    pop ecx
    shr ecx 2                                                   ; restore true data size
    mov edi eax, esi D$StructureTextTable

    While B$esi > 0 | movsb | End_While | mov eax 0 | stosd

    call 'KERNEL32.GlobalUnlock' D$hBlock
    call 'USER32.SetClipboardData' &CF_TEXT  D$hBlock
L8: call 'USER32.CloseClipboard'
L9: ret

____________________________________________________________________________________________













TITLE Loaders
________________________________________________________________________________________
________________________________________________________________________________________

                         ; Loaders for non-edited Resources
________________________________________________________________________________________
________________________________________________________________________________________

[WaveType: U$ 'WAVE'    AviType: 'AVI'] [WAVETYPELEN 4    AVITYPELEN 3] ; 'SOUND'

; read new open PE Resources:

ReadRosAsmWaves:
    mov edi WaveList, eax 0, ecx 300 | rep stosd
    mov edi WaveType, edx WAVETYPELEN | call SearchResourceNamedType | On eax = 0, ret
    mov D$WaveListPtr WaveList,  ebx WaveListPtr | call ReadResourcesRecord
ret

ReadRosAsmAvis:
    mov edi AviList, eax 0, ecx 300 | rep stosd
    mov edi AviType, edx AVITYPELEN | call SearchResourceNamedType | On eax = 0, ret
    mov D$AviListPtr AviList,  ebx AviListPtr | call ReadResourcesRecord
    mov esi AviList
ret

ReadRosAsmRCs:
    mov edi RcDataList, eax 0, ecx 300 | rep stosd
    mov ebx &RT_RCDATA | call SearchResourceType | On eax = 0, ret
    mov D$RcDataListPtr RcDataList,  ebx RcDataListPtr | call ReadResourcesRecord
ret


ReadRosAsmCursors:
    mov edi CursorList, eax 0, ecx 300 | rep stosd
    mov ebx &RT_CURSOR | call SearchResourceType | On eax = 0, ret
    mov D$CursorListPtr CursorList,  ebx CursorListPtr | call ReadResourcesRecord
ret


ReadRosAsmGroupCursors:
    mov edi GroupCursorList, eax 0, ecx 300 | rep stosd
    mov ebx RT_GROUP_CURSOR | call SearchResourceType | On eax = 0, ret
    mov D$GroupCursorListPtr GroupCursorList,  ebx GroupCursorListPtr
    call ReadResourcesRecord
ret

ReadRosAsmIcons:
    mov edi IconList, eax 0, ecx 300 | rep stosd

    mov ebx &RT_ICON | call SearchResourceType | On eax = 0, ret

    mov D$IconListPtr IconList,  ebx IconListPtr | call ReadResourcesRecord

  ; Arase the First Icon, Which is the Main One (elsewhere...)
    VirtualFree D$IconList+4

    mov esi IconList, edi esi, ecx MAXICON-3 | add esi 12 | rep movsd
    On D$IconListPtr > IconList, sub D$IconListPtr 12
ret


ReadRosAsmGroupIcons:
    mov edi GroupIconList, eax 0, ecx 300 | rep stosd
    mov ebx RT_GROUP_ICON | call SearchResourceType | On eax = 0, ret
    mov D$GroupIconListPtr GroupIconList,  ebx GroupIconListPtr
    call ReadResourcesRecord

  ; Arase the First GroupIcon, Which is the Main One (elsewhere...)
    VirtualFree D$GroupIconList+4

    mov esi GroupIconList, edi esi, ecx MAXICON-3 | add esi 12 | rep movsd
    On D$GroupIconListPtr > GroupIconList, sub D$GroupIconListPtr 12
ret

[ResourcePointersSecurity: ? #10]

; Each Record of these Lists is: ID / Ptr / Size.

[CursorList: ? #MAXCURSOR]      [CursorListPtr: CursorList]
[GroupCursorList: ? #MAXCURSOR] [GroupCursorListPtr: GroupCursorList]
[IconList: ? #MAXICON]          [IconListPtr: IconList]
[MenuList: ? #MAXMENU]          [MenuListPtr: MenuList]
[DialogList: ? #MAXDIALOG]      [DialogListPtr: DialogList]
[StringsList: ? #MAXSTRINGS]    [StringsListPtr: StringsList]
[GroupIconList: ? #MAXICON]     [GroupIconListPtr: GroupIconList]
[WaveList: ? #MAXWAVE]          [WaveListPtr: WaveList]
[AviList: ? #MAXAVI]            [AviListPtr: AviList]
[RCdataList: ? #MAXRCDATA]      [RCdataListPtr: RCdataList]
[BitMapList: ? #MAXBITMAP]      [BitMapListPtr: BitMapList]
[OtherList: 0    OtherListPtr: 0]

[FontFilesTitle:     B$ 'Choose a Font File', 0
 WaveFilesFilters:   B$ 'Wave Files' 0 '*.wav' 0 0
 WaveFilesTitle:     B$ 'Chose a Wave File', 0
 AviFilesFilters:    B$ 'Avi Files' 0   '*.avi', 0 0
 AviFilesTitle:      B$ 'Choose an Avi File', 0
 RCDataFilesFilters: B$ 'AnyThing' 0  '*.*' 0 0
 RCDataFilesTitle:   B$ 'Choose a File', 0
 CursorFilesFilters: B$ 'Cursor Files' 0   '*.cur' 0 0
 CursorFilesTitle:   B$ 'Choose a Cursor File' 0
 IconFilesFilters: B$ 'Icon Files' 0   '*.Ico' 0 0
 IconFilesTitle:   B$ 'Choose an Icon File' 0
 DialogFilesFilters: B$ 'Dlg Files', 0, '*.dlg', 0, 0
 BinDialogFilesFilters: B$ 'bdf Files', 0, '*.bdf', 0, 0
 BinMenuFilesFilters: B$ 'bmf Files', 0, '*.bmf', 0, 0
 DialogFilesTitle: B$ 'Choose a Dialog Template File' 0
 MenuFilesTitle: B$ 'Choose a Menu Template File' 0]

[OtherChoosenFile: B$ ? #260] [OtherFileFilter: B$ ? #260]
[OtherSourceFilterPtr: B$ ? #260][OtherSaveFilter: ? #260]

[OtherOpenStruc: len
 OtherhwndFileOwner: 0  OtherhInstance: 0
 OtherFilesFilters: 0  OtherFileFilter  260
 OtherSourceFilterPtr  OtherSaveFilter  260  OtherChoosenFile  260  0
 OpenOtherFileTitle: 0  OtherFlags: 0281804 ; for read
 0  0  0  0  0]                   ; 0280006 : for write

[OtherSourceHandle: ?    OtherFileLen: ?    OtherFilePtr: ?]

ReadRCData:
    mov D$OtherFilesFilters RCDataFilesFilters
    mov D$OpenOtherFileTitle RCDataFilesTitle
    mov D$OtherList RcDataList | move D$OtherListPtr D$RCDataListPtr
    call ReadOtherFile
        If D$OtherSaveFilter = 0
            mov D$OtherList 0,  D$OtherListPtr 0 | ret
        End_If
        call AskForResID | add D$RCDataListPtr 12
    call CloseOtherFilesRead
ret


SaveRcData:
    If D$RCDataList = 0
        call 'USER32.MessageBoxA' D$hwnd, NoRcData, Argh, &MB_OK+&MB_SYSTEMMODAL | ret
    End_If

    mov D$WhatDialogListPtr RcDataList,  D$OkDialogFlag &FALSE
    add D$WhatDialogListPtr 4

    call 'USER32.CreateDialogParamA' D$hInstance, 1000, &NULL, EmptyProc, &NULL
    mov D$EmptyDialogHandle eax


    .While B$OkDialogFlag = &FALSE
        call SetRcDataTitle | call ShowHexa
        call SetNextChoiceID
        call 'User32.DialogBoxIndirectParamA' D$hinstance, ChoiceBar, D$hwnd,
                                              ChoiceDialogBoxProc, RcDataList
        .If D$OkDialogFlag = &VK_ESCAPE
            jmp L9>>
        .Else_If D$WhatDialogListPtr < RCDataList
            add D$WhatDialogListPtr 12
            call SetNextChoiceID
        .Else
            mov esi D$WhatDialogListPtr
            If D$esi = 0
                sub D$WhatDialogListPtr 12
                call SetNextChoiceID
            End_If
        .End_If
   .End_While

    call 'USER32.MessageBoxA' D$hwnd, SaveRc, Sure, &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL

    push eax
        call 'User32.EndDialog' D$EmptyDialogHandle &NULL
    pop eax

   .If eax = &IDYES
        mov D$OpenDlg.lpstrFilter RcFilesFilters
        call 'Comdlg32.GetSaveFileNameA' OpenDlg
        mov D$OpenDlg.lpstrFilter DlgFilesFilters
        On eax = &FALSE, ret

        call 'KERNEL32.CreateFileA' SaveDlgFilter &GENERIC_WRITE,
                                &FILE_SHARE_READ__&FILE_SHARE_WRITE, 0,
                                &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0

        If eax = &INVALID_HANDLE_VALUE
            mov eax D$BusyFilePtr | call MessageBox | ret
        End_If

        mov D$DestinationHandle eax, D$NumberOfReadBytes 0
        mov esi D$WhatDialogListPtr, ecx D$esi+4, esi D$esi

        call 'KERNEL32.WriteFile' D$DestinationHandle, esi, ecx, NumberOfReadBytes  0

        call 'KERNEL32.CloseHandle' D$DestinationHandle | mov D$DestinationHandle 0
   .End_If

L9: ret


[NoRcData: 'No RC Data Resources in this PE', 0]
[KillRc: 'Delete this Rc Data Resource?', 0]
[SaveRc: 'Save this RC Resource to Disk?', 0]
[IdTitle: 'RC Data ID: ' IdTitleID: '       ', 0]

SetRcDataTitle:
    mov eax D$WhatDialogListPtr, eax D$eax-4, edi IdTitleID
    call TransDwordToAsciiDecimal
    call 'USER32.SendMessageA' D$EmptyDialogHandle &WM_SETTEXT 0 IdTitle
ret


ShowHexa:
    mov eax D$WhatDialogListPtr, esi D$eax, ecx D$eax+4
    shl ecx 3 | On ecx > 0FF00, mov ecx 0FF00
    push ecx, esi
        VirtualAlloc TempoMemPointer ecx | mov edi D$TempoMemPointer
    pop esi, ecx
    shr ecx 3 | sub ecx 001111 | or ecx 001111
    push edi
L0:     lodsb | shr al 4 | add al '0' | On al > '9', add al 7 | stosb
        dec esi | lodsb | and al 0F | add al '0' | On al > '9', add al 7 | stosb
        mov al ' ' | stosb
        test ecx 00111 | jnz L1>
            mov al ' ' | stosb
        test ecx 001111 | jnz L1>
           sub esi 16
           push ecx
               mov ecx 16
T0:            lodsb | On al < ' ', mov al '.' | stosb | loop T0<
           pop ecx
           mov ax 0A0D | stosw
L1:     loop L0<
    pop edi

    call 'USER32.SetDlgItemTextA' D$EmptyDialogHandle, 100, edi
ret


DeleteRcData:
    If D$RCDataList = 0
        call 'USER32.MessageBoxA' D$hwnd, NoRcData, Argh, &MB_OK+&MB_SYSTEMMODAL | ret
    End_If

    mov D$WhatDialogListPtr RcDataList,  D$OkDialogFlag &FALSE
    add D$WhatDialogListPtr 4
; Tag Dialog 1000
    call 'USER32.CreateDialogParamA' D$hInstance, 1000, &NULL, EmptyProc, &NULL
    mov D$EmptyDialogHandle eax

    .While B$OkDialogFlag = &FALSE
        call SetRcDataTitle | call ShowHexa
        call SetNextChoiceID
        call 'User32.DialogBoxIndirectParamA' D$hinstance, ChoiceBar, D$hwnd, ChoiceDialogBoxProc, RcDataList

        .If D$OkDialogFlag = &VK_ESCAPE
            jmp L9>>
        .Else_If D$WhatDialogListPtr < RCDataList
            add D$WhatDialogListPtr 12
            call SetNextChoiceID
        .Else
            mov esi D$WhatDialogListPtr
            If D$esi = 0
                sub D$WhatDialogListPtr 12 ;| mov esi D$WhatDialogListPtr
                call SetNextChoiceID
            End_If
        .End_If
   .End_While

   call 'USER32.MessageBoxA' D$hwnd, KillRc, Sure, &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL
   If eax = &IDYES
        sub D$WhatDialogListPtr 4
        mov esi D$WhatDialogListPtr, edi esi | add esi 12
        mov eax D$WhatDialogListPtr | sub eax RCDataList | shr eax 2 | mov ecx 300 | sub ecx eax
        rep movsd
        sub D$RCDataListPtr 12
   End_If

L9: call 'User32.EndDialog' D$EmptyDialogHandle &NULL
ret


ReadWaveFile:
    mov D$OtherFilesFilters WaveFilesFilters
    mov D$OpenOtherFileTitle WaveFilesTitle
    mov D$OtherList WaveList | move D$OtherListPtr D$WaveListPtr
    call ReadOtherFile
        If D$OtherSaveFilter = 0
            mov D$OtherList 0,  D$OtherListPtr 0 | ret
        End_If
        call AskForResID | add D$WaveListPtr 12
    call CloseOtherFilesRead
ret


[KillWave: 'Delete this Wave Resource?', 0
 NoWave: 'No Wave Resources in this PE', 0]
[TempoWaveFileHandle: 0  TempoWaveFile: 'Wave$$$.Wav' 0]

DeleteWave:
    If D$WaveList = 0
        call 'USER32.MessageBoxA' D$hwnd, NoWave, Argh, &MB_OK+&MB_SYSTEMMODAL | ret
    End_If

    mov D$WhatDialogListPtr WaveList,  D$OkDialogFlag &FALSE
    add D$WhatDialogListPtr 4

    .While B$OkDialogFlag = &FALSE
        call 'KERNEL32.CreateFileA' TempoWaveFile &GENERIC_WRITE, 0, 0,
                                    &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
        mov D$TempoWaveFileHandle eax
        mov esi D$WhatDialogListPtr
        call 'KERNEL32.WriteFile' D$TempoWaveFileHandle D$esi D$esi+4 NumberOfReadBytes &NULL
        call 'Kernel32.CloseHandle' D$TempoWaveFileHandle
        call 'WINMM.PlaySound' TempoWaveFile &NULL  &SND_ASYNC__&SND_FILENAME
        call SetNextChoiceID
        call 'User32.DialogBoxIndirectParamA' D$hinstance, ChoiceBar, D$hwnd, ChoiceDialogBoxProc, WaveList
        call 'WINMM.PlaySound' &NULL &NULL &NULL
        .If D$OkDialogFlag = &VK_ESCAPE
            jmp L9>>
        .Else_If D$WhatDialogListPtr < WaveList
            add D$WhatDialogListPtr 12
            call SetNextChoiceID
        .Else
            mov esi D$WhatDialogListPtr
            If D$esi = 0
              sub D$WhatDialogListPtr 12 | mov esi D$WhatDialogListPtr
              call SetNextChoiceID
            End_If
        .End_If
   .End_While

    call 'USER32.MessageBoxA' D$hwnd, KillWave, Sure, &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL
    If eax = &IDYES
        sub D$WhatDialogListPtr 4
        mov esi D$WhatDialogListPtr, edi esi | add esi 12
        mov eax D$WhatDialogListPtr | sub eax WaveList | shr eax 2 | mov ecx 300 | sub ecx eax
        rep movsd
        sub D$WaveListPtr 12
    End_If

L9: call 'KERNEL32.DeleteFileA' TempoWaveFile
ret


ReadAviFile:
    mov D$OtherFilesFilters AviFilesFilters
    mov D$OpenOtherFileTitle AviFilesTitle
    mov D$OtherList AviList | move D$OtherListPtr D$AviListPtr
    call ReadOtherFile
        If D$OtherSaveFilter = 0
            mov D$OtherList 0,  D$OtherListPtr 0 | ret
        End_If

        call AskForResID | add D$AviListPtr 12
    call CloseOtherFilesRead
ret


[TempoCursorMem: ?    CursorHotSpot: ?]
[BadCurFile: 'Bad or multiple Cursor(s) file', 0
 BadIcoFile: 'Bad or multiple Icon(s) file', 0]

ReadCursor:
    mov D$OtherFilesFilters CursorFilesFilters
    mov D$OpenOtherFileTitle CursorFilesTitle
    mov D$OtherList CursorList | move D$OtherListPtr D$CursorListPtr

    move D$OtherhwndFileOwner D$hwnd, D$OtherhInstance D$hInstance

    mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc
        If D$OtherSaveFilter = 0
            mov D$OtherList 0,  D$OtherListPtr 0 | ret
        End_If

    call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
      mov eax D$BusyFilePtr | call MessageBox | ret  ; return to caller of caller
    Else
      mov D$OtherSourceHandle eax
    End_If

    call 'KERNEL32.GetFileSize'  eax 0
    mov D$OtherFileLen eax
    VirtualAlloc OtherFilePtr eax

    mov D$NumberOfReadBytes 0
    call 'KERNEL32.ReadFile' D$OtherSourceHandle D$OtherFilePtr,
                            D$OtherFileLen NumberOfReadBytes 0

    mov eax D$OtherFilePtr
    If D$eax+2 <> 010002
        call 'USER32.MessageBoxA' D$hwnd, BadCurFile, Argh, &MB_OK+&MB_SYSTEMMODAL

        VirtualFree D$OtherFilePtr | ret
    End_If

  ; We write both the RT_CURSOR and the RT_GROUP_CURSOR:
    VirtualAlloc TempoCursorMem D$OtherFileLen
    VirtualAlloc TempoMemPointer 20
    mov edi D$GroupCursorListPtr, eax D$TempoMemPointer, D$edi+4 eax, D$edi+8 20

    mov edi eax                                       ; edi > RT_GROUP_CURSOR mem

    mov esi D$OtherFilePtr

    mov ecx 20 | rep movsb
    move D$CursorHotSpot D$edi-10                     ; x/y hot spot
    push edi

    mov esi D$OtherFilePtr | add esi 016
    sub D$OtherFileLen 012 | mov ecx D$OtherFileLen
    mov eax D$CursorHotSpot                           ; PE cursors need the hot spot in data:
    mov edi D$TempoCursorMem | stosd | rep movsb

    VirtualFree D$OtherFilePtr

    move D$OtherFilePtr D$TempoCursorMem

    call AskForResID | call CloseOtherFilesRead

    mov esi D$OtherListPtr | lodsd                    ; rewrite ID to GroupCursor:
    mov edi D$GroupCursorListPtr | stosd
    pop edi
    mov W$edi-2 ax                           ; write the ID in RT_GROUP_CURSOR records
    add D$edi-6 4                            ; +4 size because upper added hot Spot in data

    add D$CursorListPtr 12 | add D$GroupCursorListPtr 12
ret


[TempoIconMem: ?]

ReadIcon:
    mov D$OtherFilesFilters IconFilesFilters
    mov D$OpenOtherFileTitle IconFilesTitle
    mov D$OtherList IconList | move D$OtherListPtr D$IconListPtr

    move D$OtherhwndFileOwner D$hwnd, D$OtherhInstance D$hInstance

    mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc
        If D$OtherSaveFilter = 0
            mov D$OtherList 0,  D$OtherListPtr 0 | ret
        End_If

    call 'KERNEL32.CreateFileA' OtherSaveFilter &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
      mov eax D$BusyFilePtr | call MessageBox | ret  ; return to caller of caller
    Else
      mov D$OtherSourceHandle eax
    End_If

    call 'KERNEL32.GetFileSize'  eax 0
    mov D$OtherFileLen eax
    VirtualAlloc OtherFilePtr eax

    mov D$NumberOfReadBytes 0
    call 'KERNEL32.ReadFile' D$OtherSourceHandle D$OtherFilePtr,
                            D$OtherFileLen NumberOfReadBytes 0

    mov eax D$OtherFilePtr
    If D$eax+2 <> 010001
        call 'USER32.MessageBoxA' D$hwnd, BadIcoFile, Argh, &MB_OK+&MB_SYSTEMMODAL

        VirtualFree D$OtherFilePtr | ret

    End_If

  ; We write both the RT_ICON and the RT_GROUP_ICON:
    VirtualAlloc TempoIconMem D$OtherFileLen
    VirtualAlloc TempoMemPointer 20
    mov edi D$GroupIconListPtr, eax D$TempoMemPointer, D$edi+4 eax, D$edi+8 20

    mov edi eax                                       ; edi > RT_GROUP_ICON mem

    mov esi D$OtherFilePtr

    mov ecx 20 | rep movsb
    push edi

    mov esi D$OtherFilePtr | add esi 016
    sub D$OtherFileLen 012 | mov ecx D$OtherFileLen
    mov edi D$TempoIconMem | rep movsb

    VirtualFree D$OtherFilePtr

    move D$OtherFilePtr D$TempoIconMem

    mov B$OnIconLoad &TRUE
        call AskForResID | call CloseOtherFilesRead
    mov B$OnIconLoad &FALSE

    mov esi D$OtherListPtr | lodsd                    ; rewrite ID to GroupCursor:
    mov edi D$GroupIconListPtr | stosd
    pop edi
    mov W$edi-2 ax                           ; write the ID in RT_GROUP_CURSOR records
    add D$edi-6 4                            ; +4 size because upper added hot Spot in data

    add D$IconListPtr 12 | add D$GroupIconListPtr 12
ret


[AnimateHandle: 0    TempoAviFileHandle: 0
 AnimateClass: 'SysAnimate32' 0    TempoAviFile: 'Avi$$$.avi', 0]
[KillAvi: 'Delete this Avi Resource?', 0
 NoAvi: 'No Avi Resources in this PE', 0]

[EmptyDialog: D$ 0900408C2 0    ; Style
 U$ 0 0 0 0DC 0C8              ; Dim
 0                             ;      no Menu
 '' 0                          ; Class
 '' 0                          ; Title
 08 'Helv' 0]                  ; Font

[EmptyDialogHandle: ?]

Proc EmptyProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    If D@Message = &WM_INITDIALOG
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        mov eax &TRUE

    Else_If D@Message = &WM_CLOSE
        mov B$OkDialogFlag &TRUE
       ; call 'User32.EndDialog' D$ChoiceDialogBoxHandle 0
        call 'User32.DestroyWindow' D@Adressee

    Else
        popad | mov eax &FALSE | jmp L9>

    End_If

    popad | mov eax &TRUE

L9: EndP


DeleteAviFile:
    If D$AviList = 0
        call 'USER32.MessageBoxA' D$hwnd, NoAvi, Argh, &MB_OK+&MB_SYSTEMMODAL | ret
    End_If

    call 'USER32.CreateDialogIndirectParamA' D$hinstance EmptyDialog &NULL Emptyproc 0
    mov D$EmptyDialogHandle eax

    call 'USER32.CreateWindowExA' &WS_SIZEBOX__&WS_DLGFRAME  AnimateClass &NULL,  ; &WS_Border  &WS_BORDER
                                 &ACS_AUTOPLAY__&WS_VISIBLE__&WS_CHILD__&ACS_CENTER,
                                 4 4 200 100 D$EmptyDialogHandle,
                                 0 D$hInstance 0
    mov D$AnimateHandle eax

    mov D$WhatDialogListPtr AviList,  D$OkDialogFlag &FALSE
    add D$WhatDialogListPtr 4

    .While B$OkDialogFlag = &FALSE
        call 'KERNEL32.CreateFileA' TempoAviFile &GENERIC_WRITE, 0, 0,
                                    &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0

        mov D$TempoAviFileHandle eax
        mov esi D$WhatDialogListPtr | mov ecx D$esi+4
        call 'KERNEL32.WriteFile' D$TempoAviFileHandle D$esi ecx NumberOfReadBytes &NULL
        call 'Kernel32.CloseHandle' D$TempoAviFileHandle
        call 'USER32.SendMessageA' D$AnimateHandle &ACM_OPEN  &NULL TempoAviFile
        call SetNextChoiceID
        call 'User32.DialogBoxIndirectParamA' D$hinstance, ChoiceBar, D$hwnd, ChoiceDialogBoxProc, AviList
        call 'USER32.SendMessageA' D$AnimateHandle &ACM_STOP  &NULL &NULL
        .If D$OkDialogFlag = &VK_ESCAPE
            jmp L9>>
        .Else_If D$WhatDialogListPtr < AviList
            add D$WhatDialogListPtr 12
            call SetNextChoiceID
        .Else
            mov esi D$WhatDialogListPtr
            If D$esi = 0
              sub D$WhatDialogListPtr 12 | mov esi D$WhatDialogListPtr
              call SetNextChoiceID
            End_If
        .End_If
    .End_While

    call 'USER32.MessageBoxA' D$hwnd, KillAvi, Sure, &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL
    If eax = &IDYES
        sub D$WhatDialogListPtr 4
        mov esi D$WhatDialogListPtr, edi esi | add esi 12
        mov eax D$WhatDialogListPtr | sub eax AviList | shr eax 2 | mov ecx 300 | sub ecx eax
        rep movsd
        sub D$AviListPtr 12
    End_If

L9: call 'USER32.DestroyWindow' D$AnimateHandle
    call 'User32.EndDialog' D$EmptyDialogHandle &NULL
    call 'KERNEL32.DeleteFileA' TempoAviFile
ret


[NoCursor: 'No Cursor Resources in this PE' 0
 KillCursor: 'Delete this Cursor?' 0
 KillIcon: 'Delete this Icon?' 0
 TempoCursorFile: 'Cursor.$$$' 0
 CurDataPtr: W$ 0   D$ 016]

[UserCursorHandle: ?    TempoCursorFileHandle: ?]

DeleteCursor:
    If D$CursorList = 0
        call 'USER32.MessageBoxA' D$hwnd, NoCursor, Argh, &MB_OK+&MB_SYSTEMMODAL | ret
    End_If

    mov D$WhatDialogListPtr CursorList,  D$OkDialogFlag &FALSE, D$EmptyDialogHandle 0
    add D$WhatDialogListPtr 4

    .While B$OkDialogFlag = &FALSE
        On D$EmptyDialogHandle <> 0, call 'User32.EndDialog' D$EmptyDialogHandle &NULL
        call 'USER32.CreateDialogIndirectParamA' D$hinstance EmptyDialog &NULL Emptyproc 0
            mov D$EmptyDialogHandle eax
        call 'KERNEL32.CreateFileA' TempoCursorFile &GENERIC_WRITE, 0, 0,
                                    &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
        mov D$TempoCursorFileHandle eax
        mov eax D$WhatDialogListPtr | sub eax CursorList | add eax GroupCursorList
        mov ecx D$eax | sub D$ecx+14 4 | mov ecx D$ecx+14  ; how much -4 for added Hot Spot
        push eax, ecx
            call 'KERNEL32.WriteFile' D$TempoCursorFileHandle D$eax 010 NumberOfReadBytes &NULL
            call 'KERNEL32.WriteFile' D$TempoCursorFileHandle CurDataPtr 6 NumberOfReadBytes &NULL
            mov esi D$WhatDialogListPtr, esi D$esi | add esi 4
        pop ecx, eax
        mov eax D$eax | add D$eax+14 4                     ; restore our 'how much'
        call 'KERNEL32.WriteFile' D$TempoCursorFileHandle esi ecx NumberOfReadBytes &NULL
        call 'Kernel32.CloseHandle' D$TempoCursorFileHandle
        call 'User32.LoadCursorFromFileA' TempoCursorFile
        If D$UserCursorHandle > 0
            pushad
               call 'USER32.DestroyCursor' D$UserCursorHandle
            popad
        End_If
        mov D$UserCursorHandle eax
            call 'USER32.GetDC' D$EmptyDialogHandle
            push eax
                call 'User32.DrawIcon' eax 10 10 D$UserCursorHandle
            pop eax
            call 'USER32.ReleaseDC' D$EmptyDialogHandle eax
            call SetNextChoiceID
        call 'User32.DialogBoxIndirectParamA' D$hinstance, ChoiceBar,
                                             D$hwnd, ChoiceDialogBoxProc, CursorList

        .If D$OkDialogFlag = &VK_ESCAPE
            jmp L9>>
        .Else_If D$WhatDialogListPtr < CursorList
            add D$WhatDialogListPtr 12
            call SetNextChoiceID
        .Else
            mov esi D$WhatDialogListPtr
            If D$esi = 0
              sub D$WhatDialogListPtr 12
              call SetNextChoiceID
            End_If
        .End_If
   .End_While

   call 'USER32.MessageBoxA' D$hwnd, KillCursor, Sure, &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL
   If eax = &IDYES
       sub D$WhatDialogListPtr 4
       mov esi D$WhatDialogListPtr, edi esi | add esi 12
       mov ebx D$edi                                                ; ebx = ID
       mov eax D$WhatDialogListPtr | sub eax CursorList | shr eax 2
       mov ecx MAXCURSOR | sub ecx eax | rep movsd
       sub D$CursorListPtr 12

       mov esi GroupCursorList, ecx MAXCURSOR
       While D$esi <> ebx
           add esi 12 | sub ecx 3
       End_While
       mov edi esi | add esi 12  | rep movsd
       sub D$GroupCursorListPtr 12
   End_If

L9: call 'User32.EndDialog' D$EmptyDialogHandle &NULL
    call 'KERNEL32.DeleteFileA' TempoCursorFile
ret


[UserIconHandle: ?]

[ICONINFO:
 ICONINFO_fIcon: D$ &TRUE
 ICONINFO_xHotspot: D$ 0
 ICONINFO_yHotspot: D$ 0
 ICONINFO_hbmMask: D$ 0
 ICONINFO_hbmColor: D$ 0]


DeleteIcon:
    If D$IconList = 0
        call 'USER32.MessageBoxA' D$hwnd, NoIcon, Argh, &MB_OK+&MB_SYSTEMMODAL | ret
    End_If

    mov D$WhatDialogListPtr IconList,  D$OkDialogFlag &FALSE, D$EmptyDialogHandle 0
    add D$WhatDialogListPtr 4

   ; ID / Pointer / Size.

    .While B$OkDialogFlag = &FALSE
        On D$EmptyDialogHandle <> 0, call 'User32.EndDialog' D$EmptyDialogHandle &NULL
        call 'USER32.CreateDialogIndirectParamA' D$hinstance EmptyDialog &NULL Emptyproc 0
            mov D$EmptyDialogHandle eax
        call 'KERNEL32.CreateFileA' TempoCursorFile &GENERIC_WRITE, 0, 0,
                                    &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, 0
        mov D$TempoCursorFileHandle eax
        mov eax D$WhatDialogListPtr | sub eax IconList | add eax GroupIconList

      ; May hang down there here with an ecx = 0. So, temporary:
        On D$eax = 0, jmp L9>>

        mov ecx D$eax | mov ecx D$ecx+14
        push ecx
            call 'KERNEL32.WriteFile' D$TempoCursorFileHandle D$eax 010 NumberOfReadBytes &NULL
            call 'KERNEL32.WriteFile' D$TempoCursorFileHandle CurDataPtr 6 NumberOfReadBytes &NULL
            mov esi D$WhatDialogListPtr
        pop ecx
        call 'KERNEL32.WriteFile' D$TempoCursorFileHandle D$esi D$esi+4 NumberOfReadBytes &NULL
        call 'Kernel32.CloseHandle' D$TempoCursorFileHandle
        call 'User32.LoadCursorFromFileA' TempoCursorFile
        If D$UserCursorHandle > 0
            pushad
               call 'USER32.DestroyCursor' D$UserCursorHandle
            popad
        End_If
        mov D$UserCursorHandle eax
            call 'USER32.GetDC' D$EmptyDialogHandle
            push eax
                call 'User32.DrawIcon' eax 10 10 D$UserCursorHandle
            pop eax
            call 'USER32.ReleaseDC' D$EmptyDialogHandle eax
            call SetNextChoiceID

        call 'User32.DialogBoxIndirectParamA' D$hinstance, ChoiceBar,
                                             D$hwnd, ChoiceDialogBoxProc, IconList

        .If D$OkDialogFlag = &VK_ESCAPE
            jmp L9>>
        .Else_If D$WhatDialogListPtr < IconList
            add D$WhatDialogListPtr 12
            call SetNextChoiceID
        .Else
            mov esi D$WhatDialogListPtr
            If D$esi = 0
              sub D$WhatDialogListPtr 12
              call SetNextChoiceID
            End_If
        .End_If
   .End_While

    call 'USER32.MessageBoxA' D$hwnd, KillIcon, Sure, &MB_ICONQUESTION+&MB_YESNO+&MB_SYSTEMMODAL
    If eax = &IDYES
        sub D$WhatDialogListPtr 4
        mov esi D$WhatDialogListPtr, edi esi | add esi 12
        mov ebx D$edi                                                ; ebx = ID
        mov eax D$WhatDialogListPtr | sub eax IconList | shr eax 2
        mov ecx MAXICON | sub ecx eax | rep movsd
        sub D$IconListPtr 12

        mov esi GroupIconList, ecx MAXICON
        While D$esi <> ebx
            add esi 12 | sub ecx 3
        End_While
        mov edi esi | add esi 12  | rep movsd
        sub D$GroupIconListPtr 12
    End_If

L9: call 'User32.EndDialog' D$EmptyDialogHandle &NULL
    call 'KERNEL32.DeleteFileA' TempoCursorFile
ret


ReadOtherFile:
    move D$OtherhwndFileOwner D$hwnd, D$OtherhInstance D$hInstance

    mov edi OtherSaveFilter, ecx 260, eax 0 | rep stosd
    call 'Comdlg32.GetOpenFileNameA' OtherOpenStruc
      On D$OtherSaveFilter = 0,  ret

  ; Loading the entire file in memory:
    On D$OtherSourceHandle > 0, call 'KERNEL32.CloseHandle' D$OtherSourceHandle
    mov D$OtherSourceHandle 0

    call 'KERNEL32.CreateFileA' OtherSaveFilter, &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0,
                                &OPEN_EXISTING, &FILE_ATTRIBUTE_NORMAL, 0
    If eax = &INVALID_HANDLE_VALUE
      mov eax D$BusyFilePtr | call MessageBox | ret  ; return to caller of caller
    Else
        mov D$OtherSourceHandle eax
    End_If

    call 'KERNEL32.GetFileSize'  eax 0 | mov D$OtherFileLen eax

    VirtualAlloc OtherFilePtr eax

    mov D$NumberOfReadBytes 0
    call 'KERNEL32.ReadFile' D$OtherSourceHandle, D$OtherFilePtr,
                            D$OtherFileLen, NumberOfReadBytes 0
ret


CloseOtherFilesRead:
    On D$OtherSourceHandle > 0, call 'KERNEL32.CloseHandle' D$OtherSourceHandle
    mov D$OtherSourceHandle 0
ret



AskForResID:
    call 'USER32.DialogBoxIndirectParamA' D$hinstance, OtherIdTemplate, 0, OtherIDProc, 0
ret


[OtherEditHandle: 0    OtherID: '                   ', 0]

[OnIconLoad: ?]

Proc OtherIDProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    .If D@Message = &WM_COMMAND
       ..If D@wParam = &IDCANCEL
            call 'User32.EndDialog' D@Adressee 0
       ..Else_If D@wParam = &IDOK
           call 'User32.GetDlgItem' D@Adressee 3 | mov D$OtherEditHandle eax
           call 'User32.SendMessageA' D$OtherEditHandle &WM_GETTEXTLENGTH 0 0 | inc eax
           call 'User32.SendMessageA' D$OtherEditHandle &WM_GETTEXT eax OtherID
           TranslateAsciiToDword OtherID
           If eax > 0FFFF
             mov eax D$IdTooBigPtr | call MessageBox
           Else_If eax < 1
             mov eax D$IdTooSmallPtr | call MessageBox
           Else
             mov edi D$OtherListPtr | stosd
             mov eax D$OtherFilePtr | stosd
             mov eax D$OtherFileLen | stosd
             call 'User32.EndDialog' D@Adressee 0
           End_If
       ..End_If

    .Else_If D@Message = &WM_INITDIALOG
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        call 'User32.GetDlgItem' D@Adressee 3
        call 'User32.SendMessageA' eax &EM_SETLIMITTEXT 5  0
           mov esi D$OtherListPtr | On esi > D$OtherList, sub esi 12
           If D$esi = 0
             mov eax 1
             On B$OnIconLoad = &TRUE, inc eax
           Else
             lodsd | inc eax
           End_If
           call 'USER32.SetDlgItemInt' D@Adressee 3 eax 0
    .Else
       popad | mov eax &FALSE | jmp L9>

    .End_If

    popad | mov eax &TRUE

L9: EndP


[OtherIdTemplate: D$ 090C408C2 0    ; Style
 U$ 03 0 0 0B9 018             ; Dim
 0                             ; no Menu
 '' 0                          ; Class
 'What ID number for new Resource?' 0 ; Title
 08 'Helv' 0]                  ; Font

[OID0: D$ 050000000 0         ; Style
 U$ 07E 03 038 013             ; Dim
 01                            ; ID
 0FFFF 080                     ; Class
 'OK' 0                        ; Title
 0]                            ; No creation data

[OID1: D$ 050000000 0         ; Style
 U$ 03 03 038 013              ; Dim
 02                            ; ID
 0FFFF 080                     ; Class
 'Abort' 0                     ; Title
 0]                            ; No creation data

[OID2: D$ 050802000 0         ; Style
 U$ 040 05 038 0F              ; Dim
 03                            ; ID
 0FFFF 081                     ; Class
 '' 0                          ; Title
 0]                            ; No creation data


TITLE Clip
____________________________________________________________________________________________
____________________________________________________________________________________________
;                                     Templates.
;
; A simple bank of Templates to be copied inside the user ClipBoard trough a friendly
; Dialog interface ([Clip] Menu Option).

[GenericName: 0 #10]     ; 40 bytes for a name to add to symbols.

; 'TemplateChoice' 'AddGroup' 'DeleteGroup' 'AddTemplate' 'DeleteTemplate'
;
;
; Proc modified is: 'ShowClip'
; Additional procs added are: 'Clip_Disable_Customization_Controls' and
; 'Clip_Enable_Customization_Controls'
____________________________________________________________________________________________
____________________________________________________________________________________________

[ClipMessage: " Copy 'Clip.txt' in this directory
or run [Config] menu option" 0]

Templates:
    If D$ClipperHandle > 0
        Beep | ret
    End_If

    On eax = M00_Clip_File, jmp L1>

    If D$NumberOfClipFiles > 1
        call LoadSelectedClipFile
    Else
L1:     call LoadClipFile
    End_If

    If B$ClipFileReady = &TRUE
      ; Tag Dialog 2000
        call 'USER32.DialogBoxParamA' D$hInstance, 2000, &NULL, TemplateChoice, &NULL
        call ReleaseClipFile
    Else_If B$ClipFileReady = &FALSE
        call 'User32.MessageBoxA' D$hwnd, ClipMessage, FileNotFound, &MB_ICONINFORMATION+&MB_SYSTEMMODAL
    Else_If B$ClipFileReady = 0-1
        call 'USER32.MessageBoxA' D$hwnd, ClipTitleWanted, UnvalidClipTitle, &MB_SYSTEMMODAL
        call ReleaseClipFile
    End_If
ret


[ClipFileHandle: ?   ClipFileSize: ?    ClipFileMemoryPointer: ?    ClipMemoryEnd: ?
 ClipFileReady: ?]

[CLIPRESERVATION 010000]

LoadClipFile:
    call 'KERNEL32.CreateFileA' ClipName, &GENERIC_READ, 0, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, &NULL
    If eax = &INVALID_HANDLE_VALUE
        mov B$ClipFileReady &FALSE | ret
    Else
        mov B$ClipFileReady &TRUE, D$ClipFileHandle eax
    End_If

    call 'KERNEL32.GetFileSize' D$ClipFileHandle, &NULL | mov D$ClipFileSize eax

    add eax CLIPRESERVATION | VirtualAlloc ClipFileMemoryPointer, eax

    add eax D$ClipFileSize | add eax CLIPRESERVATION | mov D$ClipMemoryEnd eax

    call 'KERNEL32.ReadFile' D$ClipFileHandle, D$ClipFileMemoryPointer, D$ClipFileSize,
                            NumberOfReadBytes, &NULL
    call ClipCRLFs
ret


LoadSelectedClipFile:
  ; eax stil hold the ID: 7000, 7001, ...
    sub eax 7000

    mov esi ClipMenuStrings
    .While eax > 0
        While B$esi <> 0 | inc esi | End_While | inc esi
        dec eax
    .End_While

    mov edi ClipName
    While B$edi <> 0 | inc edi | End_While
    While B$edi <> '\' | dec edi | End_While | inc edi
    While B$esi <> 0 | movsb | End_While | movsb

    call LoadClipFile
ret


WriteClipFile:
    call 'KERNEL32.CloseHandle' D$ClipFileHandle

    call 'KERNEL32.CreateFileA' ClipName, &GENERIC_READ__&GENERIC_WRITE, 0, 0,
                                &CREATE_ALWAYS, &FILE_ATTRIBUTE_NORMAL, &NULL
    mov D$ClipFileHandle eax, D$NumberOfReadBytes 0

    call 'KERNEL32.WriteFile' D$ClipFileHandle, D$ClipFileMemoryPointer, D$ClipFileSize,
                              NumberOfReadBytes, 0
ret


ReleaseClipFile:
    VirtualFree D$ClipFileMemoryPointer
    call 'KERNEL32.CloseHandle' D$ClipFileHandle
ret


[OneClipName: ? #40]

ReadClipsections:
    call 'USER32.SendMessageA' D$TemplateList1, &LB_RESETCONTENT, 0, 0

    mov esi D$ClipFileMemoryPointer

    .While esi < D$ClipMemoryEnd
        lodsb
        If al = '/'
            .If B$esi = '/'
                ..If B$esi-2 < ' '
                    inc esi | mov edi OneClipName
                    While B$esi >= ' '
                        movsb
                    End_While
                    mov al 0 | stosb

                    call 'USER32.SendMessageA' D$TemplateList1, &LB_ADDSTRING,
                                               0, OneClipName
                ..End_If
            .End_If
        End_If
    .End_While
ret


; in eax: 0 based index of the first ListBox (Sections)

[SectionPointer: ?]

SearchSection:
    inc eax | mov ebx eax
    mov esi D$ClipFileMemoryPointer

    .While esi < D$ClipMemoryEnd
        lodsb
        If al = '/'
            .If B$esi = '/'
                ..If B$esi-2 < ' '
                    dec ebx | jnz L1>
                        While B$esi <> LF
                            inc esi
                        End_While
                        inc esi | mov D$SectionPointer esi | ret
L1:             ..End_If
            .End_If
        End_If
    .End_While

    mov D$SectionPointer 0
ret


ReadClipTitles:
    mov esi D$SectionPointer
    mov edx D$ClipFileMemoryPointer | add edx D$ClipFileSize

    .While esi < edx ;D$ClipMemoryEnd
        lodsb
        If al = '/'
            .If B$esi-2 < ' '
                ..If B$esi = '/'
                    ret
                ..Else
                    mov edi OneClipName
                    While B$esi >= ' '
                        movsb
                    End_While
                    mov al 0 | stosb
                    push edx
                        call 'USER32.SendMessageA' D$TemplateList2  &LB_ADDSTRING,
                                                   0 OneClipName
                    pop edx
                ..End_If
            .End_If
        End_If
    .End_While
ret


; in eax: 0 based index of the second ListBox (Titles)

[ClipPointer: ?   ClipGroupIndex: ?   ClipIndex: ?]

SearchTheClip:
    mov D$TheClipLenght 0, D$ClipPointer 0
    call 'USER32.SendMessageA' D$TemplateList2, &LB_GETCURSEL, 0, 0 | cmp eax &LB_ERR | je L9>>
    mov D$ClipIndex eax
    mov esi D$SectionPointer | inc eax | mov ebx eax

    .While esi < D$ClipMemoryEnd
        lodsb
        If al = '/'
            .If B$esi-2 < ' '
                dec ebx | jnz L1>
                    While B$esi <> LF
                            inc esi
                    End_While

                    inc esi | mov D$ClipPointer esi | call SearchTheClipLenght | jmp L9>
L1:         .End_If
        End_If
    .End_While
L9: ret


[TheClipLenght: ?]

SearchTheClipLenght:
    .While esi < D$ClipMemoryEnd
        lodsb | inc D$TheClipLenght
        .If al = '/'
            If B$esi-2 < ' '
                dec D$TheClipLenght | ret
            End_If
        .Else_If al = 0
            dec D$TheClipLenght | ret
        .End_If
    .End_While
ret
____________________________________________________________________________________________


[TempoClipmemoryPtr: ?]
[ControlID108: ?] ; Handle to Generic Name textbox
[ControlID104: ?] ; These are the 4 handles to the radio buttons.
[ControlID105: ?]
[ControlID106: ?]
[ControlID107: ?]


ShowClip:
    call RetrieveGenericName
    call SearchTheClip | On D$TheClipLenght = 0, ret

    mov ecx D$TheClipLenght | shl ecx 2               ; *4 > room for Generic Names
    push ecx
        VirtualAlloc TempoClipmemoryPtr ecx
        mov edi D$TempoClipmemoryPtr, esi D$ClipPointer
    pop ecx
    shr ecx 2                                                   ; restore true data size

  ; If the very first Char after the first CR/LF is '@', we load the Clip 'As is':
    mov ebx esi | add ebx 2
    While B$ebx <= ' ' | inc ebx | End_While

    .If B$ebx = '@'
        call Clip_Disable_Customization_Controls
        call SearchTheClip | On D$TheClipLenght = 0, ret
        mov esi D$ClipPointer, ecx D$TheClipLenght
        While B$esi <> '@'
            inc esi | dec ecx | jz L8>
        End_While | inc esi | dec ecx | jz L8>
        rep movsb

    .Else_If B$WithData = &TRUE
        If B$GlobalScope = &TRUE
            call WithDataGlobalScope
        Else
            call WithDataLocalScope
        End_If
        call Clip_Enable_Customization_Controls
    .Else
        If B$GlobalScope = &TRUE
            call WithoutDataGlobalScope
        Else
            call WithoutDataLocalScope
        End_If
        call Clip_Enable_Customization_Controls
    .End_If

    mov eax 0 | stosd

    call 'USER32.SendMessageA' D$TemplateList3  &WM_SETTEXT 0 D$TempoClipmemoryPtr
L8:
ret


Clip_Disable_Customization_Controls:
   call 'USER32.EnableWindow' D$ControlID108 &FALSE
   call 'USER32.EnableWindow' D$ControlID104 &FALSE
   call 'USER32.EnableWindow' D$ControlID105 &FALSE
   call 'USER32.EnableWindow' D$ControlID106 &FALSE
   call 'USER32.EnableWindow' D$ControlID107 &FALSE
ret

Clip_Enable_Customization_Controls:
   call 'USER32.EnableWindow' D$ControlID108 &TRUE
   call 'USER32.EnableWindow' D$ControlID104 &TRUE
   call 'USER32.EnableWindow' D$ControlID105 &TRUE
   call 'USER32.EnableWindow' D$ControlID106 &TRUE
   call 'USER32.EnableWindow' D$ControlID107 &TRUE
ret

____________________________________________________________________________________________


[TemplateList1: ?    TemplateList2: ?    TemplateList3: ?]

[TPointer: ?    RadioButtonID: ?    ClipperHandle: ?]

[DEL_TEMPLATE 5    AD_TEMPLATE 6    DEL_GROUP 7   AD_GROUP 8   DEL_GROUP_TEMPLATES 4
 CLIP_MANAGER 25]

[ClipDialogIsExtended: ?]

ExtendClipDialog:
    call 'USER32.GetWindowPlacement' D$ClipperHandle Control

    If B$ClipDialogIsExtended = &FALSE
        add D$Control.rcNormalPosition.bottom 66
    Else
        sub D$Control.rcNormalPosition.bottom 66
    End_If

    call 'USER32.SetWindowPlacement' D$ClipperHandle Control

    xor B$ClipDialogIsExtended &TRUE
ret


Proc TemplateChoice:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND
         ..If D@wParam = &IDCANCEL
            mov D$ClipperHandle 0
            call 'User32.EndDialog' D@Adressee 0

         ..Else_If D@wParam = &IDOK
             call RetrieveGenericName
             call SearchTheClip
             call TemplateToClipBoard
             mov D$ClipperHandle 0
             call 'User32.EndDialog' D@Adressee 0

         ..Else_If D@wParam = &IDHELP
             call Help, B_U_AsmName TempateHelp, ContextHlpMessage

         ..Else_If D@wParam = CLIP_MANAGER
            call ExtendClipDialog

         ..Else_If D@wParam = AD_GROUP
            call AddGroup

         ..Else_If D@wParam = DEL_GROUP
            call DeleteGroup

         ..Else_If D@wParam = DEL_GROUP_TEMPLATES
            call DeleteGroupAndTemplates

         ..Else_If D@wParam = AD_TEMPLATE
            call AddTemplate

         ..Else_If D@wParam = DEL_TEMPLATE
            call DeleteTemplate

         ..Else_If W@wParam = 101                     ; 101 > First ListBox
             shr D@wParam 16
             .If D@wParam = &LBN_SELCHANGE
                call ViewTemplatesItems
             .End_If

         ..Else_If W@wParam = 102                     ; 102 > Second ListBox
             shr D@wParam 16
             .If D@wParam = &LBN_SELCHANGE
                 call ShowClip
             .End_If

         ..Else_If W@wParam = 108                   ; Generic Name Edit Control
            call ShowClip
         ..Else_If W@wParam >= 104                   ; 104/105/106/107 > Radio Buttons
             move D$RadioButtonID D@wParam
             and D$RadioButtonID 0FFFF
             .If W@wParam <= 107
                 shr D@wParam 16
                 If D@wParam = &BN_CLICKED
                     call CheckTemplateRadioButtons
                     call ShowClip
                 End_If
             .End_If
         ..End_If

    ...Else_If D@Message = &WM_INITDIALOG
        move D$ClipperHandle D@Adressee
        mov B$ClipDialogIsExtended &FALSE
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        call 'USER32.GetDlgItem' D@Adressee 101 | mov D$TemplateList1 eax
        call 'USER32.GetDlgItem' D@Adressee 102 | mov D$TemplateList2 eax
        call 'USER32.GetDlgItem' D@Adressee 110 | mov D$TemplateList3 eax
        call 'USER32.GetDlgItem' D@Adressee 108 | mov D$ControlID108 eax
        call 'USER32.GetDlgItem' D@Adressee 104 | mov D$ControlID104 eax
        call 'USER32.GetDlgItem' D@Adressee 105 | mov D$ControlID105 eax
        call 'USER32.GetDlgItem' D@Adressee 106 | mov D$ControlID106 eax
        call 'USER32.GetDlgItem' D@Adressee 107 | mov D$ControlID107 eax
        call ReadClipsections
        call InitTemplateRadioButtons D@Adressee
        call 'USER32.SendMessageA' D$TemplateList1  &LB_SETCURSEL 0 0
        call ViewTemplatesItems
       ; call 'USER32.SendDlgItemMessageA' D@Adressee, 110, &WM_SETFONT, D$Font1Handle, &FALSE

    ...Else_If D@Message = &WM_CTLCOLOREDIT
        jmp L1>

   ; ...Else_If D@Message = &WM_CTLCOLORBTN ; Never received for Radio/Check Buttons !!!???
   ;     jmp L1>

    ...Else_If D@Message = &WM_CTLCOLORLISTBOX
L1:     call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>>

    ...Else
       ; mov eax D$BlockEndTextPtr | sub eax D$BlockStartTextPtr
       ; mov ebx D$ClipMemoryEnd | sub ebx D$ClipFileMemoryPointer
       ; mov ecx D$BlockInside | On eax >= ebx, mov ecx &FALSE
       ; EnableControl D@Adressee, AD_TEMPLATE, ecx

        popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: Endp


ViewTemplatesItems:
    call 'USER32.SendMessageA' D$TemplateList2, &LB_RESETCONTENT, 0, 0
    call 'USER32.SendMessageA' D$TemplateList3, &WM_SETTEXT, 0, 0

    call 'USER32.SendMessageA' D$TemplateList1  &LB_GETCURSEL 0 0
    call SearchSection | On D$SectionPointer <> 0, call ReadClipTitles
ret

____________________________________________________________________________________________

[GetNewGroupNameHandle: ?]

AddGroup: ; 'LoadClipFile'
    call SaveClipSelections

    On D$GetNewGroupNameHandle <> 0,
        call 'User32.EndDialog' D$GetNewGroupNameHandle, 0
    call 'USER32.DialogBoxParamA' D$hInstance 20001, &NULL, GetNewGroupName, &NULL
    On D$NewGroupName = 0, ret

    ...If B$GroupInsert = &TRUE
      ; Go to the selected Group:
        mov esi D$ClipFileMemoryPointer, edx D$ClipGroupIndex | inc edx

        While esi < D$ClipMemoryEnd
            lodsb
            ..If al = '/'
                .If B$esi = '/'
                    If B$esi-2 < ' '
                        dec edx | jz L1>
                    End_If
                .End_If
            ..End_If
        End_While

L1:     dec esi

        push esi
          ; Make room: ('D$NewGroupNameLen'+6) Bytes:
            mov ecx D$ClipFileMemoryPointer | add ecx D$ClipFileSize
            mov edi ecx     ; edi > End.
            sub ecx esi     ; ecx = How many Bytes to be moved downward.
            mov esi edi | add edi D$NewGroupNameLen | add edi 8 ; 6 = 3 CRLF + '//'
          ; esi > End // edi > (End+room). Copy BackWard:
            inc ecx | std | rep movsb | cld
        pop edi

        add edi 2 ; (old '//' yet there).
        mov esi NewGroupName, ecx D$NewGroupNameLen | rep movsb
        mov D$edi CRLF2, W$edi+4 CRLF

        mov eax D$NewGroupNameLen | add eax 8 | add D$ClipFileSize eax

    ...Else ; B$GroupInsert = &FALSE >>> Append:
        mov edi D$ClipFileMemoryPointer | add edi D$ClipFileSize
        While B$edi < ' ' | dec edi | dec D$ClipFileSize | End_While
        inc edi | inc D$ClipFileSize
        mov D$edi CRLF2, W$edi+4 CRLF, W$edi+6 '//' | add edi 8
        mov esi NewGroupName
        While B$esi <> 0 | movsb | inc D$ClipFileSize | End_While
        mov D$edi CRLF2 | add edi 4
        add D$ClipFileSize 12 ; (5 CRLF + '//')

    ...End_If

    call ClipUpdate
ret


[GroupInsert: ?]

Proc GetNewGroupName:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

        .If D@Message = &WM_COMMAND
            If D@wParam = &IDOK         ; [Append]
                mov D$GroupInsert &FALSE
L1:             call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &WM_GETTEXTLENGTH, 0, 0
                mov D$NewGroupNameLen eax
                call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &WM_GETTEXT, 38,
                                                  NewGroupName
                call 'USER32.EndDialog' D@Adressee, 0 | popad | mov eax &TRUE | ExitP

            Else_If D@wParam = 20       ; [Insert]
                mov D$GroupInsert &TRUE | jmp L1<

            Else_If D@wParam = &IDCANCEL
                mov D$GetNewGroupNameHandle 0
                call 'USER32.EndDialog' D@Adressee, 0 | popad | mov eax &TRUE | ExitP

            End_If

        .Else_If D@Message = &WM_INITDIALOG
            mov B$WithCustomisation &FALSE
            move D$GetNewGroupNameHandle D@Adressee
            mov edi NewGroupName, eax 0, ecx 10 | rep stosd

            call 'USER32.SendDlgItemMessageA' D@Adressee, 21,  &BM_SETCHECK, &TRUE, 0
            call 'USER32.GetDlgItem', D@Adressee, 10
            call 'USER32.SetFocus' eax

        .End_If

    popad | mov eax &FALSE
EndP


; Deleting a Group name only.

[SureDelGroupName: 'Delete "                                ', 0]

DeleteGroup:
    call SaveClipSelections

    mov esi D$ClipFileMemoryPointer, ecx D$ClipGroupIndex | inc ecx

L0: inc esi | cmp D$esi 02F2F0A0D | jne L0<     ; "CR LF //" = 02F2F0A0D
    dec ecx | jnz L0<

    push esi
        add esi 4 | lea edi D$SureDelGroupName+8
        While B$esi > CR | movsb | End_While
        mov D$edi '" ? ', B$edi+3 0
        call 'USER32.MessageBoxA' D$hwnd, SureDelGroupName, SureDelTemplateTitle,
                                  &MB_SYSTEMMODAL__&MB_YESNO__&MB_ICONEXCLAMATION
    pop esi

    .If eax = &IDYES
        mov edx D$ClipFileMemoryPointer | add edx D$ClipFileSize
        add esi 2 | mov edi esi | add esi 2 | sub D$ClipFileSize 2
      ; edi > '//'. esi > Name. Skip over Line:
        While B$esi > CR | inc esi | dec D$ClipFileSize | End_While
      ; Skip over coming CRLF:
        While W$esi = CRLF | add esi 2 | sub D$ClipFileSize 2 | End_While
        While esi < edx | movsb | End_While

        call ClipUpdate
    .End_If
ret


DeleteGroupAndTemplates:
    call SaveClipSelections

    mov esi D$ClipFileMemoryPointer, ecx D$ClipGroupIndex | inc ecx

L0: inc esi | cmp D$esi 02F2F0A0D | jne L0<     ; "CR LF //" = 02F2F0A0D
    dec ecx | jnz L0<

    push esi
        add esi 4 | lea edi D$SureDelGroupName+8
        While B$esi > CR | movsb | End_While
        mov D$edi '" ? ', B$edi+3 0
        call 'USER32.MessageBoxA' D$hwnd, SureDelGroupName, SureDelTemplateTitle,
                                  &MB_SYSTEMMODAL__&MB_YESNO__&MB_ICONHAND
    pop esi

    .If eax = &IDYES
        mov edx D$ClipFileMemoryPointer | add edx D$ClipFileSize
        mov edi esi | add esi 4 | sub D$ClipFileSize 4
        While D$esi <> 02F2F0A0D
            inc esi | dec D$ClipFileSize
            On esi >= edx, jmp L2>
        End_While

        While esi < edx | movsb | End_While

L2:     call ClipUpdate
    .End_If
ret


[GetNewTemplateNameHandle: ?]

[NoClipSelection: B$ 'No selection found in the Source Editor  ', 0
 SelectionTooBig: B$ 'The Selection is too big  ', 0]

AddTemplate: ; 'LoadClipFile'
    mov eax D$BlockEndTextPtr | sub eax D$BlockStartTextPtr
    mov ebx D$ClipMemoryEnd | sub ebx D$ClipFileMemoryPointer

    If D$BlockInside = &FALSE
        call 'USER32.MessageBoxA' D$hwnd, NoClipSelection, Argh, &MB_SYSTEMMODAL | ret
    Else_If eax >= ebx
        call 'USER32.MessageBoxA' D$hwnd, SelectionTooBig, Argh, &MB_SYSTEMMODAL | ret
    End_If

    call SaveClipSelections

    On D$GetNewTemplateNameHandle <> 0,
        call 'User32.EndDialog' D$GetNewTemplateNameHandle, 0
    call 'USER32.DialogBoxParamA' D$hInstance 20000, &NULL, GetNewTemplateName, &NULL

    On D$NewTemplateName = 0, ret

    call SearchTheClip

    mov eax D$ClipFileSize | add eax CLIPRESERVATION
    VirtualAlloc TempoClipFileMemoryPointer, eax

    If D$TheClipLenght = 0
      ; No Item yet, or no Item selected >>> paste at end:
        mov ebx D$SectionPointer, edx D$ClipFileMemoryPointer | add edx D$ClipFileSize
L0:     inc ebx | cmp ebx edx | jae L1>
        cmp W$ebx '//' | jne L0<
L1:         mov D$ClipPointer ebx

        mov esi D$ClipFileMemoryPointer, edi D$TempoClipFileMemoryPointer
        While esi < D$ClipPointer | movsb | End_While

    Else
      ; Item selected >>> Insert:
        mov esi D$ClipFileMemoryPointer, edi D$TempoClipFileMemoryPointer
        While esi < D$ClipPointer | movsb | End_While

L0:     dec esi | dec edi | cmp B$esi '/' | jne L0<
        If B$esi-1 = '/'
            dec esi | dec edi
        End_If
        cmp W$esi-2 CRLF | jne L0<

    End_If

    mov B$edi '/' | inc edi | inc D$ClipFileSize
    push esi
        mov esi NewTemplateName
        While B$esi <> 0 | movsb | inc D$ClipFileSize | End_While
    pop esi
    mov D$edi CRLF2 | add edi 4 | add D$ClipFileSize 4

    If B$WithCustomisation = &FALSE
        mov B$edi '@', W$edi+1 CRLF | add edi 3 | add D$ClipFileSize 3
    End_If

    mov W$edi CRLF | add edi 2 | add D$ClipFileSize 2

    push esi
        mov esi D$BlockStartTextPtr
        While esi < D$BlockEndTextPtr
            movsb | inc D$ClipFileSize
        End_While | movsb | inc D$ClipFileSize
        mov D$edi CRLF2, W$edi+4 CRLF | add edi 6 | add D$ClipFileSize 6
    pop esi

    mov edx D$ClipFileMemoryPointer | add edx D$ClipFileSize
    While esi < edx | movsb | End_While
    Exchange D$ClipFileMemoryPointer D$TempoClipFileMemoryPointer
    VirtualFree D$TempoClipFileMemoryPointer
    call ClipUpdate
ret


SaveClipSelections:
    call 'USER32.SendMessageA' D$TemplateList1  &LB_GETCURSEL 0 0 | mov D$ClipGroupIndex eax
    call 'USER32.SendMessageA' D$TemplateList2  &LB_GETCURSEL 0 0 | mov D$ClipIndex eax
ret

ClipUpdate:
    call ClipCRLFs | call WriteClipFile | call ReleaseClipFile
    call LoadClipFile | call ReadClipsections



    call 'USER32.SendMessageA' D$TemplateList2, &LB_SETCURSEL, D$ClipIndex, 0
    If eax = &LB_ERR
        call 'USER32.SendMessageA' D$TemplateList2, &LB_SETCURSEL, 0-1, 0
    End_If

    call 'USER32.SendMessageA' D$TemplateList1, &LB_SETCURSEL, D$ClipGroupIndex, 0
    If eax = &LB_ERR
        call 'USER32.SendMessageA' D$TemplateList1, &LB_SETCURSEL, 0, 0
    End_If

    call ViewTemplatesItems
ret
____________________________________________________________________________________________

[UnvalidClipTitle: 'Unvalid Clip File', 0
 ClipTitleWanted: "A Clip File must contain some text before the first //Group", 0]

;;
  Ensure that all '/Name', '//Name' are preceeded and ended by 3 CRLF and than the
  whole thing is ended by 2 CRLF.
;;

ClipCRLFs:
    mov esi D$ClipFileMemoryPointer
    While W$esi = CRLF | add esi 2 | End_While
    If B$esi = '/'
        mov B$ClipFileReady 0-1 | ret
    End_If

    mov eax D$ClipFileSize | add eax CLIPRESERVATION
    VirtualAlloc TempoClipFileMemoryPointer, eax

    mov eax D$TempoClipFileMemoryPointer
    add eax D$ClipFileSize | add eax CLIPRESERVATION | mov D$ClipMemoryEnd eax

    mov esi D$ClipFileMemoryPointer, edi D$TempoClipFileMemoryPointer
    mov edx esi | add edx D$ClipFileSize

L0: .While esi < edx
        lodsb

        .If al = '/'
            If W$esi-3 = CRLF
              ; Skip the CRLF Back:
                While W$edi-2 = CRLF | sub edi 2 | End_While
              ; Re-Write the wanted 3 CRLFs:
                mov D$edi CRLF2, W$edi+4 CRLF | add edi 6
              ; Write the '/Name', '//Name':
                dec esi | While B$esi <> CR | movsb | End_While
              ; Write the wanted 3 CRLFs:
                mov D$edi CRLF2, W$edi+4 CRLF | add edi 6
              ; Arase the existing source CRLF:
                While W$esi = CRLF | add esi 2 | End_While | jmp L0<
            End_If
        .End_If

        stosb
    .End_While

  ; Arase existing CRLF at End:
    While W$edi-2 = CRLF | sub edi 2 | End_While
  ; And rewrite the 2 wanted ones:
    mov D$edi CRLF2 | add edi 4

    sub edi D$TempoClipFileMemoryPointer | mov D$ClipFileSize edi
    Exchange D$ClipFileMemoryPointer D$TempoClipFileMemoryPointer

    mov eax D$ClipMemoryEnd | sub eax D$ClipFileMemoryPointer

    VirtualFree D$TempoClipFileMemoryPointer
ret


[NewTemplateName: NewGroupName: ? #10] [WithCustomisation: ?    NewGroupNameLen: ?]

Proc GetNewTemplateName:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

        .If D@Message = &WM_COMMAND
            If D@wParam = &IDOK
                call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &WM_GETTEXTLENGTH, 0, 0
                inc eax | On eax > 38, mov eax 38
                call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &WM_GETTEXT, eax,
                                                   NewTemplateName

                call 'User32.EndDialog' D@Adressee 0 | popad | mov eax &TRUE | ExitP

            Else_If D@wParam = &IDCANCEL
                mov D$GetNewTemplateNameHandle 0
                call 'User32.EndDialog' D@Adressee 0 | popad | mov eax &TRUE | ExitP

            Else_If D@wParam = 20
                xor B$WithCustomisation &TRUE

            End_If

        .Else_If D@Message = &WM_INITDIALOG
            mov B$WithCustomisation &FALSE
            move D$GetNewTemplateNameHandle D@Adressee
            mov edi NewTemplateName, eax 0, ecx 10 | rep stosd

        .End_If

    popad | mov eax &FALSE
EndP


[NoClipSelected: 'Select a Template in the second List Box, if you want to delete it', 0
 SureDelTemplateTitle: 'Sure?', 0
 SureDelTemplate: 'Delete "                                ']

DeleteTemplate:
    call SaveClipSelections

    call SearchTheClip

    .If D$TheClipLenght = 0
      ; No Item yet, or no Item selected:
        call 'USER32.MessageBoxA' D$hwnd, NoClipSelected, Argh, &MB_SYSTEMMODAL

    .Else
      ; Item selected >>> Delete:
        mov esi D$ClipPointer, edi esi

      ; Go to start of Template to be deleted:
        While B$edi <> '/' | dec edi | End_While | mov D$ClipPointer edi

        push esi, edi
            lea edi D$SureDelTemplate+8 | mov esi D$ClipPointer | inc esi
            While B$esi <> CR | movsb | End_While | mov D$edi '"  ?', B$edi+4 0

            call 'USER32.MessageBoxA' D$hwnd, SureDelTemplate, SureDelTemplateTitle,
                                      &MB_SYSTEMMODAL__&MB_YESNO__&MB_ICONEXCLAMATION
        pop edi, esi

        .If eax = &IDYES
            mov edx D$ClipFileMemoryPointer | add edx D$ClipFileSize
            mov esi D$ClipPointer | inc esi | dec D$ClipFileSize
            While B$esi <> '/'
L0:             inc esi | dec D$ClipFileSize | On esi >= edx, jmp L1>
            End_While
            cmp B$esi-1 LF | jne L0<
            mov ecx D$ClipMemoryEnd | sub ecx esi | rep movsb

L1:         call ClipUpdate
        .End_If

    .End_If
ret

[TempoClipFileMemoryPointer: ?]

____________________________________________________________________________________________

Proc InitTemplateRadioButtons:
    Argument @Adressee

    mov eax 105 | xor al B$WithData
    call 'USER32.GetDlgItem' D@Adressee eax
    call 'USER32.SendMessageA' eax &BM_SETCHECK eax &TRUE
    mov eax 107 | xor al B$GlobalScope
    call 'USER32.GetDlgItem' D@Adressee eax
    call 'USER32.SendMessageA' eax &BM_SETCHECK eax &TRUE
EndP


[WithData: B$ &TRUE    GlobalScope: &TRUE]

CheckTemplateRadioButtons:
    call 'USER32.GetDlgItem' D$ClipperHandle D$RadioButtonID
    push eax
        call 'USER32.SendMessageA' eax &BM_GETCHECK 0 0 | xor eax &TRUE
    pop ebx
    call 'USER32.SendMessageA' ebx &BM_SETCHECK eax 0
    xor D$RadioButtonID 1                                    ; 104 <> 105 // 106 <> 107
    call 'USER32.GetDlgItem' D$ClipperHandle D$RadioButtonID
    push eax
        call 'USER32.SendMessageA' eax &BM_GETCHECK 0 0 | xor eax &TRUE
    pop ebx
    call 'USER32.SendMessageA' ebx &BM_SETCHECK eax 0
    If D$RadioButtonID < 106
        xor B$WithData &TRUE
    Else
        xor B$GlobalScope &TRUE
    End_If
ret


TemplateToClipBoard:
    On D$TheClipLenght = 0, ret
    call 'USER32.OpenClipboard' D$hwnd | cmp eax 0 | je L9>>
    call 'USER32.EmptyClipboard' | cmp eax 0 | je L8>>

    mov ecx D$TheClipLenght | shl ecx 2               ; *4 > room for Generic Names
    push ecx
        call 'KERNEL32.GlobalAlloc' &GMEM_DDESHARE ecx | cmp eax 0 | jne L1>  ; > eax = handle
        pop eax | jmp L8>>
L1:     mov D$hBlock eax
        call 'KERNEL32.GlobalLock' eax                                       ; > eax = adress
    pop ecx
    shr ecx 2                                                   ; restore true data size
    mov edi eax, esi D$ClipPointer

  ; If the very first Char after the first CR/LF is '@', we load the Clip 'As is':
    mov ebx esi | add ebx 2
    While B$ebx <= ' ' | inc ebx | End_While

    .If B$ebx = '@'
        call SearchTheClip | On D$TheClipLenght = 0, ret
        mov esi D$ClipPointer, ecx D$TheClipLenght
        While B$esi <> '@'
            inc esi | dec ecx | jz L8>
        End_While | inc esi | dec ecx | jz L8>
        rep movsb

    .Else_If B$WithData = &TRUE
        If B$GlobalScope = &TRUE
            call WithDataGlobalScope
        Else
            call WithDataLocalScope
        End_If
    .Else
        If B$GlobalScope = &TRUE
            call WithoutDataGlobalScope
        Else
            call WithoutDataLocalScope
        End_If
    .End_If

    mov eax 0 | stosd

    call 'KERNEL32.GlobalUnlock' D$hBlock
    call 'USER32.SetClipboardData' &CF_TEXT  D$hBlock
    call 'USER32.SendMessageA' D$TemplateList3  &WM_SETTEXT 0 D$hBlock
L8: call 'USER32.CloseClipboard'
L9: ret


[GenericNameHandle: ?]

RetrieveGenericName:
    mov edi GenericName, ecx 10, eax 0 | rep stosd
    call 'USER32.GetDlgItem' D$ClipperHandle 108  ; 108 = ID of Generic Name Edit Control.
    mov D$GenericNameHandle eax
    call 'USER32.SendMessageA' D$GenericNameHandle &EM_LINELENGTH 0 0
    If eax > 0
        mov W$GenericName ax
        call 'USER32.SendMessageA' D$GenericNameHandle, &EM_GETLINE, 0, GenericName
        mov B$GenericName+eax 0  ; >>> 'EM_GETLINE_Comment'
    End_If
ret


WithDataGlobalScope:
L0: lodsb
    .If al = '@'
        If B$GenericName > 0
            push esi
                mov esi GenericName | lodsb
L1:             stosb | lodsb | cmp al 0 | ja L1<
            pop esi
        End_If
    .Else
        stosb
    .End_If
    loop L0<
ret


WithDataLocalScope:
L0: lodsb
    .If al = '@'
        stosb
        If B$GenericName > 0
            push esi
                mov esi GenericName | lodsb
L1:             stosb | lodsb | cmp al 0 | ja L1<
            pop esi
        End_If
    .Else_If al = '['
        If B$esi = '@'
            mov eax 'Loca' | stosd | mov ax 'l ' | stosw
            call CopyTemplateLabelsOnly
        Else
            stosb
        End_If
    .Else_If al = '$'
      ; Strip '$' in 'D$@Value', but not in D$Value.
        On B$esi <> '@', stosb
    .Else_If al = '$'
      ; Strip '$' in 'D$@'Value', but not in D$Value.
        On B$esi <> '@', stosb
    .Else
        stosb
    .End_If
    loop L0<
ret


CopyTemplateLabelsOnly:
L0:
    lodsb
        .If al = '@'
            stosb
            If B$GenericName > 0
                push esi
                    mov esi GenericName | lodsb
L1:                 stosb | lodsb | cmp al 0 | ja L1<
                pop esi
            End_If
L1:         lodsb | dec ecx | stosb
            If B$esi = ' '
                dec ecx | jmp L2>
            Else_If B$esi <> ':'
                jmp L1<
            End_If

L2:         mov ax ', ' | stosw
        .Else_If al = ']'
            sub edi 2 | mov D$edi 0 | ret       ; strip ending ' ,'
        .End_If
    Loop L0<


WithoutDataGlobalScope:
L0: lodsb
    .If al = '['
        On B$esi <> '@', jmp L2>
        While al <> ']'
            lodsb | dec ecx         ; Strip Data if unwished
        End_While
    .Else_If al = '@'
        If B$GenericName > 0
            push esi
                mov esi GenericName | lodsb
L1:             stosb | lodsb | cmp al 0 | ja L1<
            pop esi
        End_If
    .Else
L2:     stosb
    .End_If
    loop L0<
ret


WithoutDataLocalScope:
L0: lodsb
    .If al = '['
        On B$esi <> '@', jmp L2>
        While al <> ']'
            lodsb | dec ecx         ; Strip Data if unwished
        End_While
    .Else_If al = '@'
        stosb
        If B$GenericName > 0
            push esi
                mov esi GenericName | lodsb
L1:             stosb | lodsb | cmp al 0 | ja L1<
            pop esi
        End_If
    .Else_If al = '$'
      ; Strip '$' in 'D$@'
        On B$esi <> '@', stosb
    .Else_If al = '$'
      ; Strip '$' in 'D$@'
        On B$esi <> '@', stosb
    .Else
L2:     stosb
    .End_If
    loop L0<
ret







TITLE Struct
____________________________________________________________________________________________
____________________________________________________________________________________________

; The Structures DialogBox ([Struct] Menu option):

[WinStructures: ?]
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
 Data in the .str Files are like this:

     [POINT:|x D|y D
     [POINTS:|x W|y W
     [RECT:|left D|top D|right D|bottom D

 For multi-units records:

     [FONTSIGNATURE:|fsUsb4 D 4|fsCsb2 D 2
                              ^          ^
 Nested Structures are expanded:

     [RBHITTESTINFO:|pt.x D|pt.y D|flags D|iBand D
                     ^^^^^^^^^^^^^
 Equates Values are given as this:

     [MIXERCONTROLDETAILS_LISTTEXTA:|dwParam1 D|dwParam2 D|szName < MIXER_LONG_NAME_CHARS
                                                                    ^^^^^^^^^^^^^^^^^^^^^
 (Without the '&').
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[StructHelp: 'Structures', 0]

StructDialog:
    .If B$StructuresFileOK = &TRUE
        If D$StructHandle = 0
            call 'USER32.DialogBoxParamA' D$hinstance, 18000, &NULL, StrucProc, &NULL
        Else
            Beep
        End_If

    .Else
        call Help B_U_AsmName, IncludeFilesHelp, RosAsmHlpMessage

    .End_If
ret


[StructHandle: ?   StructComboHandle: ?    StructEditHandle: ?    StructTitleEditHandle: ?]

; Tag Dialog 18000

Proc StrucProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_INITDIALOG
        move D$StructHandle D@Adressee

        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon

       ; call 'USER32.SetWindowLongA' D@Adressee &GWL_EXSTYLE &WS_EX_TOOLWINDOW

        call 'USER32.GetDlgItem' D@Adressee 10 | mov D$StructComboHandle eax
        call 'USER32.GetDlgItem' D@Adressee 11 | mov D$StructEditHandle eax
        call 'USER32.GetDlgItem' D@Adressee 30 | mov D$StructTitleEditHandle eax
        call InitStructListBox
        call InitSerFormFlag
        call 'USER32.GetDlgItem' D@Adressee 10
        call 'USER32.SetFocus' eax
        jmp L8>>

    ...Else_If D@Message = &WM_COMMAND
        .If W@wParam = 21
            mov D$StructHeadFlag NACKEDSTRUCT | call ReBuildStructForm
        .Else_If W@wParam = 22
            mov D$StructHeadFlag LOCALSTRUCT | call ReBuildStructForm
        .Else_If W@wParam = 23
            mov D$StructHeadFlag SEMISTRUCT | call ReBuildStructForm
        .Else_If W@wParam = 24
            mov D$StructHeadFlag DASHSTRUCT | call ReBuildStructForm
        .Else_If W@wParam = 40
            movzx eax W@wParam | call SetFormFlags | call ReBuildStructForm
        .Else_If W@wParam = 41
            movzx eax W@wParam | call SetFormFlags | call ReBuildStructForm
        .Else_If W@wParam = 42
            movzx eax W@wParam | call SetFormFlags | call ReBuildStructForm
        .Else_If W@wParam = 50
            If B$ZeroOrQuestionMark = '?'
                mov B$ZeroOrQuestionMark '0'
            Else
                mov B$ZeroOrQuestionMark '?'
            End_If
           call ReBuildStructForm
        .End_If

        mov eax D@wParam | and D@wParam 0FFFF | shr eax 16
        .If eax = &CBN_SELCHANGE
            call InitStructureName | call BuildStructForm

        .Else_If eax = &EN_CHANGE
            If W@wParam = 30
                call GetStructureUserName | call ReBuildStructForm
            End_If

        .Else_If D@wParam = &IDCANCEL
            jmp L1>

        .Else_If D@wParam = &IDOK
            call ClipStructure
L1:         mov D$StructHandle 0
            VirtualFree D$WinStructures
            call 'USER32.EndDialog' D@Adressee 0

        .Else_If D@wParam = &IDHELP
            call Help, B_U_AsmName, StructHelp, ContextHlpMessage

        .Else_If eax = &BN_CLICKED
            mov eax D@wParam

       .End_If

    ...Else_If D@Message = &WM_CTLCOLOREDIT
        jmp L1>

    ...Else_If D@Message = &WM_CTLCOLORLISTBOX
L1:     call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP

____________________________________________________________________________________________

[StructTitle: ? # 50] [StructTitleLen: ?]
[UserStructTitle: ? #50]
[StructEditText: ? #1000]

; Fill the ComboBox with all 'WinStructures' Data:

InitStructListBox:
    call OpenStructureFile

    mov esi D$WinStructures
    While B$esi <> 0
        lodsb
        If al = '['
            mov edi StructTitle
L1:             lodsb | cmp al ':' | je L2>
                stosb | jmp L1<
L2:         mov B$edi 0
            call 'USER32.SendMessageA' D$StructComboHandle &CB_ADDSTRING 0 StructTitle
        End_If
    End_While
    mov D$StructTitle 0
ret


[MenuID: ?    SeveralStructuresFiles: ?    StructuresFileHandle: ?    StructuresFileSize: ?]
[ApiFileString: MenuItemString: B$ ? #&MAX_PATH]

OpenStructureFile:
    .If B$StructuresFileOK = &FALSE
        call Help, B_U_AsmName, IncludeFilesHelp, ContextHlpMessage | ret

    .Else_If B$SeveralStructuresFiles = &TRUE
        mov esi EquatesName, edi MenuItemString
        While B$esi <> 0 | movsb | End_While
        dec edi
        While B$edi <> '.' | dec edi | End_While

L0:     dec edi | cmp B$edi '\' | je L1>
                  cmp B$edi ':' | je L1>
                  cmp edi MenuItemString | ja L0<
                    jmp L2>
L1:     inc edi
L2:     mov ecx &MAX_PATH | add ecx MenuItemString | sub ecx edi
      ; Case when call from the ToolBar
        On D$MenuID = 0, mov D$MenuID 4001
        call 'USER32.GetMenuStringA' D$MenuHandle, D$MenuID, edi, ecx, &MF_BYCOMMAND

        mov esi MenuItemString
        While B$esi <> 0 | inc esi | End_While | mov D$esi '.str', B$esi+4 0

    .End_If

    call 'KERNEL32.CreateFileA' MenuItemString &GENERIC_READ,
                                &FILE_SHARE_READ, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, 0
    mov D$StructuresFileHandle eax

    call 'KERNEL32.GetFileSize' eax 0 | mov D$StructuresFileSize eax

    VirtualAlloc WinStructures eax

    mov D$NumberOfReadBytes 0
    call 'KERNEL32.ReadFile' D$StructuresFileHandle, D$WinStructures,
                             D$StructuresFileSize, NumberOfReadBytes, 0

    call 'KERNEL32.CloseHandle' D$StructuresFileHandle
ret

____________________________________________________________________________________________

InitStructureName:
    call 'User32.SendMessageA' D$StructComboHandle &CB_GETCURSEL 0 0
    push eax
        call 'User32.SendMessageA' D$StructComboHandle &CB_GETLBTEXT eax StructTitle
        mov D$StructTitleLen eax
    pop eax
    call 'User32.SendMessageA' D$StructComboHandle &CB_GETLBTEXT eax UserStructTitle
    call 'User32.SendMessageA' D$StructTitleEditHandle &WM_SETTEXT 0 UserStructTitle
ret

____________________________________________________________________________________________

[OnModeHandle: ?   StructMode: ?] ; strucMode: 0 > Data    1 > Equates    2 > Stack Macro


InitSerFormFlag:
    mov eax D$StructHeadFlag | add eax 21
    call 'User32.SendDlgItemMessageA' D$StructHandle eax &BM_SETCHECK 1 0

    mov eax D$StructMode | add eax 40
    call 'User32.SendDlgItemMessageA' D$StructHandle eax &BM_SETCHECK 1 0
ret



SetFormFlags:
    mov D$StructMode eax | sub D$StructMode 40

    call 'User32.GetDlgItem' D$StructHandle eax | mov D$OnModeHandle eax

    call 'User32.GetDlgItem' D$StructHandle 40
    call 'User32.SendMessageA' eax &BM_SETCHECK 0 0
    call 'User32.GetDlgItem' D$StructHandle 41
    call 'User32.SendMessageA' eax &BM_SETCHECK 0 0
    call 'User32.GetDlgItem' D$StructHandle 42
    call 'User32.SendMessageA' eax &BM_SETCHECK 0 0

    call 'User32.SendMessageA' D$OnModeHandle &BM_SETCHECK 1 0
ret

____________________________________________________________________________________________


ReBuildStructForm:
    cmp B$StructTitle 0 | je L9>
        call SetStructHeadText | call BuildStructForm
L9: ret


BuildStructForm:
    mov edi StructEditText, eax 0, ecx 1000 | rep stosd

  ; First, search the structure inside 'WinStructures' list same for all forms):
    mov esi D$WinStructures, bl B$StructTitle, eax D$StructTitleLen

L1: inc esi
    While B$esi <> bl
        inc esi
    End_While
    cmp B$esi-1 '[' | jne L1<
    push esi
        mov ecx eax
        mov edi StructTitle | repe cmpsb
        mov dl B$esi
    pop esi | jne L1<
    cmp dl ':' | jne L1<
    add esi eax | inc esi

    If D$StructMode = 0
        call BuildStructDataForm
        sub edi 3 | mov al ']' | stosb |  mov B$edi 0
    Else_If D$StructMode = 1
       call BuildStructEquForm
       sub edi 3 | mov al ']' | stosb |  mov B$edi 0
    Else_If D$StructMode = 2
       call BuildStructStackForm
       sub edi 3 |  mov B$edi 0
    End_If

    call StripDoubleColon

    call 'User32.SendMessageA' D$StructEditHandle &WM_SETTEXT 0 StructEditText
ret


StripDoubleColon:
    mov esi StructEditText
    While B$esi > 0
        lodsb
        If al = ':'
            On B$esi = ':', mov B$esi ' '
        End_If
    End_While
ret

[ZeroOrQuestionMark: '?']

BuildStructDataForm:
  ; Write the Structure main name in the EditBox:
    mov edi StructEditText

    push esi
        mov esi UserStructTitle
        mov al '[' | stosb
        While B$esi <> 0
            movsb
        End_While
        mov al ':' | stosb
    pop esi
    mov al 13 | stosb | mov al 10 | stosb | mov al ' ' | stosb

; Write the items:
;
; [REBARBANDINFO:|cbSize D|fMask D|fStyle D|clrFore D|cl...
;                ^
    call SetStructHeadText

L0: call WriteStructHead
    inc esi                                           ; jmp over first '|'
    If B$esi+1 = '|'
        ; case of missing names: "[DDEUP:|D|D'
    Else_If B$esi+1 < ' '
        ; ... Same for: "[DDELN:|D"
    Else
        While B$esi <> ' '
        movsb
        End_While
        mov al ':' | stosb
        inc esi
    End_If

; [REBARBANDINFO:|cbSize D|fMa...
;                        ^
    ..If B$esi+1 = '|'
L3:     If B$esi = 'B'
            mov eax ' B$ '
        Else_If B$esi = 'W'
            mov eax ' W$ '
        Else_If B$esi = 'D'
            mov eax ' D$ '
        Else_If B$esi = 'Q'
            mov eax ' Q$ '
        Else_If B$esi = 'F'
            mov eax ' F$ '
        Else_If B$esi = 'U'
            mov eax ' U$ '
        Else_If B$esi = 'T'
            mov eax ' T$ '
        End_If
        stosd | mov eax 0200A0D30 | mov al B$ZeroOrQuestionMark | stosd
      ; 0200A0D30 =  '0' 13 10 ' '
        inc esi

    ..Else_If B$esi+1 = 13
        jmp L3<

    ..Else_If B$esi+1 = ' '
        add edi 2

L4:         dec edi | cmp B$edi 13 | jne L4<
L4:         dec esi | cmp B$esi-1 '|' | jne L4<
            On B$edi-1 = ']', dec edi
          ; No more need of Square Brackets for Multiple Data:
           ; mov eax 05B0A0D5D | stosd              ;  05B0A0D5D = ']' 13 10 '['
           mov W$edi CRLF, B$edi+2 ' ' | add edi 3
                call WriteStructHead
                While B$esi <> ' '
                    movsb
                End_While
            mov al ':' | stosb | inc esi

        If B$esi = 'B'
            mov eax ' B$ '
        Else_If B$esi = 'W'
            mov eax ' W$ '
        Else_If B$esi = 'D'
            mov eax ' D$ '
        Else_If B$esi = 'U'
            mov eax ' U$ '
        Else_If B$esi = 'Q'
            mov eax ' Q$ '
        Else_If B$esi = 'F'
            mov eax ' F$ '
        Else_If B$esi = 'T'
            mov eax ' T$ '
        End_If

        stosd | dec edi | mov eax ' 0 #' | stosd | mov al B$ZeroOrQuestionMark, B$edi-3 al
        add esi 2
        If B$esi >= 'A'
            mov al '&' | stosb  ; If it is a Win Equate instead of a value.
        End_If
        While B$esi <> '|'
            On B$esi = 13, jmp L5>
            movsb
        End_While
     ; No more need of Square Brackets for Multiple Data:
L5:   ;  mov eax 05B0A0D5D | stosd   ; 05B0A0D5D =  ']' 13 10 '['
      mov W$edi CRLF, B$edi+2 ' ' | add edi 3
        If B$esi <> '|'
          ; dec edi
        End_If
    ..Else
L6:     movsb | cmp B$esi '|' | je L7>
                cmp B$esi 13 | jne L6<
L7:     mov al 13 | stosb | mov al 10 | stosb | mov al ' ' | stosb
    ..End_If

L9: cmp B$esi '|' | je L0<<
ret


[StructDisplacement: ?]

BuildStructEquForm:
  ; Write the Structure main name in the EditBox:
  ; esi is on 'WinStructures'
    mov edi StructEditText, D$StructDisplacement 0

        mov al '[' | stosb

BuildFromEquRoutine:           ; reused (called by 'BuildStructStackForm')

; Write the items:
;
; [REBARBANDINFO:|cbSize D|fMask D|fStyle D|clrFore D|cl...
;                ^
    call SetStructHeadText

L0: call WriteStructHead

    inc esi                                           ; jmp over first '|'

    .If B$esi+1 = '|'
        ; case of missing names: "[DDEUP:|D|D'
    .Else_If B$esi+1 < ' '
        ; ... Same for: "[DDELN:|D"
    .Else
        While B$esi <> ' '
            movsb
            If W$esi = '::'
                inc esi | jmp L1>
            End_If
        End_While
L1:     mov eax 'Dis ' | stosd
    .End_If

    mov eax D$StructDisplacement
  ; Destination String pointed by edi. eax holds the value to translate in Ascii Decimal.
    mov dl 0FF | push edx                       ; Push stack end mark
    mov ecx 10
L1: mov edx 0
    div ecx | push edx | cmp eax 0 | ja L1<     ; Push remainders
L2: pop eax                                     ; Retrieve Backward
    cmp al 0FF | je L3>                         ; Over?
       add al '0' | stosb | jmp L2<             ; Write
L3: mov al 13 | stosb | mov al 10 | stosb | mov al ' ' | stosb

  ; Cases of '::', as found above:
    If B$esi = ':'
        jmp L0<
    End_If

    inc esi

; [REBARBANDINFO:|cbSize D|fMa|cl... |bReserved < 2|dwDa...|rcChild RECT<>|rcBand RECT<>...
;                        ^
    ..If B$esi+1 = '|'
        If B$esi = 'B'
            add D$StructDisplacement 1
        Else_If B$esi = 'W'
            add D$StructDisplacement 2
        Else_If B$esi = 'D'
            add D$StructDisplacement 4                                   ; WinStructures
        Else_If B$esi = 'Q'
            add D$StructDisplacement 8
        Else_If B$esi = 'F'
            add D$StructDisplacement 4
        End_If
        inc esi

    ..Else_If B$esi+1 = ' '
      ; Cases of multiple Values (#n)
        mov bl B$esi | add esi 2 | mov ecx 0, eax 0
L4:     lodsb
        cmp al '|' | je L6>>
        cmp al '9' | ja L4>
        cmp al '0' | jb L5>>

                sub al '0'                  ; convert Decimal to binary:
                lea ecx D$ecx+ecx*4         ;     ecx = ecx * 5
                lea ecx D$eax+ecx*2         ;     ecx = eax + old ecx * 10
        jmp L4<
L4:
            mov D$imm32 0
            pushad
                mov edi DataLoopWinEquate
                ;mov al '&' | stosb |
                dec esi
                While B$esi > ' '
                    movsb | On B$esi = '|', jmp L4>
                End_While
L4:             mov al 0 | stosb
                mov esi DataLoopWinEquate
                mov B$ShowWinEquateError &FALSE

                call ReadWin32Equate | on B$EquateFound = &TRUE, mov D$imm32 eax
            popad

            If B$EquateFound = &TRUE
                mov ecx D$imm32
            Else
                mov ecx 1
            End_If

            mov B$ShowWinEquateError &TRUE, D$imm32 0
            While B$esi >= 'A'
                inc esi | On B$esi = '|', jmp L5>
            End_While
            If D$esi = ' + 1'
                inc ecx | add esi 4
            End_If

L5:   ; Error case

L6:     If bl = 'B'
            mov eax 1
        Else_If bl = 'W'
            mov eax 2
        Else
            mov eax 4
        End_If
        mul ecx | add D$StructDisplacement eax | dec esi

    ..End_If

        While B$esi <> '|'
            On B$esi = 13, jmp L9>
            inc esi
        End_While

L9: cmp B$esi '|' | je L0<<
ret


BuildStructStackForm:

    mov edi StructEditText | add edi 100 | mov D$StructDisplacement 0

    call BuildFromEquRoutine

    While B$esi <> '|'        ; Back one item to count the last one size
        dec esi
    End_While

    While B$esi <> ' '
        inc esi
    End_While
    inc esi

    .If B$esi+1 <= CR
        If B$esi = 'B'
            add D$StructDisplacement 1
        Else_If B$esi = 'W'
            add D$StructDisplacement 2
        Else_If B$esi = 'D'
            add D$StructDisplacement 4
        Else_If B$esi = 'Q'
            add D$StructDisplacement 8
        Else_If B$esi = 'F'
            add D$StructDisplacement 4
        End_If
        inc esi
;;
    .Else    ;_If B$esi+1 = ' '
  ; In fact(, it apears that, when the Structure is ended by a Table, this Table Length
  ; is already counted inside the D$StructDisplacement provided by 'BuildFromEquRoutine'.
        mov bl B$esi | add esi 2 | mov ecx 0
L4:     lodsb
        cmp al '9' | ja L5>
        cmp al '0' | jb L5>
        cmp al '|' | je L6>
                sub al '0'                  ; convert Decimal to binary:
                lea ecx D$ecx+ecx*4         ;     ecx = ecx * 5
                lea ecx D$eax+ecx*2         ;     ecx = eax + old ecx * 10
        jmp L4<
L5:     ; Error case
L6:     If bl = 'B'
            mov eax 1
        Else_If bl = 'W'
            mov eax 2
        Else
            mov eax 4
        End_If
        mul ecx | add D$StructDisplacement eax | dec esi
;;

    .End_If

    mov edi StructEditText, esi UserStructTitle  ; Write "Structure @NAME"
    mov eax 'Stru' | stosd | mov eax 'ctur' | stosd | mov ax 'e ' | stosw | mov al '@' | stosb
        While B$esi <> 0
            movsb
        End_While
        mov al ' ' | stosb

    mov eax D$StructDisplacement
    Align_On 4 eax                              ; Stack must remain aligned, whatever.

  ; Destination String pointed by edi. eax holds the value to translate in Ascii Decimal.
    mov dl 0FF | push edx                       ; Push stack end mark
    mov ecx 10
L0: mov edx 0
    div ecx | push edx | cmp eax 0 | ja L0<     ; Push remainders
L2: pop eax                                     ; Retrieve Backward
    cmp al 0FF | je L9>                         ; Over?
       add al '0' | stosb | jmp L2<             ; Write
L9:
    mov ax ', ' | stosw

    mov esi StructEditText | add esi 100

    While B$esi <> 0
        lodsb
        If al = 13
            mov al ','
        Else_If al = 10
            mov al ' '
        End_If
        stosb
    End_While
ret

____________________________________________________________________________________________


[StructHeadText: ? #50]

WriteStructHead:
    push esi
        mov esi StructHeadText
        While B$esi > 0
            movsb
        End_While
    pop esi
ret

[NACKEDSTRUCT 0    LOCALSTRUCT 1    SEMISTRUCT 2    DASHSTRUCT 3]

[StructHeadFlag: ?]

; Defining What text will (or none) be added at the begining of each symbol:

SetStructHeadText:
    pushad
        mov edi StructHeadText

        If B$StructMode = 2
            mov al '@' | stosb | jmp L1>
        End_If

        .If D$StructHeadFlag = NACKEDSTRUCT
            ; 0

        .Else_If D$StructHeadFlag = LOCALSTRUCT
            mov al '@' | stosb

        .Else
L1:         call GetStructureUserName
            mov esi UserStructTitle
            While B$esi <> 0
                movsb
            End_While
            If D$StructHeadFlag = SEMISTRUCT
                mov al '.' | stosb
            Else
                mov al '_' | stosb
            End_If

        .End_If

        mov al 0 | stosb
    popad
ret
____________________________________________________________________________________________

[UserStructName: ? #50]

GetStructureUserName:
    call 'USER32.SendMessageA' D$StructTitleEditHandle &WM_GETTEXT 150 UserStructTitle
ret

____________________________________________________________________________________________

[ClipStructureMemory: ?]

ClipStructure:
    push D$BlockStartTextPtr, D$BlockEndTextPtr, D$BlockInside

        VirtualAlloc ClipStructureMemory 4000
        move D$BlockStartTextPtr D$ClipStructureMemory

        call 'USER32.SendMessageA' D$StructEditHandle, &WM_GETTEXT, 4000, D$ClipStructureMemory

        If eax > 0
            add eax D$BlockStartTextPtr
            mov B$BlockInside &TRUE, D$BlockEndTextPtr eax
            call ControlC

            VirtualFree D$ClipStructureMemory
        End_If

L9: pop D$BlockInside, D$BlockEndTextPtr, D$BlockStartTextPtr
ret


TITLE Format
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
 >>> 'PeHeader' <<<
 SubSystem: W$ 2 > GUI // 3 > CON

 CodeCharacteristics:
 D$   0_60000020                ; readable, runable, code
      0_40000040                ; readable
      0_C0000040                ; readable, writable, initialised data
      0_C0000000                ; Not readable initialised data; don't keep; don't cache
      0_6000840                 ; Not readable initialised data; don't keep; don't cache
0x00000020 code. Usually set in conjunction with the executable flag (0x80000000
0x00000040 initialized data. Almost all sections except executable and the .bss section have this flag set.
0x00000080 uninitialized data (for example, the .bss section).
0x00000200 comments or some other type of information. A typical use of this section is the .drectve section emitted by the compiler, which contains commands for the linker.
0x00000800 shouldn't be put in the final EXE file. These sections are used by the compiler/assembler to pass information to the linker.
0x02000000 can be discarded, since it's not needed by the process once it's been loaded. The most common discardable section is the base relocations (.reloc).
0x10000000 shareable. When used with a DLL, the data in this section will be shared among all processes using the DLL. The default is for data sections to be nonshared, meaning that each process using a DLL gets its own copy of this section's data. In more technical terms, a shared section tells the memory manager to set the page mappings for this section such that all processes using the DLL refer to the same physical page in memory. To make a section shareable, use the SHARED attribute at link time. For example
LINK /SECTION:MYDATA,RWS ...
tells the linker that the section called MYDATA should be readable, writeable, and shared.
0x20000000 executable. This flag is usually set whenever the "contains code" flag (0x00000020) is set.
0x40000000 readable. This flag is almost always set for sections in EXE files.
0x80000000 writeable. loader should mark the memory mapped pages as read-only or execute-only. Typical sections with this attribute are .data and .bss. Interestingly, the .idata section also has this attribute set.

 >>> code = 0_60000020 (unwriteable) // 0_A0000020 (Writeable)
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

OutputFormat:
    If D$OutputHandle = 0
        call 'USER32.DialogBoxParamA' D$hinstance, 19000,  D$hwnd, OutputFormatProc, 0
    Else
        Beep | ret
    End_If

    .If D$TempoSavingExtension  = '.DLL'
        If D$OutputHandle = 0
            call 'USER32.DialogBoxParamA' D$hinstance, 21000,  D$hwnd, DLLFormatProc, 0
        Else
            Beep | ret
        End_If
    .End_If
;;
    .If D$TempoSavingExtension  = '.SYS'
        If D$OutputHandle = 0
            call 'USER32.DialogBoxParamA' D$hinstance, 21001,  D$hwnd, SYSFormatProc, 0
        Else
            Beep | ret
        End_If
    .End_If
;;
ret


[TempoSubSystem: ?    TempoSavingExtension: ?    TempoCodeCharacteristics: ?
 TempoDataCharacteristics: ?
 TempoLinkerDllDefault: ?   OutputHandle: ?]

; Tag Dialog 19000

Proc OutputFormatProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND
        .If D@wParam = &IDCANCEL
            jmp L1>

        .Else_If D@wParam = &IDOK
            call SaveOutputFormat
L1:         mov D$OutputHandle 0 | call 'User32.EndDialog' D@Adressee 0

        .Else_If D@wParam = 10
          ; GUI:
            mov D$TempoSubSystem &IMAGE_SUBSYSTEM_WINDOWS_GUI,
                D$TempoSavingExtension '.EXE'
        .Else_If D@wParam = 11
          ; CON:
            mov D$TempoSubSystem &IMAGE_SUBSYSTEM_WINDOWS_CUI,
                D$TempoSavingExtension '.EXE'
        .Else_If D@wParam = 12
          ; ScreenSaver:
            mov D$TempoSubSystem &IMAGE_SUBSYSTEM_WINDOWS_GUI,
                D$TempoSavingExtension '.SCR'
        .Else_If D@wParam = 13
          ; DLL:
            mov D$TempoSubSystem &IMAGE_SUBSYSTEM_WINDOWS_GUI,
                D$TempoSavingExtension '.DLL'
        .Else_If D@wParam = 14
          ; SYS:
            mov D$TempoSubSystem &IMAGE_SUBSYSTEM_NATIVE,
                D$TempoSavingExtension '.SYS'
; 'SubSystem'
        .Else_If D@wParam = 210

    ;  ..Else_If D$wParam = 211                                    ; Num EditControls, no use.
    ;  ..Else_If D$wParam = 212
    ;  ..Else_If D$wParam = 213

        .Else_If D@wParam = 300                                     ; Writeable Code
            xor D$TempoCodeCharacteristics 0_8000_0000

        .Else_If D@wParam = 301
            xor D$TempoDataCharacteristics &IMAGE_SCN_MEM_SHARED

        .Else
            jmp L8>>

        .End_If

    ...Else_If D@Message = &WM_INITDIALOG
        move D$OutputHandle D@Adressee
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon

        call InitOutputDialog

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP



[LinkerDllDefaultString: '           ', 0] [DllAttachDetach: 0]

; Tag Dialog 21000

Proc DLLFormatProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND
        ..If D@wParam = &IDCANCEL
L1:         mov D$OutputHandle 0
            call 'User32.EndDialog' D@Adressee 0

        ..Else_If D@wParam = &IDOK
            mov ax W$DllAttachDetach, W$DllCharacteristics ax
            call SaveDLLLinkerDefault | cmp eax 0 | jne L1<

 ; DllCharacteristics:     ; 0001h - Per-Process Library Initialization
 ;                         ; 0002h - Per-Process Library Termination
 ;                         ; 0004h - Per-Thread Library Initialization
 ;                         ; 0008h - Per-Thread Library Termination

        ..Else_If D@wParam = 200             ; &DLL_PROCESS_ATTACH = 1
            or D$DllAttachDetach 4 | xor D$DllAttachDetach 4
            or D$DllAttachDetach 1
            call CheckDLLFlags
        ..Else_If D@wParam = 201             ; &DLL_PROCESS_DETACH = 0
            or D$DllAttachDetach 8 | xor D$DllAttachDetach 8
            or D$DllAttachDetach 2
            call CheckDLLFlags
        ..Else_If D@wParam = 202             ; &DLL_THREAD_ATTACH = 2
            or D$DllAttachDetach 1 | xor D$DllAttachDetach 1
            or D$DllAttachDetach 4
            call CheckDLLFlags
        ..Else_If D@wParam = 203             ; &DLL_THREAD_DETACH = 3
            or D$DllAttachDetach 2 | xor D$DllAttachDetach 2
            or D$DllAttachDetach 8
            call CheckDLLFlags

        ..Else_If D@wParam = 100                                     ; LinkerDllDefault

        ..Else
            jmp L8>>

        ..End_If

    ...Else_If D@Message = &WM_INITDIALOG
        move D$OutputHandle D@Adressee
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        mov edi LinkerDllDefaultString, ecx 10 al ' ' | rep stosb
        mov eax D$LinkerDllDefault, ebx eax | mov edi LinkerDllDefaultString | add edi 10
        std
            mov ecx, 8
L1:         mov al bl | and al 0F | On al >= 0A, add al 7
            add al, '0' | stosb | shr ebx, 4 | loop L1<
        cld
        inc edi
        push edi
            call 'USER32.GetDlgItem' D@Adressee 100
        pop edi
        call 'USER32.SendMessageA' eax &WM_SETTEXT 0 edi

        mov ax W$DllCharacteristics, W$DllAttachDetach ax
        call CheckDLLFlags

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP

____________________________________________________________________________________________

[NO_SOURCE 10, SOURCE_IN_CHECKSUM 11, SOURCE_OUT_CHECKSUM 12]

[SysOutputType: ?]

; Tag Dialog 21001

Proc SYSFormatProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_COMMAND
        ..If D@wParam = &IDCANCEL
L1:         mov D$OutputHandle 0
            call 'User32.EndDialog' D@Adressee 0

        ..Else_If D@wParam = &IDOK
            jmp L1<

        ..Else_If D@wParam = 10
            mov D$SysOutputType NO_SOURCE
        ..Else_If D@wParam = 11
            mov D$SysOutputType SOURCE_IN_CHECKSUM
        ..Else_If D@wParam = 12
            mov D$SysOutputType SOURCE_OUT_CHECKSUM
        ..End_If

    ...Else_If D@Message = &WM_INITDIALOG
        move D$OutputHandle D@Adressee
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP
____________________________________________________________________________________________


[DllAdressRange: "
 Smaller than: 0_8000_0000
 Bigger  than:    040_0000     ", 0
 DllAdressRangeTitle: 'Dll Load Adress range is:', 0]

SaveDLLLinkerDefault:
    call 'USER32.GetDlgItem' D$OutputHandle 100
    call 'USER32.SendMessageA' eax &WM_GETTEXT 11 LinkerDllDefaultString

    mov esi LinkerDllDefaultString, ebx 0, eax 0
L0: lodsb | cmp al ' ' | je L0<
            cmp al '_' | je L0<
            cmp al 0   | je L8>
    sub al '0' | On al > 9, sub al 7
    If al > 0F
        mov eax 0 | jmp L9>
    End_If
    shl ebx 4 | add ebx eax | jmp L0<

L8: mov eax ebx | Align_On 01000 eax
    If eax < 0_40_0000
        jmp L2>
    Else_If eax >= 0_8000_0000
L2:     call 'USER32.MessageBoxA' D$hwnd, DllAdressRange, DllAdressRangeTitle, &MB_SYSTEMMODAL
        mov eax 0
    Else
        mov D$LinkerDllDefault eax
    End_If

L9: ret


 ; DllCharacteristics:     ; 0001h - Per-Process Library Initialization
 ;                         ; 0002h - Per-Process Library Termination
 ;                         ; 0004h - Per-Thread Library Initialization
 ;                         ; 0008h - Per-Thread Library Termination

CheckDLLFlags:

    On D$DllAttachDetach = 0, mov D$DllAttachDetach 3    ; Default on first run

    Test D$DllAttachDetach 1 | jnz L1>
        or D$DllAttachDetach 4 | jmp L2>    ; If not 1 > 4
L1: and D$DllAttachDetach 0_FFFF_FFFB       ; If 1 > not 4

L2: Test D$DllAttachDetach 2 | jnz L1>
        or D$DllAttachDetach 8 | jmp L2>    ; If not 2 > 8
L1: and D$DllAttachDetach 0_FFFF_FFF7       ; If 2 > not 8

L2: call 'USER32.CheckDlgButton' D$OutputHandle 200 &FALSE
    call 'USER32.CheckDlgButton' D$OutputHandle 201 &FALSE
    call 'USER32.CheckDlgButton' D$OutputHandle 202 &FALSE
    call 'USER32.CheckDlgButton' D$OutputHandle 203 &FALSE

    Test D$DllAttachDetach 1 | jz L1>
        call 'USER32.CheckDlgButton' D$OutputHandle 200 &TRUE
L1: Test D$DllAttachDetach 2 | jz L1>
        call 'USER32.CheckDlgButton' D$OutputHandle 201 &TRUE
L1: Test D$DllAttachDetach 4 | jz L1>
        call 'USER32.CheckDlgButton' D$OutputHandle 202 &TRUE
L1: Test D$DllAttachDetach 8 | jz L1>
        call 'USER32.CheckDlgButton' D$OutputHandle 203 &TRUE
L1: ret

____________________________________________________________________________________________

InitOutputDialog:
    move D$TempoCodeCharacteristics D$CodeCharacteristics
    move D$TempoDataCharacteristics D$DataCharacteristics
    move D$TempoSavingExtension D$SavingExtension
    move D$TempoSubSystem D$SubSystem
    move D$TempoLinkerDllDefault, D$LinkerDllDefault

    call 'USER32.SetDlgItemInt' D$OutputHandle, 210, D$AppStackMin, 0
    call 'USER32.SetDlgItemInt' D$OutputHandle, 211, D$AppStackMax, 0
    call 'USER32.SetDlgItemInt' D$OutputHandle, 212, D$AppHeapMin, 0
    call 'USER32.SetDlgItemInt' D$OutputHandle, 213, D$AppHeapMax, 0

    test D$CodeCharacteristics 0_8000_0000 | jz L2>
        call 'USER32.CheckDlgButton' D$OutputHandle, 300, &TRUE

L2: test D$DataCharacteristics &IMAGE_SCN_MEM_SHARED | jz L2>
        call 'USER32.CheckDlgButton' D$OutputHandle, 301, &TRUE

L2: If D$SavingExtension = '.SCR'
        call 'USER32.CheckDlgButton' D$OutputHandle, 12, &TRUE
    Else_If D$SavingExtension = '.DLL'
        call 'USER32.CheckDlgButton' D$OutputHandle, 13, &TRUE
    Else_If D$SavingExtension = '.SYS'
        call 'USER32.CheckDlgButton' D$OutputHandle, 14, &TRUE
    Else_If D$SubSystem = 2
        call 'USER32.CheckDlgButton' D$OutputHandle, 10, &TRUE
    Else_If D$SubSystem = 3
        call 'USER32.CheckDlgButton' D$OutputHandle, 11, &TRUE
    End_If

   call LoadCommandLine
ret


SaveOutputFormat:
    call 'USER32.GetDlgItemInt' D$OutputHandle, 210, &NULL, &FALSE | Align_On 01000 eax
        mov D$AppStackMin eax
    call 'USER32.GetDlgItemInt' D$OutputHandle, 211, &NULL, &FALSE | Align_On 01000 eax
        On eax < D$AppStackMin, mov eax D$AppStackMin
        mov D$AppStackMax eax
    call 'USER32.GetDlgItemInt' D$OutputHandle, 212, &NULL, &FALSE
        On eax > 0,  Align_On 01000 eax
        mov D$AppHeapMin eax
    call 'USER32.GetDlgItemInt' D$OutputHandle, 213, &NULL, &FALSE | Align_On 01000 eax
        On eax < D$AppHeapMin, mov eax D$AppHeapMin
        mov D$AppHeapMax eax

    move D$CodeCharacteristics D$TempoCodeCharacteristics
    move D$DataCharacteristics D$TempoDataCharacteristics
    move D$SavingExtension D$TempoSavingExtension
    move D$SubSystem D$TempoSubSystem

    On D$TempoSavingExtension = '.SYS',
       mov W$DllCharacteristics &IMAGE_DLLCHARACTERISTICS_WDM_DRIVER

    call SaveCommandLine
ret







TITLE Disassembler

;;
  'StripSectionsZeroEnd', 'FlagApiProcedures'
  
  'DisDataTypeRouter', 'MarkSSEdata'
 
 'HLL_Strings_Table_notes'
 'FlagApiProcedures', 'SetApiProcedure', 'WriteDisCodeLabel', 
 'WriteOneDataLabel', 'WriteDisPointers'

 'SelectMainWindowProc'
 
 'ForcedFlagsProc' 'DisassembleProc' 'WriteForcedMapFiles'
 
 'ConditionalJumpsAnalyzes' 'IsConditionalShortJump' 'IsLoop'
 
 'DisImageBase' 'UnlikelyOut'
 
 'WriteOneDataChunk' >>> 'DisDataTypeRouter' 'FlagPointerToPointer'
  
 'Map'
 
 'DisMain' 'ForceMenusExType' 'WriteDisRelative' 'EndWithDisByteRelative'
 'WritedWordPointers'
 'DisFail'
 'MarkEvocated' 'StoreDisSize' <<< for Size Markers
 'IsItCode' 'CheckAsciiData'
 'DisassembleForCodeRouting' 'TryToDisassembleEvocated' 'DisassembleAndWrite'
 'WriteDBandData' 'AlignRecognition' 'WriteOneDataChunk' >>> 'DisDataTypeRouter'
 'SearchMainWindowProc'
 'WriteDisRelative', 'FlagApiProcedures', 'StoreDisSize'
 'IsItCode'
 
  For Menus: EnableMenuItem
  
 'NamedIdSubstitution'  'WriteDisMenuIDs'
 
 'ST0ToAscii'
 
 'DisOp1'
____________________________________________________________________________________________
 
 For volunteers: 'OpenDev' / 'HLLAnalyzes' / ...

 Strategy:
 
   Once loaded, the target PE is re-mapped from File Alignement (usually 0200) to Memory
   alignement (usually 01000). The Name of this Target Table is yet 'UserPeStart'

   Then Tables are created, with the same length as the mapped PE. They are 'Flag Images'
   of the Target:
   
 * The 'SectionsMap' Table is for storing Sections Flags.
 * The 'RoutingMap' Table is for storing the routing Flags.
 * The 'SizesMap' Table is for the Sizes of evocated Data.
 
   These Table are duplicated , for the Negative Strategy, in 'InitDisTablesCopies'
   and friends.
 
 ________________ Positive Strategy ____________________
 (This is to say, searching, first, for all very highly probable Code and Data).
  
 * Mark 'Main'.
 
 * Search the EVOCATED Procedure (PUSH_EBP)
 
 * 'DisassembleForCodeRouting' for main and identified procedures
 
 * Search for Data Strings, Unicode Strings, PointersFlows, ...
 
 * (Sure Code marked CODEFLAG // Data Strings, Pointers and Sizes Marked >>> DATAFLAG)
 
 
 ________________ Negative Strategy ____________________
 (This is to say, everything left unflaged, that could be considerd Code will
 much likely kill something already identified valid, either as Code or as Data
 if it would not be interpreted as Data).

 * 'TryToDisassembleEvocated' >>> ItsItCode >>> Yes (it looks like valid Codes
   >>>> 'DisassemblingAttempt' >>> No Code broken // No Data in Disassembly 
   >>> Valid Code >>> Run 'DisassembleForCodeRouting' on all Evocated Location
   not yet Flaged as a Section.
 
 * All remaining zeroed Sections Flags to Data.
____________________________________________________________________________________________
____________________________________________________________________________________________
;;

[FirstDisVirtualData: ?]

; re-mapped target File:

;;
  All of these Tables are the same size as the PE to be disassembled.
  
  'SectionsMap' is simply for flaging the various sections. The Flags are the
  ones found at 'CODEFLAG'
  
  'RoutingMap' is mainly for flaging the Code Flow, as found by r=the Recognitions
  and by the various Disassembling passes. The Flags are the ones found at 'INSTRUCTION'.
  In this List of Equates, 'EVOCATED' is not only for Code, but is used as well for
  Data.
  
  'SizesMap' is for flaging the Memory accesses. The purpose is for pointing Data
  out. The Flags are the one at 'BYTE'
  
  'StringsMap' is a Table of dWords, where each dWord is a mirror of a Byte, in
  the PE, and where each dWord may be a Pointer to a Symbol String, located
  anywhere else.
  
  A Macro 'ToStringsMapFrom' is provided to help switching from any other Map, to
  the Strings Table. This Macro is used each time a Label is being written, so
  that the Symbolic Name could be given, in the outputed Source, with the usual
  synthetic Label.
;;

[SectionsMap: ?    EndOfSectionsMap: ?
 RoutingMap: ?     EndOfRoutingMap: ?
 SizesMap: ?       EndOfSizesMap: ?
 StringsMap: ?     EndOfStringsMap: ?]

;;
  Macro for switching from any Map to StringsMap:
  
  ToStringsMapFrom Map reg ; example:
  
  ToStringsMapFrom SectionsMap, ebx
;;

[ToStringsMapFrom | sub #2 D$#1 | shl #2 2 | add #2 D$StringsMap]

;;
  ToStringsMapFrom is evocated from: 'MarkEntryPoint', 'WriteOneDataLabel',
  'WriteDisPointers', 'SetWINDCLASSData', 'SetWINDCLASSEXData', 'SetApiProcedure',
  'WriteDisCodeLabel', 'SetProcStrings'
;;

; ('EndOf...' points the Byte *after* // All the Length are 'D$UserPeLen')

; Sections Flags:
[CODEFLAG 1, DATAFLAG 2, VIRTUALFLAG 4, IMPORTFLAG 8, RESOURCESFLAG 010
 EXPORTFLAG 040,  KILLFLAG 080, TEMPOFLAG 0FF]

[TWOTEMPOFLAGS 0FFFF TWODATAFLAGS 0202
 FOURCODEFLAGS 01010101    FOURDATAFLAGS 02020202    FOURTEMPOFLAGS 0FFFF_FFFF
 FOUR_RESOURCESFLAG 010101010]
; 02 0A 01
; Routing Flags:  ; 01A (0A=EVOCATED+LABEL) 012 01F 010 09F 04A
[INSTRUCTION         1  ; > Start of an Instruction.
 EVOCATED        00_10  ; > little weight marker for any supposed evocation.
 NODE           00_100  ; > Directely CALLed or JMPed Location (+INSTRUCTION+LABEL)
 LABEL         00_1000  ; > Labelled Data Location.
 CHUNKEND      00_1000  ; > Location after a RET or a JMP (should be LABEL+NODE)
 ACCESSED    00_1_0000  ; > Marks a chunk of Instructions by direct call or jump.
 EXPORTNODE 00_10_0000  ; > Used for direct write of Exported Function Labels Names.
 INDIRECT  00_100_0000  ; > Data Reference to Code. No effect if not Instruction aligned.
 PUSH_EBP 00_1000_0000] ; > Futur NODE (typical CallBack entry-Point).

; 04A >  00_100_1010 EVOCATED LABEL INDIRECT
; 01F
; 016 >>> 10110
; 17    >>>   001_0001  ; Instruction / Accessed  //  0A EVOCATED+LABEL 012

; Sizes Flags: ; 014 045
[BYTE 1, WORD 00_10, DWORD  00_100
 FP4 00_1000, FP8 00_1_0000, FP10 00_10_0000
 POINTER 00_100_0000, STRINGS 00_1000_0000]

[LeaInstruction: &FALSE]

Proc BuildCommentedCodeReference:
    Arguments @DataPointer
    Local @DataPos
    Uses edx, esi, ebx, eax

        mov ebx D@DataPointer

      ; Get the actual position of the data label.
        mov eax ebx
        sub eax D$RoutingMap
        mov D@DataPos eax

        Zcopy {W$ CRLF, B$ "; Referenced Routing Flags: Hex = ", 0}
        movzx eax B$ebx

        push eax
            call Writeeax
        pop eax

L1:     cmp al CHUNKEND | jnz L1>
            zCopy {' CHUNKEND +', 0} | jmp L2>>
L1:
        test eax INSTRUCTION | jz L1>
            zCopy {' INSTRUCTION +', 0}
L1:     test eax EVOCATED | jz L1>
            zCopy {' EVOCATED +', 0}
L1:     test eax NODE | jz L1>
            zCopy {' NODE +', 0}
L1:     test eax LABEL | jz L1>
            zCopy {' LABEL +', 0}
;L1:    test eax CHUNKEND | jz L1>
    ;       zCopy {' CHUNKEND +', 0}
L1:     test eax ACCESSED | jz L1>
            zCopy {' ACCESSED +', 0}
L1:     test eax EXPORTNODE | jz L1>
            zCopy {' EXPORTNODE +', 0}
L1:     test eax INDIRECT | jz L1>
            zCopy {' INDIRECT +', 0}
L1:     test eax PUSH_EBP | jz L1>
            zCopy {' PUSH_EBP +', 0}
L1:

L2:

    If W$edi-2 = ' +'
        sub edi 2
    End_If

    mov W$edi CRLF | add edi 2
EndP


Proc BuildCommentedDataReference:
    Arguments @DataPointer
    Local @DataPos
    Uses edx, esi, ebx, eax

        mov ebx D@DataPointer

      ; Get the actual position of the data label:
        mov eax ebx
        sub eax D$RoutingMap
        mov D@DataPos eax

        Zcopy {W$ CRLF, B$ "; Referenced Size Flag for next data: Hex = ", 0}
        movzx eax B$ebx

        push eax
            call WriteEax
        pop eax

        test eax STRINGS | jz L1>
            zCopy {' STRINGS +', 0}
L1:     test eax POINTER | jz L1>
            zCopy {' POINTER +', 0}
L1:     test eax FP10 | jz L1>
            zCopy {' FP10 +', 0}
L1:     test eax FP8 | jz L1>
            zCopy {' FP8 +', 0}
L1:     test eax FP4 | jz L1>
            zCopy {' FP4 +', 0}
L1:     test eax DWORD | jz L1>
            zCopy {' DWORD +', 0}
L1:     test eax WORD | jz L1>
            zCopy {' WORD +', 0}
L1:     test eax BYTE | jz L1>
            zCopy {' BYTE +', 0}
L1:

        If W$edi-2 = ' +'
            sub edi 2
        End_If

        mov W$edi CRLF | add edi 2
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

; For Disassembler developpements: Shows the Hexa of the various Dis Tables:

Proc ShowMaping:
    Argument @Map, @MapEnd, @Close

        ;mov D$DisViewPos 0

        mov esi D@Map, ecx D@MapEnd | sub ecx D@Map | shl ecx 6
        VirtualAlloc TempoMemPointer ecx

S0:     mov edi D$TempoMemPointer, esi D@Map, ecx D@MapEnd
        sub ecx esi | dec ecx

        mov eax esi | sub eax D@Map | add eax D$DisImageBase
        call WriteEax | mov D$edi '    ' | add edi 4

L0:     lodsb | shr al 4 | add al '0' | On al > '9', add al 7 | stosb
        dec esi | lodsb | and al 0F | add al '0' | On al > '9', add al 7 | stosb
        mov al ' ' | stosb

        test ecx 00111 | jnz L1>
            mov al ' ' | stosb

        test ecx 001111 | jnz L1>
            sub esi 16
            push ecx
                mov ecx 16
T0:             lodsb | On al < ' ', mov al '.' | stosb | loop T0<
            pop ecx
            mov ax 0A0D | stosw
            mov eax esi | sub eax D@Map | add eax D$DisImageBase
            call WriteEax | mov D$edi '    ' | add edi 4
L1:     loop L0<
; Tag Dialog 1001
        call 'USER32.DialogBoxParamA' D$hInstance, 1001, &NULL, DisViewProc, &NULL

        .If D$ViewCommand = 11
            mov eax D$SectionsMap, D@Map eax
            mov eax D$EndOfSectionsMap, D@MapEnd eax
            jmp S0<<
        .Else_If D$ViewCommand = 12
            mov eax D$RoutingMap, D@Map eax
            mov eax D$EndOfRoutingMap, D@MapEnd eax
            jmp S0<<
        .Else_If D$ViewCommand = 13
            mov eax D$Sizesmap, D@Map eax
            mov eax D$EndOfSizesMap, D@MapEnd eax
            jmp S0<<
        .Else_If D$ViewCommand = 14
            mov eax D$UserPeStart, D@Map eax
            mov eax D$UserPeEnd, D@MapEnd eax
            jmp S0<<
        .Else_If D$ViewCommand = 15
            If D$JumpsMap <> 0
                mov eax D$JumpsMap, D@Map eax
                mov eax D$EndOfJumpsMap, D@MapEnd eax
                jmp S0<<
            End_If
        .End_If

        VirtualFree D$TempoMemPointer

        mov B$SilentMap &TRUE
        On B@Close = &TRUE, jmp DisFail
EndP


[DisViewPos: ?    ViewCommand: ?]

Proc DisViewProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    .If D@Message = &WM_INITDIALOG
        mov D$EmptyDialogHandle eax
        call 'USER32.SetDlgItemTextA' D@Adressee, 100, D$TempoMemPointer
        If D$DisViewPos <> 0
            call 'User32.SendDlgItemMessageA' D@Adressee,100, &EM_LINESCROLL, 0, D$DisViewPos
        End_If

        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        mov eax &TRUE

    .Else_If D@Message = &WM_CLOSE
        mov D$DisViewPos 0, D$ViewCommand 0
        call 'User32.DestroyWindow' D@Adressee

    .Else_If D@Message = &WM_COMMAND
        If D@wparam < 11
            ;
        Else_If D@wparam > 15
            ;
        Else
            move D$ViewCommand D@wParam
            call 'User32.SendDlgItemMessageA' D@Adressee, 100, &EM_GETFIRSTVISIBLELINE, 0, 0
            mov D$DisViewPos eax
            call 'User32.DestroyWindow' D@Adressee
        End_If

    .Else_If D@Message = &WM_CTLCOLOREDIT
        call 'USER32.SendMessageA' D@lParam, &EM_SETSEL, 0-1, 0
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor

    .Else
        popad | mov eax &FALSE | jmp L9>

    .End_If

    popad | mov eax &TRUE

L9: EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
 Initialisation of the Disassembly:
 
 We clear all of the Disassembler internal data, from 'FirstDisVirtualData'
 to 'LastDisVirtualData', and free all of the Data that could have been for
 a previously loaded PE.
 
 We intialize The Truth Ascii Table, for Ascii and Unicode Recognitions, and
 initialize the ProgreesBar, for the Disassembly time.
;;

DisInitialise:
  ; Clear all Disassembler job Virtual Data:
    mov edi FirstDisVirtualData, eax 0

    While edi < LastDisVirtualData | stosd | End_While

    Align_On 4 D$UserPeLen

    mov B$Disassembling &TRUE

    call CloseTree | call ReInitUndo | call ReInitHeaderFormat
    VirtualFree D$BookMarks | call ClearBackTable | call ReleaseResourceMemory

    call BuildTruthAsciiTable

    call InitDisProgressBar
;;
  The steping of the Progress Bar is just a simple evaluation. The Range is set
  (in 'InitDisProgressBar') at 0 to 128. So that we have to shr 7 for having the
  step size. But, as the Disassembler is run at least 4 times (2 or more for Pass1 /
  1 for Pass2 / 1 for Pass3), we estimate the number of Passes at 8 (> shl 3).
  So 7-3 > 4.
;;
    mov eax D$UserPeLen | shr eax 4 | or eax 1
    mov D$DisBarStep eax | move D$NextDisBarPos D$UserPeStart

    mov eax D$UserPeStart
    If D$eax+059 = 'spit'
        On D$eax+069 = ' wiz', mov D$CompiledBy 'ROSA'
    End_If

    mov D$DisMainWindowProc 0
ret
____________________________________________________________________________________________

; 'DisMain' is called by 'OpenRosAsmPe' if no Source found inside and if the
; user wants it.

[DisWarningMessage: ' ... with Un-modified File Name.           ', 0
 DisWarningTitle: 'Take care!!!...', 0]

[WritingData: 'Writing Data...', 0
 DisPasses: 'Analyze of the Code flow...', 0
 PointersAnalyzes: 'Analyzes of pointers to Code. Wait...', 0
 NegativeAnalyze: 'Negative Analysis of Code. May be slow...', 0
 SymbolsWriting: 'Symbolic Analyze of Api calls Parameters...', 0]

[EndOfDisData: ?    FromUserPeStartToMap: ?]
____________________________________________________________________________________________

MarkRosAsmPeSections:
    GetPeHeader SectionsHeaders | mov esi eax

    mov ecx D$DisNumberOfSections

L0: push ecx
        mov edi D$esi+SECTION_RVA | add edi D$SectionsMap
        mov ecx D$esi+SECTION_RVASIZE | Align_On 01000 ecx

        mov eax D$esi

        .If eax = '.ida'
            mov al IMPORTFLAG
        .Else_If eax = '.rsr'
            mov al RESOURCESFLAG
        .Else_If eax = '.dat'
            mov al DATAFLAG, ecx D$esi+SECTION_RVASIZE, edx D$esi+SECTION_FILESIZE
            On edx < ecx, xchg ecx edx
            Align_On 32 ecx
            push ecx
                rep stosb
            pop eax
            mov ecx D$esi+SECTION_RVASIZE, edx D$esi+SECTION_FILESIZE
            On edx > ecx, xchg ecx edx
            Align_On 01000 ecx | sub ecx eax
            mov al VIRTUALFLAG
        .Else_If eax = '.tex'
          ; Not CODEFLAG. It would kill the 'TryToDisassembleEvocated' job:
            mov al 0, ecx D$esi+SECTION_RVASIZE, edx D$esi+SECTION_FILESIZE
            On edx < ecx, xchg ecx edx
            add ecx 7
            push ecx
                rep stosb
            pop eax
            mov ecx D$esi+SECTION_RVASIZE, edx D$esi+SECTION_FILESIZE
            On edx > ecx, xchg ecx edx
            Align_On 01000 ecx | sub ecx eax
            mov al KILLFLAG
        .Else_If eax = '.eda'
            mov al EXPORTFLAG
        .Else
            mov al KILLFLAG
        .End_If

        rep stosb
    pop ecx

    add esi SECTIONHEADERSIZE | dec ecx | jnz L0<<
ret

____________________________________________________________________________________________

[OriginalDisPe: B$ ? #&MAX_PATH] [UserDisPeName: B$ ? #&MAX_PATH]

Proc SaveDisPeName:
    Argument @Destination

        mov esi MainName, edi D@Destination

        While B$esi <> 0 | movsb | End_While

        mov eax D$SavingExtension | stosd | mov B$edi 0
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

;call ShowMaping D$SectionsMap, D$EndOfSectionsMap, 1
;call ShowMaping D$RoutingMap, D$EndOfRoutingMap, 1
;call ShowMaping D$ApiBuffer, D$EndOfApiBuffer, 1
;call ShowMaping D$UserPeStart, D$UserPeEnd, 1
;call ShowMaping D$SizesMap, D$EndOfSizesMap, 1

[MapingBase: 050A007] ;407967]

[Map | call MapCall]

MapCall: MapView

[MapView |  If D$MapingBase <> 0
                mov eax D$MapingBase | sub eax D$DisImageBase | shr eax 4
                mov D$DisViewPos eax
            Else
                mov D$DisViewPos 0
            End_If

call ShowMaping D$SectionsMap, D$EndOfSectionsMap, 1]

[CompiledBy: ?    LastDisassemblyRoutingPass: ?]

DisMain: ; 'MSVBVM' 'OpenRosAsmPe', 'DisassembleProc'
    mov B$LastDisassemblyRoutingPass &FALSE

    call SaveDisPeName OriginalDisPe
    ___________________________
  ; Initialise the Disassembly:
;;
  When loading a PE without Source, the 'OpenRosAsmPE' Routine jumps here.
  'UserPeStart' point to the Start of the PE load into Memory, and 'UserPeLen'
  holds the length of the PE. All of this is the PE as found on Disk.
;;
  ; For 'DisFail' short exit:
    mov eax esp, D$OldStackPointer eax, D$CompiledBy 0

    call DisInitialise | call FixMzParagraphsNumber

  ; 'ReadResourcesRecord' seems to fail at pointing out GoAsm Resources.
  ; Not sure: To be verified.

    call LoadDisResources

    call StartNewDisFile | call ReAlignPE | call AllocateDisTables

; 'OutputFormat'
; Hexprint D$SavingExtension | jmp DisFail
    ____________________________________________________________
;;
  The PE in Memory is now ready for analyzes.
;;
  ; We don't need .reloc and .debug:
    call KillPeHeader | call KillSection RelocSectionTable | call KillSection DebugDir
;map
  ; Check the secure Sections:
    call CheckImport | call CheckExport
;map
    call CheckResources
;map
    call CheckVirtualData | call CheckExtendedVirtual

    call SmallBlanksToSameFlag
;map
    call KillSectionsExtensions
;map
    _____________________________________________________________

  ; If called from 'TryDisassembly' or from 'ReRunDisassembler':
    If B$WithForcedMapFile = &TRUE
        call ReadForcedRecordsFile
        On D$ForcedRecordsTable <> 0, call ForceRecordsToMaps
    Else
        call DeleteForcedFile
        VirtualFree D$ForcedRecordsTable
    End_If

  ; Sniff Recognition should come here...
    If D$CompiledBy = 'ROSA'
        call MarkRosAsmPeSections
;map
    Else_If D$CompiledBy = 'MSVB'
        call MarkVbPe
    Else
      ; ...
    End_If
;map
    ;
    ____________________________________________________________
;;
    Guga D.I.S. Identification Plan:
  
    call GetDisPath | call LoadOneDisFile {'Pe', 0}, '.dis'
    
    ; LoadPeDisFile
    
    .If B$DisFileOk = &TRUE
        VirtualAlloc PeDisMatches 01000 | move D$PeDisMatchesPointer D$PeDisMatches
  
        call ParsePeDis
        call GetBiggerPeDisID
        
        VirtualFree D$PeDisMatches
        jmp DisFail
    .End_If
;;
    ____________________________________________________________
  ; Here we go for Code vs Data Recognitions:
    ______________________________________
  ; Positive Recognition for Data and Code:

  ; 'MarkEvocated' _MUST_ be kept _first_ Recognition.
    call MarkEvocated | call ConditionalJumpsAnalyzes
;map
    call MarkEntryPoint
    call MarkProcedures | call MarkJumpsTables
;map
    call MarkPointersFlows | call MarkAlternatedPointersFlows
;map
    call DisassembleForCodeRouting
;map
    call MarkVeryRepetitiveDataBytes ; (12 identical Bytes >>> Data)
;Map
    call MarkEvocatedSizes
;map
    call MarkRepetitiveDataBytes ; (8 identical Bytes >>> Data)
;;;map
; Probably obsolete. Anyway, should not be at thins place:
    ;call ExtendStrings | call FillStringsSizes
;Map
    call UnEvocatedProcedures

    call DisassembleForCodeRouting

    mov B$Forced &TRUE
    call AsciiRecognition 25 | call UnicodeRecognition 25
    mov B$Forced &FALSE
;Map
    call SmallBlanksToSameFlag
;Map
    mov B$LastDisassemblyRoutingPass &TRUE
    call DisassembleForCodeRouting
    mov B$LastDisassemblyRoutingPass &FALSE

    call FlagTrueDataSection
;map
    call MarkIsolatedPointers
;map
    call SmallBlanksToSameFlag
;map
    call FlagsCleaner
;map
    ;call FlagTrueDataSection ; Better 4 lines above.
;map

    _________________________________________________________________
  ; Try&See recognitions of left Code // Negative Recognition of Data:
    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, PointersAnalyzes
;
    call CodeFromPointers

    If B$AttemptSuccess = &TRUE
        call DisassembleForCodeRouting
        call SmallBlanksToSameFlag
    End_If

    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, NegativeAnalyze

    call GetBiggerSectionsBlank | mov ecx D$BiggerZeroedSectionsChunk
;map

    .Do
L0:     push ecx
            call TryToDisassembleEvocated ecx

            If B$AttemptSuccess = &TRUE
                call DisassembleForCodeRouting
                call SmallBlanksToSameFlag
;;
  This inner loop is Bound to "jmp L9>", in 'TryToDisassembleEvocated'. When these
  are uncommented, the results tend to be a little bit better. The problem is that
  it all becomes way too slow:
;;
                ;pop ecx | jmp L0<
;;
  Therefore, we can expect that a more sophisticated way for choosing the biggest
  Chunks could perhaps be implemented.
;;
            End_If
        pop ecx
;;
  To be watched: The tuning of these Strings jobs have impact on 3DFUN.EXE. Example,
  reducing the last (smaller) length, breaks the rebuilt. Remark: There is no need of
  scaning smaller Chunks here, as they should be assumed later, by 'DisDataTypeRouter'.
;;
        push ecx
            .If ecx < 100
                If ecx > 50
                    call AsciiRecognition 20 | call UnicodeRecognition 20 | jmp L9>
                End_If
            .End_If

            .If ecx <= 50
                If ecx > 25
                    call AsciiRecognition 15 | call UnicodeRecognition 15 | jmp L9>
                End_If
            .End_If

            .If ecx <= 25
                If ecx > 13
                    call AsciiRecognition 12 | call UnicodeRecognition 12 | jmp L9>
                End_If
            .End_If
L9:     pop ecx

        shr ecx 1 | mov eax ecx | shr eax 1 | add ecx eax
  ; Let the ecx = 0. This is to say down to one _Instruction_:
    .Loop_Until ecx = 0
;map
    call FlagsCleaner

    call DisassembleForCodeRouting

    call SmallBlanksToSameFlag
;Map
    call DisAlign
;Map
    ;call RemoveNonAccessedEvocatedData
;Map
  ; All Code pointed out >>> Not flaged Chunks to Data:
    call FillDataSection | call StripSectionsZeroEnd

    call MarkIsolatedPointers ; Second call really helpfull?
;map
    mov B$LastDisassemblyRoutingPass &TRUE

    call DisassembleForCodeRouting
;Map
    call CheckPointersInData

    call SplitBigData
;map
    call FlagsCoherency

    call FlagsCleaner
;map

    _________________________________
    _________________________________

  ; Recognitions over: The real Disassembly output begins here.
    ________________________________________________________
  ; Now we write the Source. We need the original File Name. Save it first:

    mov edi D$CodeSource | call WriteOriginalFileNameInSource

  ; then, Default Macros, and Data:

    mov D$NextDisTITLE edi | add D$NextDisTITLE (TITLE_MAX/2) | mov W$DisTitle+12 '01'

    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, WritingData
;Map
    If B$WithMacros = &TRUE
        On D$SavingExtension <> '.SYS', call WriteMacros
    End_If

    mov D$EndOfDisData edi

  ; ... and then Code:
;Map
    mov D$NextDisBarPos 0 | call DisassembleAndWrite  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;call TestStringsTable
    pushad
        call WriteMapFiles ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        call WriteForcedRecordsFileBase
    popad

    ________________________________
  ; Preparing for the Source Editor:
    call SetDisSourceVariables

  ; Searching for 'MainWindowProc' Location:
   ;On D$SavingExtension <> '.DLL', call SearchMainWindowProc

    If B$MenuInside = &TRUE
         ; called from 'MenuIdsSubstitutions', 'PrepareDisMenuIDs' Builds the
           ; Table of Menu Ids Declarations
            call MenuIdsSubstitutions
            On B$WM_COMMAND_Found = &TRUE, call ResetMenusIDs
        End_If
    End_If

    call NamedIdSubstitution

    VirtualFree D$TruthAsciiTable, D$ApiBuffer
    VirtualFree D$UserPeStart | move D$UserPeStart D$CodeSource
    VirtualFree D$SectionsMap, D$RoutingMap, D$SizesMap, D$StringsMap
;;
  Because the 'normal' way to load a PE, in RosAsm, implements the 'CodeSource'
  pointer into the 'UserPeStart' Mem Chunk. Here, we do not define the Mem size
  depending on the File Source size, but we evaluate the size from the Code
  length after analyze of the PE.

  + If Resources saved by Name: Set ID Numbers ?????
;;
    SetWindowText

    mov D$DestinationFile 0

    mov D$OpenPEStruc+(12*4) ChangeNameTitle
    mov esi SaveFilter
    While B$esi <> 0 | inc esi | End_While
    dec esi | lea edi D$esi+2
    std
        Do
            movsb | On B$esi = '\', jmp L1>
        Loop_Until esi < SaveFilter
L1:     inc esi | mov W$esi 'My'
    cld

    .If D$WithForcedMapFile = &FALSE
        call ChangeName | mov D$OpenPEStruc+(12*4) OpenPEFileTitle

        If eax = &FALSE
            call 'USER32.MessageBoxA' D$hwnd, DisWarningMessage, DisWarningTitle,
                                    &MB_SYSTEMMODAL__&MB_ICONSTOP
        End_If

        call SaveDisPeName UserDisPeName

    .Else
        call SaveNewFileName | mov D$OpenPEStruc+(12*4) OpenPEFileTitle
        call SaveDisPeName UserDisPeName
        SetWindowText

    .End_If

    call StartEdition | move D$UserPeStart D$CodeSource

    mov B$Disassembling &FALSE, B$SourceReady &TRUE

    call DestroyDisProgressBar

    mov B$ThisSourceIsDisassembled &TRUE
ret


DestroyDisProgressBar:
    On D$ProgressInst <> 0, call 'User32.DestroyWindow' D$ProgressInst
    On D$hwndForBar <> 0, call 'User32.DestroyWindow' D$hwndForBar
    mov D$ProgressInst 0, D$hwndForBar 0
ret
____________________________________________________________________________________________

; Simple Debug-Test for viewing what is inside:

TestStringsTable:
    pushad
        mov esi D$StringsMap

        .While esi < D$EndOfStringsMap
            If D$esi <> 0
                mov eax esi | sub eax D$StringsMap | shr eax 2 | add eax D$DisImageBase
                mov edi Trash | call WriteEax | mov D$edi ' -> ' | add edi 4
                push esi
                    mov esi D$esi
                    While B$esi <> 0 | movsb | End_While
                pop esi
                mov B$edi 0
                Showme Trash
            End_If

            add esi 4

        .End_While
    popad
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[MenuInside: ?]

LoadDisResources:
    __________________________________________________________________________
  ; Next Lines are the same as the ones in 'OpenRosAsmPE' after having read the
  ; included Source:

    mov B$MenuInside &FALSE

    call SearchDisPEstartOfResource | On B$NoResourcesPE = &TRUE, jmp L9>>

  ; Here, 'UserPEStartOfResources' is the IMAGE_OPTIONAL_HEADER Sections aligned Pointer
  ; to Header.
    mov eax D$UserPEStartOfResources, ebx 0 | On eax = 0, jmp L9>>

L0: shl ebx 1 | or ebx 1 | test eax ebx | jz L0<
    shr ebx 1 | and eax ebx

    push eax
        call SearchPEstartOfResource
      ; Here 'UserPEStartOfResources' is the Sections Header File Aligned Section Pointer.
      ; We need this one but with the eventual Dis to Header (header not necessary at
      ; first Section Byte.
    pop eax

    .If D$UserPEStartOfResources <> 0
        or D$UserPEStartOfResources eax

        move D$iExePtr D$UserPeStart

        mov eax D$UserPEStartOfResources, D$iStartOfResources eax
        call DisReadMainIcon

        If B$PeIconFound = &TRUE
            mov esi eax | mov edi iIcon | rep movsb ; Copying to icon editor buffer
            call StoreIcon                          ; and copy it to 'compilable' image
        End_If

        call ReadRosAsmResources

        If D$MenuList+4 <> 0
            call ForceMenusExType | mov B$MenuInside &TRUE
        End_If
    .End_If
L9: ret


SearchDisPEstartOfResource:
    mov B$NoResourcesPE &TRUE, D$UserPEStartOfResources 0
    mov esi D$DisPeTagPointer | On esi = 0, ret

  ; RVA of resources from "Image Data Dir...":
    add esi 136 | lodsd
    If eax <> 0
        add eax D$UserPeStart | mov D$UserPEStartOfResources eax
        move D$ResourcesSize D$esi
        mov B$NoResourcesPE &FALSE
    End_If
ret
____________________________________________________________________________________________

; There are 2 types of Win Menus: Menu and MenuEx. RosAsm work only with MenuEx Type.
; In case an old type is encounted we need a translation:

ForceMenusExType:  ; ExistingMenu
    mov ebx MenuList                                ; (ID / Ptr / Size)
    While D$ebx+4 <> 0
        mov esi D$ebx+4
        If W$esi = 0

            call TurnThisMenuToExType     ; First Header Word is 0 (old) / 1 (EX)

        End_If

        add ebx 12
    End_While
ret


[DisExMenuMemoryPointer: ?]

TurnThisMenuToExType:
    mov D$PopUpNumber 1

    mov ecx D$ebx+8 | mov edx ecx | shl edx 3
  ; esi > Menu Template // ecx Length of Menu Template (*8 estimation > edx).
    push ebx, esi
        VirtualAlloc DisExMenuMemoryPointer edx
    pop esi, ebx

  ; Menu Header:
    mov edi D$DisExMenuMemoryPointer
    mov W$edi 1 | add edi 2     ; Type.
    mov W$edi 4 | add edi 2     ; Displacement to next Item.
    mov D$edi 0 | add edi 4     ; Help ID.
    movzx eax W$esi+2 | add eax 4 | add esi eax

  ; Items:
  ; Split MF_Flags into MFT_Flags / MFS_Flags / MFR_Flags.
L0:
  ; Security in case of perverted Menu: Old Menus begin by W$ Flags W$ ID. So the first
  ; dWord can't be zeroed, even in case of PopUp -with no ID-:
  ;;;  On D$esi = 0, jmp L9>>
  ;;; Commented out because it troncates the Menus after the first separator...
    movzx eax W$esi
    and eax &MFT_BITMAP__&MFT_MENUBARBREAK__&MFT_MENUBREAK__&MFT_RIGHTJUSTIFY__&MFT_SEPARATOR
    stosd
    mov ax W$esi
    and eax &MFS_CHECKED__&MFS_DEFAULT__&MFS_GRAYED__&MFS_HILITE
    stosd
    mov ax W$esi
    and eax &MF_END__&MF_POPUP
    add esi 2

    mov D$edi 0
    Test eax &MF_POPUP | jz L1>
        and eax (not &MF_POPUP) | or eax 1      ; 1 = My MF_POPUP substitution.
        inc D$PopUpNumber
      ; No ID in old Menu for POPUP item:
        add edi 4 | jmp L2>

L1: movsw | add edi 2      ; ID

L2: stosw       ; My MF_END / &MF_POPUP >>> ax yet holds the MF_Flags.
    Test eax &MF_END | jz L1>
        dec D$PopUpNumber
L1:
;;
  ; Menu: Items                  //     MenuEx Items
    W$     ; Menu Item Flags            D$      ; Type >>> 0
    W$     ; ID (none for PopUp)        D$      ; State >>> 0
    US     ; 'String', 0                W$      ; ID
                                        B$      ; END / POPUP / 0
                                        B$ 0    ; Align
                                        US      ; 'String', 0
                                        Align 4
                                      ; If PopUp:
                                        D$      ; HelpID
;;
    While W$esi <> 0 | movsw | End_While | movsw | Align_On 4, edi

L1: Test eax 1 | jz L1>             ; 1 = My MF_POPUP substitution.
        mov D$edi 0 | add edi 4

L1: cmp D$PopUpNumber 0 | ja L0<<

L9: mov eax edi | sub eax D$DisExMenuMemoryPointer | mov D$ebx+8 eax
    push ebx, esi
        VirtualFree D$ebx+4
    pop esi, ebx

    move D$ebx+4 D$DisExMenuMemoryPointer
    mov ecx edi | sub ecx D$DisExMenuMemoryPointer
ret


[BasemenuId: ?]

ResetMenusIDs:
    mov ebx MenuList                                ; (ID / Ptr / Size)
    While D$ebx+4 > 0
        move D$BasemenuId D$ebx
        push ebx
            call ResetThisMenuIDs
        pop ebx
        add ebx 12
    End_While
ret


ResetThisMenuIDs:
    mov esi D$ebx+4, edx D$ebx+8 | add edx esi

;[MENUEX_TEMPLATE_HEADER:
; wVersion: W$ 0
; wOffset: W$ 0
; dwHelpId: D$ 0]

    add esi 8

;[MENUEX_TEMPLATE_ITEM:
; dwType: D$ 0
; dwState: D$ 0
; uId: D$ 0
; bResInfo: W$ 0
; szText:U1
; dwHelpId: D$ 0]

L0: add esi 8 | movzx eax W$esi+4     ; Save Pos of possible POPUP Flag
    and eax (not &MF_END)
    .If eax = 0    ; &MF_END  080 // &MF_POPUP 010   ; Menu
        If W$esi+6 <> 0     ; 0 > Separator
            inc D$BasemenuId | move D$esi D$BasemenuId
        End_If
    .End_If

L2: add esi 6
  ; Name (including 2 zeros if Separators):
    While W$esi <> 0 | add esi 2 | End_While | add esi 2 | Align_On 4, esi

    If eax <> 0
      ; Help ID:
        add esi 4
    End_If

L2: cmp esi edx | jb L0<
ret
____________________________________________________________________________________________

SetDisSourceVariables:
    mov D$SourceEnd edi
    mov D$SourceLen edi, eax D$CodeSource | sub D$SourceLen eax
    mov eax 0A0D0A0D, ecx 100 | rep stosd                            ; end security tail

    mov eax D$CodeSource
    mov D$CurrentWritingPos eax, D$CaretLine 0, D$CaretRow 1

    move D$UpperLine D$CodeSource
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

StartHllAnalyze:
    mov eax D$SourceLen | add eax 1_000_000 | VirtualAlloc SymbolicCodeSource eax

    mov esi D$CodeSource, edi D$SymbolicCodeSource
    mov eax 0A0D0A0D | stosd | stosd | add D$SymbolicCodeSource 8
ret


CloseHllAnalyze:
    Exchange D$SymbolicCodeSource D$CodeSource
    VirtualFree D$SymbolicCodeSource
    call SetDisSourceVariables
ret


; Main of HllAnalyzes.

HLLAnalyzes:
  ;;; Analyze1.
    ; call StartHllAnalyze | call Analyze1 | call CloseHllAnalyze

  ;;; Analyze2.
    ; call StartHllAnalyze | call Analyze2 | call CloseHllAnalyze
  ;;; ...
    ; ...
ret

;;
 Example of specific Analyzes to be implemented.

 In: esi > D$CodeSource // edi > D$SymbolicCodeSource.

 A couple of Routines, Macros are already implemented for Source organisations (paging?):
 NextdisLine (Macro) / NextDataDisLine (Routine) / ...
;;

Analyze1:
  ; Must first write the required Macro(s) into the Source!!!

    .While esi < D$SourceEnd
        ..If D$esi = 'call'
            If W$esi+4 = " '"
                call BuildApiCallMacro | On B$ApiMacroSuccess = &FALSE, movsb
            End_If

        ..Else
            movsb

        ..End_If

    .End_While
ret

[ApiMacroSuccess: ?]

BuildApiCallMacro:
    mov B$ApiMacroSuccess &FALSE
;;
   Good luck EveryBody :))

   Must ajust esi Pointer right after the original api call.
   Otherwise > infinite loop!!!

   Must set the 'B$ApiMacroSuccess' to &TRUE if performed!!!
;;
ret

____________________________________________________________________________________________
;;
  We read all through the PE and search for Pointers to PE Locations.
  3 Processes are done:
  * Simple Evocations >>> EVOCATED
  * Pointers to Code saying 'Push ebp | mov ebp esp' / 'Enter' >>> PUSH_EBP+EVOCATED
  * Pointer Lists >>> EVOCATED+NODE+ACCESSED
;;

[EntryPointName: "
Main:", 0]

MarkEntryPoint:
    mov eax D$DisEntryPoint | sub eax D$DisImageBase | add eax D$RoutingMap
    or B$eax NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
    sub eax D$RoutingMap | add eax D$SectionsMap | mov B$eax CODEFLAG

    ToStringsMapFrom SectionsMap, eax | mov D$eax EntryPointName
ret
____________________________________________________________________________________________

MarkEvocated:
; We are going to analyze the PE up to the last dWord (mov eax D$esi >>> error!!!). So:
    sub D$UserPeEnd 4
;;
 EVOCATED is a 'little weight' Flag, just saying that some reference has been found
 to this Location. Nothing more. It may come from hazard. NODE / LABEL are stronger
 meaning (considered definitive significant Locations).
 
 Search for any reference (evocation) to a Code, Data or Virtual Data Location all 
 along the File being disassembled. When found, we mark the Routing Map Byte pointed
 by the evocation with EVOCATED:
;;

    mov esi D$UserPeStart | add esi D$FirstSection
  ; Relative:
    .While esi < D$UserPeEnd
        mov eax esi | add eax 4 | add eax D$esi
;push eax
;    mov eax esi | sub eax D$UserPeStart | add eax D$DisImageBase
;    On eax = 0440899, int3
;pop eax
        ;sub eax D$DisImageBase | add eax D$UserPeStart

        ...If eax > D$UserPeStart
            ..If eax < D$UserPeEnd
                sub eax D$UserPeStart | add eax D$SectionsMap
                mov bl B$eax | and bl IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG
                .If bl = 0
                    sub eax D$SectionsMap | add eax D$RoutingMap
                  ; eax >>> "Pointed to" Location
                    If B$esi-1 = 0E8
                        test B$eax EVOCATED | jz L1>
                      ; 1 chance on 400,000 * (2 or more) for both case:

                      ; 2 or more CALL Instructions to the same location:
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                        mov ebx eax | sub ebx D$RoutingMap | add ebx D$SectionsMap
                        mov B$ebx CODEFLAG

                    Else_If B$esi-1 = 0E9
                        test B$eax EVOCATED | jz L1>
                      ; 2 or more JMP Instructions to the same location:
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                        mov ebx eax | sub ebx D$RoutingMap | add ebx D$SectionsMap
                        mov B$ebx CODEFLAG

L1:                     or B$eax EVOCATED

                    End_If

                .End_If
            ..End_If
        ...End_If

L5:     inc esi
    .End_While

    mov esi D$UserPeStart | add esi D$FirstSection
  ; Absolute:
    While esi < D$UserPeEnd
        mov eax D$esi | sub eax D$DisImageBase | add eax D$UserPeStart
        ..If eax > D$UserPeStart
            .If eax < D$UserPeEnd
                sub eax D$UserPeStart | add eax D$SectionsMap
                mov bl B$eax | and bl IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG
                If bl = 0
                    sub eax D$SectionsMap | add eax D$RoutingMap
                    or B$eax EVOCATED
                End_If
            .End_If
        ..End_If

L5:     inc esi
    End_While

    add D$UserPeEnd 4
ret

____________________________________________________________________________________________

MarkProcedures:
;;
 'Enter' and 'push ebp | mov ebp esp', Locations in Code, are Flaged PUSH_EBP, in
 the 'RoutingMap' Table. But, if they also are found as EVOCATED, we consider them
 valid and accessed Code Nodes:
;;
    sub D$UserPeEnd 4

    mov esi D$UserPeStart | add esi D$FirstSection

    .While esi < D$UserPeEnd
        mov eax esi | sub eax D$UserPeStart | add eax D$RoutingMap
        Test B$eax EVOCATED | jz L5>>

        mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
        Test B$eax VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+DATAFLAG | jnz L5>>

      ; 1 miss-interpretation chance on 0FFFFFF (16,777,215)
      ; * by number of "push ebp | mov ebp esp":
        ...If B$esi = 055               ; OpCode for "push ebp"  Op55
            ..If B$esi-1 <> 0F          ; No Escape Prefix wanted.
                .If W$esi+1 = 0EC8B      ; 08B 0EC >  "mov ebp esp"
L1:                 sub eax D$SectionsMap | add eax D$SectionsMap
                    If B$eax = 0
                        mov B$eax CODEFLAG
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                    Else
L2:                     sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax EVOCATED+LABEL
                    End_If

                .Else_If W$esi+1 = 0E589 ; Alternate for "mov ebp esp" op89 / op8B
                    jmp L1<
                .End_If
            ..End_If
      ; 1 miss-interpretation chance on 0FF*(0FF-32) [* (256/8) for IsItPush case]
      ; 0FF-32 = 0CD // 0CD*FF = 0CC33 // (256/8) = 020 // 0CC33*020 = 1 on 1,672,800
      ; * by number of "Enter":
        ...Else_If B$esi = 0C8          ; OpCode for 'enter'  OpC8 Op0F
            ..If B$esi-1 <> 0F          ; No Escape Prefix wanted.
                If B$esi+3 < 32         ; Nested Levels Byte is from 0 to 31.
                    sub eax D$SectionsMap | add eax D$RoutingMap
                    lea ebx D$eax+4 | call IsItPush ebx | cmp eax &FALSE | je L5>>
                        mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
                        On B$eax <> 0, jmp L2>
                            mov B$eax CODEFLAG
                            sub eax D$SectionsMap | add eax D$RoutingMap
                            or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL | jmp L5>>

L2:                     sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax EVOCATED+LABEL
                End_If
            ..End_If

       ; 1 miss-interpretation chance on 0FF * (0FF/2) * (0FF/7) = 1 on 1,165,860
         ...Else_If B$esi = 0EC
             .If B$esi-1 = 083         ; 083 0EC: OPcode for sub esp imm8
                sub eax D$SectionsMap | add eax D$RoutingMap
                lea ebx D$eax+2 | call IsItPushRegister ebx | cmp eax &FALSE | je L5>>
                    mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
                    If B$eax = 0
                        mov B$eax CODEFLAG
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                    Else
L2:                     sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax EVOCATED+LABEL
                    End_If

             .Else_If B$esi-1 = 081    ; 081 EC: OPcode for sub esp imm32
                sub eax D$SectionsMap | add eax D$RoutingMap
                lea ebx D$eax+5 | call IsItPushRegister ebx | cmp eax &FALSE | je L5>
                    mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
                    If B$eax = 0
                        mov B$eax CODEFLAG
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                    Else
L2:                     sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax EVOCATED+LABEL
                    End_If
             .End_If

        ...End_If

L5:     inc esi
    .End_While

    add D$UserPeEnd 4
ret
____________________________________________________________________________________________

UnEvocatedProcedures:
;;
 'Enter' and 'push ebp | mov ebp esp', Locations in Code, are Flaged PUSH_EBP, in
 the 'RoutingMap' Table. But, if they also are found as EVOCATED, we consider them
 valid and accessed Code Nodes:
;;
    sub D$UserPeEnd 4

    mov esi D$UserPeStart | add esi D$FirstSection

    .While esi < D$UserPeEnd
        mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
        Test B$eax VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG ;+DATAFLAG |
        jnz L5>>

      ; 1 miss-interpretation chance on 0FFFFFF (16,777,215)
      ; * by number of "push ebp | mov ebp esp":
        ...If B$esi = 055               ; OpCode for "push ebp"  Op55
            ..If B$esi-1 <> 0F          ; No Escape Prefix wanted.
                .If W$esi+1 = 0EC8B      ; 08B 0EC >  "mov ebp esp"
L1:                 push esi
                        mov eax esi | add eax 50
                        call IsItCode esi, eax, 8 ;20
                    pop esi

                    cmp eax &FALSE | je L5>

                    mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
                    If B$eax = 0
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                        sub eax D$RoutingMap | add eax D$SectionsMap | mov B$eax CODEFLAG
                    Else_If B$eax = CODEFLAG
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                    Else
                      ; Case of Map File reuse with Flag forced to Data (to follow up):
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        mov B$eax EVOCATED+LABEL
                    End_If

                .Else_If W$esi+1 = 0E589 ; Alternate for "mov ebp esp" op89 / op8B
                    jmp L1<

                .End_If
            ..End_If

        ...End_If

L5:     inc esi
    .End_While

    add D$UserPeEnd 4
ret


____________________________________________________________________________________________

; There is such a JMPs Table at Data043E188, in Teste.exe.

MarkJumpsTables:
    mov esi D$UserPeStart | add esi D$FirstSection
    mov edx D$UserPeEnd | sub edx 4
    mov ecx 0

    .While esi < edx
       ; OpFF, 'Dis_rm32_rm16', 'WriteEffectiveAddressFromModRm'
        ...If B$esi = 0FF  ; 1 on 256
            mov bl B$esi+1 | DigitMask bl to al
          ; 0FF /2 >>> CALL r/m32 // 0FF /4 >>> JMP r/m32
            ..If al = 2    ; 2 on 8
                jmp L1>
            ..Else_If al = 4
              ; Dis32 inside ? With SIB ?
              ; For JMP or CALL "D$Table+eax*4" and friends, the ModRm Byte must be:
              ; mod = 0 and r/m = 4 (SIB + dis32)
L1:             ModMask bl To al
                .If al = 0 ; 1 on 4
                    RmMask bl To al
                    If al = 4 ; 1 on 4
                        call CheckPointersTable
                        On eax = &TRUE, add esi 7
                    End_If
                .End_If
            ..End_If
        ...End_If

        inc esi

    .End_While
ret

;;
  A flow of Bytes that could be, for example, for 'call D$Table+eax*4' has been found.
  Is this 'Table' really a flow of Pointers. If true, the Instruction is valid Code,
  the target is valid Data, the data contents are valid Pointers to Code and the Code
  pointed by these Pointers are valid entry-points.
;;
CheckPointersTable:
    push esi, edx

    sub D$UserPeEnd 4 | mov eax D$esi+3
    sub eax D$DisImageBase | add eax D$UserPeStart

    ..If eax > D$UserPeStart
        .If eax < D$UserPeEnd
            mov ebx eax
            sub eax D$UserPeStart | add eax D$SectionsMap
            test B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG | jnz L5>>
          ; OK: 'Label' is a valid Pointer to a supposed Jumps Table.
          ; Now, are the two first dWords valid Pointers ?
            mov eax ebx, ebx D$eax | sub ebx D$DisImageBase | add ebx D$UserPeStart
            cmp ebx D$UserPeStart | jb L5>>
            cmp ebx D$UserPeEnd | ja L5>>

            mov ebx D$eax+4 | sub ebx D$DisImageBase | add ebx D$UserPeStart
            cmp ebx D$UserPeStart | jb L5>>
            cmp ebx D$UserPeEnd | ja L5>>

              ; OK, this is a Table of Code Pointers. Flag everything:
L0:             mov ebx D$eax | sub ebx D$DisImageBase | add ebx D$UserPeStart
                cmp ebx D$UserPeStart | jb L2>
                cmp ebx D$UserPeEnd | ja L2>
                    mov edx eax | sub edx D$UserPeStart | add edx D$SizesMap
                    or B$edx POINTER
                    sub edx D$SizesMap | add edx D$SectionsMap
                    mov D$edx FOURDATAFLAGS

                    sub ebx D$UserPeStart | add ebx D$SectionsMap
                    mov B$ebx CODEFLAG
                    sub ebx D$SectionsMap | add ebx D$RoutingMap
                    mov B$ebx PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL

                add eax 4 | jmp L0<
        .End_If
    ..End_If

L2: pop edx, esi | add D$UserPeEnd 4 | mov eax &TRUE | ret

L5: pop edx, esi | add D$UserPeEnd 4 | mov eax &FALSE | ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  Analyzes of the Code Conditional Jumps
;;

[JumpsMap: ? EndOfJumpsMap: ?]

ConditionalJumpsAnalyzes:
  ; Create a Table, where to flag the possible Addresses pointed to, by Conditional Jumps:
    mov eax D$EndOfSectionsMap | sub eax D$SectionsMap
    mov D$EndOfJumpsMap eax
    VirtualAlloc JumpsMap eax
    add D$EndOfJumpsMap eax

    mov esi D$UserPeStart | add esi D$FirstSection
    mov ebx D$SectionsMap | add ebx D$FirstSection
    mov edx D$JumpsMap | add edx D$FirstSection
    mov eax 0

    .While esi < D$UserPeEnd
        ...If B$ebx = 0
            ..If B$esi <> 0
                call IsConditionalShortJump esi

                .If eax = &TRUE
L1:                 inc esi, ebx, edx | movsx eax B$esi | inc esi, ebx, edx
                    add eax edx
                    push esi, eax, ebx, edx
                        sub eax D$JumpsMap | add eax D$UserPeStart
                        mov ebx eax | add ebx 50
                        call IsItCode eax, ebx, 0
                        If eax = &TRUE
                            pop edx, ebx, eax, esi
                            inc B$eax
                        Else
                            pop edx, ebx, eax, esi
                        End_If
                .Else
                     call IsLoop esi
                     On eax = &TRUE, jmp L1<
                .End_If
            ..End_If
        ...End_If

        inc esi, ebx, edx
    .End_While
;;
  16 Chance on 256 (1 on 16) for a given Byte to be a Jcc.
  
  This is to say, that in a Flow of Random Bytes, one given Byte has 1 chance on
  16 to be the target of a possible Jcc. [In fact, less than that, because the
  cases of "070", ... , "07F", are way less frequent than, say "0", in a real PE]
  
  So, randomaly, there would 1 chance on 256, for a given Byte, for being the target
  of 2 JCCs, if these Jcc would not be limited to a 256 Bytes scope.
  
  Plus 3 chances on 256*2 to be a loop.
  
  Then, with the IsItCode Identification, this is considered reliable.
  
  We now cross all of this with the previously done analyzes of 'MarkEvocated',
  that flaged any Absolute or Relative Evocation of a Location.
;;
    mov esi D$RoutingMap, edi D$JumpsMap, edx D$EndOfRoutingMap

    While esi < edx
        Test B$esi EVOCATED | jz L2>
            On B$edi <> 0, inc B$edi
L2:     inc esi, edi
    End_While


    mov esi D$JumpsMap | add esi D$FirstSection
    mov edi D$SectionsMap | add edi D$FirstSection
    mov ebx D$RoutingMap | add ebx D$FirstSection
    mov edx D$EndOfSectionsMap

    While edi < edx
        If B$esi > 3
            On B$edi = 0, mov B$edi CODEFLAG
            On B$edi = CODEFLAG, mov B$ebx INSTRUCTION+EVOCATED+LABEL+ACCESSED+PUSH_EBP
            inc ecx
        End_If
        inc esi, edi, ebx
    End_While
;map
    VirtualFree D$JumpsMap
ret


[BadCode: ?    GoodCode: ?]

;[LongJmpsOp: 0E8    ; Long call 'OpE8'
;             0E9]   ; Long jmp    'OpE9'
;           ; 0EB    ; jmp short 'OpEB'
;;'loop' ; E0, E1, E2     OpE3 >>> jecxz
;[ShortJccOp:
;    070, 071, 072, 073, 074, 075, 076, 077, 078, 079, 07A, 07B, 07C, 07D, 07E, 07F, 0E3]
;; 0F Prefix >>> Long
;[LongJccOp:
;    080 > 08F    Op80 Op8F

;[DisCodePointer: ?]

Proc IsConditionalShortJump:    ; 21 random chances on 256
    Argument @Pointer
    Uses esi, edi, ebx

        mov esi D@Pointer, al B$esi, ebx &FALSE
;;
  Op78, Op79, Op7A, Op7B, Op7C, Op7D
  
  If these next ones have a 0F Escape Prefix, they are other Mnemonics:
  
  Op70, Op71, Op72, Op73, Op74, Op75, Op76, Op77, (....above.....)  Op7E, Op7F
  
  OpE3 is JECXZ
;;
        ...If al >= 070
            ..If al <= 07D
              ; This is can be a Conditional Short Jump
                mov ebx &TRUE
              ; No Escape Prefix for some:
                If al <= 077
                    On B$esi-1 = 0F, mov ebx &FALSE
                Else_If al >= 07E
                    On B$esi-1 = 0F, mov ebx &FALSE
                End_If

              ; A bit less than 16 chances on 256, randomaly.

            ..Else_If al = 0E3
              ; OpE3 is JECXZ // DEC ecx: 049 // sub ecx 5: 083 0E9 05
                If B$esi-1 = 049
                    mov ebx &TRUE
                Else_If W$esi-3 = 0E983
                    mov ebx &TRUE
                Else
                    mov ebx &FALSE
                End_If

              ; Max: (1 chance on 256) * (1 chance on 256) = 1 on 65,536
            ..End_If
        ...End_If

        If ebx = &TRUE
          ; It cannot be a jump to 0, -1, -2, -3, -4
            mov al B$esi+1 | neg al
            On al < 5, mov ebx &FALSE
        End_If

        mov eax ebx
EndP


Proc IsLoop:     ; 18 random chances on 256 / by the 1 on 256 of the 0F Jcc prefix.
    Argument @Pointer
    Uses esi

        mov esi D@Pointer, eax D$UserPeEnd | dec eax | On esi <= eax, jmp L2>

        mov al B$esi

      ; Must be negative:
        Test B$esi+1 080 | jz L2>

        .If al = 0E0
            mov eax &TRUE
        .Else_If al = 0E1
            mov eax &TRUE
        .Else_If al = 0E2
            mov eax &TRUE
        .Else
L2:         mov eax &FALSE
        .End_If

  ; 3 chances on 256*2 to be a loop
EndP
____________________________________________________________________________________________

Proc IsItPush:
    Argument @Location
    uses esi
      ; 8 chances on 256
        mov esi D@Location
        sub esi D$RoutingMap | add esi D$UserPeStart | mov al B$esi

        If al = 060
            mov eax &TRUE       ; pushad
        Else_If al < 050
            mov eax &FALSE
        Else_If al < 058
            mov eax &TRUE       ; push reg (050 to 057)
        Else
            mov eax &FALSE
        End_If
EndP

Proc IsItPushRegister:
    Argument @Location
    uses esi
      ; 7 chances on 256
        mov esi D@Location
        sub esi D$RoutingMap | add esi D$UserPeStart | mov al B$esi

        If al < 050
            mov eax &FALSE
        Else_If al < 058
            mov eax &TRUE       ; push reg (050 to 057)
        Else
            mov eax &FALSE
        End_If
EndP
____________________________________________________________________________________________

; Force the small (smaller than 4) zeroed Bytes inside a Code/Data Section (SectionsMap)
; to CODEFLAG/DATAFLAAG:

SmallBlanksToSameFlag:
    mov esi D$SectionsMap | add esi D$FirstSection
    mov edx D$EndOfSectionsMap | sub edx 4

    While esi < edx
        .If B$esi = 0
            mov edi esi, bl B$esi-1, ecx 0
            lodsb
            lodsb | inc ecx | cmp al bl | je L1>
                              cmp al 0 | ja L1>
            lodsb | inc ecx | cmp al bl | je L1>
                              cmp al 0 | ja L1>
            lodsb | inc ecx | cmp al bl | jne L2>
L1:         If al = bl
                rep stosb | dec esi
            End_If
        .End_If

L2:     inc esi
    End_While
ret
____________________________________________________________________________________________

;;
  Search for Chunks with non zeroed Bytes in UserPeStart and zeroed Flags in SectionsMap.
  Check if this is Code or not.
;;
[PreviousFlag: ?    NextFlag: ?    NewCodeChunkFound: ?]


____________________________________________________________________________________________

[SymCallApi: "call '", 0    SymTrue: "&TRUE", 0]

;;
 This the Main of the Symbolic Analyze. We search for all occurences of "call '...."
 with 'DisSearch'. If found, we call for 'ApiAnalyze', in order to seek for the called
 Function in our internal List. If found again, instead of zero, the 'DisApiSymbolsTable'
 holds Pointer(s) to the Api Parameter(s) Name(s). Example, for:

>KERNEL32._hwrite(
> HFILE hFile, ; handle to file
> LPCSTR lpBuffer, ; write data buffer
> long lBytes ; number of bytes to write
>)

 'DisApiSymbolsTable' will hold 3 dWords pointing to:
 'hFile', 'lpBuffer', 'lBytes'.

 Instead of overwriting the Source all along the Ananyles (what would take no end time),
 'MarkDisSymbols' simply overwrite 'Dataxxxxxx' with a 1 Flag first (1ataxxxxxx) and
 store the Pointer to the found Parameter name after this Ascii 1 Char.

 Only when the whole File parsing is done, 'ReWriteTheSymbolicSource' does the real
 replacement writing job at once, searching for all "1", loading the Pointer to Symbolic
 Name and writing it.
;;

SymbolicAnalyzes:
    mov esi SymCallApi, edi D$EndOfDisData | call FirstDisSearch

    While edi < D$SourceEnd
        push edi
            call ApiAnalyze
        pop edi

        On D$DisApiSymbolsTable <> 0, call MarkDisSymbols

        mov esi SymCallApi | call NextDisSearch

      ; Progress Bar:
        If edi > D$NextDisBarPos
            push edi
                mov eax edi | add eax D$DisBarStep | mov D$NextDisBarPos eax
                call BarProgress
            pop edi
        End_If
    End_While

    call ReWriteTheSymbolicSource
ret


; Searches esi zero ended String along edi (no reuse of available Search RosAsm features
; because here, the search is much simpler (perfectely ensured size, Case,... > faster):

[DisSearchLength: ?]

FirstDisSearch:
    mov ecx 0
    push esi
        While B$esi <> 0
            inc ecx | inc esi
        End_While
    pop esi
    sub ecx 4 | mov D$DisSearchLength ecx

NextDisSearch:
    mov eax D$esi | add esi 4

L1: While edi < D$SourceEnd
        cmp D$edi eax | je L2>
            inc edi
    End_While
    ret

L2: push esi, edi
        add edi 4 | mov ecx D$DisSearchLength | repe cmpsb | jne L3>

    pop eax, eax               ; Found: edi at end of searhced String.
    ret

L3: pop edi, esi
    inc edi | jmp L1<
ret


[ApiCallCopy: ? #40]

; Searching for the encounted Api call inside SpÂsm 'Win32ApiList'.
; When in: edi is pointing to the First Char of DLL Name in an api:
; call 'DLLNAME.FunctionNAME'
; ------^

ApiAnalyze:
  ; First Make a zero ended copy:
    mov esi edi, edi ApiCallCopy

    While B$esi <> "'"
        movsb
    End_While
    movsb | mov al 0 | stosb

L0: mov D$DisApiSymbolsTable 0

    mov edi D$Win32ApiList

L0: mov esi ApiCallCopy, eax D$esi | cmp eax D$edi | jne L1>

        mov ecx 80 | repe cmpsb
        On B$esi-1 = 'A', inc esi
        On B$esi-1 = 'W', inc esi
        cmp B$edi-1 '(' | jne L1>
        cmp B$esi-1 "'" | jne L1>

          ; >>> Found:

          ; Writes a 'Done Byte' in the List for searching once only per Function.
          ; (We reload the 'Functions.api' File at each Api Analyze).
            mov B$edi-1 0FF

            call RegisterApiParametersPointers | ret

L1: While B$edi <> ')'
        inc edi
    End_While
    add edi 3 | cmp B$edi 0 | jne L0<
ret


; Fitting Api Function found in 'Win32ApiList' by 'ApiAnalyze'. edi-1 is at the '('.

[DisApiSymbolsTable: ? #20]

; A fitting Api has been found inside 'Win32ApiList'. We now store in 'DisApiSymbolsTable',
; as many Pointer to the Api Parameters Names, as discribed in the 'SymbolicAnalyzes' top
; comment:

RegisterApiParametersPointers:
    mov esi edi, edi DisApiSymbolsTable
    If D$esi = 'VOID'
        mov D$edi 0 | ret
    End_If
    add esi 2

L0: add esi 2
    While B$esi > ' '
        inc esi
        If B$esi = ')'
            mov D$edi 0 | ret
        End_If
    End_While
    inc esi

  ; This happends with unknown optional parameters (like for: wnsprintf, in 'Win32ApiList'):
    If B$esi = ';'
        mov D$edi 0 | ret
    End_If

    mov D$edi esi | add edi 4       ; <<<< Write the Pointer in 'DisApiSymbolsTable'.

    While B$esi > LF | inc esi | End_While
    While B$esi <= ' ' | inc esi | End_While
    cmp B$esi ')' | jne L0<
    mov D$edi 0
ret


[OneDisLineUp | While B$edi <> LF | dec edi | End_While
                While B$edi < ' ' | dec edi | End_While
                While B$edi <> LF | dec edi | End_While | inc edi
                While B$edi = ' ' | inc edi | End_While]

;;
 Here, we are at an Api call, and Valid Parameters Names have been found in 'Win32ApiList'.
 We step back line after line and search for possible, for example, "push D$Data0403024'.
 At eaxh Parameter push found, we call for 'DisMarkAll' to mark all of this Label
 evocations with the 1 Flag and with the Symbol Name Pointer:
;;

MarkDisSymbols:
    push edi
        mov ebx DisApiSymbolsTable

L0:     OneDisLineUp | cmp D$edi 'push' | jne L9>

            add edi 5 | On W$edi = 'D$', add edi 2

            move D$PointerToApiList D$ebx

            .If D$edi = 'Code'
                call DisMarkAll
            .Else_If D$edi = 'Data'
                call DisMarkAll
            .End_If

            sub edi 5 | add ebx 4 | cmp D$ebx 0 | ja L0<
L9: pop edi
ret


[LengthOfDisReplaceString: ?    PointerToApiList: ?]
;;
 Mark all the occurences of the found Api Parameter with Ascii 1 + dWord Pointer to
 to Parameter Name inside 'Win32ApiList':
;;
DisMarkAll:
    pushad
    push D$DisSearchLength
        mov esi edi, edi SearchString, ecx 11
        rep movsb | mov B$edi 0

        mov edi D$CodeSource, D$DisSearchLength 7
      ; 11-4 (as we know the length, we don't need to call for 'FirstDisSearch' at all).

L0:     mov esi SearchString | call NextDisSearch
        While edi < D$SourceEnd

            sub edi 11 |  mov al 1 | stosb
            mov eax D$PointerToApiList | stosd
          ; 'Data0404204' is now replaced by:
          ; 'xYYYY404204', where x is the Byte value 1, YYYY the Pointer to the Parameter
          ; found inside RosAsm 'Win32ApiList'.

            mov esi SearchString | call NextDisSearch
        End_While

L9:     mov B$OnReplaceAll &FALSE
    pop D$DisSearchLength
    popad
ret


[SymbolicCodeSource: ?]

; General rewrite of all the Source with the real symbolic Names at each Flag 1 + dWord
; Pointer, instead:

ReWriteTheSymbolicSource:
    mov ecx D$EndOfSourceMemory | sub ecx D$CodeSource

    VirtualAlloc SymbolicCodeSource ecx
    mov D$eax CRLF2, D$eax+4 CRLF2

    add D$SymbolicCodeSource 8

    mov esi D$CodeSource, edi D$SymbolicCodeSource

    mov D$StartOfDisLine edi, D$AlignedComment edi | add D$AlignedComment 38

    .While esi < D$SourceEnd
        lodsb
        .If al = 1
            lodsd
            push esi
                mov esi eax
                While B$esi > ' ' | movsb | End_While
                On B$edi-1 = ',', dec edi

                mov W$edi '_0' | add edi 2
            pop esi

        .Else_If al = ':'
            stosb

        .Else
            stosb
            If al = LF
                mov D$StartOfDisLine edi, D$AlignedComment edi | add D$AlignedComment 38
            Else_If al = ';'
                dec edi | On D$edi-3 <> '   ;', jmp L2>
                While edi > D$AlignedComment
                    On B$edi-2 <> ' ', jmp L2>
                    dec edi
                End_While
L2:             mov B$edi ';' | inc edi
            End_If

        .End_If
    .End_While

L9:
;;
  There is some Variable somewhere, that i am unable to point out, and that produces
  a hang, if i 'Exchange' the usual way, and restore all the wished Variables. So, i
  do it the very stupid way: Copying:
;;
    mov ecx edi | sub ecx D$SymbolicCodeSource
    mov esi D$SymbolicCodeSource, edi D$CodeSource

    rep movsb

    mov D$SourceEnd edi | sub edi D$CodeSource | mov D$SourceLen edi

    push edi
        VirtualFree D$SymbolicCodeSource
    pop edi
ret

____________________________________________________________________________________________
;;
  Some PEs may have a wrong Paragraphs Number, in the MZ header. Fix It now to the
  correct values, because the Routines called for loading the various Resources
  make use of those values to point, through the various PE Headers, to the Resources
  Tree.
  
  We also get a Pointer to the Pe Tag (a Pointer to 'PE', in the PE header, as you
  can see, for example, at 'PeHeader'.
  
  A DOS 'Paragraph' is 16 Bytes. See Records at 'DosHeader':
  
  * At DosHeader+8 > Size of the Dos header in Paragraph units.
  
;;

[DisPeTagPointer: ?]

FixMzParagraphsNumber:
    mov D$DisPeTagPointer 0

  ; Standard manner: parag. size of dos header end > PE header address:
    mov esi D$UserPeStart | movzx eax W$esi+8 | shl eax 4 | sub eax 4
    If eax < D$UserPeLen
        add esi D$esi+eax
    Else
        mov eax 0
    End_If

    ..If eax <> 0
        mov edx D$UserPeStart | add edx D$UserPeLen | sub edx 4
        .If esi < edx
            If D$esi = 'PE'
                mov D$DisPeTagPointer esi | ret ; (No fix needed, in that case)
            End_If
        .End_If
    ..End_If

  ; Fix needed for these two other methods:
    call GetPeTagMethod2
    If esi < edx
        On D$esi = 'PE', jmp L1>
    End_If

    call GetPeTagMethod3 | On D$esi <> 'PE', jmp DisFail

L1: mov D$DisPeTagPointer esi

  ; Now, esi point to the PE Tag. Fix the MZ Paragraph Number for 'SearchPEstartOfResource':
    mov ecx esi | sub ecx D$UserPeStart

  ; Overwrite the Dos header according Displacement ('2' is for a minimum Dos Header):
    mov edi D$UserPeStart | mov W$edi+8 2, D$edi+(16+12) ecx

;  ; Test: Make sure it is now good for the default internal method:
;    mov esi D$UserPeStart | movzx eax W$esi+8 | shl eax 4 | sub eax 4 | add esi D$esi+eax
;    On D$esi <> 'PE', jmp DisFail

; With such an error, the Debugger fails, when compiling RosAsm with RosAsm...
; mov esi 0 | On D$esi <> 'PE', jmp DisFail
ret


GetPeTagMethod2:
  ; Method 2 for searching the PE Tag:
  ; If Origin >= 040 > PE header adress at 03C
    mov eax D$UserPeStart | add eax 018
    If W$eax >= 040
        sub eax 018 | add eax 03C | movzx esi W$eax | add esi D$UserPeStart
    End_If
ret

GetPeTagMethod3:
  ; Method 3. Stupid desesparated search:
    mov esi D$UserPeStart, ecx 0200
L0: inc esi | On D$esi <> 'PE', loop L0<
ret
____________________________________________________________________________________________

[DisNumberOfSections: ?
 DisDataMin: ?   DisDataMax: ?
 DisVirtualMin: ?   DisVirtualMax: ?
 DisCodeMin: ?   DisCodeMax: ?
 DisApiMin:  ?   DisApiMax:  ?
 LastCodeRef: ?    DisImageBase: ?    DisEntryPoint: ?    DisPeOrigine: ?
 DisRvaSectionAlignment: ?    DisFileSectionAlignment: ?
 DisBaseOfRsrc: ?]

[Disassembling: ?    ThisSourceIsDisassembled: ?]


; Used to switch from a RosAsm Data Label (for example, 'AppBaseOfCode') to the target
; File corresponding location:

[GetPeHeader | mov eax #1 | sub eax DosHeader | add eax D$DisPeOrigine
 add eax D$UserPeStart]

;;
  Here, we store several Data we need along Disassembling:
  The equivalents, in the UserPE of the Displacements found in our internal Stub;
  'PeHeader', 'SubSystem', 'NumberOfSections', 'ImageBase', Sections Alignment,
  EntryPoint ('AppRVAentryPoint').
;;

StartNewDisFile:
    mov D$DisPeOrigine 0 | GetPeHeader PeHeaderPointer

    mov eax D$eax | sub eax 080 | mov D$DisPeOrigine eax
  ; (080 is the RosAsm Data 'PeHeaderPointer')

    GetPeHeader PeHeader | mov eax D$eax | On eax <> D$PeHeader, jmp DisFail
  ; Pe Header found.

  ; Like in 'ReadHeaderFormat'.
  ; Copy / SubSystem / DllCharacteristics / AppStackMax / .... :
    GetPeHeader SubSystem | mov esi eax, edi SubSystem, ecx 5 | rep movsd

    GetPeHeader NumberOfSections | movzx eax W$eax | On eax = 0, jmp DisFail
    mov D$DisNumberOfSections eax

    GetPeHeader ImageBase | mov ebx D$eax, D$DisImageBase ebx, D$LinkerDllDefault ebx

    move D$DisRvaSectionAlignment D$eax+4, D$DisFileSectionAlignment D$eax+8

    GetPeHeader AppRVAentryPoint | mov eax D$eax | add eax D$DisImageBase
    mov D$DisEntryPoint eax
ret

____________________________________________________________________________________________

[TempoUserPeStart: ?    DisFlagsImage: ?    DisFlagsImageEnd: ?    DisRelocPointer: ?]

[FirstSection: ?    EndOfLastSection: ?]

;;
  Targetted File Mapping. Usually:

  The PE File alignment is on 0200 Bytes / Memory Image alignement is on 01000.
  In other words: On disk the Section are aligned on 0200h Boundaries // In
  Memory, the runing PE Sections are aligned on 01000h Boudaries, by the OS
  Launcher.
  
  The analyzes are made a bit easier by realigning the Sections the same way
  they are when runing in Memory.
;;

ReAlignPE:
    mov eax D$UserPeStart | sub D$UserPEStartOfResources eax ; Gona switch...

    mov ecx D$DisNumberOfSections, D$FirstSection 0-1, D$EndOfLastSection 0
    GetPeHeader SectionsHeaders

  ; Search for the First Section RVA:
L0: mov ebx D$eax+SECTION_RVA
    On ebx < D$FirstSection, mov D$FirstSection ebx
  ; Search for the last Section RVA and adds its RVA Size:
    push ecx
        mov ecx D$eax+SECTION_RVASIZE
      ; Some compiler (Watcom-C) may set the RVA to zero. So... :
        If ecx < D$eax+SECTION_FILESIZE
            mov ecx D$eax+SECTION_FILESIZE
            Align_On_Variable D$DisRvaSectionAlignment ecx
          ; Fix it (just in case this would be needed later...):
            mov D$eax+SECTION_RVASIZE ecx
        End_If

        On ebx > D$EndOfLastSection, mov D$EndOfLastSection ebx, edx ecx
    pop ecx
    add eax SECTIONHEADERSIZE | loop L0<

    add edx ebx | Align_On_Variable D$DisRvaSectionAlignment edx | mov D$UserPeLen edx

    VirtualAlloc TempoUserPeStart edx ;D$UserPeLen

    mov esi D$UserPeStart, edi D$TempoUserPeStart

  ; Copy the PE headers down to (including) 'SectionsHeaders':
    GetPeHeader SectionsHeaders
    mov ecx eax | sub ecx D$UserPeStart | rep movsb

    mov ecx D$DisNumberOfSections

L0: push ecx
        mov ecx SECTIONHEADERSIZE | rep movsb
    pop ecx
    loop L0<

  ; Want to skip 'RelocSectionTable', if any:
    GetPeHeader RelocSectionTable | move D$DisRelocPointer D$eax
  ; Copy all Sections with Memory alignment:
    GetPeHeader SectionsHeaders | mov edx D$DisNumberOfSections

    While D$eax+SECTION_RVA <> 0
        mov esi D$eax+SECTION_FILEPOINTER | add esi D$UserPeStart
        mov edi D$eax+SECTION_RVA | On edi = D$DisRelocPointer, jmp L1>
        add edi D$TempoUserPeStart
        mov ecx D$eax+SECTION_FILESIZE | Align_On 4 ecx | shr ecx 2 | rep movsd
L1:     add eax SECTIONHEADERSIZE | dec edx | jz L2>
    End_While

L2: Exchange D$UserPeStart D$TempoUserPeStart
    mov eax D$UserPeStart | add eax D$UserPeLen | mov D$UserPeEnd eax
    VirtualFree D$TempoUserPeStart
ret

____________________________________________________________________________________________
;;
  Allocations of 'SectionsMap', 'RoutingMap', 'SizesMap' (more comments ther) Tables
  (All same length as the mapped File):
;;

AllocateDisTables:
    VirtualAlloc SectionsMap D$UserPeLen,
                 RoutingMap D$UserPeLen,
                 SizesMap D$UserPeLen
    mov eax D$SectionsMap | add eax D$UserPeLen | mov D$EndOfSectionsMap eax
    mov eax D$RoutingMap | add eax D$UserPeLen | mov D$EndOfRoutingMap eax
    mov eax D$SizesMap | add eax D$UserPeLen | mov D$EndOfSizesMap eax

    If D$StringsMap = 0
        mov eax D$UserPeLen | shl eax 2
        push eax
            VirtualAlloc StringsMap eax
            move D$EndOfStringsMap D$StringsMap
        pop ecx
        add D$EndOfStringsMap ecx
    End_If

  ; And widely evaluated disassembly Source:
    mov ecx D$UserPeLen | shl ecx 4 | add ecx 10_000_000
    push ecx
        VirtualAlloc CodeSource ecx
        mov D$eax CRLF2, D$eax+4 CRLF2 | add D$CodeSource 8
    pop ecx
    add ecx D$CodeSource | mov D$EndOfSourceMemory ecx

  ; restore the true length (without the security tail):
    sub D$UserPeLen 01000

    mov edi D$CodeSource, eax CRLF2, ecx 100 | rep stosd

    mov eax D$UserPeStart | add D$UserPEStartOfResources eax  ; Switch done...
ret

HLL_Strings_Table_notes:

;;
  * Create one another paralel Table: 'SymbolsMap'
  
  * Symbol wanted at 'SomeRoom': Set the 'STRINGS' Flag.
  
  * Store the String, zero-ended, in a StringsTable.
  
  * Store the Pointer to the zero-ended String in a 'StringsPointersTable':
    Record: [... / SomeRoom, StringPointer / ...]
  
  'STRINGS' Flag encouted in 'SymbolsMap'
  >>> Search for the 'SomeRoom' Displacement, in the 'StringsPointersTable'
  >>> take the 'StringPointer'.
  
  Length? Why not using directly the String origine? Example the "Functions.api"
  File. Just a Pointer to the Name (>= ' ' ending).
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[DisImportPtr: ?    DisImportSize: ?]

;;
 Import Section looks like this:

[DirectoryTable:
 LookUpRVA: D$ 03050 TimeDate: 0 ForwarderChain: 0 NameRVA: 03136 AdressRVA: 030A8
 LookUpRVA: D$ 03060 TimeDate: 0 ForwarderChain: 0 NameRVA: 03164 AdressRVA: 030B8
 ...
 LookUp1: (03050:)
;;

[DisDllName: ?   StartOfDisImport: ?    EndOfDisImport: ?   FirstDisImportName: ?
 PointerToDisImportDirectory: ?    PointerToDisImportAddressTable: ?
 DisImportRVA: ?    DisImportFilePointer: ?    LastPointerInOurApiTable: ?
 DllMin: ?    DllMax: ?]

[DisNumberOfFunctions: ?    ApiBuffer: ?    EndOfApiBuffer: ?]

CheckImport:
    GetPeHeader AppImportSize | mov eax D$eax | On eax = 0, ret ;jmp DisFail

  ; !!! 'AppImportSize' is _NOT_ the size of Import, but the one of the Import
  ; Header only !!! We can't use it for defining the 'ApiBuffer' size !!!
  ; Done at the end, based on the number of found Functions.

    GetPeHeader AppBaseOfImport | mov edx D$eax | On edx = 0, jmp DisFail

    add edx D$UserPeStart
;;
  The Import Directory is a flow of blocks of 5 dWords (+ zero ended with 5 dWords):
  
  Import LookUp Table RVA
  Time and Date Stamp
  Forwarder Chain
  Name RVA                    ; <<<<<  MODULE.dll
  Import Addresses Table RVA  ; <<<<<  Function
  
  Import Addresses Table RVA is flow of dWords Pointer to Functions Names for each DLL.
  (Zero ending dWord).
  
  We first fill all the SectionsMap part of this Tree-like Structure with IMPORTFLAG:

  If either 'Import LookUp Table RVA' or 'Import Addresses Table RVA' are zeroed,
  we fill the one by the other, in order to save from no end Checking:
;;
    mov eax edx

    While D$eax+(4*3) <> 0          ; At least 'Name RVA' should be there ;)
        If D$eax = 0
            move D$eax D$eax+(4*4)
        Else_If D$eax+(4*4) = 0
            move D$eax+(4*4) D$eax
        End_If
        add eax (5*4)
    End_While

    push edx
        mov eax IMPORTFLAG+(IMPORTFLAG shl 8)+(IMPORTFLAG shl 16)+(IMPORTFLAG shl 24)

        mov edi edx | sub edi D$UserPeStart | add edi D$SectionsMap

        ..While D$edx <> 0
          ; Flag the Directory (dWords):
            mov edi edx, ecx 5
            sub edi D$UserPeStart | add edi D$SectionsMap | rep stosd
          ; Flag the LookUp Table (dWords):
            mov edi D$edx, ebx edi | add edi D$SectionsMap | add ebx D$UserPeStart
            While D$ebx <> 0
                ;call FlagImportCalls ebx
                stosd | add ebx 4
            End_While | stosd
          ; Flag the DLL Name (Bytes):
            mov edi D$edx+(3*4), ebx edi | add edi D$SectionsMap | add ebx D$UserPeStart
            While B$ebx <> 0 | stosb | inc ebx | End_While | stosb
          ; Flag the Address Table (dWords):
            mov edi D$edx+(4*4), ebx edi | add edi D$SectionsMap | add ebx D$UserPeStart
            While D$ebx <> 0
               ; call FlagImportCalls ebx
                stosd | add ebx 4
            End_While | stosd
          ; The Import Address Table may be either empty or filled up with any value.
          ; we first recopy the LoockUp Table upon it:
            push esi, edi
                mov esi D$edx, edi D$edx+(4*4)
                add esi D$UserPeStart | add edi D$UserPeStart
                While D$esi <> 0 | movsd | End_While
            pop edi, esi
          ; Flag the Functions String (Bytes, pointed by LookUp // Address Tables):
            mov ebx D$edx | add ebx D$UserPeStart
            .While D$ebx <> 0
                push ebx
                    mov ebx D$ebx, edi ebx, ecx ebx | and ecx 0_8000_0000
                    If ecx = 0_8000_0000 ; By Number

                    Else                 ; By Name
                        add ebx D$UserPeStart | add edi D$SectionsMap
                        stosw | add ebx 2
                        While B$ebx <> 0 | stosb | inc ebx | End_While | stosb
                    End_If
                pop ebx
                add ebx 4
            .End_While

            add edx (5*4)
        ..End_While
      ; Flag the Directory zero ending (5 dWords, too):
        mov edi edx, ecx 5
        sub edi D$UserPeStart | add edi D$SectionsMap | rep stosd
    pop edx
;;
  We fill the relative Flags image with the Pointers to DLL Names (instead of a Flag),
  at each Function Name Address, so that, when the Flag Image will hold a Pointer,
  instead of a Flag, this will be the Pointer to the DLL Name, and the Pointer to the
  Function Name will appear in the relative Pos in UserPeStart:
;;
    push edx
      ; (edx keeps track of the .import Base)
        .While D$edx <> 0
            mov eax D$edx+12 | add eax D$UserPeStart    ; Pointer to DLL Name
            On D$eax = 'MSVB', mov D$CompiledBy 'MSVB'
            mov ebx D$edx+16 | add ebx D$UserPeStart    ; Pointer to Functions Names List.
            mov edi D$RoutingMap | add edi D$edx+16
        ; Write the Pointer to DLL Name upon all 'RoutingMap' Pointers to Functions Names:
            While D$ebx <> 0
                stosd | add ebx 4
            End_While

            mov ebx D$edx+16 | add ebx D$UserPeStart
            mov edi D$SectionsMap | add edi D$edx+16
            mov eax IMPORTFLAG
        ; Write again IMPORTFLAG upon all 'SectionsMap' Pointers to Functions Names:
            While D$ebx <> 0
                stosb | inc ebx
            End_While

            add edx 20
        .End_While

    pop edx
;;
  Once done, when we encount a Pointer, and see 'IMPORTFLAG' in the relative 'SectionsMap'
  dWord / >>> We have the DLL Name Pointer in the relative 'RoutingMap' dWord and the
  the Pointer to the Function Name in the relative 'UserPeStart' dWord.
  
  Now, we make a Copy of 'DllName.FunctionName' into 'ApiBuffer', and replace all
  Address Table and LookUp Table dWords by Pointers to these new Strings:
  
  Search the Number of Functions, first, in order to guess what size for 'ApiBuffer'.
;;
    push esi, edx

        mov D$DisNumberOfFunctions 0

      ; Pointer to Functions Names Address Table in edx:
L0:     mov esi D$edx+(4*4) | add esi D$UserPeStart
        While D$esi <> 0
            add esi 4 | inc D$DisNumberOfFunctions
        End_While

        add edx 20 | cmp D$edx 0 | jne L0<<

    pop edx, esi

  ; Large estimation: 128 Chars per Function:
    mov eax D$DisNumberOfFunctions | shl eax 7
    pushad
        push eax
            VirtualAlloc ApiBuffer eax
        pop ecx
        add ecx eax | mov D$EndOfApiBuffer ecx
    popad

  ; Now, fill the ApiBuffer:
    mov edi D$ApiBuffer

L0: mov ebx D$edx+(3*4) | add ebx D$UserPeStart    ; Pointer to DLL Name.
    mov esi D$edx+(4*4) | add esi D$UserPeStart    ; Pointer to Functions Names Address Table.

    While D$esi <> 0
        mov ecx edi

        mov B$edi "'" | inc edi
        push ebx
L1:         mov al B$ebx | stosb | inc ebx | cmp al 0 | jne L1<   ; 'DllName.
        pop ebx
        mov eax D$edi-5 | or eax 020202020
        If eax = '.dll'
            sub edi 4
        Else
            mov B$edi-1 "."
        End_If

        lodsd | test eax 08000_0000 | jz L1>
            xor eax 08000_0000 | push ebx | call WriteEax | pop ebx | jmp L2>

L1:     push ebx
            mov ebx eax | add ebx D$UserPeStart | add ebx 2
L1:         mov al B$ebx | stosb | inc ebx | cmp al 0 | jne L1<   ; ....FunctionName'
            dec edi
        pop ebx

L2:     mov B$edi "'" | inc edi | mov B$edi 0 | inc edi

      ; Overwrite Address Table and LookUp Table dWords by Pointers to 'ApiBuffer':
        mov D$esi-4 ecx
        mov eax esi | sub eax D$edx+(4*4) | add eax D$edx | mov D$eax-4 ecx
    End_While

    add edx 20 | cmp D$edx 0 | jne L0<<

  ; ... and clear the temporary used 'RoutingMap'
    mov edi D$RoutingMap, ecx D$EndOfRoutingMap, eax 0
    sub ecx edi | shr ecx 2 | rep stosd

    call KillBlankBytes AppImportSize, IMPORTFLAG
ret

____________________________________________________________________________________________

[ResourcesTypesNumber: ?    DisResourcesOrigine: ?]

; Resources have be loaded by LoadDisResources. We now simply Flag the Resources Section.
; (Only the real Resources -not the whole Section that main contain anything else-).

CheckResources:
    GetPeHeader AppBaseOfRsrc | On D$eax = 0, ret

    mov eax D$eax | add eax D$UserPeStart | mov D$DisResourcesOrigine eax

    call FlagResourceTree eax

    call KillBlankBytes AppBaseOfRsrc, RESOURCESFLAG
ret

;;
  'FlagResourceTree' is a good example of Procedure calling itself, for moving along
  all branches of a tree.
;;

Proc OldFlagResourceTree: ; 'ResourcesStub' For infos. 'NewFlagResourceTree'
    Argument @Pointer
    Local @N
    Uses esi

        mov esi D@Pointer | add esi 12
      ; By Name references:
        lodsw | mov W@N ax
      ; By ID number references:
        lodsw | add W@N ax

        mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap
        mov D$ebx-16 FOUR_RESOURCESFLAG,
            D$ebx-12 FOUR_RESOURCESFLAG,
            D$ebx-8 FOUR_RESOURCESFLAG,
            D$ebx-4 FOUR_RESOURCESFLAG,
            D$ebx FOUR_RESOURCESFLAG,
            D$ebx+4 FOUR_RESOURCESFLAG

          ; esi now points to the Type/ID/Lang and Displacement dWords pairs.
          ; We Skip the ID and retrieve the Pointer:
L0:         add esi 4 | lodsd

          ; If the Value include the High Bit (example: 0_80000020), this is a node)
          ; No High Bit, this is a leaf.

            .If eax >= 08000_0000
                xor eax 08000_0000 | add eax D$DisResourcesOrigine
                call FlagResourceTree eax

                If W@N > 1
                  ; Flag the next coming Type/ID/Lang and Displacement dWords pair:
                    mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap
                    mov D$ebx FOUR_RESOURCESFLAG, D$ebx+4 FOUR_RESOURCESFLAG
                    dec W@N | jmp L0<
                End_If

            .Else
              ; Flag the leaf Pointer and size, and then the true Resources Data:
                add eax D$DisResourcesOrigine
                mov edi D$eax, ecx D$eax+4
                add edi D$DisResourcesOrigine
                GetPeHeader AppBaseOfRsrc | sub edi D$eax
                sub edi D$UserPeStart | add edi D$SectionsMap
                mov al RESOURCESFLAG | rep stosb

            .End_If
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; Guga proposition:

;;

Resource structures

[IMAGE_RESOURCE_DIRECTORY:
 Characteristics: D$ 0
 TimeDateStamp: D$ 0
 MajorVersion: W$ 0
 MinorVersion: W$ 0
 NumberOfNamedEntries: W$ 0
 NumberOfIdEntries: W$ 0]

[ImgResDir.CharacteristicsDis 0
 ImgResDir.TimeDateStampDis 4
 ImgResDir.MajorVersionDis 8
 ImgResDir.MinorVersionDis 10
 ImgResDir.NumberOfNamedEntriesDis 12
 ImgResDir.NumberOfIdEntriesDis 14]

[Size_Of_IMAGE_RESOURCE_DIRECTORY 16]

; followed by an array of XX IMAGE_RESOURCE_DIRECTORY_ENTRY. The total amount of elements
 on theg array are the sum of NumberOfNamedEntries + NumberOfIdEntries.

[IMAGE_RESOURCE_DIRECTORY_ENTRY:
 Name1: Id: D$ 0
 OffsetToData: D$ 0]
 
 Name1 = This field contains either an integer ID or a pointer to a structure that contains a string name.
         If the high bit (0x80000000) is zero, this field is interpreted as an integer ID.
         Th ID is the type of the resource, such as a dialog, an icon, an bitmap image etc. It can be one of the
         following equates (This member does not allow combination of the equates):
         &RT_CURSOR, &RT_BITMAP, &RT_ICON, &RT_MENU, &RT_DIALOG, &RT_STRING, &RT_FONTDIR, &RT_FONT, &RT_ACCELERATOR,
         &RT_RCDATA, &RT_GROUP_CURSOR, &RT_GROUP_ICON, &RT_MESSAGETABLE, &RT_VERSION, &RT_DLGINCLUDE, &RT_PLUGPLAY,
         &RT_VXD, &RT_ANICURSOR

            Ex.: 05 = the ID of the data resource. It is a dialog (&RT_DIALOG)
 
         If the high bit is nonzero, the lower 31 bits are an offset (relative to the start of the resources)
            to an IMAGE_RESOURCE_DIR_STRING_U structure.
            Ex.: 080000688 = 080000000+DataOffset-IMAGE_RESOURCE_DIRECTORY_ENTRY (The main one, that is the 1st found in the section)
                So, on the example we are at byte 0688 from the start of the resources section.
                At byte 0688 we will have a IMAGE_RESOURCE_DIR_STRING_U structure
            This structure contains a WORD character count, followed by a UNICODE string with the resource name.
            Yes, even PE files intended for non-UNICODE Win32 implementations use UNICODE here.
            To convert the UNICODE string to an ANSI string, use the WideCharToMultiByte function.
                [IMAGE_RESOURCE_DIR_STRING_U:
                    Length1: W$ 0   The length of the string
                    NameString: W$ 0] The unicode string. This string is non null terminated, but an additional word
                                      may be inserted after the string to make next field start on a dword boundary.

OffsetToData = This field is either an offset to another resource directory or a pointer to information about
               a specific resource instance.
               
               If the high bit (0x80000000) is set, this directory entry refers to a subdirectory.
                The lower 31 bits are an offset (relative to the start of the resources) to another IMAGE_RESOURCE_DIRECTORY.
                Ex.: 080000468 = 080000000+DataOffset-IMAGE_RESOURCE_DIRECTORY_ENTRY (The main one, that is the 1st found in the section)
                So, on the example we are at byte 0468 from the start of the resources section.
                At byte 0468 we will have another IMAGE_RESOURCE_DIRECTORY structure
               
               If the high bit isn't set, the lower 31 bits point to an IMAGE_RESOURCE_DATA_ENTRY structure.
               This is called as "leaf node".
                Ex.: 0EA0 = DataOffset-IMAGE_RESOURCE_DIRECTORY_ENTRY (The main one, that is the 1st found in the section)
                     At byte 0EA0 we will have an IMAGE_RESOURCE_DATA_ENTRY structure
                The IMAGE_RESOURCE_DATA_ENTRY structure contains the location of the resource's raw data, its size, and its code page.
                    [IMAGE_RESOURCE_DATA_ENTRY:
                        OffsetToData: D$ 0
                        Size1: D$ 0
                        CodePage: D$ 0
                        Reserved: D$ 0]

                OffsetToData = location of the actual resource data. Since this information is used primarily
                               by functions once the application has been loaded,
                               it makes more sense to make the OffsetToData field a relative virtual address.

                                This is precisely the case.
               
                                Interestingly enough, all other offsets, such as pointers from directory entries
                                to other directories, are offsets relative to the location of the root node.
                                Ex.: 0E1608 = DataOffset-ImageBase (The start of thge PE file)
               
                Size1 = size of the actual resource data.
               
                CodePage = Code page is the traditional IBM term used for a specific character encoding table:
                           a mapping in which a sequence of bits, usually a single octet representing integer values
                           0 through 255, is associated with a specific character. IBM and Microsoft often allocate a
                           code page number to a character set even if that charset is better known by another name.

                           Whilst the term code page originated from IBM's EBCDIC-based mainframe systems, the term is
                           most commonly associated with the IBM PC code pages. Microsoft, a maker of PC operating systems,
                           refers to these code pages as OEM code pages, and supplements them with its own "ANSI" code pages.

                           Most well-known code pages, excluding those for the CJK languages and Vietnamese, represent character
                           sets that fit in 8 bits and don't involve anything that can't be represented by mapping each code to a
                           simple bitmap, such as combining characters, complex scripts, etc.

                           The text mode of standard (VGA compatible) PC graphics hardware is built around using an 8 bit
                           code page, though it is possible to use two at once with some color depth sacrifice, and up to
                           8 may be stored in the display adaptor for easy switching).
                           
                           There were a selection of code pages that could be loaded into such hardware.
                           
                           However, it is now commonplace for operating system vendors to provide their own character encoding
                           and rendering systems that run in a graphics mode and bypass this system entirely.
                           
                           The character encodings used by these graphical systems (particularly Windows) are sometimes
                           called code pages as well.
                           
                            - Relationship to ASCII. -
                           The basis of the IBM PC code pages is ASCII, a 7-bit code representing 128 characters and control
                           codes. In the past, 8-bit extensions to the ASCII code often either set the top bit to zero,
                           or used it as a parity bit in network data transmissions.
                           When this bit was instead made available for representing character data, another 128 characters
                           and control codes could be represented. IBM used this extended range to encode characters used
                           by various languages.
                           No formal standard existed for these 'extended character sets'; IBM merely referred to the variants
                           as code pages, as it had always done for variants of EBCDIC encodings.
               
                            - IBM PC (OEM) code pages -

                            These code pages are most often used under MS-DOS-like operating systems;
                            they include a lot of box drawing characters. Since the original IBM PC code page (number 437)
                            was not really designed for international use, several incompatible variants emerged.
                            Microsoft refers to these as the OEM code pages. Examples include:

                                * 437 — The original IBM PC code page
                                * 737 — Greek
                                * 850 — "Multilingual (Latin-1)" (Western European languages)
                                * 852 — "Slavic (Latin-2)" (Eastern European languages)
                                * 855 — Cyrillic
                                * 857 — Turkish
                                * 858 — "Multilingual" with euro symbol
                                * 860 — Portuguese
                                * 861 — Icelandic
                                * 863 — French Canadian
                                * 865 — Nordic
                                * 866 — Cyrillic
                                * 869 — Greek

                            - Other code pages of note -

                                * 10000 — Macintosh Roman encoding (followed by several other Mac character sets)
                                * 10007 — Macintosh Cyrillic encoding
                                * 10029 — Macintosh Central European encoding
                                * 932 — Supports Japanese
                                * 936 — GBK Supports Simplified Chinese
                                * 949 — Supports Korean
                                * 950 — Supports Traditional Chinese
                                * 1200 — UCS-2LE Unicode little-endian
                                * 1201 — UCS-2BE Unicode big-endian
                                * 65001 — UTF-8 Unicode
                                * ASMO449+ — Supports Arabic

                            In modern applications, operating systems and programming languages, the IBM code pages
                            have been rendered obsolete by newer & better international standards, such as ISO 8859-1
                            and Unicode.

                            - Windows (ANSI) code pages -

                            Microsoft defined a number of code pages known as the ANSI code pages (as the first one, 1252
                            was based on an ansi draft of what became ISO 8859-1). Code page 1252 is built on ISO 8859-1
                            but uses the range 0x80-0x9F for extra printable characters rather than the C1 control codes
                            used in ISO-8859-1.
                            Some of the others are based in part on other parts of ISO 8859 but often rearranged to make
                            them closer to 1252.

                                * 1250 — East European Latin
                                * 1251 — Cyrillic
                                * 1252 — West European Latin
                                * 1253 — Greek
                                * 1254 — Turkish
                                * 1255 — Hebrew
                                * 1256 — Arabic
                                * 1257 — Baltic
                                * 1258 — Vietnamese

                Reserved = Reserved data. Do not use.
;;

;;
  'FlagResourceTree' is a good example of Procedure calling itself, for moving along
  all branches of a tree.
;;

; IMAGE_RESOURCE_DIRECTORY structure

[ImgResDir.CharacteristicsDis 0
 ImgResDir.TimeDateStampDis 4
 ImgResDir.MajorVersionDis 8
 ImgResDir.MinorVersionDis 10
 ImgResDir.NumberOfNamedEntriesDis 12
 ImgResDir.NumberOfIdEntriesDis 14]

[Size_Of_IMAGE_RESOURCE_DIRECTORY 16]

; IMAGE_RESOURCE_DIRECTORY_ENTRY structure

[ImgResDirEntry.Name1Dis 0
 ImgResDirEntry.OffsetToDataDis 4]

[Size_Of_IMAGE_RESOURCE_DIRECTORY_ENTRY 8]

; IMAGE_RESOURCE_DIR_STRING_U structure

[ImgResDirStringU.Length1Dis 0]
; ImgResDirStringU.NameString the size of the unicode string depends of the value of Length1

; IMAGE_RESOURCE_DATA_ENTRY structure

[ImgResDataEntry.OffsetToDataDis 0
 ImgResDataEntry.Size1Dis 4
 ImgResDataEntry.CodePageDis 8
 ImgResDataEntry.ReservedDis 12]

[Size_Of_IMAGE_RESOURCE_DATA_ENTRY 16]

Proc FlagResourceTree: ; 'ResourcesStub' For infos.
    Argument @Pointer
    Local @Array
    Uses esi, ebx, eax

    mov esi D@Pointer, eax 0

    push esi
      ; add ImgResDir.NumberOfNamedEntries to ImgResDir.NumberOfIdEntries
      ; and copy the result to N:
        add esi ImgResDir.NumberOfNamedEntriesDis
        lodsw | mov D@Array eax
        lodsw | add D@Array eax
    pop esi

    ; now we flag all IMAGE_RESOURCE_DIRECTORY
    mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap
    mov eax RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)
    mov D$ebx+ImgResDir.CharacteristicsDis eax, D$ebx+ImgResDir.TimeDateStampDis eax,
    W$ebx+ImgResDir.MajorVersionDis ax, W$ebx+ImgResDir.MinorVersionDis ax,
    W$ebx+ImgResDir.NumberOfNamedEntriesDis ax, W$ebx+ImgResDir.NumberOfIdEntriesDis ax

    ; esi and ebx now points to the IMAGE_RESOURCE_DIRECTORY_ENTRY.
    add esi Size_Of_IMAGE_RESOURCE_DIRECTORY
    add ebx Size_Of_IMAGE_RESOURCE_DIRECTORY

          ; We need to see if we have a Unicode String Name or a ID
L0:         lodsd ; load the name ID to eax
            ; flag the Name1Dis member
            mov D$ebx+ImgResDirEntry.Name1Dis RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)
            ;add ebx ImgResDirEntry.OffsetToDataDis ; update ebx to it points to the offsettodata in the sectionmap

            Test_If eax 08000_0000 ; If it is a named ID, flag all the IMAGE_RESOURCE_DIR_STRING_U structure
                xor eax 08000_0000
                add eax D$DisResourcesOrigine ; eax is now at IMAGE_RESOURCE_DIR_STRING_U
                movzx ecx W$eax ; ecx now contains the lenght of our unicode string
                sub eax D$userpestart ; let´s point it to the proper location
                add eax D$SectionsMap ; in the section map
                ; flag the lenght member
                mov W$eax+ImgResDirStringU.Length1Dis RESOURCESFLAG+(RESOURCESFLAG shl 8)
                add eax 2 ; points to the begginning of the unicode string
                ; flag the unicode string
                mov edi eax
                mov ax RESOURCESFLAG+(RESOURCESFLAG shl 8) | rep stosw
            Test_End

            ; Now, load the OffsetToData and save it´s value at eax
            lodsd
            ; flag the OffsetToDataDis member
            mov D$ebx+ImgResDirEntry.OffsetToDataDis RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)
            add ebx Size_Of_IMAGE_RESOURCE_DIRECTORY_ENTRY ; update ebx

            .Test_If eax 08000_0000 ; If the high bit (0x80000000) is set this is a node
                xor eax 08000_0000 | add eax D$DisResourcesOrigine
                call FlagResourceTree eax

                If D@Array > 1
                  ; let´s flag the rest of the array IMAGE_RESOURCE_DIRECTORY_ENTRY.
                    dec D@Array | jmp L0<<
                End_If

            .Test_Else ; If the high bit (0x80000000) is not set this is a leaf
                ; Flag all the IMAGE_RESOURCE_DATA_ENTRY and their internal pointers
                add eax D$DisResourcesOrigine
                mov ebx eax
                sub ebx D$UserPeStart
                add ebx D$SectionsMap

                mov D$ebx+ImgResDataEntry.OffsetToDataDis RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)
                mov D$ebx+ImgResDataEntry.Size1Dis RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)
                mov D$ebx+ImgResDataEntry.CodePageDis RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)
                mov D$ebx+ImgResDataEntry.ReservedDis RESOURCESFLAG+(RESOURCESFLAG shl 8)+(RESOURCESFLAG shl 16)+(RESOURCESFLAG shl 24)

                ; flag the data contents
                mov edi D$eax+ImgResDataEntry.OffsetToDataDis
                mov ecx D$eax+ImgResDataEntry.Size1Dis
                add edi D$SectionsMap; edi points to the offset of the data in the sectinosmap
                mov al RESOURCESFLAG | rep stosb

            .Test_End
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
 If no Virtual Data Section is found, the Application is allowed (RosAsm works like
 this, and many other Compilers), to consider as Virtual (uninitialized) Data the
 room left between the End of Data and the Virtual End of .Data section. In
 'SectionsHeaders', this is the difference between the first dWord (after the name)
 and the third dWord.

 Here, if we find no Virtual Data Section, we simply exit and let in the Values
 defined in upper 'ReadDataSection'.
;;

[VirtualIsRunable: ?]

CheckVirtualData:
    GetPeHeader SectionsHeaders | mov ecx D$DisNumberOfSections

L0: test D$eax+SECTION_FLAG &IMAGE_SCN_CNT_UNINITIALIZED_DATA | jz L3>
        test D$eax+SECTION_FLAG &IMAGE_SCN_MEM_READ | jz L3>
            test D$eax+SECTION_FLAG &IMAGE_SCN_MEM_WRITE | jz L3>

                test D$eax &IMAGE_SCN_MEM_EXECUTE | jz L2>
                    mov B$VirtualIsRunable &TRUE            ; See this pb later.

  ; Regular Virtual Data Section found. Check the Bytes in 'SectionMap':
L2: mov ebx D$eax+SECTION_RVA | add ebx D$SectionsMap
    mov edi D$SectionsMap | add edi D$eax+SECTION_RVA
    mov edx edi | add edx D$eax+SECTION_FILESIZE
    push edi
        While edi < edx | mov B$edi VIRTUALFLAG | inc edi | End_While
    pop edi
  ; Force the First Virtual Byte EVOCATED:
    sub edi D$SectionsMap | add edi D$RoutingMap | mov B$edi EVOCATED

L3: add eax SECTIONHEADERSIZE | loop L0<
ret


CheckExtendedVirtual:
    GetPeHeader SectionsHeaders | mov ecx D$DisNumberOfSections

L0: mov ecx D$eax+SECTION_RVASIZE, ebx D$eax+SECTION_FILESIZE
    Align_On_Variable D$DisRvaSectionAlignment ecx
    Align_On_Variable D$DisFileSectionAlignment ebx
    .If ecx > ebx
        test D$eax+SECTION_FLAG &IMAGE_SCN_MEM_EXECUTE | jz L2>
            mov B$VirtualIsRunable &TRUE            ; See this pb later.

L2:     mov edi D$SectionsMap | add edi D$eax+SECTION_RVA | add edi D$eax+SECTION_FILESIZE
      ; Don't touch Reloc and DebugInfo:
        If B$edi <> KILLFLAG
          ; Force the First Virtual Byte EVOCATED:
            mov edx edi | sub edx D$SectionsMap | add edx D$RoutingMap | mov B$edx EVOCATED

            push eax
                mov ecx D$eax+SECTION_RVASIZE
                Align_On_Variable D$DisRvaSectionAlignment ecx
                sub ecx ebx | mov al VIRTUALFLAG | rep stosb
            pop eax
        End_If
    .End_If

L3: add eax SECTIONHEADERSIZE | cmp D$eax+SECTION_RVA 0 | ja L0<<
ret
____________________________________________________________________________________________

[NumberOfDisExportedFunctions: ?    DisExportFunctionsPointers: ?
 DisExportNamesPointers: ?    DisExportInside: ?    DisExportOrdinal: ?]

; 'ExportSectionComments'.

[NumberOfForwardedExport: ?]

[ForwardedMessage: '     ', Forwarded: "Forwarded Exports found in this Module. 
   
 RosAsm Assembler does not assume this method.    
 The rebuilt Module will therefore not work
 like the original (missing Functions).", 0]

CheckExport:
    GetPeHeader SectionTable | On D$eax = 0, ret

    mov D$NumberOfForwardedExport 0

    push eax
        mov edi D$eax, ecx D$eax+4, al EXPORTFLAG
        add edi D$SectionsMap | rep stosb
    pop eax

    mov edx D$eax | add edx D$UserPeStart
    mov eax D$edx+(5*4), ebx D$edx+(6*4)
    On ebx > eax, mov eax ebx
    add edx (6*4)
    mov D$NumberOfDisExportedFunctions eax
; 0476 = 1142 in wsock32.dll !!!   04B  Forwarded Functions (forwarded to other DLLs) !!!
    On D$NumberOfDisExportedFunctions = 0, jmp L9>>
  ; 'ExportSectionComments'
    add edx 4 | mov eax D$edx | add eax D$UserPeStart
    mov D$DisExportFunctionsPointers eax

    add edx 4 | mov eax D$edx | add eax D$UserPeStart
    mov D$DisExportNamesPointers eax

    add edx 4 | mov eax D$edx | add eax D$UserPeStart
    mov D$DisExportOrdinal eax

  ; Mark the Exported Functions as Nodes in the Code Routing Table:
    mov esi D$DisExportFunctionsPointers, ecx D$NumberOfDisExportedFunctions

L0: lodsd
    .If eax = 0
        loop L0<
    .Else
        add eax D$SectionsMap
        If B$eax = EXPORTFLAG
            inc D$NumberOfForwardedExport | loop L0<
        Else
            sub  eax D$SectionsMap | add eax D$RoutingMap
            or B$eax NODE+INSTRUCTION+EXPORTNODE+ACCESSED+EVOCATED+PUSH_EBP+LABEL
            sub eax D$RoutingMap | add eax D$SectionsMap | mov B$eax CODEFLAG | loop L0<
        End_If
    .End_If

    If D$NumberOfForwardedExport <> 0
        mov eax D$NumberOfForwardedExport, edi ForwardedMessage
        call WriteEaxDecimal
        While edi < Forwarded | mov B$edi ' ' | inc edi | End_While
        call 'USER32.MessageBoxA', 0, ForwardedMessage,
                                  {' Warning', 0}, 0
    End_If
ret

; Old flaging method:

  ; Flag the SectionsMap with EXPORTFLAG (only the real Export Table. Not
  ; the whole Section, that may contain anything else -Import / Data /...-):
L1: GetPeHeader SectionTable | mov esi D$eax | add esi D$UserPeStart

    mov al EXPORTFLAG

  ; First, the Header (10 dWords).
    mov ecx (10*4)
    mov edi esi | sub edi D$UserPeStart | add edi D$SectionsMap
    rep stosb

  ; 'ExportSectionComments'.
  ;
  ; DllName:
    mov edi D$esi+(3*4), ebx edi
    ..If edi <> 0
        add edi D$SectionsMap | add ebx D$UserPeStart
        .If edi > D$SectionsMap
            If edi < D$EndOfSectionsMap
                While B$ebx <> 0 | stosb | inc ebx | End_While | stosb
            End_If
        .End_If
    ..End_If

  ; ExportAdressesTable:
    mov edi D$esi+(7*4)
    ..If edi <> 0
        add edi D$SectionsMap
        .If edi > D$SectionsMap
            If edi < D$EndOfSectionsMap
                mov ecx D$NumberOfDisExportedFunctions | shl ecx 2 | rep stosb
            End_If
        .End_If
    ..End_If

  ; ExportNamesTable:
    mov edi D$esi+(8*4)
    ..If edi <> 0
        add edi D$SectionsMap
        .If edi > D$SectionsMap
            If edi < D$EndOfSectionsMap
                mov ecx D$NumberOfDisExportedFunctions | shl ecx 2 | rep stosb
            End_If
        .End_If
    ..End_If

  ; ExportOrdinals
    mov edi D$esi+(9*4)
    ..If edi <> 0
        add edi D$SectionsMap
        .If edi > D$SectionsMap
            If edi < D$EndOfSectionsMap
                mov ecx D$NumberOfDisExportedFunctions | shl ecx 1 | rep stosb
            End_If
        .End_If
    ..End_If

  ; Function1Name, Function2Name, ...
    mov esi D$esi+(8*4), ecx D$NumberOfDisExportedFunctions | On esi = 0, jmp L1>
    add esi D$UserPeStart
    ...If esi > D$UserPeStart
        ..If esi < D$UserPeEnd
L0:         mov edi D$esi, ebx edi
            add edi D$SectionsMap | add ebx D$UserPeStart
            .If edi > D$SectionsMap
                If edi < D$EndOfSectionsMap
                    While B$ebx <> 0 | stosb | inc ebx | End_While | stosb
                    add esi 4 | loop L0<
                End_If
            .End_If
        ..End_If
    ...End_If

L1: mov B$DisExportInside &TRUE

L9: call KillBlankBytes SectionTable, EXPORTFLAG
ret
____________________________________________________________________________________________

;;
  The 'KILLFLAG' is simply for _not_ analysing these Sections that are no use for
  the Disassembling Process.
;;

KillPeHeader:
    mov edi D$SectionsMap, ecx D$FirstSection, al KILLFLAG
    rep stosb
ret


Proc KillSection:
    Argument @OptionalHeaderTable

        GetPeHeader D@OptionalHeaderTable | mov edi D$eax | On edi = 0, ExitP

    ; Example: Is it a clean .reloc with nothing else inside?
        test edi 0FFF | jnz L2>

            mov esi edi | add esi D$UserPeStart
            mov ecx D$eax+4 | Align_On_Variable D$DisRvaSectionAlignment ecx
            mov edx esi | add edx ecx | add esi D$eax+4

            While esi < edx
                On B$esi <> 0, jmp L2>
                inc esi
            End_While

            ; Example: Seems to be a clean .reloc. Fill it all:
                add edi D$SectionsMap | mov al KILLFLAG | rep stosb | ExitP

L2:     mov ecx D$eax+4 | add edi D$SectionsMap | mov al KILLFLAG | rep stosb
EndP


Proc KillBlankBytes:
    Arguments @OptionalHeaderTable, @FLAG

        mov eax D@OptionalHeaderTable, esi D$eax, ecx D$eax+4
        Align_On_Variable D$DisRvaSectionAlignment ecx

        add esi D$UserPeStart | mov edx esi | add edx ecx
        mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap

        While esi < edx
            On ebx >= D$EndOfSectionsMap, ExitP

            If B$ebx = 0
                On B$esi <> 0, ExitP
            End_If
            inc esi | inc ebx
        End_While

      ; OK. Only blank Bytes found, other than, for example, the normal Export Data:
        mov eax D@OptionalHeaderTable, esi D$eax, ecx D$eax+4
        Align_On_Variable D$DisRvaSectionAlignment ecx

        add esi D$UserPeStart | mov edx esi | add edx ecx
        mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap

        While esi < edx
            On B$ebx = 0, mov B$ebx KILLFLAG
            inc esi | inc ebx
        End_While
EndP


KillSectionsExtensions:
    GetPeHeader SectionsHeaders | mov esi eax

    mov ecx D$DisNumberOfSections

L0: push ecx
        mov edi D$esi+SECTION_RVA | add edi D$SectionsMap
        mov ecx D$esi+SECTION_RVASIZE
        mov eax D$esi+SECTION_FILESIZE
        On ecx > eax, mov eax ecx
        Align_On_Variable D$DisFileSectionAlignment eax
        mov ecx eax
        Align_On_Variable D$DisRvaSectionAlignment ecx
        sub ecx eax | jz L2>

            add edi eax | mov al KILLFLAG | rep stosb
L2: pop ecx

    add esi SECTIONHEADERSIZE | loop L0<
ret
____________________________________________________________________________________________

[DisFailText: 'Failure of Disassembly', 0]
[SilentMap: ?]

DisFail:
    call DestroyDisProgressBar

    VirtualFree D$UserPeStart, D$CodeSource, D$TruthAsciiTable, D$RoutingMap, D$SectionsMap,
                D$SizesMap, D$ApiBuffer

    mov B$Disassembling &FALSE
    If B$SilentMap = &FALSE
        mov eax DisFailText | call MessageBox
    End_If
    mov B$SilentMap &FALSE

L0: mov ebx, esp | cmp ebx, D$OldStackPointer | jnb L1>
        pop ebx | jmp L0<

L1: jmp StartNewFile

____________________________________________________________________________________________
____________________________________________________________________________________________

[ProgressWindowStyle: 084 ] ;&WS_EX_TOOLWINDOW] ; 084

;;
   Attempt to having a ProgressBar that would be possible to close.
   
   Should be the routing center of all of the Assembler or Disassembler stuff.
   
   later...
;;

;InitDisProgressBar:
  ; Tag Dialog 25
    call 'USER32.DialogBoxParamA' D$hinstance, 25, &NULL, ProgressProc, &NULL
ret

Proc ProgressProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ..If D@Message = &WM_COMMAND
        If D@wParam = &IDCANCEL
            call 'USER32.EndDialog' D@Adressee, 0
        End_If

    ..If D@Message = &WM_CLOSE
        call 'USER32.EndDialog' D@Adressee, 0

    ..Else_If D@Message = &WM_INITDIALOG
        move D$hwndForBar D@Adressee
        call 'USER32.GetDlgItem' D@Adressee 5 | mov D$ProgressInst eax

        call 'USER32.SetClassLongA' D@Adressee, &GCL_HICON, D$wc_hIcon
      ; Set steping and Title:
        call 'User32.SendMessageA' D$ProgressInst, &PBM_SETRANGE, 0, (128 shl 16)
        call 'User32.SendMessageA' D$ProgressInst, &PBM_SETSTEP, 1, 0  ; 1/100
        call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, DisPasses

    ..Else
        popad | mov eax &FALSE | ExitP

    ..End_If

    popad | mov eax &TRUE
EndP
____________________________________________________________________________________________

InitDisProgressBar:
  ; Center the bar:
    call 'User32.GetSystemMetrics' &SM_CXSCREEN
      sub eax D$PBarWindowW | shr eax 1 | mov D$PBarWindowX eax
    call 'User32.GetSystemMetrics' &SM_CYSCREEN
      sub eax D$PBarWindowH | shr eax 1 | mov D$PBarWindowY eax

  ; WindowExStyle > 084:    80 > tool  4 > no parent notify
    call 'User32.CreateWindowExA' 084, ClassName, &NULL, &WS_OVERLAPPEDWINDOW,
                                  D$PBarWindowX, D$PBarWindowY, D$PBarWindowW, D$PBarWindowH,
                                  D$hwnd, 0, D$hInstance, 0
    mov D$hwndForBar eax

    call 'User32.ShowWindow' D$hwndForBar, &SW_SHOWNORMAL
    call 'User32.UpdateWindow' D$hwndForBar
_____________________________

    call 'User32.CreateWindowExA' 0, ProgressClassName, 0, 050000000,
                                  D$PWindowX, D$PWindowY, D$PWindowW, D$PWindowH,
                                  D$hwndForBar, 1, D$hInstance, 0
    mov D$ProgressInst eax

  ; Set steping and Title:
    call 'User32.SendMessageA' D$ProgressInst, &PBM_SETRANGE, 0, (128 shl 16)
    call 'User32.SendMessageA' D$ProgressInst, &PBM_SETSTEP, 1, 0  ; 1/100
    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, DisPasses
ret

;InitDisProgressBar:
  ; Center the bar:
    call 'User32.GetSystemMetrics' &SM_CXSCREEN
      sub eax D$PBarWindowW | shr eax 1 | mov D$PBarWindowX eax
    call 'User32.GetSystemMetrics' &SM_CYSCREEN
      sub eax D$PBarWindowH | shr eax 1 | mov D$PBarWindowY eax

  ; WindowExStyle > 084:    80 > tool  4 > no parent notify
    call 'User32.CreateWindowExA' D$ProgressWindowStyle, ClassName, &NULL, &WS_OVERLAPPEDWINDOW,
                                  D$PBarWindowX, D$PBarWindowY, D$PBarWindowW, D$PBarWindowH,
                                  D$hwnd, 0, D$hInstance, 0
    mov D$hwndForBar eax

    call 'User32.ShowWindow' D$hwndForBar, &SW_SHOWNORMAL
    call 'User32.UpdateWindow' D$hwndForBar

    call 'User32.SetWindowLongA' D$hwndForBar, &GWL_WNDPROC, ProgressProc
    mov D$PreviousProgressProc eax
_____________________________

    call 'User32.CreateWindowExA' 0, ProgressClassName, 0, 050000000,
                                  D$PWindowX, D$PWindowY, D$PWindowW, D$PWindowH,
                                  D$hwndForBar, 1, D$hInstance, 0
    mov D$ProgressInst eax

  ; Set steping and Title:
    call 'User32.SendMessageA' D$ProgressInst, &PBM_SETRANGE, 0, (128 shl 16)
    call 'User32.SendMessageA' D$ProgressInst, &PBM_SETSTEP, 1, 0  ; 1/100
    call 'User32.SendMessageA' D$hwndForBar, &WM_SETTEXT, 0, DisPasses
ret


[PreviousProgressProc: ?
 ProgressRet: ?
 ProgressAdressee: ?  ProgressMessage: ?  ProgressWparam: ?  ProgressLparam: ?]

;ProgressProc:
    pop D$ProgressRet
    pop D$ProgressAdressee, D$ProgressMessage, D$ProgressWparam, D$ProgressLparam
    push D$ProgressRet

    .If D$ProgressMessage = &WM_COMMAND
        If D$mEditWparam = &IDCANCEL
           ; mov eax &FALSE | ret
        End_If
    .End_If

L9: call 'User32.CallWindowProcA' D$PreviousProgressProc D$ProgressAdressee,
                                  D$ProgressMessage, D$ProgressWparam, D$ProgressLparam
    ret

____________________________________________________________________________________________
____________________________________________________________________________________________

[SubEdi6 | On B$WithCommentedHexa = &FALSE, call SubEdi6IfNoComment]

;;
 Try a minimal organisation of Jcc Instructions writing, under the form of:

 > cmp eax 2 | je K2<

 In case "Cmp eax 2" is followed by comments (either "Code0407050" or Commented
 Hexa Code), we abort the attempt:
;;

SubEdi6IfNoComment:
    push ebx
        mov ebx edi | sub ebx 7
        While B$ebx >= ' '
            dec ebx | On B$ebx = ';', jmp L9>
        End_While
        sub edi 6
L9: pop ebx
ret
____________________________________________________________________________________________

; The main Passes Analyzes of Disassembly.
____________________________________________________________________________________________

[DisEndOfChunk: ?]
[DisCodeDisplacement: ?    DisCodeBytes: ?    DisBarStep: ?    NextDisBarPos: ?
 NewAccessedLocations: ?]

[TestLastLocation: ?  TestLastLineLocation: ?]

DisassembleForCodeRouting:
    mov edi D$CodeSource, esi D$UserPeStart
    add esi D$FirstSection
    mov D$NewAccessedLocations &FALSE, D$LastCodeRef 0

    NextDisLine

L0: mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
    mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
    mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
    mov B$CALLInstruction &FALSE, B$LeaInstruction &FALSE

  ; Parse onlyCODEFLAGed (in SectionsMap) and ACCESSED (in RoutingMap) Locations:
L1: mov eax esi | sub eax D$UserPestart | add eax D$SectionsMap
    Test B$eax CODEFLAG | jnz L2>
        inc esi | On esi = D$UserPeEnd, jmp L9>>
            jmp L1<

L2: sub eax D$SectionsMap | add eax D$RoutingMap
    test B$eax ACCESSED | jnz L3>
        inc esi | On esi = D$UserPeEnd, jmp L9>>
            jmp L1<

      ; Call for the Disassembly Routines:
L3:     or B$eax INSTRUCTION
L3:     movzx eax B$esi

        mov D$TestLastLineLocation esi, D$TestLastLocation esi

        inc esi | call D$DisOp1+eax*4

      ; Loop immidiately in case of simple Prefix:
        While B$DisFlag = DISDONE
            mov D$TestLastLocation esi
            movzx eax B$esi | inc esi | call D$DisOp1+eax*4
        End_While

        mov eax D$TestLastLineLocation | sub eax D$UserPeStart | add eax D$DisImageBase

      ; Clear any LABEL from inside the valid parsed Code:
        mov eax D$TestLastLineLocation, edx esi | inc eax
        sub eax D$UserPeStart | add eax D$RoutingMap
        sub edx D$UserPeStart | add edx D$RoutingMap
L3:     and B$eax (not LABEL)
        On B$LastDisassemblyRoutingPass = &TRUE,
            and B$eax (not LABEL+INSTRUCTION+EVOCATED+NODE)
        inc eax | cmp eax edx | jb L3<

      ; If a CALL or a JMP was Disassembed, the decoding Routines return this Flag set on.
      ; We mark the RoutingMap's according Byte as a new Entry Point:
        .If B$CALLInstruction = &TRUE
            mov B$CALLInstruction &FALSE

            If B$EscapePrefix <> &TRUE
                mov eax D$TestLastLocation
                On B$eax = 0E8, call IsItNoReturnCall  ; OpE8
            End_If

            mov eax D$LastCodeRef
            sub eax D$DisImageBase | add eax D$SectionsMap
            On eax < D$SectionsMap, jmp L4>>
            On eax >= D$EndOfSectionsMap, jmp L4>>
            test B$eax VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+DATAFLAG | jnz L4>>
            ;test B$eax VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG | jnz L4>>
                mov B$eax CODEFLAG
                sub eax D$SectionsMap | add eax D$RoutingMap
                test B$eax ACCESSED | jnz L3>
                    mov B$NewAccessedLocations &TRUE
L3:             or B$eax NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
        .End_If

      ; CHUNKEND Flag marks the first Byte *after* a RET or a JMP:
L4:     mov eax esi | sub eax D$UserPeStart | add eax D$RoutingMap
        If B$DisEndOfChunk = &TRUE
            or B$eax CHUNKEND | dec eax | mov B$DisEndOfChunk &FALSE
        End_If

      ; Now Flaged *backward* 'ACCESSED' the Bytes of the new disassembled Instruction,
      ; including the very first Byte of the new coming Instruction, if this one is
      ; not a CHUNKEND (we have 'dec eax' up there in such cases):
L4:     test B$eax ACCESSED | jnz L4>
            mov D$NewAccessedLocations &TRUE

L4:     mov ecx D$TestLastLineLocation | sub ecx D$UserPeStart | add ecx D$RoutingMap

L4:     or B$eax ACCESSED
        mov ebx eax | sub ebx D$RoutingMap | add ebx D$SectionsMap
        test B$ebx VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+DATAFLAG | jnz L5>
       ; test B$eax VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG | jnz L5>
        mov B$ebx CODEFLAG
L5:     dec eax

        On eax >= ecx, jmp L4<

L6:   ; Adjust the ProgressBar is wanted:
        If esi > D$NextDisBarPos
            mov eax esi | add eax D$DisBarStep | mov D$NextDisBarPos eax
            call BarProgress
        End_If

    On esi < D$UserPeEnd, jmp L0<<

  ; Loop it all until no more new accessed Code Chunks are found:
L9: mov D$NextDisBarPos 0
   ; map
    cmp B$NewAccessedLocations &TRUE | je DisassembleForCodeRouting
L9:ret

____________________________________________________________________________________________

IsItNoReturnCall:
  ; Escape, if the pointed Byte is already flaged valid Code, by some Code Reference:
    mov eax esi | sub eax D$UserPeStart | add eax D$RoutingMap
    test B$eax LABEL | jz L1>
        sub eax D$RoutingMap | add eax D$SectionsMap
        On B$eax = CODEFLAG, ret
;sub eax D$SectionsMap | add eax D$DisImageBase | On eax = 040188B, mov B$TestNow 1
L1: push esi, edi
        push D$DisEndOfChunk, D$LastCodeRef
            lea eax D$esi+50
            mov B$StopAtCall &TRUE
                call IsItCode esi, eax, 0
            mov B$StopAtCall &FALSE
        pop D$LastCodeRef, D$DisEndOfChunk
    pop edi, esi

;If B$TestNow = 1
;    mov eax D$LastUnAccessed | sub eax D$UserPeStart | add eax D$DisImageBase
;    hexprint eax
;End_If

    If eax = &FALSE
        mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap | mov B$eax DATAFLAG
        sub eax D$SectionsMap | add eax D$RoutingMap | or B$eax EVOCATED
        mov D$DisEndOfChunk &TRUE | ;mov B$esi-5 0E9
        mov eax &FALSE

    Else
        mov D$DisEndOfChunk &FALSE

    End_If
ret
____________________________________________________________________________________________

[FollowedByCode: ?  No0CC: ?]

CodeFromPointers:
    call InitDisTablesCopies

    mov B$AttemptSuccess &FALSE, B$No0CC &TRUE, B$StopAtEndOfChunk &TRUE

    mov esi D$SizesMap | add esi D$FirstSection
    sub edx 4

    .While esi < D$EndOfSizesMap
        test B$esi POINTER | jz L8>>
          ; Get the Pointer:
            mov ebx esi | sub ebx D$SizesMap | add ebx D$UserPeStart
            mov eax D$ebx |; On eax = 047E3D4, int3
            sub eax D$DisImageBase | add eax D$UserPeStart

            ...If eax < D$UserPeStart
                xor B$esi POINTER

            ...Else_If eax > D$UserPeEnd
                xor B$esi POINTER

            ...Else
              ; If the Bytes flow begins with zero, this is probably not Code:
                On B$eax = 0, jmp L8>>

              ; Kill POINTERs to the special Sections:
                sub eax D$UserPeStart | add eax D$SectionsMap
                Test_If B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG
                    xor B$esi POINTER
                    jmp L8>>
                Test_End

              ; The Section must not be flaged, yet:
                ..If B$eax = 0
                  ; Compute the size of the zeored Chunk:
                    mov ecx 0 | While B$eax+ecx = 0 | inc ecx | End_While
                    If B$eax+ecx = CODEFLAG
                        mov B$FollowedByCode &TRUE
                    Else
                        mov B$FollowedByCode &FALSE
                    End_If
                    push esi, ebx
                        lea ebx D$eax+ecx
                        sub eax D$SectionsMap | add eax D$UserPeStart
                        sub ebx D$SectionsMap | add ebx D$UserPeStart
                        call IsItCode eax, ebx, 1
                    pop ebx, esi

                    .If eax = &TRUE
                        If B$FollowedByCode = &FALSE
                            On B$DisEndOfChunkEncounted = &FALSE, jmp L7>>
                        End_If

                      ; Possible Code Candidate found. Give it a try:
L4:                     push esi, ebx
                            mov esi D$ebx ;| On eax = 047E3D4, int3
                            sub esi D$DisImageBase | add esi D$SectionsMap
                            If B$esi <> 0
                                pop edx, ebx, esi | jmp L8>>
                            End_If
                          ; Save copies the Tables states for cases of failure:
                            call SetDisTablesCopies

                            mov B$esi CODEFLAG
                            sub esi D$SectionsMap | add esi D$RoutingMap
                            or B$esi NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL

                            sub esi D$RoutingMap | add esi D$SectionsMap
                            call DisassemblingAttempt
                        pop ebx, esi

                      ; Restore the previous Tables versions on failure cases:
                        If B$DisFailure = &TRUE
                      ; Arase the effect of the previous 'SetDisTablesCopies':
                            sub esi D$SizesMap | add esi D$RoutingMap
                            call ExchangeDisTables
                            sub esi D$RoutingMap | add esi D$SizesMap

                            jmp L7>

                        Else
                            mov B$AttemptSuccess &TRUE

                        End_If

                    .Else
                       ; Kills the rebuilt of 3DFUN.exe:

L7:                    ; mov eax D$ebx | sub eax D$DisImageBase | add eax D$SectionsMap
                       ; mov B$eax DATAFLAG

                    .End_If
                ..End_If
            ...End_If
L8:     inc esi
    .End_While

    call ReleaseDisTablesCopies
    mov B$No0CC &FALSE, B$StopAtEndOfChunk &FALSE
ret
____________________________________________________________________________________________

[BiggerZeroedSectionsChunk: ?]

GetBiggerSectionsBlank:
    mov D$BiggerZeroedSectionsChunk 1

    mov esi D$SectionsMap, edx D$EndOfSectionsMap | add esi D$FirstSection
    mov ebx esi | sub ebx D$SectionsMap | add ebx D$UserPeStart

    .While esi < edx
        .If B$esi = 0
            mov ecx 0, eax &FALSE

            While B$esi = 0
                inc esi | inc ecx | On esi >= edx, jmp L2>
                On B$ebx <> 0, mov eax &TRUE
            End_While

            If eax = &TRUE
              ; (Don't consider zeroed Chunks, in the PE):
                mov eax &FALSE
L2:             On ecx > D$BiggerZeroedSectionsChunk, mov D$BiggerZeroedSectionsChunk ecx
            End_If
        .End_If

        inc esi, ebx

    .End_While
ret

____________________________________________________________________________________________
;;
  Everything EVOCATED but not yet Recognized may be either Code or Data.
  
  We first call for 'IsItCode' that says if, 'physicaly', a Chunk could be Code or not.
  
  If yes, run a Try&See Disassembly ('DisassemblingAttempt') on duplicated Dis Tables.
  
  If this attempt is _not_ valid Code, it will __much__ probably break something in the
  already found out Code and/or Data. Nothing broken >>> Run 'DisassembleForCodeRouting'
  for flaging Code.
;;

Proc CodeAttempt:

EndP

[TestNow: ?   LastIdentifiedCandidate: ?]

[Switch | sub #1 D$#2 | add #1 D$#2]

Proc TryToDisassembleEvocated:
    Argument @Required
  ; This 'Required' is the Number of Instructions. Not the number of Bytes.
        call InitDisTablesCopies

        mov B$AttemptSuccess &FALSE

        mov esi D$RoutingMap | add esi D$FirstSection

L0:     .While esi < D$EndOfRoutingMap
L1:         test B$esi EVOCATED+LABEL | jz L5>>

            mov ebx esi | sub ebx D$RoutingMap | add ebx D$SectionsMap
            cmp B$ebx 0 | jne L5>>
            sub ebx D$SectionsMap | add ebx D$SizesMap
            cmp B$ebx 0 | jne L5>>

            push esi, ebx
                sub ebx D$SizesMap | add ebx D$UserPeStart
                mov ecx ebx | add ecx 100
                call IsItCode ebx, D$UserPeEnd, D@Required
            pop ebx, esi

            move D$LastIdentifiedCandidate D$LastUnAccessed

            ...If eax = &TRUE
              ; Possible Code Candidate found. Give it a try:
L4:             push esi
                  ; The copies are for preserving the Tables states in cases of failure:
                    call SetDisTablesCopies
                    or B$esi NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                    sub esi D$RoutingMap | add esi D$SectionsMap
                    mov B$esi CODEFLAG

                    call DisassemblingAttempt
                pop esi

              ; Restore the previous Tables versions on failure cases:
                .If B$DisFailure = &TRUE
                  ; Arase the effect of the previous 'SetDisTablesCopies':
                    call ExchangeDisTables

                .Else
                    mov B$AttemptSuccess &TRUE
                    ;jmp L9> ; (Bound to "pop ecx | jmp L0<", in the main calling loop)

                .End_If

            ...End_If

L5:     inc esi

    .End_While

L9:  call ReleaseDisTablesCopies
EndP


[SectionsMapCopy: ?    RoutingMapCopy: ?    SizesMapCopy: ?
 EndOfSectionsMapCopy: ?    EndOfRoutingMapCopy: ?    EndOfSizesMapCopy: ?]
[DisTableLength: ?]

InitDisTablesCopies:
    mov eax D$EndOfSectionsMap | sub eax D$SectionsMap
  ; Align_On_Variable D$DisRvaSectionAlignment eax |
    mov D$DisTableLength eax

    VirtualAlloc SectionsMapCopy D$DisTableLength
    VirtualAlloc RoutingMapCopy D$DisTableLength
    VirtualAlloc SizesMapCopy D$DisTableLength

    mov ecx D$DisTableLength
    mov eax D$SectionsMapCopy | add eax ecx | mov D$EndOfSectionsMapCopy eax
    mov eax D$RoutingMapCopy | add eax ecx | mov D$EndOfRoutingMapCopy eax
    mov eax D$SizesMapCopy | add eax ecx | mov D$EndOfSizesMapCopy eax
ret


SetDisTablesCopies:
    push esi, edi, ecx
        mov esi D$SectionsMap, edi D$SectionsMapCopy, ecx D$DisTableLength
        shr ecx 2 | rep movsd
        mov esi D$RoutingMap, edi D$RoutingMapCopy, ecx D$DisTableLength
        shr ecx 2 | rep movsd
        mov esi D$SizesMap, edi D$SizesMapCopy, ecx D$DisTableLength
        shr ecx 2 | rep movsd
    pop ecx, edi, esi
ret

ExchangeDisTables:
    sub esi D$RoutingMap
    Exchange D$SectionsMap D$SectionsMapCopy
    Exchange D$RoutingMap D$RoutingMapCopy
    Exchange D$SizesMap D$SizesMapCopy
    Exchange D$EndOfSectionsMap D$EndOfSectionsMapCopy
    Exchange D$EndOfRoutingMap D$EndOfRoutingMapCopy
    Exchange D$EndOfSizesMap D$EndOfSizesMapCopy
    add esi D$RoutingMap
ret

ReleaseDisTablesCopies:
    VirtualFree D$SectionsMapCopy, D$RoutingMapCopy, D$SizesMapCopy
ret


; Code Recognitions over > Everything not yet Flaged is Data:

FillDataSection:
    mov esi D$SectionsMap | add esi D$FirstSection
    mov edx D$EndOfSectionsMap

;mov eax esi | sub eax D$SectionsMap | add eax D$DisImageBase
;    hexprint eax

    While esi < edx

        ;mov eax esi | sub eax D$SectionsMap | add eax D$UserPeStart | sub eax D$FirstSection
        ;On eax = 04081E4, hexprint DATAFLAG


        .If B$esi = 0
            mov B$esi DATAFLAG

          ; Force a dummy EVOCATED, at start of any Data Chunk, for the output:
            If B$esi-1 <> DATAFLAG
                mov ebx esi | sub ebx D$SectionsMap | add ebx D$RoutingMap
                or B$ebx EVOCATED+LABEL
            End_IF

        .End_If

        inc esi

    End_While

   ; mov eax esi | sub eax D$SectionsMap | add eax D$DisImageBase
   ; hexprint eax
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
    Code Recognition of a [Start --- End] un-accessed Code Chunk. Positive recognition
    occur when:
    
    * begins with a 'PUSH_EBP' Routing Flaged Instruction ('@PUSH_EBP')
    * end with a CHUNKEND ('@CHUNKEND')
    * not produce any 'DB' in Disassembly ('@DB')
    * have a positive Likely/Unlikely Code weight Value ('LikelyCode', 'UnLikelyCode')
    * have less than 20% of zeroed Bytes ('@Zeros')
    * be big enough for any bet ('@Size')
    
    Terrific problem of 'tuning', with all of this. So, the recognition tends to say
    it is really Code when it is very likely Code (better failing at flaging valid
    Code than flaging wrong Code as valid...).
;;

[LikelyCode: ?  UnLikelyCode: ? SimpleScan: ?    LastUnAccessed: ?
 StopAtCall: ?  StopAtEndOfChunk: ?  DisEndOfChunkEncounted: ? UnlikelyCodeFoundAt: ?]

Proc IsItCode:
    Arguments @Start, @End, @Required
    Local @OpNumber

    mov B$SimpleScan &TRUE ; Prevents 'WriteDisRelative' from modifying Routing Flags.
    mov B$DisEndOfChunkEncounted &FALSE

    mov D$LikelyCode 0, D$UnLikelyCode 0, B$DisEndOfChunk &FALSE, D@OpNumber 0

    mov eax D@Start | sub eax D$UserPeStart | add eax D$RoutingMap

    mov ecx D@End | On ecx > D$UserPeEnd, move D@End D$UserPeEnd

    mov esi D@Start, edi D$CodeSource

    .If B$esi = 0
        mov ecx esi
        add ecx 2
        On ecx >= D$UserPeEnd, jmp L2>
        If W$esi+1 = 0
L2:            mov eax &FALSE | jmp L9>>
        End_If
    .End_If


    .While esi < D@End
        mov B$DisFlag 0

        mov D$SegmentOverride 0, B$AddressSizeOverride 0, B$OperandSizeOverride 0
        mov W$DisSizeMarker 'D$', B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
        mov D$LastCodeRef 0, B$LeaInstruction &FALSE

        mov D$LastUnAccessed esi
;If B$TestNow = 1
;    mov eax esi | sub eax D$UserPeStart | add eax D$DisImageBase
;    On eax = 0401899, int3
;End_If

L0:     movzx eax B$esi | inc esi | call D$DisOp1+eax*4 | inc D@OpNumber

        ;mov ecx D@Required | On D@OpNumber >= ecx, jmp L2>

        .If B$StopAtCall = &TRUE
            If B$CALLInstruction = &TRUE
                mov eax D$LastUnAccessed | On B$eax = 0E8, mov B$DisEndOfChunk &TRUE
            End_If
        .End_If

        If D$UnLikelyCode > 0
L1:         mov eax D$LastUnAccessed | sub eax D$UserPeStart | add eax D$DisImageBase
            mov D$UnlikelyCodeFoundAt eax
            mov eax &FALSE | jmp L9>>
        Else_If B$DisFlag = DISFAILED
            mov eax &FALSE | jmp L9>
        Else_If B$DisEndOfChunk = &TRUE
            mov B$DisEndOfChunkEncounted &TRUE
            On B$StopAtEndOfChunk = &TRUE, jmp L2>
            mov ecx D@Required | On D@OpNumber >= ecx, jmp L2>
        End_If

        If B$DisFlag = DISDONE
            jmp L0<<
        Else_If B$LockPrefix = &TRUE
          ; DISDONE+DISLINEOVER, but LOCK not taken by a valid LOCKable Instruction:
            mov B$LockPrefix &FALSE | jmp L1<
        End_If

    .End_While

L2: mov eax &TRUE

L9: mov B$SimpleScan &FALSE

    On eax = &TRUE, mov D$LastUnAccessed esi
EndP
____________________________________________________________________________________________

[StartOfDisLine: ?    AlignedComment: ?    NonAccessedByteWritten: ?]

[DisFailure: ?  DisFailureType: ?   EncountedFlag: ?  AttemptSuccess: ?]

DisassemblingAttempt:
    mov B$DisFailure &FALSE, D$DisFailureType 0, B$NewAccessedLocations &FALSE
    mov B$LockPrefix &FALSE

  ; esi > 'SectionsMap' new CODEFLAG attempt when called. So:
    sub esi D$SectionsMap | add esi D$UserPeStart

L0: mov edi D$CodeSource, D$LastCodeRef 0
    mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
    mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
    mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
    mov B$CALLInstruction &FALSE, B$DisEndOfChunk &FALSE

  ; Parse onlyCODEFLAGed (in SectionsMap) and ACCESSED (in RoutingMap) Locations:
L1: mov eax esi | sub eax D$UserPestart | add eax D$SectionsMap

    Test B$eax CODEFLAG | jnz L2>
        If B$eax <> 0
            ;On B$TestNow = 1, hexprint 1
            mov D$DisFailureType 1
            mov B$DisFailure &TRUE | ret
        End_If
        inc esi | On esi = D$UserPeEnd, jmp L9>>
            jmp L1<

L2:
  ; Is it still a new Location when comparing to the original Table? Yes > Quit:
    sub eax D$SectionsMap | add eax D$SectionsMapCopy | On B$eax = CODEFLAG, ret

    sub eax D$SectionsMapCopy | add eax D$RoutingMap
    test B$eax ACCESSED | jnz L3>
        inc esi | On esi = D$UserPeEnd, jmp L9>>
            jmp L1<

      ; Call for the Disassembly Routines:
L3:     or B$eax INSTRUCTION

        movzx eax B$esi | mov D$TestLastLocation esi | inc esi

        call D$DisOp1+eax*4

        While B$DisFlag = DISDONE
            movzx eax B$esi | inc esi | call D$DisOp1+eax*4
        End_While

        If B$LockPrefix = &TRUE
            mov B$LockPrefix &FALSE | add B$UnlikelyCode 50
        End_If

      ; The instruction must not cover a valid Label:
        mov eax D$TestLastLocation | inc eax
        mov ebx eax | sub ebx D$UserPeStart | add ebx D$RoutingMap
        While eax < esi
            test B$ebx INSTRUCTION+NODE+LABEL | jz L3>
                mov D$DisFailureType 2 | mov B$DisFailure &TRUE | ret
L3:         inc eax | inc ebx
        End_While

      ; If a CALL or a JMP was Disassembed, the decoding Routines return this Flag set on.
      ; We mark the RoutingMap's according Byte as a new Entry Point:
        ...If B$CALLInstruction = &TRUE
            mov B$CALLInstruction &FALSE

            If B$EscapePrefix <> &TRUE
                mov eax D$TestLastLocation
                On B$eax = 0E8, call IsItNoReturnCall ; OpE8
            End_If

            mov eax D$LastCodeRef | sub eax D$DisImageBase | add eax D$SectionsMap
            On eax < D$SectionsMap, jmp L4>>
            On eax > D$EndOfSectionsMap, jmp L4>>
            test B$eax VIRTUALFLAG+IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+DATAFLAG | jnz L4>>
            jmp L5>

L4:         mov D$DisFailureType 3 | mov B$DisFailure &TRUE | ret

L5:         If B$eax = CODEFLAG
                sub eax D$SectionsMap | add eax D$RoutingMap
                cmp B$eax 0 | je L5>
                test B$eax INSTRUCTION+CHUNKEND | jnz L3>>
                    mov D$DisFailureType 4 | mov B$DisFailure &TRUE | ret

L5:             sub eax D$RoutingMap | add eax D$SectionsMap
; This is not out of logic to re-scan the Code: We are in Try&See actions.
            End_If

            push esi, eax
                sub eax D$SectionsMap | add eax D$UserPeStart
                mov ebx eax | add ebx 100
                push D$DisEndOfChunk
                    call IsItCode eax, ebx, 1
                pop D$DisEndOfChunk
                If eax = &FALSE
                    pop eax, esi
                    mov D$DisFailureType 5 | mov B$DisFailure &TRUE | ret
                End_If
            pop eax, esi

            mov B$eax CODEFLAG
            sub eax D$SectionsMap | add eax D$RoutingMap | test B$eax ACCESSED | jnz L3>
                mov B$NewAccessedLocations &TRUE
L3:         or B$eax NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
        ...End_If

      ; CHUNKEND Flag marks the first Byte *after* a RET or a JMP:
L4:     mov eax esi | sub eax D$UserPeStart | add eax D$RoutingMap
        If B$DisEndOfChunk = &TRUE
            or B$eax CHUNKEND | dec eax | mov B$DisEndOfChunk &FALSE | ret ; <<<< new
        End_If

        mov ebx eax | sub ebx D$RoutingMap | add ebx D$SectionsMap
        .If B$ebx = 0
            ; OK
        .Else_If B$ebx <> CODEFLAG
            mov D$DisFailureType 6 | mov B$DisFailure &TRUE | ret
        .End_If

      ; Now Flaged *backward* 'ACCESSED' the Bytes of the new disassembled Instruction,
      ; including the very first Byte of the new coming Instruction, if this one is
      ; not a CHUNKEND (we have 'dec eax' up there in such cases):
L4:     test B$eax ACCESSED | jnz L6>>
            mov ecx D$TestLastLocation | sub ecx D$UserPeStart | add ecx D$RoutingMap

L4:         or B$eax ACCESSED | mov D$NewAccessedLocations &TRUE
            mov ebx eax | sub ebx D$RoutingMap | add ebx D$SectionsMap
            .If B$ebx = 0
                mov B$ebx CODEFLAG
            .Else_If B$ebx <> CODEFLAG
                mov al B$ebx, B$EncountedFlag al
                mov D$DisFailureType 7 | mov B$DisFailure &TRUE | ret
            .End_If
            sub ebx D$SectionsMap | add ebx D$SizesMap
            If B$ebx <> 0
                mov D$DisFailureType 8 | mov B$DisFailure &TRUE | ret
            End_If

L5:         dec eax

            If eax >= ecx
                test B$eax ACCESSED | jz L4<<
            End_If

L6: If B$DisFlag = DISLINEOVER+DISDONE
        On esi < D$UserPeEnd, jmp L0<<
    Else_If B$DisFlag = DISFAILED
        mov D$DisFailureType 9 | mov B$DisFailure &TRUE | ret
    End_If

  ; Adjust the ProgressBar is wanted:
    If esi > D$NextDisBarPos
        mov eax esi | add eax D$DisBarStep | mov D$NextDisBarPos eax
        call BarProgress
    End_If

  ; Cases of B$DisFlag = DISDONE only (Prefixes, ...):
    On esi < D$UserPeEnd, jmp L1<<

  ; Loop it all until no more new accessed Code Chunks are found:
L9: mov D$NextDisBarPos 0
    If B$NewAccessedLocations = &TRUE
        mov edi D$CodeSource, esi D$UserPeStart
        add esi D$FirstSection
        mov D$NewAccessedLocations &FALSE, D$LastCodeRef 0 | jmp L0<<
    End_If
ret
____________________________________________________________________________________________

[ZeroedEnd: ?    NextDisTITLE: ?   StartOfDataChunks: ?]

DisassembleAndWrite:
    mov B$NonAccessedByteWritten &FALSE, B$LabelWritten &FALSE, D$ZeroedEnd 0
    mov esi D$UserPeStart, D$TestLastLineLocation 0

    NextDisLine

L0: mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
    mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
    mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
    mov B$CALLInstruction &FALSE, B$LeaInstruction &FALSE, B$LabelWritten &FALSE
    mov D$LastCodeRef 0

    mov D$Prefixes 0

    On edi > D$NextDisTITLE, call WriteDisTITLE

  ; Parse only CODEFLAGed Chunks:
L1: mov eax esi | sub eax D$UserPestart | add eax D$SectionsMap

    If B$eax = DATAFLAG
        call WriteOneDataChunksAsFound eax | On esi >= D$UserPeEnd, jmp L9>>
        jmp L1<

    Else_If B$eax = VIRTUALFLAG
        call WriteOneDataChunksAsFound eax | On esi >= D$UserPeEnd, jmp L9>>
        jmp L1<

    Else
        mov D$StartOfDataChunks 0

    End_If

    Test B$eax CODEFLAG | jnz L2>
        inc esi | On esi = D$UserPeEnd, jmp L9>>
            jmp L1<<

L2: mov ebx esi | sub ebx D$UserPeStart | add ebx D$RoutingMap

    Test B$ebx EVOCATED | jz L3>
        push ebx
            call WriteDisCodeLabel
        pop ebx
        mov B$edi CR, B$edi+1 LF, D$edi+2 '    ' | add edi 6

      ; Just to force non ACCESSED DB here:
        mov B$NonAccessedByteWritten &FALSE, B$LabelWritten &TRUE

L3: test B$ebx ACCESSED | jnz L3>
        .If B$NonAccessedByteWritten = &FALSE
            If B$LabelWritten = &FALSE
                push ebx
                    call WriteDisCodeLabel | NextDisLine
                pop ebx
            End_If
            push ebx
                call WriteDBandData
            pop ebx
            cmp B$ItWasAlignment &TRUE | je L0<<
            cmp B$NonAccessedByteWritten &FALSE | je L4>
        .End_If
        mov B$edi-2 ';' | jmp L4>

L3: mov B$NonAccessedByteWritten &FALSE

L4: mov D$StartOfDisLine esi, D$AlignedComment edi | add D$AlignedComment 32

    movzx eax B$esi | inc esi
    push esi
        call D$DisOp1+eax*4
            While B$DisFlag = DISDONE
                movzx eax B$esi | inc esi | call D$DisOp1+eax*4
            End_While
        End_If
    pop ebx

  ; Was a real NODE eaten by the Decoding? If yes, go back and re-parse:
  ; Should be no more used since the implementation of upper 'DisAlignedToData':
    While ebx < esi
        mov eax ebx | sub eax D$UserPeStart | add eax D$RoutingMap
        Test B$eax NODE | jz L4>
            call BadDecode | mov esi ebx
            push esi
                call WriteDisCodeLabel | NextDisLine
            pop esi
            jmp L0<<
L4:     inc ebx
    End_While

  ; Adjust the ProgressBar is wanted:
    If esi > D$NextDisBarPos
        mov eax esi | add eax D$DisBarStep | mov D$NextDisBarPos eax
        call BarProgress
    End_If

    If B$DisFlag = DISLINEOVER+DISDONE
        On B$WithCommentedHexa = &TRUE, call CommentHexa
        NextDisLine

    Else_If B$DisFlag = DISDONE
        On esi < D$UserPeEnd, jmp L1<<

    Else_If B$DisFlag = DISFAILED
        push esi, eax
            mov esi D$StartOfDisLine
            call WriteDisCodeLabel
        pop eax, esi
        mov D$edi ' DB ' | add edi 4
        call LoadedOpToHexa | stosw
            NextDisLine
    End_If

    On esi < D$UserPeEnd, jmp L0<<

L9: If D$ZeroedEnd <> 0
        mov edi D$ZeroedEnd, D$edi 0
    End_If
ret
____________________________________________________________________________________________

[RegisterClassStructure: 'Data0403060' 0, 0, 0, 0
 LastRegisterClass: 0   ClassEx: 0]

; Searching downward for "call 'USER32.RegisterClassA'" (or ClassExA):

SearchRegisterClass:
    mov esi D$LastRegisterClass, D$ClassEx 0
  ; 'ClassEx' is for Searching by Structure (Ex >>> one more dWord first for Size).
    While esi < D$SourceEnd
        ...If D$esi = 'Regi'
            ..If D$esi+4 = 'ster'
                .If D$esi-13 = 'call'
                    If D$esi+8 = 'Clas'
                        On W$esi+13 = 'Ex', mov D$ClassEx 4
                        mov D$LastRegisterClass esi | add D$LastRegisterClass 12 | jmp L9>
                    End_If
                .End_If
            ..End_If
        ...End_If
        inc esi
    End_While

    mov D$LastRegisterClass 0

L9: ret
____________________________________________________________________________________________

;;
  The preceeding Instruction may be "push Dataxxx". If found by the ".While", ok. If 
  not found (End of Line encounted), we give a try to previous Instructions in a scope
  of 1000 Bytes (Source Bytes...), that could eventually be some "mov eax Dataxxxx".
;;

[CodeToMainWindowProc: ?]

SearchUpperCodeToMainWindowProc: ret
  ; Upper Instruction was not "push Dataxxx".
  ; Example: push esp >>> try to find some upper 'Code0405060' (very rude...):

    mov esi D$LastRegisterClass

    While B$esi <> CR | dec esi | End_While

    mov ecx 0,  edx 1000 | On B$WithCommentedHexa = &TRUE, mov edx 3000

L0: .While esi > D$CodeSource
        ..If D$esi = 'Code'
          ; Don't confuse with a call, a jump or a Comment:
            On B$esi-2 = ';', jmp L3>
            On D$esi-5 = 'call', jmp L3>
            On D$esi-4 = 'jmp ', jmp L9>

          ; Don't confuse with a Code Label Declaration:
            mov eax esi
            While B$esi <> ':'
L1:             inc esi
                .If B$esi <= ' '
                  ; Is the mainWindowProc candidate first Instruction "push ebp"?
                    call IsThisPushEbp
                    If B$ThisIsEbp = &TRUE
                        mov D$CodeToMainWindowProc eax | jmp L9>>
                    End_If
                .End_If
            End_While

L2:         mov esi eax
        ..End_If

L3:     dec esi | inc ecx | cmp ecx edx | ja L9>
    .End_While

L9: ret


[ThisIsEbp: ?]

IsThisPushEbp:
    mov B$ThisIsEbp &FALSE
    pushad
      ; eax points to the 'Codexxxx' (// esi is on the Byte after).
        add eax 4 | mov edi D$EndOfDisData

        .While edi < D$SourceEnd
            ...If D$edi = 'Code'
                add edi 4 | mov esi eax, ecx 10
                repe cmpsb
                cmp B$edi-1 ':' | jne L2>
                cmp B$esi-1 ' ' | ja L2>
                    While B$edi <> LF | inc edi | End_While
                    While B$edi <= ' ' | inc edi | End_While
                    .If D$edi = 'push'
                        If D$edi+4 = ' ebp'
                            mov B$ThisIsEbp &TRUE | jmp L9>
                        End_If
                    .End_If
                    jmp L9>>
                ..End_If

            ...End_If

L2:         inc edi

        .End_While

L9: popad
ret


SearchMainWindowProc:
    mov esi D$EndOfDisData, ebx 4, D$LastRegisterClass esi, D$CodeToMainWindowProc 0,
            D$MainWindowProcIsThere 0

L0: call SearchRegisterClass

    ...If D$LastRegisterClass <> 0
      ; A "call 'USER32.RegisterClass...'" has been found.
      ; Is MainWindowProc written directely in the RegisterClass Structure?
        call GetMainWindowProcFromStructure

      ; If not, search for any possible 'Code0405060' in the close upper Lines:
        If D$CodeToMainWindowProc = 0
            call SearchUpperCodeToMainWindowProc
        End_If

        If D$CodeToMainWindowProc <> 0
            call WriteMainWindowProc
        Else
            jmp L0<
        End_If

    ...End_If
ret
____________________________________________________________________________________________

;;
  Menus: Usually, 0111 (&WM_COMMAND) in D$ebp+12 // ID in W$ebp+16. Failure Message if not.
;;

[WM_COMMAND_Found: ?]

MenuIdsSubstitutions:
    mov B$WM_COMMAND_Found &FALSE

    On D$MainWindowProcIsThere = 0, ret

  ; 'PrepareDisMenuIDs' Builds the Table of Menu Ids Declaration ready to insert:
    call PrepareDisMenuIDs | call WriteDisMenuIDs

    mov esi D$MainWindowProcIsThere, edx D$SourceEnd

    .While esi < edx
          ; Search for a &WM_COMMAND:
;;
; Example:
  mov eax D$ebp+0C
    cmp eax 01
    
Code040112B: N9: | jne K0>  ; Code04011A4
;;
        ...If D$esi = 'p+0C'

            If D$esi+5 = '0111'
                add esi 5 | jmp L1>
            End_If
L0:         While D$esi <> 'cmp '
                inc esi | On esi >= edx, jmp L9>>
            End_While
            add esi 5
            While B$esi > ' '
                inc esi | On esi >= edx, jmp L9>>
            End_While
            inc esi

            ..If D$esi = '0111'
L1:             .If B$esi-1 <= ' '
                    If B$esi+4 <= ' '
                    ; Example:
                    ; Code0401230: I0:
                    ;     cmp eax 0111 | jne Code04018D1
                        mov ebx esi | sub ebx 2
                        While B$ebx > ' ' | dec ebx | End_While
                        On D$ebx-3 = 'cmp ', jmp L5>>
                    End_If
                .End_If

            ..Else
;;
                  ; Not a '0111' Case >>> Search the 'jne ' >>> Get the next Label:
                    While D$esi <> 'jne '
                        inc esi | On esi >= edx, jmp L9>>
                    End_While
                    While D$esi <> 'Code'
                        inc esi | On esi >= edx, jmp L9>>
                    End_While
                    add esi 7 | lodsd
        
L1:                 While D$esi <> eax
                        inc esi | On esi >= edx, jmp L9>>
                    End_While
                    add esi 4 | On B$esi <> ':', jmp L1<
;;
            ..End_If

            jmp L0<<

       ...End_If

        inc esi
    .End_While

    call 'USER32.MessageBoxA' D$hwnd, {"WM_COMMAND not found:
  
You cannot edit the Resources Main Menu, if any   ", 0},
                                {'Menu IDs substitution failure', 0}, 0
    ret

L5: push esi
        call SaveOriginalMenuIDs
    pop esi

    call DisReplace esi, 4, {'&WM_COMMAND', 0}, 11

    call SubstituteMainMenuIDs

    mov B$WM_COMMAND_Found &TRUE
L9: ret

;;
  Menu ID Equates in 'DataForClipEquates'
  Original Equates in 'OriginalMenuIDs'
  esi yet pointing '0111' (&WM_COMMAND) in the Source
;;
SubstituteMainMenuIDs:
;;
  esi yet pointing the &WM_COMMAND Location:
  
  cmp eax &WM_COMMAND | jne Code04018D1
      mov eax D$ebp+010
      cmp ax 0M00_Calculate_
    
Code0401242: J8: | jne Code040142B
;;
    While B$esi <> '|' | inc esi | End_While
    While W$esi <> ' j' | inc esi | End_While | inc esi

    If D$esi <> 'jne '
        call 'USER32.MessageBoxA' D$hwnd, {'Unexpected MainWindowProc Main Menu Messages Cases organisation', 0},
                                {'Failure of Main Menu IDs substitutions', 0}, 0
        ret
    End_If

  ; Store the end of the Label Name closing the &WM_COMMAND Case in edx ('Text'):
    add esi 9 | While B$esi > ' ' | inc esi | End_While
    mov edx D$esi-4

L0: ..While D$esi <> edx
        inc esi

        ...If D$esi = '$ebp'
            ..If D$esi+4 = '+010'
                If D$esi-5 = 'cmp '
                    add esi 8 | jmp A5>
                End_If
                add esi 8
L1:             While D$esi <> 'cmp '
                    inc esi | On esi = D$SourceEnd, jmp L9>>
                End_While

                add esi 5 | On D$esi = '$ebp', jmp L1<

                While B$esi > ' ' | inc esi | End_While

A5:             .If W$esi = ' 0'
                    add esi 2 | mov ebx 0
                    push esi
L2:                     lodsb | cmp al ' ' | jbe L2>
                        sub al '0' | On al > 9, sub al 7
                        shl ebx 4 | or bl al | jmp L2<
L2:                 pop esi
                    dec esi

                  ; Possible ID in eax. Is it in 'OriginalMenuIDs':
                    If ebx <> 0
                        mov eax ebx, edi OriginalMenuIDs, ecx 100 | repne scasd
                    Else
                        mov ecx 0
                    End_If

                    If ecx > 0
                      ; One Based Indice of Menu ID in ecx (1 is M00_Menu):
                        sub ecx 100 | neg ecx
                        mov edi DataForClipEquates | inc edi

                        While ecx > 0
L3:                         inc edi | cmp B$edi ' ' | ja L3<    ; An Equate Name
L3:                         inc edi | cmp B$edi ' ' | jna L3<   ; Spaces
L3:                         inc edi | cmp B$edi ' ' | ja L3<    ; An Equate Value
L3:                         inc edi | cmp B$edi ' ' | jna L3<   ; Spaces
                            dec ecx
                        End_While

                      ; Length of Equate Name in ebx
                        mov ebx 0
                        While B$edi+ebx > ' ' | inc ebx | End_While
                        On B$edi+ebx-1 = ']', dec ebx
                      ; Length of Original Source Equate Value in ecx
                        mov ecx 0
                        While B$esi+ecx > ' ' | inc ecx | End_While

                        call DisReplace esi, ecx, edi, ebx
                    End_If
                .End_If

                While D$esi <> 'jne '
                    inc esi | On esi = D$SourceEnd, jmp L9>>
                End_While
                While D$esi <> 'Code'
                    inc esi | On esi = D$SourceEnd, jmp L9>>
                End_While

                While B$esi > ' ' | inc esi | End_While
                mov eax D$esi-4
L6:             While D$esi <> eax
                    inc esi | On esi = D$SourceEnd, jmp L9>>
                End_While
                add esi 4 | cmp B$esi ':' | jne L6<

                jmp L1<<
            ..End_If
        ...End_If
    ..End_While

    add esi 4 | cmp B$esi ':' | jne L0<<
L9: ret


; For replacing small words on the fly:

Proc DisReplace:
    Arguments @SourcePos, @DelLength, @Insert, @InsertLength
    Uses esi, edi, ecx

        add D$SourceLen 400 | add D$SourceEnd 400
        mov eax D@InsertLength

        .If eax > D@DelLength
            mov esi D$SourceEnd, edi esi
            add edi D@InsertLength | sub edi D@DelLength
            mov ecx esi | sub ecx D@SourcePos | std | rep movsb | cld

            mov esi D@Insert, edi D@SourcePos, ecx D@InsertLength
            rep movsb

        .Else
            mov esi D@Insert, edi D@SourcePos, ecx D@InsertLength
            rep movsb

            If eax < D@DelLength
                mov esi D@SourcePos | add esi D@DelLength
                mov ecx D$SourceEnd | sub ecx esi
                rep movsb
            End_If

        .End_If

        mov eax D@InsertLength | sub eax D@DelLength
        sub D$SourceLen 400 | add D$SourceLen eax
        sub D$SourceEnd 400 | add D$SourceEnd eax
EndP


[OriginalMenuIDs: ? #100]
; 'uMenu' comments
; We read the original Menu Items IDs yet in the new MenuEx Table:

SaveOriginalMenuIDs: ; Original IDs at +8?   'PrepareDisMenuIDs'  'TurnThisMenuToExType'
    mov D$MenulistPtr MenuList, esi MenuList        ; (ID / Ptr / Size)

    mov eax D$esi, ecx D$esi+8, esi D$esi+4
    inc eax | mov D$FirstMenuId eax

    mov D$EndOfDisMenu esi | add D$EndOfDisMenu ecx

  ; Header:  'uMenu'
    add esi 8

    mov edi OriginalMenuIDs, eax 0, ecx 100 | rep stosd

    mov edi OriginalMenuIDs, edx 0, D$SeparatorsNumber 0, D$PopUpNumber 0

L0: movzx eax W$esi+8
    .If eax = 0             ; No ID >>> Separator or PopUp
        If W$esi+12 = 0     ; Separator (8 zeroed Words)
            add esi 16 | On esi < D$EndOfDisMenu, jmp L0<
                jmp L9>
        Else                ; PopUp (+4 is the Added 'HelpID' for Popups Items only)
            add esi 14
            While W$esi <> 0 | add esi 2 | End_While | add esi 2+4
            Align_On 4, esi
        End_If

    .Else
        stosd
L1:     add esi 14
        If esi < D$EndOfDisMenu
            While W$esi <> 0 | add esi 2 | End_While | add esi 2
            Align_On 4, esi
        Else
L9:         mov D$edi 0 | ret
        End_If

    .End_If

    On esi < D$EndOfDisMenu, jmp L0<

____________________________________________________________________________________________

[MenuCharsSet: B$ '&<>=?@0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.' 0
 MenuCharsLen: D$ len   MenuChar: B$ 0]

; Is a Char valid for Naming The Menu IDs?:

MenuChars:
        push ecx, edi
            mov ecx D$MenuCharsLen, edi MenuCharsSet, B$MenuChar &FALSE
            repne scasb | jnz L9>
                mov B$MenuChar &TRUE
L9:     pop edi, ecx
ret
____________________________________________________________________________________________

[MenuReadPointer: ?   EndOfDisMenu: ?    DisItemFlag: ?]

PrepareDisMenuIDs:  ; 'ClipEquates', 'ForceMenusExType', 'TurnThisMenuToExType'

    mov D$MenulistPtr MenuList, esi MenuList        ; (ID / Ptr / Size)

  ; Temporary consider the first Menu, the Main one.
  ; Add Checking for the Main Window Menu later.
    mov eax D$esi, ecx D$esi+8, esi D$esi+4

  ; Kill the High Bit saying that this is a Pointer to the name of a Named ID, if any:
    and eax 0FFFF

    inc eax | mov D$FirstMenuId eax

    mov D$EndOfDisMenu esi | add D$EndOfDisMenu ecx

    mov D$MenuEquateIndice 'M00_'
    mov eax D$MenulistPtr | sub eax MenuList
    mov ebx 12, edx 0 | div ebx                 ; > indice = 0, 1, 2, ...
    mov ebx 10, edx 0 | div ebx
    add B$MenuEquateIndice+2 dl
    mov edx 0 | div ebx
    add B$MenuEquateIndice+1 dl

  ; Header:  'uMenu'
    add esi 8 | mov D$MenuReadPointer esi

    mov edi DataForClipEquates, edx 0, D$SeparatorsNumber 0, D$PopUpNumber 0
    mov al '[' | stosb | mov D$StartOfItemsLine edi

    mov eax D$MenuEquateIndice | stosd | mov eax 'Menu' | stosd

    dec D$FirstMenuID | call WriteClipIDvalue | inc D$FirstMenuID

L0: push edi
        mov edi OneItemString, esi D$MenuReadPointer
        add esi 14
        movzx eax W$esi-2 | and eax (not &MF_END) | mov D$DisItemFlag eax

        .If esi < D$EndOfDisMenu
            While W$esi <> 0
L1:             lodsw
                    call MenuChars | On B$MenuChar = &FALSE, mov al '_'
                stosb
            End_While | lodsw | stosb
            On D$DisItemFlag <> 0, add esi 4
            Align_On 4, esi | mov D$MenuReadPointer esi
        .Else
            pop edi
            While B$edi-1 <= ' ' | dec edi | End_While
            mov al ']' | stosb | mov al 0 | stosb | ret
        .End_If
    pop edi

    mov esi OneItemString

    While B$esi = tab
        inc esi
    End_While
    If B$esi = 0
        inc D$SeparatorsNumber | inc edx | jmp L0<<
    End_If

    If D$DisItemFlag <> 0
        inc D$PopUpNumber | inc edx | jmp L0<<
    End_If

T0: mov esi OneItemString, eax D$MenuEquateIndice | stosd
    While B$esi <= ' '
        lodsb                                           ; strip leading tabs and spaces
    End_While

L3: lodsb | cmp al 0 | je L4>
        On al = '&', jmp L3<                            ; do not write '&'
        On al = tab  , jmp L4>                          ; do not write 'hot keys'
        On al < '0', mov al '_'
        If al = '_'
            On B$edi-1 = '_', jmp L3<                   ; only one '_' at a time
        End_If
        stosb | jmp L3<                                 ; name

L4: call WriteClipIDvalue | inc edx | jmp L0<<

____________________________________________________________________________________________

[TempoSource: ?]

; Writes the [Menus IDs] into the Source.

WriteDisMenuIDs:
    mov ecx D$SourceLen | add ecx 1_000_000
    VirtualAlloc TempoSource ecx

  ; Make a temporary Copy:
    mov esi D$CodeSource, edi D$TempoSource, ecx D$SourceLen

    Align_On 4 ecx | shr ecx 2 | rep movsd

  ; Now Tempo >>> Original Source (simpler than killing all associated Variables)
  ; (edx = How many added Bytes):

    mov edi D$MainWindowProcIsThere, esi edi
    sub esi D$CodeSource | add esi D$TempoSource

  ; Start the Insert after a CRLF:
    While W$edi-2 <> CRLF | dec edi | dec esi | End_While

  ; Kep track of the original Source Last Chunk length:
    mov ebx D$SourceEnd | sub ebx edi

    mov al '_'
    mov ecx DRAWLINELEN | rep stosb | mov W$edi CRLF | add edi 2
    mov ecx DRAWLINELEN | rep stosb | mov D$edi CRLF2 | add edi 4

    mov edx (DRAWLINELEN+2+DRAWLINELEN+4)

    push esi
        mov esi DataForClipEquates

        While B$esi <> 0 | movsb | inc edx | End_While
    pop esi

    mov D$edi CRLF2 | add edi 4 | add edx 4

    mov ecx ebx | add ecx 400       ; Security CRLFs Tail
    rep movsb

    add D$SourceLen edx | add D$SourceEnd edx

    VirtualFree D$TempoSource
ret

____________________________________________________________________________________________
;;
  See if the Line before "call 'USER32.RegisterClassA'" is some "push Dataxxxx", 
  wich would provide the Structure Pointer:
;;
GetMainWindowProcFromStructure:
    mov esi D$LastRegisterClass
    While B$esi <> CR | dec esi | End_While
    While B$esi <> LF | dec esi | End_While
    While B$esi <= ' ' | inc esi | End_While
    On D$esi <> 'push', jmp L9>>

    add esi 5 | mov edi RegisterClassStructure
    While B$esi > ' ' | movsb | End_While | mov B$edi 0
;;
  At this point we know the Structure is declared in Data or ?Data. It may either be
  filled at write time or at run time. See first if the second (or third) Member of
  the Structure provides directely the 'MainWindowProc' label:
;;
    mov esi RegisterClassStructure, edi D$CodeSource
    call FirstDisSearch | On edi >= D$SourceEnd, jmp L9>>
    inc edi
    If D$ClassEx = 4
        While B$edi <> ':' | inc edi | End_While | inc edi
    End_If
    While B$edi <> ':' | inc edi | End_While
    add edi 2
    If D$edi = 'Code'
        mov D$CodeToMainWindowProc edi | jmp L9>>
    End_If
;;
  The MainWindowProc Label was not written directely in the Structure. It is filled
  at run time. Is the Structure Record accessed from somewhere in the Source? We first
  Add 4 or 8 to the pushed Label found when calling 'USER32.RegisterClass...' 
  (RegisterClassEx Structure has one dword for size in first Pos), and re-run a search
  of this Label evocation in Code:
;;
    .If B$ClassEx = 4
        mov esi RegisterClassStructure | While B$esi+1 <> 0 | inc esi | End_While
L0:     mov al B$esi | sub al '0' | On al > 9, sub al 7 | add al B$ClassEx
        If al > 0F
            mov bl al | sub al 010 | mov bl 1
        Else
            mov bl 0
        End_If
        add al '0' | On al > '9', add al 7 | mov B$esi al
        If bl > 0
            dec esi | jmp L0<
        End_If
    .End_If

    mov esi RegisterClassStructure, edi D$EndOfDisData | call FirstDisSearch

    .While edi < D$SourceEnd
        While B$edi <> ' ' | inc edi | End_While | inc edi

        If D$edi = 'Code'
            mov D$CodeToMainWindowProc edi | ret
        Else
            mov esi RegisterClassStructure | call NextDisSearch
        End_If
    .End_While
L9: ret


[MainWindowProcIsThere: ?]

WriteMainWindowProc:
L1: mov esi D$CodeToMainWindowProc, edi RegisterClassStructure
    While B$esi > ' ' | movsb | End_While
    On B$edi-1 = ']', dec edi
    mov B$edi ':', B$edi+1 0

    mov esi RegisterClassStructure, edi D$EndOfDisData | call FirstDisSearch

    mov D$MainWindowProcIsThere edi

  ; Make room for CRLF 'MainWindowProc: ':
    push edi
        mov esi D$SourceEnd | add esi 400
        mov ecx esi | sub ecx edi | inc ecx
        mov edi esi | add edi 18
        std | rep movsb | cld
        add D$SourceEnd 18 | add D$SourceLen 18
    pop edi

    mov W$edi CRLF | add edi 2
    mov D$edi 'Main', D$edi+4 'Wind', D$edi+8 'owPr', D$edi+12  'oc: '

L9: ret
____________________________________________________________________________________________

[NumberOfDisTitles: ?]

WriteDisTITLE:  ; 'DisTitle'
    push esi
        mov esi DisTitle
        .If B$DisTitle+13 = '9'
            mov B$DisTitle+13 'A'
        .Else
            inc B$DisTitle+13
            If B$DisTitle+13 = '['
                mov B$DisTitle+13 '0' | inc B$DisTitle+12
            End_If
        .End_If
        While B$esi <> 0 | movsb | End_While
    pop esi

    mov eax edi | add eax (TITLE_MAX/2) | mov D$NextDisTITLE eax

    mov D$edi '    ' | add edi 4
ret

____________________________________________________________________________________________
;;
  Problem: When Pointers to either Code or Data are found inside Data, we have to
  choose if they effectively are Pointers or not. It is statistically possible that
  what appears to possiblily be a Pointer, be nothing else but the result of random
  Needless to say, the bigger size the targetted File is, the more chances we have
  for a wrong interpretation.
  
  In such case, wrongly interpreting a random flow of Bytes as a Pointer is not
  catastrophic. The reverse is... : Say we have a dWord like 040301A that we suspect
  to be a Code Pointer. Now, if we do not validate the 'Code040301A' interpretation,
  the Application will hang after re-compilation, because what was located at 040301A
  in the original file has no chance to be at the same Address after re-compilation
  (because of Code size variations across various Compiler, because of PE Sections
  ordering, and so on...). I other words, once re-compiled, 'Code040301A' Value will
  not be 040301A (unless the targetted File had been builded with RosAsm).
  
  So, the better way is to validate those Pointers each time it is possible, when
  interpreting and writing the Data.
  
  For Data Pointers to Data, there is zero problem. In the worst cases, we may, for
  example, induce a no use Data Label, that will, fore example, cut a String presentation,
  into 2 sub-Strings, but this will not change a thing for the re-Compilation. Only
  the Data content (in place of that Pointer will be wrong, and user can restore it
  from the Label Name, if necesary, by hand).
  
  For Code, the problem is about not cutting into the middle of a valid Instruction.
  This is why, before runing 'CheckPointersInData', we have first run
  'DisassembleForIntructions' one shot (for having all Instructions Flaged INSTRUCTION).
  
  Here, we simply Flag the Data Part of RoutingMap, with INDIRECT, for making the 
  interpretations easier. We verify, also that any Pointer to Code does
  not break an Instruction into two. So, the possibilities for wrongly validating a 
  Pointer to Code is divided by 3 or 4...
;;

CheckPointersInData:
    mov esi D$SectionsMap, edx D$EndOfSectionsMap | sub edx 4
    add esi D$FirstSection

    .While esi < edx
    mov eax esi | sub eax D$SectionsMap | add eax D$DisImageBase

        ...If B$esi =  DATAFLAG
          ; We read the dWord Values of each Data in the PE:
L1:         mov eax esi | sub eax D$SectionsMap | add eax D$UserPeStart
            mov eax D$eax | sub eax D$DisImageBase | add eax D$UserPeStart
          ; Is it pointing somewhere inside the PE?
            ..If eax > D$UserPeStart
                .If eax < D$UserPeEnd
                    call IsItTruePointer | cmp eax 0 | je L5>>

                  ; Yes, say it in SizesMap:
                    mov ebx esi | sub ebx D$SectionsMap | add ebx D$SizesMap
                    or B$ebx POINTER

                  ; Yes > read the Pointer Section Flag:
                    sub eax D$UserPeStart | add eax D$SectionsMap
                    mov bl B$eax | and bl CODEFLAG+DATAFLAG+VIRTUALFLAG | jz L5>>
                        sub eax D$SectionsMap | add eax D$RoutingMap
                        or B$eax EVOCATED
                        If bl = CODEFLAG
                            test B$eax INSTRUCTION | jz L5> ; Do not kill a valid instruction.
                              ; Write the Code Routing Map:
                                or B$eax NODE+ACCESSED+LABEL
                              ; Write the Data Routing Map:
L2:                             mov eax esi |  sub eax D$SectionsMap | add eax D$RoutingMap
                                or B$eax INDIRECT
                                add esi 3       ; +1 down here > next dWord.
                        Else_If bl = DATAFLAG
                          ; Do not destroy a valid Data Type: ???
                            mov eax esi |  sub eax D$SectionsMap | add eax D$SizesMap
                          ;  cmp D$eax 0 | jne L5>
                            sub eax D$SizesMap | add eax D$RoutingMap
;;
  Problem: For Erde, it needs 'INDIRECT'. For the big File it needs 'EVOCATED'.
  This should indicate a problem in the Data outputing...
;;
                            or B$eax INDIRECT ;+EVOCATED+LABEL
                            add esi 3
                        End_If
                .End_If
            ..End_If
        ...End_If

L5:     inc esi
    .End_While

  ; Now, force a dummy Label to be outputed at the first and after last INDIRECT
  ; references (first and last of a flow of pointers, in order to ease the Data
  ; interpretations output, and group in one single set, flows of Pointers).
    mov esi D$SectionsMap | add esi D$FirstSection

    .While esi < edx
        If B$esi = DATAFLAG
            mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap

            test B$eax INDIRECT | jz L5>
                mov D$eax LABEL+EVOCATED+INDIRECT  ; 04A
L1:             add eax 4 | add esi 4
                test B$eax INDIRECT | jz L3>
                test B$eax LABEL+EVOCATED | jnz L3>
                    mov D$eax 0 | jmp L1<
L2:
L3:             or B$eax LABEL+EVOCATED

        Else
L5:         inc esi
        End_If

    .End_While
ret
____________________________________________________________________________________________

;;
  In RosAsm Assembler, the Table Sizes (usually zeroed Tables), are limited,
  on purpose (they could as well not be limited...), to push the users to good
  programming practices. So, in the Disassembler we need a Routine for splitting
  these too big Tables, by emitting (forcing) a dummy Label, that has no other
  purpose but forcing the Assembler to eat such demential Tables, and to kill the limitation.
;;

SplitBigData:
    mov esi D$SectionsMap, edx D$EndOfSectionsMap | add esi D$FirstSection
    mov ebx esi | sub ebx D$SectionsMap | add ebx D$RoutingMap

    .While esi < edx
        mov al B$esi

        .If al = DATAFLAG
            mov ecx 4
            While B$esi = al
                inc esi | inc ecx | inc ebx | On esi >= edx, ret
                test B$ebx EVOCATED+LABEL | jz L1>
                    mov ecx 4

L1:             If ecx >= LOOPDATAMAX
                    mov ebx esi | sub ebx D$SectionsMap | add ebx D$RoutingMap
                    or B$ebx LABEL+EVOCATED
                    ;sub ebx D$RoutingMap | add ebx D$DisImageBase | hexprint ebx
                    mov ecx 4
                End_If
            End_While

        .Else_If al = VIRTUALFLAG
            mov ecx 4
            While B$esi = al

                inc esi | inc ecx | inc ebx | On esi >= edx, ret
                test B$ebx LABEL | jz L1>
                    mov ecx 4

L1:             If ecx >= LOOPVDATAMAX
                    mov ebx esi | sub ebx D$SectionsMap | add ebx D$RoutingMap
                    or B$ebx LABEL+EVOCATED
                    ;sub ebx D$RoutingMap | add ebx D$DisImageBase | hexprint ebx
                    mov ecx 4
                End_If
            End_While

        .End_If

        inc esi | inc ebx

    .End_While
ret
____________________________________________________________________________________________

FlagsCoherency:
    mov esi D$SizesMap, edx D$EndOfSizesMap | add esi D$FirstSection
    mov ebx esi | sub ebx D$SizesMap | add ebx D$RoutingMap

    .While esi < edx
        mov eax ebx | sub eax D$RoutingMap | add eax D$SectionsMap
        On B$eax <> DATAFLAG, jmp L2>>

        test B$esi FP4 | jz L1>
            ;call IsLabelInsideFp 4
            and D$ebx 0FF
            mov D$esi 0, B$esi FP4 | jmp L2>>
            ;mov B$esi FP4 | jmp L2>>

L1:     test B$esi FP8 | jz L1>
            ;call IsLabelInsideFp 8
            and D$ebx 0FF | mov D$ebx+4 0
            mov D$esi 0, D$esi+4 0, B$esi FP8 | jmp L2>>

            ;mov B$esi FP8 | jmp L2>>

L1:     test B$esi FP10 | jz L1>
            ;call IsLabelInsideFp 10
            and D$ebx 0FF | mov D$ebx+4 0, W$ebx+8 0
            mov D$esi 0, D$esi+4 0, W$esi+8 0, B$esi FP10 | jmp L2>
           ;mov B$esi FP10 | jmp L2>>

L1:     test B$esi DWORD | jz L1>
            ;call IsDwordString | On eax = &TRUE, jmp L2>
            ;and D$ebx 0FF
            mov B$esi DWORD | jmp L2>

L1:     Test B$esi STRINGS | jz L1>
            mov al POINTER+DWORD | not al | and B$esi al

L1:     Test B$esi POINTER | jz L2>
;;
            push ebx
                sub ebx D$RoutingMap | add ebx D$UserPeStart | mov eax D$ebx
                sub eax D$DisImageBase | add eax D$SectionsMap
                On eax < D$SectionsMap, jmp L4>
                On eax > D$EndOfSectionsMap, jmp L4>
                   ; If B$eax = CODEFLAG
                   ;     sub eax D$SectionsMap | add eax D$RoutingMap
                   ;     test B$eax INSTRUCTION | jnz L3>

L4:                         ;pop ebx | push ebx
                            ;sub ebx D$RoutingMap | add ebx D$DisImageBase
                            ;hexprint ebx
                            ;mov D$MapingBase ebx
                            ;map

                            xor B$esi POINTER
                   ; End_If
L3:         pop ebx
;;
L2:     inc esi | inc ebx
    .End_While
ret


[LabelInsideFP: ?]

;;
  FP Data may be crossed over by Strings Recognitions.
  
  In such cases, the FP is Prevalent, and we push the String Label downward.
;;

Proc IsLabelInsideFp:
    Argument @N

        mov B$LabelInsideFP &FALSE

      ; ebx >>> RoutingMap, first FP Byte.
        mov eax 1, ecx D@N | dec ecx

L0:     test B$ebx+eax LABEL | jz L1>
            mov B$LabelInsideFP &TRUE
L1:     inc eax | loop L0<

        On B$LabelInsideFP = &TRUE, or B$ebx+eax LABEL
EndP
____________________________________________________________________________________________

Proc FlagsCleaner:
    pushad
        mov ecx D$SectionsMap, edx D$EndOfSectionsMap, esi D$RoutingMap, ebx D$SizesMap
        mov eax (not (INSTRUCTION+NODE+EXPORTNODE+PUSH_EBP))

        .While ecx < edx
          ; Data cannot assume any of these Routing Flags:
            If B$ecx = DATAFLAG
                xor al EXPORTNODE
                and B$esi al
                xor al EXPORTNODE

          ; Same for VirtualData:
            Else_If B$ecx = VIRTUALFLAG
                and B$esi al

          ; Code cannot assume any Size Flag:
            Else_If B$ecx = CODEFLAG
                mov B$ebx 0

            End_If

            inc ecx, esi, ebx

        .End_While
    popad
EndP
____________________________________________________________________________________________

;;
  eax points to a supposed Pointer in the PE data section.
  Might not be a true Pointer but, as well, a String, unicode String, or anything else.
;;

IsItTruePointer:
    pushad
      ; esi points to 'SectionsMap'. Read the real PE Value:
        sub esi D$SectionsMap | add esi D$UserPeStart | mov eax D$esi

      ; Do not break any Label:
        mov ebx esi | sub ebx D$UserPeStart | add ebx D$RoutingMap
        test D$ebx ((LABEL shl 24)+(LABEL shl 16)+(LABEL shl 8)) | jz L1>
            and B$ebx (not INDIRECT)
            popad | mov eax 0 | ret

      ; First, do not break any identifed Data Type:
L1:     mov ebx esi | sub ebx D$UserPeStart | add ebx D$SizesMap
        If D$ebx <> 0
            popad | mov eax 0 | ret
        End_If



      ; Do not break an Evocated Ascii String:
        mov edx D$TruthAsciiTable
        mov eax 0 | add esi 3 | add ebx 3 | mov al B$esi

        push esi, ebx
            While B$edx+eax = GOODASCII
                If B$ebx <> 0
                    test B$ebx BYTE | jz L2>
                        or B$ebx STRINGS
                        pop ebx, esi | popad | mov eax 0 | ret
                End_If

                dec esi | dec ebx
                mov al B$esi
            End_While

L2:     pop ebx, esi

      ; Do not break an Evocated Unicode String:
        mov al B$esi
        If al = 0
            dec esi | dec ebx
            mov al B$esi
        End_If

        While B$edx+eax = GOODASCII
            On B$esi+1 <> 0, jmp L2>

            If B$ebx <> 0
                test B$ebx WORD | jz L2>
                    or B$ebx STRINGS
                    popad | mov eax 0 | ret
            End_If

            sub esi 2
            dec ebx | cmp B$ebx 0 | jne L2>
            dec ebx

            mov al B$esi
        End_While

L2:
    popad
ret
____________________________________________________________________________________________


CheckZeroEndedString:
    push edx
        mov ebx eax | sub ebx D$SectionsMap | add ebx D$UserPeStart
        mov edx D$TruthAsciiTable, eax 0

        push ebx
L0:         mov al B$ebx | inc ebx
            cmp B$edx+eax GOODASCII | je L0<
        pop eax

        cmp B$ebx-1 0 | ja L9>
        sub ebx eax | cmp ebx 5 | jb L9>

          ; Valid String found: Flag the String:
            sub eax D$UserPeStart | add eax D$RoutingMap | or B$eax STRINGS+BYTE
          ; FLAG the Pointer:
            mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap | or B$eax POINTER

            add esi 3
L9: pop edx
ret
____________________________________________________________________________________________

WriteLabelFromEsi:
    On esi = D$LastWrittenLabel, ret
    mov ebx esi | sub ebx D$UserPeStart | add ebx D$DisImageBase
            push ebx
            mov ax 0A0D | stosw
            mov D$edi 'Code' | add edi 4
            push 0-1
L0:         mov eax ebx | shr ebx 4 | and eax 0F
            add eax '0' | On eax > '9', add eax 7
            push eax
            cmp ebx 0 | ja L0<
            mov B$edi '0' | inc edi
L0:         pop eax | cmp eax 0-1 | je L9>
            mov B$edi al | inc edi | jmp L0<
L9:         mov W$edi ': ' | add edi 2
        pop eax
        call WriteLocalLabelFromEax
ret


[ItWasAlignment: ?]

; In: ebx (> eax) > RoutingMap // esi > CodeTest // edi > CodeSource
WriteDBandData:
    mov B$ItWasAlignment &FALSE
  ; May be Valid Code, but not ACCESSED:
; (This first part should no more be of any use).
    test B$ebx PUSH_EBP | jz L1>
        push ebx
L0:         inc ebx | cmp ebx D$EndOfRoutingMap | je L0>
            test B$ebx ACCESSED | jnz L0>
                mov eax ebx | sub eax D$RoutingMap | add eax D$UserPestart
                .If B$eax = 05D                 ; pop ebp
                    If B$eax+1 = 0C3            ; ret
                        inc ebx
                        mov ecx ebx | pop ebx | call ReFlagNonaccessed ; | jmp L9>>
                        mov B$NonAccessedByteWritten &FALSE, B$LabelWritten &FALSE | ret
                    Else_If B$eax+1 = 0C2   ; ret n (n dWord aligned)
                        Test B$eax+2 00_11 | jnz L0>
                            add ebx 3
                            mov ecx ebx | pop ebx | call ReFlagNonaccessed ; | jmp L9>>
                            mov B$NonAccessedByteWritten &FALSE, B$LabelWritten &FALSE | ret
                    End_If
                .End_If
            jmp L0<
L0:     pop ebx

  ; May be a 'NOP' or 'Int 3', or... , Alignment:
L1: call AlignRecognition

    If B$ItWasAlignment = &TRUE
        mov D$edi 'Alig', W$edi+4 'n ' | add edi 6
        move D$edi D$Alignement | add edi 4
        mov D$StartOfDisLine esi | add esi D$Alignementlenght
        On B$WithCommentedHexa = &TRUE, call CommentHexa
        NextDisLine | jmp L9>>
    End_If

L2: mov eax ebx
    push esi
       ; If B$LabelWritten = &FALSE
            push eax
                call WriteLabelFromEsi | NextDisLine
            pop eax
       ; End_If
;;
pushad
mov eax esi | sub eax D$UserPeStart | add eax D$DisImageBase
On eax = 0401354, int3
popad
;;
        call WriteDisCodeLabel
      ; Durty: Need a version without the CRLFs:
        While B$edi <> ':' | dec edi | End_While | inc edi
        mov B$edi ' ' | inc edi

        mov edx eax, ecx 0
        mov D$edi 'DB  ' | add edi 3

L0:     test B$edx ACCESSED | jnz L5>  ; 01F
        test B$edx EVOCATED | jz L3>
            pushad
                call WriteDisCodeLabel
            popad
           ; mov B$edi CR, B$edi+1 LF, D$edi+2 '    ' | add edi 6

L3:         movzx eax B$esi | inc esi
            If eax < 010
                mov D$edi '    ' | inc edi
                On eax = 0, inc edi
            End_If
            call WriteEax
            mov B$edi ' ' | inc edi | inc ecx
            If ecx = 20
                mov B$edi-1 ','
                NextDisLine | mov D$edi '    ' | add edi 3
                mov ecx 0
            End_If
            inc edx
            If edx < D$EndOfRoutingMap
                test B$edx EVOCATED | jnz L5>
                jmp L0<
            End_If

L5:     On D$edi-3 = '    ', sub edi 3 ; <--- Probably stupid.
        NextDisLine
        mov ecx esi
    pop esi

    sub ecx esi | jecxz L9>
    mov ebx esi | call WriteCommentedAsciiData | NextDisLine
    .If B$ItWasReallyAscii = &FALSE
        If ecx > 3
            call WritedCommentedWordsData | NextDisLine
        End_If
    .End_If

L9: mov B$NonAccessedByteWritten &TRUE, B$LabelWritten &FALSE
ret

;;
[AlignNop: B$ 090
 AlignInt3: 0CC
 AddB_eaxAl: 0 0
 LeaEspLong: 08D 0A4 024 0 0 0 0    ; lea esp D$esp+00 >>> 8D A4 24 00 00 00 00
 LeaEsiLong: 08D 0B4 026 0 0 0 0    ; lea esi D$esi+00 >>> 8D B4 26 00 00 00 00
 LeaEsp: 08D 064 024 0              ; lea esp D$esp+00 >>> 8D 64 24 00 
 LeaEcx: 08D 049 0                  ; lea ecx D$ecx+00 >>> 8D 49 00 
 LeaEbx: 08D 09B 0 0 0 0            ; lea ebx D$ebx+00 >>> 8D 9B 00 00 00 00
 AddEax0: 05 0 0 0 0                ; add eax 0 >>> 05 00 00 00 00 
 MovEdiEdi: 08B 0FF                 ; mov edi edi >>> 8B FF 
 MovEsiEsi: 089 0F6                 ; mov esi esi >>> 89 F6 
 ]

[AlignTable: AlignNop 1, AlignInt3 1, AddB_eaxAl 2, LeaEspLong 7, LeaEsp 4, LeaEcx 3,
             LeaEbx 6, AddEax0 5, MovEdiEdi 2
             0 0]
;;

[AlignTablePointer: ?    Alignement: ?   Alignementlenght: ?]

AlignRecognition:
    mov B$ItWasAlignment &FALSE
    pushad
      ; esi > UserPe
      ; ebx > RoutingMap . How many Bytes?
        mov ecx 0
L0:     test B$ebx ACCESSED | jnz L1>
            inc ecx | inc ebx | cmp ebx D$EndOfRoutingMap | jb L0<

L1:   ; ecx = How many Bytes unaccessed.
        On ecx = 0, jmp L9>>

        mov D$Alignementlenght ecx

        .If ecx > 0100
            jmp L9>>
        .Else_If ecx > 080
            test ebx 00_1111_1111 | jnz L9>>
                mov D$Alignement '0100'
        .Else_If ecx > 040
            test ebx 00_0111_1111 | jnz L9>>
                mov D$Alignement '080 '
        .Else_If ecx > 020
            test ebx 00_0011_1111 | jnz L9>>
                mov D$Alignement '040 '
        .Else_If ecx > 010
            test ebx 00_0001_1111 | jnz L9>>
                mov D$Alignement '020 '
        .Else_If ecx > 08
            test ebx 00_1111 | jnz L9>>
                mov D$Alignement '010 '
        .Else_If ecx > 04
            test ebx 00_0111 | jnz L9>>
                mov D$Alignement '08  '
        .Else  ; _If ecx > 0
            test ebx 00_0011 | jnz L9>>
                mov D$Alignement '04  '
        .End_If

        mov B$ItWasAlignment &TRUE
L9: popad
ret

;;
  Supposed no more use Instructions checking, because, at that stage, if no pointer
  has been found anywhere in the File to this Location, we can suppose this is neither
  Code nor Data, and that, anyway, even if it was not Alignment, this interpretation
  would not change a thing: The rebuilt would be wron,g in any case. So...
;;
L0:     lodsb

        ..If al = 090                   ; nop
            dec ecx | cmp ecx 0 | ja L0<

        ..Else_If al = 0CC              ; int 3
            dec ecx | cmp ecx 0 | ja L0<

        ..Else_If al = 0
            If B$esi = 0                ; add B$eax al >>> 0 0
                inc esi | sub ecx 2 | jc L9>>
                cmp ecx 0 | ja L0<
            End_If
           ; dec esi
           ; While B$esi = 0
           ;     inc esi | dec ecx | jc L9>>
           ; End_While
           ; cmp ecx 0 | ja L0<

        ..Else_If al = 08D              ; lea esp D$esp+00 >>> 8D A4 24 00 00 00 00
            .If D$esi = 024A4
                If W$esi+4 = 0
                    add esi 6 | sub ecx 7 | jc L9>>
                    cmp ecx 0 | ja L0<
                End_If

            .Else_If D$esi = 0B6       ; lea esi D$esi >>> 8D B6 00 00 00 00
                                       ; LeaEsiLong2 --> Guga
                If B$esi+4 = 0
                    add esi 5 | sub ecx 6 | jc L9>>
                    cmp ecx 0 | ja L0<<
                End_If
            .Else_If D$esi = 026B4      ; lea esi D$esi+00 >>> 8D B4 26 00 00 00 00
                If W$esi+4 = 0
                    add esi 6 | sub ecx 7 | jc L9>>
                    cmp ecx 0 | ja L0<<
                End_If
            .Else_If D$esi-1 = 024648D  ; lea esp D$esp+00 >>> 8D 64 24 00
                add esi 3 | sub ecx 4 | jc L9>>
                cmp ecx 0 | ja L0<<
            .Else_If D$esi = 09B        ; lea ebx D$ebx+00 >>> 8D 9B 00 00 00 00
                If B$esi+4 = 0
                    add esi 5 | sub ecx 6 | jc L9>>
                    cmp ecx 0 | ja L0<<
                End_If
            .Else_If W$esi = 049        ; lea ecx D$ecx+00 >>> 8D 49 00
                add esi 2 | sub ecx 3 | jc L9>>
                cmp ecx 0 | ja L0<<
            .Else_If W$esi = 040        ; lea eax D$eax+00 >>> 8D 40 00
                add esi 2 | sub ecx 3 | jc L9>>
                cmp ecx 0 | ja L0<<
            .End_If

        ..Else_If al = 05               ; add eax 0 >>> 05 00 00 00 00
            If D$esi = 0
                add esi 4 | sub ecx 5 | jc L9>>
                cmp ecx 0 | ja L0<<
            End_If

        ..Else_If al = 089              ; mov esi esi >>> 89 F6
            If B$esi = 0F6
                inc esi | sub ecx 2 | jc L9>>
                cmp ecx 0 | ja L0<<
            End_If

        ..Else_If al = 08B              ; mov edi edi >>> 8B FF
            If B$esi = 0FF
                inc esi | sub ecx 2 | jc L9>>
                cmp ecx 0 | ja L0<<
            Else_If B$esi = 0C0         ; mov eax eax >>> 8B C0
                inc esi | sub ecx 2 | jc L9>>
                cmp ecx 0 | ja L0<<
            End_If
        ..End_If

L5:     On ecx = 0, mov B$ItWasAlignment &TRUE

L9: popad
ret

____________________________________________________________________________________________

;;
  After having analyzed all possible Code, but, before the Negative Recogition,
  if a complete Section holds nothing but Data, we can bet that it is a true
  Data Section, without any Code inside.
  
  Seems to be of little help.
;;

OldFlagTrueDataSection:
    mov ecx D$DisNumberOfSections

    GetPeHeader SectionsHeaders

L0: mov ebx D$eax+SECTION_FLAG
    test ebx &IMAGE_SCN_MEM_EXECUTE | jnz L1>>

    ...If ebx = &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
        push eax, ecx
            mov esi D$eax+SECTION_RVA | add esi D$SectionsMap
            mov edx D$eax+SECTION_RVASIZE
            mov ebx D$eax+SECTION_FILESIZE
            On edx < ebx, xchg edx ebx
            add edx esi | add ebx esi

            push esi, ebx, edx
                .While esi < ebx
                    .If B$esi <> 0
                        If B$esi <> DATAFLAG
                        ;sub esi D$SectionsMap | add esi D$DisImageBase |
                       ; mov D$MapingBase esi | map
                           ; sub esi D$SectionsMap | add esi D$DisImageBase
                           ; hexprint esi

                           ; pop edx, ebx, esi
                           ; sub edx D$SectionsMap | add edx D$DisImageBase
                           ; sub ebx D$SectionsMap | add ebx D$DisImageBase
                           ; sub esi D$SectionsMap | add esi D$DisImageBase
                           ; hexprint esi, ebx, edx
                           ; map
                            movzx eax B$esi | On eax = CODEFLAG, jmp L5>
                            pop eax, eax, eax, ecx, eax | jmp L1>>
                        End_If
                    .End_If

                    inc esi

                .End_While
L5:         pop edx, ebx, esi

          ; If here, this Section holds nothing but data. Flag it all:
            While esi < ebx
                mov B$esi DATAFLAG | inc esi
            End_While
            While esi < edx
                mov B$esi VIRTUALFLAG | inc esi
            End_While

        pop ecx, eax

    ...End_If

L1: add eax SECTIONHEADERSIZE | dec ecx | jnz L0<< ;loop L0<
ret


FlagTrueDataSection:
    mov ecx D$DisNumberOfSections

    GetPeHeader SectionsHeaders

L0: mov ebx D$eax+SECTION_FLAG | test ebx &IMAGE_SCN_MEM_EXECUTE | jnz L8>>

    ...If ebx = &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
        push eax, ecx
            mov esi D$eax+SECTION_RVA | add esi D$SectionsMap
            mov edx D$eax+SECTION_RVASIZE
            mov ebx D$eax+SECTION_FILESIZE
            On edx < ebx, xchg edx ebx
            add edx esi | add ebx esi

            push esi, ebx, edx
                .While esi < ebx
                    .If B$esi <> 0
                        If B$esi = DATAFLAG
                            ; OK.
                        Else_If B$esi = VIRTUALFLAG
                            ; OK.
                        Else
                            pop eax, eax, eax, ecx, eax | jmp L8>>
                        End_If
                    .End_If

                    inc esi

                .End_While

L5:         pop edx, ebx, esi

          ; If here, this Section holds nothing but data. Flag it all:
            While esi < ebx
                mov B$esi DATAFLAG | inc esi
            End_While
            While esi < edx
                mov B$esi VIRTUALFLAG | inc esi
            End_While

        pop ecx, eax

    ...End_If

L8: add eax SECTIONHEADERSIZE | dec ecx | jnz L0<<
ret

____________________________________________________________________________________________

DisAlign:
    mov esi D$SectionsMap | add esi D$FirstSection

    .While esi < D$EndOfSectionsMap
        ...If B$esi = CODEFLAG
            While B$esi = CODEFLAG
                inc esi | On esi >= D$EndOfSectionsMap, ret
            End_While

            ..If B$esi = 0
                mov ebx esi | inc esi
                While B$esi = 0
                    mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap
                    test B$eax LABEL | jnz L9>
                    inc esi | On esi >= D$EndOfSectionsMap, ret
                End_While

                .If B$esi = CODEFLAG
                    mov edx esi, ecx edx | sub ecx ebx

                    push esi, ebx
                        sub ebx D$SectionsMap | add ebx D$RoutingMap
                        mov esi ebx | sub esi D$RoutingMap | add esi D$UserPeStart
                        call AlignRecognition
                    pop ebx, esi

                    If B$ItWasAlignment = &TRUE
                        mov edi ebx, al CODEFLAG | rep stosb
                    End_If

                .End_If
            ..End_If
        ...End_If

L9:     inc esi
    .End_While
ret
____________________________________________________________________________________________

[NoDirectString: "; No direct Access found to this valid Code Chunk:
    "
 NoDirectStringLength: len]

ReFlagNonaccessed:
    push esi, ecx
        mov esi NoDirectString, ecx D$NoDirectStringLength
        sub edi 2 | rep movsb
    pop ecx, esi

  ; ebx > Start // ecx > End of Chunk that may be forced to ACCESSED, once the
  ; 'NoDirectString' Comment has been written:
    push edi
        sub ecx ebx | inc ecx | mov edi ebx, al ACCESSED | rep stosb
    pop edi
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

[Prefixes: ?]

CommentHexa:
   ; mov al CR | stosb | mov al LF | stosb ;;; for Ret and ret n:
    If W$edi-2 = 0A0D
        sub edi 2
    End_If
    mov al ' ' | While edi < D$AlignedComment | stosb | End_While

    mov D$edi '  ; ' | add edi 4

    mov ebx D$StartOfDisLine ;| sub ebx D$Prefixes |
    mov D$Prefixes 0

    While ebx < esi
        movzx eax B$ebx | inc ebx
        mov ecx eax | shr ecx 4
        and eax 0F | and ecx 0F
        mov al B$HexaTable+eax, cl B$HexaTable+ecx
        shl eax 8 | or eax ecx | or eax 020200000 | stosd | dec edi
    End_While
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; StringsMap jobs

; Example: call GetStringsMap RoutingMap, esi

Proc GetStringsMapSymbol:
    Argument @Map, @Pointer
    Uses esi

        mov eax D@Pointer | sub eax D@Map | shl eax 2 | mov esi D$eax ; Wrong!!!

        If esi <> 0
            mov B$edi '_' | inc edi
            While B$esi > ' ' | movsb | End_While
        End_If
EndP




TITLE VB

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  Special case of VB compiled PEs. The first Instructions of a VB PE are:
  
  > push Vb6Header
  > call 'MSVBVM50.064'
  
  The VB Header is a Structure that is saved in Code, and that discribes the
  organisation of the File:
  
  [VB6HEADER:|Vbsignature B 4|CompilerVersion W|SzLangDLL B 14|SzSecLangDLL B 14|
  RuntimeDLLVersion W|LanguageID D|BackupLanguageID D|
  >>> SubMain <<< D| >>> ProjectInfo <<< D|
  Flag2 W|Flag3 W|Flag4 D|ThreadSpace B|Const1 B|Flag5 W|Flag6 W|Flag7 W|FormCount W|
  ExternalComponentCount W|Flag8 B|Flag9 B|Flag10 W|DialogStructureGUI D|
  ExternalComponentTable D|Project D|ProjectExename D|ProjectTitle D|HelpFile D|
  ProjectName D|Flag11 D|Flag12 D|Flag13 D|Flag14 W
  
  
  Main Routine: 'MarkVbPe'
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

; VB6HEADER Structure (Displacements Equates):

[VBdis.VbsignatureDis 0
 VBdis.CompilerVersionDis 4
 VBdis.SzLangDLLDis 6
 VBdis.SzSecLangDLLDis 20
 VBdis.RuntimeDLLVersionDis 34
 VBdis.LanguageIDDis 36
 VBdis.BackupLanguageIDDis 40
 VBdis.SubMainDis 44
 VBdis.ProjectInfoDis 48
 VBdis.Flag2Dis 52
 VBdis.Flag3Dis 54
 VBdis.Flag4Dis 56
 VBdis.ThreadSpaceDis 60
 VBdis.Const1Dis 61
 VBdis.Flag5Dis 62
 VBdis.Flag6Dis 64
 VBdis.Flag7Dis 66
 VBdis.FormCountDis 68
 VBdis.ExternalComponentCountDis 70
 VBdis.Flag8Dis 72
 VBdis.Flag9Dis 73
 VBdis.Flag10Dis 74
 VBdis.DialogStructureGUIDis 76
 VBdis.ExternalComponentTableDis 80
 VBdis.ProjectDis 84
 VBdis.ProjectExenameDis 88
 VBdis.ProjectTitleDis 92
 VBdis.HelpFileDis 96
 VBdis.ProjectNameDis 100
 VBdis.Flag11Dis 104
 VBdis.Flag12Dis 108
 VBdis.Flag13Dis 112
 VBdis.Flag14Dis 116
 VB_HEADER_LEN 118]


; For flaging the 'SizesMap':

 [VBsizes:
 VBsizes.Vbsignature: B$ BYTE+STRINGS #4
 VBsizes.CompilerVersion: W$ WORD
 VBsizes.SzLangDLL: B$ BYTE #14
 VBsizes.SzSecLangDLL: B$ BYTE #14
 VBsizes.RuntimeDLLVersion: W$ WORD
 VBsizes.LanguageID: D$ DWORD
 VBsizes.BackupLanguageID: D$ DWORD
 VBsizes.SubMain: D$ DWORD
 VBsizes.ProjectInfo: D$ DWORD
 VBsizes.Flag2: W$ WORD
 VBsizes.Flag3: W$ WORD
 VBsizes.Flag4: D$ DWORD
 VBsizes.ThreadSpace: B$ BYTE
 VBsizes.Const1: B$ BYTE
 VBsizes.Flag5: W$ WORD
 VBsizes.Flag6: W$ WORD
 VBsizes.Flag7: W$ WORD
 VBsizes.FormCount: W$ WORD
 VBsizes.ExternalComponentCount: W$ WORD
 VBsizes.Flag8: B$ BYTE
 VBsizes.Flag9: B$ BYTE
 VBsizes.Flag10: W$ WORD
 VBsizes.DialogStructureGUI: D$ DWORD
 VBsizes.ExternalComponentTable: D$ DWORD
 VBsizes.Project: D$ DWORD
 VBsizes.ProjectExename: D$ DWORD
 VBsizes.ProjectTitle: D$ DWORD
 VBsizes.HelpFile: D$ DWORD
 VBsizes.ProjectName: D$ DWORD
 VBsizes.Flag11: D$ DWORD
 VBsizes.Flag12: D$ DWORD
 VBsizes.Flag13: D$ DWORD
 VBsizes.Flag14: W$ WORD]


; For Flaging the 'RoutingMap':

 [VBrouting:
 VBrouting.Vbsignature: D$ EVOCATED+LABEL
 VBrouting.CompilerVersion: W$ EVOCATED+LABEL
 VBrouting.SzLangDLL: B$ 0 #14
 VBrouting.SzSecLangDLL: B$ 0 #14
 VBrouting.RuntimeDLLVersion: W$ EVOCATED+LABEL
 VBrouting.LanguageID: D$ EVOCATED+LABEL
 VBrouting.BackupLanguageID: D$ EVOCATED+LABEL
 VBrouting.SubMain: D$ EVOCATED+LABEL+POINTER ; >>> Flag the pointed to Code later
 VBrouting.ProjectInfo: D$ EVOCATED+LABEL
 VBrouting.Flag2: W$ EVOCATED+LABEL
 VBrouting.Flag3: W$ EVOCATED+LABEL
 VBrouting.Flag4: D$ EVOCATED+LABEL
 VBrouting.ThreadSpace: B$ EVOCATED+LABEL
 VBrouting.Const1: B$ EVOCATED+LABEL
 VBrouting.Flag5: W$ EVOCATED+LABEL
 VBrouting.Flag6: W$ EVOCATED+LABEL
 VBrouting.Flag7: W$ EVOCATED+LABEL
 VBrouting.FormCount: W$ EVOCATED+LABEL
 VBrouting.ExternalComponentCount: W$ EVOCATED+LABEL
 VBrouting.Flag8: B$ EVOCATED+LABEL
 VBrouting.Flag9: B$ EVOCATED+LABEL
 VBrouting.Flag10: W$ EVOCATED+LABEL
 VBrouting.DialogStructureGUI: D$ EVOCATED+LABEL+POINTER
 VBrouting.ExternalComponentTable: D$ EVOCATED+LABEL
 VBrouting.Project: D$ EVOCATED+LABEL
 VBrouting.ProjectExename: D$ EVOCATED+LABEL
 VBrouting.ProjectTitle: D$ EVOCATED+LABEL
 VBrouting.HelpFile: D$ EVOCATED+LABEL
 VBrouting.ProjectName: D$ EVOCATED+LABEL
 VBrouting.Flag11: D$ EVOCATED+LABEL
 VBrouting.Flag12: D$ EVOCATED+LABEL
 VBrouting.Flag13: D$ EVOCATED+LABEL
 VBrouting.Flag14: W$ EVOCATED+LABEL]


; ToDo: Implied SectionsMap Flags. Example, 'SubMain': At the DWORD >>> CODE

____________________________________________________________________________________________
____________________________________________________________________________________________

MarkVbPe:
    mov eax D$DisEntryPoint | sub eax D$DisImageBase | add eax D$UserPeStart
    mov esi D$eax+1 | sub esi D$DisImageBase | add esi D$UserPeStart
    On D$esi <> 'VB5!', ret

  ; Mark the VB Header Flags in the Tables. First, the 'SectionsMap' to Data:
    mov edi esi | sub edi D$UserPeStart | add edi D$SectionsMap
    mov ecx VB_HEADER_LEN, al DATAFLAG | rep stosb

  ; Routing Map according 'VB6HeaderRouting':
    mov eax esi | sub eax D$UserPeStart | add eax D$RoutingMap
    mov B$eax ACCESSED+LABEL
    push esi
        mov edi eax,  esi VBrouting, ecx VB_HEADER_LEN | rep movsb
    pop esi

  ; Sizes Map according 'VB6HeaderSizes':
    sub eax D$RoutingMap | add eax D$SizesMap
    push esi
        mov edi eax,  esi VBSizes, ecx VB_HEADER_LEN | rep movsb
    pop esi

    add esi VBdis.SubMainDis

    mov eax D$esi | sub eax D$DisImageBase | add eax D$SectionsMap
    If eax < D$SectionsMap
        ; nop (There are VB PEs without any direct Code inside).
    Else_If eax < D$EndOfSectionsMap
        mov B$eax CODEFLAG
        sub eax D$SectionsMap | add eax D$RoutingMap
        mov B$eax INSTRUCTION+EVOCATED+LABEL+ACCESSED+PUSH_EBP
    End_If

    add esi VBdis.ProjectInfoDis ; >>> ProjectInfo Data

    mov eax D$esi | sub eax D$DisImageBase | add eax D$SectionsMap
    If eax < D$SectionsMap
        ; nop (There are VB PEs without any direct Code inside).
    Else_If eax < D$EndOfSectionsMap
        mov B$eax DATAFLAG
        sub eax D$SectionsMap | add eax D$RoutingMap
        mov B$eax LABEL+ACCESSED
    End_If
ret










TITLE DisData

;;
  Write all Data and VirtualData, at once, at the Top of Source.

  3Dfun:
  
  [Data0404040: D$ 0 #03
                 D$ Data0404093]
  [<Data040404D: B$ "@@"]
  [<Data040404F: B$ 0]
  [Data0404050: B$ "Software\Chris Dragan\"]
  
  0408290 non flaged Resources 'IMAGE_RESOURCES_DATA_ENTRY'
;;

;;
; Obsolete
WriteAllDisData:
    mov esi D$SectionsMap | add esi D$FirstSection
    mov edx D$EndOfSectionsMap

L0: .While esi < edx
        test B$esi DATAFLAG+VIRTUALFLAG | jz L9>
            mov cl B$esi
            mov ebx esi, eax esi
            sub ebx D$SectionsMap | add ebx D$RoutingMap

L1:         inc ebx | inc esi | cmp esi edx | jae L2>
            If B$esi = cl
                test B$ebx LABEL+EVOCATED | jz L1<
            End_If

L2:         sub eax D$SectionsMap | add eax D$SizesMap
            sub ebx D$RoutingMap | add ebx D$SizesMap

            If cl = VIRTUALFLAG
                call WriteOneVirtualDataChunk, eax, ebx
            Else
                call WriteOneDataChunk eax, ebx
            End_If

            jmp L0<

L9:     inc esi
    .End_While
ret
;;

Proc WriteOneDataChunksAsFound:
    Argument @Section
    Local @ChunkSize, @Type

      ; Reset the output to the start of Line (first row):
        While B$edi-1 <= ' ' | dec edi | End_While
        mov D$edi CRLF2 | add edi 4

      ; esi points into 'UserPeStart'.

      ; Consider DATA or VIRTUALDATA Flags, in SectionsMap:
        mov eax D@Section, edx eax, cl B$eax, D@ChunkSize 0, B@Type cl

        While B$edx = cl
            inc edx | inc D@ChunkSize | On edx = D$EndOfSectionsMap, jmp L0>
        End_While
;;
  This 'ChunSize' is the whole size of a 'Chunk'; that may hold several
  Labels, and so forth, several "[Chunk: XXXX]".
  
  'eax:edx' is now the 'Start:End' of the whole 'Chunk', inside 'SectionsMap'.
;;
L0:     .While eax < edx
            mov ebx eax | sub ebx D$SectionsMap | add ebx D$RoutingMap
            mov ecx edx | sub ecx D$SectionsMap | add ecx D$RoutingMap

L1:         inc ebx | cmp ebx ecx | jae L2>
            test B$ebx LABEL+EVOCATED | jz L1<

L2:         sub eax D$SectionsMap | add eax D$SizesMap
            sub ebx D$RoutingMap | add ebx D$SizesMap

          ; call BuildCommentedDataReference eax ; made by Guga

            push ebx, edx
                If B@Type = VIRTUALFLAG
                    call WriteOneVirtualDataChunk, eax, ebx
                Else
                    call WriteOneDataChunk eax, ebx
                End_If
            pop edx, eax

            sub eax D$SizesMap | add eax D$SectionsMap
        .End_While

        add esi D@ChunkSize
EndP


[NextDataOutputBreak: ?]
;;
  Here, 'Chunk' stands for 'Chunk from Label to Label'.
;;

[NextDataChunkStart: ?]

; Writes one Data Chunk, in between two 'LABEL+EVOCATED':

Proc WriteOneDataChunk:
    Arguments @SizesmapStart, @SizesmapEnd
    Uses esi, edx

        InitDataLineBreak | mov B$edi '[' | inc edi

        test D@SizesmapStart 00_11 | jz L0>
            mov eax D@SizesmapStart
            If eax = D$NextDataChunkStart
                mov B$edi '<' | inc edi
            Else
                mov D$edi '<2 ' | add edi 3
            End_If

L0:     test D@SizesmapStart 00_1111 | jnz L0>
                mov D$edi '<16 ' | add edi 4

L0:     mov eax D@SizesmapStart | sub eax D$SizesMap | add eax D$SectionsMap
        call WriteOneDataLabel eax

        mov esi D@SizesmapStart, edx D@SizesmapEnd, cl B$esi
        mov D$NextDataChunkStart edx

        mov B$RepetitiveBytesDone &FALSE | call DisDataTypeRouter

        While B$edi-1 <= ' ' | dec edi | End_While
        On B$edi-1 = ',' dec edi

        mov B$edi ']', W$edi+1 CRLF | add edi 3
EndP


[ActualSizeFlag: ?  LastSizeFlag: ?  RealDataChunkEdx: ?]

DisDataTypeRouter:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag

 ; mov eax esi | sub eax D$SizesMap | add eax D$DisImageBase
 ; On eax = 0403000, int3 ;map

    mov B$ActualSizeFlag cl, D$RealDataChunkEdx edx

    call AlignSizeOn ecx

    If edx = esi
        mov edx D$RealDataChunkEdx
        mov cl BYTE, B$ActualSizeFlag cl | call WriteDisBytes | jmp L9>>
    End_If

    On cl = 0, mov cl BYTE

    .If cl = BYTE
        mov eax edx | sub eax esi | and eax 00_11
        If eax = 00_10
            mov cl WORD
        Else_If eax = 00_00
            mov cl DWORD
        End_If
    .End_If

    .If cl = BYTE
        call WriteDisBytes
    .Else_If cl = WORD
        call WriteDisWords
    .Else_If cl = DWORD
        call WriteDisPointers ; WriteDisdWords
    .Else_If cl = POINTER
        call WriteDisPointers
    .Else_If cl = POINTER+DWORD
        call WriteDisPointers
    .Else_If cl = STRINGS+BYTE
        call WriteDisAscii
    .Else_If cl = STRINGS+WORD
        call WriteDisUnicode
    .Else_If cl = FP4
        call WriteDisFP4
    .Else_If cl = FP8
        call WriteDisFP8
    .Else_If cl = FP10
        call WriteDisFP10
    .Else_If cl = FP4+POINTER
        call WriteDisFP4
    .Else_If cl = FP8+POINTER
        call WriteDisFP8
    .Else_If cl = FP10+POINTER
        call WriteDisFP10
    .Else_If cl = STRINGS+BYTE+POINTER
        mov cl STRINGS+BYTE, B$ActualSizeFlag cl
        call WriteDisAscii
    .Else_If cl = STRINGS+WORD+POINTER
        mov cl STRINGS+WORD, B$ActualSizeFlag cl
        call WriteDisUnicode
    .Else_If cl = STRINGS+POINTER
        mov cl STRINGS+BYTE, B$ActualSizeFlag cl
        call WriteDisAscii
    .Else
        test cl STRINGS | jz L1>
            If B$LastSizeFlag = STRINGS+BYTE
                mov cl STRINGS+BYTE, B$ActualSizeFlag cl | call WriteDisAscii
            Else_If B$LastSizeFlag = STRINGS+WORD
                mov cl STRINGS+WORD, B$ActualSizeFlag cl | call WriteDisUnicode
            Else
                mov cl STRINGS+BYTE, B$ActualSizeFlag cl | call WriteDisAscii
            End_If
            jmp L5>>

L1:     mov eax edx | sub eax esi
        cmp eax 4 | jb L1>
            call IsPointerCandidate

            If eax = &TRUE
                mov cl POINTER, B$ActualSizeFlag cl
                call AlignSizeOn ecx
                call WriteDisPointers | jmp L5>>
            End_If

L1:   ; edx (end) has been aligned: Unalign:
        mov edx D$RealDataChunkEdx | call IsStringCandidate

        If eax = &TRUE
           ; mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
           ; push esi, edx
                mov cl STRINGS+BYTE, B$ActualSizeFlag cl | call WriteDisAscii
           ; pop edx, esi
           ; mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
        Else
            mov cl BYTE, B$ActualSizeFlag cl | call WriteDisBytes
        End_If

    .End_If

  ; Trailing Bytes may remain there because of the above call to 'AlignSizeOn'. So:
L5: .If esi < D$RealDataChunkEdx
        mov edx D$RealDataChunkEdx
        mov W$edi '  ' | add edi 2
        mov eax edx | sub eax esi
        If eax < 4
            mov cl BYTE, B$ActualSizeFlag cl | call WriteDisBytes
        Else
            jmp DisDataTypeRouter
        End_If
    .End_If

L9: mov cl B$ActualSizeFlag, B$LastSizeFlag cl
ret

[ExportedDataWarning: "
; This Data was an Export, in the original Application.
; RosAsm does not (yet) support such Exports.
", 0]

Proc WriteOneDataLabel: ; 'WriteDisCodeLabel', 'WriteExportedFunctionLabel'
; called by 'WriteOneDataChunk' and 'WriteOneVirtualDataChunk'
    Argument @SectionsMapPtr

        mov eax D@SectionsMapPtr | sub eax D$SectionsMap | add eax D$RoutingMap
        Test B$eax EXPORTNODE | jz L1>  ; 'CheckExport'
            mov ebx eax, eax D@SectionsMapPtr
            sub eax D$SectionsMap | add eax D$DisImageBase
            call WriteExportedFunctionLabel
            push esi
                zCopy ExportedDataWarning
            pop esi

L1:     mov eax D@SectionsMapPtr

        If B$eax = DATAFLAG
            mov D$edi 'Data' | add edi 4
        Else_If B$eax = VIRTUALFLAG
            mov D$edi 'Virt', D$edi+4 'ual' | add edi 7
        End_If

        sub eax D$SectionsMap | add eax D$DisImageBase
        push eax
            call WriteEax
        pop eax

        ToStringsMapFrom DisImageBase, eax
        If D$eax <> 0
            push esi
                zCopy D$eax
            pop esi
        End_If

        mov W$edi ': ' | add edi 2
EndP


Proc AlignSizeOn:
    Argument @Unit
    Uses ecx

      ; esi = SizesmapStart, edx = SizesmapEnd
        mov ecx D@Unit | and ecx (not STRINGS)

        .If cl = POINTER
            mov ecx 4
        .Else
            and ecx (not POINTER)
            If cl = 0
                mov ecx BYTE | ExitP
            Else_If cl = BYTE
                ExitP
            Else_If cl = WORD
                mov ecx 2
            Else_If cl = DWORD
                mov ecx 4
            Else_If cl = FP4
                mov ecx 4
            Else_If cl = FP8
                mov ecx 8
            Else_If cl = FP10
                mov ecx 10
            End_If
        .End_If

        mov eax edx | sub eax esi
        mov edx 0 | div ecx | mul ecx
        mov edx esi | add edx eax
EndP


[RepetitiveBytesDone: ?  NumberOfRepetitiveData: ?]

IsRepetitiveBytes:
    If B$RepetitiveBytesDone = &TRUE
        mov D$NumberOfRepetitiveData 0 | ret
    End_If

    push esi, ecx, edx
        sub edx D$SizesMap | add edx D$UserPeStart

        mov esi ebx, al B$esi, ecx 0

        While B$esi = al
            lodsb | inc ecx | cmp esi edx | jae L2>>
        End_While

L2:     If ecx > 1
            mov D$NumberOfRepetitiveData ecx
        Else
            mov D$NumberOfRepetitiveData 0
        End_If

    pop edx, ecx, esi

    mov B$RepetitiveBytesDone &TRUE
ret


IsRepetitiveWords:
    If B$RepetitiveBytesDone = &TRUE
        mov D$NumberOfRepetitiveData 0 | ret
    End_If

    push esi, ecx, edx
        sub edx D$SizesMap | add edx D$UserPeStart

        mov esi ebx, ax W$esi, ecx 0

        While W$esi = ax
            lodsw | inc ecx | cmp esi edx | jae L2>>
        End_While

L2:     If ecx > 1
            mov D$NumberOfRepetitiveData ecx
        Else
            mov D$NumberOfRepetitiveData 0
        End_If

    pop edx, ecx, esi

    mov B$RepetitiveBytesDone &TRUE
ret


IsRepetitivedWords:
    If B$RepetitiveBytesDone = &TRUE
        mov D$NumberOfRepetitiveData 0 | ret
    End_If

    push esi, ecx, edx
        sub edx D$SizesMap | add edx D$UserPeStart

        mov esi ebx, eax D$esi, ecx 0

        While D$esi = eax
            lodsd | inc ecx | cmp esi edx | jae L2>>
        End_While

L2:     If ecx > 1
            mov D$NumberOfRepetitiveData ecx
        Else
            mov D$NumberOfRepetitiveData 0
        End_If

    pop edx, ecx, esi

    mov B$RepetitiveBytesDone &TRUE
ret


WriteDisBytes: ; 'WriteBytesData', 'WriteAsciiData'
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    On B$edi-2 = '$', sub edi 3
    mov D$edi 'B$ ' | add edi 3

    mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart

    call IsRepetitiveBytes

    If D$NumberOfRepetitiveData > 0
        movzx eax B$ebx | push ebx | call WriteEax | pop ebx
        mov W$edi ' #' | add edi 2
        mov eax D$NumberOfRepetitiveData | push ebx | call WriteEax | pop ebx
        add esi D$NumberOfRepetitiveData
        add ebx D$NumberOfRepetitiveData | cmp esi edx | jae L9>
        call NextDisDataLine
    End_If

L0: movzx eax B$ebx | push ebx | call WriteEax | pop ebx

    inc esi | inc ebx | cmp esi edx | jae L9>

        .If B$esi <> 0
            If B$esi <> cl
                call NextDisDataLine
                mov cl B$esi | ret
            End_If
        .End_If

        If edi > D$NextDataOutputBreak
            call NextDisDataLine
        Else_If esi < edx
            mov D$edi ', ' | add edi 2
        End_If

    jmp L0<
L9: ret


WriteDisWords:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
   On B$edi-2 = '$', sub edi 3
    mov D$edi 'W$ ' | add edi 3

    mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart

    call IsRepetitiveWords

    If D$NumberOfRepetitiveData > 0
        movzx eax W$ebx | push ebx | call WriteEax | pop ebx
        mov W$edi ' #' | add edi 2
        mov eax D$NumberOfRepetitiveData | push ebx | call WriteEax | pop ebx
        mov eax D$NumberOfRepetitiveData | shl eax 1
        add esi eax | add ebx eax | cmp esi edx | jae L9>
        call NextDisDataLine
    End_If

L0: mov eax edx | sub eax esi
    If eax < 2
        mov cl BYTE | ret
    End_If

    movzx eax W$ebx | push ebx | call WriteEax | pop ebx

    add esi 2 | add ebx 2 | cmp esi edx | jae L9>

        .If B$esi <> 0
            If B$esi <> cl
                call NextDisDataLine
                mov cl B$esi | ret
            End_If
        .End_If

        If edi > D$NextDataOutputBreak
            call NextDisDataLine
        Else_If esi < edx
            mov D$edi ', ' | add edi 2
        End_If

    jmp L0<
L9: ret


WriteDisdWords:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    On B$edi-2 = '$', sub edi 3
    mov D$edi 'D$ ' | add edi 3

    mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart

    call IsRepetitivedWords

    If D$NumberOfRepetitiveData > 0
        mov eax D$ebx | push ebx | call WriteEax | pop ebx
        mov W$edi ' #' | add edi 2
        mov eax D$NumberOfRepetitiveData | push ebx | call WriteEax | pop ebx
        mov eax D$NumberOfRepetitiveData | shl eax 2
        add esi eax | add ebx eax | cmp esi edx | jae L9>>
        call NextDisDataLine
    End_If

L0: mov eax D$ebx | push ebx | call WriteEax | pop ebx

    add esi 4 | add ebx 4 | cmp esi edx | jae L9>

        .If B$esi <> 0
            If B$esi <> cl
                call NextDisDataLine
                mov cl B$esi | ret
            End_If
        .End_If

        If edi > D$NextDataOutputBreak
            call NextDisDataLine
        Else_If esi < edx
            mov D$edi ', ' | add edi 2
        End_If

    jmp L0<<
L9: ret


[WasValidPointer: ?]

WriteDisPointers:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    On B$edi-2 = '$', sub edi 3
    mov D$edi 'D$ ' | add edi 3

    mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart

L0: mov eax edx | sub eax esi
    If eax < 4
        mov cl BYTE | ret
    End_If

    mov eax D$ebx

    ;sub eax D$DisImageBase | add eax D$RoutingMap
    ;test B$eax LABEL | jz WriteDisdWords
    ;mov eax D$ebx
;;
  This case of zeroed POINTERs should be turned DWORDs, in 'CheckFlagsCoherency'
;;
    .If eax = 0
        call IsRepetitivedWords

        If D$NumberOfRepetitiveData > 0
            mov eax D$ebx | push ebx | call WriteEax | pop ebx
            mov W$edi ' #' | add edi 2
            mov eax D$NumberOfRepetitiveData | push ebx | call WriteEax | pop ebx
            mov eax D$NumberOfRepetitiveData | shl eax 2
            add esi eax | add ebx eax | cmp esi edx | jae L9>>
            call NextDisDataLine | jmp L0<
        End_If

    .End_If

    mov B$RepetitiveBytesDone &TRUE

    push eax
        sub eax D$DisImageBase | add eax D$SectionsMap
        ..If eax > D$SectionsMap
            .If eax < D$EndOfSectionsMap
                sub eax D$SectionsMap | add eax D$RoutingMap
                test B$eax LABEL+INSTRUCTION+EVOCATED | jz L2>
L1:             sub eax D$RoutingMap | add eax D$SectionsMap
                If B$eax = CODEFLAG
                    sub eax D$SectionsMap | add eax D$RoutingMap
                    test B$eax LABEL+INSTRUCTION | jz L2>
                    mov D$edi 'Code' | add edi 4
                Else_If B$eax = DATAFLAG
                    mov D$edi 'Data' | add edi 4
                Else_If B$eax = VIRTUALFLAG
                    mov D$edi 'Virt', D$edi+4 'ual' | add edi 7
                End_If
            .End_If
        ..End_If
L2: pop eax

    .If D$edi-4 = 'tual'
        mov B$WasValidPointer &TRUE
    .Else_If D$edi-4 = 'Data'
        mov B$WasValidPointer &TRUE
    .Else_If D$edi-4 = 'Code'
        mov B$WasValidPointer &TRUE
    .Else
        mov B$WasValidPointer &FALSE
        push eax
            mov edx D$RealDataChunkEdx | call IsStringCandidate
            If eax = &TRUE
                pop eax
                mov cl STRINGS+BYTE, B$ActualSizeFlag cl | call WriteDisAscii | ret
            End_If
        pop eax
    .End_If

    push ebx, eax | call WriteEax | pop eax, ebx

    ..If B$WasValidPointer = &TRUE
        ToStringsMapFrom DisImageBase, eax
        .If D$eax <> 0
            push esi
                If D$eax = MainWindowProcName
                    While D$edi <> 'Code' | dec edi | End_While
                End_If
                zCopy D$eax
            pop esi
        .End_If
    ..End_If

    add esi 4 | add ebx 4 | cmp esi edx | jae L9>

        .If B$esi <> 0
            If B$esi <> cl
                call NextDisDataLine
                mov cl B$esi | ret
            End_If
        .End_If

        If edi > D$NextDataOutputBreak
            call NextDisDataLine
        Else_If esi < edx
            mov D$edi ', ' | add edi 2
        End_If

    jmp L0<<
L9: ret


[InsideQuotes: ?]

WriteDisAscii: ; 'WriteAsciiData'
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    mov B$RepetitiveBytesDone &TRUE
    On B$edi-2 = '$', sub edi 3
    mov D$edi 'B$ ' | add edi 3
    mov B$InsideQuotes &FALSE

    mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart

L0: movzx eax B$ebx
;On D$ebx = '3D F', int3
    push ebx
        mov ebx D$TruthAsciiTable

        ...If B$ebx+eax = GOODASCII
;;
  Isolated cases of 13 or 10 might be miss-interpretated as part of a CRLF:
;;
            If al = CR
                pop ebx | push ebx
                On B$ebx <> LF, jmp L2>
            Else_If al = LF
                pop ebx | push ebx
                On B$esi-2 <> CR, jmp L2>
            End_If

            On al = '"', jmp L2>

            If B$InsideQuotes = &FALSE
                mov B$edi '"' | inc edi
                mov B$InsideQuotes &TRUE
            End_If
            stosb

        ...Else
L2:         If B$InsideQuotes = &TRUE
                mov B$edi '"' | inc edi
                mov B$InsideQuotes &FALSE
            End_If
            .If W$edi-2 <> ', '
                If W$edi-3 <> 'B$'
                    mov W$edi ', ' | add edi 2
                End_If
            .End_If
            call WriteEax
            inc esi
            ..If esi < edx
                .If W$edi-2 <> ', '
                    If W$edi-3 <> 'B$'
                        mov D$edi ', ' | add edi 2
                    End_If
                .End_If
            ..End_If
            dec esi
        ...End_If
    pop ebx

    inc esi | inc ebx | cmp esi edx | jae L9>

        ..If B$esi <> 0
            .If B$esi <> cl
                If B$InsideQuotes = &TRUE
                    mov B$edi '"' | inc edi
                    mov B$InsideQuotes &FALSE
                End_If
                call NextDisDataLine
                mov cl B$esi | ret
            .End_If
        ..End_If

        jmp L0<<

L9: If B$InsideQuotes = &TRUE
        mov B$edi '"' | inc edi
        mov B$InsideQuotes &FALSE
    End_If
ret


WriteDisUnicode:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    mov B$RepetitiveBytesDone &TRUE
    On B$edi-2 = '$', sub edi 3
    mov D$edi 'U$ ' | add edi 3
    mov B$InsideQuotes &FALSE

    mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart

L0: movzx eax B$ebx

    push ebx, ecx
        mov ecx ebx, ebx D$TruthAsciiTable
        ..If B$ebx+eax = GOODASCII
            On al = '"', jmp L2>
            If al = CR
                On B$ecx+2 <> LF, jmp L2>
            Else_If al = LF
                On B$ecx-2 <> CR, jmp L2>
            End_If
            If B$InsideQuotes = &FALSE
                mov B$edi '"' | inc edi
                mov B$InsideQuotes &TRUE
            End_If
            stosb
        ..Else
L2:         If B$InsideQuotes = &TRUE
                mov B$edi '"' | inc edi
                mov B$InsideQuotes &FALSE
            End_If
            .If W$edi-2 <> ', '
                If W$edi-3 <> 'U$'
                    mov W$edi ', ' | add edi 2
                End_If
            .End_If
            call WriteEax
            inc esi
            .If esi < edx
                .If W$edi-2 <> ', '
                    If W$edi-3 <> 'U$'
                        mov W$edi ', ' | add edi 2
                    End_If
                .End_If
            .End_If
            dec esi
        ..End_If
    pop ecx, ebx

    add esi 2 | add ebx 2 | cmp esi edx | jae L9>

        ..If B$esi <> 0
            .If B$esi <> cl
                If B$InsideQuotes = &TRUE
                    mov B$edi '"' | inc edi
                    mov B$InsideQuotes &FALSE
                End_If
                call NextDisDataLine
                mov cl B$esi | ret
            .End_If
        ..End_If

        jmp L0<<

L9: If B$InsideQuotes = &TRUE
        mov B$edi '"' | inc edi
        mov B$InsideQuotes &FALSE
    End_If
ret


WriteDisFP4: ; WriteDisdWords
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    On B$edi-2 = '$', sub edi 3

L0: mov eax edx | sub eax esi
    If eax < 4
        mov cl BYTE | ret
    End_If

    push esi, edx
        mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart
        call WriteFP4
    pop edx, esi

    add esi 4

    .If B$esi <> 0
        If B$esi <> cl
            call NextDisDataLine
            mov cl B$esi | ret
        End_If
    .End_If

    .If esi < edx
        If edi > D$NextDataOutputBreak
            call NextDisDataLine
        Else_If esi < edx
            mov D$edi ', ' | add edi 2
        End_If

        jmp L0<
    .End_If

    mov B$RepetitiveBytesDone &TRUE
ret


WriteDisFP8:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    On B$edi-2 = '$', sub edi 3

L0: mov eax edx | sub eax esi
    If eax < 8
        mov cl BYTE | ret
    End_If

    push esi, edx
        mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart
        call WriteFP8
    pop edx, esi

    add esi 8

    .If B$esi <> 0
        If B$esi <> cl
            call NextDisDataLine
            mov cl B$esi | ret
        End_If
    .End_If

    .If esi < edx
        If edi > D$NextDataOutputBreak
            call NextDisDataLine
        Else_If esi < edx
            mov D$edi ', ' | add edi 2
        End_If

        jmp L0<
    .End_If

    mov B$RepetitiveBytesDone &TRUE
ret


WriteDisFP10:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    On B$edi-2 = '$', sub edi 3

L0: mov eax edx | sub eax esi
    If eax < 10
        mov cl BYTE | ret
    End_If

    push esi, edx
        mov ebx esi | sub ebx D$Sizesmap | add ebx D$UserPeStart
        call WriteFP10
    pop edx, esi

    add esi 10

    .If B$esi <> 0
        If B$esi <> cl
            call NextDisDataLine
            mov cl B$esi | ret
        End_If
    .End_If

    .If esi < edx
        If edi > D$NextDataOutputBreak
            call NextDisDataLine
        Else_If esi < edx
            mov D$edi ', ' | add edi 2
        End_If

        jmp L0<
    .End_If

    mov B$RepetitiveBytesDone &TRUE
ret


NextDisDataLine:
    InitDataLineBreak
    mov D$edi 020200A0D, D$edi+4 '    ', D$edi+8 '    ', D$edi+12 '    ', D$edi+16 '    '
    add edi 19
ret


NextCommentedDisDataLine:
    InitDataLineBreak
    mov D$edi 020200A0D, D$edi+4 '    ', D$edi+8 '    ', D$edi+12 '    ', D$edi+16 '  ; '
    add edi 19
ret


[InitDataLineBreak | mov D$NextDataOutputBreak edi | add D$NextDataOutputBreak 70]


IsPointerCandidate:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    push ecx, esi
        mov ecx edx | sub ecx esi | shr ecx 2

        sub esi D$Sizesmap | add esi D$Routingmap

L0:     test B$esi INDIRECT | jz L1>
            mov eax esi
            sub eax D$Routingmap | add eax D$UserPeStart
            mov eax D$eax
            sub eax D$DisImageBase | add eax D$RoutingMap

            If eax < D$Routingmap
                ;
            Else_If eax < D$EndOfRoutingMap
                test B$eax LABEL | jz L1>
                    mov eax &TRUE | jmp L9>
            End_If

L1:         add esi 4 | loop L0<

            mov eax &FALSE
L9: pop esi, ecx
ret


IsStringCandidate:
  ; esi = SizesmapStart, edx = SizesmapEnd, cl = SizeFlag
    push esi, ecx, edx
L0:     mov ecx edx | sub ecx esi
        sub esi D$Sizesmap | add esi D$UserPeStart | On B$esi = 0, jmp L8>

        mov eax 0, edx D$TruthAsciiTable
L0:     lodsb | On B$edx+eax = GOODASCII, loop L0<
        jecxz L9>

L1:         If al = 0
                lodsb | loop L1<
                jecxz L9>
            Else_If B$edx+eax = GOODASCII
                jecxz L9>
                loop L0<
            End_If

L8:     mov eax &FALSE
    pop edx, ecx, esi
ret

L9:     mov eax &TRUE
    pop edx, ecx, esi
ret


IsDwordString:
  ; esi >>> SizesMap // ebx >>> RoutingMap // B$esi = DWORD
    If B$esi = DWORD

    End_If


ret
____________________________________________________________________________________________

Proc WriteOneVirtualDataChunk:
    Arguments @SizesmapStart, @SizesmapEnd
    Uses esi, edx

        InitDataLineBreak | mov B$edi '[' | inc edi

        test D@SizesmapStart 00_11 | jz L0>
            mov B$edi '<' | inc edi

L0:     mov eax D@SizesmapStart | sub eax D$SizesMap | add eax D$SectionsMap
        call WriteOneDataLabel eax

        mov esi D@SizesmapStart, ecx D@SizesmapEnd | sub ecx esi

        ..If ecx = 1
            mov D$edi 'B$ ?' | add edi 4
        ..Else_If ecx = 2
            mov D$edi 'W$ ?' | add edi 4
        ..Else_If ecx = 4
            If B$esi = FP4
                mov D$edi 'F$ ?'
            Else
                mov D$edi 'D$ ?'
            End_If
            add edi 4
        ..Else
        ; LOOPVDATAMAX
L1:         mov eax ecx | and eax 0011
            .If eax = 0
                If B$esi = FP4
                    mov D$edi 'F$ ?'
                Else
                    mov D$edi 'D$ ?'
                End_If
                mov W$edi+4 ' #'  | add edi 6
                mov eax ecx | shr eax 2
                On eax > LOOPVDATAMAX, mov eax LOOPVDATAMAX
                call WriteEax
            .Else
                mov D$edi 'B$ ?', W$edi+4 ' #'  | add edi 6
                mov eax ecx | On eax > LOOPVDATAMAX, mov eax LOOPVDATAMAX
                call WriteEax
            .End_If
        ..End_If
        mov B$edi ']' | inc edi

      ; Case of set sizes > RosAsm Max, split into as many sub-sets as wanted:
        If ecx > LOOPVDATAMAX
            sub ecx LOOPVDATAMAX | NextDisLine
            push esi
                mov esi edi
                While B$esi <> '[' | dec esi | End_While
                While B$esi <> ':' | movsb | End_While
                mov B$edi 'X' | inc edi
                While B$esi <> '$' | movsb | End_While | dec edi
            pop esi
            jmp L1<<
        End_If

        mov D$edi CRLF2 | add edi 4
EndP





































TITLE DisEngine

____________________________________________________________________________________________

; This is the only one Table used in the Disassembler.
; Table of Pointers to each primary Opcode computation Routine:

[DisOp1:
 Op00 Op01 Op02 Op03 Op04 Op05 Op06 Op07 Op08 Op09 Op0A Op0B Op0C Op0D Op0E Op0F
 Op10 Op11 Op12 Op13 Op14 Op15 Op16 Op17 Op18 Op19 Op1A Op1B Op1C Op1D Op1E Op1F
 Op20 Op21 Op22 Op23 Op24 Op25 Op26 Op27 Op28 Op29 Op2A Op2B Op2C Op2D Op2E Op2F
 Op30 Op31 Op32 Op33 Op34 Op35 Op36 Op37 Op38 Op39 Op3A Op3B Op3C Op3D Op3E Op3F
 Op40 Op41 Op42 Op43 Op44 Op45 Op46 Op47 Op48 Op49 Op4A Op4B Op4C Op4D Op4E Op4F
 Op50 Op51 Op52 Op53 Op54 Op55 Op56 Op57 Op58 Op59 Op5A Op5B Op5C Op5D Op5E Op5F
 Op60 Op61 Op62 Op63 Op64 Op65 Op66 Op67 Op68 Op69 Op6A Op6B Op6C Op6D Op6E Op6F
 Op70 Op71 Op72 Op73 Op74 Op75 Op76 Op77 Op78 Op79 Op7A Op7B Op7C Op7D Op7E Op7F
 Op80 Op81 Op82 Op83 Op84 Op85 Op86 Op87 Op88 Op89 Op8A Op8B Op8C Op8D Op8E Op8F
 Op90 Op91 Op92 Op93 Op94 Op95 Op96 Op97 Op98 Op99 Op9A Op9B Op9C Op9D Op9E Op9F
 OpA0 OpA1 OpA2 OpA3 OpA4 OpA5 OpA6 OpA7 OpA8 OpA9 OpAA OpAB OpAC OpAD OpAE OpAF
 OpB0 OpB1 OpB2 OpB3 OpB4 OpB5 OpB6 OpB7 OpB8 OpB9 OpBA OpBB OpBC OpBD OpBE OpBF
 OpC0 OpC1 OpC2 OpC3 OpC4 OpC5 OpC6 OpC7 OpC8 OpC9 OpCA OpCB OpCC OpCD OpCE OpCF
 OpD0 OpD1 OpD2 OpD3 OpD4 OpD5 OpD6 OpD7 OpD8 OpD9 OpDA OpDB OpDC OpDD OpDE OpDF
 OpE0 OpE1 OpE2 OpE3 OpE4 OpE5 OpE6 OpE7 OpE8 OpE9 OpEA OpEB OpEC OpED OpEE OpEF
 OpF0 OpF1 OpF2 OpF3 OpF4 OpF5 OpF6 OpF7 OpF8 OpF9 OpFA OpFB OpFC OpFD OpFE OpFF]

[AMDassumed: &FALSE]
;;
  Prefixes: Op0F (EscapePrefix) , Op66 (OperandSizeOverride), Op67 (AddressSizeOverride)
;;


; Jcc Prefixes (02E / 03E) implemented as UTJ LTJ (Unlikely / Likely Taken Jump).
; Op2E > UTJ // Op3E > LTJ Followed by Jcc / (+JECXz ???).

;;
  Bad TD Files:

  115, impossible: Trick with create Window STATIC + Resource Name !!!!
  170, Menu? + Does not show the BitMaps (???...). Hang
  710, Strings IDs? BitMaps?

  810, Tricky (Auto-Write ?) Code (not Writeable in [Output].

* The Short Jumps Sizes adjustements do not seem to work (TD 170 example).
* Menu IDs replacement to be implemented.
* Some detail os wrong in the Menus until they be reloaded and resaved by the Menu Editor...
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

; 256 Routines for the primary Opcodes:
____________________________________________________________________________________________
____________________________________________________________________________________________

Op00:
    On D$esi-5 = 0, add D$UnLikelyCode 4
    On D$esi-1 = 0, add D$UnLikelyCode 1 ; ???...

; This hangs here, because a valid "add reg8 reg8" is found somewhere and
; produces something wrong in the Sections recognitions...
;
; To be analyzed on Calc.exe:
;
; RoutingMap differences with or without this added 'UnLikelyCode', in order
; to understand the failure point of the Recogitions...

   ; push eax
   ;     mov eax esi | add eax 7
   ;     If eax < D$UserPeEnd
   ;        ; On D$esi = 0,
;           add D$UnLikelyCode 1
   ;     End_If
   ; pop eax

    .If B$EscapePrefix = &FALSE           ; add r/m8 r8
        mov B$LockPrefix &FALSE
        mov D$edi 'add ' | add edi 4 | jmp Dis_rm8_r8

    .Else
        mov bl B$esi | inc esi | DigitMask bl To al

        If al = 0       ; 0F 00 /0 SLDT r/m16 ; 0F 00 /0 SLDT r/m32
            mov D$edi 'sldt', B$edi+4 ' ' | add edi 5 | jmp Dis_rm32_rm16
        Else_If al = 1  ; 0F 00 /1 STR r/m16
            mov D$edi 'str ' | add edi 4
        Else_If al = 2  ; 0F 00 /2 LLDT r/m16
            mov D$edi 'lldt', B$edi+4 ' ' | add edi 5
        Else_If al = 3  ; 0F 00 /3 > LTR r/m16
            mov D$edi 'ltr ' | add edi 4 | jmp EndWith.W.mem
        Else_If al = 4  ; 0F 00 /4 VERR r/m16
            mov D$edi 'verr', B$edi+4 ' ' | add edi 5 ; VERW
        Else_If al = 5  ; 0F 00 /5 VERW r/m16
            mov D$edi 'verw', B$edi+4 ' ' | add edi 5
        Else
            dec esi | ret
        End_If
        inc D$UnLikelyCode
        jmp EndWith.W.mem
    .End_If


Op01:
    ..If B$EscapePrefix = &FALSE
        mov B$LockPrefix &FALSE
        mov D$edi 'add ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16
        inc D$LikelyCode

    ..Else_If W$esi = 0C801 ; 0F,01,C8 MONITOR
        inc D$LikelyCode
        add esi 2
        mov D$edi 'moni', D$edi+4 'tor ' | add edi 8
        mov B$DisFlag DISDONE+DISLINEOVER | ret

    ..Else_If W$esi = 0C901 ; 0F,01,C9 MWAIT
        inc D$LikelyCode
        add esi 2
        mov D$edi 'mwai', D$edi+4 't ' | add edi 6
        mov B$DisFlag DISDONE+DISLINEOVER | ret

    ..Else
        mov bl B$esi | inc esi | DigitMask bl To al
        inc D$UnLikelyCode

        .If al = 0          ; 0F 01 /0 SGDT m
            mov D$edi 'sgdt', B$edi+4 ' ' | add edi 5 | jmp EndWith.X.mem
        .Else_If al = 1     ; 0F 01 /1 SIDT m
            mov D$edi 'sidt', B$edi+4 ' ' | add edi 5 | jmp EndWith.X.mem
        .Else_If al = 2     ; LGDT m16&32
            mov D$edi 'lgdt', B$edi+4 ' ' | add edi 5 | jmp EndWith.X.mem
        .Else_If al = 3     ; LIDT m16&32
            mov D$edi 'lidt', B$edi+4 ' ' | add edi 5 | jmp EndWith.X.mem
        .Else_If al = 4     ; 0F 01 /4 SMSW r/m16 ; 0F 01 /4 SMSW r32/m16
            mov D$edi 'smsw', B$edi+4 ' ' | add edi 5 | jmp Dis_rm32_rm16
        .Else_If al = 6     ; LMSW r/m16
            mov D$edi 'lmsw', B$edi+4 ' ' | add edi 5 | jmp EndWith.W.mem
        .Else_If al = 7     ; INVLPG m
            mov D$edi 'invl', D$edi+4 'pg  ' | add edi 7 | jmp EndWith.X.mem
        .Else
            dec esi | ret
        .End_If
    ..End_If


Op02:
    If B$EscapePrefix = &FALSE
        mov B$LockPrefix &FALSE
        mov D$edi 'add ' | add edi 4 | jmp Dis_r8_rm8
    Else       ; LAR r16,r/m16
        mov D$edi 'lar ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16
    End_If


Op03:
    If B$EscapePrefix = &FALSE
        mov D$edi 'add '
    Else     ; LSL r32,r/m32 ; LSL r16,r/m16
        mov D$edi 'lsl '
        inc D$UnLikelyCode
    End_If
    add edi 4 | jmp Dis_r32_r16__rm32_rm16


Op04: ; add al imm8
    If D$esi-1 = 4
        inc D$UnlikelyCode
    Else
        inc D$LikelyCode
    End_If
    mov D$edi 'add ' | add edi 4 | jmp Dis_al_imm8


Op05: ; add eax/ax imm32/imm16
    mov D$edi 'add ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16


Op06: ; clts
    inc D$UnLikelyCode
    If B$EscapePrefix = &TRUE
        mov D$edi 'clts' | add edi 4 | mov B$DisFlag DISDONE+DISLINEOVER
    Else        ; 06 PUSH ES
        mov D$edi 'push', D$edi+4 ' es ' | add edi 7 | mov B$DisFlag DISDONE+DISLINEOVER
    End_If
ret


Op07: ; 07 POP ES
    inc D$UnLikelyCode
    mov D$edi 'pop ', W$edi+4 'es' | add edi 6 | mov B$DisFlag DISDONE+DISLINEOVER
ret


Op08:
    If B$EscapePrefix = &FALSE        ; OR r/m8,r8
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'or  ' | add edi 3 | jmp Dis_rm8_r8
    Else     ; INVD
        inc D$UnLikelyCode
        mov D$edi 'invd' | add edi 4 | mov B$DisFlag DISDONE+DISLINEOVER
    End_If
ret


Op09:
    If B$EscapePrefix = &FALSE    ; OR r/m16,r16 // OR r/m32,r32
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'or  ' | add edi 3 | jmp Dis_rm32_rm16__r32_r16
    Else    ; 0F 09 WBINVD
        inc D$UnLikelyCode
        mov D$edi 'wbin', D$edi+4 'vd  ' | add edi 6
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op0A: ; OR r8,r/m8
    inc D$LikelyCode
    mov B$LockPrefix &FALSE
    mov D$edi 'or  ' | add edi 3 | jmp Dis_r8_rm8


Op0B:
    If B$EscapePrefix = &FALSE    ; OR r32,r/m32 // OR r16,r/m16
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'or  ' | add edi 3 | jmp Dis_r32_r16__rm32_rm16
    Else    ; 0F 0B UD2
        inc D$UnLikelyCode
        mov D$edi 'ud2 ' | add edi 3
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op0C: ; OR AL,imm8
    inc D$LikelyCode
    mov D$edi 'or  ' | add edi 3 | jmp Dis_al_imm8


Op0D: ; OR AX,imm16 ; OR EAX,imm32
    .If B$AMDassumed = &TRUE
         If B$EscapePrefix = &TRUE ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Looki
            mov D$edi 'PREF', D$edi+4 'ETCH', W$edi+8 'W ' | add edi 10
            jmp Dis_rm8
        Endif
    .End_If
    inc D$LikelyCode
    mov D$edi 'or  ' | add edi 3 | jmp Dis_eax_ax__imm32_imm16


Op0E: ; 0E PUSH CS
    .If B$AMDassumed = &TRUE
        If B$EscapePrefix = &TRUE ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Looki
            mov D$edi 'FEMM', B$edi+4 'S' | add edi 5
            mov B$DisFlag DISDONE+DISLINEOVER
            ret
        Endif
    .End_If

    inc D$UnLikelyCode
    mov D$edi 'push', D$edi+4 ' cs ' | add edi 7
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op0F:
    ...If B$AMDassumed = &TRUE
        ..If B$EscapePrefix = &TRUE ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< new
            .If B$esi+1 = 0AE ; 0F 0F xx 0AE - PFACC
                mov D$edi 'PFAC', W$edi+4 'C ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 09E ; 0F 0F xx 09E - PFADD
                mov D$edi 'PFAD', W$edi+4 'D ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 09A ; 0F 0F xx 09A - PFSUB
                mov D$edi 'PFSU', W$edi+4 'B ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 0B4 ; 0F 0F xx 0B4 - PFMUL
                mov D$edi 'PFMU', W$edi+4 'L ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 096 ; 0F 0F xx 096 - PFRCP
                mov D$edi 'PFRC', W$edi+4 'P ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 097 ; 0F 0F xx 097 - PFRSQRT <<<<<< until here all are common
                mov D$edi 'PFRS', D$edi+4 'QRT ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 0BF ; 0F 0F xx 0BF - PAVGUSB
                mov D$edi 'PAVG', D$edi+4 'USB ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 01D ; 0F 0F xx 01D - PF2ID
                mov D$edi 'PF2I', W$edi+4 'D ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 090 ; 0F 0F xx 090 - PFCMPGE
                mov D$edi 'PFCM', D$edi+4 'PGE ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 0A0 ; 0F 0F xx 0A0 - PFCMPGT
                mov D$edi 'PFCM', D$edi+4 'PGT ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 0B0 ; 0F 0F xx 0B0 - PFCMPEQ
                mov D$edi 'PFCM', D$edi+4 'PEQ ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 094 ; 0F 0F xx 094 - PFMIN
                mov D$edi 'PFMI', W$edi+4 'N ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 0A4 ; 0F 0F xx 0A4 - PFMAX
                mov D$edi 'PFMA', W$edi+4 'X ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 0A6 ; 0F 0F xx 0A6 - PFRCPIT1
                mov D$edi 'PFRC', D$edi+4 'PIT1', B$edi+8 ' ' | add edi 9
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 0A7 ; 0F 0F xx 0A7 - PFRSQIT1
                mov D$edi 'PFRS', D$edi+4 'QIT1', B$edi+8 ' ' | add edi 9
                jmp Dis_mmx1__mmx2_m64_v2
    ;
            .ElseIf B$esi+1 = 0B6 ; 0F 0F xx 0B6 - PFRCPIT2
                mov D$edi 'PFRC', D$edi+4 'PIT2', B$edi+8 ' ' | add edi 9
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 0AA ; 0F 0F xx 0AA - PFSUBR
                mov D$edi 'PFSU', W$edi+4 'BR', B$edi+6 ' ' | add edi 7 ; ??????
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 0D ; 0F 0F xx 0D - PI2FD
                mov D$edi 'PI2F', W$edi+4 'D ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 0B7 ; 0F 0F xx 0B7 - PMULHRW
                mov D$edi 'PMUL', D$edi+4 'HRW ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 0C ; 0F 0F xx 0C - PI2FW*
                mov D$edi 'PI2F', W$edi+4 'W ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 01C ; 0F 0F xx 01C - PF2IW*
                mov D$edi 'PF2I', W$edi+4 'W ' | add edi 6
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 08E ; 0F 0F xx 08E - PFPNACC*
                mov D$edi 'PFPN', D$edi+4 'ACC ' | add edi 8
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 08A ; 0F 0F xx 08A - PFNACC*
                mov D$edi 'PFNA', W$edi+4 'CC', B$edi+6 ' ' | add edi 7 ; ??????
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 0BB ; 0F 0F xx 0BB - PSWAPD*
                mov D$edi 'PSWA', W$edi+4 'PD', B$edi+6 ' ' | add edi 7 ; ??????
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 086 ; 0F 0F xx 086 - PFRCPV**
                mov D$edi 'PFRC', W$edi+4 'PV', B$edi+6 ' ' | add edi 7 ; ??????
                jmp Dis_mmx1__mmx2_m64_v2
            .ElseIf B$esi+1 = 087 ; 0F 0F xx 087 - PFRSQRTV**
                mov D$edi 'PFRS', D$edi+4 'QRTV', B$edi+8 ' ' | add edi 9
    ;* Enhanced 3DNow! or Extended 3DNow! or 3DNow!+ (Athlon/XP+-Doc[22466.pdf])
    ;** 3DNow! Professional or 3DNow! Pro (Geode LX/GX)
            .Else
                inc D$UnLikelyCode
            .Endif
        ..Endif
    ...End_If

    On B$EscapePrefix = &TRUE, inc D$UnLikelyCode
    mov B$EscapePrefix &TRUE, B$DisFlag DISDONE
    inc D$Prefixes
ret


Op10:
    .If B$EscapePrefix = &FALSE            ; adc r/m8 m8
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'adc ' | add edi 4 | jmp Dis_rm8_m8

    .Else
        ;inc D$UnLikelyCode
        mov D$edi 'movu'
        If B$OperandSizeOverride = &TRUE   ; 66 0F 10 /r MOVUPD xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'pd  '
        Else       ; 0F 10 /r MOVUPS xmm1, xmm2/m128
            call MarkSSEdata SSE_4_F
            mov D$edi+4 'ps  '
        End_If
        add edi 7 | jmp Dis_xmm1__xmm2_m128

    .End_If


Op11:
    .If B$EscapePrefix = &FALSE         ; adc r/m32//r/m16 r32/r16
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'adc ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16

    .Else
        ;inc D$UnLikelyCode
        mov D$edi 'movu'
        If B$OperandSizeOverride = &TRUE   ; 66 0F 11 /r MOVUPD xmm2/m128, xmm
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'pd  '
        Else       ; 0F 11 /r MOVUPS xmm2/m128, xmm1
            call MarkSSEdata SSE_4_F
            mov D$edi+4 'ps  '
        End_If
        add edi 7 | jmp Dis_xmm2_m128__xmm1

    .End_If


Op12:
    ..If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        .If B$OperandSizeOverride = &TRUE        ; 66 0F 12 /r MOVLPD xmm, m64
            call MarkSSEdata SSE_1_R
            mov bl B$esi | inc esi
            mov D$edi 'movl', D$edi+4 'ps  ' | add edi 7 | jmp Dis_xmm_m64
        .Else        ; OF 12 /r MOVHLPS xmm1, xmm2 // 0F 12 /r MOVLPS xmm, m64
            mov bl B$esi | inc esi | ModMask bl to al

            If al = 3
                mov D$edi 'movh', D$edi+4 'lps ' | add edi 8
                jmp Dis_xmm1_xmm2
            Else
                dec esi | call MarkSSEdata SSE_2_F | inc esi
                mov D$edi 'movl', D$edi+4 'ps  ' | add edi 7
                jmp Dis_xmm_m64
            Else
                inc D$UnLikelyCode | dec esi | ret
            End_If
        .End_If

    ..Else    ; adc r8 r/m8
        inc D$LikelyCode
        mov D$edi 'adc ' | add edi 4 | jmp Dis_r8_rm8

    ..End_If


Op13:
    .If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        mov D$edi 'movl'
        If B$OperandSizeOverride = &TRUE        ; 66 0F 13 /r MOVLPD m64, xmm
            call MarkSSEdata SSE_1_R
            mov D$edi+4 'pd  '
        Else    ; 0F 13 /r MOVLPS m64, xmm
            call MarkSSEdata SSE_2_F
            mov D$edi+4 'ps  '
        End_If
        add edi 7 | mov bl B$esi | inc esi | jmp Dis_m64_xmm

    .Else       ; adc r32/r16 r/m32//r/m16
        inc D$LikelyCode
        mov D$edi 'adc ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16

    .End_If


Op14:
    .If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        mov D$edi 'unpc'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 14 /r UNPCKLPD xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'klpd'
        Else        ; 0F 14 /r UNPCKLPS xmm1, xmm2/m128
            call MarkSSEdata SSE_4_F
            mov D$edi+4 'klps'
        End_If
        mov B$edi+8 ' ' | add edi 9 | jmp Dis_xmm1__xmm2_m128

    .Else ; adc al imm8
        inc D$LikelyCode
        mov D$edi 'adc ' | add edi 4 | jmp Dis_al_imm8

    .End_If
ret


Op15:
    .If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        mov D$edi 'unpc'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 15 /r UNPCKHPD xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'khpd'
        Else        ; 0F 15 /r UNPCKHPS xmm1, xmm2/m128
            call MarkSSEdata SSE_4_F
            mov D$edi+4 'khps'
        End_If
        mov B$edi+8 ' ' | add edi 9 | jmp Dis_xmm1__xmm2_m128

    .Else   ; adc eax/ax imm32/imm16
        inc D$LikelyCode
        mov D$edi 'adc ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16

    .End_If


Op16:

    ..If B$EscapePrefix = &TRUE
        .If B$OperandSizeOverride = &TRUE    ; 66 0F 16 /r MOVHPD xmm, m64
            call MarkSSEdata SSE_1_R
            mov bl B$esi | inc esi
            mov D$edi 'movh', D$edi+4 'pd  ' | add edi 7 | jmp Dis_xmm_m64

        .Else            ; 0F 16 /r MOVHPS xmm, m64 // OF 16 /r MOVLHPS xmm1, xmm2
            mov bl B$esi | inc esi | ModMask bl to al

            If al = 3
                mov D$edi 'movl', D$edi+4 'hps ' | add edi 8
                jmp Dis_xmm1_xmm2
            Else
                dec esi | call MarkSSEdata SSE_2_F | inc esi
                mov D$edi 'movh', D$edi+4 'ps  ' | add edi 7
                jmp Dis_xmm_m64
            Else
                inc D$UnLikelyCode | dec esi | ret
            End_If
        .End_If

    ..Else  ; 16 PUSH SS
        mov D$edi 'push', D$edi+4 ' ss ' | add edi 7

    ..End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op17:
    .If B$EscapePrefix = &TRUE
        mov D$edi 'movh'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 17 /r MOVHPD m64, xmm
            call MarkSSEdata SSE_1_R
            mov D$edi+4 'pd  '
        Else            ; 0F 17 /r MOVHPS m64, xmm
            call MarkSSEdata SSE_2_F
            mov D$edi+4 'ps  '
        End_If
        add edi 7 | mov bl B$esi | inc esi | jmp Dis_m64_xmm

    .Else       ; 17 POP SS
        inc D$UnLikelyCode
        mov D$edi 'pop ', W$edi+4 'ss' | add edi 6

    .End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op18:
    .If B$EscapePrefix = &TRUE

        mov D$edi 'pref', D$edi+4 'etch' | add edi 8
        mov bl B$esi | inc esi | DigitMask bl to al

        If al = 0           ; 0F 18 /0 PREFETCHNTA m8
            mov D$edi 'nta ' | add edi 4
        Else_If al = 1      ; 0F 18 /1 PREFETCHT1 m8
            mov D$edi 't0  ' | add edi 3
        Else_If al = 2      ; 0F 18 /1 PREFETCHT2 m8
            mov D$edi 't1  ' | add edi 3
        Else_If al = 3      ; 0F 18 /1 PREFETCHT3 m8
            mov D$edi 't2  ' | add edi 3
        Else
            inc D$UnLikelyCode | dec esi | ret
        End_If
        jmp EndWith.B.mem

    .Else       ; 18 /r SBB r/m8,r8
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'sbb ' | add edi 4 | jmp Dis_rm8_r8

    .End_If


Op19: ; 19 /r SBB r/m16,r16 ; 19 /r SBB r/m32,r32
    inc D$LikelyCode
    mov B$LockPrefix &FALSE
    mov D$edi 'sbb ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16


Op1A: ; 1A /r SBB r8,r/m8
    inc D$LikelyCode
    mov D$edi 'sbb ' | add edi 4 | jmp Dis_r8_rm8


Op1B: ; 1B /r SBB r16,r/m16 ; 1B /r SBB r32,r/m32
    inc D$LikelyCode
    mov D$edi 'sbb ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16


Op1C: ; 1C ib SBB AL,imm8
    inc D$LikelyCode
    mov D$edi 'sbb ' | add edi 4 | jmp Dis_al_imm8


Op1D: ; 1D iw SBB AX,imm16  ; 1D id SBB EAX,imm32
    inc D$LikelyCode
    mov D$edi 'sbb ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16


Op1E:   ; 1E PUSH DS
    inc D$UnLikelyCode
    mov D$edi 'push', D$edi+4 ' ds ' | add edi 7
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op1F: ; 1F POP DS
    inc D$UnLikelyCode
    mov D$edi 'pop ', W$edi+4 'ds' | add edi 6
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op20:
    If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'and ' | add edi 4 | jmp Dis_rm8_r8

    Else        ; MOV r32,CR0 // CR1...
        inc D$UnLikelyCode
        mov bl B$esi | inc esi | BaseMask bl to al | and eax 0FF
        mov D$edi 'mov ' | add edi 4
        move D$edi D$dWordRegsTable+eax*4 | add edi 4
        mov D$edi 'CR0 ' | DigitMask bl To al | add B$edi+2 al | add edi 3
        mov B$DisFlag DISDONE+DISLINEOVER

    End_If
ret


Op21:
    If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'and ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16

    Else        ; MOV r32, DR0-DR7
        inc D$UnLikelyCode
        mov bl B$esi | inc esi | BaseMask bl to al | and eax 0FF
        mov D$edi 'mov ' | add edi 4
        move D$edi D$dWordRegsTable+eax*4 | add edi 4
        mov D$edi 'DR0 ' | DigitMask bl To al | add B$edi+2 al | add edi 3
        mov B$DisFlag DISDONE+DISLINEOVER

    EndiF
ret


Op22:
    If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        mov D$edi 'and ' | add edi 4 | jmp Dis_r8_rm8

    Else        ; MOV CR0,r32 // CR1...
        inc D$UnLikelyCode
        mov bl B$esi | inc esi | DigitMask bl To al
        mov D$edi 'mov ', D$edi+4 'CR0 '
        add B$edi+6 al | add edi 8
        BaseMask bl to al | and eax 0FF
        move D$edi D$dWordRegsTable+eax*4 | add edi 3
        mov B$DisFlag DISDONE+DISLINEOVER

    End_If
ret


Op23:
    If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        mov D$edi 'and ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16

    Else        ; MOV DR0-DR7,r32
        inc D$UnLikelyCode
        mov bl B$esi | inc esi | DigitMask bl To al
        mov D$edi 'mov ', D$edi+4 'DR0 '
        add B$edi+6 al | add edi 8
        BaseMask bl to al | and eax 0FF
        move D$edi D$dWordRegsTable+eax*4 | add edi 3
        mov B$DisFlag DISDONE+DISLINEOVER

    End_If
ret


Op24: ; and al imm8
    inc D$LikelyCode
    mov D$edi 'and ' | add edi 4 | jmp Dis_al_imm8


Op25: ; 25 iw AND AX,imm16 ; 25 id AND EAX,imm32
    inc D$LikelyCode
    mov D$edi 'and ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16


Op26:
    inc D$UnLikelyCode
    inc D$Prefixes
    mov D$SegmentOverride 'es: ', B$DisFlag DISDONE
ret


Op27: ; DAA
    inc D$LikelyCode
    mov D$edi 'daa ' | add edi 3 | mov B$DisFlag DISDONE+DISLINEOVER
ret


Op28: ; 66 0F 28 /r > MOVAPD xmm1, xmm2/m128
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        mov D$edi 'mova'
        If B$OperandSizeOverride = &TRUE
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'pd  '
        Else        ; 0F 28 /r MOVAPS xmm1, xmm2/m128
            call MarkSSEdata SSE_4_F
            mov D$edi+4 'ps  '
        End_If
        add edi 7 | jmp Dis_xmm1__mmx2_m128

    .Else   ; 28 /r SUB r/m8,r8
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'sub ' | add edi 4 | jmp Dis_rm8_r8

    .End_If


Op29:   ; 66 0F 29 /r MOVAPD xmm2/m128, xmm1
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        mov D$edi 'mova'
        If B$OperandSizeOverride = &TRUE
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'pd  '
        Else        ; 0F 29 /r MOVAPS xmm2/m128, xmm1
            call MarkSSEdata SSE_4_F
            mov D$edi+4 'ps  '
        End_If
        add edi 7 | jmp Dis_mmx2_m128__xmm1

    .Else   ; 29 /r SUB r/m16,r16 ; 29 /r SUB r/m32,r32
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'sub ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16

    .End_If


Op2A:
    .If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        mov D$edi 'cvtp'
        If B$OperandSizeOverride = &TRUE  ; ; CVTPI2PD xmm, mm/m64
            call MarkSSEdata SSE_2_D
            mov D$edi+4 'i2pd'
        Else                                ; CVTPI2PS xmm, mm/m64
            call MarkSSEdata SSE_2_D
            mov D$edi 'cvtp', D$edi+4 'i2ps'
        End_If
        mov B$edi+8 ' ' | add edi 9 | jmp Dis_xmm1__mmx2_m64

    .Else       ; 2A /r SUB r8,r/m8
        inc D$LikelyCode
        mov D$edi 'sub ' | add edi 4 | jmp Dis_r8_rm8

    .End_If


Op2B:
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        mov D$edi 'movn'
        If B$OperandSizeOverride = &TRUE        ; 66 0F 2B /r MOVNTPD m128, xmm
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'tpd '
        Else        ; 0F 2B /r MOVNTPS m128, xmm
            call MarkSSEdata SSE_4_F
            mov D$edi+4 'tps '
        End_If
        add edi 8 | mov bl B$esi | inc esi | jmp Dis_m128_xmm

    .Else   ; 2B /r SUB r16,r/m16 ; 2B /r SUB r32,r/m32
        inc D$LikelyCode
        mov D$edi 'sub ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16

    .End_If


Op2C: ; CVTTPD2PI mm, xmm/m128
    .If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        mov D$edi 'cvtt'
        If B$OperandSizeOverride = &TRUE    ; CVTTPD2PI mm, xmm/m128
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'pd2p', W$edi+8 'i ' | add edi 10
            jmp Dis_mmx1__xmm2_m128
        Else  ; CVTTPS2PI mm, xmm/m64
            call MarkSSEdata SSE_2_F
            mov D$edi 'cvtt', D$edi+4 'ps2p', W$edi+8 'i ' | add edi 10
            jmp Dis_mmx1__xmm2_m64
        End_If

    .Else       ; 2C ib SUB AL,imm8
        If D$esi-1 = 02C
            inc D$UnlikelyCode
        Else
            inc D$LikelyCode
        End_If
        mov D$edi 'sub ' | add edi 4 | jmp Dis_al_imm8

    .End_If


Op2D:
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        mov D$edi 'cvtp'
        If B$OperandSizeOverride = &TRUE    ; CVTPD2PI mm, xmm/m128
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'd2pi', B$edi+8 ' ' | add edi 9
            jmp Dis_mmx1__xmm2_m128
        Else                                ; CVTPS2PI mm, xmm/m64
            call MarkSSEdata SSE_2_F
            mov D$edi+4 's2pi', B$edi+8 ' ' | add edi 9
            jmp Dis_mmx1__xmm2_m64
        End_If

    .Else       ; 2D iw SUB AX,imm16 ; 2D id SUB EAX,imm32
        inc D$LikelyCode
        mov D$edi 'sub ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16

    .End_If


; Unikely Taken Jump: This is a Mnemonic non defined by Intel, which purpose is to
; reverse the Jump Prediction. UTJ / LTJ have been defined in collaboration with
; the NASM developers group. UTJ / LTJ are prefixes to Jcc Instructions. I have no
; info about if it is active or not before JECXZ. As i think it can't hurt, i allow
; it in RosAsm assembling.

Op2E:
    ;inc D$UnLikelyCode
    .If B$EscapePrefix = &TRUE
        mov D$edi 'ucom'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 2E /r UCOMISD xmm1, xmm2/m64
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'isd ' | add edi 8 | jmp Dis_xmm1__xmm2_m64
        Else    ; 0F 2E /r UCOMISS xmm1, xmm2/m32
            call MarkSSEdata SSE_4_F
            mov D$edi+4 'iss ' | add edi 8 | jmp Dis_xmm1__xmm2_m32
        End_If

    .Else
        ; UTJ if Jcc:
        ;      op70 71 72 73 74 75 76 77 Op78 79 7A 7B 7C 7D 7E 7F  E3 (E3 is JCXZ JECXZ...)
        ; Of / 80 81 82 83 84 85 86 86 88 89 8A 8B 8C 8D 8E 8F
        mov al B$esi
        .If al = 0F
            mov al B$esi+1
            cmp al 080 | jb L5>
                cmp al 08F | ja L5>
                    inc esi | mov B$EscapePrefix &TRUE | jmp L3>

        .Else
            cmp al 0E3 | je L3>
                cmp al 070 | jb L5>
                    cmp al 07F | ja L5>
L3:                     mov D$edi 'utj ' | add edi 4
                            movzx eax B$esi
                            inc esi | call D$DisOp1+eax*4
                        mov B$DisFlag DISDONE+DISLINEOVER | ret

        .End_If

L5:     mov D$SegmentOverride 'cs: '
        inc D$Prefixes
      ; Watcom-C incodes the Api calls in the form of call D$cs:apiname:
        If W$esi <> 015FF
            inc D$UnLikelyCode
        Else
            mov eax D$esi+2
            sub eax D$DisImageBase | add eax D$UserPeStart | mov eax D$eax
            On eax < D$ApiBuffer, inc D$UnLikelyCode
            On eax >= D$EndOfApiBuffer, inc D$UnLikelyCode
        End_If

    .End_If

L9: mov B$DisFlag DISDONE
ret


Op2F:
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        mov D$edi 'comi'
        If B$OperandSizeOverride = &TRUE
            call MarkSSEdata SSE_1_R
            mov D$edi+4 'sd  ' | add edi 7
            jmp Dis_xmm1__xmm2_m64     ; COMISD xmm1, xmm2/m64
        Else
            call MarkSSEdata SSE_1_F
            mov D$edi+4 'ss  ' | add edi 7
            jmp Dis_xmm1__xmm2_m32     ; COMISS xmm1, xmm2/m32
        End_If

    .Else ; DAS
        inc D$LikelyCode
        mov D$edi 'das ' | add edi 3 | mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op30:
    If B$EscapePrefix = &FALSE  ; 30 /r XOR r/m8,r8
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'xor ' | add edi 4 | jmp Dis_rm8_r8
    Else         ; 0F 30 WRMSR
        inc D$UnLikelyCode
        mov D$edi 'wrms', B$edi+4 'r' | add edi 5
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op31: ; 0F 31 RDTSC
    If B$EscapePrefix = &FALSE  ; 31 /r XOR r/m16,r16 ; 31 /r XOR r/m32,r32
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'xor ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16
    Else
        ;inc D$UnLikelyCode
        mov D$edi 'rdts', B$edi+4 'c' | add edi 5  ; rdtsc
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op32:
    If B$EscapePrefix = &FALSE  ; 32 /r XOR r8,r/m8
        inc D$LikelyCode
        mov D$edi 'xor ' | add edi 4 | jmp Dis_r8_rm8
    Else     ; 0F 32 RDMSR
        ;inc D$UnLikelyCode
        mov D$edi 'rdms', B$edi+4 'r' | add edi 5
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op33:
    If B$EscapePrefix = &FALSE; 33 /r XOR r16,r/m16 ; 33 /r XOR r32,r/m32
        inc D$LikelyCode
        mov D$edi 'xor ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16
    Else        ; 0F 33 RDPMC
        ;inc D$UnLikelyCode
        mov D$edi 'rdpm', B$edi+4 'c' | add edi 5
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op34:
    If B$EscapePrefix = &FALSE        ; 34 ib XOR AL,imm8
        inc D$LikelyCode
        mov D$edi 'xor ' | add edi 4 | jmp Dis_al_imm8
    Else         ; 0F 34 SYSENTER
        inc D$UnLikelyCode
        mov D$edi 'syse', D$edi+4 'nter' | add edi 8
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op35:
    If B$EscapePrefix = &FALSE        ; 35 iw XOR AX,imm16 ; 35 id XOR EAX,imm32
        inc D$LikelyCode
        mov D$edi 'xor ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16
    Else             ; 0F 35 SYSEXIT
        inc D$UnLikelyCode
        mov D$edi 'syse', D$edi+4 'xit ' | add edi 7
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op36:
    inc D$UnLikelyCode
    inc D$Prefixes
    mov D$SegmentOverride 'ss: ', B$DisFlag DISDONE
ret


Op37: ; aaa
    inc D$LikelyCode
    mov D$edi 'aaa ', B$DisFlag DISDONE+DISLINEOVER | add edi 3
ret


Op38: ; CMP rm8 r8
    inc D$LikelyCode
    mov D$edi 'cmp ' | add edi 4 | jmp Dis_rm8_r8
ret


Op39: ; cmp rm32/rm16 r32/r16
    inc D$LikelyCode
    mov D$edi 'cmp ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16
ret


Op3A: ; CMP r8 rm8

    inc D$LikelyCode
    mov D$edi 'cmp ' | add edi 4 | jmp Dis_r8_rm8
ret


Op3B: ; r32/r16 cmp rm32/rm16
    inc D$LikelyCode
    mov D$edi 'cmp ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16
ret


Op3C: ; cmp al imm8
    inc D$LikelyCode
    mov D$edi 'cmp ' | add edi 4 | jmp Dis_al_imm8


Op3D: ; cmp eax // ax,  imm32 // imm16
    inc D$LikelyCode
    mov D$edi 'cmp ' | add edi 4 | jmp Dis_eax_ax__imm32_imm16


; Likely Taken Jump: This is a Mnemonic non defined by Intel, which purpose is to
; reverse the Jump Prediction. UTJ / LTJ have been defined in collaboration with
; the NASM developers group. UTJ / LTJ are prefixes to Jcc Instructions. I have no
; info about if it is active or not before JECXZ. As i think it can't hurt, i allow
; it in RosAsm assembling.

Op3E: ; Op2E for UTJ

    ; LTJ if Jcc:
  ;      70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F E3
  ; Of / 80 81 82 83 84 85 86 86 88 89 8A 8B 8C 8D 8E 8F

    mov al B$esi
        .If al = 0F
            mov al B$esi+1
            cmp al 080 | jb L5>
                cmp al 08F | ja L5>
                    inc esi | mov B$EscapePrefix &TRUE | jmp L3>

        .Else
            cmp al 0E3 | je L3>
                cmp al 070 | jb L5>
                    cmp al 07F | ja L5>
L3:                     mov D$edi 'ltj ' | add edi 4
                        push edi
                            movzx eax B$esi
                            inc esi | add edi 5 | call D$DisOp1+eax*4
                        pop eax
                        mov B$eax ' ' | mov B$DisFlag DISDONE+DISLINEOVER | ret

        .End_If

L5: mov D$SegmentOverride 'ds: '
    inc D$Prefixes
    inc D$UnLikelyCode

L9: mov B$DisFlag DISDONE
ret


Op3F: ; aas
    inc D$LikelyCode
    mov D$edi 'aas ', B$DisFlag DISDONE+DISLINEOVER | add edi 4
ret


Op40: ; cmovo
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        mov D$edi 'cmov', W$edi+4 'o ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16

    .Else
        inc D$LikelyCode
        mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            mov B$edi 'e' | inc edi
        End_If
        mov W$edi 'ax' | add edi 2 | mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op41: ; cmovno
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        mov D$edi 'cmov', D$edi+4 'no  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16

    .Else
        mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov B$edi 'e' | inc edi
        End_If
        mov W$edi 'cx' | add edi 2 | mov B$DisFlag DISDONE+DISLINEOVER
    .End_If
ret


Op42: ; cmovb / cmovc / cmovnae
    .If B$EscapePrefix = &TRUE
        mov D$edi 'cmov', W$edi+4 'c ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16

    .Else
        mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov B$edi 'e' | inc edi
        End_If
        mov W$edi 'dx' | add edi 2 | mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op43: ; cmovae / cmovnb / cmovnc
    .If B$EscapePrefix = &TRUE
        mov D$edi 'cmov', D$edi+4 'ae  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16

    .Else
        mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov B$edi 'e' | inc edi
        End_If
        mov W$edi 'bx' | add edi 2 | mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op44: ; cmove / cmovz
    .If B$EscapePrefix = &TRUE
        mov D$edi 'cmov', W$edi+4 'e ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16

    .Else
        mov D$edi 'inc ' | add edi 4
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &FALSE
            mov B$edi 'e' | inc edi
        End_If
        mov W$edi 'sp' | add edi 2 | mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op45: ; cmovne / cmonnz
    .If B$EscapePrefix = &TRUE
        mov D$edi 'cmov', D$edi+4 'ne  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16

    .Else
        mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov B$edi 'e' | inc edi
        End_If
        mov W$edi 'bp' | add edi 2 | mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op46: ; cmovbe : cmovna
    .If B$EscapePrefix = &TRUE
        mov D$edi 'cmov', D$edi+4 'be  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16

    .Else
        mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov B$edi 'e' | inc edi
        End_If
        mov W$edi 'si' | add edi 2 | mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op47: ; cmova / cmovnbe
    .If B$EscapePrefix = &TRUE
        mov D$edi 'cmov', W$edi+4 'a ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16

    .Else
        mov D$edi 'inc ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov B$edi 'e' | inc edi
        End_If
        mov W$edi 'di' | add edi 2 | mov B$DisFlag DISDONE+DISLINEOVER

    .End_If
ret


Op48: ; cmovs
    .If B$EscapePrefix = &FALSE
        mov D$edi 'dec ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov B$edi 'e' | inc edi
        End_If
        mov  W$edi 'ax' | add edi 2 | mov B$DisFlag DISDONE+DISLINEOVER
    .Else
        mov D$edi 'cmov', W$edi+4 's ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16
    .End_If
ret


Op49: ; cmovns
    .If B$EscapePrefix = &FALSE
        mov D$edi 'dec ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov B$edi 'e' | inc edi
        End_If
        mov  W$edi 'cx' | add edi 2 | mov B$DisFlag DISDONE+DISLINEOVER
    .Else
        mov D$edi 'cmov', D$edi+4 'ns  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16
    .End_If
ret


Op4A: ; cmovp / cmovpe
    .If B$EscapePrefix = &FALSE
        mov D$edi 'dec ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov B$edi 'e' | inc edi
        End_If
        mov  W$edi 'dx' | add edi 2 | mov B$DisFlag DISDONE+DISLINEOVER
    .Else
        mov D$edi 'cmov', W$edi+4 'p ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16
    .End_If
ret


Op4B: ; cmovnp / cmovpo
    .If B$EscapePrefix = &FALSE
        mov D$edi 'dec ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov B$edi 'e' | inc edi
        End_If
        mov  W$edi 'bx' | add edi 2 | mov B$DisFlag DISDONE+DISLINEOVER
    .Else
        mov D$edi 'cmov', D$edi+4 'np  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16
    .End_If
ret


Op4C: ; cmovl / cmovnge
    If B$EscapePrefix = &FALSE
        inc D$UnLikelyCode
        mov D$edi 'dec ', D$edi+4 'esp ' | add edi 7 | mov B$DisFlag DISDONE+DISLINEOVER
    Else
        mov D$edi 'cmov', W$edi+4 'l ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16
    End_If
ret


Op4D: ; cmovge / cmovnl
    If B$EscapePrefix = &FALSE
        mov D$edi 'dec ', D$edi+4 'ebp ' | add edi 7 | mov B$DisFlag DISDONE+DISLINEOVER
    Else
        mov D$edi 'cmov', D$edi+4 'ge  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16
    End_If
ret


Op4E: ; cmovle / cmovng
    If B$EscapePrefix = &FALSE
        mov D$edi 'dec ', D$edi+4 'esi ' | add edi 7 | mov B$DisFlag DISDONE+DISLINEOVER
    Else
        mov D$edi 'cmov', D$edi+4 'le  ' | add edi 7 | jmp Dis_r32_r16__rm32_rm16
    End_If
ret


Op4F: ; cmovg / cmovnle
    If B$EscapePrefix = &FALSE
        mov D$edi 'dec ', D$edi+4 'edi ' | add edi 7 | mov B$DisFlag DISDONE+DISLINEOVER
    Else
        mov D$edi 'cmov', W$edi+4 'g ' | add edi 6 | jmp Dis_r32_r16__rm32_rm16
    End_If
ret


Op50:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi ' eax' | add edi 4
        Else
           ; inc D$UnLikelyCode
            mov D$edi ' ax ' | add edi 3
        End_If

     .Else
        ;inc D$UnLikelyCode
        mov D$edi 'movm'
        If B$OperandSizeOverride = &TRUE ; 66 0F 50 /r MOVMSKPD r32, xmm
            mov D$edi+4 'skpd'
        Else            ; 0F 50 /r MOVMSKPS r32, xmm
            mov D$edi+4 'skps'
        End_If
        mov B$edi+8 ' ' | add edi 9 | jmp Dis_r32_xmm

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op51:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi ' ecx' | add edi 4
        Else
            ;inc D$UnLikelyCode
            mov D$edi ' cx ' | add edi 3
        End_If

    .Else
       ; inc D$UnLikelyCode
        mov D$edi 'sqrt'
        If B$OperandSizeOverride = &TRUE   ; 66 0F 51 /r SQRTPD xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'pd  '
        Else        ; 0F 51 /r SQRTPS xmm1, xmm2/m128
            call MarkSSEdata SSE_4_F
            mov D$edi+4 'ps  '
        End_If
        add edi 7 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op52:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi ' edx' | add edi 4
        Else
            ;inc D$UnLikelyCode
            mov D$edi ' dx ' | add edi 3
        End_If

    .Else   ; 0F 52 /r RSQRTPS xmm1, xmm2/m128
        call MarkSSEdata SSE_4_F
        mov D$edi 'rsqr', D$edi+4 'tps ' | add edi 8 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op53:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi ' ebx' | add edi 4
        Else
           ; inc D$UnLikelyCode
            mov D$edi ' bx ' | add edi 3
        End_If

    .Else  ; 0F 53 /r RCPPS xmm1, xmm2/m128
        call MarkSSEdata SSE_4_F
        mov D$edi 'rcpp', W$edi+4 's ' | add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op54:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            mov D$edi ' esp' | add edi 4
        Else
            inc D$UnlikelyCode
            mov D$edi ' sp ' | add edi 3
        End_If

    .Else
        mov D$edi 'andp' | add edi 4
        If B$OperandSizeOverride = &TRUE                ; 066 0F 054 ...
            call MarkSSEdata SSE_2_R    ; ANDPD 66 0F 54 /r
            mov W$edi 'd '
        Else
            call MarkSSEdata SSE_4_F
            mov W$edi 's '              ; ANDPS 0F 54 /r
        End_If
        add edi 2 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op55:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi ' ebp' | add edi 4
        Else
            inc D$UnLikelyCode
            mov D$edi ' bp ' | add edi 3
        End_If

    .Else
        ;inc D$UnLikelyCode
        mov D$edi 'andn' | add edi 4
        If B$OperandSizeOverride = &TRUE
            call MarkSSEdata SSE_2_R
            mov D$edi 'pd  '    ; ANDNPD 66 0F 55 /r
        Else
            call MarkSSEdata SSE_4_F
            mov D$edi 'ps  '    ; ANDNPS 0F 55 /r
        End_If
        add edi 3 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op56:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi ' esi' | add edi 4
        Else
            inc D$UnLikelyCode
            mov D$edi ' si ' | add edi 3
        End_If

    .Else
        ;inc D$UnLikelyCode
        If B$OperandSizeOverride = &TRUE    ; ORPD xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov D$edi 'orpd'
        Else        ; ORPS xmm1, xmm2/m128
            call MarkSSEdata SSE_4_F
            mov D$edi 'orps'
        End_If
        mov B$edi+4 ' ' | add edi 5 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op57:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'push' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi ' edi' | add edi 4
        Else
            inc D$UnLikelyCode
            mov D$edi ' di ' | add edi 3
        End_If

    .Else
        ;inc D$UnLikelyCode
        mov D$edi 'xorp'
        If B$OperandSizeOverride = &TRUE  ; 66 0F 57 /r XORPD xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov W$edi+4 'd '
        Else        ; 0F 57 /r XORPS xmm1, xmm2/m128
            call MarkSSEdata SSE_4_F
            mov W$edi+4 's '
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op58:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi 'eax ' | add edi 3
        Else
           ; inc D$UnLikelyCode
            mov W$edi 'ax' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode
        mov D$edi 'addp'
        If B$OperandSizeOverride = &TRUE       ; 066 0F 058...
            call MarkSSEdata SSE_2_R
            mov W$edi+4 'd '                   ; ADDPD
        Else
            call MarkSSEdata SSE_4_F
            mov W$edi+4 's '                   ; ADDPS
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op59:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi 'ecx ' | add edi 3
        Else
           ; inc D$UnLikelyCode
            mov D$edi 'cx' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode
        mov D$edi 'mulp'
        If B$OperandSizeOverride = &TRUE        ; 66 0F 59 /r MULPD xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov W$edi+4 'd '
        Else        ; 0F 59 /r MULPS xmm1, xmm2/m128
            call MarkSSEdata SSE_4_F
            mov W$edi+4 's '
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op5A:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi 'edx ' | add edi 3
        Else
           ; inc D$UnLikelyCode
            mov W$edi 'dx' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode
        mov D$edi 'cvtp'
        If B$OperandSizeOverride = &TRUE    ; CVTPD2PS xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'd2ps', B$edi+8 ' ' | add edi 9 | jmp Dis_xmm1__xmm2_m128
        Else                                ; CVTPS2PD xmm1, xmm2/m64
            call MarkSSEdata SSE_2_F
            mov D$edi+4 's2pd', B$edi+8 ' ' | add edi 9 | jmp Dis_xmm1__xmm2_m64
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op5B:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi 'ebx ' | add edi 3
        Else
           ; inc D$UnLikelyCode
            mov W$edi 'bx' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode

        If B$OperandSizeOverride = &TRUE ; CVTPS2DQ xmm1, xmm2/m128
            call MarkSSEdata SSE_4_F
            mov D$edi 'cvtp', D$edi+4 's2dq'
        Else                             ; CVTDQ2PS xmm1, xmm2/m128
            call MarkSSEdata SSE_4_D
            mov D$edi 'cvtd', D$edi+4 'q2ps'
        End_If
        mov B$edi+8 ' ' | add edi 9 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op5C:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'esp ' | add edi 3
        Else
            inc D$UnLikelyCode
            mov W$edi 'sp' | add edi 2
        End_If

    .Else
        mov D$edi 'subp'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 5C /r SUBPD xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov W$edi+4 'd '
        Else    ; 0F 5C /r SUBPS xmm1 xmm2/m128
            call MarkSSEdata SSE_4_F
            mov W$edi+4 's '
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op5D:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi 'ebp ' | add edi 3
        Else
            inc D$UnLikelyCode
            mov W$edi 'bp' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode
        mov D$edi 'minp'
        If B$OperandSizeOverride = &TRUE ; MINPD xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov W$edi+4 'd '
        Else        ; MINPS xmm1, xmm2/m128
            call MarkSSEdata SSE_4_F
            mov W$edi+4 's '
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op5E:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi 'esi ' | add edi 3
        Else
            inc D$UnLikelyCode
            mov W$edi 'si' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode
        mov D$edi 'divp'
        If B$OperandSizeOverride = &TRUE    ; DIVPD xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov W$edi+4 'd '
        Else                                ; DIVPS xmm1, xmm2/m128
            call MarkSSEdata SSE_4_F
            mov W$edi+4 's '
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op5F:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi 'edi ' | add edi 3
        Else
            inc D$UnLikelyCode
            mov W$edi 'di' | add edi 2
        End_If

    .Else
        ;inc D$UnLikelyCode
        mov D$edi 'maxp'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 5F /r MAXPD xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov W$edi+4 'd '
        Else                                ; MAXPS xmm1, xmm2/m128
            mov W$edi+4 's '
        End_If
        add edi 6 | jmp Dis_xmm1__xmm2_m128

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op60:
    .If B$EscapePrefix = &FALSE   ; 60 PUSHA 60 PUSHAD
        inc D$LikelyCode
        mov D$edi 'push', B$edi+4 'a' | add edi 5
        If B$OperandSizeOverride = &FALSE
            mov B$edi 'd' | inc edi
        End_If

    .Else; 0F 60 /r PUNPCKLBW mm, mm/m32   ; 66 0F 60 /r PUNPCKLBW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'punp', D$edi+4 'cklb', W$edi+8 'w ' | add edi 10
        If B$OperandSizeOverride = &TRUE
            jmp Dis_xmm1__xmm2_m128
        Else
            jmp Dis_mmx1__mmx2_m64
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op61:
    .If B$EscapePrefix = &FALSE   ; 61 POPA     ; 61 POPAD
        inc D$LikelyCode
        mov D$edi 'popa' | add edi 4
        If B$OperandSizeOverride = &FALSE
            mov B$edi 'd' | inc edi
        End_If

    .Else ; 0F 61 /r PUNPCKLWD mm, mm/m32   ; 66 0F 61 /r PUNPCKLWD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'punp', D$edi+4 'cklw', W$edi+8 'd ' | add edi 10
        If B$OperandSizeOverride = &TRUE
            jmp Dis_xmm1__xmm2_m128
        Else
            jmp Dis_mmx1__mmx2_m64
        End_If
    .End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op62:
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
      ; 0F 62 /r PUNPCKLDQ mm, mm/m32   ; 66 0F 62 /r PUNPCKLDQ xmm1, xmm2/m128
        mov D$edi 'punp', D$edi+4 'ckld', W$edi+8 'q ' | add edi 10
        If B$OperandSizeOverride = &TRUE
            jmp Dis_xmm1__xmm2_m128
        Else
            jmp Dis_mmx1__mmx2_m64
        End_If
    .Else
        inc D$UnLikelyCode
        mov D$edi 'boun', W$edi+4 'd ' | add edi 6  ; BOUND
        jmp Dis_r32_r16__rm32_rm16
    .End_If



Op63:
    ;inc D$UnLikelyCode
    .If B$EscapePrefix = &TRUE
        mov D$edi 'pack', D$edi+4 'sswb', B$edi+8 ' ' | add edi 9
        If B$OperandSizeOverride = &TRUE    ; 66 0F 63 /r PACKSSWB xmm1, xmm2/m128
            jmp Dis_xmm1__xmm_m128
        Else        ; 0F 63 /r PACKSSWB mm1, mm2/m64
            jmp Dis_mmx1__mmx2_m64
        End_If

    .Else
        inc D$UnlikelyCode
        mov D$edi 'arpl', B$edi+4 ' ' | add edi 5 ; ARPL
        mov B$OperandSizeOverride &TRUE             ; to avoid one more case for 16/16

        jmp Dis_rm32_rm16__r32_r16

    .End_If


Op64:
    .If B$EscapePrefix = &TRUE
      ;0F 64 /r PCMPGTB mm, mm/m64 ;66 0F 64 /r PCMPGTB xmm1, xmm2/m128
        mov D$edi 'pcmp', D$edi+4 'gtb ' | add edi 8
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
        mov D$SegmentOverride 'fs: ', B$DisFlag DISDONE
        inc D$Prefixes

    .End_If
ret


Op65:
    .If B$EscapePrefix = &TRUE
      ; 0F 65 /r PCMPGTW mm, mm/m64   ; 66 0F 65 /r PCMPGTW xmm1, xmm2/m128
        mov D$edi 'pcmp', D$edi+4 'gtw ' | add edi 8
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
        mov D$SegmentOverride 'gs: ', B$DisFlag DISDONE
        inc D$Prefixes
        inc D$UnLikelyCode
    .End_If
ret


Op66:
    .If B$EscapePrefix = &TRUE  ; 0F 66 /r PCMPGTD mm, mm/m64
        ;inc D$UnLikelyCode
        mov D$edi 'pcmp', D$edi+4 'gtd ' | add edi 8
        jmp Dis_mmx1__mmx2_m64

    .Else_If W$esi = 0660F      ; 66 0F 66 /r PCMPGTD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        add esi 2
        mov D$edi 'pcmp', D$edi+4 'gtd ' | add edi 8
        jmp Dis_xmm1__xmm2_m128

    .Else_If W$esi = 07C0F      ; 66,0F,7C,/r HADDPD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        add esi 2 | call MarkSSEdata SSE_2_R
        mov D$edi 'hadd', D$edi+4 'pd ' | add edi 7
        jmp Dis_xmm1__xmm2_m128

    .Else_If W$esi = 07D0F      ; 66,0F,7D,/r HSUBPD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        add esi 2 | call MarkSSEdata SSE_2_R
        mov D$edi 'hsub', D$edi+4 'pd ' | add edi 7
        jmp Dis_xmm1__xmm2_m128

    .Else_If W$esi = 0D00F      ; 66,0F,D0,/r ADDSUBPD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        add esi 2
        call MarkSSEdata SSE_2_R
        mov D$edi 'adds', D$edi+4 'ubpd', B$edi+8 ' ' | add edi 9
        jmp Dis_xmm1__xmm2_m128

    .Else
        On B$OperandSizeOverride = &TRUE, inc D$UnLikelyCode
        mov B$OperandSizeOverride &TRUE, B$DisFlag DISDONE, W$DisSizeMarker 'W$'
        inc D$Prefixes
    .End_If
ret


Op67:
    .If B$EscapePrefix = &FALSE
        On B$AddressSizeOverride = &TRUE, inc D$UnLikelyCode
        mov B$AddressSizeOverride &TRUE, B$DisFlag DISDONE
        inc D$Prefixes

    .Else   ; 66 0F 67 /r PACKUSWB xmm1, xmm2/m128 ; 0F 67 /r PACKUSWB mm, mm/m64
        ;inc D$UnLikelyCode
        mov D$edi 'pack', D$edi+4 'uswb', B$edi+8 ' ' | add edi 9
        jmp Dis_xmmx1__xmmx2_m64_128

    .End_If
ret


Op68:
    .If B$EscapePrefix = &FALSE   ; 68 PUSH imm16 / 32
        inc D$LikelyCode
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'push', B$edi+4 ' ' | add edi 5
        Else
            mov D$edi 'push', W$edi+4 'W ' | add edi 6
        End_If
        jmp Dis_imm32_16

    .Else ; 0F 68 /r PUNPCKHBW mm, mm/m64   ; 66 0F 68 /r PUNPCKHBW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'punp', D$edi+4 'ckhb', W$edi+8 'w ' | add edi 10
        jmp Dis_xmmx1__xmmx2_m64_128
    .End_If
ret


Op69:
    .If B$EscapePrefix = &TRUE
      ; 0F 69 /r PUNPCKHWD mm, mm/m64   ; 66 0F 69 /r PUNPCKHWD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'punp', D$edi+4 'ckhw', W$edi+8 'd ' | add edi 10
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
      ; IMUL r16,r/m16,imm16 (word register r/m16 * immediate word) (+ 32)
        inc D$LikelyCode
        mov D$edi 'imul', B$edi+4 ' ' | add edi 5
        jmp Dis_r32_r16__rm32_rm16_OrNone__SignedImm16_32
    .End_If
ret


Op6A:
    .If B$EscapePrefix = &TRUE
      ; 0F 6A /r PUNPCKHDQ mm, mm/m64   ; 66 0F 6A /r PUNPCKHDQ xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'punp', D$edi+4 'ckhd', W$edi+8 'q ' | add edi 10
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else       ; 6A PUSH imm8
        inc D$LikelyCode
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'push', B$edi+4 ' ' | add edi 5 | jmp Dis_Imm8
        Else
            mov D$edi 'push', W$edi+4 'W ' | add edi 6 | jmp Dis_Imm8
        End_If
    .End_If
ret


Op6B:
    .If B$EscapePrefix = &TRUE
      ; 66 0F 6B /r PACKSSDW xmm1, xmm2/m128 ; 0F 6B /r PACKSSDW mm1, mm2/m64
        ;inc D$UnLikelyCode
        mov D$edi 'pack', D$edi+4 'ssdw', B$edi+8 ' ' | add edi 9
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else  ; 6B /r ib > IMUL r16,r/m16,imm8
        inc D$LikelyCode
        mov D$edi 'imul', B$edi+4 ' ' | add edi 5
        jmp Dis_r32_r16__rm32_rm16_OrNone__SignedImm8

    .End_If
ret


Op6C:
    .If B$EscapePrefix = &TRUE
      ; 66 0F 6C /r PUNPCKLQDQ xmm1, xmm2/m128
        mov D$edi 'punp', D$edi+4 'cklq', D$edi+8 'dq  ' | add edi 11
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
      ; INS m8, DX (ins 'B$es:edi dx')
        inc D$UnLikelyCode
        mov D$edi 'insb' | add edi 4

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op6D:

    .If B$EscapePrefix = &TRUE
      ; 66 0F 6D /r PUNPCKHQDQ xmm1, xmm2/m128
        mov D$edi 'punp', D$edi+4 'ckhq', D$edi+8 'dq  ' | add edi 11
        jmp Dis_xmm1__xmm2_m128

    .Else ; INS m32, DX +16
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &TRUE
            mov D$edi 'insw'
        Else
            mov D$edi 'insd'
        End_If
        add edi 4

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op6E:
    .If B$EscapePrefix = &TRUE
        inc D$LikelyCode
        mov D$edi 'movd', B$edi+4 ' ' | add edi 5
        If B$OperandSizeOverride = &TRUE    ; 66 0F 6E /r MOVD xmm, r/m32
            jmp Dis_xmm_rm32
        Else         ; 0F 6E /r MOVD mm, r/m32
            jmp Dis_mmx_rm32
        End_If

    .Else       ; OUTS DX, m8
        inc D$UnLikelyCode
        mov D$edi 'outs', B$edi+4 'B' | add edi 5

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op6F:
    .If B$EscapePrefix = &TRUE
        inc D$LikelyCode
        If B$OperandSizeOverride = &TRUE        ; MOVDQA xmm1, xmm2/m128
            mov D$edi 'movd', D$edi+4 'qa  ' | add edi 7 | jmp Dis_xmm1__xmm2_m128
        Else        ; 0F 6F /r MOVQ mm, mm/m64
            mov D$edi 'movq', B$edi+4 ' ' | add edi 5 | jmp Dis_mmx1__mmx2_m64
        End_If

    .Else       ; OUTSW OUTSD
        inc D$UnLikelyCode
        mov D$edi 'outs' | add edi 4
        If B$OperandSizeOverride = &TRUE
            mov D$edi 'W'
        Else
            mov D$edi 'D'
        End_If
        inc edi

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op70:
    .If B$EscapePrefix = &FALSE        ; JO rel8
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', W$edi+4 'o ' | add edi 6
        jmp EndWithDisByteRelative

    .Else
        ;inc D$UnLikelyCode
        mov D$edi 'pshu'
        If B$OperandSizeOverride = &TRUE    ; 66 0F 70 /r ib PSHUFD xmm1, xmm2/m128, imm8
            mov D$edi+4 'fd  '
            add edi 7 | call Dis_xmm1__xmm2_m128
        Else        ; 0F 70 /r ib PSHUFW mm1, mm2/m64, imm8
            mov D$edi+4 'fw  '
            add edi 7 | call Dis_mm1__mm2_m128
        End_If
        mov D$edi ' ' | inc edi | call WriteImm8

    .End_If
     mov B$DisFlag DISDONE+DISLINEOVER
ret


Op71:
    .If B$EscapePrefix = &FALSE        ; JNO rel8
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'no  ' | add edi 7
        jmp EndWithDisByteRelative

    .Else
        mov bl B$esi | inc esi | DigitMask bl To al

        If al = 2   ; 0F 71 /2 ib PSRLW mm, imm8    ; 66 0F 71 /2 ib PSRLW xmm1, imm8
            mov D$edi 'psrl'
        Else_If al = 4   ; 0F 71 /4 ib PSRAW mm, imm8   ; 66 0F 71 /4 ib PSRAW xmm1, imm8
            mov D$edi 'psra'
        Else_If al = 6   ; 0F 71 /6 ib PSLLW mm, imm8 ; 66 0F 71 /6 ib PSLLW xmm1, imm8
            mov D$edi 'psll'
        Else
            inc D$UnLikelyCode | dec esi | ret
        End_If
        mov W$edi+4 'w ' | add edi 6 | jmp Dis_xmmx_imm8

    .End_If


Op72:
    .If B$EscapePrefix = &FALSE ; JB rel8 ; JNAE rel8
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', W$edi+4 'b ' | add edi 6
        jmp EndWithDisByteRelative

    .Else
        mov bl B$esi | inc esi | DigitMask bl To al

        If al = 2      ; 0F 72 /2 ib PSRLD mm, imm8  ; 66 0F 72 /2 ib PSRLD xmm1, imm8
            mov D$edi 'psrl'
        Else_If al = 4 ; 0F 72 /4 ib PSRAD mm, imm8  ; 66 0F 72 /4 ib PSRAD xmm1, imm8
            mov D$edi 'psra'
        Else_If al = 6 ; 0F 72 /6 ib PSLLD mm, imm8  ; 66 0F 72 /6 ib PSLLD xmm1, imm8
            mov D$edi 'psll'
        Else
            inc D$UnLikelyCode | dec esi | ret
        End_If
        mov W$edi+4 'd ' | add edi 6 | jmp Dis_xmmx_imm8

    .End_If



Op73:
    ...If B$EscapePrefix = &TRUE
        mov bl B$esi | inc esi | DigitMask bl To al

        .If al = 2   ; 0F 73 /2 ib PSRLQ mm, imm8  ; 66 0F 73 /2 ib PSRLQ xmm1, imm8
            mov D$edi 'psrl', W$edi+4 'q ' | add edi 6
            jmp Dis_xmmx_imm8
        .Else_If al = 3    ; 66 0F 73 /3 ib PSRLDQ xmm1, imm8
            If B$OperandSizeOverride = &TRUE
                mov D$edi 'psrl', D$edi+4 'dq  ' | add edi 7
                jmp Dis_xmm_imm8
            End_If
            inc D$UnLikelyCode
        .Else_If al = 6
              ; 0F 73 /6 ib PSLLQ mm, imm8 ; 66 0F 73 /6 ib PSLLQ xmm1, imm8
            mov D$edi 'psll', W$edi+4 'q ' | add edi 6 | jmp Dis_xmmx_imm8
        .Else_If al = 7    ; 66 0F 73 /7 ib PSLLDQ xmm1, imm8
            If B$OperandSizeOverride = &TRUE
                mov D$edi 'psll', D$edi+4 'dq  ' | add edi 7
                jmp Dis_xmm_imm8
            End_If
            inc D$UnLikelyCode
        .Else
            inc D$UnLikelyCode | dec esi | ret
        .End_If

    ...Else        ; JAE rel8 ; JNB rel8 ; JNC rel8
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'ae  ' | add edi 7
        jmp EndWithDisByteRelative

    ...End_If
ret


Op74:
    If B$EscapePrefix = &FALSE  ; JE rel8 ; JZ rel8
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', W$edi+4 'e ' | add edi 6
        jmp EndWithDisByteRelative

    Else
      ; 0F 74 /r PCMPEQB mm, mm/m64    ; 66 0F 74 /r PCMPEQB xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'pcmp', D$edi+4 'eqb ', B$edi+8 ' ' | add edi 8
        jmp Dis_xmmx1__xmmx2_m64_128

    End_If


Op75:
    If B$EscapePrefix = &FALSE  ; JNE rel8 ; JNZ rel8
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'ne  ' | add edi 7
        jmp EndWithDisByteRelative

    Else
      ; 0F 75 /r PCMPEQW mm, mm/m64     ; 66 0F 75 /r PCMPEQW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'pcmp', D$edi+4 'eqw ', B$edi+8 ' ' | add edi 8
        jmp Dis_xmmx1__xmmx2_m64_128

    End_If


Op76:
    If B$EscapePrefix = &FALSE        ; JBE rel8 ; JNA rel8
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'be  ' | add edi 7
        jmp EndWithDisByteRelative

    Else
      ; 0F 76 /r PCMPEQD mm, mm/m64     ; 66 0F 76 /r PCMPEQD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'pcmp', D$edi+4 'eqd ', B$edi+8 ' ' | add edi 8
        jmp Dis_xmmx1__xmmx2_m64_128

    End_If


Op77:
    If B$EscapePrefix = &FALSE        ; JA rel8 ; JNBE rel8
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', W$edi+4 'a ' | add edi 6 | jmp EndWithDisByteRelative

    Else     ; EMMS
        mov D$edi 'emms' | add edi 4

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op78: ; JS rel8
    inc D$LikelyCode
    mov B$CALLInstruction &TRUE
    SubEdi6 | mov D$edi ' | j', W$edi+4 's ' | add edi 6 | jmp EndWithDisByteRelative
ret


Op79: ; JNS rel8
    inc D$LikelyCode
    mov B$CALLInstruction &TRUE
    SubEdi6 | mov D$edi ' | j', D$edi+4 'ns  ' | add edi 7 | jmp EndWithDisByteRelative
ret


Op7A: ; JP rel8 ; JPE rel8
    inc D$LikelyCode
    mov B$CALLInstruction &TRUE
    SubEdi6 | mov D$edi ' | j', W$edi+4 'p ' | add edi 6 | jmp EndWithDisByteRelative
ret


Op7B: ; JNP rel8 ; JPO rel8
    inc D$LikelyCode
    mov B$CALLInstruction &TRUE
    SubEdi6 | mov D$edi ' | j', D$edi+4 'np  ' | add edi 7 | jmp EndWithDisByteRelative
ret


Op7C: ; JL rel8 ; JNGE rel8
    inc D$LikelyCode
    mov B$CALLInstruction &TRUE
    SubEdi6 | mov D$edi ' | j', W$edi+4 'l ' | add edi 6 | jmp EndWithDisByteRelative
ret


Op7D: ; JGE rel8 ; JNL rel8
    inc D$LikelyCode
    mov B$CALLInstruction &TRUE
    SubEdi6 | mov D$edi ' | j', D$edi+4 'ge  ' | add edi 7 | jmp EndWithDisByteRelative
ret


Op7E:
    inc D$LikelyCode
    If B$EscapePrefix = &FALSE     ; JLE rel8 ; JNG rel8
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'le  ' | add edi 7
        jmp EndWithDisByteRelative

    Else
       ; 66 0F 7E /r MOVD r/m32, xmm ; 0F 7E /r MOVD r/m32, mm
         mov D$edi 'movd', B$edi+4 ' ' | add edi 5 | jmp Dis_rm32_xmmx

    End_If


Op7F:
    .If B$EscapePrefix = &FALSE  ; JG rel8 ; JNLE rel8
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', W$edi+4 'g ' | add edi 6
        jmp EndWithDisByteRelative

    .Else
        If B$OperandSizeOverride = &TRUE    ; 66 0F 7F /r MOVDQA xmm2/m128, xmm1
            mov D$edi 'movd', D$edi+4 'qa  ' | add edi 7
            jmp Dis_xmm2_m128__xmm1
        Else        ; 0F 7F /r MOVQ mm/m64, mm
            mov D$edi 'movq', B$edi+4 ' ' | add edi 5
            jmp Dis_mmx1_m64__mmx2
        End_If

    .End_If


Op80:
    inc D$LikelyCode
    ..If B$EscapePrefix = &TRUE       ; 0F 80 cw/cd JO rel16/32
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', W$edi+4 'o ' | add edi 6
        jmp EndWithDisWordDwordRelative

    ..Else
        mov bl B$esi | inc esi | DigitMask bl To al              ; ModRm with /2 ?

        .If al = 0
            mov B$LockPrefix &FALSE
            mov D$edi 'add ' | add edi 4
        .Else_If al = 1  ; OR r/m8,imm8
            mov B$LockPrefix &FALSE
            mov D$edi 'or  ' | add edi 3
        .Else_If al = 2  ; adc r/m8 imm8
            mov B$LockPrefix &FALSE
            mov D$edi 'adc ' | add edi 4
        .Else_If al = 3  ; 80 /3 ib SBB r/m8,imm8
            mov B$LockPrefix &FALSE
            mov D$edi 'sbb ' | add edi 4
        .Else_If al = 4
            mov B$LockPrefix &FALSE
            mov D$edi 'and ' | add edi 4
        .Else_If al = 5  ; 80 /5 ib SUB r/m8,imm8
            mov B$LockPrefix &FALSE
            mov D$edi 'sub ' | add edi 4
        .Else_If al = 6  ; 80 /6 ib XOR r/m8,imm8
            mov B$LockPrefix &FALSE
            mov D$edi 'xor ' | add edi 4
        .Else_If al = 7
            mov D$edi 'cmp ' | add edi 4
        .End_If

        jmp Dis_rm8_imm8

    ..End_If


Op81:
    inc D$LikelyCode
    ..If B$EscapePrefix = &TRUE      ; JNO rel16/32
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'no  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    ..Else
      ; adc r/m32//r/m16 imm32/imm16
        mov bl B$esi | inc esi | DigitMask bl To al              ; ModRm with /2 ?

        .If al = 0
            mov B$LockPrefix &FALSE
            mov D$edi 'add ' | add edi 4
        .Else_If al = 1      ; OR r/m16,imm16 // OR r/m32,imm32
            mov B$LockPrefix &FALSE
            mov D$edi 'or  ' | add edi 3
        .Else_If al = 2
            mov B$LockPrefix &FALSE
            mov D$edi 'adc ' | add edi 4
        .Else_If al = 3  ; 81 /3 iw SBB r/m16,imm16  ; 81 /3 id SBB r/m32,imm32
            mov B$LockPrefix &FALSE
            mov D$edi 'sbb ' | add edi 4
        .Else_If al = 4
            mov B$LockPrefix &FALSE
            mov D$edi 'and ' | add edi 4
        .Else_If al = 5  ; 81 /5 iw SUB r/m16,imm16 ; 81 /5 id SUB r/m32,imm32
            mov B$LockPrefix &FALSE
            mov D$edi 'sub ' | add edi 4
        .Else_If al = 6  ; 81 /6 iw XOR r/m16,imm16 ; 81 /6 id XOR r/m32,imm32
            mov B$LockPrefix &FALSE
            mov D$edi 'xor ' | add edi 4
        .Else_If al = 7
            mov D$edi 'cmp ' | add edi 4
        .End_If

        jmp Dis_rm32_rm16__imm32_imm16

    ..End_If


Op82:
    If B$EscapePrefix = &TRUE       ; JB rel16/32 ; JC rel16/32 ; JNAE rel16/32
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', W$edi+4 'b ' | add edi 6
        jmp EndWithDisWordDwordRelative
    End_If
ret


Op83:
    inc D$LikelyCode

    ..If B$EscapePrefix = &TRUE      ; JAE rel16/32 ; JNB rel16/32 ; JNC rel16/32
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'ae  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    ..Else

        mov bl B$esi | inc esi | DigitMask bl To al              ; ModRm with /2 ?

        .If al = 0
            mov B$LockPrefix &FALSE
            mov D$edi 'add ' | add edi 4
        .Else_If al = 1      ; OR r/m16,imm8 // OR r/m32,imm8
            mov B$LockPrefix &FALSE
            mov D$edi 'or  ' | add edi 3
        .Else_If al = 2   ; adc r/m32//r/m16 imm8
            mov B$LockPrefix &FALSE
            mov D$edi 'adc ' | add edi 4
        .Else_If al = 3  ; 83 /3 ib SBB r/m16,imm8   ; 83 /3 ib SBB r/m32,imm8
            mov B$LockPrefix &FALSE
            mov D$edi 'sbb ' | add edi 4
        .Else_If al = 4
            mov B$LockPrefix &FALSE
            mov D$edi 'and ' | add edi 4
        .Else_If al = 5  ; 83 /5 ib SUB r/m16,imm8 ; 83 /5 ib SUB r/m32,imm8
            mov B$LockPrefix &FALSE
            mov D$edi 'sub ' | add edi 4
        .Else_If al = 6  ; 83 /6 ib XOR r/m16,imm8 ; 83 /6 ib XOR r/m32,imm8
            mov B$LockPrefix &FALSE
            mov D$edi 'xor ' | add edi 4
        .Else_If al = 7
            mov D$edi 'cmp ' | add edi 4
        .End_If

        jmp Dis_rm32_rm16__imm8

    ..End_If


Op84:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE       ; JE rel16/32 ; JZ rel16/32 ; JZ rel16/32
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', W$edi+4 'e ' | add edi 6
        jmp EndWithDisWordDwordRelative

    Else    ; 84 /r TEST r/m8,r8
        mov D$edi 'test', B$edi+4 ' ' | add edi 5 | jmp Dis_rm8_r8

    End_If


Op85:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE    ; JNE rel16/32 ; JNZ rel16/32
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'ne  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    Else    ; 85 /r TEST r/m16,r16 ; 85 /r TEST r/m32,r32
        mov D$edi 'test', B$edi+4 ' ' | add edi 5 | jmp Dis_rm32_rm16__r32_r16

    End_If


Op86:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE    ; JBE rel16/32 ; JNA rel16/32
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'be  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    Else        ; 86 /r XCHG r/m8, r8
        mov B$LockPrefix &FALSE
        mov D$edi 'xchg', B$edi+4 ' ' | add edi 5 | jmp Dis_rm8_r8

    End_If


Op87:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE    ; 0F 87 cw/cd > JA rel16/32 ; JNBE rel16/32
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', W$edi+4 'a ' | add edi 6

        jmp EndWithDisWordDwordRelative

    Else        ; 87 /r XCHG r/m16, r16 ; 87 /r XCHG r/m32, r32 ( and reverse)
        mov B$LockPrefix &FALSE
        mov D$edi 'xchg', B$edi+4 ' ' | add edi 5 | jmp Dis_r32_r16__rm32_rm16

    End_If


Op88:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE           ; JS rel16/32
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 's ' | add edi 6
        jmp EndWithDisWordDwordRelative

    Else    ; MOV r/m8,r8
        mov D$edi 'mov ' | add edi 4 | jmp Dis_rm8_r8

    End_If


Op89:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE           ; JNS rel16/32
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'ns  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    Else        ; MOV r/m16,r16 ; MOV r/m32,r32
        mov D$edi 'mov ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16

    End_If


Op8A:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE           ; JP rel16/32 ; JPE rel16/32
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'p ' | add edi 6
        jmp EndWithDisWordDwordRelative

    Else        ; MOV r8,r/m8
        mov D$edi 'mov ' | add edi 4 | jmp Dis_r8_rm8

    End_If


Op8B:
    inc D$LikelyCode

    If B$EscapePrefix = &TRUE           ; JNP rel16/32 ; JPO rel16/32
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'np  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    Else        ; MOV r16,r/m16 ; MOV r32,r/m32
        mov D$edi 'mov ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16

    End_If


Op8C:
    .If B$EscapePrefix = &TRUE           ; JL rel16/32 ; JNGE rel16/32
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'l ' | add edi 6
        jmp EndWithDisWordDwordRelative

    .Else        ; MOV r/m16,Sreg** (there was a 066...)
        inc D$UnLikelyCode
        mov D$edi 'mov ' | add edi 4
        If B$OperandSizeOverride = &TRUE
            jmp Dis_rm16_Sreg
        Else
            jmp Dis_rm32_Sreg
        End_If
    .End_If
ret


Op8D:
    inc D$LikelyCode

    .If B$EscapePrefix = &TRUE           ; JGE rel16/32 ; JNL rel16/32
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'ge  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    .Else            ; LEA r16,m
        If B$esi > 00_10_111_111      ; Never: lea eax ebx
            inc D$UnLikelyCode
            ret
        Else

        ;If B$TestNow = 1
        ;    On D$esi+1 = 04398C0, int3
        ;End_If

            mov B$LeaInstruction &TRUE
            mov D$edi 'lea ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16
        End_If
    .End_If


Op8E:
    .If B$EscapePrefix = &TRUE           ; JLE rel16/32 ; JNG rel16/32
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', D$edi+4 'le  ' | add edi 7
        jmp EndWithDisWordDwordRelative

    .Else        ; MOV Sreg,r/m16** (there was a 066...)
        inc D$UnLikelyCode
        mov D$edi 'mov ' | add edi 4
      ;  If B$OperandSizeOverride = &TRUE
            jmp Dis_Sreg_rm16
      ;  Else
      ;      jmp Dis_Sreg_rm32 ; Too absurd to keep it that way >>> Forced to Word.
      ;  End_If

    .End_If
ret


Op8F:
    .If B$EscapePrefix = &TRUE           ; JG rel16/32 ; JNLE rel16/32
        inc D$LikelyCode
        mov B$CALLInstruction &TRUE
        SubEdi6 | mov D$edi ' | j', W$edi+4 'g ' | add edi 6
        jmp EndWithDisWordDwordRelative

    .Else
        mov bl B$esi | inc esi | DigitMask bl To al

        If al = 0       ; 8F /0 POP m16
            mov D$edi 'pop ' | add edi 4 | jmp EndWithModRm
        Else
            inc D$UnLikelyCode | dec esi | ret
        End_If
    .End_If


Op90:
    If B$EscapePrefix = &FALSE  ; NOP ;  ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        mov D$edi 'nop ' | add edi 4

    Else     ; 0F 90 SETO r/m8
       ; inc D$UnLikelyCode
        mov D$edi 'seto', B$edi+4 ' ' | add edi 5 | jmp Dis_rm8

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op91: ; 0F 91 SETNO r/m8
    If B$EscapePrefix = &TRUE
       ; inc D$UnLikelyCode
        mov D$edi 'setn', W$edi+4 'o ' | add edi 6 | jmp Dis_rm8

    Else    ; ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        mov D$edi 'xchg', B$edi+4 ' ' | add edi 5 | jmp Dis_eax_ax__rd_rw

    End_If


Op92: ; 0F 92 SETB r/m8 ; 0F 92 SETC r/m8  ; 0F 92 SETNAE r/m8
    If B$EscapePrefix = &FALSE    ; ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        mov D$edi 'xchg', B$edi+4 ' ' | add edi 5 | jmp Dis_eax_ax__rd_rw

    Else
       ; inc D$UnLikelyCode
        mov D$edi 'setc', B$edi+4 ' ' | add edi 5 | jmp Dis_rm8

    End_If


Op93:
    If B$EscapePrefix = &FALSE   ; ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        mov D$edi 'xchg', B$edi+4 ' ' | add edi 5 | jmp Dis_eax_ax__rd_rw

    Else
       ; inc D$UnLikelyCode
      ; 0F 93 SETAE r/m8    ; 0F 93 SETNB r/m8  ; 0F 93 SETNC r/m8
        mov D$edi 'seta', W$edi+4 'e ' | add edi 6 | jmp Dis_rm8

    End_If


Op94: ; 0F 94 SETE r/m8 ; 0F 94 SETZ r/m8
    If B$EscapePrefix = &FALSE    ; ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        mov D$edi 'xchg', B$edi+4 ' ' | add edi 5 | jmp Dis_eax_ax__rd_rw

    Else
       ; inc D$UnLikelyCode
        mov D$edi 'sete', B$edi+4 ' ' | add edi 5 | jmp Dis_rm8

    End_If


Op95: ; 0F 95 SETNE r/m8 ; 0F 95 SETNZ r/m8
    If B$EscapePrefix = &FALSE    ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        mov D$edi 'xchg', B$edi+4 ' ' | add edi 5 | jmp Dis_eax_ax__rd_rw

    Else
       ; inc D$UnLikelyCode
        mov D$edi 'setn', W$edi+4 'e ' | add edi 6 | jmp Dis_rm8

    End_If


Op96:
    If B$EscapePrefix = &FALSE    ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        mov D$edi 'xchg', B$edi+4 ' ' | add edi 5 | jmp Dis_eax_ax__rd_rw

    Else         ; 0F 96 SETBE r/m8    ; 0F 96 SETNA r/m8
       ; inc D$UnLikelyCode
        mov D$edi 'setb', W$edi+4 'e ' | add edi 6 | jmp Dis_rm8

    End_If


Op97:
    If B$EscapePrefix = &FALSE    ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
        inc D$LikelyCode
        mov D$edi 'xchg', B$edi+4 ' ' | add edi 5 | jmp Dis_eax_ax__rd_rw

    Else         ; 0F 97 SETA r/m8 ; 0F 97 SETNBE r/m8
       ; inc D$UnLikelyCode
        mov D$edi 'seta', B$edi+4 ' ' | add edi 5 | jmp Dis_rm8

    End_If


Op98:
    .If B$EscapePrefix = &TRUE   ; 0F 98 SETS r/m8
        mov D$edi 'sets', B$edi+4 ' ' | add edi 5 | jmp Dis_rm8

    .Else ; cbw / cwde
        If B$OperandSizeOverride = &TRUE
            mov D$edi 'cbw ' | add edi 3
        Else
            mov D$edi 'cwde' | add edi 4
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op99:
    .If B$EscapePrefix = &TRUE   ; 0F 99 SETNS r/m8
        mov D$edi 'setn', W$edi+4 's ' | add edi 6 | jmp Dis_rm8

    .Else    ; CWD / CDQ
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'cdq ' | add edi 3
        Else
            mov D$edi 'cwd ' | add edi 3
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op9A:

    ..If B$EscapePrefix = &TRUE      ; 0F 9A SETP r/m8 ; 0F 9A SETPE r/m8
        mov D$edi 'setp', B$edi+4 ' ' | add edi 5 | jmp Dis_rm8

    ..Else
        add D$UnLikelyCode 0FF
        If B$OperandSizeOverride = &TRUE        ; call far ptr16:selector16 ; callF16
            mov D$edi 'call', D$edi+4 'F16 ' | add edi 8
            push D$esi, esi
                Exchange W$esi, W$esi+2
                call WriteImm16 | mov B$edi ' ' | inc edi | call WriteImm16
            pop eax, D$eax
        Else                                ;   call far ptr32:selector16
            mov D$edi 'call', D$edi+4 'F32 ' | add edi 8
            push D$esi, D$esi+4, esi
                mov eax D$esi, bx W$esi+4, W$esi bx, D$esi+2 eax
                call WriteImm16 | mov B$edi ' ' | inc edi | call WriteImm32
            pop eax D$eax+4, D$eax
        End_If

        mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8
    ..End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op9B:
    ..If B$EscapePrefix = &TRUE     ; 0F 9B SETNP r/m8 ; 0F 9B SETPO r/m8
        ;inc D$UnLikelyCode
        mov D$edi 'setn', W$edi+4 'p ' | add edi 6 | jmp Dis_rm8

    ..Else
        .If W$esi = 0E2DB           ; 9B DB E2 > FCLEX
            mov D$edi 'fcle', W$edi+4 'x ' | add edi 5 | add esi 2

        .Else_If W$esi = 0E3DB      ; 9B DB E3 >FINIT
            mov D$edi 'fini', W$edi+4 't ' | add edi 5 | add esi 2

        .Else_If W$esi = 0E0DF      ; 9B DF E0 FSTSW AX
            mov D$edi 'fsts', D$edi+4 'w ax' | add edi 8 | add esi 2

        .Else_If B$esi = 0DD
            mov bl B$esi+1 | DigitMask bl to al

            If al = 6               ; 9B DD /6 > FSAVE m94/108byte
                mov D$edi 'fsav', W$edi+4 'e ' | add edi 6 | inc esi | lodsb
                jmp EndWith.X.mem
            Else_If al = 7          ; 9B DD /7 FSTSW m2byte
                mov D$edi 'fsts', W$edi+4 'w ' | add edi 6 | inc esi | lodsb
                jmp EndWith.W.mem
            Else
                jmp L5>
            End_If

        .Else_If B$esi = 0D9 ; opD9
            mov bl B$esi+1 | DigitMask bl to al

            If al = 6               ; 9B D9 /6 FSTENV m14/28byte
                mov D$edi 'fste', D$edi+4 'nv  ' | add edi 7 | inc esi | lodsb
                jmp EndWith.X.mem
            Else_If al = 7          ; 9B DD /6 > FSTCW m2byte
                mov D$edi 'fstc', W$edi+4 'w ' | add edi 6 | inc esi | lodsb
                jmp EndWith.W.mem
            Else
                jmp L5>
            End_If

        .Else                       ; 9B WAIT
L5:         mov D$edi 'wait' | add edi 4
        .End_If

    ..End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op9C: ; setl

    .If B$EscapePrefix = &TRUE   ; 0F 9C SETL r/m8 ; 0F 9C SETNGE r/m8
        mov D$edi 'setl', B$edi+4 ' ' | add edi 5 | jmp Dis_rm8

    .Else       ; 9C PUSHF 9C PUSHFD
        ;inc D$UnLikelyCode
        mov D$edi 'push', B$edi+4 'f' | add edi 5
        If B$OperandSizeOverride = &TRUE
            mov B$edi 'd' | inc edi
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op9D:

    .If B$EscapePrefix = &TRUE   ; 0F 9D SETGE r/m8 ; 0F 9D SETNL r/m8
        mov D$edi 'setg', W$edi+4 'e ' | add edi 6 | jmp Dis_rm8

    .Else    ; 9D POPF  ; 9D POPFD
        ;inc D$UnLikelyCode
        mov D$edi 'popf' | add edi 4
        If B$OperandSizeOverride = &TRUE
            mov B$edi 'd' | inc edi
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op9E:
    .If B$EscapePrefix = &TRUE   ; 0F 9E SETLE r/m8 ; 0F 9E SETNG r/m8
        mov D$edi 'setl', W$edi+4 'e ' | add edi 6 | jmp Dis_rm8

    .Else       ; 9E SAHF
        ;inc D$UnLikelyCode
        mov D$edi 'sahf' | add edi 4

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Op9F:

    If B$EscapePrefix = &TRUE   ; 0F 9F SETG r/m8 ; 0F 9F SETNLE r/m8
        mov D$edi 'setg', B$edi+4 ' ' | add edi 5 | jmp Dis_rm8

    Else    ; LAHF
        ;inc D$UnLikelyCode
        mov D$edi 'lahf' | add edi 4

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA0:
    If B$EscapePrefix = &TRUE   ; 0F A0 PUSH FS
        inc D$UnLikelyCode
        mov D$edi 'push', D$edi+4 ' fs ' | add edi 7

    Else ; MOV AL,moffs8*
        mov D$edi 'mov ', D$edi+4 'al B', B$edi+8 '$' | add edi 9 | call WriteImm32

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret



OpA1:
    .If B$EscapePrefix = &TRUE ; 0F A1 POP FS
        inc D$UnLikelyCode
        mov D$edi 'pop ', W$edi+4 'fs' | add edi 6

    .Else        ; MOV EAX,moffs32* ; MOV AX,moffs16*
        mov D$edi 'mov ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'eax ', W$edi+4 'D$' | add edi 6
        Else
            mov D$edi 'ax W', B$edi+4 '$' | add edi 5
        End_If
        If D$SegmentOverride <> 0
            move D$edi D$SegmentOverride | add edi 3
        End_If
        call WriteDis32 ; WriteImm32

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA2:
    If B$EscapePrefix = &TRUE ; CPUID
        mov D$edi 'cpui', B$edi+4 'd' | add edi 5

    Else        ; MOV moffs8*,AL
        mov D$edi 'mov ', D$edi+4 'B$  ' | add edi 6
        call WriteImm32 | mov D$edi ' al ' | add edi 3

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA3:
    .If B$EscapePrefix = &TRUE
        mov D$edi 'bt  ' | add edi 3 | jmp Dis_rm32_rm16__r32_r16

    .Else        ; MOV moffs32*,EAX ; MOV moffs16*,AX
        mov D$edi 'mov '
        If B$OperandSizeOverride = &FALSE
            mov D$edi+4 'D$  '
        Else
            mov D$edi+4 'W$  '
        End_If
        add edi 6
        If D$SegmentOverride <> 0
            move D$edi D$SegmentOverride | add edi 3
        End_If

        call WriteDis32

        If B$OperandSizeOverride = &FALSE
            mov D$edi ' eax' | add edi 4
        Else
            mov D$edi ' ax ' | add edi 3
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA4:
    inc  D$LikelyCode
    If B$EscapePrefix = &TRUE   ; 0F A4 SHLD r/m16, r16, imm8 ; 0F A4 SHLD r/m32, r32, imm8
        mov D$edi 'shld', B$edi+4 ' ' | add edi 5 | jmp Dis_rm32_rm16__r32_r16__imm8

    Else ; MOVSB
        mov D$edi 'movs', B$edi+4 'b' | add edi 5

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA5:
    inc D$LikelyCode
    .If B$EscapePrefix = &TRUE   ; 0F A5 SHLD r/m16, r16, CL ; 0F A5 SHLD r/m32, r32, CL
        mov D$edi 'shld', B$edi+4 ' ' | add edi 5 | jmp Dis_rm32_rm16__r32_r16__cl

    .Else
        If B$OperandSizeOverride = &FALSE  ; MOVSD
            mov D$edi 'movs', B$edi+4 'd'
        Else  ; MOVSW
            mov D$edi 'movs', B$edi+4 'w'
        End_If
        add edi 5

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA6: ; cmpsb
    inc D$LikelyCode
    mov D$edi 'cmps', B$edi+4 'b' | add edi 5
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA7: ; cmpsw / d
    inc D$LikelyCode
    mov D$edi 'cmps' | add edi 4
    If B$OperandSizeOverride = &TRUE
        mov B$edi 'w'
    Else
        mov B$edi 'd'
    End_If
    inc edi
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA8:
    If B$EscapePrefix = &TRUE   ; 0F A8 PUSH GS
        inc D$UnLikelyCode
        mov D$edi 'push', D$edi+4 ' gs ' | add edi 7

    Else    ; A8 ib TEST AL,imm8
        inc D$LikelyCode
        mov D$edi 'test', B$edi+4 ' ' | add edi 5 | jmp Dis_al_imm8

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpA9: ; 0F A9 POP GS
    If B$EscapePrefix = &TRUE
        inc D$UnLikelyCode
        mov D$edi 'pop ', W$edi+4 'gs' | add edi 6

    Else   ; A9 iw TEST AX,imm16 ; A9 id TEST EAX,imm32
        inc D$LikelyCode
        mov D$edi 'test', B$edi+4 ' ' | add edi 5 | jmp Dis_eax_ax__imm32_imm16

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpAA:
    If B$EscapePrefix = &TRUE    ; 0F AA RSM
        inc D$UnLikelyCode
        mov D$edi 'rsm ' | add edi 3

    Else       ; AA STOSB
        inc D$LikelyCode
        mov D$edi 'stos', B$edi+4 'b' | add edi 5

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpAB:
    If B$EscapePrefix = &TRUE
        mov B$LockPrefix &FALSE
        mov D$edi 'bts ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16

    Else        ; AB STOSW ; AB STOSD
        inc D$LikelyCode
        mov D$edi 'stos', B$edi+4 'd' | add edi 5
        On B$OperandSizeOverride = &TRUE, mov B$edi-1 'w'

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpAC:
    If B$EscapePrefix = &TRUE   ; 0F AC SHRD r/m16, r16, imm8 ; 0F AC SHRD r/m32, r32, mm8
        mov D$edi 'shrd', B$edi+4 ' ' | add edi 5 | jmp Dis_rm32_rm16__r32_r16__imm8

    Else ; LODSB
        inc D$LikelyCode
        mov D$edi 'lods', B$edi+4 'b' | add edi 5

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpAD:
    .If B$EscapePrefix = &TRUE   ; 0F AD SHRD r/m16, r16, CL ; 0F AD SHRD r/m32, r32, CL
        mov D$edi 'shrd', B$edi+4 ' ' | add edi 5 | jmp Dis_rm32_rm16__r32_r16__cl

    .Else    ; LODSD ; LODSW
        inc D$LikelyCode
        mov D$edi 'lods', B$edi+4 'd'
        On B$OperandSizeOverride = &TRUE, mov B$edi+4 'w'
        add edi 5

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpAE:
    ..If B$EscapePrefix = &TRUE
        movzx ebx B$esi | inc esi | DigitMask bl to al

        .If al = 0          ; FXSAVE m512byte
            mov D$edi 'fxsa', D$edi+4 've  ' | add edi 7 | jmp EndWith.X.mem
        .Else_If al = 1     ; FXRSTOR m512byte
            mov D$edi 'fxrs', D$edi+4 'tor ' | add edi 8 | jmp EndWith.X.mem
        .Else_If al = 2     ; LDMXCSR m32
            mov D$edi 'ldmx', D$edi+4 'csr ' | add edi 8 | jmp EndWith.D.mem
        .Else_If al = 3     ; 0F AE /3 STMXCSR m32
            mov D$edi 'stmx', D$edi+4 'csr ' | add edi 8 | jmp EndWith.D.mem
        .Else_If al = 5     ; LFENCE
            mov D$edi 'lfen', W$edi+4 'ce' | add edi 6
        .Else_If al = 6     ; MFENCE
            mov D$edi 'mfen', W$edi+4 'ce' | add edi 6
        .Else_If al = 7     ; 0F AE /7 CLFLUSH   ; 0F AE /7 SFENCE
            ModMask bl to al
            If al = 3
                mov D$edi 'sfen', D$edi+4 'ce  '  | add edi 6
            Else
                mov D$edi 'clfl', D$edi+4 'ush ' | add edi 8 | jmp Dis_m8
            End_If
        .Else
            dec esi | ret
        .End_If

    ..Else  ; AE SCASB
        mov D$edi 'scas', B$edi+4 'b' | add edi 5
    ..End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpAF:  ; 0F AF /r > IMUL r16,r/m16 ou 32
    inc D$LikelyCode
    If B$EscapePrefix = &TRUE
        mov D$edi 'imul', B$edi+4 ' ' | add edi 5 | jmp Dis_r32_r16__rm32_rm16

    Else        ; AF SCASD AF SCASW
         mov D$edi 'scas', B$edi+4 'd' | add edi 5
         On B$OperandSizeOverride = &TRUE, mov B$edi-1 'w'

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB0:
    If B$EscapePrefix = &FALSE  ; MOV r8,imm8
        inc D$LikelyCode
        mov D$edi 'mov ', D$edi+4 'al  ' | add edi 7 | call WriteImm8

    Else     ; CMPXCHG r/m8,r8
        ;inc D$UnLikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'cmpx', D$edi+4 'chg ' | add edi 8 | jmp Dis_rm8_r8

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB1: ; CMPXCHG r/m32,r32 (+16)
    If B$EscapePrefix = &FALSE
        mov D$edi 'mov ', D$edi+4 'cl  ' | add edi 7 | call WriteImm8

    Else
        mov B$LockPrefix &FALSE
        mov D$edi 'cmpx', D$edi+4 'chg ' | add edi 8 | jmp Dis_rm32_rm16__r32_r16

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB2: ; 0F B2 > LSS r16,m16:16 ; LSS r32,m16:32
    If B$EscapePrefix = &FALSE
        mov D$edi 'mov ', D$edi+4 'dl  ' | add edi 7 | call WriteImm8

    Else
        inc D$UnLikelyCode
        mov D$edi 'lss ' | add edi 4 | call Dis_r32_r16__rm32_rm16 ; LSL
        mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB3:
    If B$EscapePrefix = &FALSE
        mov D$edi 'mov ', D$edi+4 'bl  ' | add edi 7 | call WriteImm8

    Else
        ;inc D$UnLikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'btr ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16 ; BTR

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB4:
    If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        mov D$edi 'mov ', D$edi+4 'ah  ' | add edi 7 | call WriteImm8

    Else     ; 0F B4 > LFS r16,m16:16 ; LFS r32,m16:32
        inc D$UnLikelyCode
        mov D$edi 'lfs ' | add edi 4 | call Dis_r32_r16__rm32_rm16
        mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB5:
    If B$EscapePrefix = &FALSE
        mov D$edi 'mov ', D$edi+4 'ch  ' | add edi 7 | call WriteImm8

    Else     ; LGS r16,m16:16 ; LGS r32,m16:32
        inc D$UnLikelyCode
        mov D$edi 'lgs ' | add edi 4 | call Dis_r32_r16__rm32_rm16
        mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB6:
    If B$EscapePrefix = &FALSE
        mov D$edi 'mov ', D$edi+4 'dh  ' | add edi 7 | call WriteImm8

    Else        ; 0F B6 /r MOVZX r16,r/m8 ; 0F B6 /r MOVZX r32,r/m8
        inc D$LikelyCode
        mov D$edi 'movz', W$edi+4 'x ' | add edi 6 | jmp Dis_r32_r16__rm8

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB7:
    If B$EscapePrefix = &FALSE
        mov D$edi 'mov ', D$edi+4 'bh  ' | add edi 7 | call WriteImm8

    Else        ; 0F B7 /r MOVZX r32,r/m16
        inc D$LikelyCode
        mov D$edi 'movz', W$edi+4 'x ' | add edi 6 | jmp Dis_r32_rm16

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB8:
    inc D$LikelyCode
    If B$OperandSizeOverride = &FALSE
        mov D$edi 'mov ', D$edi+4 'eax ' | add edi 8 | call WriteImm32
    Else
        mov D$edi 'mov ', D$edi+4 'ax  ' | add edi 7 | call WriteImm16
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpB9:
    inc D$LikelyCode
    If B$OperandSizeOverride = &FALSE
        mov D$edi 'mov ', D$edi+4 'ecx ' | add edi 8 | call WriteImm32

    Else
        mov D$edi 'mov ', D$edi+4 'cx  ' | add edi 7 | call WriteImm16

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpBA:
    .If B$EscapePrefix = &TRUE
        movzx ebx B$esi | inc esi | DigitMask bl to al

        If al = 4
            mov D$edi 'bt  ' | add edi 3 ; bts, ...
        Else_If al = 5
            mov B$LockPrefix &FALSE
            mov D$edi 'bts ' | add edi 4
        Else_If al = 6
            mov B$LockPrefix &FALSE
            mov D$edi 'btr ' | add edi 4
        Else_If al = 7
            mov B$LockPrefix &FALSE
            mov D$edi 'btc ' | add edi 4
        Else
            dec esi | ret
        End_If
        jmp Dis_rm32_rm16__imm8

    .Else
        inc D$LikelyCode
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'mov ', D$edi+4 'edx ' | add edi 8 | call WriteImm32
        Else
            mov D$edi 'mov ', D$edi+4 'dx  ' | add edi 7 | call WriteImm16
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpBB:
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'btc ' | add edi 4 | jmp Dis_rm32_rm16__r32_r16 ; BTC

    .Else
        inc D$LikelyCode
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'mov ', D$edi+4 'ebx ' | add edi 8 | call WriteImm32
        Else
            mov D$edi 'mov ', D$edi+4 'bx  ' | add edi 7 | call WriteImm16
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpBC:
    .If B$EscapePrefix = &TRUE
        mov D$edi 'bsf ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16 ; bsf

    .Else
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'mov ', D$edi+4 'esp ' | add edi 8 | call WriteImm32
        Else
            inc D$UnLikelyCode
            mov D$edi 'mov ', D$edi+4 'sp  ' | add edi 7 | call WriteImm16
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpBD:
    .If B$EscapePrefix = &TRUE
        mov D$edi 'bsr ' | add edi 4 | jmp Dis_r32_r16__rm32_rm16 ; bsr

    .Else
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'mov ', D$edi+4 'ebp ' | add edi 8 | call WriteImm32
        Else
            inc D$UnLikelyCode
            mov D$edi 'mov ', D$edi+4 'bp  ' | add edi 7 | call WriteImm16
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpBE:
    inc D$LikelyCode
    .If B$EscapePrefix = &FALSE
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'mov ', D$edi+4 'esi ' | add edi 8 | call WriteImm32
        Else
            mov D$edi 'mov ', D$edi+4 'si  ' | add edi 7 | call WriteImm16
        End_If

    .Else
      ; 0F BE ¯r MOVSX r32,r/m8  ; 0F BE /r MOVSX r16,r/m8
        mov D$edi 'movs', W$edi+4 'x ' | add edi 6 | jmp Dis_r32_r16__rm8

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpBF:
    inc D$LikelyCode
    .If B$EscapePrefix = &FALSE
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'mov ', D$edi+4 'edi ' | add edi 8
            call WriteImm32
        Else
            mov D$edi 'mov ', D$edi+4 'di  ' | add edi 7
            call WriteImm16
        End_If

    .Else       ; 0F BF /r MOVSX r32,r/m16
        mov D$edi 'movs', W$edi+4 'x ' | add edi 6 | jmp Dis_r32_rm16

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpC0:
    .If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        mov bl B$esi | inc esi | DigitMask bl to al

        If al = 0   ; C0 /0 ib ROL r/m8, imm8
            mov D$edi 'rol '
        Else_If al = 1  ; C0 /1 ib ROR r/m8, imm8
            mov D$edi 'ror '
        Else_If al = 2  ; C0 /2 ib RCL r/m8, imm8
            mov D$edi 'rcl '
        Else_If al = 3  ; C0 /3 ib RCR r/m8, imm8
            mov D$edi 'rcr '
        Else_If al = 4   ; C0 /4 ib SAL r/m8,imm8   ; C0 /4 ib SHL r/m8,imm8
            mov D$edi 'shl '
        Else_If al = 5  ; C0 /5 ib SHR r/m8,imm8
           mov D$edi 'shr '
        Else_If al = 7  ; C0 /7 ib SAR r/m8,imm8
            mov D$edi 'sar '
        Else
            dec esi | ret
        End_If

        add edi 4 | jmp Dis_rm8_imm8

    .Else   ; 0F C0 /r XADD r/m8, r8
        mov B$LockPrefix &FALSE
        mov D$edi 'xadd', B$edi+4 ' ' | add edi 5 | jmp Dis_rm8_r8

    .End_If


OpC1:
    .If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        movzx ebx B$esi | inc esi | DigitMask bl to al

        If al = 0   ; C1 /0 ib ROL r/m16, imm8  C1 /0 ib ROL r/m32, imm8
            mov D$edi 'rol '
        Else_If al = 1    ; C1 /1 ib ROR r/m16, imm8    ; C1 /1 ib ROR r/m32, imm8
            mov D$edi 'ror '
        Else_If al = 2    ; C1 /2 ib RCL r/m16, imm8 ; C1 /2 ib RCL r/m32,i mm8
            mov D$edi 'rcl '
        Else_If al = 3  ; C1 /3 ib RCR r/m16, imm8  C1 /3 ib RCR r/m32, imm8
            mov D$edi 'rcr '
        Else_If al = 4  ; C1 /4 ib SAL r/m16,imm8   ; C1 /4 ib SAL r/m32,imm8 ; C1 /4 ib SHL r/m32,imm8  ; C1 /4 ib SHL r/m16,imm8
            mov D$edi 'shl '
        Else_If al = 5  ; C1 /5 ib SHR r/m16,imm8   ; C1 /5 ib SHR r/m32,imm8
            mov D$edi 'shr '
        Else_If al = 7  ; C1 /7 ib SAR r/m16,imm8   ; C1 /7 ib SAR r/m32,imm8
            mov D$edi 'sar '
        Else
            dec esi | ret
        End_If

        add edi 4 | jmp Dis_rm32_rm16__imm8

    .Else   ; 0F C1 /r XADD r/m16, r16 ; 0F C1 /r XADD r/m32, r32
        mov B$LockPrefix &FALSE
        mov D$edi 'xadd', B$edi+4 ' ' | add edi 5 | jmp Dis_rm32_rm16__r32_r16

    .End_If


OpC2:
    .If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        mov D$edi 'cmp_'
        If B$OperandSizeOverride = &TRUE
          ; 66 0F C2 /r ib CMPPD xmm1, xmm2/m128, imm8
          ; 66 0F C2 _1D_ 010 34 42 00 01
            call MarkSSEdata SSE_2_R    ; CMPPD 66 0F C2 /r ib
            mov D$edi+4 'pd  '
        Else
          ; cmpps xmm1, xmm2/m128, imm8
            call MarkSSEdata SSE_4_F    ; CMPPS 0F C2 /r ib
            mov D$edi+4 'ps  '
        End_If

        add edi 7
        call Dis_xmm1__xmm2_m128 | jmp WritePacketCondition

    .Else       ; C2 iw RET imm16
        inc D$LikelyCode
        mov D$edi 'ret ' | add edi 4 | call WriteImm16
        mov al CR | stosb | mov al LF | stosb
        mov B$DisEndOfChunk &TRUE

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpC3:
    If B$EscapePrefix = &FALSE  ; C3 RET
        inc D$LikelyCode
        mov D$edi 'ret ' | add edi 3
        mov al CR | stosb | mov al LF | stosb
        mov B$DisEndOfChunk &TRUE

    Else        ; 0F C3 /r MOVNTI m32, r32
        ;inc D$UnLikelyCode
        mov D$edi 'movn', D$edi+4 'ti  ' | add edi 7 | jmp Dis_m32_r32

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpC4:
    .If B$EscapePrefix = &TRUE
      ; 66 0F C4 /r ib PINSRW xmm, r32/m16, imm8 ; 0F C4 /r ib PINSRW mm, r32/m16, imm8
        mov D$edi 'pins', D$edi+4 'rw  ' | add edi 7
        jmp Dis_PINSRW

    .Else        ; LES r16,m16:16 ; LES r32,m16:32
        mov D$edi 'les ' | add edi 4 | call Dis_r32_r16__rm32_rm16
        mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8
        inc D$UnLikelyCode

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpC5:
    .If B$EscapePrefix = &TRUE
      ; 66 0F C5 /r ib PEXTRW r32, xmm, imm8 ; 0F C5 /r ib PEXTRW r32, mm, imm8
        mov D$edi 'pext', D$edi+4 'rw  ' | add edi 7
        jmp Dis_r32_xmmx_imm8
       ; call Dis_r32_xmmx | mov B$edi ' ' | inc edi | call Writeimm8
;Dis_xmmx_r32
    .Else        ; LDS r16,m16:16
        inc D$UnLikelyCode
        mov D$edi 'lds ' | add edi 4 | call Dis_r32_r16__rm32_rm16
        mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpC6:
    ..If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
      ; 66 0F C6 /r ib SHUFPD xmm1, xmm2/m128, imm8 ; 0F C6 /r ib SHUFPS xmm1, xmm2/m128, imm8
        mov D$edi 'shuf'
        If B$OperandSizeOverride = &TRUE
            call MarkSSEdata SSE_2_R
            mov D$edi+4 'pd  '
        Else
            call MarkSSEdata SSE_4_F
            mov D$edi+4 'ps  '
        End_If
        add edi 7 | jmp Dis_xmm1__xmm2_m128__imm8

    ..Else
        mov bl B$esi | inc esi | DigitMask bl To al

        If al = 0     ; MOV r/m8,imm8
            inc D$LikelyCode
            mov D$edi 'mov ' | add edi 4 | jmp Dis_rm8_imm8
        Else
            dec esi | ret
        End_If

    ..End_If


OpC7:
    movzx ebx B$esi | inc esi | DigitMask bl to al

    .If B$EscapePrefix = &FALSE
        inc D$LikelyCode
        If al = 0       ; MOV r/m32,imm32 ; MOV r/m16,imm16
            mov B$MovOrJmpImmInstruction &TRUE
            mov D$edi 'mov ' | add edi 4 | jmp Dis_rm32_rm16__imm32_imm16
        End_If

    .Else    ; 0F C7 /1 m64 CMPXCHG8B m64
        If al = 1
            ;inc D$UnLikelyCode
            mov B$LockPrefix &FALSE
            mov D$edi 'cmpx', D$edi+4 'chg8', W$edi+8 'b ' | add edi 10 | jmp Dis_m64
        End_If

    .End_If

    dec esi
ret


OpC8:
    .If B$EscapePrefix = &FALSE ; ENTER imm16,imm8
        mov D$edi 'ente', W$edi+4 'r ' | add edi 6
      ; Enter Max is 0FFFC and must be 4 Bytes Aligned:
        If W$esi > 0FFFC
            add D$UnlikelyCode 5
        Else
            test W$esi 00_11 | jz L1>
                add D$UnlikelyCode 5
        End_If

L1:     On B$esi+2 > 31, add D$UnlikelyCode 5
        call WriteImm16 | mov B$edi ' ' | inc edi
        call WriteImm8

    .Else
        mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'eax ' | add edi 9

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpC9:
    If B$EscapePrefix = &FALSE
        mov D$edi 'leav', B$edi+4 'e' | add edi 5

    Else
        mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'ecx ' | add edi 9

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpCA:
    If B$EscapePrefix = &FALSE        ; CA iw RET imm16
        inc D$UnLikelyCode
        mov D$edi 'retf', B$edi+4 ' ' | add edi 5 | call WriteImm16
        mov B$DisEndOfChunk &TRUE

    Else
        mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'edx ' | add edi 9

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpCB:
    If B$EscapePrefix = &FALSE        ; CB RET
        inc D$UnLikelyCode
        mov D$edi 'retF' | add edi 4
        mov B$DisEndOfChunk &TRUE

    Else
        mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'ebx ' | add edi 9

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpCC:
    .If B$EscapePrefix = &TRUE
        inc D$UnLikelyCode
        mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'esp ' | add edi 9

    .Else        ; INT 3
        mov D$edi 'int ', B$edi+4 '3' | add edi 5
        If B$No0CC = &FALSE
            mov B$DisEndOfChunk &TRUE
        Else
            inc D$UnLikelyCode
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpCD:
    If B$EscapePrefix = &TRUE
        mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'ebp ' | add edi 9

    Else        ; INT imm8
        inc D$UnLikelyCode
        mov D$edi 'int ' | add edi 4 | call WriteImm8

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpCE:
    If B$EscapePrefix = &TRUE
        mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'esi ' | add edi 9

    Else        ; INTO
        inc D$UnLikelyCode
        mov D$edi 'into' | add edi 4

    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpCF:
    .If B$EscapePrefix = &TRUE
        mov D$edi 'bswa', W$edi+4 'p ', D$edi+6 'edi ' | add edi 9

    .Else       ; IRET IRETD
        inc D$UnLikelyCode
        mov D$edi 'iret' | add edi 4
        If B$OperandSizeOverride = &FALSE
            mov B$edi 'd' | inc edi
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpD0:
    inc D$LikelyCode
    mov bl B$esi | inc esi | DigitMask bl To al

    If al = 0       ; D0 /0 ROL r/m8, 1
        mov D$edi 'rol '
    Else_If al = 1  ; D0 /1 ROR r/m8, 1
        mov D$edi 'ror '
    Else_If al = 2  ; D0 /2 RCL r/m8, 1
        mov D$edi 'rcl '
    Else_If al = 3  ; D0 /3 RCR r/m8, 1
        mov D$edi 'rcr '
    Else_If al = 4  ; D0 /4 SAL r/m8,1  ; D0 /4 SHL r/m8,1
        mov D$edi 'shl '
    Else_If al = 5  ; D0 /5 SHR r/m8,1
        mov D$edi 'shr '
    Else_If al = 7  ; D0 /7 SAR r/m8,1
        mov D$edi 'sar '
    Else
        dec esi | ret
    End_If

    add edi 4 | jmp Dis_rm8_1



OpD1:
    .If B$EscapePrefix = &TRUE ; Op0F
        ;inc D$UnLikelyCode
      ; 0F D1 /r PSRLW mm, mm/m64       ; 66 0F D1 /r PSRLW xmm1, xmm2/m128
        If B$esi-3 <> 0F
            mov D$edi 'psrl', W$edi+4 'w ' | add edi 6
            jmp Dis_xmmx1__xmmx2_m64_128
        End_If

    .Else
        inc D$LikelyCode
        mov bl B$esi | inc esi | DigitMask bl To al

        If al = 0   ; D1 /0 ROL r/m16, 1    D1 /0 ROL r/m32, 1
            mov D$edi 'rol '
        Else_If al = 1   ; D1 /1 ROR r/m16, 1   ; D1 /1 ROR r/m32, 1
            mov D$edi 'ror '
        Else_If al = 2   ; D1 /2 RCL r/m16, 1 D1 /2 RCL r/m32, 1
            mov D$edi 'rcl '
        Else_If al = 3  ; D1 /3 RCR r/m16, 1    ; D1 /3 RCR r/m32, 1
            mov D$edi 'rcr '
        Else_If al = 4  ; D1 /4 SAL r/m16,1 ; D1 /4 SAL r/m32,1 ; D1 /4 SHL r/m16,1; D1 /4 SHL r/m32,1
            mov D$edi 'shl '
        Else_If al = 5  ; D1 /5 SHR r/m16,1 ; D1 /5 SHR r/m32,1
            mov D$edi 'shr '
        Else_If al = 7  ; D1 /7 SAR r/m16,1 ; D1 /7 SAR r/m32,1
            mov D$edi 'sar '
        Else
            dec esi | ret
        End_If

        add edi 4 | jmp Dis_rm32_rm16__1

    .End_If


OpD2:
    .If B$EscapePrefix = &TRUE
      ; 0F D2 /r PSRLD mm, mm/m64   ; 66 0F D2 /r PSRLD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'psrl', W$edi+4 'd ' | add edi 6
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
        inc D$LikelyCode
        mov bl B$esi | inc esi | DigitMask bl to al

        If al = 0       ; D2 /0 ROL r/m8, CL
            mov D$edi 'rol '
        Else_If al = 1      ;     D2 /1 ROR r/m8, CL
             mov D$edi 'ror '
        Else_If al = 2      ; D2 /2 RCL r/m8, CL
            mov D$edi 'rcl '
        Else_If al = 3 ; D2 /3 RCR r/m8, CL
            mov D$edi 'rcr '
        Else_If al = 4   ; D2 /4 SAL r/m8,CL    ; D2 /4 SHL r/m8,CL
            mov D$edi 'shl '
        Else_If al = 5  ; D2 /5 SHR r/m8,CL
            mov D$edi 'shr '
        Else_If al = 7  ; D2 /7 SAR r/m8,CL
            mov D$edi 'sar '
        Else
            dec esi | ret
        End_If

        add edi 4 | jmp Dis_rm8_cl

    .End_If


OpD3:
    .If B$EscapePrefix = &TRUE
      ; 0F D3 /r PSRLQ mm, mm/m64   ; 66 0F D3 /r PSRLQ xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'psrl', W$edi+4 'q ' | add edi 6
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
        inc D$LikelyCode
        mov bl B$esi | inc esi | DigitMask bl to al

        If al = 0   ; D3 /0 ROL r/m16, CL   D3 /0 ROL r/m32, CL
            mov D$edi 'rol '
        Else_If al = 1      ; D3 /1 ROR r/m16, CL    ; D3 /1 ROR r/m32, CL
            mov D$edi 'ror '
        Else_If al = 2      ; D3 /2 RCL r/m16, CL    D3 /2 RCL r/m32, CL
            mov D$edi 'rcl '
        Else_If al = 3  ; D3 /3 RCR r/m16, CL   D3 /3 RCR r/m32, CL
            mov D$edi 'rcr '
        Else_If al = 4  ; D3 /4 SAL r/m16,CL    ; D3 /4 SAL r/m32,CL  ;D3 /4 SHL r/m32,CL  ; D3 /4 SHL r/m16,CL
            mov D$edi 'shl '
        Else_If al = 5  ; D3 /5 SHR r/m16,CL    ; D3 /5 SHR r/m32,CL
            mov D$edi 'shr '
        Else_If al = 7  ; D3 /7 SAR r/m16,CL    ; D3 /7 SAR r/m32,CL
            mov D$edi 'sar '
        Else
            dec esi | ret
        End_If

        add edi 4 | jmp Dis_rm32_rm16__cl

    .End_If


OpD4:
    .If B$EscapePrefix = &TRUE
        ; 66 0F D4 /r PADDQ xmm1,xmm2/m128       ; 0F D4 /r PADDQ mm1,mm2/m64
        ;inc D$UnLikelyCode
        mov D$edi 'padd', W$edi+4 'q ' | add edi 6
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
        mov D$edi 'aam ', B$DisFlag DISDONE+DISLINEOVER | add edi 4
        lodsb
        If al <> 0A
            call LoadedOpToHexa | stosw
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpD5:
    .If B$EscapePrefix = &TRUE
      ; 0F D5 /r PMULLW mm, mm/m64      ; 66 0F D5 /r PMULLW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'pmul', D$edi+4 'lw  ' | add edi 7
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
        mov D$edi 'aad ', B$DisFlag DISDONE+DISLINEOVER | add edi 4
        lodsb
        If al <> 0A
            call loadedOpToHexa | stosw
        End_If

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER

ret


OpD6:
    .If B$EscapePrefix = &TRUE
        If B$OperandSizeOverride = &TRUE    ; 66 0F D6 MOVQ xmm2/m64, xmm1
            mov D$edi 'movq', B$edi+4 ' ' | add edi 5 | jmp Dis_xmm2_m64__xmm1
        End_If
    .Else
        mov D$edi 'salc'  | add edi 4
        mov B$DisFlag DISDONE+DISLINEOVER
    .End_If
ret


OpD7:
    ;inc D$UnLikelyCode
    .If B$EscapePrefix = &TRUE
      ; 66 0F D7 /r PMOVMSKB r32, xmm ; 0F D7 /r PMOVMSKB r32, mm
        mov D$edi 'pmov', D$edi+4 'mskb', B$edi+8 ' ' | add edi 9 | jmp Dis_r32_xmmx

    .Else       ; D7 XLATB
        mov D$edi 'xlat', B$edi+4 'b' | add edi 5

    .End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpD8:
    ..If B$EscapePrefix = &TRUE
      ; 0F D8 /r PSUBUSB mm, mm/m64 ; 66 0F D8 /r PSUBUSB xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'psub', D$edi+4 'usb ' | add edi 8
        jmp Dis_xmmx1__xmmx2_m64_128

    ..Else
        mov bl B$esi | inc esi | DigitMask bl To al

        .If al = 0          ; D8 /0 FADD m32fp ; D8 C0+i FADD ST(0), ST(i)
            mov D$edi 'fadd', B$edi+4 ' ' | add edi 5
        .Else_If al = 1     ; D8 /1 FMUL m32fp ; D8 C8+i FMUL ST(0), ST(i)
            mov D$edi 'fmul', B$edi+4 ' ' | add edi 5
        .Else_If al = 2  ; FCOM m32fp ; FCOM ST(i)
            mov D$edi 'fcom', B$edi+4 ' ' | add edi 5
        .Else_If al = 3     ; FCOMP m32fp; FCOMP ST(i)
           mov D$edi 'fcom', W$edi+4 'p ' | add edi 6
        .Else_If al = 4     ; FSUB m32fp ; FSUB ST(0), ST(i)
            mov D$edi 'fsub', B$edi+4 ' ' | add edi 5
        .Else_If al = 5     ; FSUBR m32fp ; FSUBR ST(0), ST(i)
            mov D$edi 'fsub', W$edi+4 'r ' | add edi 6
        .Else_If al = 6     ; FDIV m32fp ; FDIV ST(0), ST(i)
            mov D$edi 'fdiv', B$edi+4 ' ' | add edi 5
        .Else_If al = 7     ; FDIVR m32fp ; FDIVR ST(0), ST(i)
            mov D$edi 'fdiv', W$edi+4 'r ' | add edi 6
        .End_If

        jmp Dis_St0Sti_or_Fmem

    ..End_If
ret


OpD9:
    If B$EscapePrefix = &TRUE
      ; 0F D9 /r PSUBUSW mm, mm/m64     ; 66 0F D9 /r PSUBUSW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'psub', D$edi+4 'usw ' | add edi 8
        jmp Dis_xmmx1__xmmx2_m64_128
    End_If

    mov bl B$esi | inc esi | ModMask bl to al  ; 0EE 0011_101_110

    ..If al = 3
        mov al bl
        .If al = 0E4       ; D9 E4 FTST
            mov D$edi 'ftst' | add edi 4
        .Else_If al = 0E5  ; FXAM
            mov D$edi 'fxam' | add edi 4
        .Else_If al = 0F0  ; F2XM1
            mov D$edi 'f2xm', B$edi+4 '1' | add edi 5
        .Else_If al = 0F1  ; FYL2X
            mov D$edi 'fyl2', B$edi+4 'x' | add edi 5
        .Else_If al = 0F2  ; FPTAN
            mov D$edi 'fpta', B$edi+4 'n' | add edi 5
        .Else_If al = 0F3  ; FPATAN
            mov D$edi 'fpat', W$edi+4 'an' | add edi 6
        .Else_If al = 0F4  ; FXTRACT
            mov D$edi 'fxtr', D$edi+4 'act ' | add edi 7
        .Else_If al = 0F5  ; FPREM1
            mov D$edi 'fpre', W$edi+4 'm1' | add edi 6
        .Else_If al = 0F8  ; FPREM
            mov D$edi 'fpre', B$edi+4 'm' | add edi 5
        .Else_If al = 0F9  ; FYL2XP1
            mov D$edi 'fyl2', D$edi+4 'xp1 ' | add edi 7
        .Else_If al = 0FA  ; FSQRT
            mov D$edi 'fsqr', B$edi+4 't' | add edi 5
        .Else_If al = 0FB  ; FSINCOS
            mov D$edi 'fsin', D$edi+4 'cos ' | add edi 7
        .Else_If al = 0FC  ; FRNDINT
            mov D$edi 'frnd', D$edi+4 'int ' | add edi 7
        .Else_If al = 0FD  ; FSCALE
            mov D$edi 'fsca', W$edi+4 'le' | add edi 6
        .Else_If al = 0FE  ; FSIN
            mov D$edi 'fsin' | add edi 4
        .Else_If al = 0D0  ; FNOP
            mov D$edi 'fnop' | add edi 4
        .Else_If al = 0E1  ; FABS
            mov D$edi 'fabs' | add edi 4
        .Else_If al = 0E0  ; FCHS
            mov D$edi 'fchs' | add edi 4
        .Else_If al = 0E8  ; FLD1
            mov D$edi 'fld1' | add edi 4
        .Else_If al = 0E9  ; FLDL2T
            mov D$edi 'fldl', W$edi+4 '2t' | add edi 6
        .Else_If al = 0EA  ; FLDL2E
            mov D$edi 'fldl', W$edi+4 '2e' | add edi 6
        .Else_If al = 0EB  ; FLDPI
            mov D$edi 'fldp', B$edi+4 'i' | add edi 5
        .Else_If al = 0EC  ; FLDLG2
            mov D$edi 'fldl', W$edi+4 'g2' | add edi 6
        .Else_If al = 0ED  ; FLDLN2
            mov D$edi 'fldl', W$edi+4 'n2' | add edi 6
        .Else_If al = 0EE  ; FLDZ
            mov D$edi 'fldz' | add edi 4
        .Else_If al = 0F6  ; FDECSTP
            mov D$edi 'fdec', D$edi+4 'stp ' | add edi 7
        .Else_If al = 0F7  ; FINCSTP
            mov D$edi 'finc', D$edi+4 'stp ' | add edi 7
        .Else_If al = 0FF  ; FCOS
            mov D$edi 'fcos' | add edi 4
        .Else
            and eax (not 7)
            If al = 0C0         ; D9 C0+i > FLD ST(i)
                mov D$edi 'fld ' | add edi 4
            Else_If al = 0C8    ; D9 C8+i FXCH ST(i)
                mov D$edi 'fxch', B$edi+4 ' ' | add edi 5
            Else
                inc D$UnLikelyCode | dec esi | ret
            End_If

            call WriteSti

        .End_If

    ..Else
        DigitMask bl To al ; 0EE

        .If al = 0            ; D9 /0 > FLD m32fp
            mov D$edi 'fld ' | add edi 4 | jmp EndWith.F.mem
        .Else_If al = 2       ; FST m32fp
            mov D$edi 'fst ' | add edi 4 | jmp EndWith.F.mem
        .Else_If al = 3       ; FSTP m32fp
            mov D$edi 'fstp', B$edi+4 ' ' | add edi 5 | jmp EndWith.F.mem
        .Else_If al = 4       ; FLDENV m14/28byte
            mov D$edi 'flde', D$edi+4 'nv  ' | add edi 7 | jmp EndWith.X.mem
        .Else_If al = 5       ; D9 /5 > FLDCW m2byte
            mov D$edi 'fldc', W$edi+4 'w ' | add edi 6
        .Else_If al = 6       ; D9 /6FNSTENV* m14/28byte
            mov D$edi 'fnst', D$edi+4 'env ' | add edi 8 | jmp EndWith.X.mem
        .Else_If al = 7       ; D9 /7 > FNSTCW m2byte
            mov D$edi 'fnst', D$edi+4 'cw  ' | add edi 7
        .Else
            inc D$UnLikelyCode | dec esi | ret
        .End_If

        jmp EndWith.W.mem

    ..End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpDA:
    If B$EscapePrefix = &TRUE
      ; 0F DA /r PMINUB mm1, mm2/m64      ; 66 0F DA /r PMINUB xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'pmin', D$edi+4 'ub  ' | add edi 7
        jmp Dis_xmmx1__xmmx2_m64_128
    End_If

    mov bl B$esi | inc esi | ModMask bl to al

    ..If al = 3
        mov al bl

        .If al = 0E9     ; FUCOMPP
            mov D$edi 'fuco', D$edi+4 'mpp ' | add edi 7
            mov B$DisFlag DISDONE+DISLINEOVER | ret

        .Else
            and eax (not 7)
            If al = 0C0         ; DA C0+i : FCMOVB ST(0), ST(i)
                mov D$edi 'fcmo', D$edi+4 'vb  ' | add edi 7
            Else_If al = 0C8    ; FCMOVE ST(0), ST(i)
                mov D$edi 'fcmo', D$edi+4 've  ' | add edi 7
            Else_If al = 0D0    ; FCMOVBE ST(0), ST(i)
                mov D$edi 'fcmo', D$edi+4 'vbe ' | add edi 8
            Else_If al = 0D8    ; FCMOVU ST(0), ST(i)
                mov D$edi 'fcmo', D$edi+4 'vu  ' | add edi 7
            Else
                inc D$UnLikelyCode | dec esi | ret
            End_If

        .End_If

        call WriteSt0Sti

    ..Else
        DigitMask bl To al

        .If al = 0          ; FIADD m32int
            mov D$edi 'fiad', W$edi+4 'd ' | add edi 6
        .Else_If al = 1     ; FIMUL m32int
            mov D$edi 'fimu', W$edi+4 'l ' | add edi 6
        .Else_If al = 2     ; FICOM m32int
            mov D$edi 'fico', W$edi+4 'm ' | add edi 6
        .Else_If al = 3     ; FICOMP m32int
            mov D$edi 'fico', D$edi+4 'mp  ' | add edi 7
        .Else_If al = 4     ; FISUB m32int
            mov D$edi 'fisu', W$edi+4 'b ' | add edi 6
        .Else_If al = 5     ; FISUBR m32int
            mov D$edi 'fisu', D$edi+4 'br  ' | add edi 7
        .Else_If al = 6     ; FIDIV m32int
            mov D$edi 'fidi', W$edi+4 'v ' | add edi 6
        .Else_If al = 7     ; FIDIVR m32int
            mov D$edi 'fidi', D$edi+4 'vr  ' | add edi 7
        .End_If

        jmp EndWith.D.mem

    ..End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret




OpDB:
    If B$EscapePrefix = &TRUE
        ; 66 0F DB /r PAND xmm1, xmm2/m128      ; 0F DB /r PAND mm, mm/m64
        mov D$edi 'pand', B$edi+4 ' ' | add edi 5
        jmp Dis_xmmx1__xmmx2_m64_128
    End_If

    mov bl B$esi | inc esi | ModMask bl to al

    ..If al = 3
        mov al bl

        If al = 0E3      ; DB E3 FNINIT >>> E3 DigitBit = 4
            mov D$edi 'fnin', D$edi+4 'it  '
L0:         add edi 6 | mov B$DisFlag DISDONE+DISLINEOVER | ret
        Else_If al = 0E2    ; DB E2 FNCLEX*
            mov D$edi 'fncl', D$edi+4 'ex  ' | jmp L0<
        End_If

        and eax (not 7)

        .If al = 0C0        ; DA C0+i : FCMOVNB ST(0), ST(i)
            mov D$edi 'fcmo', D$edi+4 'vnb ' | add edi 8
        .Else_If al = 0C8   ; FCMOVNE ST(0), ST(i)
            mov D$edi 'fcmo', D$edi+4 'vne ' | add edi 8
        .Else_If al = 0D0   ; FCMOVNBE ST(0), ST(i)
            mov D$edi 'fcmo', D$edi+4 'vnbe', B$edi+8 ' ' | add edi 9
        .Else_If al = 0D8   ; FCMOVNU ST(0), ST(i)
            mov D$edi 'fcmo', D$edi+4 'vnu ' | add edi 8
        .Else_If al = 0E8   ; FUCOMI ST, ST(i)
            mov D$edi 'fuco', D$edi+4 'mi  ' | add edi 7
        .Else_If al = 0F0   ; FCOMI ST, ST(i)
            mov D$edi 'fcom', W$edi+4 'i ' | add edi 6
        .Else
            inc D$UnLikelyCode | dec esi | ret
        .End_If

        call WriteSt0Sti

    ..Else
        DigitMask bl To al

        .If al = 0     ; FILD m32int
            mov D$edi 'fild', B$edi+4 ' ' | add edi 5 | jmp EndWith.D.mem
        .Else_If al = 1        ; FISTTP  DB /1 FISTTP m32int
            mov D$edi 'fist', D$edi+4 'tp ' | add edi 7 | jmp EndWith.D.mem
        .Else_If al = 2        ; FIST m32int
            mov D$edi 'fist', B$edi+4 ' ' | add edi 5 | jmp EndWith.D.mem
        .Else_If al = 3        ; FISTP m32int
            mov D$edi 'fist', W$edi+4 'p ' | add edi 6 | jmp EndWith.D.mem
        .Else_If al = 5        ; FLD m80fp
            mov D$edi 'fld ' | add edi 4 | jmp EndWith.T.mem
        .Else_If al = 7        ; FSTP m80fp
            mov D$edi 'fstp', B$edi+4 ' ' | add edi 5 | jmp EndWith.T.mem
        .Else
            inc D$UnLikelyCode | dec esi | ret
        .End_If

     ..End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpDC:
    If B$EscapePrefix = &TRUE
        ; 66 0F DC /r PADDUSB xmm1, xmm2/m128     ; 0F DC /r PADDUSB mm, mm/m64
        ;inc D$UnLikelyCode
        mov D$edi 'padd', D$edi+4 'usb ' | add edi 8
        jmp Dis_xmmx1__xmmx2_m64_128
    End_If

    mov bl B$esi | inc esi | ModMask bl to al

    ..If al = 3
        mov al bl | and eax (not 7)

        If al = 0C0             ; FADD ST(i), ST(0)
            mov D$edi 'fadd', B$edi+4 ' ' | add edi 5
        Else_If al = 0C8        ; FMUL ST(i), ST(0)
            mov D$edi 'fmul', B$edi+4 ' ' | add edi 5
        Else_If al = 0E0        ; FSUBR ST(i), ST(0)
            mov D$edi 'fsub', W$edi+4 'r ' | add edi 6  ; fsubr
        Else_If al = 0E8        ; FSUB ST(i), ST(0)
            mov D$edi 'fsub', B$edi+4 ' ' | add edi 5
        Else_If al = 0F0        ; FDIVR ST(i), ST(0)
            mov D$edi 'fdiv', W$edi+4 'r ' | add edi 6
        Else_If al = 0F8        ; FDIV ST(i), ST(0)
            mov D$edi 'fdiv', B$edi+4 ' ' | add edi 5
        Else
            inc D$UnLikelyCode | dec esi | ret
        End_If

        call WriteStiSt0

    ..Else
        DigitMask bl To al

        .If al = 0          ; FADD m64fp
            mov D$edi 'fadd', B$edi+4 ' ' | add edi 5
        .Else_If al = 1     ; FMUL m64fp
            mov D$edi 'fmul', B$edi+4 ' ' | add edi 5
        .Else_If al = 2     ; FCOM m64fp
            mov D$edi 'fcom', B$edi+4 ' ' | add edi 5
        .Else_If al = 3     ; FCOMP m64fp
            mov D$edi 'fcom', W$edi+4 'p ' | add edi 6
        .Else_If al = 4     ; FSUB m64fp
            mov D$edi 'fsub', B$edi+4 ' ' | add edi 5
        .Else_If al = 5      ; FSUBR m64fp
            mov D$edi 'fsub', W$edi+4 'r ' | add edi 6
        .Else_If al = 6     ; FDIV m64fp
            mov D$edi 'fdiv', B$edi+4 ' ' | add edi 5
        .Else_If al = 7     ; FDIVR m64fp
            mov D$edi 'fdiv', W$edi+4 'r ' | add edi 6
        .End_If

        jmp EndWith.R.mem

    ..End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpDD:
    If B$EscapePrefix = &TRUE
        ; 66 0F DD /r PADDUSW xmm1, xmm2/m128     ; 0F DD /r PADDUSW mm, mm/m64
        mov D$edi 'padd', D$edi+4 'usw ' | add edi 8
        jmp Dis_xmmx1__xmmx2_m64_128
    End_If

    mov bl B$esi | inc esi | ModMask bl to al

    ..If al = 3
        mov al bl | and eax (not 7)

        If al = 0C0     ; C0+i :  FFREE ST(i)
            mov D$edi 'ffre', W$edi+4 'e ' | add edi 6
        Else_If al = 0D0    ; FST ST(i)
            mov D$edi 'fst ' | add edi 4
        Else_If al = 0D8        ; FSTP ST(i)
            mov D$edi 'fstp', B$edi+4 ' ' | add edi 5
        Else_If al = 0E0        ; FUCOM ST(i)
            mov D$edi 'fuco', W$edi+4 'm ' | add edi 6
        Else_If al = 0E8        ; FUCOMP ST(i)
            mov D$edi 'fuco', D$edi+4 'mp  ' | add edi 7
        Else
            inc D$UnLikelyCode | dec esi | ret
        End_If

        call WriteSti

    ..Else
        DigitMask bl To al

        .If al = 0          ; FLD m64fp
            mov D$edi 'fld ' | add edi 4 | jmp EndWith.R.mem
        .Else_If al = 1     ; FISTTP  DD /1 FISTTP m64int
            mov D$edi 'fst ', D$edi+4 'tp '| add edi 7 | jmp EndWith.R.mem
        .Else_If al = 2     ; FST m64fp
            mov D$edi 'fst ' | add edi 4 | jmp EndWith.R.mem
        .Else_If al = 3     ; FSTP m64fp
            mov D$edi 'fstp', B$edi+4 ' ' | add edi 5 | jmp EndWith.R.mem
        .Else_If al = 4     ; FRSTOR m94/108byte
            mov D$edi 'frst', D$edi+4 'or  ' | add edi 7 | jmp EndWith.X.mem
        .Else_If al = 6     ; FNSAVE* m94/108byte
            mov D$edi 'fnsa', D$edi+4 've  ' | add edi 7 | jmp EndWith.X.mem
        .Else_If al = 7     ; DD /7 FNSTSW* m2byte
            mov D$edi 'fnst', D$edi+4 'sw  ' | add edi 7 | jmp EndWith.W.mem
        .Else
            inc D$UnLikelyCode | dec esi | ret
        .End_If

    ..End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpDE:
    If B$EscapePrefix = &TRUE
        ; 0F DE /r PMAXUB mm1, mm2/m64      ; 66 0F DE /r PMAXUB xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'pmax', D$edi+4 'ub  ' | add edi 7
        jmp Dis_xmmx1__xmmx2_m64_128
    End_If

    mov bl B$esi | inc esi | ModMask bl to al

    ...If al = 3
        mov al bl

        .If al = 0D9        ; FCOMPP
            mov D$edi 'fcom', W$edi+4 'pp' | add edi 6
        .Else_If al = 0E9   ; FSUBP
            mov D$edi 'fsub', W$edi+4 'p ' | add edi 6
            call WriteStiSt0
        .Else
            and eax (not 7)

            If al = 0C0             ; FADDP ST(0), ST(i)
                mov D$edi 'fadd', W$edi+4 'p ' | add edi 6 | jmp WriteStiSt0
            Else_If al = 0C8        ; FMULP ST(i), ST(0)
                mov D$edi 'fmul', W$edi+4 'p ' | add edi 6
            Else_If al = 0E0        ; FSUBRP ST(i), ST(0)
                mov D$edi 'fsub', D$edi+4 'rp ' | add edi 7
            Else_If al = 0E8        ; FSUBP ST(i), ST(0)
                mov D$edi 'fsub', W$edi+4 'p ' | add edi 6
            Else_If al = 0F0        ; FDIVRP ST(i), ST(0)
                mov D$edi 'fdiv', D$edi+4 'rp ' | add edi 7
            Else_If al = 0F8        ; FDIVP ST(i), ST(0)
                mov D$edi 'fdiv', W$edi+4 'p ' | add edi 6
            Else
                inc D$UnLikelyCode | dec esi | ret
            End_If

            call WriteStiSt0

        .End_If

    ...Else
        DigitMask bl To al

        .If al = 0             ; FIADD m16int
            mov D$edi 'fiad', W$edi+4 'd ' | add edi 6
        .Else_If al = 1        ; FIMUL m16int
            mov D$edi 'fimu', W$edi+4 'l ' | add edi 6
        .Else_If al = 2        ; FICOM m16int
            mov D$edi 'fico', W$edi+4 'm ' | add edi 6
        .Else_If al = 3        ; FICOMP m16int
            mov D$edi 'fico', D$edi+4 'mp  ' | add edi 7
        .Else_If al = 4        ; FISUB m16int
            mov D$edi 'fisu', W$edi+4 'b ' | add edi 6
        .Else_If al = 5        ; FISUBR m16int
             mov D$edi 'fisu', D$edi+4 'br  ' | add edi 7
        .Else_If al = 6        ; FIDIV m16int
            mov D$edi 'fidi', W$edi+4 'v ' | add edi 6
        .Else_If al = 7        ; FIDIVR m16int
            mov D$edi 'fidi', D$edi+4 'vr  ' | add edi 7
        .End_If

        jmp EndWith.W.mem

    ...End_If

L9: mov B$DisFlag DISDONE+DISLINEOVER
ret


OpDF:
    If B$EscapePrefix = &TRUE
        ; 66 0F DF /r PANDN xmm1, xmm2/m128     ; 0F DF /r PANDN mm, mm/m64
        ;inc D$UnLikelyCode
        mov D$edi 'pand', W$edi+4 'n ' | add edi 6
        jmp Dis_xmmx1__xmmx2_m64_128
    End_If

    mov bl B$esi | inc esi | ModMask bl to al

    ...If al = 3
        mov al bl

        .If al = 0E0       ; DF E0 FNSTSW* AX
            mov D$edi 'fnst', D$edi+4 'sw a', B$edi+8 'x' | add edi 9
        .Else
            and eax (not 7)

            If al = 0F0        ; FCOMIP ST, ST(i)
                mov D$edi 'fcom', D$edi+4 'ip  ' | add edi 7
            Else_If al = 0C0
                mov D$edi 'ffre', D$edi+4 'ep  ' | add edi 7 | jmp WriteSti
            Else_If al = 0E8       ; FUCOMIP ST, ST(i)
                mov D$edi 'fuco', D$edi+4 'mip ' | add edi 8
            Else
                inc D$UnLikelyCode | dec esi | ret
            End_If

            jmp WriteSt0Sti

        .End_If

    ...Else
        DigitMask bl To al

        ..If al = 0     ; FILD m16int
            mov D$edi 'fild', B$edi+4 ' ' | add edi 5 | jmp EndWith.W.mem
        ..Else_If al = 1        ; FISTTP  DF /1 FISTTP m16int
            mov D$edi 'fist', D$edi+4 'tp ' | add edi 7 | jmp EndWith.W.mem
        ..Else_If al = 2        ; FIST m16int
            mov D$edi 'fist', B$edi+4 ' ' | add edi 5 | jmp EndWith.W.mem
        ..Else_If al = 3        ; FISTP m16int
            mov D$edi 'fist', W$edi+4 'p ' | add edi 6 | jmp EndWith.W.mem
        ..Else_If al = 4           ; /4 > FBLD m80 dec
            mov D$edi 'fbld', B$edi+4 ' ' | add edi 5 | jmp EndWith.T.mem
            ; This is an m80 Binary coded decimal chunk.
        ..Else_If al = 5        ; FILD m64int
            mov D$edi 'fild', B$edi+4 ' ' | add edi 5 | jmp EndWith.Q.mem
        ..Else_If al = 6      ; /6 > FBSTP m80bcd
            mov D$edi 'fbst', W$edi+4 'p ' | add edi 6 | jmp EndWith.T.mem
            ; This is an m80 Binary coded decimal chunk.
        ..Else_If al = 7        ; FISTP m64int
            mov D$edi 'fist', W$edi+4 'p ' | add edi 6 | jmp EndWith.Q.mem
        ..Else
            inc D$UnLikelyCode | dec esi | ret
        ..End_If
    ...End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpE0:
    If B$EscapePrefix = &TRUE
        ; 66 0F E0, /r PAVGB xmm1, xmm2/m128     ; 0F E0 /r PAVGB mm1, mm2/m64
        ;inc D$UnLikelyCode
        mov D$edi 'pavg', W$edi+4 'b ' | add edi 6
        jmp Dis_xmmx1__xmmx2_m64_128

    Else        ; LOOPNE rel8 ; LOOPNZ rel8
        inc D$LikelyCode
        mov D$edi 'loop', D$edi+4 'ne  ' | add edi 7
        mov B$CALLInstruction &TRUE
        test B$esi 080 | jnz L1>
            add D$UnLikelyCode 0FF
L1:     jmp EndWithDisByteRelativeBack

    End_If


OpE1:
    If B$EscapePrefix = &TRUE
      ; 0F E1 /r PSRAW mm, mm/m64       ; 66 0F E1 /r PSRAW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'psra', W$edi+4 'w ' | add edi 6
        jmp Dis_xmmx1__xmmx2_m64_128

    Else       ;  ; LOOPE rel8 ; LOOPZ rel8
        inc D$LikelyCode
        mov D$edi 'loop', W$edi+4 'e ' | add edi 6
        mov B$CALLInstruction &TRUE
        test B$esi 080 | jnz L1>
            add D$UnLikelyCode 0FF
L1:     jmp EndWithDisByteRelativeBack

    End_If


OpE2:
    If B$EscapePrefix = &TRUE
      ; 0F E2 /r PSRAD mm, mm/m64   ; 66 0F E2 /r PSRAD xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'psra', W$edi+4 'd ' | add edi 6
        jmp Dis_xmmx1__xmmx2_m64_128

    Else        ; LOOP rel8
        inc D$LikelyCode
        mov D$edi 'loop', B$edi+4 ' ' | add edi 5
        mov B$CALLInstruction &TRUE
        test B$esi 080 | jnz L1>
            add D$UnLikelyCode 0FF
L1:     jmp EndWithDisByteRelativeBack

    End_If


OpE3:
    .If B$EscapePrefix = &TRUE
        ; 66 0F E3 /r PAVGW xmm1, xmm2/m128 ; 0F E3 /r PAVGW mm1, mm2/m64
        ;inc D$UnLikelyCode
        mov D$edi 'pavg', W$edi+4 'w ' | add edi 6
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
        mov B$CALLInstruction &TRUE
        If B$OperandSizeOverride = &FALSE       ; JECXZ rel8
            inc D$LikelyCode
            SubEdi6 | mov D$edi ' | j', D$edi+4 'ecxz', B$edi+8 ' ' | add edi 9
        Else                                    ; JCXZ rel8
            inc D$UnLikelyCode
            SubEdi6 | mov D$edi ' | j', D$edi+4 'cxz ' | add edi 8
        End_If
        jmp EndWithDisByteRelative

    .End_If


OpE4:
    .If B$EscapePrefix = &TRUE
      ; 0F E4 /r PMULHUW mm1, mm2/m64       ; 66 0F E4 /r PMULHUW xmm1, xmm2/m128
        mov D$edi 'pmul', D$edi+4 'huw ' | add edi 8
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else        ; IN AL,imm8
        inc D$UnLikelyCode
        mov D$edi 'in a', W$edi+4 'l ' | add edi 6 | call WriteImm8

    .End_If

     mov B$DisFlag DISDONE+DISLINEOVER
ret


OpE5:

    .If B$EscapePrefix = &TRUE
      ; 0F E5 /r PMULHW mm, mm/m64      ; 66 0F E5 /r PMULHW xmm1, xmm2/m128
        mov D$edi 'pmul', D$edi+4 'hw  ' | add edi 7
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &FALSE   ; IN AX,imm8 / IN EAX,imm8
            mov D$edi 'in e', D$edi+4 'ax  ' | add edi 7
        Else
            mov D$edi 'in a', W$edi+4 'x ' | add edi 6
        End_If
        call WriteImm8

    .End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpE6: ; CVTTPD2DQ xmm1, xmm2/m128

    .If B$EscapePrefix = &TRUE
        If B$OperandSizeOverride = &TRUE    ; CVTTPD2DQ xmm1, xmm2/m128
            call MarkSSEdata SSE_2_R
            mov D$edi 'cvtt', D$edi+4 'pd2d', W$edi+8 'q ' | add edi 10
            jmp Dis_mmx1__xmm2_m128
        Else
            ret
        End_If
    .Else       ; OUT imm8, AL
        inc D$UnLikelyCode
        mov D$edi 'out ' | add edi 4
        call WriteImm8 | mov D$edi ' al ' | add edi 3

    .End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpE7:
    .If B$EscapePrefix = &TRUE
        mov bl B$esi | inc esi
        If B$OperandSizeOverride = &TRUE        ; 66 0F E7 /r MOVNTDQ m128, xmm
            mov D$edi 'movn', D$edi+4 'tdq ' | add edi 8
            jmp Dis_m128_xmm
        Else        ; 0F E7 /r MOVNTQ m64, mm
            mov D$edi 'movn', D$edi+4 'tq  ' | add edi 7
            jmp Dis_m64_mmx
        End_If

    .Else       ; OUT imm8, AX // OUT imm8, EAX
        inc D$UnLikelyCode
        mov D$edi 'out ' | add edi 4
        call WriteImm8
        If B$OperandSizeOverride = &TRUE
            mov D$edi ' ax ' | add edi 3
        Else
            mov D$edi ' eax' | add edi 4
        End_If

    .End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpE8:
    .If B$EscapePrefix = &TRUE
      ; 0F E8 /r PSUBSB mm, mm/m64  ; 66 0F E8 /r PSUBSB xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'psub', D$edi+4 'sb  ' | add edi 7
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else        ; call rel 16/32
        mov D$edi 'call', B$edi+4 ' ' | add edi 5
        mov B$CALLInstruction &TRUE

        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            lodsd
        Else
            inc D$UnLikelyCode
            movsx eax W$esi | add esi 2
        End_If

        mov D$LastCodeRef eax
        call RelativeToAbsolute | call WriteDisRelative

    .End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret

OpE9: ; jmp rel 16/32
    .If B$EscapePrefix = &TRUE
      ; 0F E9 /r PSUBSW mm, mm/m64  ; 66 0F E9 /r PSUBSW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
        mov D$edi 'psub', D$edi+4 'sw  ' | add edi 7
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else        ; jmp rel 16/32
        On B$edi-2 = ';', sub edi 4
        mov D$edi 'jmp ' | add edi 4
        mov B$CALLInstruction &TRUE, B$DisEndOfChunk &TRUE

        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            lodsd
        Else
            inc D$UnLikelyCode
            movsx eax W$esi | add esi 2
        End_If

        mov D$LastCodeRef eax
        call RelativeToAbsolute | call WriteDisRelative

    .End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpEA:
    ;inc D$UnLikelyCode
    .If B$EscapePrefix = &TRUE
      ; 0F EA /r PMINSW mm1, mm2/m64        ; 66 0F EA /r PMINSW xmm1, xmm2/m128
        mov D$edi 'pmin', D$edi+4 'sw  ' | add edi 7
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &TRUE    ; JMP ptr16:32, JMP ptr16:16 (jmp inter-segment).
            mov D$edi 'jmpF', D$edi+4 '16  ' | add edi 7
            push D$esi, esi
                Exchange W$esi, W$esi+2
                call WriteImm16 | mov B$edi ':' | inc edi | call WriteImm16
            pop eax, D$eax
        Else                                ;   call far ptr32:selector16
            mov D$edi 'jmpF', D$edi+4 '16  ' | add edi 7
            push D$esi, D$esi+4, esi
                mov eax D$esi, bx W$esi+4, W$esi bx, D$esi+2 eax
                call WriteImm16 | mov B$edi ':' | inc edi | call WriteImm32
            pop eax, D$eax+4, D$eax
        End_If
        mov B$DisEndOfChunk &TRUE
        mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    .End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpEB:
    If B$EscapePrefix = &TRUE
      ; 0F EB /r POR mm, mm/m64     ; 66 0F EB /r POR xmm1, xmm2/m128
        mov D$edi 'por ' | add edi 4
        jmp Dis_xmmx1__xmmx2_m64_128

    Else        ; jmp rel 8
        inc D$LikelyCode
        On B$edi-2 <> ';', sub edi 4
        mov D$edi 'jmp ' | add edi 4
        mov B$CALLInstruction &TRUE, B$DisEndOfChunk &TRUE | jmp EndWithDisByteRelative

    End_If


OpEC:
    If B$EscapePrefix = &TRUE
        ; 66 0F EC /r PADDSB xmm1,xmm2/m128       ; 0F EC /r PADDSB mm, mm/m64
        mov D$edi 'padd', D$edi+4 'sb  ' | add edi 7
        jmp Dis_xmmx1__xmmx2_m64_128

    Else           ; IN AL,DX
        inc D$UnLikelyCode
        mov D$edi 'in a', D$edi+4 'l dx' | add edi 8

    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpED:
    .If B$EscapePrefix = &TRUE
        ; 66 0F ED /r PADDSW xmm1, xmm2/m128    ; 0F ED /r PADDSW mm, mm/m64
        mov D$edi 'padd', D$edi+4 'sw  ' | add edi 7
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else        ; IN AX,DX / IN EAX,DX
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'in e', D$edi+4 'ax d', B$edi+8 'x' | add edi 9
        Else
            mov D$edi 'in a', D$edi+4 'x dx' | add edi 8
        End_If

    .End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret

OpEE:

    If B$EscapePrefix = &TRUE
        ; 0F EE /r PMAXSW mm1, mm2/m64      ; 66 0F EE /r PMAXSW xmm1, xmm2/m128
        mov D$edi 'pmax', D$edi+4 'sw  ' | add edi 7
        jmp Dis_xmmx1__xmmx2_m64_128

    Else          ; OUT DX, AL
        inc D$UnLikelyCode
        mov D$edi 'out ', D$edi+4 'dx a', B$edi+8 'l' | add edi 9

    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpEF:
    .If B$EscapePrefix = &TRUE
      ; 0F EF /r PXOR mm, mm/m64    ; 66 0F EF /r PXOR xmm1, xmm2/m128
        mov D$edi 'pxor', B$edi+4 ' ' | add edi 5
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
        inc D$UnLikelyCode
      ; OUT DX, AX // OUT DX, EAX
        mov D$edi 'out ', W$edi+4 'dx' | add edi 6
        If B$OperandSizeOverride = &FALSE
            mov D$edi ' eax' | add edi 4
        Else
            mov D$edi ' ax ' | add edi 3
        End_If

    .End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret

[LockPrefix: ?]

; ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR,
; SBB, SUB, XOR, XADD, XCHG

OpF0:
    mov B$LockPrefix &TRUE
    inc D$Prefixes
    mov D$edi 'lock', B$edi+4 ' ', B$DisFlag DISDONE | add edi 5
    mov B$DisFlag DISDONE ;+DISLINEOVER
ret


OpF1:
    ;inc D$UnLikelyCode
    If B$EscapePrefix = &TRUE
      ; 0F F1 /r PSLLW mm, mm/m64  ; 66 0F F1 /r PSLLW xmm1, xmm2/m128
        mov D$edi 'psll', W$edi+4 'w ' | add edi 6
        jmp Dis_xmmx1__xmmx2_m64_128
    End_If
ret


OpF2:
    ..If B$esi = 0F
        .If B$esi+1 = 010       ; F2 0F 10 /r MOVSD xmm1, xmm2/m64 ; op10
            add esi 2 | mov D$edi 'movs', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 011       ; F2 0F 11 /r MOVSD xmm2/m64, xmm
            add esi 2 | mov D$edi 'movs', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm2_m64__xmm1
        .Else_If B$esi+1 = 012       ; F2,0F,12,/r MOVDDUP xmm1, xmm2/m64
            add esi 2 | call MarkSSEdata SSE_1_Q
            mov D$edi 'movd', D$edi+4 'dup ' | add edi 8
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 02A       ; CVTSI2SD xmm, r/m32
            add esi 2 | call MarkSSEdata SSE_1_D
            mov D$edi 'cvts', D$edi+4 'i2sd', B$edi+8 ' ' | add edi 9
            jmp Dis_xmm1__rm32
        .Else_If B$esi+1 = 02C       ; CVTTSD2SI r32, xmm/m64
            add esi 2 | call MarkSSEdata SSE_1_R
            mov D$edi 'cvtt', D$edi+4 'sd2s', W$edi+8 'i ' | add edi 10
            jmp Dis_r32__xmm_m64
        .Else_If B$esi+1 = 02D       ; CVTSD2SI r32, xmm/m64
            add esi 2 | call MarkSSEdata SSE_1_R
            mov D$edi 'cvts', D$edi+4 'd2si', B$edi+8 ' ' | add edi 9
            jmp Dis_r32__xmm_m64
        .Else_If B$esi+1 = 051      ; F2 0F 51 /r SQRTSD xmm1, xmm2/m64
            add esi 2 | call MarkSSEdata SSE_2_R
            mov D$edi 'sqrt', D$edi+4 'sd  ' | add edi 7
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 058      ; ADDSD
            add esi 2 | call MarkSSEdata SSE_1_R
            mov D$edi 'adds', W$edi+4 'd ' | add edi 6 | call Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 059      ; F2 0F 59 /r MULSD xmm1, xmm2/m64
            add esi 2 | call MarkSSEdata SSE_1_R
            mov D$edi 'muls', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 05A       ; CVTSD2SS xmm1, xmm2/m64
            add esi 2 | call MarkSSEdata SSE_1_R
            mov D$edi 'cvts', D$edi+4 'd2ss', B$edi+8 ' ' | add edi 9
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 05C   ; F2 0F 5C /r SUBSD xmm1, xmm2/m64
            add esi 2 | call MarkSSEdata SSE_2_R
            mov D$edi 'subs', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 05D       ; MINSD xmm1, xmm2/m64
            add esi 2 | call MarkSSEdata SSE_1_R
            mov D$edi 'mins', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 05E         ; DIVSD xmm1, xmm2/m64
            add esi 2 | call MarkSSEdata SSE_1_R
            mov D$edi 'divs', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 05F      ; F2 0F 5F /r MAXSD xmm1, xmm2/m64
            add esi 2 | call MarkSSEdata SSE_1_R
            mov D$edi 'maxs', W$edi+4 'd ' | add edi 6
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 070      ; F2 0F 70 /r ib PSHUFLW xmm1, xmm2/m128, imm8
            add esi 2 | mov D$edi 'pshu', D$edi+4 'flw ' | add edi 8
            call Dis_xmm1__xmm2_m128 | mov B$edi ' ' | inc edi
            call WriteImm8
        .Else_If B$esi+1 = 07C      ; F2,0F,7C,/r HADDPS xmm1, xmm2/m128
            add esi 2 | call MarkSSEdata SSE_4_F
            mov D$edi 'hadd', D$edi+4 'ps ' | add edi 7
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 07D      ; F2,0F,7D,/r HSUBPS xmm1, xmm2/m128
            add esi 2 | call MarkSSEdata SSE_4_F
            mov D$edi 'hsub', D$edi+4 'ps ' | add edi 7
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 0C2       ; CMPSD xmm1, xmm2/m64, imm8
            add esi 2 | mov D$edi 'cmps', W$edi+4 'd ' | add edi 6
            call Dis_xmm1__xmm2_m64 | jmp WritePacketCondition
        .Else_If B$esi+1 = 0D0          ; F2,0F,D0,/r ADDSUBPS xmm1, xmm2/m128
            add esi 2 | call MarkSSEdata SSE_4_F
            mov D$edi 'adds', D$edi+4 'ubps', B$edi+8 ' ' | add edi 9
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 0D6          ; F2 0F D6 MOVDQ2Q mm, xmm
            add esi 2 | mov D$edi 'movd', D$edi+4 'q2q ' | add edi 8
            jmp Dis_mmx_xmm
        .Else_If B$esi+1 = 0E6       ; CVTPD2DQ xmm1, xmm2/m128
            add esi 2 | call MarkSSEdata SSE_2_R
            mov D$edi 'cvtp', D$edi+4 'd2dq', B$edi+8 ' ' | add edi 9
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 0F0       ; F2,0F,F0,/r LDDQU xmm, mem
            add esi 2 | mov D$edi 'lddq', D$edi+4 'u ' | add edi 6
            jmp Dis_xmm1__xmm2_m128  ; Xmm2 is dummy, here.
        .Else
            inc D$UnLikelyCode | ret
        .End_If

    ..Else_If B$esi = 0A6   ; F2 A6 REPNE CMPS m8, m8
        inc esi | mov D$edi 'repn', D$edi+4 'e cm', D$edi+8 'psb ' | add edi 11
    ..Else_If W$esi = 0A766   ; F2 A7 REPNE CMPS m16, m16 ; F2 A7 REPNE CMPS m32, m32
        add esi 2 | mov D$edi 'repn', D$edi+4 'e cm', D$edi+8 'psw ' | add edi 11
    ..Else_If B$esi = 0A7   ; F2 A7 REPNE CMPS m16, m16 ; F2 A7 REPNE CMPS m32, m32
        inc esi | mov D$edi 'repn', D$edi+4 'e cm', D$edi+8 'psd ' | add edi 11
    ..Else_If B$esi = 0AE   ; F2 AE REPNE SCAS m8
        inc esi | mov D$edi 'repn', D$edi+4 'e sc', D$edi+8 'asb ' | add edi 11
    ..Else_If W$esi = 0AF66   ; F2 AF REPNE SCAS m16 ; F2 AF REPNE SCAS m32
        add esi 2 | mov D$edi 'repn', D$edi+4 'e sc', D$edi+8 'asw ' | add edi 11
    ..Else_If B$esi = 0AF   ; F2 AF REPNE SCAS m16 ; F2 AF REPNE SCAS m32
        inc esi | mov D$edi 'repn', D$edi+4 'e sc', D$edi+8 'asd ' | add edi 11
    ..Else
        .If B$EscapePrefix = &TRUE
          ; 0F F2 /r PSLLD mm, mm/m64   ;  66 0F F2 /r PSLLD xmm1, xmm2/m128
            mov D$edi 'psll', W$edi+4 'd ' | add edi 6 | jmp Dis_xmmx1__xmmx2_m64_128
        .Else
            inc D$UnLikelyCode | ret
        .End_If
    ..End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpF3:
    ..If B$esi = 0F
        .If B$esi+1 = 010       ; F3 0F 10 /r MOVSS xmm1, xmm2/m32
            add esi 2 | call MarkSSEdata SSE_1_R
            mov D$edi 'movs', W$edi+4 's ' | add edi 6
            jmp Dis_xmm1__xmm2_m32F
        .Else_If B$esi+1 = 011       ; F3 0F 11 /r MOVSS xmm2/m32, xmm
            add esi 2 | call MarkSSEdata SSE_1_R
            mov D$edi 'movs', W$edi+4 's ' | add edi 6
            jmp Dis_xmm2_m32F__xmm1
        .Else_If B$esi+1 = 012       ; F3,0F,12,/r MOVSLDUP xmm1, xmm2/m128
            add esi 2 | call MarkSSEdata SSE_4_F
            mov D$edi 'movs', D$edi+4 'ldup', B$edi+8 ' ' | add edi 9
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 016       ; F3,0F,16,/r MOVSHDUP xmm1, xmm2/m128
            add esi 2 | call MarkSSEdata SSE_4_F
            mov D$edi 'movs', D$edi+4 'hdup', B$edi+8 ' ' | add edi 9
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 051      ; F3 0F 51 /r SQRTSS xmm1, xmm2/m32
            add esi 2 | call MarkSSEdata SSE_4_F
            mov D$edi 'sqrt', D$edi+4 'ss  ' | add edi 7 | jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 052      ; F3 0F 52 /r RSQRTSS xmm1,xmm2/m32
            add esi 2 | call MarkSSEdata SSE_4_F
            mov D$edi 'rsqr', D$edi+4 'tss ' | add edi 8 | jmp Dis_xmm1__xmm2_m32
        .Else_If al = 053; F3 0F 53 /r RCPSS xmm1, xmm2/m32; F3 0F 53 /r RCPSS xmm1, xmm2/m32
            add esi 2 | call MarkSSEdata SSE_4_F
            mov D$edi 'rcpp', W$edi+4 's ' | add edi 6 | jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 058 ; F3 0F 58 /r ADDSS
            add esi 2 | call MarkSSEdata SSE_1_F
            mov D$edi 'adds', W$edi+4 's ' | add edi 6 | jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 059       ; F3 0F 59 /r MULSS xmm1, xmm2/m32
            add esi 2 | call MarkSSEdata SSE_1_F
            mov D$edi 'muls', W$edi+4 's ' | add edi 6
            jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 05C   ; F3 0F 5C /r SUBSS xmm1, xmm2/m32
            add esi 2 | call MarkSSEdata SSE_4_F
            mov D$edi 'subs', W$edi+4 's ' | add edi 6
            jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 05D       ; MINSS xmm1, xmm2/m32
            add esi 2 | call MarkSSEdata SSE_1_F
            mov D$edi 'mins', W$edi+4 's ' | add edi 6
            jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 05F      ; F3 0F 5F /r MAXSS xmm1, xmm2/m32
            add esi 2 | call MarkSSEdata SSE_1_F
            mov D$edi 'maxs', W$edi+4 's ' | add edi 6
            jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 070       ; F3 0F 70 /r ib PSHUFHW xmm1, xmm2/m128, imm8
            add esi 2 | mov D$edi 'pshu', D$edi+4 'fhw ' | add edi 8
            call Dis_xmm1__xmm2_m128 | mov B$edi ' ' | inc edi
            call WriteImm8
        .Else_If B$esi+1 = 07E      ;  F3 0F 7E MOVQ xmm1, xmm2/m64
            add esi 2 | mov D$edi 'movq', B$edi+4 ' ' | add edi 5
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 0C2      ; CMPSD xmm1, xmm2/m64, imm8
            add esi 2 | mov D$edi 'cmps', W$edi+4 's ' | add edi 6
            call  Dis_xmm1__xmm2_m64 | jmp WritePacketCondition
        .Else_If B$esi+1 = 0D6        ; F3 0F D6 MOVQ2DQ xmm, mm
            add esi 2 | mov D$edi 'movq', D$edi+4 '2dq ' | add edi 8
            jmp Dis_xmm_mmx
        .Else_If B$esi+1 = 0E6      ; CVTDQ2PD xmm1, xmm2/m64
            add esi 2 | call MarkSSEdata SSE_2_D
            mov D$edi 'cvtd', D$edi+4 'q2pd', B$edi+8 ' ' | add edi 9
            jmp Dis_xmm1__xmm2_m64
        .Else_If B$esi+1 = 02A      ; CVTSI2SS xmm, r/m32
            add esi 2 | call MarkSSEdata SSE_1_D
            mov D$edi 'cvts', D$edi+4 'i2ss', B$edi+8 ' ' | add edi 9
            jmp Dis_xmm1__rm32
        .Else_If B$esi+1 = 02C      ; CVTTSS2SI r32, xmm/m32
            add esi 2 | call MarkSSEdata SSE_1_F
            mov D$edi 'cvtt', D$edi+4 'ss2s', W$edi+8 'i ' | add edi 10
            jmp Dis_r32__xmm_m32
        .Else_If B$esi+1 = 05A      ; CVTSS2SD xmm1, xmm2/m32
            add esi 2 | call MarkSSEdata SSE_1_F
            mov D$edi 'cvts', D$edi+4 's2sd', B$edi+8 ' ' | add edi 9
            jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 02D      ; CVTSS2SI r32, xmm/m32
            add esi 2 | call MarkSSEdata SSE_1_F
            mov D$edi 'cvts', D$edi+4 's2si', B$edi+8 ' ' | add edi 9
            jmp Dis_r32__xmm_m32
        .Else_If B$esi+1 = 05B      ; CVTTPS2DQ xmm1, xmm2/m128
            add esi 2 | call MarkSSEdata SSE_4_F
            mov D$edi 'cvtt', D$edi+4 'ps2d', W$edi+8 'q ' | add edi 10
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 05E      ; DIVSS xmm1, xmm2/m32
            add esi 2 | call MarkSSEdata SSE_1_F
            mov D$edi 'divs', W$edi+4 's ' | add edi 6
            jmp Dis_xmm1__xmm2_m32
        .Else_If B$esi+1 = 06F      ; F3 0F 6F /r MOVDQU xmm1, xmm2/m128
            add esi 2 | mov D$edi 'movd', D$edi+4 'qu  ' | add edi 7
            jmp Dis_xmm1__xmm2_m128
        .Else_If B$esi+1 = 07F      ; F3 0F 7F /r MOVDQU xmm2/m128, xmm1
            add esi 2 | mov D$edi 'movd', D$edi+4 'qu  ' | add edi 7
            jmp Dis_xmm2_m128__xmm1
        .Else
            ret
        .End_If

    ..Else_If B$esi = 090   ; F3 90 PAUSE
        inc esi | mov D$edi 'paus', B$edi+4 'e' | add edi 5
    ..Else_If W$esi = 0A766 ; F3 66 17
        add esi 2 | mov D$edi 'rep ', D$edi+4 'cmps', B$edi+8 'w' | add edi 9
      ;  add esi 2 | mov D$edi 'rep ', D$edi+4 'movs', B$edi+8 'w' | add edi 9
    ..Else_If W$esi = 0AF66 ; F3 66 17
        add esi 2 | mov D$edi 'rep ', D$edi+4 'scas', B$edi+8 'w' | add edi 9
    ..Else_If W$esi = 0A566 ; F3 66 17
        add esi 2 | mov D$edi 'rep ', D$edi+4 'movs', B$edi+8 'w' | add edi 9
      ;!!!!  add esi 2 | mov D$edi 'rep ', D$edi+4 'cmps', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 06C       ; F3 6C REP INS r/m8, DX
        inc D$UnLikelyCode
        inc esi | mov D$edi 'rep ', D$edi+4 'insb' | add edi 8 ; | jmp Dis_rm8_dx
    ..Else_If B$esi = 06D       ; F3 6D REP INS r/m16, DX ; F3 6D REP INS r/m32, DX
        inc D$UnLikelyCode
        inc esi | mov D$edi 'rep ', D$edi+4 'insd' | add edi 8 ; | jmp Dis_rm32_rm16__dx
    ..Else_If W$esi = 06D66       ; F3 6D REP INS r/m16, DX ; F3 6D REP INS r/m32, DX
        inc D$UnLikelyCode
        add esi 2 | mov D$edi 'rep ', D$edi+4 'insw' | add edi 8 ; | jmp Dis_rm32_rm16__dx
    ..Else_If B$esi = 06E       ; F3 6E REP OUTS DX, r/m8
        inc D$UnLikelyCode
        inc esi | mov D$edi 'rep ', D$edi+4 'outs', B$edi+8 'b' | add edi 9 ;| jmp Dis_dx_rm8
    ..Else_If W$esi = 06F66       ; F3 6F REP OUTS DX, r/m16 ; F3 6F REP OUTS DX, r/m32
        inc D$UnLikelyCode
        add esi 2 | mov D$edi 'rep ', D$edi+4 'outs', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 06F       ; F3 6F REP OUTS DX, r/m16 ; F3 6F REP OUTS DX, r/m32
        inc D$UnLikelyCode
        inc esi | mov D$edi 'rep ', D$edi+4 'outs', B$edi+8 'd' | add edi 9 ;| jmp Dis_dx__rm32_rm16
    ..Else_If B$esi = 0A4       ; F3 A4 REP MOVS m8, m8
        inc esi | mov D$edi 'rep ', D$edi+4 'movs', B$edi+8 'b' | add edi 9
    ..Else_If W$esi = 0A566       ; F3 A5 REP MOVS m16, m16 ; F3 A5 REP MOVS m32, m32
        add esi 2 | mov D$edi 'rep ', D$edi+4 'movs', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 0A5       ; F3 A5 REP MOVS m16, m16 ; F3 A5 REP MOVS m32, m32
        inc esi | mov D$edi 'rep ', D$edi+4 'movs', B$edi+8 'd' | add edi 9
    ..Else_If B$esi = 0A6       ; F3 A6 REPE CMPS m8, m8
        inc esi | mov D$edi 'rep ', D$edi+4 'cmps', B$edi+8 'b' | add edi 9
    ..Else_If W$esi = 0A766       ; F3 A7 REPE CMPS m16, m16 ; F3 A7 REPE CMPS m32, m32
        add esi 2 | mov D$edi 'rep ', D$edi+4 'cmps', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 0A7       ; F3 A7 REPE CMPS m16, m16 ; F3 A7 REPE CMPS m32, m32
        inc esi | mov D$edi 'rep ', D$edi+4 'cmps', B$edi+8 'd' | add edi 9
    ..Else_If B$esi = 0AA       ; F3 AA REP STOS m8
        inc esi | mov D$edi 'rep ', D$edi+4 'stos', B$edi+8 'b' | add edi 9
    ..Else_If W$esi = 0AB66       ; F3 AB REP STOS m16 ; F3 AB REP STOS m32
        add esi 2 | mov D$edi 'rep ', D$edi+4 'stos', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 0AB       ; F3 AB REP STOS m16 ; F3 AB REP STOS m32
        inc esi | mov D$edi 'rep ', D$edi+4 'stos', B$edi+8 'd' | add edi 9
    ..Else_If B$esi = 0AC       ; F3 AC REP LODS AL
        inc esi | mov D$edi 'rep ', D$edi+4 'lods', B$edi+8 'b' | add edi 9
    ..Else_If W$esi = 0AD66       ; F3 AD REP LODS AX ; F3 AD REP LODS EAX
        add esi 2 | mov D$edi 'rep ', D$edi+4 'lods', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 0AD       ; F3 AD REP LODS AX ; F3 AD REP LODS EAX
        inc esi | mov D$edi 'rep ', D$edi+4 'lods', B$edi+8 'd' | add edi 9
    ..Else_If B$esi = 0AE       ; F3 AE REPE SCAS m8
        inc esi | mov D$edi 'rep ', D$edi+4 'scas', B$edi+8 'b' | add edi 9
    ..Else_If W$esi = 0AF66       ; F3 AF REPE SCAS m16 ; F3 AF REPE SCAS m32
        add esi 2 | mov D$edi 'rep ', D$edi+4 'scas', B$edi+8 'w' | add edi 9
    ..Else_If B$esi = 0AF       ; F3 AF REPE SCAS m16 ; F3 AF REPE SCAS m32
        inc esi | mov D$edi 'rep ', D$edi+4 'scas', B$edi+8 'd' | add edi 9
    ..Else
        If B$EscapePrefix = &TRUE
            ; 0F F3 /r PSLLQ mm, mm/m64     ; 66 0F F3 /r PSLLQ xmm1, xmm2/m128
            mov D$edi 'psll', W$edi+4 'q ' | add edi 6
            jmp Dis_xmmx1__xmmx2_m64_128
        Else
            ret
        End_If
    ..End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpF4: ; HLT
    If B$EscapePrefix = &TRUE
      ; 0F F4 /r PMULUDQ mm1, mm2/m64       ; 66 OF F4 /r PMULUDQ xmm1, xmm2/m128
        mov D$edi 'pmul', D$edi+4 'udq ' | add edi 8
        jmp Dis_xmmx1__xmmx2_m64_128

    Else
        inc D$UnLikelyCode
        mov D$edi 'hlt ' | add edi 3

    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpF5: ; cmc
    If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
      ; 0F F5 /r PMADDWD mm, mm/m64       ; 66 0F F5 /r PMADDWD xmm1, xmm2/m128
        mov D$edi 'pmad', D$edi+4 'dwd ' | add edi 8
        jmp Dis_xmmx1__xmmx2_m64_128

    Else
        mov D$edi 'cmc ' | add edi 3  ; cmc

    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpF6:
    .If B$EscapePrefix = &TRUE
      ; 0F F6 /r PSADBW mm1, mm2/m64        ; 66 0F F6 /r PSADBW xmm1, xmm2/m128
        ;inc D$UnLikelyCode
         mov D$edi 'psad', D$edi+4 'bw  ' | add edi 7
        jmp Dis_xmmx1__xmmx2_m64_128

    .Else
        inc D$LikelyCode
        mov bl B$esi | inc esi | DigitMask bl To al              ; ModRm with /6 ?

        If al = 0   ; F6 /0 ib TEST r/m8,imm8
            mov D$edi 'test', B$edi+4 ' ' | add edi 5 | jmp Dis_rm8_imm8
        Else_If al = 2       ; F6 /2 NOT r/m8
            mov B$LockPrefix &FALSE
            mov D$edi 'not ' | add edi 4
        Else_If al = 3       ; F6 /3 NEG r/m8
            mov B$LockPrefix &FALSE
            mov D$edi 'neg ' | add edi 4
        Else_If al = 4           ; F6 /4 MUL r/m8
            mov D$edi 'mul ' | add edi 4
        Else_If al = 5           ; IMUL r/m8
            mov D$edi 'imul', B$edi+4 ' ' | add edi 5
        Else_If al = 6      ; DIV r/m8
            mov D$edi 'div ' | add edi 4
        Else_If al = 7      ; IDIV r/m8
            mov D$edi 'idiv', B$edi+4 ' ' | add edi 5
        Else
            inc D$UnLikelyCode | ret
        End_If

        jmp EndWith.B.mem

    .End_If
ret


OpF7:
    ..If B$EscapePrefix = &TRUE
        ;inc D$UnLikelyCode
        mov D$edi 'mask' | mov bl B$esi | inc esi
        If B$OperandSizeOverride = &TRUE    ; 66 0F F7 /r MASKMOVDQU xmm1, xmm2
            mov D$edi+4 'movd', D$edi+8 'qu  ' | add edi 11
            jmp Dis_xmm1_xmm2
        Else                                ; 0F F7 /r MASKMOVQ mm1, mm2
            mov D$edi+4 'movq', B$edi+8 ' ' | add edi 9
            jmp Dis_mmx1_mmx2
        End_If


    ..Else
        inc D$LikelyCode
        mov bl B$esi | inc esi | DigitMask bl To al              ; ModRm with /6 ?

        .If al = 0  ; F7 /0 iw TEST r/m16,imm16 ; F7 /0 id TEST r/m32,imm32
            mov D$edi 'test', B$edi+4 ' ' | add edi 5 | jmp Dis_rm32_rm16__imm32_imm16
        .Else_If al = 2      ; F7 /2 NOT r/m16
            mov B$LockPrefix &FALSE
            mov D$edi 'not ' | add edi 4
        .Else_If al = 3       ; F7 /3 NEG r/m16
            mov B$LockPrefix &FALSE
            mov D$edi 'neg ' | add edi 4
        .Else_If al = 4           ; F7 /4 MUL r/m16
            mov D$edi 'mul ' | add edi 4
        .Else_If al = 5           ; IMUL r/m16
            mov D$edi 'imul', B$edi+4 ' ' | add edi 5
        .Else_If al = 6      ; DIV r/m32 r/m16
            mov D$edi 'div ' | add edi 4
        .Else_If al = 7      ; IDIV r/m32 // r/m16
            mov D$edi 'idiv', B$edi+4 ' ' | add edi 5
        .Else
            inc D$UnLikelyCode | ret
        .End_If

        On B$OperandSizeOverride = &TRUE, jmp EndWith.W.mem
        jmp EndWith.D.mem

    ..End_If
ret



OpF8:
    If B$EscapePrefix = &TRUE
      ; 0F F8 /r PSUBB mm, mm/m64   ; 66 0F F8 /r PSUBB xmm1, xmm2/m128
        mov D$edi 'psub', W$edi+4 'b ' | add edi 6 | jmp Dis_xmmx1__xmmx2_m64_128

    Else; clc
        mov D$edi 'clc ' | add edi 3

    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpF9:
    If B$EscapePrefix = &TRUE
      ; 0F F9 /r PSUBW mm, mm/m64   ; 66 0F F9 /r PSUBW xmm1, xmm2/m128
        mov D$edi 'psub', W$edi+4 'w ' | add edi 6 | jmp Dis_xmmx1__xmmx2_m64_128

    Else       ; F9 STC
        mov D$edi 'stc ' | add edi 3

    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpFA:
    If B$EscapePrefix = &TRUE
      ; 0F FA /r PSUBD mm, mm/m64   ; 66 0F FA /r PSUBD xmm1, xmm2/m128
        mov D$edi 'psub', W$edi+4 'd ' | add edi 6 | jmp Dis_xmmx1__xmmx2_m64_128

    Else
        inc D$UnLikelyCode
        mov D$edi 'cli ' | add edi 3
    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpFB:
    If B$EscapePrefix = &TRUE
      ; 0F FB /r PSUBQ mm1, mm2/m64 ; 66 0F FB /r PSUBQ xmm1, xmm2/m128
        mov D$edi 'psub', W$edi+4 'q ' | add edi 6 | jmp Dis_xmmx1__xmmx2_m64_128

    Else       ; FB STI
        inc D$UnLikelyCode
        mov D$edi 'sti ' | add edi 3

    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpFC:
    If B$EscapePrefix = &TRUE
        ; 66 0F FC /r PADDB xmm1,xmm2/m128    ; 0F FC /r PADDB mm, mm/m64
        mov D$edi 'padd', W$edi+4 'b ' | add edi 6 | jmp Dis_xmmx1__xmmx2_m64_128

    Else               ; cld
        mov D$edi 'cld ' | add edi 3

    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpFD:
    If B$EscapePrefix = &TRUE
        ; 66 0F FD /r PADDW xmm1, xmm2/m128     ;  0F FD /r PADDW mm, mm/m64
        mov D$edi 'padd', W$edi+4 'w ' | add edi 6 | jmp Dis_xmmx1__xmmx2_m64_128

    Else       ; FD STD
        mov D$edi 'std ' | add edi 3

    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


OpFE:
    .If B$EscapePrefix = &TRUE
        ; 66 0F FE /r PADDD xmm1, xmm2/m128    ; 0F FE /r PADDD mm, mm/m64
        ;inc D$UnLikelyCode
        mov D$edi 'padd', W$edi+4 'd ' | add edi 6 | jmp Dis_xmmx1__xmmx2_m64_128

    .Else
        movzx ebx B$esi | inc esi | DigitMask bl to al
        If al = 0           ; INC r/m8
            mov B$LockPrefix &FALSE
            mov D$edi 'inc '
        Else_If al = 1      ; DEC r/m8
            mov B$LockPrefix &FALSE
            mov D$edi 'dec '
        Else
            inc D$UnLikelyCode | ret
        End_If

        add edi 4 | jmp EndWith.B.mem
    .End_If
ret

;075 00_01_110_101

OpFF:
    movzx ebx B$esi | inc esi | DigitMask bl to al

    .If al = 0           ; INC r/m16 / r/m32
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'inc ' | add edi 4 | jmp EndWith.WD.mem

    .Else_If al = 1      ; DEC r/m32 // DEC r/m16
        inc D$LikelyCode
        mov B$LockPrefix &FALSE
        mov D$edi 'dec ' | add edi 4 | jmp EndWith.WD.mem

    .Else_If al = 2     ;  ; FF /2 CALL r/m16 ; FF /2 CALL r/m32
        inc D$LikelyCode
        mov D$edi 'call', B$edi+4 ' ' | add edi 5
      ; add here the DLL Functions calls.
      ; If BL = 15 and D$esi inside .import Address Table
      ;             or D$esi points to a JMP Pointer To .import Address Table
        jmp L5> ;;;call Dis_rm32_rm16

    .Else_If al = 3
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &TRUE
            mov D$edi 'call', D$edi+4 'F16 ' | add edi 8
        Else
            mov D$edi 'call', D$edi+4 'F32 ' | add edi 8
        End_If
        call WriteEffectiveAddressFromModRm         ; Mem pointing to 16:16/32
        mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    .Else_If al = 4      ; JMP r/m16 ; ; JMP r/m32
        inc D$LikelyCode
        mov B$DisEndOfChunk &TRUE
        mov D$edi 'jmp ' | add edi 4

L5:     ;push D$LastCodeRef
            call Dis_rm32_rm16
;       ;pop eax
;;
        cmp eax D$LastCodeRef | je L9>>
      ; This 'D$LastCodeRef' may be, for example, 'mov eax D$Codexxxx' or 'D$Dataxxxx'.
            mov ebx D$LastCodeRef
            cmp ebx D$DisCodeMin | jb L9>>
            cmp ebx D$DisCodeMax | ja L9>>
                call ExtendToSideCodePointers

L9:         cmp ebx D$DisDataMin | jb L9>>
            cmp ebx D$DisDataMax | ja L9>>
                call ExtendToSideDataPointers
;;

  ; OpEA: ; JMP ptr16:32, JMP ptr16:16 (jmp inter-segment).
    .Else_If al = 5      ; JMP m16:32
        inc D$UnLikelyCode
        If B$OperandSizeOverride = &FALSE
            mov D$edi 'jmpF', D$edi+4 '16  ' | add edi 7
        Else
            mov D$edi 'jmpF', D$edi+4 '32  ' | add edi 7
        End_If
        mov B$DisEndOfChunk &TRUE
        call WriteEffectiveAddressFromModRm
        mov D$edi ' ; !', D$edi+4 '!!!!' | add edi 8

    .Else_If al = 6     ; FF /6 PUSH r/m16  ; FF /6 PUSH r/m32
        inc D$LikelyCode
        mov D$edi 'push', B$edi+4 ' ' | add edi 5 | jmp Dis_m32_16

    .Else
        inc D$UnLikelyCode
        ret

    .End_If

L9: mov B$DisFlag DISDONE+DISLINEOVER
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; Routines usable by several encodings:
____________________________________________________________________________________________
____________________________________________________________________________________________

Dis_rm8_r8:
    mov W$DisSizeMarker 'B$'
    movzx ebx B$esi | inc esi
    push ebx
        call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WriteByteRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_al_imm8:
    mov D$edi 'al  ' | add edi 3 | call WriteImm8
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_eax_ax__imm32_imm16:
    If B$OperandSizeOverride = &TRUE
        mov D$edi 'ax  ' | add edi 3 | call WriteImm16
    Else
        mov D$edi 'eax ' | add edi 4 | call WriteImm32
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_eax_ax__rd_rw:
  ; See: ; 90+rw XCHG AX, r16 ; 90+rd XCHG EAX, r32
  ;
  ; the Reg is given in the last Opcode Byte, in the BaseMask

    movzx eax B$esi-1 | and eax 00_000_111

    If B$OperandSizeOverride = &TRUE
        mov D$edi 'ax  ' | add edi 3
        mov eax D$WordRegsTable+eax*4 | stosd | dec edi
    Else
        mov D$edi 'eax ' | add edi 4
        mov eax D$dWordRegsTable+eax*4 | stosd
    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm8_m8:
    mov W$DisSizeMarker 'B$'
    movzx ebx B$esi | inc esi
    push ebx
        call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WriteByteRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_rm16__r32_r16:
    On B$OperandSizeOverride = &TRUE, mov W$DisSizeMarker 'W$'
    movzx ebx B$esi | inc esi
    push ebx
        call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WritedWordRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Dis_rm32_rm16__r32_r16__imm8:
    call Dis_rm32_rm16__r32_r16 | mov B$edi ' ' | inc edi
    call WriteImm8      ; not signed this is for SHLD / SHRD
ret

Dis_rm32_rm16__r32_r16__cl:
    call Dis_rm32_rm16__r32_r16 | mov D$edi ' cl ' | add edi 3
ret

Dis_m32_r32:
    mov W$DisSizeMarker 'D$'
    movzx ebx B$esi | inc esi
    push ebx
        call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WritedWordRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r8_rm8:
    mov W$DisSizeMarker 'B$'
    movzx ebx B$esi | inc esi
    call WriteByteRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWithModRm ;EndWith.D.mem
ret

Dis_r32_r16__rm32_rm16:
    On  B$OperandSizeOverride = &TRUE, mov W$DisSizeMarker 'W$'
    movzx ebx B$esi | inc esi
    call WritedWordRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.D.mem
ret

Dis_r32_r16__rm32_rm16_orNone__SignedImm8:
    On  B$OperandSizeOverride = &TRUE, mov W$DisSizeMarker 'W$'
    movzx ebx B$esi | inc esi
    call WritedWordRegsFromRegBits | mov B$edi ' ' | inc edi
    Test bl 00_11_000_000 | jz L2>
        RegMask bl to al | RmMask bl to cl | ;on al = cl jmp L3>
            call WriteEffectiveAddressFromModRm
            mov B$edi ' ' | inc edi | jmp L3>
L2: call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
L3: call WriteSignedImm8
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r32_r16__rm32_rm16_OrNone__SignedImm16_32:
    On B$OperandSizeOverride = &TRUE, mov W$DisSizeMarker 'W$'
    movzx ebx B$esi | inc esi
    call WritedWordRegsFromRegBits | mov B$edi ' ' | inc edi
    Test bl 00_11_000_000 | jz L2>
        RegMask bl to al | RmMask bl to cl | ;on al = cl jmp L3>
            call WriteEffectiveAddressFromModRm
            mov B$edi ' ' | inc edi | jmp L3>
L2: call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
L3: If B$OperandSizeOverride = &TRUE
        call WriteSignedImm16
    Else
        call WriteSignedImm32
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Dis_rm8_1:
    mov W$DisSizeMarker 'B$' | jmp Dis_rm32_1
Dis_rm16_1:
    mov W$DisSizeMarker 'W$'
Dis_rm32_1:
  ;  movzx ebx B$esi | inc esi
    call WriteEffectiveAddressFromModRm | mov W$edi ' 1' | add edi 2
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm8:
    mov W$DisSizeMarker 'B$'
    movzx ebx B$esi | inc esi
    call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm8_dx:
    mov W$DisSizeMarker 'B$' | jmp L1>
Dis_rm32_rm16__dx:
    On B$OperandSizeOverride = &TRUE, mov W$DisSizeMarker 'W$'
L1: movzx ebx B$esi | inc esi
    call WriteEffectiveAddressFromModRm | mov D$edi ' dx ' | add edi 3
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_dx_rm8:
    mov W$DisSizeMarker 'B$' | jmp L1>
Dis_dx__rm32_rm16:
    On B$OperandSizeOverride = &TRUE, mov W$DisSizeMarker 'W$'
L1: mov D$edi ' dx ' | add edi 3
    movzx ebx B$esi | inc esi
    call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_rm16__1:
    If B$OperandSizeOverride = &FALSE
        jmp Dis_rm32_1
    Else
        jmp Dis_rm16_1
    End_If

Dis_rm8_cl:
    mov W$DisSizeMarker 'B$' | jmp Dis_rm32_cl
Dis_rm16_cl:
    mov W$DisSizeMarker 'W$'
Dis_rm32_cl:
   ; movzx ebx B$esi | inc esi
    call WriteEffectiveAddressFromModRm | mov D$edi ' cl ' | add edi 3
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_rm16:
    On B$OperandSizeOverride = &TRUE, mov W$DisSizeMarker 'W$'
    call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_rm16__cl:
    If B$OperandSizeOverride = &FALSE
        jmp Dis_rm32_cl
    Else
        jmp Dis_rm16_cl
    End_If

;Dis_rm16_imm8:
;    mov W$DisSizeMarker 'W$'
;    movzx ebx B$esi | inc esi
;    call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
;    call WriteImm8
;    mov B$DisFlag DISDONE+DISLINEOVER
;ret

Dis_rm16_Sreg:
    mov W$DisSizeMarker 'W$'
    movzx ebx B$esi | inc esi
    push ebx
        call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WriteSregsFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_Sreg:
    mov W$DisSizeMarker 'D$'
    movzx ebx B$esi | inc esi
    push ebx
        call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WriteSregsFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Dis_Sreg_rm16:
    mov W$DisSizeMarker 'W$'
    movzx ebx B$esi | inc esi
    call WriteSregsFromModRm | mov B$edi ' ' | inc edi
    call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_Sreg_rm32:
    mov W$DisSizeMarker 'D$'
    movzx ebx B$esi | inc esi
    call WriteSregsFromModRm | mov B$edi ' ' | inc edi
    call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm8_imm8:
    mov W$DisSizeMarker 'B$'
    call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    call WriteImm8
    mov B$DisFlag DISDONE+DISLINEOVER

ret

Dis_Imm8:
    call WriteSignedImm8
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_imm32_16:
    If B$OperandSizeOverride = &FALSE
        call WriteImm32
    Else
        call WriteImm16
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_rm16__imm32_imm16:
    On B$OperandSizeOverride = &TRUE, mov W$DisSizeMarker 'W$'
    call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    If B$OperandSizeOverride = &FALSE
        call WriteImm32
    Else
        call WriteImm16
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_rm16__imm8:
    On  B$OperandSizeOverride = &TRUE, mov W$DisSizeMarker 'W$'
    call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    call WriteSignedImm8
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r32_r16__rm8:
    On B$OperandSizeOverride = &TRUE, jmp Dis_r16_rm8
Dis_r32_rm8:
    mov bl B$esi | inc esi
    call WriteEregsFromRegBits | mov B$edi ' ' | inc edi
    mov W$DisSizeMarker 'B$' | call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r16_rm8:
    mov bl B$esi | inc esi
    call WriteWordregsFromRegBits | mov B$edi ' ' | inc edi
    mov W$DisSizeMarker 'B$' | call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r32_rm16:
    mov bl B$esi | inc esi
    call WriteEregsFromRegBits | mov B$edi ' ' | inc edi
    mov W$DisSizeMarker 'W$' | call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r32_xmmx:
    On B$OperandSizeOverride = &FALSE, jmp Dis_r32_mmx
Dis_r32_xmm:
    mov bl B$esi | inc esi
    call WriteEregsFromRegBits | mov B$edi ' ' | inc edi
    call WriteXmmRegsFromRmBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r32_mmx:
    mov bl B$esi | inc esi
    call WriteEregsFromRegBits | mov B$edi ' ' | inc edi
    call WriteMMXRegsFromRmBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

; Some encodings like MOVMSKPD are in the form: 11 r32 mm
; Some like PMOVMSKB are: 11 mm r32.
; This 'Rev'ersed  form is for this second case:

; Was wronbg Doce of Intel-2001. Correct in Intel-2004
;;
Dis_r32_xmmx_Rev:
    On B$OperandSizeOverride = &FALSE, jmp Dis_r32_mmx_Rev
Dis_r32_xmmRev:
    mov bl B$esi | inc esi
    call WriteEregsFromRmBits | mov B$edi ' ' | inc edi
    call WriteXmmRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_r32_mmx_Rev:
    mov bl B$esi | inc esi
    call WriteEregsFromRmBits | mov B$edi ' ' | inc edi
    call WriteMMXRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret
;;

Dis_r32_xmmx_imm8:
    On B$OperandSizeOverride = &FALSE, jmp Dis_r32_mmx_imm8
Dis_r32_xmm_imm8:
    mov bl B$esi | inc esi
    call WriteEregsFromRmBits | mov B$edi ' ' | inc edi
    call WriteXmmRegsFromRegBits | jmp L9>

Dis_r32_mmx_imm8:
    mov bl B$esi | inc esi
    call WriteEregsFromRmBits | mov B$edi ' ' | inc edi
    call WriteMMXRegsFromRegBits
L9: mov B$edi ' ' | inc edi | call Writeimm8
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmmx_r32_imm8:
    On B$OperandSizeOverride = &FALSE, jmp Dis_r32_mmx_imm8
Dis_xmm_r32_imm8:
    mov bl B$esi | inc esi
    call WriteXmmRegsFromRmBits | mov B$edi ' ' | inc edi
    call WriteEregsFromRegBits | jmp L9>

Dis_mmx_r32_imm8:
    mov bl B$esi | inc esi
    call WriteMMXRegsFromRmBits | mov B$edi ' ' | inc edi
    call WriteEregsFromRegBits
L9: mov B$edi ' ' | inc edi | call Writeimm8
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_PINSRW:
    mov W$DisSizeMarker 'D$'
    mov bl B$esi | inc esi

    On B$OperandSizeOverride = &FALSE, jmp L2>

    call WriteXmmRegsFromRegBits | mov B$edi ' ' | inc edi
    push edi ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        call WriteEffectiveAddressFromModRm | jmp L9>

L2:     call WriteMMXRegsFromRegBits | mov B$edi ' ' | inc edi
    push edi ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        call WriteEffectiveAddressFromModRm

L9:     mov B$edi ' ' | inc edi | call Writeimm8
    pop eax ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    On B$eax = 'D', mov B$eax 'W' ; <<<<<<<<<< Old EDI.
    mov B$DisFlag DISDONE+DISLINEOVER
ret


Dis_r32__xmm_m64:
    mov bl B$esi | inc esi
    call WriteEregsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.X.XMMmem
ret

Dis_r32__xmm_m32:
    mov bl B$esi | inc esi
    call WriteEregsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.X.XMMmem
ret

Dis_xmm1__xmm2_m128:
    mov bl B$esi | inc esi
    call WriteXMMRegsFromRegBits | mov B$edi ' ' | inc edi
    ModMask bl to al
    If al = 3
        call WriteXMMRegsFromRmBits
    Else
        call EndWith.X.XMMmem
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_mm1__mm2_m128:
    mov bl B$esi | inc esi
    call WriteMMXRegsFromRegBits | mov B$edi ' ' | inc edi
    ModMask bl to al
    If al = 3
        call WriteMMXRegsFromRmBits
    Else
        call EndWith.Q.mem
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmm1__xmm2_m128__imm8:
    call Dis_xmm1__xmm2_m128 | mov B$edi ' ' | inc edi
    call WriteImm8
ret

Dis_xmm2_m128__xmm1:
    mov W$DisSizeMarker 'X$'
    mov bl B$esi | inc esi
    push ebx
        call WriteEffectiveXMMAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WriteXMMRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmm1__xmm2_m64:
    mov bl B$esi | inc esi
    call WriteXMMRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.X.XMMmem
ret

Dis_xmm1__xmm2_m32:
    mov bl B$esi | inc esi
    call WriteXMMRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.X.XMMmem
ret

Dis_xmm1__xmm2_m32F:
    mov bl B$esi | inc esi
    call WriteXMMRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.F.mem
ret

Dis_mmx_rm32:
    mov bl B$esi | inc esi
    call WriteMMXRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.D.mem
ret

Dis_xmm_rm32:
    mov bl B$esi | inc esi
    call WriteXMMRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.D.mem
ret

Dis_rm32_xmmx:
    On B$OperandSizeOverride = &TRUE, jmp Dis_rm32_xmm
Dis_rm32_mmx:
    mov bl B$esi | inc esi
    mov W$DisSizeMarker 'D$'
    push ebx
        call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WriteMMXRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_rm32_xmm:
    mov bl B$esi | inc esi
    mov W$DisSizeMarker 'D$'
    push ebx
        call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WriteXMMRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_mmx1__xmm2_m128:
    mov bl B$esi | inc esi
    call WriteMMXRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.X.XMMmem
ret

Dis_mmx1__xmm2_m64:
    mov bl B$esi | inc esi
    call WriteMMXRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.X.XMMmem
ret

Dis_xmm2_m64__xmm1:
    mov bl B$esi | inc esi
    mov W$DisSizeMarker 'X$'
    push ebx
        call WriteEffectiveXMMAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WriteXMMRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmm2_m32__xmm1:
    mov bl B$esi | inc esi
    mov W$DisSizeMarker 'D$'
    push ebx
        call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WriteXMMRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmm2_m32F__xmm1:
    mov bl B$esi | inc esi
    mov W$DisSizeMarker 'F$'
    push ebx
        call WriteEffectiveAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WriteXMMRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_mmx1__mmx2_m64:
    mov bl B$esi | inc esi
    call WriteMMXRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.Q.MMXmem

Dis_mmx1__mmx2_m64_v2: ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Looki
    mov bl B$esi | inc esi | inc esi
    call WriteMMXRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.Q.MMXmem

Dis_xmmx1__xmmx2_m64_128:
    If B$OperandSizeOverride = &TRUE
        jmp Dis_xmm1__xmm2_m128
    Else
        jmp Dis_mmx1__mmx2_m64
    End_If

Dis_xmm1__xmm_m128:
    mov bl B$esi | inc esi
    call WriteXMMRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.X.XMMmem

Dis_mmx1__mmx2_m128:
    mov bl B$esi | inc esi
    call WriteMMXRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.X.MMXmem

Dis_mmx_xmm:
    mov bl B$esi | inc esi
    RegMask bl to al
    mov D$edi 'MMX0', B$edi+4 ' ' | add B$edi+3 al | add edi 5
    BaseMask bl to al
    mov D$edi 'XMM0', B$edi+4 ' ' | add B$edi+3 al | add edi 4
ret

Dis_xmm_mmx:
    mov bl B$esi | inc esi
    RegMask bl to al
    mov D$edi 'XMM0', B$edi+4 ' ' | add B$edi+3 al | add edi 5
    BaseMask bl to al
    mov D$edi 'MM0 ' | add B$edi+2 al | add edi 3
ret

Dis_xmm1__mmx2_m64:
Dis_xmm1__mmx2_m128:
    mov bl B$esi | inc esi
    call WriteXMMRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.X.XMMmem
ret

Dis_mmx2_m128__xmm1:
    mov bl B$esi | inc esi
    mov W$DisSizeMarker 'X$'
    push ebx
        call WriteEffectiveXMMAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WriteXMMRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_mmx1_m64__mmx2:
    mov bl B$esi | inc esi
    mov W$DisSizeMarker 'Q$'
    push ebx
        call WriteEffectiveMMXAddressFromModRm | mov B$edi ' ' | inc edi
    pop ebx
    call WriteMMXRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmm1__rm32:
    mov bl B$esi | inc esi
    call WriteXMMRegsFromRegBits | mov B$edi ' ' | inc edi | jmp EndWith.D.mem
ret

Dis_xmmx_imm8:
    On B$OperandSizeOverride = &FALSE, jmp Dis_mmx_imm8

Dis_xmm_imm8:
   ; mov bl B$esi | inc esi
    call WriteXMMRegsFromRmBits | mov B$edi ' ' | inc edi
    call WriteImm8
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_mmx_imm8:
   ; mov bl B$esi | inc esi
    call WriteMMXRegsFromRmBits | mov B$edi ' ' | inc edi
    call WriteImm8
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_m64:
    mov W$DisSizeMarker 'Q$'
    call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_m32_16:
    On B$OperandSizeOverride = &TRUE, mov W$DisSizeMarker 'W$'
    call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_m8:
    mov W$DisSizeMarker 'B$'
    call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret


WritePacketCondition:
    mov B$edi ' ' | inc edi | lodsb | and eax 0FF

    push eax
        call WriteEax
    pop eax

    mov D$edi ' ; (' | add edi 4

    If al = 0
        mov D$edi 'EQ) ' | add edi 3
    Else_If al = 1
        mov D$edi 'LT) ' | add edi 3
    Else_If al = 2
        mov D$edi 'LE) ' | add edi 3
    Else_If al = 3
        mov D$edi 'UNOR', W$edi 'D)' | add edi 6
    Else_If al = 4
        mov D$edi 'NEQ)' | add edi 4
    Else_If al = 5
        mov D$edi 'NLT)' | add edi 4
    Else_If al = 6
        mov D$edi 'NLE)' | add edi 4
    Else_If al = 7
        mov D$edi 'ORD)' | add edi 4
    Else
        add D$UnlikelyCode 5
    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret


EndWith.B.mem:
    mov W$DisSizeMarker 'B$' | jmp EndWithModRm
ret

EndWith.W.mem:
    mov W$DisSizeMarker 'W$'
EndWith.D.mem:
EndWithModRm:
    call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

EndWith.WD.mem:
    On B$OperandSizeOverride = &TRUE, jmp EndWith.W.mem
    call WriteEffectiveAddressFromModRm
    mov B$DisFlag DISDONE+DISLINEOVER
ret

EndWith.Q.mem:
    mov W$DisSizeMarker 'Q$' | jmp EndWithModRm
ret

EndWith.F.mem:
    mov W$DisSizeMarker 'F$' | jmp EndWithModRm
ret

EndWith.R.mem:
    mov W$DisSizeMarker 'R$' | jmp EndWithModRm
ret

EndWith.T.mem:
    mov W$DisSizeMarker 'T$' | jmp EndWithModRm
ret

EndWith.X.mem:
    mov W$DisSizeMarker 'X$' | jmp EndWithModRm
ret

EndWith.X.XMMmem:
EndWith.X.MMXmem:
    mov W$DisSizeMarker 'X$'
    ModMask bl to al
    If al = 3
        call WriteXMMregsFromRmBits
    Else
        call EndWithModRm
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret

EndWith.Q.MMXmem:
    mov W$DisSizeMarker 'Q$'
    ModMask bl to al
    If al = 3
        call WriteMMXregsFromRmBits
    Else
        call EndWithModRm
    End_If
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmmx1_xmmx2:
    On B$OperandSizeOverride = &TRUE, jmp Dis_xmm1_xmm2

Dis_mmx1_mmx2:
    call WriteMMXRegsFromRegBits | mov B$edi ' ' | inc edi
    call WriteMMXRegsFromRmBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmm1_xmm2:
    call WriteXMMRegsFromRegBits | mov B$edi ' ' | inc edi
    call WriteXMMRegsFromRmBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_xmm_m64:
    call WriteXMMRegsFromRegBits | mov B$edi ' ' | inc edi
    mov W$DisSizeMarker 'X$' | jmp EndWithModRm
ret

Dis_m64_xmm:
    mov W$DisSizeMarker 'X$' | call WriteEffectiveAddressFromModRm
    mov B$edi ' ' | inc edi
    call WriteXMMRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_m64_mmx:
    mov W$DisSizeMarker 'Q$' | call WriteEffectiveAddressFromModRm
    mov B$edi ' ' | inc edi
    call WriteMMXRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

Dis_m128_xmm:
    mov W$DisSizeMarker 'X$' | call WriteEffectiveAddressFromModRm
    mov B$edi ' ' | inc edi
    call WriteXMMRegsFromRegBits
    mov B$DisFlag DISDONE+DISLINEOVER
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; Now come the terminal writing Routines.
____________________________________________________________________________________________
____________________________________________________________________________________________


[NextDisLine | push eax | mov eax 020200A0D | stosd | mov eax '    ' | stosw | pop eax]

[DisFlag: ?    SegmentOverride: ?
 OperandSizeOverride: ?    AddressSizeOverride: ?
 EscapePrefix: ?]

[DISDONE 1    DISLINEOVER 2    DISFAILED 0]

; Reads a Byte, returns the Hexa in ax. If The Hexa is greater than '0F', writes the
; wanted leading '0'.

[HexaTable: '0123456789ABCDEF']

OpToHexa:
    movzx eax B$esi | inc esi
LoadedOpToHexa:             ; If the Byte has already been loaded for some caller test.
    mov ebx eax | shr ebx 4
    and eax 0F | and ebx 0F
    mov al B$HexaTable+eax, bl B$HexaTable+ebx
    If ebx > '0'
        mov B$edi '0' | inc edi
    End_If
    shl eax 8 | or eax ebx
ret


[ModMask | mov #3 #1 | and #3 0011_000_000 | shr #3 6]
[DigitMask | mov #3 #1 | and #3 00_111_000 | shr #3 3]
[RegMask   | mov #3 #1 | and #3 00_111_000 | shr #3 3]
[RmMask    | mov #3 #1 | and #3 00_000_111]

[ScaleMask | mov #3 #1 | and #3 00_11_000_000 | shr #3 6]
[IndexMask | mov #3 #1 | and #3 00_111_000 | shr #3 3]
[BaseMask  | mov #3 #1 | and #3 00_000_111]
;;
 'DisSizeMarker' is set to 'D$' by default. If a 066 OpCode is encouneted, 'DisSizeMarker'
 is set to 'W$' at that time. So, All the OpCode Routines have the overwrite this Marker
 only in case of Bytes (which is always specific to one given OpCode).
;;
[DisSizeMarker: ?]


[dWordRegsTable: 'eax ecx edx ebx esp ebp esi edi '
 WordRegsTable:  'ax  cx  dx  bx  sp  bp  si  di  '
 ByteRegsTable:  'al  cl  dl  bl  ah  ch  dh  bh  '
 SregsTable:     'es  cs  ss  ds  fs  gs          ']

WriteEregsFromRmBits:
    RmMask bl To al | and eax 0FF
    move D$edi D$dWordRegsTable+eax*4 | add edi 3
ret

WriteEregsFromRegBits:
    RegMask bl To al | and eax 0FF
    move D$edi D$dWordRegsTable+eax*4 | add edi 3
ret

WritedWordRegsFromRegBits:
    On B$OperandSizeOverride = &TRUE, jmp WriteWordRegsFromRegBits
    RegMask bl To al | and eax 0FF
    move D$edi D$dWordRegsTable+eax*4 | add edi 3
Ret

WriteSregsFromModRm:
    RegMask bl To al | and eax 0FF
    move D$edi D$SregsTable+eax*4 | add edi 2  ; 0010001110 08C 00111
ret

WriteWordRegsFromRegBits:
    RegMask bl To al | and eax 0FF
    move D$edi D$WordRegsTable+eax*4 | add edi 2

Ret

WriteMMXRegsFromRegBits:
    RegMask bl To al
    mov D$edi 'MM0 ' | add B$edi+2 al | add edi 3
Ret

WriteMMXRegsFromRmBits:
    RmMask bl To al
    mov D$edi 'MM0 ' | add B$edi+2 al | add edi 3
Ret

WriteXMMRegsFromRegBits:
    RegMask bl To al
    mov D$edi 'XMM0' | add B$edi+3 al | add edi 4
Ret

WriteXMMRegsFromRmBits:
    RmMask bl To al
    mov D$edi 'XMM0' | add B$edi+3 al | add edi 4
Ret

WriteWordRegsFromRmBits:
    RmMask bl To al | and eax 0FF
    move D$edi D$WordRegsTable+eax*4 | add edi 2
ret

WriteByteRegsFromRmBits:
    RmMask bl To al | and eax 0FF
    move D$edi D$ByteRegsTable+eax*4 | add edi 2
ret

WriteByteRegsFromRegBits:
    RegMask bl To al | and eax 0FF
    move D$edi D$ByteRegsTable+eax*4 | add edi 2
ret


; Writes, for example: 'D$', 'CS:B$cs:', ...
StartEffectiveAddress:
    move W$edi W$DisSizeMarker | add edi 2

    If D$SegmentOverride <> 0
        move D$edi D$SegmentOverride | add edi 3
    End_If
ret


WriteFromSib: ; 085  00_10_000_101
    ModMask bl To cl                                ; Saves the MOD Bits for Base5 case.
    lodsb | mov bl al | BaseMask bl To al ; 025 00_00_100_101

    If al = 0      | mov D$edi 'eax+' | add edi 4
    Else_If al = 1 | mov D$edi 'ecx+' | add edi 4
    Else_If al = 2 | mov D$edi 'edx+' | add edi 4
    Else_If al = 3 | mov D$edi 'ebx+' | add edi 4
    Else_If al = 4 | mov D$edi 'esp+' | add edi 4
    Else_If al = 5 | call Base5                     ; No Base or ebp with dis 8 or 32
    Else_If al = 6 | mov D$edi 'esi+' | add edi 4
    Else           | mov D$edi 'edi+' | add edi 4
    End_If

    IndexMask bl To al

    .If al = 0      | mov D$edi 'eax ' | add edi 3
    .Else_If al = 1 | mov D$edi 'ecx ' | add edi 3
    .Else_If al = 2 | mov D$edi 'edx ' | add edi 3
    .Else_If al = 3 | mov D$edi 'ebx ' | add edi 3
    .Else_If al = 4
        If cl = 0FF
          ; Example: cmp ah B$078
            On W$DisSizeMarker <> 'D$', inc D$UnlikelyCode
        End_If
        On B$edi-1 = '+', dec edi             ; None / Strip the '+'
        jmp L9>
    .Else_If al = 5 | mov D$edi 'ebp ' | add edi 3
    .Else_If al = 6 | mov D$edi 'esi ' | add edi 3
    .Else           | mov D$edi 'edi ' | add edi 3
    .End_If

    ScaleMask bl To al

    If al = 0                                       ; no need *1
    Else_If al = 1 | mov W$edi '*2' | add edi 2
    Else_If al = 2 | mov W$edi '*4' | add edi 2
    Else_If al = 3 | mov W$edi '*8' | add edi 2
    End_If
L9: ret


Base5:          ; No Base or ebp with dis 8 or 32 (cl is the MOD bits from previous ModRm).
    If cl <> 0
        mov D$edi 'ebp+' | add edi 4
    Else
        mov cl 0FF
    End_If
ret


[ToJumpsTable: ?] ; Might now be removed entirely.

WriteBase5dis32:
    If B$edi-1 <> '+'
        mov B$edi '+' | inc edi
    End_If

WriteDis32:
    If B$AddressSizeOverride = &FALSE
        lodsd
    Else
WriteDis16:
        lodsw | and eax 0FFFF | call WriteEax | ret
    End_If

WriteDisRelative:
    mov D$LastCodeRef eax | On eax = 0, jmp L8>>

L0: If B$SimpleScan = &TRUE
        mov B$DisFlag DISDONE+DISLINEOVER | ret
    End_If

L0: On B$WeAreInTheCodeBox = &TRUE, jmp L8>>
;On eax = 01013E38, int3
    sub eax D$DisImageBase | add eax D$SectionsMap

    On eax >= D$EndOfSectionsMap, jmp L8>>
    On eax <= D$SectionsMap, jmp L8>>

    mov B$ToJumpsTable &FALSE
    mov al B$eax | and al DATAFLAG+VIRTUALFLAG+IMPORTFLAG+CODEFLAG
;map
    ..If al = 0
        mov eax D$LastCodeRef

        mov ebx eax | sub ebx D$DisImageBase | add ebx D$SizesMap

            .If B$LeaInstruction = &TRUE
                mov B$LeaInstruction &FALSE
                sub ebx D$SizesMap | add ebx D$SectionsMap | mov B$ebx DATAFLAG
            .Else_If W$edi-2 = 'B$'
                or B$ebx BYTE
                sub ebx D$SizesMap | add ebx D$SectionsMap | mov B$ebx DATAFLAG
            .Else_If W$edi-2 = 'W$'
                or B$ebx WORD
                sub ebx D$SizesMap | add ebx D$SectionsMap
                mov B$ebx DATAFLAG, B$ebx+1 DATAFLAG
            .Else_If W$edi-2 = 'D$'
                or B$ebx DWORD
                sub ebx D$SizesMap | add ebx D$SectionsMap
                mov D$ebx FOURDATAFLAGS
            .Else_If W$edi-2 = 'F$'
                or B$ebx FP4
                sub ebx D$SizesMap | add ebx D$SectionsMap
                mov D$ebx FOURDATAFLAGS
            .Else_If W$edi-2 = 'R$'
                or B$ebx FP8
                sub ebx D$SizesMap | add ebx D$SectionsMap
                mov D$ebx FOURDATAFLAGS, D$ebx+4 FOURDATAFLAGS
            .Else_If W$edi-2 = 'T$'
                or B$ebx FP10
                sub ebx D$SizesMap | add ebx D$SectionsMap
                mov D$ebx FOURDATAFLAGS, D$ebx+4 FOURDATAFLAGS, D$ebx+6 FOURDATAFLAGS
            .Else
                jmp L8>>
               ; or B$ebx POINTER
            .End_If

    ..Else_If al = DATAFLAG
        mov eax D$LastCodeRef | call StoreDisSize
        sub eax D$DisImageBase | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        mov D$edi 'Data' | add edi 4 | jmp L8>>

    ..Else_If al = CODEFLAG
      ; Is it a call to a Jumps Table?
        mov eax D$LastCodeRef
        sub eax D$DisImageBase | add eax D$UserPeStart

        If W$eax = 025FF ; Code of jmp relative long
            mov ebx D$eax+2 | sub ebx D$DisImageBase | add ebx D$SectionsMap
            On ebx > D$EndOfSectionsMap, jmp L1>
            On ebx < D$SectionsMap, jmp L1>
                On B$ebx <> IMPORTFLAG, jmp L1>

                    mov B$ApiCommentWanted &TRUE, ebx D$eax+2, D$PtrToApiName ebx
        End_If

L1:     mov eax D$LastCodeRef
        sub eax D$DisImageBase | add eax D$RoutingMap
        test B$eax INSTRUCTION | jz L8>>
        or B$eax NODE+LABEL | mov D$edi 'Code' | add edi 4 | jmp L8>>

    ..Else_If al = VIRTUALFLAG
        mov eax D$LastCodeRef | call StoreDisSize
        sub eax D$DisImageBase | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        mov D$edi 'Virt', D$edi+4 'ual ' | add edi 7 | jmp L8>>

    ..Else_If al = IMPORTFLAG
        mov ebx D$LastCodeRef
L5:     sub ebx D$DisImageBase | add ebx D$UserPeStart | mov ebx D$ebx
      ; May be a wrong pointing inside the .Import!
      ; Add a Pointer test!
        On ebx < D$ApiBuffer, ret
        On ebx >= D$EndOfApiBuffer, ret

        push esi

            On W$edi-2 = 'D$', sub edi 2

            mov esi ebx

            .If D$edi-4 = 'jmp '    ; Jumps Table?
                call WriteApiJmpTableLabel

                While B$esi <> 0 | movsb | End_While

            .Else_If D$edi-4 = 'all '  ; call api?
                call FlagNoReturnApi
                call FlagApiProcedures
                While B$esi <> 0 | movsb | End_While

            .Else_If D$edi-4 = '$cs:'
                sub edi 5 | jmp L6>

          ; Other case: Either "mov eax D$ApiCall" or "mov D$eax ApiCall"
            .Else
                push edi
                    mov al "'"
                    While B$edi > LF
                        dec edi
                        On B$edi = '$', mov al 0
                    End_While
                pop edi
L6:             mov esi ebx
                If al = 0
                    While B$esi <> '.' | inc esi | End_While | inc esi
                End_If
                While B$esi <> 0 | movsb | End_While
                On al = 0, dec edi

            .End_If
        pop esi

     ..End_If
ret

L8: On B$WeAreInTheCodeBox = &FALSE, jmp L8>
    On D$LibFileMemory = 0, jmp L8>
        push esi
            mov esi D$LastCodeRef
            .If esi > D$LibFileMemory
                mov eax D$LibFileMemory | add eax D$LibFileLength
                If esi < eax
                    While B$esi <> 0 | movsb | End_While
                   ; mov D$edi ' ; <', D$edi+4 '<<<<' | add edi 8
                Else
                    pop esi | jmp L8>
                End_If
            .Else
                pop esi | jmp L8>
            .End_If
        pop esi
        ret

L8: ;On D$LastCodeRef = 0438E28, int3

    .If B$edi-1 = '+'
        If W$edi-3 = '*2'
            call TryWithIndice 2
        Else_If W$edi-3 = '*4'
            call TryWithIndice 4
        Else_If W$edi-3 = '*8'
            call TryWithIndice 8
        End_If
    .End_If

    If W$DisplacementFromLabel = 0
        mov eax D$LastCodeRef | sub eax D$DisImageBase | add eax D$SizesMap
        mov ebx D$SizesMap | add ebx 4
        On eax < ebx, jmp L8>
        On eax > D$EndOfSizesMap, jmp L8>
        test B$eax-4 FP8 | jz L8>
            sub D$LastCodeRef 4 | mov W$DisplacementFromLabel '+4'
    End_If

L8: push 0-1

    mov ebx D$LastCodeRef

L0: mov eax ebx | shr ebx 4 | and eax 0F
    add eax '0' | On eax > '9', add eax 7
    push eax
    cmp ebx 0 | ja L0<

    mov B$edi '0' | inc edi
L0: pop eax | cmp eax 0-1 | je L9>
    mov B$edi al | inc edi | jmp L0<

L9: mov ebx D$LastCodeRef | sub ebx D$DisImageBase | add ebx D$UserPeStart

    ..If ebx > D$UserPeStart
        .If ebx < D$UserPeEnd
            mov ebx D$LastCodeRef | ToStringsMapFrom DisImageBase, ebx
            If D$ebx <> 0
                push esi
                ;On D$LastCodeRef = 04037EC, showme D$ebx
                    zCopy D$ebx
                pop esi
            End_If
        .End_If
    ..End_If

    If W$DisplacementFromLabel <> 0
        mov ax W$DisplacementFromLabel | stosw
        mov W$DisplacementFromLabel 0
    End_If

    mov eax D$LastCodeRef | sub eax D$DisImageBase | add eax D$SectionsMap

    .If eax < D$SectionsMap
        ;
    .Else_If eax < D$EndOfSectionsMap
        If B$eax = DATAFLAG
            sub eax D$SectionsMap | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        End_If
    .End_If

    On B$ApiCommentWanted = &TRUE, call WriteApiLabelComment
ret


[DisplacementFromLabel: ?]

Proc TryWithIndice:
    Argument @Indice

        mov eax D$LastCodeRef | add eax D@Indice
        sub eax D$DisImageBase | add eax D$SectionsMap

        ..If eax < D$SectionsMap
            ;
        ..Else_If eax < D$EndOfSectionsMap
            .If B$eax = DATAFLAG
                sub eax D$SectionsMap | add eax D$RoutingMap
                test B$eax LABEL+EVOCATED | jz L9>
                    mov eax D@Indice | add D$LastCodeRef eax
                    If eax = 2
                        mov W$DisplacementFromLabel '-2'
                    Else_If eax = 4
                        mov W$DisplacementFromLabel '-4'
                    Else_If eax = 8
                        mov W$DisplacementFromLabel '-8'
                    End_If

                    mov D$edi 'Data' | add edi 4
            .End_If
        ..End_If
L9:
EndP
____________________________________________________________________________________________

WriteApiLabel:
    While B$esi <> 0
        lodsb
;;
  ; No need as long as they are all Comments, now:
        If al = '$'
            mov al 'S'
        Else_If al = '$'
            mov al 'S'
        Else_If al = '@'
            mov al 'a'
        End_If
;;
        stosb
    End_While
ret

[ApiCommentWanted: ? PtrToApiName: ?]

WriteApiLabelComment:
    push esi
        mov B$ApiCommentWanted &FALSE

        mov D$edi ' ; ' | add edi 3
        mov esi D$PtrToApiName
        sub esi D$DisImageBase | add esi D$UserPeStart
        mov esi D$esi
        push esi
            call WriteApiLabel
        pop esi
        call FlagApiProcedures
    pop esi
ret


WriteApiJmpTableLabel:
    While B$edi-1 > LF | dec edi | End_While

    push esi
        mov W$edi '; ' | add edi 2

        mov esi ebx | inc esi

        call WriteApiLabel
    pop esi

    mov B$edi-1 ':' | NextDisLine
    mov D$edi 'jmp ' | add edi 4
ret
____________________________________________________________________________________________

FlagNoReturnApi:
    push esi
        inc esi
;;
      ; MSVBVM50.064 ???
        ...If D$esi = 'MSVB'
            ..If D$esi+4 = 'VM50'
                .If D$esi+8 = '.064'
                    If B$esi+12 = "'"
                        mov B$DisEndOfChunk &TRUE
                    End_If
                .End_If
            ..End_If
        ...End_If
;;
        While B$esi <> '.' | inc esi | End_While | inc esi

      ; ExitProcess
        ...If D$esi = 'Exit'
            ..If D$esi+4 = 'Proc'
                If D$esi+8 = "ess'"
                    mov B$DisEndOfChunk &TRUE
                End_If
            ..End_If

      ; __vbaErrorOverflow
        ...Else_If D$esi = '__vb'
            ..If D$esi+4 = 'aErr'
                .If D$esi+8 = 'orOv'
                    If D$esi+12 = 'erfl'
                        On W$esi+16 = 'ow', mov B$DisEndOfChunk &TRUE
                    End_If
                .End_If
            ..End_If

        ...Else
          ; For freezing the 'IsItNoReturnCall' test:
            mov B$CallInstruction &FALSE

        ...End_If
    pop esi
ret
____________________________________________________________________________________________

;;
  The 4 Dialogs Creations Functions:
  
        'USER32.CreateDialogParamA'         >>> second above push
        'USER32.CreateDialogindirectParamA' >>> second above push
        
        'USER32.DialogBoxParamA'            >>> second above push
        'USER32.DialogBoxindirectParamA'    >>> second above push

  The 'USER32.SetWindowLong' Function, with the "GWL_WNDPROC" Parameter
  GWL_WNDPROC >>> second above push
  Procedure >>> first above push

  The 'KERNEL32.CreateThread' Function.     >>> fourth above push

  The 'USER32.SetWindowsHookExA' Function.          >>> third above push
  
  List of Api with CallBacks:
  
    USER32.CreateDialogParamA
    USER32.CreateDialogindirectParamA
    USER32.DialogBoxParamA
    USER32.DialogBoxindirectParamA
    USER32.SetWindowLongA
    KERNEL32.CreateThread
    USER32.SetWindowsHookExA
    USER32.EnumChildWindows
;;

FlagApiProcedures:
    push esi

    While B$esi <> '.' | inc esi | End_While | inc esi

      ; ExitProcess
        ...If D$esi = 'Crea'
            ..If D$esi+4 = 'teDi'
                .If D$esi+8 = "alog"
                    If D$esi+12 = 'Para'
                      ; 'USER32.CreateDialogParamA'
                        call GetDialogProcedure

                    Else_If D$esi+12 = 'indi'
                      ; 'USER32.CreateDialogindirectParamA'
                        call GetDialogProcedure

                    End_If
                .End_If
            ..End_If

        ...Else_If D$esi = 'Dial'
            ..If D$esi+4 = 'ogBo'
                If D$esi+8 = 'xPar'
                  ; 'USER32.DialogBoxParamA'
                    call GetDialogProcedure

                Else_If D$esi+8 = 'indi'
                  ; 'USER32.DialogBoxindirectParamA'
                    call GetDialogProcedure

                End_If
            ..End_If

        ...Else_If D$esi = 'SetW'
            ..If D$esi+4 =  'indo'
                .If D$esi+8 = 'wLon'
                  ; 'USER32.SetWindowLongA'
                    call GetApiPush 2
                    If eax = &GWL_WNDPROC
                        call GetApiPush 3
                        On eax <> 0, call SetApiProcedure eax, WindowProcName
                    End_If
                .End_If
            ..End_If

        ...Else_If D$esi = 'Crea'
            ..If D$esi+4 = 'teTh'
                If D$esi+8 = 'read'
                  ; 'KERNEL32.CreateThread'
                    call GetApiPush 3
                    On eax <> 0, call SetApiProcedure eax, ThreadProcName
                End_If
            ..End_If

        ...Else_If D$esi = 'SetW'
            ..If D$esi+4 = 'indo'
                .If D$esi+8 = 'wsHo'
                    If D$esi+12 = 'okEx'
                      ; 'USER32.SetWindowsHookExA'
                        call GetApiPush 2
                        On eax <> 0, call SetApiProcedure eax, HookProcName
                    End_If
                .End_If
            ..End_If

        ...Else_If D$esi = 'Enum'
            ..If D$esi+4 = 'Chil'
                .If D$esi+8 = 'dWin'
                    If D$esi+12 = 'dows'
                      ; 'USER32.EnumChildWindows'
                        call GetApiPush 2
                        On eax <> 0, call SetApiProcedure eax, EnumChildWindowsProcName
                    End_If
                .End_If
            ..End_If

        ...Else_If D$esi = 'lstr'
            ..If D$esi+4 = 'cpyA'
              ; 'KERNEL32.lstrcpyA'
                call GetApiPush 1
                On eax <> 0, call SetApiData eax
                call GetApiPush 2
                On eax <> 0, call SetApiData eax
            ..End_If

        ...Else_If D$esi = 'Regi'
            ..If D$esi+4 = 'ster'
                .If D$esi+8 = 'Clas'
                    If D$esi+12 = 'sExA'
                      ; 'USER32.RegisterClassExA/W'
L1:                     call GetApiPush 1 | On eax = 0, jmp L9>
                        push eax
                            call SelectMainWindowProc eax, 12
                        pop eax
                        call SetWINDCLASSEXData eax

                    Else_If D$esi+12 = 'sExW'
                        jmp L1<

                    Else_If B$esi+12 = 's'
                      ; 'USER32.RegisterClassA/W'
                        call GetApiPush 1 | On eax = 0, jmp L9>
                        push eax
                            call SelectMainWindowProc eax, 10
                        pop eax
                        call SetWINDCLASSData eax
                    End_If

                .End_If
            ..End_If
        ...End_If
L9: pop esi
ret


[DisMainWindowProc: ?]

Proc SelectMainWindowProc:
    Argument @WNDCLASS, @N
    Uses edi, ebx, ecx

        mov eax D@WNDCLASS | sub eax D$DisImageBase | add eax D$UserPeStart

        mov eax D$eax+8

        ..If eax <> 0
            .If D$DisMainWindowProc = 0
                mov D$DisMainWindowProc eax
                call SetApiProcedure eax, MainWindowProcName

            .Else
              ; Several candidates: Take the one closer to 'Main':
                mov ebx D$DisMainWindowProc | sub ebx D$DisEntryPoint | Absolute ebx
                mov ecx eax | sub ecx D$DisEntryPoint | Absolute ecx
                If ecx < ebx
                    call SetApiProcedure D$DisMainWindowProc, WindowProcName
                    call SetApiProcedure eax, MainWindowProcName
                    mov D$DisMainWindowProc eax
                Else_If ecx > ebx
                    call SetApiProcedure eax, WindowProcName
                End_If
            .End_If
        ..End_If

        mov edi D@WNDCLASS | sub edi D$DisImageBase | add edi D$SectionsMap

        mov ecx D@N, eax FOURDATAFLAGS | rep stosd
EndP


[WNDCLASS.cbSize.Name: B$'_cbSize', 0

 WNDCLASS.style.Name: B$ '_style', 0
 WNDCLASS.lpfnWndProc.Name: '_lpfnWndProc', 0
 WNDCLASS.cbClsExtra.Name: '_cbClsExtra', 0
 WNDCLASS.cbWndExtra.Name: '_cbWndExtra', 0
 WNDCLASS.hInstance.Name: '_hInstance', 0
 WNDCLASS.hIcon.Name: '_hIcon', 0
 WNDCLASS.hCursor.Name: '_hCursor', 0
 WNDCLASS.hbrBackground.Name: '_hbrBackground', 0
 WNDCLASS.lpszMenuName.Name: '_lpszMenuName', 0
 WNDCLASS.lpszClassName.Name: '_lpszClassName', 0

 WNDCLASS.hIconSm.Name: B$'_hIconSm', 0]

Proc SetWINDCLASSData:
    Argument @Pointer
    Uses edi

        mov eax D@Pointer

        ToStringsMapFrom DisImageBase eax
        mov D$eax WNDCLASS.style.Name | add eax 16
        mov D$eax WNDCLASS.lpfnWndProc.Name | add eax 16
        mov D$eax WNDCLASS.cbClsExtra.Name | add eax 16
        mov D$eax WNDCLASS.cbWndExtra.Name | add eax 16
        mov D$eax WNDCLASS.hInstance.Name | add eax 16
        mov D$eax WNDCLASS.hIcon.Name | add eax 16
        mov D$eax WNDCLASS.hCursor.Name | add eax 16
        mov D$eax WNDCLASS.hbrBackground.Name | add eax 16
        mov D$eax WNDCLASS.lpszMenuName.Name | add eax 16
        mov D$eax WNDCLASS.lpszClassName.Name

        mov edi D@Pointer | sub edi D$DisImageBase | add edi D$RoutingMap
        mov eax LABEL, ecx 10 | rep stosd

        mov edi D@Pointer | sub edi D$DisImageBase | add edi D$SizesMap
        mov eax DWORD, ecx 10 | rep stosd
EndP


Proc SetWINDCLASSEXData:
    Argument @Pointer
    Uses edi

        mov eax D@Pointer | ToStringsMapFrom DisImageBase, eax

        mov D$eax WNDCLASS.cbSize.Name | add eax 16
        mov D$eax WNDCLASS.style.Name | add eax 16
        mov D$eax WNDCLASS.lpfnWndProc.Name | add eax 16
        mov D$eax WNDCLASS.cbClsExtra.Name | add eax 16
        mov D$eax WNDCLASS.cbWndExtra.Name | add eax 16
        mov D$eax WNDCLASS.hInstance.Name | add eax 16
        mov D$eax WNDCLASS.hIcon.Name | add eax 16
        mov D$eax WNDCLASS.hCursor.Name | add eax 16
        mov D$eax WNDCLASS.hbrBackground.Name | add eax 16
        mov D$eax WNDCLASS.lpszMenuName.Name | add eax 16
        mov D$eax WNDCLASS.lpszClassName.Name | add eax 16
        mov D$eax WNDCLASS.hIconSm.Name

        mov edi D@Pointer | sub edi D$DisImageBase | add edi D$RoutingMap
        mov eax LABEL+EVOCATED, ecx 12 | rep stosd

        mov edi D@Pointer | sub edi D$DisImageBase | add edi D$SizesMap
        mov eax DWORD, ecx 12 | rep stosd
EndP


Proc GetApiPush:
    Argument @Indice

        mov D$PossibleApiPointer 0

        mov esi D$TestLastLineLocation | On esi = 0, jmp L9>>

        dec esi | mov ebx esi | sub ebx D$UserPeStart | add ebx D$RoutingMap

L0:     movzx eax B$ebx
        test eax INSTRUCTION | jz L2>>
        test eax NODE+EXPORTNODE+PUSH_EBP | jnz L9>>

            mov al B$esi
          ; IsItPush    >>>>>>>>>   Op68 !!!!!!!!!!!
            .If al = 060 ; pushad
                jmp L9>>
            .Else_If al = 0FF ; OpFF // /6   ; 75
                DigitMask B$esi+1 To al
                If al = 6
                    mov eax &TRUE
                Else
                    mov eax &FALSE
                End_If

            .Else_If al = 06A
                mov eax &TRUE
            .Else_If al = 068
                mov eax &TRUE
            .Else_If al < 050
                mov eax &FALSE
            .Else_If al < 058
                mov eax &TRUE       ; push reg (050 to 057)
            .Else
                mov eax &FALSE
            .End_If

            ...If eax = &TRUE
                dec D@Indice

                ..If D@Indice = 0
                    If B$esi = 0FF ; OpFF, 035 = 00_110_101
                        add esi 2 | lodsd
                        cmp eax D$UserPeStart | jb L9>>
                        cmp eax D$UserPeEnd | ja L9>>
                            mov eax D$eax | ExitP

                    Else_If B$esi = 068 ; Op68
                        cmp B$esi-1 0F | je L9>  ; Op0F: Escape Prefix
                        cmp B$esi-1 066 | je L9>;   Op66 >>> Operand Size Override
                            inc esi | lodsd | ExitP
                    End_If

                ..End_If
            ...End_If

L2:     dec ebx | dec esi | jmp L0<<

L9:     mov eax 0
EndP


[PossibleApiPointer: ?  PossibleApiPointerIndice: ?]

Proc GetPossibleApiPointer:
    Argument @Pointer, @Indice

        mov eax D@Pointer

        sub eax D$DisImageBase | add eax D$UserPeStart | mov eax D$eax
      ; May be a wrong pointing inside the .Import!
      ; Add a Pointer test!
        If eax < D$ApiBuffer
            mov D$PossibleApiPointer 0
        Else_If eax >= D$EndOfApiBuffer
            mov D$PossibleApiPointer 0
        Else
            mov D$PossibleApiPointer eax
            mov eax D@Indice, D$PossibleApiPointerIndice eax
        End_If
EndP


GetDialogProcedure:
    call GetApiPush 4

    .If eax <> 0
        call SetApiProcedure eax, DialogProcName

    .Else_If D$PossibleApiPointer <> 0
;;
  There are case of:
  
        call 'KERNEL32.GetModuleHandleA'  ; FF 15 80 C1 43 00 
        push eax
        
        used inside the PUSHes flow, to set-up the 'hInstance' Member.
;;
        If D$PossibleApiPointerIndice = 3
            call GetApiPush 5
            On eax <> 0, call SetApiProcedure eax, DialogProcName
        End_If

    .End_If
ret


[MainWindowProcName: "MainWindowProc", 0

WindowProcName: '_WindowProc', 0
ThreadProcName: '_ThreadProc', 0
HookProcName: '_HookProc', 0
EnumChildWindowsProcName: '_EnumChildWindowsProc', 0
DialogProcName: '_DialogProc', 0]

Proc SetApiProcedure:
    Argument @Pointer, @Name
    Uses eax

        mov eax D@Pointer

        sub eax D$DisImageBase | add eax D$SectionsMap

        .If eax > D$SectionsMap
            If eax < D$EndOfSectionsMap
                mov B$eax CODEFLAG

                sub eax D$SectionsMap | add eax D$RoutingMap
                mov B$eax LABEL+NODE+EVOCATED+INSTRUCTION+ACCESSED

                ToStringsMapFrom RoutingMap, eax
                move D$eax D@Name
            End_If
        .End_If
EndP


Proc SetApiData:
    Argument @Pointer

        mov eax D@Pointer

        sub eax D$DisImageBase | add eax D$SectionsMap

        .If eax > D$SectionsMap
            If eax < D$EndOfSectionsMap
                mov B$eax DATAFLAG

                sub eax D$SectionsMap | add eax D$RoutingMap
                or B$eax LABEL+EVOCATED
            End_If
        .End_If

EndP


____________________________________________________________________________________________

; Storing the SizeOf the accessed element into 'SizesMap'. Before eax holds D$LastCodeRef.

StoreDisSize:
    mov ebx eax | sub ebx D$DisImageBase | add ebx D$SizesMap

    .If B$LeaInstruction = &TRUE
        or B$ebx POINTER | mov B$LeaInstruction &FALSE
    .Else_If W$edi-2 = 'B$'
        or B$ebx BYTE | call FlagData 1
    .Else_If W$edi-2 = 'W$'
        or B$ebx WORD | call FlagData 2
    .Else_If W$edi-2 = 'D$'
        or B$ebx DWORD | call FlagPointerToPointer| call FlagData 4
    .Else_If W$edi-2 = 'F$'
        or B$ebx FP4 | call FlagData 4
    .Else_If W$edi-2 = 'R$'
        or B$ebx FP8 | call FlagData 8
    .Else_If W$edi-2 = 'T$'
        or B$ebx FP10 | call FlagData 10
    .Else
        ;or B$ebx POINTER
        call FlagPointerToPointer
    .End_If
ret


Proc FlagData:
    Argument @N
    Uses edi, eax, ecx

        mov edi ebx | sub edi D$SizesMap | add edi D$SectionsMap
        On B$edi = VIRTUALFLAG, Exitp
        mov ecx D@N, al DATAFLAG | rep stosb
EndP


FlagPointerToPointer:
   push ebx
      ; If it is a Pointer to Pointer, LABEL the final Location:
        mov ebx eax | sub ebx D$DisImageBase | add ebx D$UserPeStart
      ; Here, eax still is 'D$LastCodeRef'
        ..If ebx < D$UserPeStart
            ;
        ..Else_If ebx < D$UserPeEnd
            sub ebx D$UserPeStart | add ebx D$RoutingMap | or B$ebx EVOCATED+LABEL

            sub ebx D$RoutingMap | add ebx D$UserPeStart
            mov ebx D$ebx | sub ebx D$DisImageBase | add ebx D$UserPeStart
            .If ebx < D$UserPeStart
                ;
            .Else_If ebx < D$UserPeEnd
                push eax
                    sub ebx D$UserPeStart | add ebx D$RoutingMap
                    mov eax ebx | sub eax D$RoutingMap | add eax D$SectionsMap
                    If B$eax = CODEFLAG
                        or B$ebx EVOCATED;+LABEL
                    Else
                        or B$ebx EVOCATED+LABEL
                    End_If
                pop eax
            .End_If

        ..End_If
    pop ebx
ret

____________________________________________________________________________________________

[DisShortRef: B$ ?    EncreasedLocalJmp: ?]

EndWithDisByteRelative:
    ;On B$esi = 0, add B$UnlikelyCode 5 ; Absurd, but really found in some Code.

    If B$SimpleScan = &TRUE
        inc esi | mov B$DisFlag DISDONE+DISLINEOVER | ret
    End_If

    mov B$EncreasedLocalJmp &FALSE
    movsx eax B$esi | inc esi | mov D$LastCodeRef eax
    call RelativeToAbsolute
    push eax
        call WriteLocalLabelFromEax
    pop eax
    If eax > D$LastCodeRef
        mov B$edi-1 '>'
    Else
        mov B$edi-1 '<'
    End_If

    On B$WeAreInTheCodeBox = &TRUE, ret
;jmp L7>>
  ; Is the short jump out of range because of the replacement of a DLL call Direct
  ; instead of Indirect?
    push esi, eax
        mov ecx 0
        mov al B$esi-1, bl al, B$DisShortRef al | and bl 00_1000_0000

      ; Negatif short?
        ..If bl = 00_1000_0000
            sub esi 3 | neg al
            .While al <> 0
                dec esi
              ; Code of Call Indirect (To Jumps Table?).
                .If B$esi = 0E8
                  ; Yes, but is it an Instruction ?
                    mov ebx esi | sub ebx D$UserPeStart | add ebx D$RoutingMap
                    test B$ebx INSTRUCTION | jz L1>
                  ; Relative to absolute:
                    mov ebx esi | add ebx D$esi+1 | add ebx 5
                    cmp ebx D$UserPeStart | jb L1>
                    cmp ebx D$UserPeEnd | ja L1>
                        If W$ebx = 025FF
                            mov ebx D$ebx+2
                            sub ebx D$DisImageBase | add ebx D$SectionsMap

                            On ebx > D$EndOfSectionsMap, jmp L1>
                            On ebx < D$SectionsMap, jmp L1>
                                On B$ebx = IMPORTFLAG, inc ecx
L1:                     End_If
                .End_If
                dec al
            .End_While

        ..Else
            .While al <> 0
              ; Code of Call Direct (To Jumps Table?).
                .If B$esi = 0E8
                  ; Yes, but is it an Instruction ?
                    mov ebx esi | sub ebx D$UserPeStart | add ebx D$RoutingMap
                    test B$ebx INSTRUCTION | jz L1>
                  ; Relative to absolute:
                    mov ebx esi | add ebx D$esi+1 | add ebx 5
                    cmp ebx D$UserPeStart | jb L1>
                    cmp ebx D$UserPeEnd | ja L1>
                        If W$ebx = 025FF  ; FF 25 XX XX XX XX > jmp D$xxxx
                            mov ebx D$ebx+2
                            sub ebx D$DisImageBase | add ebx D$SectionsMap
                            cmp ebx D$SectionsMap | jb L1>
                            cmp ebx D$EndOfSectionsMap | ja L1>
                                On B$ebx = IMPORTFLAG, inc ecx
L1:                     End_If
                .End_If
                dec al | inc esi
            .End_While

        ..End_If

L2:     .If ecx <> 0
            mov al B$DisShortRef
            If B$edi-1 = '>'
                add al cl | test al 00_1000_0000 | jz L5>
                mov B$edi '>' | inc edi
            Else
                sub al cl | test al 00_1000_0000 | jnz L5>
                mov B$edi '<' | inc edi
            End_If
            mov B$EncreasedLocalJmp &TRUE
        .End_If

L5: pop eax, esi
L7:
    mov D$edi '  ; ' | add edi 4

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;mov D$edi 'Code' | add edi 4
    call RelativeToAbsolute | mov D$LastCodeRef eax
    ;push eax
    ;    call WriteEax
    ;pop eax
    mov ebx D$LastCodeRef
    sub ebx D$DisImageBase | add ebx D$SectionsMap | mov B$ebx CODEFLAG
    call WriteDisRelative
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


    If B$EncreasedLocalJmp = &TRUE
        NextDisLine
        mov D$edi "; >>", D$edi+4 "> 'C", D$edi+8 "omme", D$edi+12 "nt1'"
        add edi 16
    End_If

    mov B$DisFlag DISDONE+DISLINEOVER
ret

; Same as upper, but, in cases of Data in code, a LOOP L2>, might be generated. Not
; that important, but what is important is that this could mess up the targeted Code
; when re-aligning because of Code reference.

EndWithDisByteRelativeBack:
    movsx eax B$esi | On eax < 3, add B$UnlikelyCode 5

    inc esi | mov D$LastCodeRef eax
    call RelativeToAbsolute
    push eax
        call WriteLocalLabelFromEax
    pop eax
    If eax > D$LastCodeRef
        mov D$edi-1 '> ; ', D$edi+3 '!!!!' | add edi 7
        mov D$LastCodeRef 0, B$DisFlag DISDONE+DISLINEOVER | ret
    Else
        mov B$edi-1 '<'
    End_If
    mov D$edi '  ; ' | add edi 4
    call RelativeToAbsolute | mov D$LastCodeRef eax
    call WriteDisRelative
    mov B$DisFlag DISDONE+DISLINEOVER
ret

EndWithDisWordDwordRelative:
    If B$OperandSizeOverride = &TRUE
        movsx eax W$esi | add esi 2
    Else
        lodsd
    End_If
    mov D$LastCodeRef eax
    call RelativeToAbsolute | call WriteDisRelative
    mov B$DisFlag DISDONE+DISLINEOVER
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

; This is the Chunks of Macros to be saved at Top of the Disassembly Source:

[DisMacros2: "____________________________________________________________________________________________

;;
  Used Macros Strings Variables:
  
    &1, &2, &3              Proc
    &9, &10 to &19          For
 
  Used Macros Counters Variables:
 
    &&0, &&1                If
    &&2, &&3                While
    &&4, &&5                Do
    &&6, &&7                For
    
  Local Labels Attributions:
  
    O1                      On
    P9                      Proc
    I0,... I9, J0,... J9    If
    W0,... W9               While
    D0,... D9               Do
    F0,... F9               For
;;
____________________________________________________________________________________________

[= e   < b    > a    <s l    >s g    =< be    <= be    => ae    >= ae    <> ne]
____________________________________________________________________________________________

; Multi push, pop, mov, move, inc, and dec  Macros:

[push | push #1 | #+1]
[pop | pop #1 | #+1]
[mov | mov #1 #2 | #+2]
[move | push #2 | pop #1 | #+2]
[inc | inc #1 | #+1]
[dec | dec #1 | #+1]
____________________________________________________________________________________________

[Exchange | push #1 | push #2 | pop #1 | pop #2 | #+2]
____________________________________________________________________________________________

[On | cmp #1 #3 | jn#2 O1> | #4>L | O1:]
____________________________________________________________________________________________

[call | #If #1=str
            ApiPush #L>2
        #Else
            push #L>2
        #End_If
        call #1]

[ApiPush | #If #1=str
                push {#1, 0}
           #Else
                push #1
           #End_If
           #+1]
____________________________________________________________________________________________

; C calling convention:

[ccall
    push #L>2 | call #1
    #If #N>1
        add esp ((#N-1)*4)
    #EndIf]
____________________________________________________________________________________________

[.If
    #If &&0<>0
        #If &&0<> '0'
            #Error 'Unpaired If'
        #End_If
    #End_If
    &&0= '0' | &&1=Pos
    AndCmp I&&0>>, #1>L]

[.End_If | I&&0: | J&&0:
    #If &&0<> '0'
        #ErrorPos &&1 'Unpaired If'
    #End_If
    &&0=0]

[If
    #If &&0=0
        &&0= '0'
    #Else
        &&0=&&0+1
    #End_If

    AndCmp I&&0>>, #1>L]

[Else_If | jmp J&&0>> | I&&0:
    AndCmp I&&0>>, #1>L]

[Else | jmp J&&0>> | I&&0: ]

[End_If | I&&0: | J&&0:
    #If &&0= '0'
        &&0=0
    #Else
        &&0=&&0-1
    #End_If]

[AndCmp | cmp #2 #4 | jn#3 #F | #+3]
____________________________________________________________________________________________

[.While
    #If &&2<>0
        #If &&2<> '0'
                #Error 'Unpaired While'
        #End_If
    #End_If

    &&2= '0' | &&3=Pos

    W&&2: cmp #1 #3 | jn#2 W&&2>>]

[.End_While
    #If &&2<> '0'
        #ErrorPos  &&3 'Unpaired While'
    #End_If
    jmp W&&2<< | w&&2:
    &&2=0]

[While
    #If &&2=0
        &&2= '0'
    #Else
        &&2=&&2+1
    #End_If
    W&&2: cmp #1 #3 | jn#2 W&&2>>]

[End_While | jmp W&&2<< | w&&2:
             #If &&2= '0'
                &&2=0
             #Else
                &&2=&&2-1
             #End_If]
____________________________________________________________________________________________

[.Do
    #If &&4<>0
        #If &&4<> '0'
                #Error 'Unpaired Do'
        #End_If
    #End_If

    &&4= '0' | &&5=Pos

    D&&4:]

[.Loop_Until
    #If &&4<> '0'
        #ErrorPos  &&5 'Unpaired Do Until'
    #End_If

    cmp #1 #3 | jn#2 D&&4<<
    &&4=0]

[.Loop_While
    #If &&4<> '0'
        #ErrorPos  &&5 'Unpaired Do While'
    #End_If

    cmp #1 #3 | j#2 D&&4<<
    &&4=0]

[Do
    #If &&4= 0
        &&4= '0'
    #Else
        &&4=&&4+1
    #End_If

    D&&4: ]

[Loop_Until | cmp #1 #3 | jn#2 D&&4<<  | D&&4:
 #If &&4= '0'
    &&4=0
 #Else
    &&4=&&4-1
 #End_If]

[Loop_While | cmp #1 #3 | j#2 D&&4<<  | D&&4:
 #If &&4= '0'
    &&4=0
 #Else
    &&4=&&4-1
 #End_If]
 
[Do_Loop | jmp D&&4<<]
____________________________________________________________________________________________

[.For
    #If &&6<>0
        #If &&6<> '0'
            #Error 'Unpaired For'
        #End_If
    #End_If
    &&6= '0' | &&7=Pos

    #If #3=imm
        mov #1 (#3-1)
    #Else
        mov #1 #3
        dec #1
    #EndIf
 F&&6:
    inc #1 | cmp #1 #5 | ja F&&6>> ]

[.Next | jmp F&&6<<
 F&&6:
    #If &&6<> '0'
        #ErrorPos &&7 'Unpaired For'
    #End_If
    &&6=0]

[For
    #If &&6=0
        &&6= '0'
    #Else
        &&6=&&6+1
    #EndIf

    #If #3=imm
        mov #1 (#3-1)
    #Else
        mov #1 #3
        dec #1
    #EndIf
 F&&6:
    inc #1 | cmp #1 #5 | ja F&&6>> ]


[Next | jmp F&&6<< | F&&6: &&6=&&6-1]

[Break | jmp F&&6>>]
[Continue | jmp F&&6<<]
[ExitF | jmp F0>>]
____________________________________________________________________________________________

;;
  &1 = Size of arguments 
  &2 = Size of local data (local+structures) 
  &3 = preserved regs 
;;

[Proc | &1=0 | &2=0 | &3= | #1 | push ebp | mov ebp esp]

[Arguments | {#1 ebp+((#x*4)+4)} | #+1 | &1=(#N*4)]

[Local | {#1 ebp-(#x*4)} | #+1 | &2=(#N*4) | sub esp &2]

[GetMember | {#3 ebp-(#F-#2)} | #+2]

[Structure | {#1 ebp-(&2+#2+4)} | sub esp #2 | push esp | GetMember &2+#2 #L>3 | &2=&2+#2+4]

[Uses | push #1>L | &3=pop #L>1]

[Return | #If #N=1 | mov eax #1 | #EndIf | jmp P9>>]

[ExitP | jmp P9>>]

[EndP | P9: | &3 | mov esp ebp | pop ebp | ret &1]

[.EndP | P9: | &3 | mov esp ebp | pop ebp | ret &1]
_____________________________________________________________________________________________

; little message routines for values tests (dWords only / text pointer) to be called with:
; > Hexprint D$esi / showme esi+5, for exemple:

[InfoTitle: 'Application Base', 0]

[HexprintString: B$ '        h' 0
 MessageTitle:      'HihoHiho' 0]


Proc HexPrnt:
    Arguments @N

    pushad
        mov ebx D@N, ecx 8, edi HexPrintString | add edi 7
        std
            Do
                mov al bl | and al 0F | add al '0'
                On al > '9', add al 7
                stosb | shr ebx 4
            Do_Loop
        cld
        call 'User32.MessageBoxA'  0  HexPrintString  MessageTitle  &MB_OK__&MB_SYSTEMMODAL
    popad
EndP

[Hexprint | call Hexprnt #1 | #+1]


Proc ShowYou:
    Arguments @Pointer

    pushad
        call 'MessageBoxA'  &NULL  D@Pointer  MessageTitle  &MB_SYSTEMMODAL__&MB_OK
    popad
EndP

[Showme | push eax | lea eax D$#1 | call ShowYou eax | pop eax]

_______________________________________________________________________________________

____________________________________________________________________________________________

Comment1:
;;
  Many Compilers encode the DLLs calls under the form of a CALL to JUMPs Table. This is
  to say that each call to a DLL Function is encoded with two instructions: a CALL plus
  a JMP.
  
  RosAsm performs these calls in one single Instruction (a direct call to the .Import
  Section record).
  
  Unfortunately, the direct RosAsm form is one Byte longer than the indirect call to a
  Jumps Table (the Instruction Opcode for 'call D$Location' is two Bytes, whereas the
  one for 'call Label' is one Byte).
  
  It may happend that, when a short JMP jumps over one or more DLLs calls, the shorter
  form found in the Disassembly becomes out of range because of these added Bytes.
  
  In such cases, the Disassembler replaces, for example, 'je K5>', by 'je K5>>'.
  
  All occurences of '>>' and '<<' found in a disassembly Source fall under that case.
;;
",

DisTitle: B$ CR, LF ; ('1' is at DisTitle+12).
"TITLE Part01 

_____________________________________________________________________________________________

", 0]


WriteMacros:
    mov esi DisMacros2 | While B$esi <> 0 | movsb | End_While
ret
____________________________________________________________________________________________

[EvocatedOnly: ?]

RemoveNonAccessedEvocatedData:
    mov esi D$RoutingMap, edx D$EndOfRoutingMap | add esi D$FirstSection
    mov edi D$SectionsMap | add edi D$FirstSection
mov D$EvocatedOnly 0
    While esi < edx
        If B$esi = LABEL
          ; When here, this '0' means that it is going to be considered Data:
          ;  On B$edi = 0, mov B$esi 0
        Else_If B$esi = EVOCATED
          ;  On B$edi = 0, mov B$esi 0
          inc D$EvocatedOnly
        End_If

        inc esi | inc edi
    End_While

    hexprint D$EvocatedOnly
ret
____________________________________________________________________________________________

[DisReadyForTable: ?    DisCloseBracket: ?    DisVirtual: ?]

[PeWithoutData: B$ "
; Weird PE without .Data Section inside !!!" PeWithoutDataLen: Len
 AndVirtualIsRunable: "
; And a Virtual Section is runable!!!

" AndVirtualIsRunableLen: Len]




[TargetSize: ?]     ; May be BYTE, WORD, DWORD, FP4, FP8, FP10, POINTER.




; check if a Data set may be represented by [Data: 0 #XXX]
; (B$ / W$ / D$ // 0 or other):




[FirstDisDataByte: ?]

WriteBytesData:
    push ebx, ecx
        mov edx 0, D$edi 'B$  ' | add edi 3

L5:     movzx eax B$ebx | push ebx | call WriteEax | pop ebx
        mov B$edi ' ' | inc edi | inc edx
        .If edx = 16
            If ecx > 1
                NextDisLine
                mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    ', B$edi+12 ' '
                add edi 13 | mov edx 0
            End_If
        .End_If
        inc ebx | loop L5<
        mov B$edi-1 ']'
    pop ecx, ebx
ret


WriteWordsData:
    push ebx, ecx
        shr ecx 1

        NextDisLine
        mov D$edi '    ', D$edi+4 '    '
        add edi 7 | mov D$edi '    ' | add edi 3
        mov edx 0, D$edi 'W$  ' | add edi 3

L5:     movzx eax W$ebx | push ebx | call WriteEax | pop ebx
        mov B$edi ' ' | inc edi | inc edx
        .If edx = 11
            If ecx > 1
                NextDisLine
                mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    '
                add edi 10 | mov D$edi '    ' | add edi 3 | mov edx 0
            End_If
        .End_If
        add ebx 2 | On ebx < D$UserPeEnd, loop L5<
        mov B$edi-1 ']'
    pop ecx, ebx
ret


WriteUnicodeData:
    push ebx, ecx
        shr ecx 1

        NextDisLine
        mov D$edi '    ', D$edi+4 '    '
        add edi 7 | mov D$edi '    ' | add edi 3
        mov edx 0, D$edi 'U$  ' | add edi 3

L5:     movzx eax W$ebx | push ebx | call WriteEax | pop ebx
        mov B$edi ' ' | inc edi | inc edx
        .If edx = 11
            If ecx > 1
                NextDisLine
                mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    '
                add edi 10 | mov D$edi '    ' | add edi 3 | mov edx 0
            End_If
        .End_If
        add ebx 2 | loop L5<
        mov B$edi-1 ']'
    pop ecx, ebx
ret


L9: pop ecx, ebx
ret

WriteCommentedWordsData:
    push ebx, ecx
        shr ecx 1 | jecxz L9<

        NextDisLine
        mov D$edi '    ', D$edi+4 '    '
        add edi 7 | mov D$edi ';   ' | add edi 3
        mov edx 0, D$edi 'W$  ' | add edi 3

L5:     movzx eax W$ebx | push ebx | call WriteEax | pop ebx
        mov B$edi ' ' | inc edi | inc edx
        .If edx = 11
            If ecx > 1
                NextDisLine
                mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    '
                add edi 10 | mov D$edi ';   ' | add edi 3 | mov edx 0
            End_If
        .End_If
        add ebx 2 | loop L5<
        mov B$edi-1 ']'
L9: pop ecx, ebx
ret


WritedWordPointers:
    push ebx, ecx
        shr ecx 2 | mov edx 0

L0:     mov eax D$ebx

        push ebx
            mov ebx eax | sub ebx D$DisImageBase | add ebx D$RoutingMap
            cmp ebx D$RoutingMap | jb L2>>
                cmp ebx D$EndOfRoutingMap | jae L2>>

                    push ebx
                        sub ebx D$RoutingMap | add ebx D$SectionsMap
                        mov bl B$ebx | and bl CODEFLAG+DATAFLAG+VIRTUALFLAG
                        If bl = CODEFLAG
                            mov D$edi 'Code' | add edi 4
                        Else_If bl = DATAFLAG
                            mov D$edi 'Data' | add edi 4
                        Else_If bl = VIRTUALFLAG
                            mov D$edi 'Virt', D$edi+4 'ual' | add edi 7
                        End_If
                    pop ebx

                    test B$ebx LABEL | jnz L2>>
                    mov cl B$ebx | and cl EVOCATED+INSTRUCTION
                    cmp cl EVOCATED+INSTRUCTION | je L2>>
                    If cl = INSTRUCTION
                        or B$ebx EVOCATED | jmp L2>>
                    End_If
                        mov ecx 0
L1:                     dec ebx
                        .If ebx <= D$RoutingMap
                            call EraseSectionName
                            add eax ecx | jmp L2>>
                        .Else_If ecx > 8
                            call EraseSectionName
                            add eax ecx | jmp L2>>
                        .End_If
                        dec eax | inc ecx
                        test B$ebx LABEL | jz L1<
                            sub ebx D$RoutingMap | add ebx D$SectionsMap
                            push edx
                                mov dl B$ebx, dh B$ebx+ecx
                                .If dl <> dh
                                    call EraseSectionName
                                    If dl = CODEFLAG
                                        sub ebx D$SectionsMap | add ebx D$RoutingMap
                                        test B$ebx INSTRUCTION | jz L1<<
                                        mov D$edi 'Code' | add edi 4
                                    Else_If dl = DATAFLAG
                                        mov D$edi 'Data' | add edi 4
                                    Else_If dl = VIRTUALFLAG
                                        mov D$edi 'Virt', D$edi+4 'ual' | add edi 7
                                    End_If
                                .End_If
                            pop edx
                            call WriteEax | mov B$edi '+' | inc edi
                            mov eax ecx

L2:                 call WriteEax
L3:     pop ebx
        mov B$edi ' ' | inc edi | inc edx
        .If edx = 6
            If ecx > 1
                NextDisLine
                mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    '
                add edi 10 ;| mov D$edi ';   ' | add edi 3 |
                mov edx 0
            End_If
        .End_If
        add ebx 4 | dec ecx | cmp ecx 0 | ja L0<<
        mov B$edi-1 ']'
    pop ecx, ebx
ret


EraseSectionName:
    If D$edi-4 = 'tual'
        sub edi 7
    Else_If D$edi-4 = 'Code'
        sub edi 4
    Else_If D$edi-4 = 'Data'
        sub edi 4
    End_If
ret


WritedWordsData:
    push ebx, ecx
        shr ecx 2

L0:     mov edx 0, D$edi 'D$  ' | add edi 3

L0:     mov eax D$ebx
        push ebx
            mov ebx eax | sub ebx D$DisImageBase | add ebx D$RoutingMap
            cmp ebx D$RoutingMap | jb L2>>
                cmp ebx D$EndOfRoutingMap | jae L2>>
                    test B$ebx NODE | jz L1>
                        sub ebx D$RoutingMap | add ebx D$SectionsMap

                        mov bl B$ebx | and bl CODEFLAG+DATAFLAG+VIRTUALFLAG
                        If bl = CODEFLAG
                            mov D$edi 'Code' | add edi 4
                        Else_If bl = DATAFLAG
                            mov D$edi 'Data' | add edi 4
                        Else_If bl = VIRTUALFLAG
                            mov D$edi 'Virt', D$edi+4 'ual' | add edi 7
                        End_If
                        jmp L2>

L1:                 test B$ebx Evocated | jz L2>
                        push ebx, eax
                            call WriteEax | mov D$edi '  ; ' | add edi 4
                        pop eax, ebx
                        sub ebx D$RoutingMap | add ebx D$SectionsMap
                        mov bl B$ebx | and bl CODEFLAG+DATAFLAG+VIRTUALFLAG
                        If bl = CODEFLAG
                            mov D$edi 'Code' | add edi 4
                        Else_If bl = DATAFLAG
                            mov D$edi 'Data' | add edi 4
                        Else_If bl = VIRTUALFLAG
                            mov D$edi 'Virt', D$edi+4 'ual' | add edi 7
                        End_If
                        call WriteEax
                        mov D$edi '??? ' | add edi 3 | mov W$edi CRLF | add edi 2
                        mov edx 6 | jmp L3>


L2:                 call WriteEax
L3:     pop ebx
        mov B$edi ' ' | inc edi | inc edx
        .If edx = 7
            If ecx > 1
                NextDisLine
                mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    '
                add edi 10 | mov D$edi '    ' | add edi 3 | mov edx 0
            End_If
        .End_If
        add ebx 4 | dec ecx | cmp ecx 0 | ja L0<<
        mov B$edi-1 ']'
    pop ecx, ebx
ret


L9: pop ecx, ebx
ret

WritedCommentedWordsData:
    push ebx, ecx
        shr ecx 2 | jecxz L9<

        NextDisLine
        mov D$edi '    ', D$edi+4 '    '
        add edi 7 | mov D$edi ';   ' | add edi 3
L0:     mov edx 0, D$edi 'D$  ' | add edi 3

L0:     mov eax D$ebx
        push ebx
            mov ebx eax | sub ebx D$DisImageBase | add ebx D$RoutingMap
            cmp ebx D$RoutingMap | jb L2>>
                cmp ebx D$EndOfRoutingMap | jae L2>>
                    test B$ebx NODE | jz L1>
                        sub ebx D$RoutingMap | add ebx D$SectionsMap

                        mov bl B$ebx | and bl CODEFLAG+DATAFLAG+VIRTUALFLAG
                        If bl = CODEFLAG
                            mov D$edi 'Code' | add edi 4
                        Else_If bl = DATAFLAG
                            mov D$edi 'Data' | add edi 4
                        Else_If bl = VIRTUALFLAG
                            mov D$edi 'Virt', D$edi+4 'ual' | add edi 7
                        End_If
                        jmp L2>

L1:                 test B$ebx Evocated | jz L2>
                        push ebx, eax
                            call WriteEax | mov D$edi '  ; ' | add edi 4
                        pop eax, ebx
                        sub ebx D$RoutingMap | add ebx D$SectionsMap
                        mov bl B$ebx | and bl CODEFLAG+DATAFLAG+VIRTUALFLAG
                        If bl = CODEFLAG
                            mov D$edi 'Code' | add edi 4
                        Else_If bl = DATAFLAG
                            mov D$edi 'Data' | add edi 4
                        Else_If bl = VIRTUALFLAG
                            mov D$edi 'Virt', D$edi+4 'ual' | add edi 7
                        End_If
                        call WriteEax
                        mov D$edi '??? ' | add edi 3 | mov edx 6 | jmp L3>


L2:                 call WriteEax
L3:     pop ebx
        mov B$edi ' ' | inc edi | inc edx
        .If edx = 7
            If ecx > 1
                NextDisLine
                mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    '
                add edi 10 | mov D$edi ';   ' | add edi 3 | mov edx 0
            End_If
        .End_If
        add ebx 4 | dec ecx | cmp ecx 0 | ja L0<<
        mov B$edi-1 ']'
L9: pop ecx, ebx
ret


[ControlFloat: ? ? ? ?]



; ecx = how many Bytes
[ST0trash: T$ ?]
[SourceOfSpecialFPU: ?  SourceOfSpecialFPUSize: ?]

WriteFP4:
    mov D$SourceOfSpecialFPU ebx, D$SourceOfSpecialFPUSize 4
    finit
    fld F$ebx | add ebx 4 | mov D$edi 'F$  ' | jmp L0>
WriteFP8:
    mov D$SourceOfSpecialFPU ebx, D$SourceOfSpecialFPUSize 8
    finit
    fld R$ebx | add ebx 8 | mov D$edi 'R$  ' | jmp L0>
WriteFP10:
    mov D$SourceOfSpecialFPU ebx, D$SourceOfSpecialFPUSize 10
    finit
    fld T$ebx | add ebx 10 | mov D$edi 'T$  '

L0: add edi 3
    pushad
        push edi
            mov eax 0, ecx 10 | rep stosd
        pop edi

        fstp T$ST0trash | call DisassemblerFloatToUString ST0trash edi
    popad

    While B$edi > 0 | inc edi | End_While

    .If B$SpecialFPU = &TRUE
        push ecx
            While B$edi <> '$' | dec edi | End_While | dec edi
            mov D$edi 'B$  ' | add edi 3
            mov ecx D$SourceOfSpecialFPUSize, ebx D$SourceOfSpecialFPU

L0:         mov al B$ebx
            mov B$edi '0' | inc edi
            If al = 0
              ; Done above
            Else_If al > 0F
                shr al 4 | and eax 0F | mov al B$HexaTable+eax | stosb
                mov al B$ebx
                and eax 0F | mov al B$HexaTable+eax | stosb
            Else
                and eax 0F | mov al B$HexaTable+eax | stosb
            End_If

            mov W$edi ', ' | add edi 2

            inc ebx | loop L0<

            sub edi 2
        pop ecx

    .End_If
ret


[FpModeTroncated 00_00001100_00000000
 FpModeNearest   00_00000000_00000000
 FpModeDown      00_00000100_00000000
 FpModeUp        00_00001000_00000000]

Proc FpuRounding:
    Argument @Mode
    local @ControlWord
        fstcw W@ControlWord
        and W@ControlWord 00_11110011_11111111
        mov eax D@Mode | or W@ControlWord ax
        fldcw W@ControlWord
EndP


Proc qWordToAscii:
    Arguments @qWordPointer, @StringPointer
    local @Divisor, @Remainder

        call FpuRounding FpModeTroncated

        push 0-1 ; End mark on the Stack.

        mov D@Divisor 10 | fild D@Divisor
        mov ebx D@qWordPointer
        fild Q$ebx
L0:     fprem | fistp D@Remainder | push D@Remainder
        fild Q$ebx | fdiv
        fld ST0 | fistp Q$ebx
        mov eax D$ebx | or eax D$ebx+4 | cmp eax 0 | jne L0<

        mov edi D@StringPointer
L0:     pop eax | cmp eax 0-1 | je L7>
            add al '0' | stosb | jmp L0<
L7:     mov al 0 | stosb
EndP
____________________________________________________________________________________________

NextDataDisLine:
    NextDisLine
    mov D$edi '    ', D$edi+4 '    ', D$edi+8 '  ; ' | add edi 12
ret
____________________________________________________________________________________________

[TruthAsciiTable: ?]
[BADASCII 2    GOODASCII 1]

BuildTruthAsciiTable:
    VirtualAlloc TruthAsciiTable 256
    mov edi D$TruthAsciiTable, al BADASCII, ecx 256 | rep stosb

    mov edi D$TruthAsciiTable, B$edi 0
    mov B$edi+LF GOODASCII, B$edi+CR GOODASCII,
        B$edi+0A7 GOODASCII,    ; $
        B$edi+025 GOODASCII,    ; %
        B$edi+0A9 GOODASCII,    ; ®
        B$edi+02F GOODASCII     ; /

    mov ebx 32, ecx 127
    While ebx < ecx
        mov B$edi+ebx GOODASCII | inc ebx
    End_While
ret


[GoodAsciiSum: ?    BadAsciiSum: ?    ZeroAsciiSum: ?]

;;
 Ascii recognition: The 3 upper Variables are used to store the number of 'good', 'bad'
 and 'zeroed' Bytes. When several zero-Bytes are consecutive, they count for 1 zero
 Bytes (possible cases of Strings Alignements). The truth Table is build by
 'BuildTruthAsciiTable' (called from 'DisInitialise'). As the intermediate Zeros are reduced
 to 1 when consecutive, the final number of zeros in 'D$ZeroAsciiSum' tells the possible
 Number of Strings in the parsed Chunk. Dividing the overall Number of 'D$GoodAsciiSum'
 by the number gives the average length of string(s). If too small, interpretation is
 statistically impossible. I set the limit, here to '< 4', what seems to me very risky.
 5 good Ascii Chars on 5 Bytes is only around 1 chance on 2*2*2*2*2 (32). Much too low
 to consider it 100% ensured. I must add a MAYBE Flag, for cases between 32 and ... ???
 The MAYBE case, would allow arasing the simple Bytes interpretation (same > no hurt),
 but should not forbid Words and dWords interpretations.
;;

CheckAsciiData:
    push ebx, ecx, edx, edi

        mov edx D$TruthAsciiTable, eax 0
        mov D$GoodAsciiSum 0, D$BadAsciiSum 0, D$ZeroAsciiSum 0
        mov B$ItWasReallyAscii &FALSE

L0:     mov al B$ebx | inc ebx
        If al = 0
            While B$ebx = 0
                inc ebx | cmp ebx D$UserPeEnd | jae L1>
                dec ecx | jz L1>
            End_While
            inc D$ZeroAsciiSum      ; Counts how many separated Strings, in fact;
        End_If

      ; 'GOODASCII' is 1, 'BADASCII' is 2. So:
        mov al B$edx+eax | shr al 1 | adc D$GoodAsciiSum 0 | add D$BadAsciiSum eax | loop L0<

      ; Extend the Ascii Recognition if Bytes coming after the parsed ones are also Ascii:
        mov al B$ebx, al B$edx+eax
        ..If al = GOODASCII
            inc D$GoodAsciiSum | inc ebx | mov al B$ebx, al B$edx+eax
            .If al = GOODASCII
                inc D$GoodAsciiSum | inc ebx | mov al B$ebx, al B$edx+eax
                If al = GOODASCII
                    inc D$GoodAsciiSum
                End_If
            .End_If
        ..End_If

L1:     .If D$ZeroAsciiSum > 1
            If D$GoodAsciiSum < 10
                mov edx 0, eax D$GoodAsciiSum, ecx D$ZeroAsciiSum | div ecx
                mov D$GoodAsciiSum eax
            End_If
        .End_If

        If D$BadAsciiSum = 0
            On D$GoodAsciiSum > 3, mov B$ItWasReallyAscii &TRUE
        End_If

    pop edi, edx, ecx, ebx
ret


[ItWasReallyUnicode: ?    NumberOfStringChars: ?]

CheckUnicodeData:
    push ebx, ecx, edx, edi

        mov edx D$TruthAsciiTable, eax 0
        mov D$GoodAsciiSum 0, D$BadAsciiSum 0, D$ZeroAsciiSum 0
        mov B$ItWasReallyAscii &FALSE

L0:     mov al B$ebx, al B$edx+eax | cmp al BADASCII | je L2>
        If B$ebx+1 = 0
            add ebx 2 | dec ecx | jz L2>
                        dec ecx | jz L2>
                            jmp L0<
        End_If

L2:     jecxz L3>

        While W$ebx = 0
            add ebx 2
            dec ecx | jz L3>
            dec ecx | jz L3>
        End_While

L3:     mov D$NumberOfStringChars ecx

        If ecx = 0
            mov B$ItWasReallyUnicode &TRUE
        Else
            mov B$ItWasReallyUnicode &FALSE
        End_If

    pop edi, edx, ecx, ebx
ret
____________________________________________________________________________________________

[SectionsMapForStrings: ?   EndOfSectionsMapForStrings: ?]

GetSectionsMapForStrings:
    mov ecx D$EndOfSectionsMap | sub ecx D$SectionsMap
    push ecx
        VirtualAlloc SectionsMapForStrings ecx
    pop ecx
    add ecx D$SectionsMapForStrings | mov D$EndOfSectionsMapForStrings ecx
ret

ReleaseSectionsMapForStrings:
    VirtualFree D$SectionsMapForStrings
ret
____________________________________________________________________________________________
;;
  Winner in matter of bad Strings Recognition:
  
  [Data0453031: B$ "=.midtd=.aift]=.au", 0,
                   "tV=.sndtO=.wmatH=.jpgtA=.bmpt:=.gift3=.pict,=.imgt%=.tift"]
  [<Data045307D: B$ 01E]
  [<Data045307E: B$ "=.tgat"]
  [Data0453084: B$ 017]
  [<Data0453085: B$ "=.pcxt"]
  [<Data045308B: B$ 010]
  [Data045308C: B$ "=.jpgt"]
  [<Data0453092: B$ 09]
  [<Data0453093: B$ "=.jpet"]
  
  ... which is real Code... :)))))))
;;

[Forced: ?]

Proc AsciiRecognition:
    Argument @Length
    Uses ecx

      ; First, for all Ascii Char, write a TEMPOFLAG into the relative SectionsMap Bytes:
        mov esi D$UserPeStart | add esi D$FirstSection
        mov ebx D$SectionsMap | add ebx D$FirstSection
        mov edx D$TruthAsciiTable, eax 0

        sub D$UserPeEnd 3

        While esi < D$UserPeEnd
            test B$ebx IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG+CODEFLAG | jnz L2>
            mov al B$esi

            .If B$edx+eax = GOODASCII
                If B$Forced = &TRUE
                    mov B$ebx TEMPOFLAG
                Else
                    On B$ebx = 0, mov B$ebx TEMPOFLAG
                End_If
            .End_If

L2:         inc esi | inc ebx
        End_While

      ; Append zero-ends:
        mov esi D$SectionsMap | add esi D$FirstSection

        .While esi < D$EndOfSectionsMap
            .If B$esi = TEMPOFLAG
              ; Consider case of Strings Length >= D@length/2 :
                mov ecx 0
                While B$esi = TEMPOFLAG | inc esi | inc ecx | End_While
                shl ecx 1 | cmp ecx D@Length | jb L2>

                If B$esi = 0
                  ; Write a TEMPOFLAG on the trailing zero, if any:
                    mov ebx esi | sub ebx D$SectionsMap | add ebx D$UserPeStart
                    On B$ebx = 0, mov B$esi TEMPOFLAG
                End_If
            .End_If

L2:         inc esi

        .End_While

      ; Delete too small Strings Chunks:
        mov esi D$SectionsMap | add esi D$FirstSection
        mov edx D$EndOfSectionsMap | sub edx 4

        .While esi < edx
            ..If B$esi = TEMPOFLAG
                mov ecx 0, ebx esi
L0:             While B$esi = TEMPOFLAG
                    inc esi | inc ecx | On esi >= edx, jmp L0>
                End_While

              ; Append any following small Chunk (down to 5 uChars):
                .If B$esi+1 = TEMPOFLAG                 ; 1 Byte in between!
                    If D$esi+2 = FOURTEMPOFLAGS
                        add esi 6 | add ecx 5 | jmp L0<
                    End_If
                .Else_If B$esi+2 = TEMPOFLAG            ; 1 Word in between!
                    If D$esi+3 = FOURTEMPOFLAGS
                        add esi 7 | add ecx 5 | jmp L0<
                    End_If
               ; .Else_If B$esi+3 = TEMPOFLAG            ; 3 Bytes >>> unlikely!
                   ; If D$esi+4 = FOURTEMPOFLAGS
                   ;     add esi 8 | add ecx 5 | jmp L0<
                   ; End_If
              ;  .Else_If B$esi+4 = TEMPOFLAG            ; 1 dWord in between!
                   ; If D$esi+5 = FOURTEMPOFLAGS
                   ;     add esi 8 | add ecx 5 | jmp L0<
                   ; End_If
                .End_If

L0:             If ecx < D@Length
                  ; Too small > arase the TEMPOFLAGs
                    push esi
L0:                     dec esi | mov B$esi 0 | cmp esi ebx | ja L0<
                    pop esi
                End_IF
            ..End_If

            inc esi

        .End_While

      ; Now flag the long enough Chunks:
        mov esi D$SectionsMap | add esi D$FirstSection

        .While esi < D$EndOfSectionsMap
            ..If B$esi = TEMPOFLAG
                mov ebx esi
                While B$esi = TEMPOFLAG
                    inc esi | On esi >= D$EndOfSectionsMap, jmp L0>
                End_While

L0:             sub ebx D$SectionsMap | add ebx D$RoutingMap | or B$ebx EVOCATED
                sub ebx D$RoutingMap | add ebx D$SizesMap | mov B$ebx STRINGS+BYTE
              ; and include trailing zeros in Data:
                mov ebx esi | sub ebx D$SectionsMap | add ebx D$UserPeStart
                On ebx >= D$UserPeEnd, jmp L2>
                If W$ebx = 0
                    mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap
                    or B$eax+2 EVOCATED
                    While B$ebx+1 = 0
                        mov B$esi TEMPOFLAG | inc esi | inc ebx
                        On ebx >= D$UserPeEnd, jmp L2>
                    End_While
                Else
                    mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap
                    or B$eax EVOCATED
                End_If

            ..End_If

            inc esi
        .End_While

L2:     call ReplaceTempoFlagBy DATAFLAG, STRINGS+BYTE | add D$UserPeEnd 3
EndP
____________________________________________________________________________________________

Proc UnicodeRecognition:
    Argument @Length
    Uses ecx

      ; First, for all Ascii Char, write a TEMPOFLAG into the relative SectionsMap Bytes:
        mov esi D$UserPeStart | add esi D$FirstSection
        mov ebx D$SectionsMap | add ebx D$FirstSection
        mov edx D$TruthAsciiTable, eax 0

        sub D$UserPeEnd 3

        While esi < D$UserPeEnd
            test B$ebx IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG+CODEFLAG | jnz L2>
            mov al B$esi

            ..If B$edx+eax = GOODASCII
              ; If No Section Flag yet:
                On B$Forced = &TRUE, jmp L1>
                .If W$ebx = 0
L1:                 If B$esi+1 = 0
                        mov B$ebx TEMPOFLAG, B$ebx+1 TEMPOFLAG
                        inc esi | inc ebx
                    End_If
                .End_If
            ..End_If

L2:         inc esi | inc ebx
        End_While

      ; Append zero-ends:
        mov esi D$SectionsMap | add esi D$FirstSection

        .While esi < D$EndOfSectionsMap
            ..If B$esi = TEMPOFLAG
              ; Consider case of Strings Length >= D@length/2 :
                mov ecx 0
                While B$esi = TEMPOFLAG | inc esi | inc ecx | End_While
                cmp ecx D@Length | jb L2>

                If W$esi = 0
                  ; Write a TEMPOFLAG on the trailing zero, if any:
                    mov ebx esi | sub ebx D$SectionsMap | add ebx D$UserPeStart
                    On W$ebx = 0, mov W$esi TWOTEMPOFLAGS
                End_If
            ..End_If

L2:         inc esi

        .End_While

      ; Delete too small Strings Chunks:
        mov esi D$SectionsMap | add esi D$FirstSection

        .While esi < D$EndOfSectionsMap
            ..If B$esi = TEMPOFLAG
                mov ecx 0, ebx esi
L0:             While B$esi = TEMPOFLAG
                    inc esi | inc ecx | On esi = D$EndOfSectionsMap, jmp L0>
                End_While

              ; Append any following small Chunk (down to 5 uChars):
                .If B$esi+1 = TEMPOFLAG                 ; 1 Byte in between!
                    If D$esi+2 = FOURTEMPOFLAGS
                        add esi 6 | add ecx 5 | jmp L0<
                    End_If
                .Else_If B$esi+2 = TEMPOFLAG            ; 1 Word in between!
                    If D$esi+3 = FOURTEMPOFLAGS
                        add esi 7 | add ecx 5 | jmp L0<
                    End_If
                .Else_If B$esi+3 = TEMPOFLAG            ; 3 Bytes >>> unlikely!
                   ; If D$esi+4 = FOURTEMPOFLAGS
                   ;     add esi 8 | add ecx 5 | jmp L0<
                   ; End_If
                .Else_If B$esi+4 = TEMPOFLAG            ; 1 dWord in between!
                    If D$esi+5 = FOURTEMPOFLAGS
                        add esi 8 | add ecx 5 | jmp L0<
                    End_If
                .End_If

L0:             shr ecx 1

                If ecx < D@Length
                  ; Too small > arase the TEMPOFLAGs
                    push esi
L0:                     dec esi | mov B$esi 0 | cmp esi ebx | ja L0<
                    pop esi
                End_IF
            ..End_If

            inc esi

        .End_While

      ; Now flag the long enough Chunks:
        mov esi D$SectionsMap | add esi D$FirstSection

        .While esi < D$EndOfSectionsMap
            ..If B$esi = TEMPOFLAG
                mov ebx esi
                While B$esi = TEMPOFLAG
                    inc esi | On esi = D$EndOfSectionsMap, jmp L0>
                End_While

L0:             sub ebx D$SectionsMap | add ebx D$RoutingMap | or B$ebx EVOCATED
                sub ebx D$RoutingMap | add ebx D$SizesMap | mov B$ebx STRINGS+WORD
              ; and include trailing zeros in Data:
                mov ebx esi | sub ebx D$SectionsMap | add ebx D$UserPeStart
                On ebx >= D$UserPeEnd, jmp L2>
                If W$ebx = 0
                    mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap
                    or B$eax+2 EVOCATED
                    While W$ebx+2 = 0
                        mov B$esi TEMPOFLAG | inc esi | inc ebx
                        mov B$esi TEMPOFLAG | inc esi | inc ebx
                        On ebx >= D$UserPeEnd, jmp L2>
                    End_While
                Else
                    mov eax esi | sub eax D$SectionsMap | add eax D$RoutingMap
                    or B$eax EVOCATED
                End_If

            ..End_If

            inc esi
        .End_While

L2:     call ReplaceTempoFlagBy DATAFLAG, STRINGS+WORD | add D$UserPeEnd 3
EndP
____________________________________________________________________________________________

Proc ReplaceTempoFlagBy:
    Argument @SectionFlag, @FLAG

      ; replace, for example, all TEMPOFLAGs by DATAFLAGs:
L2:     mov esi D$SectionsMap | add esi D$FirstSection
        mov eax D@SectionFlag

        mov ebx esi | sub ebx D$SectionsMap | add ebx D$SizesMap

        mov ecx D@FLAG

        While esi < D$EndOfSectionsMap
            If B$esi = TEMPOFLAG
                mov B$esi al
                or B$ebx cl
            End_If

            inc esi, ebx
        End_While
EndP

;;
  Small Strings before and after identified Strings are much likely also Strings.
  Not if this is inside Code that could as well be read as String.
;;
ExtendStrings: ret ; 'AsciiRecognition'
    push ebp

    mov esi D$SizesMap | add esi D$FirstSection
    mov edx D$EndOfSizesMap, eax 0, ebp D$TruthAsciiTable

    mov ebx esi | sub ebx D$SizesMap | add ebx D$SectionsMap
    mov edx esi | sub edx D$SizesMap | add edx D$RoutingMap
    mov edi esi | sub edi D$SizesMap | add edi D$UserPeStart

; esi > SizesMap // ebx > SectionsMap // edx > RoutingMap // edi > UserPeStart

    .While esi < edx
        test B$esi STRINGS | jz L5>
          ; What is above? Data or Code?
            .If B$ebx-1 = CODEFLAG
              ; Are we at the end of a Code Chunk?
                If B$edx = CHUNKEND
                  ; Yes > do nothing.
                Else
                    mov ecx 0
L0:                 inc ecx | dec edx | dec ebx
                    On B$ebx-1 <> CODEFLAG, jmp L2>
                        mov al B$edi, al B$ebp+eax | On al = BADASCII, jmp L5>
                        test B$edx CHUNKEND | jz L0<

L2:
                End_If

            .Else_If B$ebx-1 = DATAFLAG

            .End_If


L5:     inc esi | inc ebx | inc edi
    .End_While

    pop ebp
ret


FillStringsSizes:
    mov esi D$SizesMap | add esi D$FirstSection
    mov ecx D$EndOfSizesMap

    mov ebx esi | sub ebx D$SizesMap | add ebx D$UserPeStart

    mov edx D$TruthAsciiTable, eax 0

    .While esi < ecx
        test B$esi STRINGS | jz L2>
            If B$esi = STRINGS+BYTE
                mov al B$ebx
                While D$edx+eax = GOODASCII
                    or B$esi STRINGS
                    inc esi, ebx
                End_While

                On B$esi = 0, or B$esi STRINGS

            Else_If B$esi = STRINGS+WORD
                mov al B$ebx
                While D$edx+eax = GOODASCII
                    cmp B$esi+1 0 | jne L2>
                    or W$esi ((STRINGS shl 8)+STRINGS)
                    inc esi, ebx
                    inc esi, ebx
                End_While

                On W$esi = 0, or W$esi ((STRINGS shl 8)+STRINGS)
            End_If

L2:     inc esi, ebx
    .End_While
ret
____________________________________________________________________________________________

;;
  Repetitive Bytes may be real Instructions. Example:
  
  05, 05, 05, 05, 05   ; add eax 05050505
  C7,80, BC,00,00,00, 00,00,00,00  ; mov D$eax+0BC 0
;;

MarkRepetitiveDataBytes:
    mov esi D$UserPeStart | add esi D$FirstSection
    mov edx D$UserPeEnd | sub edx 8

    mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap

    .While esi < edx
L0:     cmp D$ebx 0 | jne L8>
        cmp D$ebx+4 0 | jne L8>

            mov al B$esi | cmp al 090 | je L8> ; Op90 nop
                           cmp al 0CC | je L8> ; OpCC int3
                           cmp al 0A4 | je L8> ; OpA4 movsb
                           cmp al 0A5 | je L8> ; OpA5 movsd
                           cmp al 0C3 | je L8> ; OpC3 ret

            cmp B$esi+1 al | jne L8>
            cmp B$esi+2 al | jne L8>
            cmp B$esi+3 al | jne L8>
            cmp B$esi+4 al | jne L8>
            cmp B$esi+5 al | jne L8>
            cmp B$esi+6 al | jne L8>
            cmp B$esi+7 al | jne L8>

              ; Case of dummy "Push/pop eax" for all Registers >>> 9 cases:
                cmp al 050 | je L1>     ; Op50 push eax
                cmp al 058 | jne L2>    ; Op58 pop eax
L1:                 cmp B$esi+8 al | jne L8>

L2:             While B$esi = al
                    mov B$ebx DATAFLAG
                    inc esi | inc ebx | On esi = edx, ret
                    cmp B$ebx 0 | jne L8>
                End_While

                jmp L0<

L8:     inc esi | inc ebx
    .End_While
ret


MarkVeryRepetitiveDataBytes:
    mov esi D$UserPeStart | add esi D$FirstSection
    mov edx D$UserPeEnd | sub edx 15

    mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap

    .While esi < edx
L0:     cmp D$ebx 0 | jne L2>
        cmp D$ebx+4 0 | jne L2>
        cmp D$ebx+8 0 | jne L2>

            movzx eax B$esi | cmp al 090 | je L2> ; Op90 nop
                              cmp al 0CC | je L2> ; OpCC int3
                              cmp al 0A4 | je L2> ; OpA4 movsb
                              cmp al 0A5 | je L2> ; OpA5 movsd
                              cmp al 0C3 | je L2> ; OpC3 ret

                mov ecx eax | shl ecx 8 | or ecx eax | shl ecx 16 | or ecx eax
                cmp D$esi ecx | jne L2>
                cmp D$esi+4 ecx | jne L2>
                cmp D$esi+8 ecx | jne L2>

                    While B$esi = al
                        mov B$ebx DATAFLAG
                        inc esi | inc ebx | On esi = edx, ret
                        cmp B$ebx 0 | jne L2>
                    End_While

                    jmp L0<

L2:     inc esi | inc ebx
    .End_While
ret

____________________________________________________________________________________________

MarkEvocatedSizes:
    mov esi D$SizesMap, edx D$EndOfSizesMap | add esi D$FirstSection

    .While esi < edx
        mov al B$esi

        ..If al <> 0
            .If al = POINTER
L1:             mov ebx esi | sub ebx D$SizesMap | add ebx D$UserPeStart
                mov ecx ebx | add ecx 100
                push esi, edx, ebx
                    call IsItCode ebx, ecx, 25
                pop ebx, edx, esi

                sub ebx D$UserPeStart | add ebx D$SectionsMap
                If eax = &TRUE
                    On B$ebx = 0, mov B$ebx CODEFLAG
                Else
                    On D$ebx = 0, mov D$ebx FOURDATAFLAGS
                End_If

            .Else_If al = DWORD
                jmp L1<

            .Else
              ; Bytes, Words, qWords, FP >>> Data:
                If al < FP4     ; BYTE 1, WORD 00_10, ; // ;DWORD  00_100
                    movzx ecx al
                Else_If al = FP4
                    mov ecx 4
                Else_If al = FP8
                    mov ecx 8
                Else_If al = FP10
                    mov ecx 10
                Else
                    jmp L5>
                End_If

                mov ebx esi | sub ebx D$SizesMap | add ebx D$SectionsMap
               ; Force it:
L0:             cmp B$ebx VIRTUALFLAG | je L5>
                    mov B$ebx DATAFLAG | inc ebx | loop L0<

            .End_If
        ..End_If

L5:     inc esi
    .End_While
ret

____________________________________________________________________________________________

[FlowNumberOfPointers: ?]

MarkPointersFlows:
    mov esi D$UserPeStart | add esi D$FirstSection
    mov edx D$UserPeEnd | sub edx 4
    mov D$FlowNumberOfPointers 0

L0:     .While esi < edx
            mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
            test B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG | jnz L5>>

            mov eax D$esi | sub eax D$DisImageBase | add eax D$UserPeStart
            .If eax > D$UserPeStart
                If eax < D$UserPeEnd
                    sub eax D$UserPeStart | add eax D$SectionsMap
                    test B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG | jnz L5>>

                    inc D$FlowNumberOfPointers | add esi 4 | jmp L0<
                End_If
            .End_If

          ; Minimum number of Pointers in the flow: 4
            .If D$FlowNumberOfPointers > 3
                mov ecx D$FlowNumberOfPointers | shl ecx 2 | sub esi ecx
                mov edi esi | sub edi D$UserPeStart | add edi D$SizesMap
                mov ebx edi | sub ebx D$SizesMap | add ebx D$RoutingMap
                push edi
                    mov ecx D$FlowNumberOfPointers

                    mov D$edi POINTER | add edi 4
                    mov D$ebx INDIRECT+LABEL+EVOCATED | add ebx 4
                    dec ecx

L1:                 mov D$edi POINTER | add edi 4
                    mov D$ebx INDIRECT | add ebx 4 | loop L1<
                pop edi

                mov ecx D$FlowNumberOfPointers | shl ecx 2
                sub edi D$SizesMap | add edi D$SectionsMap
                mov al DATAFLAG | rep stosb
              ; Give a chance to downward Code Analyzes:
                sub edi D$SectionsMap | add edi D$RoutingMap | or B$edi EVOCATED

              ; Flag the Locations pointed to by the Pointers Flow:
                mov ecx D$FlowNumberOfPointers
L1:             lodsd | sub eax D$DisImageBase | add eax D$RoutingMap
                or B$eax EVOCATED+LABEL | loop L1<

                mov D$FlowNumberOfPointers 0 | jmp L0<<
            .End_If

L5:         mov ecx 0

            inc esi | mov D$FlowNumberOfPointers 0
        .End_While
ret


[NumberOfAlternatedPointers: ?]

MarkAlternatedPointersFlows:
    mov esi D$UserPeStart | add esi D$FirstSection
    mov edx D$UserPeEnd | sub edx 4
    mov D$NumberOfAlternatedPointers 0

L0: .While esi < edx
        mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
        test B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG | jnz L5>>
;mov eax esi | sub eax D$UserPeStart | add eax D$ImageBase
;On eax = 077ED83D4, int3
        mov eax D$esi | sub eax D$DisImageBase | add eax D$UserPeStart
        .If eax > D$UserPeStart
            If eax < D$UserPeEnd
                sub eax D$UserPeStart | add eax D$SectionsMap
                test B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG | jnz L5>>
                call IsNBytesInstruction 4 | On eax = &TRUE, jmp L5>>
                ;hexprint D$NumberOfAlternatedPointers
                inc D$NumberOfAlternatedPointers | add esi 8 | jmp L0<<
            End_If
        .End_If

      ; Minimum number of Pointers in the flow: 4
        .If D$NumberOfAlternatedPointers > 3
        ;hexprint D$NumberOfAlternatedPointers
            mov ecx D$NumberOfAlternatedPointers | shl ecx 3 | sub esi ecx
            mov edi esi | sub edi D$UserPeStart | add edi D$SizesMap
            mov ebx edi | sub ebx D$SizesMap | add ebx D$RoutingMap
          ; ebx > RoutingMap // edi >> SizesMap
            push edi
                mov ecx D$NumberOfAlternatedPointers

                mov D$edi POINTER | add edi 8
                mov D$ebx INDIRECT+LABEL+EVOCATED | add ebx 8
                dec ecx

L1:             mov D$edi POINTER | add edi 8
                mov D$ebx INDIRECT | add ebx 8 | loop L1<
            pop edi

            mov ecx D$NumberOfAlternatedPointers | shl ecx 3 | sub ecx 4
            sub edi D$SizesMap | add edi D$SectionsMap
            mov al DATAFLAG | rep stosb
          ; Give a chance to downward Code Analyzes:
            sub edi D$SectionsMap | add edi D$RoutingMap | or B$edi EVOCATED

          ; Flag the Locations pointed to by the Pointers Flow:

            mov ecx D$NumberOfAlternatedPointers
L1:         lodsd | add esi 4 | sub eax D$DisImageBase | add eax D$RoutingMap
            or B$eax EVOCATED | loop L1<

            mov D$NumberOfAlternatedPointers 0 | jmp L0<<
        .End_If

L5:     mov D$NumberOfAlternatedPointers 0

        inc esi
    .End_While
ret
____________________________________________________________________________________________

Proc IsNBytesInstruction:
    Argument @N
    Local @Pointer, @End
    Uses esi, edx

      ; @N: Number of Byte before the four bytes Address.
      ; esi: Points to the Four Bytes Address.

      ; Like for 'DecodeOnly':
        mov B$WeAreInTheCodeBox &TRUE, B$SimpleScan &TRUE

        mov D@Pointer esi
      ; D@Pointer points to the first Byte of the Adress Candidate.
        lea eax D$esi+4 | mov D@End eax
      ; D@End points to the next Byte after the Address Candidate.
        sub esi D@N
      ; Esi points to the start Address of an Instruction Candidate, to be now tested.

      ; Disassemble: (DisMain)
L0:     mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
        mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
        mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE

        mov edi DecodeText
L1:     movzx eax B$esi | inc esi | call D$DisOp1+eax*4
        On B$DisFlag = DISDONE, jmp L1<

        .If esi = D@End
            mov eax &TRUE
        .Else_If esi < D@Pointer
            jmp L0<
        ;.Else_If esi = D@Pointer
          ; The Pointer candidate could, itself, also be an Instruction:
        ;    mov eax &TRUE
        .Else
            mov eax &FALSE
        .End_If

        mov B$WeAreInTheCodeBox &FALSE, B$SimpleScan &FALSE
EndP

____________________________________________________________________________________________

;;
  On a big File of 1 Mega, parsing the yet zeroed SectionsMap Bytes may be evaluated
  to parsing 500 Ko. (We execute this Recognition in between the positive and the
  megative Recognitions).
  ___________________________
  Probablity rude evaluations:
  
  * 500,000 on 4,294,967,295 (0_FFFF_FFFF) >>> say, 1 random chance on 2000.
  
    Two consecutive Pointer >>> say, 1 random chance on 4,000,000.
    Three consecutive Pointer >>> say, 1 random chance on 16,000,000,000,000.
    (Four consecutive Pointer and more are already identified erlier, by
    MarkPointersFlows'
  
  * For isolated Pointers (1 random chance on 2000) we also execute:
  
    'IsIsolatedPointer' >>> 'IsNBytesInstruction' that encreases a little bit
    the 1 on 2000 probablity when saying that the Pointer Candidate cannot be
    member of an Instruction (not guaranted at all, but better than nothing).
    
  * For Pointer to identified Code we also ensure that the Pointer does not
    point into the middle of a valid Instruction
;;

[PointerInData: ?]

MarkIsolatedPointers: ; MarkPointersFlows
    mov esi D$UserPeStart | add esi D$FirstSection
    mov edx D$UserPeEnd | sub edx 4
    mov D$FlowNumberOfPointers 0

L0: .While esi < edx
        mov B$PointerInData &FALSE

        mov eax esi | sub eax D$UserPeStart | add eax D$SectionsMap
        If B$eax = 0
            ;
        Else_If B$eax = DATAFLAG
            mov B$PointerInData &TRUE
        Else
            jmp L5>>
        End_If

        mov eax D$esi | sub eax D$DisImageBase | add eax D$UserPeStart

        .If eax > D$UserPeStart
            If eax < D$UserPeEnd
                sub eax D$UserPeStart | add eax D$SectionsMap
                test B$eax IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG | jnz L5>>
                test B$eax+1 IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG | jnz L5>>
                test B$eax+2 IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG | jnz L5>>
                test B$eax+3 IMPORTFLAG+RESOURCESFLAG+EXPORTFLAG+KILLFLAG | jnz L5>>

                inc D$FlowNumberOfPointers | add esi 4 | jmp L0<<
            End_If
        .End_If

        .If D$FlowNumberOfPointers = 0
            ;
        .Else_If D$FlowNumberOfPointers = 1
            If B$PointerInData = &TRUE
                lea eax D$esi-4 | sub eax D$UserPeStart | add eax D$SizesMap
               ; test B$eax POINTER | jnz L1>
               ; test B$eax DWORD | jnz L1>
                On B$eax = POINTER, jmp L1>
                On B$eax = DWORD, jmp L1>
                mov eax D$esi-4 | sub eax D$DisImageBase | add eax D$RoutingMap
                Test B$eax EVOCATED+LABEL+INDIRECT | jnz L1>

                On B$eax <> 0, jmp L5>>

L1:             mov eax D$esi-4 | sub eax D$DisImageBase | add eax D$SectionsMap
                On B$eax <> CODEFLAG, jmp L1>>
                    sub eax D$SectionsMap | add eax D$RoutingMap
                    test B$eax INSTRUCTION | jnz L1>
            End_If
;;
  There is no logic that would tell if an isolated Pointer Candidate is or not
  a Pointer, by scaning weither or not, it could be some Code.
;;
            jmp L5>>
            ;sub esi 4 | call IsIsolatedPointer | add esi 4

            ;If eax = &TRUE
            ;    mov eax D$esi-4 | sub eax D$DisImageBase | add eax D$SectionsMap
            ;    On D$eax = 0, jmp L1>
            ;End_If

        .Else_If D$FlowNumberOfPointers = 2
            If B$PointerInData = &TRUE
                lea eax D$esi-4 | sub eax D$UserPeStart | add eax D$SizesMap
                test B$eax STRINGS | jnz L5>>

                jmp L1>
            End_If

            ;sub esi 8 | call IsIsolatedPointer | add esi 8
            ;On eax = &TRUE, jmp L1>

        .Else
          ; Restore esi to the first Pointer:
L1:         mov ecx D$FlowNumberOfPointers | shl ecx 2 | sub esi ecx
            mov edi esi | sub edi D$UserPeStart | add edi D$SizesMap
            mov ebx edi | sub ebx D$SizesMap | add ebx D$RoutingMap
            push edi
                mov ecx D$FlowNumberOfPointers
              ; First Pointer of a list:
                mov D$edi POINTER | add edi 4
                mov D$ebx INDIRECT+LABEL+EVOCATED | add ebx 4
                dec ecx | jz L2>
              ; Other Pointers if any:
L1:             mov D$edi POINTER | add edi 4
                and D$ebx 0_FF | or D$ebx INDIRECT | add ebx 4 | loop L1<
L2:         pop edi

            mov ecx D$FlowNumberOfPointers | shl ecx 2
            sub edi D$SizesMap | add edi D$SectionsMap
            mov al DATAFLAG | rep stosb
          ; Give a chance to downward Code Analyzes:
            sub edi D$SectionsMap | add edi D$RoutingMap | or B$edi EVOCATED

          ; Flag the Locations pointed to by the Pointers Flow:
            mov ecx D$FlowNumberOfPointers

L1:         lodsd | sub eax D$DisImageBase | add eax D$RoutingMap
            or B$eax EVOCATED+LABEL | loop L1<

            mov D$FlowNumberOfPointers 0 | jmp L0<<
        .End_If

L5:     inc esi | mov D$FlowNumberOfPointers 0
    .End_While
ret


IsIsolatedPointer:
    push esi, edx
      ; esi: UserPeStart (Four Bytes Pointer Adress)

;If D$esi = 04293E8 ; <<< Value of the Pointer Candidate
;    push esi | sub esi D$UserPeStart | add esi D$DisImageBase
;        On esi = 041F1C0, int3 ; <<< Location
;    pop esi
;End_If

        mov ecx 0, ebx esi
        sub ebx D$UserPeStart | add ebx D$SectionsMap

        While B$ebx-1 = 0
        ; "mov D$eax*4+ecx+01234 Data": 11 Bytes Instruction - 4 = 7 Bytes before Address
            inc ecx | dec ebx
            On ecx = 7, jmp L0>
        End_While

        ..If ecx <> 0
L0:         push ecx
                mov D$LastCodeRef 0 | call IsNBytesInstruction ecx
            pop ecx
            .If eax = &TRUE
                jmp L9>
            .Else
                mov eax D$LastCodeRef
                If eax = D$esi
                    mov eax &TRUE | jmp L9>
                End_If
            .End_If
            dec ecx | jnz L0<
            ;mov D$LastCodeRef 0 | call IsNBytesInstruction 0 | jmp L9>

        ..End_If

        mov eax &FALSE

L9: pop edx, esi

    xor eax &TRUE
ret
____________________________________________________________________________________________

;;
  When all possible Recognitions are done we generalize the found Flags in all
  the coming Sections. Based on the 'DisRvaSectionAlignment'.
;;

ExtendSections:
    mov esi D$SectionsMap, edx D$EndOfSectionsMap | add esi D$FirstSection

  ; Ensure, first that the first Section starts with a valid Flag. If not, extend
  ; by the next coming one:
    If B$esi = 0
        mov edi esi, ecx 0
        While B$esi = 0 | inc esi | inc ecx | End_While
        mov al B$esi | rep stosb
    End_If

  ; Now unicize the Flags depending on the previous one. But, in case the next
  ; Flag is Data and the previous oneis  Code with CHUNKEND, we extend to Data:
    mov esi D$SectionsMap, edx D$EndOfSectionsMap | add esi D$FirstSection
    .While esi < edx
        mov al B$esi
        While B$esi = al
            inc esi | cmp esi edx | je L9>
        End_While
        mov ebx esi
        While B$ebx = 0
            inc ebx | cmp ebx edx | je L1>
        End_While
        .If al = CODEFLAG
            If B$ebx = DATAFLAG
                mov ebx esi | sub ebx D$SectionsMap | add ebx D$RoutingMap
                Test B$ebx CHUNKEND | jz L1>
                    mov al DATAFLAG
            End_If
        .End_If
L1:     While B$esi = 0
            mov B$esi al | inc esi | cmp esi edx | je L9>
        End_While
    .End_While
L9: ret


StripSectionsZeroEnd:
    mov esi D$UserPeStart, edx D$UserPeEnd | add esi D$FirstSection
    add esi D$DisRvaSectionAlignment | dec esi

    .While esi < edx
        push esi

            mov ecx 0
            While B$esi = 0
                mov eax esi | sub eax D$UserPeStart | add eax D$RoutingMap
                On B$eax <> 0, jmp L1>
                inc ecx | dec esi | On ecx = D$DisRvaSectionAlignment, jmp L1>
            End_While
            inc esi

            .If ecx > 0
                mov ebx esi | sub ebx D$UserPeStart | add ebx D$SectionsMap

                If B$ebx = DATAFLAG
                    sub ebx D$SectionsMap | add ebx D$RoutingMap
                    inc ebx | On ecx > 4, Align_On 4 ebx
                    mov B$ebx EVOCATED

                Else_If B$ebx = VIRTUALFLAG

                Else_If B$ebx <> KILLFLAG
                    mov edi ebx, al 0 | rep stosb

                End_If

            .End_If

L1:     pop esi

        add esi D$DisRvaSectionAlignment
    .End_While
ret
____________________________________________________________________________________________

[ItWasReallyAscii: ?]

WriteCommentedAsciiData:
    ;call CheckAsciiData |
    On D$BadAsciiSum = ecx, ret

    push ebx, ecx, edi
        NextDisLine

        mov D$NextStringBreak edi | add D$NextStringBreak 70

        .If B$ItWasReallyAscii = &TRUE
            If D$FirstDisDataByte <> 0
                mov edi D$FirstDisDataByte | mov B$edi '"' | inc edi | jmp L0>
            End_If
        .End_If

        mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    '
        add edi 7 | mov D$edi ';  B', D$edi+4 '$ " ' | add edi 7

K0:     mov al B$ebx | inc ebx
            jmp L1>
L0:             loop K0<
                    jmp L9>>

L1:     ...If al = CR
            cmp B$ebx  LF | jne L2>
                 inc ebx | dec ecx | cmp ecx 0 | je L9>>
L1:         If B$ItWasReallyAscii = &TRUE
                On D$FirstDisDataByte = 0, jmp L1>
                NextDisLine
                mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    ', D$edi+12 '    '
                add edi 13
            Else
L1:             call NextDataDisLine
            End_If
            jmp L0<

        ...Else_If al = LF
L2:         mov al '.' | inc edx

        ...Else_If al = 0
            inc edx
            ..If D$edi-4 = 'B$ "'
                mov B$edi-1 '0'   ; > 'B$ 0'

            ..Else_If B$edi-1 = '0'
                If D$edi-4 = 'B$ 0'
                    mov D$edi ', 0 ' | add edi 3
                Else_If W$edi-3 = '" '
                    mov D$edi ', 0 ' | add edi 3
                Else_If W$edi-3 = ', '
                    mov D$edi ', 0 ' | add edi 3
                Else
                    mov D$edi '", 0' | add edi 4
                End_If

            ..Else
                mov D$edi '" 0 ' | add edi 3

            ..End_If

            cmp ecx 1 | je L8>>
            .If B$ebx <> 0
                If B$ItWasReallyAscii = &TRUE
                    On D$FirstDisDataByte = 0, jmp L1>
                    NextDisLine
                    mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    ', D$edi+12 '    '
                    add edi 13
                Else
L1:                 call NextDataDisLine
                End_If
                mov B$edi '"' | inc edi
            .End_If
            cmp ecx 1 | je L8>>
            jmp L0<<

        ...Else_If al = 9
            mov eax '    ' | stosd

        ...Else_If al = '"'
            mov D$edi '",02', D$edi+4 '2, "' | add edi 8 | jmp L0<<

        ...Else_If al < ' '
L2:         mov al '.' | inc edx


        ...Else_If al > 127
            ; ... ???

        ...End_If

        .If B$edi-1 = '0'
            If W$edi-3 = '" '
                mov D$edi ', " ' | add edi 3
            Else_If W$edi-3 = ', '
                mov D$edi ', " ' | add edi 3
            Else
                ; ????
            End_If
        .End_If

        stosb

        If edi = D$NextStringBreak
            mov W$edi '",', W$edi+2 CRLF | add edi 4
            mov eax '    ' | stosd | stosd | stosd | stosd
            mov W$edi-2 ';"'

            add D$NextStringBreak 88
        End_If

        jmp L0<<

L9:     mov W$edi '" ' | add edi 2
L8:     mov B$edi ']' | inc edi
    pop eax, ecx, ebx
ret


[NextStringBreak: ?    InsideDataText: ?]

Proc WriteAsciiData:
    Argument @Format
    Uses ebx, ecx

        mov D$NextStringBreak edi | add D$NextStringBreak 70

        If D@Format = 1
            mov D$edi 'B$ "'
        Else
            mov D$edi 'U$ "'
        End_If
        add edi 4
        mov B$InsideDataText &TRUE

L0:     mov al B$ebx | add ebx D@Format

L1:     ...If al = CR
            mov D$NextStringBreak edi | add D$NextStringBreak 70
            mov eax D@Format | dec eax
            cmp B$ebx+eax LF | jne L2>
                 add ebx D@Format | sub ecx D@Format | cmp ecx 0 | jle L9>>
L1:         If B$ItWasReallyAscii = &TRUE
                On D$FirstDisDataByte = 0, jmp L1>
             ;   NextDisLine
             ;   mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    ', D$edi+12 '    '
             ;   add edi 13
                mov W$edi CRLF | add edi 2
            Else
L1:             call NextDataDisLine
            End_If

            jmp L5>>

        ...Else_If al = LF
L2:         mov al '.' | inc edx

        ...Else_If al = 0
           ; If B$InsideDataText = &TRUE
           ;     mov D$edi '",  ' | add edi 3
           ;     mov B$InsideDataText &FALSE
           ; End_If


L1:         ..If D$edi-4 = 'B$ "'
                mov B$edi-1 '0'   ; > 'B$ 0'

            ..Else_If D$edi-4 = 'U$ "'
                mov B$edi-1 '0'   ; > 'B$ 0'

            ..Else_If B$edi-1 = '0'
                If D$edi-4 = 'B$ 0'
                    mov D$edi ', 0 ' | add edi 3
                Else_If D$edi-4 = 'U$ 0'
                    mov D$edi ', 0 ' | add edi 3
                Else_If W$edi-3 = '" '
                    mov D$edi ', 0 ' | add edi 3
                Else_If W$edi-3 = ', '
                    mov D$edi ', 0 ' | add edi 3
                Else
L1:                 mov D$edi '", 0' | add edi 4
                End_If

          ; Case of 'NextDisLine' in the previous pass:
            ..Else_If D$edi-4 = '    '
                On B$InsideDataText = &TRUE, jmp L1<
                mov D$edi '    ', D$edi+4 '    ', D$edi+8 ', 0' | add edi 11

            ..Else
                mov D$edi '" 0 ' | add edi 3

            ..End_If

            mov B$InsideDataText &FALSE

            cmp ecx D@Format | jle L8>>

            ..If B$ebx <> 0
                .If D@Format = 2
                    If B$ItWasReallyUnicode = &TRUE
                      jmp L1>
                       ; NextDisLine
                       ; mov D$NextStringBreak edi | add D$NextStringBreak 70
                    End_If
                .Else_If B$ItWasReallyAscii = &TRUE
L1:                 On D$FirstDisDataByte = 0, jmp L1>
                    NextDisLine
                    mov D$NextStringBreak edi | add D$NextStringBreak 70
                    mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    ', D$edi+12 '    '
                    add edi 13
                .Else
L1:                 call NextDataDisLine
                    mov D$NextStringBreak edi | add D$NextStringBreak 70
                .End_If
                mov B$edi '"' | inc edi
                mov B$InsideDataText &TRUE
            ..End_If

            jmp L5>>

        ...Else_If al = 9
            mov eax '    ' | stosd | jmp L5>>

        ...Else_If al = '"'  ; 022, 34
            mov D$edi '",02', D$edi+4 '2, "' | add edi 8 | jmp L5>>

        ...Else_If al < ' '
L2:         mov al '.'

        ...Else_If al > 127
            ; ... ???

        ...End_If

        .If B$InsideDataText = &FALSE
            If D$edi-4 = '", 0'
                mov D$edi ', " ' | add edi 3
            Else_If D$edi-4 = 'B$ 0'
                mov D$edi ', " ' | add edi 3
            Else_If D$edi-4 = 'U$ 0'
                mov D$edi ', " ' | add edi 3
            Else_If D$edi-3 = ', 0 '
                mov D$edi ', " ' | add edi 3
            End_If
        .End_If

        stosb

L5:     .If edi > D$NextStringBreak
            If B$InsideDataText = &TRUE
                mov W$edi '",', W$edi+2 CRLF, B$edi+4 '"' | add edi 5
            Else
                NextDisLine
            End_If
           ; mov B$InsideDataText &TRUE
            mov D$NextStringBreak edi |
            add D$NextStringBreak 70 ;88
        .End_If

L5:     sub ecx D@Format | jg L0<<

L9:     mov W$edi '" ' | add edi 2
L8:     mov B$edi ']' | inc edi
EndP

Proc NewWriteAsciiData:
    Argument @Format
    Uses ebx, ecx

        mov D$NextStringBreak edi | add D$NextStringBreak 70

        If D@Format = 1
            mov D$edi 'B$ "'
        Else
            mov D$edi 'U$ "'
        End_If
        add edi 4
        mov B$InsideDataText &TRUE

L0:     mov al B$ebx | add ebx D@Format

L1:     ...If al = CR
            mov D$NextStringBreak edi | add D$NextStringBreak 70
            mov eax D@Format | dec eax
            cmp B$ebx+eax LF | jne L2>
                 add ebx D@Format | sub ecx D@Format | cmp ecx 0 | jle L9>>
L1:         If B$ItWasReallyAscii = &TRUE
                On D$FirstDisDataByte = 0, jmp L1>
             ;   NextDisLine
             ;   mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    ', D$edi+12 '    '
             ;   add edi 13
                mov W$edi CRLF | add edi 2
            Else
L1:             call NextDataDisLine
            End_If

            jmp L5>>

        ...Else_If al = LF
L2:         mov al '.' | inc edx

        ...Else_If al = 0
           ; If B$InsideDataText = &TRUE
           ;     mov D$edi '",  ' | add edi 3
           ;     mov B$InsideDataText &FALSE
           ; End_If


L1:         ..If D$edi-4 = 'B$ "'
                mov B$edi-1 '0'   ; > 'B$ 0'

            ..Else_If D$edi-4 = 'U$ "'
                mov B$edi-1 '0'   ; > 'B$ 0'

            ..Else_If B$edi-1 = '0'
                If D$edi-4 = 'B$ 0'
                    mov D$edi ', 0 ' | add edi 3
                Else_If D$edi-4 = 'U$ 0'
                    mov D$edi ', 0 ' | add edi 3
                Else_If W$edi-3 = '" '
                    mov D$edi ', 0 ' | add edi 3
                Else_If W$edi-3 = ', '
                    mov D$edi ', 0 ' | add edi 3
                Else
L1:                 mov D$edi '", 0' | add edi 4
                End_If

          ; Case of 'NextDisLine' in the previous pass:
            ..Else_If D$edi-4 = '    '
                On B$InsideDataText = &TRUE, jmp L1<
                mov D$edi '    ', D$edi+4 '    ', D$edi+8 ', 0' | add edi 11

            ..Else
                ;mov D$edi '" 0 ' | add edi 3 ; <<<<<<<<<<<<<<<<<<<<<<<<<<<
                mov D$edi '", 0' | add edi 4
                NextDisLine
                ;mov B$edi ' ' | inc edi

            ..End_If

            mov B$InsideDataText &FALSE

            cmp ecx D@Format | jle L8>>

            ..If B$ebx <> 0
                .If D@Format = 2
                    If B$ItWasReallyUnicode = &TRUE
                      jmp L1>
                       ; NextDisLine
                       ; mov D$NextStringBreak edi | add D$NextStringBreak 70
                    End_If
                .Else_If B$ItWasReallyAscii = &TRUE
L1:                 On D$FirstDisDataByte = 0, jmp L1>
                    NextDisLine
                    mov D$NextStringBreak edi | add D$NextStringBreak 70
                    mov D$edi '    ', D$edi+4 '    ', D$edi+8 '    ', D$edi+12 '    '
                    add edi 13
                .Else
L1:                 ;call NextDataDisLine
                    NextDisLine
                    mov D$NextStringBreak edi | add D$NextStringBreak 70
                .End_If
                mov B$edi '"' | inc edi
                mov B$InsideDataText &TRUE
            ..End_If

            jmp L5>>

        ...Else_If al = 9
            mov eax '    ' | stosd | jmp L5>>

        ...Else_If al = '"'  ; 022, 34
            mov D$edi '",02', D$edi+4 '2, "' | add edi 8 | jmp L5>>

        ...Else_If al < ' '
L2:         mov al '.'

        ...Else_If al > 127
            ; ... ???

        ...End_If

        .If B$InsideDataText = &FALSE
            If D$edi-4 = '", 0'
                mov D$edi ', " ' | add edi 3
            Else_If D$edi-4 = 'B$ 0'
                mov D$edi ', " ' | add edi 3
            Else_If D$edi-4 = 'U$ 0'
                mov D$edi ', " ' | add edi 3
            Else_If D$edi-3 = ', 0 '
                mov D$edi ', " ' | add edi 3
            End_If
        .End_If

        stosb

L5:     .If edi > D$NextStringBreak
            If B$InsideDataText = &TRUE
                mov W$edi '",', W$edi+2 CRLF, B$edi+4 '"' | add edi 5
            Else
                NextDisLine
            End_If
           ; mov B$InsideDataText &TRUE
            mov D$NextStringBreak edi |
            add D$NextStringBreak 70 ;88
        .End_If

L5:     sub ecx D@Format | jg L0<<

L9:     mov W$edi '" ' | add edi 2
L8:     mov B$edi ']' | inc edi
EndP


WriteEcxByte:
L0: movzx eax B$esi | inc esi
    mov ebx eax | shr ebx 4
    and eax 0F | and ebx 0F
    mov al B$HexaTable+eax, bl B$HexaTable+ebx
    shl eax 8 | or eax ebx | or eax 020200000 | mov D$edi eax | add edi 3 | loop L0<

ret

WriteImm8:
    movzx ebx B$esi | inc esi | jmp L3>
WriteImm16:
    movzx ebx W$esi | add esi 2 | jmp L3>
WriteImm32:  ; WriteDis32
    On B$OperandSizeOverride = &TRUE, jmp WriteImm16

    lodsd | On B$SimpleScan = &TRUE, jmp WriteEax

    mov ebx eax | sub ebx D$DisImageBase | add ebx D$SectionsMap
    If ebx >= D$EndOfSectionsMap
        ; >>> WriteEax
    Else_If ebx <= D$SectionsMap
        ; >>> WriteEax
    Else
        mov bl B$ebx
        and bl DATAFLAG+VIRTUALFLAG+CODEFLAG | jnz WriteDisRelative
    End_If

WriteEax:
    mov ebx eax

L3: If ebx = 0
        mov B$edi '0' | inc edi | ret
    End_If

    push 0-1

L0: mov eax ebx | shr ebx 4 | and eax 0F

    mov al B$HexaTable+eax
    push eax
    cmp ebx 0 | ja L0<
    mov B$edi '0' | inc edi
L0: pop eax | cmp eax 0-1 | je L9>
    mov B$edi al | inc edi | jmp L0<
L9: ret


WriteSignedImm32:
    mov ebx D$esi | add esi 4 | jmp L0>
WriteSignedImm16:
    movsx ebx W$esi | add esi 2 | jmp L0>
WriteSignedImm8:
    movsx ebx B$esi | inc esi
L0: push 0-1
    test ebx dWordHighbit | jz L0>
        If B$edi-1 = '+'
            mov B$edi-1 '-'
        Else
            mov W$edi '0-' | add edi 2
        End_If
        neg ebx
L0: mov eax ebx | shr ebx 4 | and eax 0F
    mov al B$HexaTable+eax
    push eax
    cmp ebx 0 | ja L0<
    mov B$edi '0' | inc edi
L0: pop eax | cmp eax 0-1 | je L9>
    mov B$edi al | inc edi | jmp L0<
L9: ret

UnlikelyOut:
    push eax
        mov eax D$esi
        sub eax D$DisImageBase | add eax D$SectionsMap
        On eax >= D$EndOfSectionsMap, jmp L8>
        On eax <= D$SectionsMap, jmp L8>
    pop eax
ret

L8: If D$SegmentOverride = 0
      ; In case, for example of 'fs:0', this would be normal
        add B$UnlikelyCode 0F
    End_If
    pop eax | ret

;;
UnlikelyOut:
    push eax
        mov eax D$esi
        sub eax D$DisImageBase | add eax D$SectionsMap
        On eax >= D$EndOfSectionsMap, jmp L8>
        On eax <= D$SectionsMap, jmp L8>
    pop eax
ret

L8: add B$UnlikelyCode 0FF
    pop eax | ret
;;

; Input: bl = Mod (0 / 1 / 2.  - 3 is already done before calling here by a call to
; WriteEregsFromRmBits -)

WriteEffectiveAddressFromModRm:  ; 044 00_100_100    015 00_010_101
    On B$AddressSizeOverride = &TRUE, jmp WriteEffectiveAddressFromModRm16
    ModMask bl To al

    .If al = 0
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'eax ' | add edi 4
        Else_If al = 1 | mov D$edi 'ecx ' | add edi 4
        Else_If al = 2 | mov D$edi 'edx ' | add edi 4
        Else_If al = 3 | mov D$edi 'ebx ' | add edi 4
        Else_If al = 4 | call WriteFromSib
            ..If cl = 0FF
                call WriteBase5dis32
            ..End_If
        Else_If al = 5
            call UnlikelyOut
            call Writedis32
        Else_If al = 6 | mov D$edi 'esi ' | add edi 4
        Else           | mov D$edi 'edi ' | add edi 4
        End_If

    .Else_If al = 1
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | call WriteFromSib
            ..If B$edi-1 <> '+'
                mov B$edi '+' | inc edi
            ..End_If
        Else_If al = 5 | mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | mov D$edi 'esi+' | add edi 4
        Else           | mov D$edi 'edi+' | add edi 4
        End_If

        call WriteSignedImm8 ;| mov W$edi ax | add edi 2  ; OpToHexa

    .Else_If al = 2
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | call WriteFromSib
            ..If B$edi-1 <> '+'
                mov B$edi '+' | inc edi
            ..End_If
        Else_If al = 5 | mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | mov D$edi 'esi+' | add edi 4
        Else           | mov D$edi 'edi+' | add edi 4
        End_If

        call Writedis32

    .Else ; bl = 3
        If W$DisSizeMarker = 'D$'
            call WriteEregsFromRmBits
        Else_If W$DisSizeMarker = 'B$'
            call WriteByteRegsFromRmBits
        Else_If W$DisSizeMarker = 'W$'
            call WriteWordRegsFromRmBits
        End_If

    .End_If

    If W$edi-2 = '00'
        On B$edi-3 = '+', sub edi 3
    End_If
ret


WriteEffectiveAddressFromModRm16:
    inc B$UnlikelyCode

    ModMask bl To al

    .If al = 0
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'bx+s', D$edi+4 'i ' | add edi 6
        Else_If al = 1 | mov D$edi 'bx+d', D$edi+4 'i ' | add edi 6
        Else_If al = 2 | mov D$edi 'bp+s', D$edi+4 'i ' | add edi 6
        Else_If al = 3 | mov D$edi 'bp+d', D$edi+4 'i ' | add edi 6
        Else_If al = 4 | mov D$edi 'si ' | add edi 3
        Else_If al = 5 | mov D$edi 'di ' | add edi 3
        Else_If al = 6 | call Writedis16
        Else           | mov D$edi 'bx ' | add edi 3
        End_If

    .Else_If al = 1
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'bx+s', D$edi+4 'i ' | add edi 6
        Else_If al = 1 | mov D$edi 'bx+d', D$edi+4 'i ' | add edi 6
        Else_If al = 2 | mov D$edi 'bp+s', D$edi+4 'i ' | add edi 6
        Else_If al = 3 | mov D$edi 'bp+d', D$edi+4 'i ' | add edi 6
        Else_If al = 4 | mov D$edi 'si ' | add edi 3
        Else_If al = 5 | mov D$edi 'di ' | add edi 3
        Else_If al = 6 | mov D$edi 'bp ' | add edi 3
        Else           | mov D$edi 'bx ' | add edi 3
        End_If

        call WriteSignedImm8 ;| mov W$edi ax | add edi 2  ; OpToHexa

    .Else_If al = 2
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'bx+s', D$edi+4 'i ' | add edi 6
        Else_If al = 1 | mov D$edi 'bx+d', D$edi+4 'i ' | add edi 6
        Else_If al = 2 | mov D$edi 'bp+s', D$edi+4 'i ' | add edi 6
        Else_If al = 3 | mov D$edi 'bp+d', D$edi+4 'i ' | add edi 6
        Else_If al = 4 | mov D$edi 'si ' | add edi 3
        Else_If al = 5 | mov D$edi 'di ' | add edi 3
        Else_If al = 6 | mov D$edi 'bp ' | add edi 3
        Else           | mov D$edi 'bx ' | add edi 3
        End_If

        call WriteSignedImm16

    .Else ; bl = 3
        If W$DisSizeMarker = 'D$'
            call WriteEregsFromRmBits
        Else_If W$DisSizeMarker = 'B$'
            call WriteByteRegsFromRmBits
        Else_If W$DisSizeMarker = 'W$'
            call WriteWordRegsFromRmBits
        End_If

    .End_If

    If W$edi-2 = '00'
        On B$edi-3 = '+', sub edi 3
    End_If
ret


WriteEffectiveXMMAddressFromModRm:
    ModMask bl To al

    .If al = 0
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'eax ' | add edi 4
        Else_If al = 1 | mov D$edi 'ecx ' | add edi 4
        Else_If al = 2 | mov D$edi 'edx ' | add edi 4
        Else_If al = 3 | mov D$edi 'ebx ' | add edi 4
        Else_If al = 4 | call WriteFromSib | On cl = 0FF, call WriteBase5dis32
        Else_If al = 5 | call UnlikelyOut | call Writedis32
        Else_If al = 6 | mov D$edi 'esi ' | add edi 4
        Else           | mov D$edi 'edi ' | add edi 4
        End_If

    .Else_If al = 1
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | call WriteFromSib | mov B$edi '+' | inc edi
        Else_If al = 5 | mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | mov D$edi 'esi+' | add edi 4
        Else           | mov D$edi 'edi+' | add edi 4
        End_If

        call WriteSignedImm8 ;;;OpToHexa | mov W$edi ax | add edi 2

    .Else_If al = 2
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | call WriteFromSib | mov B$edi '+' | inc edi
        Else_If al = 5 | mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | mov D$edi 'esi+' | add edi 4
        Else           | mov D$edi 'edi+' | add edi 4
        End_If

        call Writedis32

    .Else ; bl = 3
        call WriteXMMregsFromRmBits

    .End_If

    If W$edi-2 = '00'
        On B$edi-3 = '+', sub edi 3
    End_If
ret


WriteEffectiveMMXAddressFromModRm: ; 04  00_000_100
    ModMask bl To al

    .If al = 0
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'eax ' | add edi 4
        Else_If al = 1 | mov D$edi 'ecx ' | add edi 4
        Else_If al = 2 | mov D$edi 'edx ' | add edi 4
        Else_If al = 3 | mov D$edi 'ebx ' | add edi 4
        Else_If al = 4 | call WriteFromSib | On cl = 0FF, call WriteBase5dis32
        Else_If al = 5 | call UnlikelyOut | call Writedis32
        Else_If al = 6 | mov D$edi 'esi ' | add edi 4
        Else           | mov D$edi 'edi ' | add edi 4
        End_If

    .Else_If al = 1
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | call WriteFromSib | mov B$edi '+' | inc edi
        Else_If al = 5 | mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | mov D$edi 'esi+' | add edi 4
        Else           | mov D$edi 'edi+' | add edi 4
        End_If

        call WriteSignedImm8 ;;;OpToHexa | mov W$edi ax | add edi 2

    .Else_If al = 2
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | call WriteFromSib | mov B$edi '+' | inc edi
        Else_If al = 5 | mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | mov D$edi 'esi+' | add edi 4
        Else           | mov D$edi 'edi+' | add edi 4
        End_If

        call Writedis32

    .Else ; bl = 3
        call WriteMMXregsFromRmBits

    .End_If

    If W$edi-2 = '00'
        On B$edi-3 = '+', sub edi 3
    End_If
ret
____________________________________________________________________________________________

[NoDirectAccess: B$ ' ; Not accessed by direct CALL or JMP.', 0]

[ActualDisCodePointer: ?    BackStep: ?    LabelWritten: ?   LastWrittenLabel: ?]

WriteDisCodeLabel: ; 'WriteOneDataLabel'
    On esi = D$LastWrittenLabel, ret
    mov D$LastWrittenLabel esi

    mov eax esi | ToStringsMapFrom UserPeStart, eax
    .If D$eax <> 0
        push esi
            If D$eax = EntryPointName
                zCopy D$eax
            Else_If D$eax = MainWindowProcName
                mov W$edi CRLF | add edi 2
                zCopy D$eax
                mov B$edi ':' | inc edi
            End_If
        pop esi
    .End_If

    mov eax esi | sub eax D$UserPeStart | add eax D$DisImageBase
  ; >>> eax = RVA. ebx = 'RoutingMap' pointer.

   ; call BuildCommentedCodeReference ebx ; made by Guga

    test B$ebx EXPORTNODE | jz L0>
        call WriteExportedFunctionLabel

L0: mov ecx ebx, ebx eax
    push ebx
        If W$edi-3 <> '::'
            mov W$edi CRLF | add edi 2
        End_If

        mov D$edi 'Code' | add edi 4
        push 0-1

L0:     mov eax ebx | shr ebx 4 | and eax 0F
        add eax '0' | On eax > '9', add eax 7
        push eax
        cmp ebx 0 | ja L0<
        mov B$edi '0' | inc edi
L0:     pop eax | cmp eax 0-1 | je L1>
        mov B$edi al | inc edi | jmp L0<

L1: pop eax | push eax

    mov eax esi | ToStringsMapFrom UserPeStart, eax
    .If D$eax <> 0
        If D$eax = EntryPointName
            ;
        Else_If D$eax = MainWindowProcName
            ;
        Else
            push esi
                zCopy D$eax
            pop esi
        End_If
    .End_If

    mov W$edi ': ' | add edi 2

L2: pop eax
    mov ecx 10, edx 0 | div ecx | add dl '0'
    and al 001111 | add al 'A'
    mov B$edi al, B$edi+1 dl, B$edi+2 ':' | add edi 3

L9: ret


WriteExportedFunctionLabel:
  ; >>> eax = RVA. ebx = 'RoutingMap' pointer.       'ExportSectionComments' 'CheckExport'

    push eax, ebx, esi
        sub eax D$DisImageBase

      ; May be a wrong Flag resulting from a DLL Name pointer saved inside the
      ; 'RoutingMap'. If so, the relative 'SectionsMap' Byte is 'IMPORTFLAG':
        mov ecx D$NumberOfDisExportedFunctions | cmp ecx 0 | je L9>>

        mov esi D$DisExportFunctionsPointers, ebx D$DisExportNamesPointers

        .If esi < D$UserPeStart
            ; nop
        .Else_If esi > D$UserPeEnd
            ; nop
        .Else
          ; Scan the Functions Pointers, to get the Ordinal Indice:
            mov edx D$UserPeEnd | sub edx 4
L0:         cmp esi edx | jae L9>>
            cmp D$esi eax | je L1>
K0:             add esi 4 | add ebx 4 | loop L0<
                    jmp L9>>

L1:         push eax, ebx, ecx, edx, esi

            mov eax D$NumberOfDisExportedFunctions | sub eax ecx

          ; Search the Ordinal Number, in the Ordinal Table
            mov esi D$DisExportOrdinal, ecx D$NumberOfDisExportedFunctions

L2:         cmp esi edx | jae L8>>
            cmp W$esi ax | je L3>
              ; Ordinal are Words:
                add esi 2 | loop L2<
                    jmp L8>>

L3:         mov eax D$NumberOfDisExportedFunctions | sub eax ecx

          ; Get the parallel Pointer, in the Functions Pointers Table:
            mov esi D$DisExportNamesPointers | shl eax 2 | add esi eax
            mov esi D$esi | add esi D$UserPeStart

            On esi < D$UserPeStart, jmp L8>>
                On esi > D$UserPeEnd, jmp L8>>
                    ;sub edi 4

                    While B$edi-1 = ' ' | dec edi | End_While
                    If B$edi-3 > ' '
                        mov W$edi CRLF | add edi 2
                    End_If
                    push esi
                        mov bl 0, dl 0
                        While B$esi <> 0
                            lodsb
                                If al = '@'
                                    On dl = 0, mov al 'a', bl 1
                                Else_If al = '$'
                                    mov al 'S', bl 1
                                Else_If al = '$'
                                    mov al 'S', bl 1
                                Else_If al <> '_'
                                    inc dl
                                End_If
                            stosb
                        End_While
                        mov D$edi '::  ' | add edi 3
                    pop esi
                    If bl = 1
                        push esi | zCopy {'; The_real_Name_was: ', 0} | pop esi
                        While B$esi <> 0 | movsb | End_While
                        mov D$edi '::  ' | add edi 3
                        mov W$edi CRLF | add edi 2
                    End_If

                    pop esi, edx, ecx, ebx, eax | jmp K0<<

L8:             pop esi, edx, ecx, ebx, eax
        .End_If

L9: pop esi ebx, eax
ret
____________________________________________________________________________________________

; Provides Local Labels, depending on the Code Pointer Value, in the range of
; A0-A9 to P0-P9:

WriteLocalLabelFromEax:
    mov ecx 10, edx 0 | div ecx | add dl '0'
    and al 001111 | add al 'A'
    mov B$edi al, B$edi+1 dl, B$edi+2 ':' | add edi 3
ret


[BadDecodeText: B$ "
 ; Downward Chunk would be bad if previous one was good. On Reference, aligning back: "
 BackSteps: "          
"
 BadDecodeTextLen: Len
 CommentItHexa: "; Get the Bytes Values with the Dialog option: [With Commented Hexa Code].
 ", CommentItHexaLen: Len]

BadDecode:
    push eax, ebx, ecx, esi
        push edi
            mov D$BackSteps '    ', D$BackSteps+4 '    '
            mov edi BackSteps
            mov eax esi | sub eax ebx | call WriteEax
        pop edi

        mov esi BadDecodeText, ecx D$BadDecodeTextLen | rep movsb

        If B$WithCommentedHexa = &FALSE
            mov esi CommentItHexa, ecx D$CommentItHexaLen | rep movsb
        End_If
    pop esi, ecx, ebx, eax
ret


[CALLInstruction: ?    MovOrJmpImmInstruction: ?]

RelativeToAbsolute:
 ; When called, eax = relative Dis
    mov eax D$LastCodeRef
    add eax esi | sub eax D$UserPeStart | add eax D$DisImageBase

    push eax
        sub eax D$DisImageBase | add eax D$SectionsMap

        .If eax < D$EndOfSectionsMap
            If eax > D$SectionsMap
                jmp L1>
            End_If
        .End_If

        add D$UnlikelyCode 0F
L1: pop eax
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

Dis_St0Sti_or_Fmem:
    ModMask bl to al | On al <> 3, jmp EndWith.F.mem

WriteSt0Sti: ; (Byte in bl).
    mov D$edi 'ST0 ', D$edi+4 'ST0 '
    RmMask bl to al
    add B$edi+6 al
    add edi 7
    mov B$DisFlag DISDONE+DISLINEOVER
ret


WriteStiSt0:
    mov D$edi 'ST0 ', D$edi+4 'ST0 '
    RmMask bl to al
    add B$edi+2 al
    add edi 7
    mov B$DisFlag DISDONE+DISLINEOVER
ret


WriteSti:
    mov D$edi 'ST0 '
    RmMask bl to al
    add B$edi+2 al
    add edi 3
    mov B$DisFlag DISDONE+DISLINEOVER
ret
____________________________________________________________________________________________



;;; 'Dis_mmx2_m128__xmm1'
; When called, ESI position is on the Mod/Reg/Rm Byte.

Proc MarkSSEdata:
    Arguments @Type
    Uses esi

        On B$WeAreInTheCodeBox = &TRUE, ExitP

      ; Remove the 'reg' bits from the mod/r/m byte:
        lodsb | and al 00_11_000_111 | On al <> 00_000_101, ExitP

        lodsd | sub eax D$DisImageBase | add eax D$RoutingMap

        .If eax < D$RoutingMap
            mov B$UnlikelyCode 5

        .Else_If eax > D$EndOfRoutingMap
            mov B$UnlikelyCode 5

        .Else
            or B$eax LABEL+EVOCATED

            sub eax D$RoutingMap | add eax D$SizesMap

            If D@Type = SSE_4_F
                mov D$eax FP4, D$eax+4 FP4, D$eax+8 FP4, D$eax+12 FP4

L4:             sub eax D$SizesMap | add eax D$SectionsMap
                On D$eax <> VIRTUALFLAG,
                    mov D$eax FOURDATAFLAGS, D$eax+4 FOURDATAFLAGS,
                        D$eax+8 FOURDATAFLAGS, D$eax+12 FOURDATAFLAGS

            Else_If D@Type = SSE_2_R
                mov D$eax FP8, D$eax+8 FP8 | jmp L4<

            End_If

        .End_If
EndP

[SSE_4_F 1, SSE_2_R 2, SSE_1_R 3, SSE_1_F 4, SSE_2_F 5,
 SSE_4_D 6, SSE_2_D 7, SSE_1_D 8, SSE_1_Q 9]

;;
  List of SSE Mnemonics >>> Types:  (call MarkSSEdata )
  
  addpd     call MarkSSEdata SSE_2_R
  addps     call MarkSSEdata SSE_4_F
  addsd     call MarkSSEdata SSE_1_R
  addss     call MarkSSEdata SSE_1_F
  addsubpd  call MarkSSEdata SSE_2_R
  addsubps  call MarkSSEdata SSE_4_F
  andnpd    call MarkSSEdata SSE_2_R
  andnps    call MarkSSEdata SSE_4_F
  andpd     call MarkSSEdata SSE_2_R
  andps     call MarkSSEdata SSE_4_F
  cmp..ps   call MarkSSEdata SSE_4_F opc2
  cmp..ss   call MarkSSEdata SSE_2_F
  comisd    call MarkSSEdata SSE_1_R
  comiss    call MarkSSEdata SSE_1_F
  cvtdq2pd  call MarkSSEdata SSE_2_D
  cvtdq2ps  call MarkSSEdata SSE_4_D
  cvtpd2dq  call MarkSSEdata SSE_2_R   ; F2 0F E6 /r opf2
  cvtpd2pi  call MarkSSEdata SSE_2_R
  cvtpd2ps  call MarkSSEdata SSE_2_R
  cvtpi2pd  call MarkSSEdata SSE_2_D
  cvtpi2ps  call MarkSSEdata SSE_2_D
  cvtps2dq  call MarkSSEdata SSE_4_F
  cvtps2pd  call MarkSSEdata SSE_2_F
  cvtps2pi  call MarkSSEdata SSE_2_F
  cvtsd2si  call MarkSSEdata SSE_1_R
  cvtsd2ss  call MarkSSEdata SSE_1_R
  cvtsi2sd  call MarkSSEdata SSE_1_D
  cvtsi2ss  call MarkSSEdata SSE_1_D
  cvtss2sd  call MarkSSEdata SSE_1_F
  cvtss2si  call MarkSSEdata SSE_1_F
  cvttpd2dq call MarkSSEdata SSE_2_R
  cvttpd2pi call MarkSSEdata SSE_2_R
  cvttps2dq call MarkSSEdata SSE_4_F
  cvttps2pi call MarkSSEdata SSE_2_F
  cvttsd2si call MarkSSEdata SSE_1_R
  cvttss2si call MarkSSEdata SSE_1_F
  divpd     call MarkSSEdata SSE_2_R
  divps     call MarkSSEdata SSE_4_F
  divsd     call MarkSSEdata SSE_1_R
  divss     call MarkSSEdata SSE_1_F
  haddpd    call MarkSSEdata SSE_2_R
  haddps    call MarkSSEdata SSE_4_F
  hsubpd    call MarkSSEdata SSE_2_R
  hsubps    call MarkSSEdata SSE_4_F
  maxpd     call MarkSSEdata SSE_2_R
  maxsd     call MarkSSEdata SSE_1_R
  maxss     call MarkSSEdata SSE_1_F
  minpd     call MarkSSEdata SSE_2_R
  minps     call MarkSSEdata SSE_4_F
  minsd     call MarkSSEdata SSE_1_R
  minss     call MarkSSEdata SSE_1_F
  movapd    call MarkSSEdata SSE_2_R
  movaps    call MarkSSEdata SSE_4_F
  movddup   call MarkSSEdata SSE_1_Q
  movhpd    call MarkSSEdata SSE_1_R
  movhps    call MarkSSEdata SSE_2_F
  movlpd    call MarkSSEdata SSE_1_R
  movlps    call MarkSSEdata SSE_2_F
  movshdup  call MarkSSEdata SSE_4_F
  movsldup  call MarkSSEdata SSE_4_F
  movntpd   call MarkSSEdata SSE_2_R
  movntps   call MarkSSEdata SSE_4_F
  movss     call MarkSSEdata SSE_1_R
  movupd    call MarkSSEdata SSE_2_R
  movups    call MarkSSEdata SSE_4_F
  mulpd     call MarkSSEdata SSE_2_R
  mulps     call MarkSSEdata SSE_4_F
  mulsd     call MarkSSEdata SSE_1_R
  mulss     call MarkSSEdata SSE_1_F
  orpd      call MarkSSEdata SSE_2_R
  orps      call MarkSSEdata SSE_4_F
  rcpps     call MarkSSEdata SSE_4_F
  rcpss     call MarkSSEdata SSE_4_F
  rsqrtps   call MarkSSEdata SSE_4_F
  rsqrtss   call MarkSSEdata SSE_4_F
  shufpd    call MarkSSEdata SSE_2_R
  shufps    call MarkSSEdata SSE_4_F
  sqrtpd    call MarkSSEdata SSE_2_R
  sqrtps    call MarkSSEdata SSE_4_F
  sqrtsd    call MarkSSEdata SSE_2_R
  sqrtss    call MarkSSEdata SSE_4_F
  subpd     call MarkSSEdata SSE_2_R
  subps     call MarkSSEdata SSE_4_F
  subsd     call MarkSSEdata SSE_2_R
  subss     call MarkSSEdata SSE_4_F
  ucomisd   call MarkSSEdata SSE_2_R
  ucomiss   call MarkSSEdata SSE_4_F
  unpckhpd  call MarkSSEdata SSE_2_R
  unpckhps  call MarkSSEdata SSE_4_F
  unpcklpd  call MarkSSEdata SSE_2_R
  unpcklps  call MarkSSEdata SSE_4_F
  xorpd     call MarkSSEdata SSE_2_R
  xorps     call MarkSSEdata SSE_4_F
;;


____________________________________________________________________________________________
____________________________________________________________________________________________

; The Encode / Decode Dialog (Tool Menu).
____________________________________________________________________________________________
____________________________________________________________________________________________

ViewEncoding:
    call 'USER32.DialogBoxParamA' D$hinstance, 28000, &NULL, EncodingProc, &NULL
ret

[EncodeEditHandle: ?    EncodingDialogHandle: ?] [ EncodeHelp: 'Code_Viewer' 0]
[ZeroString: ?]

; This is the Source For Encoding (Upper Edite Control);
[EncodeSourceMargin: B$ CR LF CR LF CR LF CR LF CR LF CR LF]
[EncodeSource: B$ "[DATA: 0 0 0 0]
LABEL0:
L0: ", EncodeText: "                                                                  
L1:
Label1:
"]
; This is to ensure that the Assembler do not overwrite the downward Data when ajusting,
; for example, the Asm Source ending CR/LF(s):
[EncodeSecurity: 0 #10]

; This is the second Edit Control showing Text Hexa Code
[HexaCodeText: ? #10]

; This is the third read only EditBox for Disassembly:
[DummyDecodeText: ? ?][DecodeText: ? #40] ; 40+2 >>> 168

; This is for storing Binary Hexa of Code when only Disassembling:
[DecodeOnlyHexa: ? #10]

Proc EncodingProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ...If D@Message = &WM_INITDIALOG
        move D$EncodingDialogHandle D@Adressee
        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        call 'USER32.GetDlgItem' D@Adressee 13 | mov D$EncodeEditHandle eax
        call 'USER32.SetFocus' eax
        jmp L8>>

    ...Else_If D@Message = &WM_COMMAND
        mov eax D@wParam | and D@wParam 0FFFF | shr eax 16
        ..If eax = &CBN_SELCHANGE

        ..Else_If D@wParam = &IDCANCEL
            mov D$EncodingDialogHandle 0
            call 'USER32.EndDialog' D@Adressee 0

        ..Else_If D@wParam = &IDOK
            call 'USER32.GetFocus' | call 'USER32.GetDlgCtrlID' eax
            On eax = 16, jmp L3>

            mov eax '    ', edi EncodeText, ecx 15 | rep stosd
            call 'USER32.GetDlgItemTextA' D@Adressee, 13, EncodeText, 60
            On eax = 0, jmp L3>

            mov B$EncodeText+eax ' ' | call EncodeDecode

            call 'USER32.SetDlgItemTextA' D@Adressee, 16, HexaCodeText
            call 'USER32.SetDlgItemTextA' D@Adressee, 17, DecodeText

        ..Else_If D@wParam = 3
L3:         call 'USER32.GetDlgItemTextA' D@Adressee, 16, HexaCodeText, 80

            call DecodeOnly

            call 'USER32.SetDlgItemTextA' D@Adressee, 13, ZeroString
            call 'USER32.SetDlgItemTextA' D@Adressee, 17, DecodeText
            call 'USER32.SetDlgItemTextA' D@Adressee, 16, HexaCodeText


        ..Else_If D@wParam = &IDHELP
            call Help, B_U_AsmName, EncodeHelp, ContextHlpMessage

        ..End_If

    ...Else_If D@Message = &WM_CTLCOLOREDIT
        jmp L1>

    ...Else_If D@Message = &WM_CTLCOLORLISTBOX
L1:     call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | jmp L9>

    ...Else
L8:     popad | mov eax &FALSE | jmp L9>

    ...End_If

    popad | mov eax &TRUE

L9: EndP


[WeAreInTheCodeBox: ?]

DecodeOnly:
    mov B$WeAreInTheCodeBox &TRUE, B$SimpleScan &TRUE
    mov esi HexaCodeText

    While B$esi > 0
        On B$esi <= ' ', mov B$esi Space
        inc esi
    End_While
    mov B$esi Space, D$esi+1 0

    mov esi HexacodeText, edi DecodeOnlyHexa

    .While B$esi > 0
        mov ebx 0,  edx 0, ecx 0, eax 0

        While B$esi < '0'
            inc esi | On B$esi = 0, jmp L9>
        End_While
        While B$esi = '0'
            inc esi
            On B$esi <= Space, jmp L8>
            On B$esi = 0, jmp L9>
        End_While

L0:     lodsb | On al > 'Z', and eax (not 32) | cmp al Space | jbe L8>
            sub al '0' | cmp al 9 | jbe L2>
                sub al 7
L2:     shld edx ebx 4 | shl ebx 4 | or bl al
        cmp edx ecx | jb L7>
        mov ecx edx
        cmp al 0F | jbe L0<

L7:     Beep | ret

L8:     mov eax ebx
        cmp eax 0FF | ja L7<

        stosb
    .End_While
L9:  mov D$edi 0

  ; Disassemble: (DisMain)
    mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
    mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
    mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE
    mov esi DecodeOnlyHexa, edi DecodeText
L0: movzx eax B$esi | inc esi | call D$DisOp1+eax*4
; WriteImm32 WeAreInTheCodeBox WriteDisRelative
    On B$DisFlag = DISDONE, jmp L0<
    mov D$edi 0

  ; Re-write the Hexa Code Text (simply for clean up and striping extra-Bytes):
    mov edx esi, esi DecodeOnlyHexa, edi HexacodeText
    While esi < edx
        movzx eax B$esi | inc esi
        mov ebx eax | shr ebx 4
        and eax 0F | and ebx 0F
        mov al B$HexaTable+eax, bl B$HexaTable+ebx
        shl eax 8 | or eax ebx | or eax 020200000 | stosd
    End_While
    mov D$edi 0

  ; In case of text organisation (sub edi 6, for example), we reset:
    If D$DummyDecodeText+4 <> 0
        mov eax DecodeText
        While B$eax-1 > 0
            dec eax
        End_While
        mov ecx DecodeText | sub ecx eax
        mov esi DecodeText | add esi 160-1 | mov edi esi | sub esi ecx
        std
L0:         movsb | cmp edi DecodeText | jae L0<
        cld
        mov D$DummyDecodeText 0, D$DummyDecodeText+4 0
    End_If

    mov B$WeAreInTheCodeBox &FALSE, B$SimpleScan &FALSE
ret


[LastDisVirtualData: ?]

____________________________________________________________________________________________
____________________________________________________________________________________________



TITLE DisInter

;;
  With each successful Disassembly, the Disassembler outputs 4 Files:
  
  * 3 of them are simple copies of 'SectionsMap', 'RoutingMap' and 'SizesMap'.
  
  * The 4th one is the 'ForcedRecordsTable', storing, at least, a header for
    'DisImageBase', and followed by the user defined Records, as edited with
    the 'ForcedFlags' Dialog, if any.
    
  -----------------
  The 
  
  'ForcedFlags' >>> 'ForcedFlagsProc'
  
  is called from the Float menu
  ('RightClickOnBlock' >>> DisLabel >>> Float Menu)
  
  When this interface is called, 'DisLabelTypeWas' says if this was CODEFLAG or
  DATAFLAG, 'DisAddressWas' holds the dWord Value of the selected Label (ex: 040506B),
  and 'CopyOfLabelHexa' is the Hexa Text form of the Label Number. Same is it for
  'NextDisAddressWas' and 'CopyOfNextLabelHexa', that hold the next matching Label,
  to assume then end of a Chunk, in Strings Cases.
  
  'ForcedFlagsProc' is the main Procedure that:
  
  * Reads the Files: 'MyAppSection.map', 'MyAppRouting.map', 'MyAppSize.map',
                     and, also, the 'MyAppForced.map' File.
                     
    These 3 Files are images of the Disassembler Tables, saves at the end of each
    Disassembling. When 'ForcedFlagsProc' reads them, this is just to get the
    actual Flags of the Bytes targetted by the last Location the User selected
    in the Disassembled Source. These Flags are just read to initialize the Dialog.
;;

____________________________________________________________________________________________
____________________________________________________________________________________________

; Main of the Forced Flag Box: 'ForcedFlags' >>> 'ForcedFlagsProc'.

ForcedFlags:
    call GetOriginalDisFileNameFromSource

    If B$SaveFilter <> 0
        call 'USER32.DialogBoxParamA' D$hInstance, 2500, D$hwnd, ForcedFlagsProc, &NULL

        On eax = &TRUE, call ReRunDisassembler
    Else
        call 'USER32.MessageBoxA', D$hwnd, {"The expected Original File Name was not found,
at the Top of this Source" 0}, {'Failure of Edition', 0}, 0
    End_If
ret


[ForcedFlagsProcHandle: ?]

; Tag Dialog 2500

Proc ForcedFlagsProc:
    Arguments @Adressee, @Message, @wParam, @lParam

    pushad

    ..If D@Message = &WM_INITDIALOG
        move D$ForcedFlagsProcHandle D@Adressee
        mov B$ForcedFlagsModified &FALSE

        call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &EM_SETLIMITTEXT, 8, 0
        call 'USER32.SendDlgItemMessageA' D@Adressee, 11, &EM_SETLIMITTEXT, 8, 0

        call 'USER32.SetClassLongA' D@Adressee &GCL_HICON D$wc_hIcon
        mov eax &TRUE

        call InitForcedFlagsDialog

        If D$ForcedRecordsTable = 0
            call 'USER32.MessageBoxA', D@Adressee,
            {'The Forced Records File was not found', 0}, {'Failure of Edition', 0}, 0
            call 'User32.EndDialog' D@Adressee, &FALSE
        End_If

    ..Else_If D@Message = &WM_CLOSE
        call 'User32.EndDialog' D@Adressee, &FALSE

    ..Else_If D@Message = &WM_COMMAND
        .If D@wParam = &IDCANCEL
            call 'User32.EndDialog' D@Adressee, &FALSE

        .Else_If D@wParam = &IDOK
            call RegisterUserFlags
            If B$BadUserFlag = &FALSE
                call WriteForcedRecordsFile  ; ReadForcedRecordsFile
                call 'User32.EndDialog' D@Adressee, &TRUE
            End_If

        .Else_If D@wparam = ID_HELP
            call Help, B_U_AsmName, DisMap, ContextHlpMessage

      ; [x] Code Flag
        .Else_If D@wparam = 10
            call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &BM_GETCHECK, 0, 0
            push eax
                xor eax &TRUE
                call 'USER32.SendDlgItemMessageA' D@Adressee, 11, &BM_SETCHECK, eax, 0
            pop eax
            If eax = &TRUE
                call DisableDisDataFlags
              ; Code cannot be 'POINTER':
                call 'USER32.SendDlgItemMessageA' D@Adressee, 23, &BM_SETCHECK, &FALSE, 0
              ; But should be 'INSTRUCTION'
                call 'USER32.SendDlgItemMessageA' D@Adressee, 20, &BM_SETCHECK, &TRUE, 0
            Else
                call EnableDisDataFlags
              ; Data cannot be 'INSTRUCTION', 'EXPORTED':
                call 'USER32.SendDlgItemMessageA' D@Adressee, 20, &BM_SETCHECK, &FALSE, 0
                call 'USER32.SendDlgItemMessageA' D@Adressee, 22, &BM_SETCHECK, &FALSE, 0
            End_If
      ; [x] Data Flag
        .Else_If D@wparam = 11
            call 'USER32.SendDlgItemMessageA' D@Adressee, 11, &BM_GETCHECK, 0, 0
            xor eax &TRUE
            push eax
                call 'USER32.SendDlgItemMessageA' D@Adressee, 10, &BM_SETCHECK, eax, 0
            pop eax
            xor eax &TRUE
            If eax = &TRUE
                call EnableDisDataFlags
              ; Data cannot be 'INSTRUCTION', 'EXPORTED':
                call 'USER32.SendDlgItemMessageA' D@Adressee, 20, &BM_SETCHECK, &FALSE, 0
                call 'USER32.SendDlgItemMessageA' D@Adressee, 22, &BM_SETCHECK, &FALSE, 0
            Else
                call DisableDisDataFlags
              ; Code cannot be 'POINTER':
                call 'USER32.SendDlgItemMessageA' D@Adressee, 23, &BM_SETCHECK, &FALSE, 0
            End_If
       ; [x] Instruction
         .Else_If D@wparam = 20
            call CheckForcedRouting 20
       ; [x] Label
         .Else_If D@wparam = 21
            call CheckForcedRouting 21
       ; [x] Exported
         .Else_If D@wparam = 22
            call CheckForcedRouting 22
       ; [x] Pointer
         .Else_If D@wparam = 23
            call CheckForcedRouting 23

      ; [x] Previous
        .Else_If D@wparam = 60
            call DecForcedRecord

      ; [x] Next
        .Else_If D@wparam = 62
            call IncForcedRecord

      ; [x] Delete This Record
        .Else_If D@wparam = 70
            call DeleteForcedRecord
            If D$DisForcedRecordIndice = 0
                call WriteForcedRecordsFile
                call 'User32.EndDialog' D@Adressee 0
            End_If

        .Else_If D@wparam < 30
          ; nop

      ; [x] Byte / Word / Dword / FPU4/8/10
        .Else_If D@wparam < 36
            call Disable D$ForcedFlagsProcHandle, 51

      ;; [x] String or Unicode String
        .Else_If D@wparam < 38
            call Enable D$ForcedFlagsProcHandle, 51
            call SetForcedNextAddressEditControl

        .End_If

    ..Else_If D@Message = &WM_CTLCOLOREDIT
        call 'USER32.SendMessageA' D@lParam, &EM_SETSEL, 0-1, 0
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | ExitP

    ..Else
        popad | mov eax &FALSE | jmp L9>

    ..End_If

    popad | mov eax &TRUE

L9: EndP
____________________________________________________________________________________________

; For coherency of the Routing Flags:

Proc CheckForcedRouting:
    Argument @ID

        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, D@ID, &BM_GETCHECK, 0, 0

        .If eax = &TRUE
            If D@ID < 23
              ;  >>> Cannot be Pointer:
                call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 23,
                                                  &BM_SETCHECK, &FALSE, 0
            Else
              ; 23 (Pointer) >>> Cannot be Instruction, Exported:
                call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 20,
                                                  &BM_SETCHECK, &FALSE, 0
                call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 22,
                                                  &BM_SETCHECK, &FALSE, 0
              ; But must be a dWord (ID 32):
                call CheckForcedData 32

            End_If
        .End_If
EndP


; Tag Dialog 2500

Proc CheckForcedData:
    Argument @ID

        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 30, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 31, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 32, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 33, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 34, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 35, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 36, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 37, &BM_SETCHECK, &FALSE, 0

        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, D@ID, &BM_SETCHECK, &TRUE, 0
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[MapFileHandle: ?]

; Called from DisMain:

WriteMapFiles:
    pushad

    call TakeCopyOfDisName

    push edi
        mov D$edi 'Sect', D$edi+4 'ion.', D$edi+8 'map'

        call 'KERNEL32.CreateFileA' DisassemblyMapName, &GENERIC_WRITE, 0, 0, &CREATE_ALWAYS,
                                    &FILE_ATTRIBUTE_NORMAL, 0

        If eax <> &INVALID_HANDLE_VALUE
            mov D$MapFileHandle eax

            mov ecx D$EndOfSectionsMap | sub ecx D$SectionsMap

            call 'KERNEL32.WriteFile' D$MapFileHandle, D$SectionsMap, ecx,
                                      NumberOfReadBytes, 0

            call 'KERNEL32.CloseHandle' D$MapFileHandle
        End_If

    pop edi
    push edi
        mov D$edi 'Rout', D$edi+4 'ing.', D$edi+8 'map'

        call 'KERNEL32.CreateFileA' DisassemblyMapName, &GENERIC_WRITE, 0, 0, &CREATE_ALWAYS,
                                    &FILE_ATTRIBUTE_NORMAL, 0

        If eax <> &INVALID_HANDLE_VALUE
            mov D$MapFileHandle eax

            mov ecx D$EndOfSectionsMap | sub ecx D$SectionsMap

            call 'KERNEL32.WriteFile' D$MapFileHandle, D$SectionsMap, ecx,
                                      NumberOfReadBytes, 0

            call 'KERNEL32.CloseHandle' D$MapFileHandle
        End_If

    pop edi
    push edi
        mov D$edi 'Size', D$edi+4 '.map', B$edi+8 0

        call 'KERNEL32.CreateFileA' DisassemblyMapName, &GENERIC_WRITE, 0, 0, &CREATE_ALWAYS,
                                    &FILE_ATTRIBUTE_NORMAL, 0

        If eax <> &INVALID_HANDLE_VALUE
            mov D$MapFileHandle eax

            mov ecx D$EndOfSectionsMap | sub ecx D$SectionsMap

            call 'KERNEL32.WriteFile' D$MapFileHandle, D$SectionsMap, ecx,
                                      NumberOfReadBytes, 0

            call 'KERNEL32.CloseHandle' D$MapFileHandle
        End_If
    pop edi

    popad
ret
____________________________________________________________________________________________
;;
  Called from DisMain.
  
  Must be executed in all case. For example, a user can change the AddressBase from
  exe to dll, without having yet used any Forced Record...
;;
WriteForcedRecordsFileBase:
  ; Is this usefull? (Case of empty File?)
    call ReadForcedRecordsFile

    If D$ForcedRecordsTable = 0
        VirtualAlloc ForcedRecordsTable, 010
    End_If

  ; Really needed:
    mov edi D$ForcedRecordsTable, eax D$DisImageBase | stosd

    call WriteForcedRecordsFile

    VirtualFree D$ForcedRecordsTable
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

DecForcedRecord:
    If D$DisForcedRecordIndice > 1
        call GetForcedDialogFlags
        call RegisterForcedRecord
        dec D$DisForcedRecordIndice
        call SetForcedFlagsFromForcedRecord
        call SetSourceToForcedRecord
    End_If
ret

IncForcedRecord:
    call GetForcedRecordPointer | mov esi eax | add esi FORCED_RECORD_LENGHT

    If D$esi <> 0
        call GetForcedDialogFlags
        call RegisterForcedRecord
        inc D$DisForcedRecordIndice
        call SetForcedFlagsFromForcedRecord
        call SetSourceToForcedRecord
    End_If
ret

DeleteForcedRecord:
    call GetForcedRecordPointer | mov esi eax

    On D$DisForcedRecordIndice > 1, dec D$DisForcedRecordIndice

    mov edi esi | add esi FORCED_RECORD_LENGHT

L0: movsd | movsd | movsd | cmp D$esi 0 | ja L0<

    mov D$edi 0, D$edi+4 0, D$edi+8 0

    sub D$ForcedRecordsSize FORCED_RECORD_LENGHT

    call SetForcedFlagsFromForcedRecord
    call SetSourceToForcedRecord
ret

; Called by the Disassembler, when the 'WithForcedMapFile' is set to &FALSE:

DeleteForcedFile:
    call TakeCopyOfDisName
    mov D$edi 'Forc', D$edi+4 'ed.m', D$edi+8 'ap'

    call 'KERNEL32.DeleteFileA' DisassemblyMapName
ret
____________________________________________________________________________________________

RegisterForcedRecord:
    call GetForcedRecordPointer | mov ebx eax

    move D$ebx+FORCED_RECORD_OFFSET1 D$DisAddressWas
    move D$ebx+FORCED_RECORD_OFFSET2 D$NextDisAddressWas
    call ForcedFlagsIntoEax | mov D$ebx+FORCED_RECORD_FLAGS eax
ret


; Returns a Pointer to the actual Forced Record:

GetForcedRecordPointer:
    push ecx
        mov eax D$DisForcedRecordIndice | dec eax
        mov ecx FORCED_RECORD_LENGHT | mul ecx
        add eax FORCED_FILE_HEADERLENGHT
        add eax D$ForcedRecordsTable
    pop ecx
ret
____________________________________________________________________________________________

[SearchCopyOfForcedLabel: ? #4]

; Moves the Disassembly Source to the actually edited Forced Label ([Previous]/[Next]):

SetSourceToForcedRecord:
    mov esi CopyOfLabelHexa, edi SearchCopyOfForcedLabel

    If B$UserSectionFlag = CODEFLAG
        mov eax 'Code'
    Else
        mov eax 'Data'
    End_If
    stosd
    mov ebx 4
    While B$esi <> 0 | movsb | inc ebx | End_While | mov B$edi 0

  ; We now have a Copy of the Edited Record Label in 'SearchCopyOfForcedLabel'.
  ; call for a Search:
    push ebx
        call RestoreRealSource
    pop ebx
    mov edx SearchCopyOfForcedLabel

    call InternSearch | call AskForRedrawNow

    If B$BlockInside = &TRUE
        mov B$BlockInside &FALSE
        mov esi D$CurrentWritingPos | dec esi | dec esi | dec esi | call InternalRightClick
        mov B$BlockInside &TRUE
    End_If

    call SetPartialEditionFromPos
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

[DisLabelTypeWas: ?    DisAddressWas: ?  NextDisAddressWas: ?
 CopyOfLabelHexa: ? ? ? ? ? ? ? ? ? ?
 CopyOfNextLabelHexa: ? ? ? ? ? ? ? ? ? ?]

[DisassemblyMapName: B$ ? #&MAXPATH]

TakeCopyOfDisName:
    mov esi SaveFilter, edi DisassemblyMapName
    While B$esi <> 0 | movsb | End_While | mov B$edi 0
    While B$edi <> '.' | dec edi | End_While
  ; Returns with edi >>> '.'
ret

[OriginalFileComment: B$ "
; Do not remove this Comment. It is used by the Disassembler for the interactive
; Editions of the Disassemblies Flags. Without, it would fail to guess which was
; the original File Name:
;
; "

OriginalDisFilePath: 0]

WriteOriginalFileNameInSource:
    mov esi OriginalFileComment, ecx OriginalDisFilePath
    sub ecx OriginalFileComment | rep movsb

    mov esi SaveFilter | While B$esi <> 0 | movsb | End_While

    mov D$edi CRLF2 | add edi 4
ret


GetOriginalDisFileNameFromSource:
    call RestoreRealSource

  ; Search, for example, for '; E:\':, as written by 'WriteOriginalFileNameInSource'
    mov esi D$CodeSource
    mov ecx OriginalDisFilePath | sub ecx OriginalFileComment
    add esi ecx

    mov edi SaveFilter

    .If W$esi-2 = '; '
        If W$esi+1 = ':\'
            While B$esi > CR | movsb | End_While | mov B$edi 0
        Else
            mov B$edi 0
        End_If

    .Else
        mov B$edi 0
    .End_If

    call SetPartialEditionFromPos

    call 'KERNEL32.FindFirstFileA' SaveFilter, FindFile

    If eax = &INVALID_HANDLE_VALUE
        mov D$SaveFilter 0
    Else
        call 'KERNEL32.FindClose' eax
    End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

InitForcedFlagsDialog:
    call ReadForcedRecordsFile

    call Disable D$ForcedFlagsProcHandle, 51

    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 50, &WM_SETTEXT, 0,
                                      CopyOfLabelHexa

    mov esi D$ForcedRecordsTable, eax D$esi+FORCED_FILE_IMAGEBASE, D$DisImageBase eax

    call GetUserSelectionIndice | On eax = 0, call RegisterForcedRecord

    call 'USER32.SetDlgItemInt' D$ForcedFlagsProcHandle, 61,
                                D$DisForcedRecordIndice, &FALSE

    call TakeCopyOfDisName

    mov ebx edi
    push ebx
        mov D$ebx 'Sect', D$ebx+4 'ion.', D$ebx+8 'map'
        call ReadMapFileByte D$DisAddressWas ; SectionsMap, EndOfSectionsMap
        .If D$DisassemblyMapHandle = &INVALID_HANDLE_VALUE
           ; mov eax {'Sections Map File not found', 0} | call MessageBox
L1:         pop ebx | call InitForcedFlagsFromSelection | ret

        .Else
            call InitForcedSectionsDialog

        .End_If
    pop ebx

    push ebx
        mov D$ebx 'Rout', D$ebx+4 'ing.', D$ebx+8 'map'
        call ReadMapFileByte D$DisAddressWas ; SectionsMap, EndOfSectionsMap
        .If D$DisassemblyMapHandle = &INVALID_HANDLE_VALUE
            mov eax {'Routing Map File not found', 0} | call MessageBox | jmp L1<<

        .Else
            call InitForcedRoutingDialog

        .End_If
    pop ebx

    push ebx
        mov D$ebx 'Size', D$ebx+4 '.map', B$ebx+8 0
        call ReadMapFileByte D$DisAddressWas

        ..If D$DisassemblyMapHandle = &INVALID_HANDLE_VALUE
            mov eax {'Sizes Map File not found', 0} | call MessageBox | jmp L1<<

        ..Else
            call InitForcedSizeDialog

        ..End_If
    pop ebx
ret


InitForcedSectionsDialog:
    If eax = CODEFLAG
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 10, &BM_SETCHECK, &TRUE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 11, &BM_SETCHECK, &FALSE, 0
        call DisableDisDataFlags
    Else
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 10, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 11, &BM_SETCHECK, &TRUE, 0
        call EnableDisDataFlags
    End_If
ret


InitForcedRoutingDialog:
    test eax INSTRUCTION | jz L1>
        push eax
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 20, &BM_SETCHECK, &TRUE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 10, &BM_SETCHECK, &TRUE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 11, &BM_SETCHECK, &FALSE, 0
        pop eax
L1: test eax NODE | jz L1>
        push eax
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 21, &BM_SETCHECK, &TRUE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 20, &BM_SETCHECK, &TRUE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 10, &BM_SETCHECK, &TRUE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 11, &BM_SETCHECK, &FALSE, 0
        pop eax
L1: ;test eax LABEL | jz L1> ; We suppose the Label always wanted
        push eax
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 21, &BM_SETCHECK, &TRUE, 0
        pop eax
L1: test eax EXPORTNODE | jz L1>
        push eax
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 22, &BM_SETCHECK, &TRUE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 21, &BM_SETCHECK, &TRUE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 20, &BM_SETCHECK, &TRUE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 10, &BM_SETCHECK, &TRUE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 11, &BM_SETCHECK, &FALSE, 0
        pop eax
L1: test eax INDIRECT | jz L1>
        push eax
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 23, &BM_SETCHECK, &TRUE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 10, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 11, &BM_SETCHECK, &TRUE, 0
        pop eax
L1: ret


InitForcedSizeDialog:
  ; Clear all Sizes Flags and disable the End Address Edit:
    push eax
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 30, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 31, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 32, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 33, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 34, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 35, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 36, &BM_SETCHECK, &FALSE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 37, &BM_SETCHECK, &FALSE, 0
        call Disable D$ForcedFlagsProcHandle, 51
    pop eax

    .If eax = BYTE
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 30, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = WORD
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 31, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = DWORD
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 32, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = FP4
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 33, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = FP8
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 34, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = FP10
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 35, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = POINTER
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 23, &BM_SETCHECK, &TRUE, 0
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 32, &BM_SETCHECK, &TRUE, 0
    .Else_If eax = STRINGS+BYTE
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 36, &BM_SETCHECK, &TRUE, 0
        call Enable D$ForcedFlagsProcHandle, 51
    .Else_If eax = STRINGS+WORD
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 37, &BM_SETCHECK, &TRUE, 0
        call Enable D$ForcedFlagsProcHandle, 51
    .End_If
ret
____________________________________________________________________________________________

; First Record, for a given Disassembly. We take the Infos from the user's selection:

InitForcedFlagsFromSelection:
    mov eax D$DisLabelTypeWas | call InitForcedSectionsDialog

    ..If D$DisLabelTypeWas = CODEFLAG
        mov eax D$BlockEndTextPtr
        If W$eax +1 = '::'
            mov eax EXPORTNODE
        Else
            mov eax 0
        End_If
        add eax INSTRUCTION+LABEL | call InitForcedRoutingDialog
        call DisableDisDataFlags

    ..Else
        mov eax D$BlockEndTextPtr, edx D$eax+3, bl B$eax+6, al B$eax+3

        If edx = 'Data'
            mov eax INDIRECT | call InitForcedRoutingDialog
            mov eax DWORD
        Else_If edx = 'Code'
            mov eax INDIRECT | call InitForcedRoutingDialog
            mov eax DWORD
        Else_If al = 'B'
            mov eax BYTE
            On bl = '"', add eax STRINGS
        Else_If al = 'W'
            mov eax WORD
        Else_If al = 'D'
            mov eax DWORD
        Else_If al = 'F'
            mov eax FP4
        Else_If al = 'R'
            mov eax FP8
        Else_If al = 'T'
            mov eax FP10
        Else_If al = 'U'
            mov eax STRINGS+WORD
        End_If

        call InitForcedSizeDialog

    ..End_If

    call Disable D$ForcedFlagsProcHandle, 60
    call Disable D$ForcedFlagsProcHandle, 62
ret


DisableDisDataFlags:
    call Disable D$ForcedFlagsProcHandle, 30
    call Disable D$ForcedFlagsProcHandle, 31
    call Disable D$ForcedFlagsProcHandle, 32
    call Disable D$ForcedFlagsProcHandle, 33
    call Disable D$ForcedFlagsProcHandle, 34
    call Disable D$ForcedFlagsProcHandle, 35
    call Disable D$ForcedFlagsProcHandle, 36
    call Disable D$ForcedFlagsProcHandle, 37
    call Disable D$ForcedFlagsProcHandle, 51
ret


EnableDisDataFlags:
    call Enable D$ForcedFlagsProcHandle, 30
    call Enable D$ForcedFlagsProcHandle, 31
    call Enable D$ForcedFlagsProcHandle, 32
    call Enable D$ForcedFlagsProcHandle, 33
    call Enable D$ForcedFlagsProcHandle, 34
    call Enable D$ForcedFlagsProcHandle, 35
    call Enable D$ForcedFlagsProcHandle, 36
    call Enable D$ForcedFlagsProcHandle, 37
    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 36, &BM_GETCHECK, 0, 0
    push eax
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 37, &BM_GETCHECK, 0, 0
    pop ebx
    or eax ebx
    If eax <> 0
        call Enable D$ForcedFlagsProcHandle, 51
    End_If
ret


SetForcedNextAddressEditControl:
    call GetForcedRecordPointer | mov eax D$eax+FORCED_RECORD_OFFSET2

    mov D$CopyOfNextLabelHexa 0

    If eax <> 0
        mov edi CopyOfNextLabelHexa | call WriteEax | mov B$edi 0
    End_If

    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 51, &WM_SETTEXT,
                                      0, CopyOfNextLabelHexa
ret
____________________________________________________________________________________________

[DisassemblyMapHandle: ?  DisassemblyMapPtr: ?  DisassemblyMapLen: ?]
;;
  Reads one Byte, in any Map (SectionsMap, , 'RoutingMap' or 'SizesMap'):
;;
Proc ReadMapFileByte:
    Argument @Ptr
        call 'KERNEL32.CreateFileA' DisassemblyMapName, &GENERIC_READ,
                                    &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL, 0
        mov D$DisassemblyMapHandle eax

        .If eax <> &INVALID_HANDLE_VALUE

            call 'KERNEL32.GetFileSize' eax, 0 | mov D$DisassemblyMapLen eax
                add eax 10

            VirtualAlloc DisassemblyMapPtr eax

            call 'KERNEL32.ReadFile' D$DisassemblyMapHandle, D$DisassemblyMapPtr,
                                     D$DisassemblyMapLen, NumberOfReadBytes, 0

            call 'KERNEL32.CloseHandle' D$DisassemblyMapHandle

            mov eax D@Ptr | sub eax D$DisImageBase | add eax D$DisassemblyMapPtr
            movzx eax B$eax
          ; Flags Byte in eax

            push eax
                VirtualFree D$DisassemblyMapPtr
            pop eax
        .End_If
EndP
____________________________________________________________________________________________

[ForcedRecordsTable: ?  ForcedRecordsSize: ?]
;;
  'ForcedRecordsTable' holds Records of 2 dWords.
  
  * The leading Record is only for storing the 'DisImageBase', and is written at
    the end of the Disassembly Process, by the Disassembler itself.
  
  * The next Records store the user Editions: ... // DWORD Offset / DWORD Flags // ...
    where "Offset" is the displacement inside any Flags Table ('SectionsMap',
    'RoutingMap' and 'SizesMap'), plus the 'DisImageBase', and where "Flags" holds
    the 3 Flags Types, in order:
    
    Low Byte = SizesMap (Example, if Data: STRINGS+BYTE)
    Next Byte = RoutingMap Flag (Example INSTRUCTION+LABEL+EXPORTNODE)
    Next Byte = SectionsMap Flag (Example CODEFLAG)
    
    ... that are managed by 'ForcedFlagsIntoEax', 'EaxIntoForcedFlags'
    
    An "empty" Forced Records Table holds 8 Bytes, at least, for the DisImageBase.
;;

[FORCED_FILE_IMAGEBASE 0, FORCED_FILE_HEADERLENGHT 4
 FORCED_RECORD_OFFSET1 0, FORCED_RECORD_OFFSET2 4, FORCED_RECORD_FLAGS 8,
 FORCED_RECORD_LENGHT 12]

ReadForcedRecordsFile: ; WriteForcedRecordsFile
    VirtualFree D$ForcedRecordsTable

    call TakeCopyOfDisName
    mov D$edi 'Forc', D$edi+4 'ed.m', D$edi+8 'ap'

    call 'KERNEL32.CreateFileA' DisassemblyMapName, &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, 0

    If eax <> &INVALID_HANDLE_VALUE
        mov D$DisassemblyMapHandle eax

        call 'KERNEL32.GetFileSize' D$DisassemblyMapHandle, 0
        mov D$ForcedRecordsSize eax | add eax 010
        VirtualAlloc ForcedRecordsTable eax

        call 'KERNEL32.ReadFile' D$DisassemblyMapHandle, D$ForcedRecordsTable,
                                 D$ForcedRecordsSize, NumberOfReadBytes, 0

        call 'KERNEL32.CloseHandle' D$DisassemblyMapHandle

    Else
        mov D$ForcedRecordsTable 0

    End_If
ret


IsForcedMapFile:
    call TakeCopyOfDisName

    mov D$edi 'Forc', D$edi+4 'ed.m', D$edi+8 'ap'

    call 'KERNEL32.FindFirstFileA' DisassemblyMapName, FindFile

    If eax <> &INVALID_HANDLE_VALUE
        call 'KERNEL32.FindClose' eax
        mov eax &TRUE
    Else
        mov eax &FALSE
    End_If
ret
____________________________________________________________________________________________

; Called from 'DisMain':

ForceRecordsToMaps:
    mov esi D$ForcedRecordsTable | mov edx D$esi+FORCED_FILE_IMAGEBASE
    add esi FORCED_FILE_HEADERLENGHT

    .While D$esi <> 0
        mov eax D$esi+FORCED_RECORD_FLAGS | call EaxIntoForcedFlags

      ; Take the Displacement to the Map Tables:
        mov ebx D$esi+FORCED_RECORD_OFFSET1
      ; edx is the previously saved 'DisImageBase':

        sub ebx edx

      ; Force the SectionsMap:
      ; Useless: Everything is empty at this stage:
      ;  mov edi D$SectionsMap | add edi ebx
      ;  mov ecx D$esi+FORCED_RECORD_OFFSET2 | sub ecx D$esi+FORCED_RECORD_OFFSET1 | jecxz L1>
      ;  mov al 0 | rep stosb

L1:     mov edi D$SectionsMap, al B$UserSectionFlag, B$edi+ebx al

      ; Force the RoutingMap:
        mov edi D$RoutingMap, al B$UserRoutingFlag
        On B$UserSectionFlag = CODEFLAG, or al LABEL+NODE+EVOCATED+INSTRUCTION+ACCESSED
        mov B$edi+ebx al

      ; Force the SizesMap:
        mov edi D$SizesMap, al B$UserSizeFlag
        .If B$UserSectionFlag = CODEFLAG
            mov B$edi+ebx 0
        .Else
;;
  If Data, we may have to Flag Chunks of Bytes, in the SizesMap, instead of one
  single Byte, and to also flag the SectionsMap as Data:
;;
            If al = BYTE
                call ForceDataFlag eax, 1
            Else_If al = WORD
                call ForceDataFlag eax, 2
            Else_If al = DWORD
                call ForceDataFlag eax, 4
            Else_If al = FP4
                call ForceDataFlag eax, 4
            Else_If al = FP8
                call ForceDataFlag eax, 8
            Else_If al = FP10
                call ForceDataFlag eax, 10
            Else_If al = POINTER
                call ForceDataFlag eax, 4
            Else_If al = STRINGS+BYTE
                call ForceDataFlag eax, 0-1
            Else_If al = STRINGS+WORD
                call ForceDataFlag eax, 0-1
            End_If
        .End_If

        add esi FORCED_RECORD_LENGHT
    .End_While
;map
ret

Proc ForceDataFlag:
    Argument @Flag, @n

        mov al B@Flag

        .If D@n = 0-1
          ; Flag Strings down to the next Label:
            mov ecx D$esi+FORCED_RECORD_OFFSET2 | sub ecx D$esi+FORCED_RECORD_OFFSET1

            push ebx, ecx
L0:             mov B$edi+ebx al | inc ebx | loop L0<
            pop ecx, ebx

            mov edi D$SectionsMap
L0:         mov B$edi+ebx DATAFLAG | inc ebx | loop L0<

        .Else
            push ebx
                mov ecx D@n
L0:             mov B$edi+ebx al | inc ebx | loop L0<
            pop ebx

            push ebx
                mov ecx D@n, edi D$SectionsMap
L0:             mov B$edi+ebx DATAFLAG | inc ebx | loop L0<
            pop ebx
        .End_If
EndP
____________________________________________________________________________________________

WriteForcedRecordsFile: ; ReadForcedRecordsFile
    call TakeCopyOfDisName
    mov D$edi 'Forc', D$edi+4 'ed.m', D$edi+8 'ap'

    call 'KERNEL32.CreateFileA' DisassemblyMapName, &GENERIC_WRITE,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &CREATE_ALWAYS,
                                &FILE_ATTRIBUTE_NORMAL, 0
    mov D$DisassemblyMapHandle eax

    If eax <> &INVALID_HANDLE_VALUE
        mov esi D$ForcedRecordsTable, ecx FORCED_FILE_HEADERLENGHT
        add esi ecx

        While D$esi <> 0
            add esi FORCED_RECORD_LENGHT | add ecx FORCED_RECORD_LENGHT
        End_While

        call 'KERNEL32.WriteFile' D$DisassemblyMapHandle, D$ForcedRecordsTable,
                                  ecx, NumberOfReadBytes, 0

        call 'KERNEL32.CloseHandle' D$DisassemblyMapHandle
    End_If
ret
____________________________________________________________________________________________

[DisForcedRecordIndice: ?]

GetUserSelectionIndice:
  ; Substract the 'DisImageBase' from the selected Label dWord:
    mov eax D$DisAddressWas
;;
  Scan all Records, in 'ForcedRecordsTable'. In case a same Offest would already
  have been edited, we lock on that one. If none found, we start the Edition of
  a new Record, at the end.
;;
    mov esi D$ForcedRecordsTable | add esi FORCED_FILE_HEADERLENGHT

    mov ecx 1

    While D$esi <> 0
        cmp D$esi eax | je L1>
        add esi FORCED_RECORD_LENGHT | inc ecx
    End_While

  ; No matching Record found >>> Return 0
    mov eax 0

L1: mov D$DisForcedRecordIndice ecx
ret
____________________________________________________________________________________________
;;
  Job similar to the one already done by the Init of 'InitForcedFlagsDialog' (the caller),
  but done from the Values Recorded in 'ForcedRecordsTable', at the wanted Indice:
;;
SetForcedFlagsFromForcedRecord:
        call Disable D$ForcedFlagsProcHandle, 51

        call 'USER32.SetDlgItemInt' D$ForcedFlagsProcHandle, 61,
                                    D$DisForcedRecordIndice, &FALSE

      ; Take the DisImageBase:
        mov esi D$ForcedRecordsTable
        mov eax D$esi+FORCED_FILE_IMAGEBASE | mov D$DisImageBase eax

      ; Point with esi to the proper Record
        mov ecx D$DisForcedRecordIndice | dec ecx
        mov eax FORCED_RECORD_LENGHT | mul ecx
        add eax FORCED_FILE_HEADERLENGHT
        add esi eax

      ; Write the Address to the EditBox:
        mov eax D$esi+FORCED_RECORD_OFFSET1
        push esi
            mov edi CopyOfLabelHexa | call WriteEax | mov B$edi 0
            call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 50, &WM_SETTEXT,
                                              0, CopyOfLabelHexa
        pop esi

      ; Split the Flags onto the wanted Variables:
        mov eax D$esi+FORCED_RECORD_FLAGS | call EaxIntoForcedFlags
      ; And set the Radio and CheckBoxes:
        push esi
            mov eax D$UserSectionFlag | call InitForcedSectionsDialog
            mov eax D$UserRoutingFlag | call InitForcedRoutingDialog
            mov eax D$UserSizeFlag | call InitForcedSizeDialog
        pop esi

        Test B$UserSizeFlag STRINGS | jz L2>
            mov eax D$esi+FORCED_RECORD_OFFSET2

          ; And write it to the EditBox:
            mov edi CopyOfNextLabelHexa | call WriteEax | mov B$edi 0
            call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 51, &WM_SETTEXT,
                                              0, CopyOfNextLabelHexa
L2:
        If D$UserSectionFlag = CODEFLAG
            call DisableDisDataFlags
        End_If
ret
____________________________________________________________________________________________

[StartOfForcedSection: ? EndOfForcedSection: ?   ForcedFlagsModified: ?]
[ForcedStartAddressBuffer: ? #3][ForcedEndAddressBuffer: ? #3]

[UserSectionFlag: ?  UserRoutingFlag: ?   UserSizeFlag: ?   BadUserFlag: ?]

; The order, from High to low is: Empty/Section/Routing/Size.

ForcedFlagsIntoEax:
    mov eax D$UserSectionFlag | shl eax 8
    or al B$UserRoutingFlag | shl eax 8
    or al B$UserSizeFlag
ret

EaxIntoForcedFlags:
    mov B$UserSizeFlag al | shr eax 8
    mov B$UserRoutingFlag al | shr eax 8
    mov B$UserSectionFlag al
ret
____________________________________________________________________________________________

GetForcedDialogFlags:
    mov B$BadUserFlag &FALSE

  ; Get the targetted Address:
    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 50, &WM_GETTEXT,
                                      10, ForcedStartAddressBuffer

    call GetHexaFromText ForcedStartAddressBuffer

    If B$GetHexaFromTextError = &TRUE
        mov eax {'The Address must be given in Hexa Format', 0} | call MessageBox
        mov B$BadUserFlag &TRUE | ret
    End_If

    mov D$DisAddressWas eax

    call GetForcedEndAddress | On eax <> 0, mov D$NextDisAddressWas eax

  ; Get the SectionsMap Flag:
    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 10, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        mov B$UserSectionFlag CODEFLAG
    Else
        mov B$UserSectionFlag DATAFLAG
    End_If

  ; Get the RoutingMap Flags:
  ; [x] Instruction
    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 20, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        mov B$UserRoutingFlag INSTRUCTION
    Else
        mov B$UserRoutingFlag 0
    End_If
  ; [x] Label
    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 21, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        or B$UserRoutingFlag LABEL+EVOCATED
    End_If
  ; [x] Exported
    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 22, &BM_GETCHECK, 0, 0
    On eax = &TRUE, or B$UserRoutingFlag EXPORTNODE+NODE+EVOCATED+ACCESSED+LABEL
  ; [x] Pointer
    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 23, &BM_GETCHECK, 0, 0
    On eax = &TRUE, or B$UserRoutingFlag INDIRECT

  ; Get the SizesMap Flags:
    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 30, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        mov B$UserSizeFlag BYTE | ret
    End_If

    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 31, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        mov B$UserSizeFlag WORD | ret
    End_If

    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 32, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        mov B$UserSizeFlag DWORD | ret
    End_If

    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 33, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        mov B$UserSizeFlag FP4 | ret
    End_If

    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 34, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        mov B$UserSizeFlag FP8 | ret
    End_If

    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 35, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        mov B$UserSizeFlag FP10 | ret
    End_If

    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 36, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        mov B$UserSizeFlag STRINGS+BYTE | ret
    End_If

    call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 37, &BM_GETCHECK, 0, 0
    If eax = &TRUE
        mov B$UserSizeFlag STRINGS+WORD | ret
    End_If
ret
____________________________________________________________________________________________

RegisterUserFlags:
    call GetForcedDialogFlags

    If B$BadUserFlag = &FALSE
        call GetForcedRecordPointer | mov edi eax

        mov eax D$DisAddressWas | mov D$edi+FORCED_RECORD_OFFSET1 eax
        mov eax D$NextDisAddressWas | mov D$edi+FORCED_RECORD_OFFSET2 eax

        call ForcedFlagsIntoEax | mov D$edi+FORCED_RECORD_FLAGS eax

        push edi
            call GetForcedEndAddress
        pop edi

        On eax <> 0, mov D$edi+FORCED_RECORD_OFFSET2 eax
    End_If
ret
____________________________________________________________________________________________

GetForcedEndAddress:
    call 'USER32.GetDlgItem' D$ForcedFlagsProcHandle, 51
    call 'USER32.IsWindowEnabled' eax

    .If eax = &TRUE
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 51, &WM_GETTEXT,
                                          10, ForcedStartAddressBuffer
        If eax = 0
            call 'USER32.MessageBoxA' D$ForcedFlagsProcHandle,
            {'You must give the End Address of the String (Excluded Label)', 0},
            {'Missing Address', 0}, &MB_OK

            mov B$BadUserFlag &TRUE | jmp L2>
        End_If

        call GetHexaFromText ForcedStartAddressBuffer

        If B$GetHexaFromTextError = &TRUE
            mov eax {'The Address must be given in Hexa Format', 0}
            call MessageBox

            mov B$BadUserFlag &TRUE | jmp L2>
        End_If
      ; eax = Value of the End Label

    .Else
L2:      mov eax 0

    .End_If
ret
____________________________________________________________________________________________

[CopyOfEndLabelHexa: ? ? ? ? ? ? ? ? ? ?]

SetForcedEndAddress:
    push esi, edi
        mov eax D$esi+FORCED_RECORD_OFFSET2, edi CopyOfEndLabelHexa | call WriteEax
        call 'USER32.SendDlgItemMessageA' D$ForcedFlagsProcHandle, 51, &WM_SETTEXT,
                                          0, CopyOfEndLabelHexa
    pop edi, esi
ret
____________________________________________________________________________________________

[AddressToBeForced: ?   ForcedFlag: ?
 ForcedUpperLine: ?    ForcedCurrentWritingPos: ?]

ReRunDisassembler:
    mov B$AddressToBeForced &TRUE

    call RestoreRealSource

    mov eax D$UpperLine | sub eax D$CodeSource
    mov D$ForcedUpperLine eax
    mov eax D$CurrentWritingPos | sub eax D$CodeSource
    mov D$ForcedCurrentWritingPos eax

    call SetPartialEditionFromPos | call AskForRedrawNow

    call ReInitUndo | call ClearBackTable | mov D$TiTleTable 0

    call ReleaseMainFile | StoreNameOnly SaveFilter | call ClearBackTable
    VirtualFree D$UserPeStart

    mov B$WithForcedMapFile &TRUE | call ReloadForDissassembler

    mov eax D$ForcedUpperLine | add eax D$CodeSource
    mov D$UpperLine eax
    mov eax D$ForcedCurrentWritingPos | add eax D$CodeSource
    mov D$CurrentWritingPos eax
    mov D$PreviousPartialSourceLen 0

    call SetPartialEditionFromPos
    call SetCaret D$CurrentWritingPos

    mov B$BlockInside &FALSE, B$AddressToBeForced &FALSE
ret
____________________________________________________________________________________________
____________________________________________________________________________________________











TITLE D.I.S.


[PesDisPath: B$ ? #&MAX_PATH]
[PeDisFileHandle: ?    PeDisFileLength: ?    PeDisFileMemory: ?    DisFileOk: ?]
[EndOfDisPath: ?]

GetDisPath:
    call GetRosAsmFilesPath
    mov esi RosAsmFilesPath, edi PesDisPath
    While B$esi <> 0 | movsb | End_While

    mov D$edi 'Dis\' | add edi 4 | mov D$EndOfDisPath edi
ret

LoadPeDisFile:
    call GetDisPath | mov edi D$EndOfDisPath, D$edi 'Pe.d', D$edi+4 'is'

    call 'KERNEL32.FindFirstFileA' PesDisPath, FindFile

    ...If eax <> &INVALID_HANDLE_VALUE

        call 'KERNEL32.FindClose' eax

        call 'KERNEL32.CreateFileA' PesDisPath, &GENERIC_READ,
                                    &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL, 0
        mov D$PeDisFileHandle eax

        call 'KERNEL32.GetFileSize' eax, 0 | mov D$PeDisFileLength eax
        add eax 10

        VirtualAlloc PeDisFileMemory, eax | add D$PeDisFileMemory 10

        call 'KERNEL32.ReadFile' D$PeDisFileHandle, D$PeDisFileMemory,
                                 D$PeDisFileLength, NumberOfReadBytes, 0

        call 'KERNEL32.CloseHandle' D$PeDisFileHandle

        mov B$DisFileOk &TRUE

    ...Else
        mov B$DisFileOk &FALSE

    ...End_If
ret


[NextLine | While B$esi > CR | inc esi | End_While
            While B$esi < ' ' | inc esi | End_While]

[TestSignatures: ?    TestSignaturesMax: ?    PeDisMatches: ?    PeDisMatchesPointer: ?]

ParsePeDis:
    mov esi D$PeDisFileMemory, edx esi | add edx D$PeDisFileLength

    While D$esi <> '; Da' | inc esi | End_While

L0: cmp B$esi '[' | je L1>
        inc esi | cmp esi edx | jb L0<
            jmp L9>>

L1: .While D$esi <> 'Sign'  ; ature:
        NextLine | On B$esi = ']', jmp L0<
    .End_While

    add esi 11 | inc D$TestSignatures

  ; "Signature:" found:

    mov edi D$DisEntryPoint | sub edi D$DisImageBase | add edi D$UserPeStart

L2: call GetHexaFromSignature

    ...If eax = CRLF
      ; Matching Pattern found.
        push esi
            While B$esi <> '[' | dec esi | End_While
            mov edi D$PeDisMatchesPointer, D$edi esi
            While D$esi <> 'Func' | inc esi | End_While | add esi 15
            call GetDisFunctionSize | mov D$edi+4 eax
        pop esi
        jmp L0<<

    ...Else_If eax = QUESTIONMARKS
        inc edi | jmp L2<

    ...Else
       ; .If D$TestSignatures = 416
       ;     If al <> B$edi
       ;         hexprint eax
       ;         mov B$esi+100 0 | showme esi
       ;         map
       ;     End_If
       ; .End_If
        cmp al B$edi | jne L0<<
            inc edi | jmp L2<<

    ...End_If
L9: ret


GetDisFunctionSize:
    mov ecx 0

L0: lodsb | cmp al '0' | jb L8>
        sub al '0'
        lea ecx D$ecx+ecx*4
        lea ecx D$eax+ecx*2
    jmp L0<

L8: ret


GetBiggerPeDisID:
    mov esi D$PeDisMatches, eax 0, edx 0

L0: If D$esi+4 > eax
        mov eax D$esi+4, edx D$esi
    End_If

    add esi 8 | cmp D$esi 0 | ja L0<

    mov esi edx, B$esi+100 0 | ;showme esi
ret


[QUESTIONMARKS 0FFFF]

GetHexaFromSignature:
    While B$esi = ' ' | inc esi | End_While

    If B$esi = '?'
        add esi 3 | mov eax QUESTIONMARKS
        On B$esi = LF, dec esi
        ret
    Else_If B$esi = CR
        mov eax CRLF | add esi 2 | ret
    End_If

    lodsb | sub al '0' | cmp al 9 | jbe L2>
        sub al 7

L2: mov ah al
    lodsb | sub al '0' | cmp al 9 | jbe L2>
        sub al 7

L2: If ah > 0F
        jmp L8>

    Else_If al > 0F
        jmp L8>

    Else_If B$esi > ' '
L8:
        call 'USER32.MessageBoxA', 0, {'Bad Hexa Data encounted', 0},
                                    FindFile.cFileName, 0 ;{'Reading Pe.dis', 0}, 0
        While B$esi <> '[' | dec esi | End_While
        mov B$esi+200 0 | ;showme esi
        jmp DisFail

    Else
        shl ah 4 | or al ah | and eax 0FF

    End_If
ret

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  For example, a File like vc32rt.dis may be 6,778,426 Bytes long. 
  
  That is: 298,780 Lines... / 12 Lines per Record: 24898 Records to parse (!!!...)
  for one single "ModUsed" File...
  
  So, it's necessary to build a '.bis' File from each '.dis' one.
  
  Structure:
  
  1) A Header Table of 256 dWords pointing to the Signatures Entries.
  
  2) Each 'Entry' is a set of Linked records holding the 'Signatures':
  
  Example, for:
  
  [
  Id: 1
  Name: fFSQRT
  Signature: 0A C9 75 12 D9 FA C3 0A C9 75 0B C3 D9 E4 9B DF E0 9B 9E 75 EB C3 E9
  Entry Point: False 0 <$C>
  Reference List: 0
  Code Label: <$$>0007 _rtforsqrtinf <$$>000C _rtforsqrtzero <$$>0016 sqrtindfnpop
  CRC: 00 0000
  Function Size: 27
  ]
  
  The dWord at (0+(0A*4)) points to the 'fFSQRT' (binary translation) record
  
  Each 'Signature' Binary translation is, for example, with the above 'fFSQRT'
  one:
  
  B$ 23 0A 0C9 075 012 0D9 0FA 0C3 0A 0C9 075 0B 0C3 0D9 0E4 09B 0DF 0E0 09B 09E 075 0EB 0C3 0E9
  
  Where the '23' Byte says that 23 determined Bytes are following.
  
  In cases when undertermined Bytes are included, for example:
  
  [
  Id: 7
  Name: ?do_tolower@?$ctype@D@std@@MBEDD@Z
  Signature: 0F B6 44 24 04 83 C1 08 51 50 E8 ?? ?? ?? ?? 59 59 C2 04 00
  Entry Point: False 0 <$C>
  Reference List: <$$>000B __Tolower
  Code Label: 0
  CRC: 00 0000
  Function Size: 20
  ]
  
  the 'Signature' Binary translation is:
     __                                          ___ _
  B$ 11 0F 0B6 044 024 04 083 0C1 08 051 050 0E8 0-4 5 059 059 0C2 04 0

  ... where 11 says that 11 determined Bytes are following,
           0-4 says that 4 undetermined Bytes are following,
         and 5 says that 5 dtermined Bytes are following.
         
  Now, in the 256 dWords Header, each dWord points to only _one Signature.
  
  As ther may be many different Signatures beginning with the same Byte
  value, we need to Link the Lists of Signatures.
  
  This is to say that, for example, all Signatures beginning by 0A, will
  have to come under the form of a Linked List:
  
  Header dWords: [.... .... .... Ptr0A ... ... ...]
  
  Ptr0A: [Ptr0A_1: D$ Ptr0A_2 B$ 11 0F 0B6 044 024 04....
          Ptr0A_2: D$ Ptr0A_3 B$ ........................
          ....
          0]
          
  Scaning a Disassembled PE, for Pattern Matchings should look like this:
  
  ; ...
    mov eax 0
  ; ....
    mov al B$esi
  
    ...If D$dWordsHeader+eax*4 <> 0
            mov edi D$dWordsHeader+eax*4
          ; Take the Chained Pointer:
            mov edx D$edi | add edi 4
            
          ; Take the Bytes count:
            mov cl B$edi | inc edi
            
            If cl = 0
                ; Found
            Else_If cl <= 32
                While cl <> 0
                    ; Compare
                End_While
            Else
                While cl <> 0
                    inc esi | inc cl
                End_Wile
            End_If

    ...End_If   
    
    inc esi
    
  ; ... 
;;


Proc LoadOneDisFile:
    Argument @Name, @Ext

        mov edi D$EndOfDisPath, esi D@Name
        While B$esi <> 0 | movsb | End_While
        If D@Ext <> &NULL
            move D$edi D@Ext | add edi 4
        End_If
        mov B$edi 0

        call 'KERNEL32.CreateFileA' PesDisPath, &GENERIC_READ,
                                    &FILE_SHARE_READ, 0, &OPEN_EXISTING,
                                    &FILE_ATTRIBUTE_NORMAL, 0

        ...If eax <> &INVALID_HANDLE_VALUE

            mov D$PeDisFileHandle eax

            call 'KERNEL32.GetFileSize' eax, 0 | mov D$PeDisFileLength eax
            add eax 10

            VirtualAlloc PeDisFileMemory, eax | add D$PeDisFileMemory 10

            call 'KERNEL32.ReadFile' D$PeDisFileHandle, D$PeDisFileMemory,
                                    D$PeDisFileLength, NumberOfReadBytes, 0

            call 'KERNEL32.CloseHandle' D$PeDisFileHandle

            mov B$DisFileOk &TRUE

        ...Else
            mov B$DisFileOk &FALSE

        ...End_If
EndP


DisToBis:
    mov edi D$EndOfDisPath, D$edi '*.di', D$edi+4 's'

    call 'KERNEL32.FindFirstFileA' PesDisPath, FindFile | mov D$FindHandle eax

    ...If eax = &INVALID_HANDLE_VALUE

        call 'KERNEL32.FindClose' eax

    ...Else
L1:     call LoadOneDisFile FindFile.cFileName, &NULL

        call ComputeDisToBin

        VirtualFree D$PeDisFileMemory

        call 'KERNEL32.FindNextFileA' D$FindHandle FIND_EQU | on eax = &TRUE, jmp L1<

        call 'KERNEL32.FindClose' D$FindHandle
    ...End_If
ret


[BisMem: ?]

ComputeDisToBin:
    VirtualAlloc BisMem D$PeDisFileLength

    mov esi D$PeDisFileMemory, edi D$BisMem, edx esi
    add edx D$PeDisFileLength

    mov D$FirstByte 0

    add edi (0100*4)

  ; ParsePeDis
    While D$esi <> '; Da' | inc esi | End_While

L0: cmp B$esi '[' | je L1>
        inc esi | cmp esi edx | jb L0<
            jmp L9>>

L1: .While D$esi <> 'Sign'  ; ature:
        NextLine | On B$esi = ']', jmp L0<
    .End_While

    add esi 11 | inc D$TestSignatures

  ; "Signature:" found:
   ; call EncodeOneSignature |
   jmp L0<
L9: VirtualFree D$BisMem
    ret


; Signature: 0F B6 44 24 04 83 C1 08 51 50 E8 ?? ?? ?? ?? 59 59 C2 04 00
;    __                                          ___ _
; B$ 11 0F 0B6 044 024 04 083 0C1 08 051 050 0E8 0-4 5 059 059 0C2 04 0


[FirstByte: ?]

EncodeOneSignature:
    mov ecx 0

  ; Read the First Byte of the Signature:
    call GetHexaFromSignature

    If al > B$FirstByte
        mov B$FirstByte al, B$FirstByte+3 0FF
        mov ebx D$BisMem, D$ebx+eax*4 edi

    Else_If al < B$FirstByte
        call 'USER32.MessageBoxA' 0, {'Bad order of Records', 0},
                                     FindFile.cFileName, 0
        While D$esi <> 'Id: ' | dec esi | End_While
        mov B$esi+200 0 | ;showme esi
        jmp DisFail

    End_If

    jmp L1>

L0: call GetHexaFromSignature

L1: .If eax = QUESTIONMARKS
      ; Write the written number of Significative Bytes
        If cl = 0
            call 'USER32.MessageBoxA' 0, {'Record beginning with ??', 0},
                                     FindFile.cFileName, 0
            mov B$esi+200 0 | ;showme esi
            While D$esi <> 'Id: ' | dec esi | End_While
            mov B$esi+200 0 | ;showme esi
            jmp DisFail
        End_If
        mov B$edi cl | add edi ecx | inc edi

        mov ecx 0-1
        While B$esi = '?'
            add esi 3 | dec ecx
        End_While
        mov B$edi cl | inc edi

        mov ecx 0

    .Else_If eax = CRLF
        If cl <s 1
            call 'USER32.MessageBoxA' 0, {'Record ending with ??', 0},
                                     FindFile.cFileName, 0
            While D$esi <> 'Id: ' | dec esi | End_While
            mov B$esi+200 0 | ;showme esi
            jmp DisFail
        End_If

        mov B$edi cl | add edi ecx | inc edi | jmp L9>

    .Else
        inc ecx | mov B$edi+ecx al

    .End_If

    jmp L0<<

L9: ret






TITLE MacroCreator

____________________________________________________________________________________
____________________________________________________________________________________________
;;
MacroCreator

Created By Looki in October/2006

The goal of this routine is to substitute some code to Macros, recover the HLL style from
disassembled code, and clean the code from the various types of aligns

Current Version: 20/November/2006
;;
____________________________________________________________________________________________
____________________________________________________________________________________________

[If_MemComp | mov #4 #3 | cmp #1 #4 | jn#2 F1>> | #+4]
[End_If_MemComp | F1: | F9:]
[Byter dl Wordr dx Dwordr edx]

[While_MultComp | N0: | cmp #1 #3 | jn#2 N9> | #+3]
[End_While_MultComp | jmp N0< | N9:]

[Buffer: B$ "    
Code02704D20: M8:
    cmp eax ebx | jne Code0403045
    mov eax 0
    cmp eax ecx | jne Code0403040
    mov eax 01
    cmp edx ecx | jne Code0403029
    mov eax 02

Code0403029: H3:
    cmp ecx edx | jne Code040303B
    mov eax 064
jmp Code0403029
    
Code040303B: J1:
    mov eax 0C
    
Code0403040: J6:
    mov eax 0D
    
Code0403045: K1:" 0]
[FirstAdress: ?]
[LastAdress: ?]
[FirstAdressWithMacro: ?]
[LastAdressWithMacro: ?]
[EndOfCodeLine: ?]
[Cache: ? #20]
[CodeSectName: ? #10]
____________________________________________________________________________________________

FindEndAdress:
    mov eax Buffer
    While B$eax <> 0
        inc eax
    End_While
    mov D$LastAdress eax
    ret
____________________________________________________________________________________________

ScanAndRealoc:
    mov ebx 0
    While edx < D$LastAdress
        mov bl B$edx
        mov B$ecx bl
        inc edx
        inc ecx
    End_While
    mov ebx ecx
    While ecx < D$LastAdress
        mov D$ecx 0
        add ecx 4
    End_While
    mov D$LastAdress ebx ; atualiza o ultimo endereço no handle principal
    ret
____________________________________________________________________________________________

InternalSubstitution:
            lea edx D$eax+25 ; endereço da ultima linha onde havia o código da macro
            mov eax D$FirstAdressWithMacro ; pega o primeiro endereço onde reside a macro
                    ; move os dados para o cache
                    mov ecx D$eax
                    mov D$Cache ecx
                    mov ecx D$eax+4
                    mov D$Cache+4 ecx
                    mov ecx D$eax+8
                    mov D$Cache+8 ecx
                    mov ecx D$eax+12
                    mov D$Cache+12 ecx
                    mov cl B$eax+16
                    mov B$Cache+16 cl
                    ; escreve o nome da macro antes do nome da seçao code
                    mov D$eax 'Proc'
                    mov cl ' '
                    mov B$eax+4 cl
                    ; move os do cache para a posiçao apos o nome da macro
                    mov ecx D$Cache
                    mov D$eax+5 ecx
                    mov ecx D$Cache+4
                    mov D$eax+9 ecx
                    mov ecx D$Cache+8
                    mov D$eax+13 ecx
                    mov ecx D$Cache+12
                    mov D$eax+17 ecx
                    mov cl B$Cache+16
                    mov B$eax+21 cl
                    lea ecx D$eax+22 ; endereço da ultima posiçao da linha do code, antes de pular a linha
                    mov eax ecx ; endereço do final da linha code no handle principal
            ret
____________________________________________________________________________________________

MacroIfRecog:
;------------------------------------------------------------------------------------
;macro validada |"cmp eax ebx | jne Code0403045" |Code0403045: K1:|
;------------------------------------------------------------------------------------
                    mov D$eax '..En'
                    mov D$eax+4 'd_if'
                    lea edx D$eax+16 ; endereço da ultima linha onde havia o código da macro [fik apontado no Byte anterior ao 0D]
                    lea ecx D$eax+8 ; endereço da ultima posiçao da linha do code, antes de pular a linha
                    mov eax ecx ; endereço do final da linha code no handle principal
                    call ScanAndRealoc

                    mov eax esi
                    mov ecx Cache
;------------------------------------------------------------------------------------
;pega o primeiro parametro da macro
;------------------------------------------------------------------------------------
                    While B$eax <> ' '
                        mov dl B$eax
                        mov B$ecx dl
                        inc ecx
                        inc eax
                    End_While

                    mov D$esi-4 '..If'
                    mov B$esi ' '
                    inc esi
;------------------------------------------------------------------------------------
;prepara para receber o segundo parametro que indica o tipo de operação a se fazer
;------------------------------------------------------------------------------------
                    inc eax
                    mov B$ecx ' '
                    inc ecx

                    mov edi eax ; armazena endereço atual de eax [final do primeiro parâmetro] para procurar o segundo parametro

                    While W$eax <> 'jn'
                        add eax 2
                    End_While
;------------------------------------------------------------------------------------
;reconhece o segundo parametro
;------------------------------------------------------------------------------------
                    ; o lea não modifica a flag do jmp, isso garante que no caso de o código
                    ; já ter passado em uma comparação com resultado positivo ele vai para o L8
            cmp B$eax+2 'e' | jne L1> | mov B$ecx '='| lea ecx D$ecx+1 | je L8>
        L1: cmp B$eax+2 'b' | jne L2> | mov B$ecx '<'| lea ecx D$ecx+1 | je L8>
        L2: cmp B$eax+2 'a' | jne L3> | mov B$ecx '>'| lea ecx D$ecx+1 | je L8>
        L3: cmp B$eax+2 'l' | jne L4> | mov W$ecx '<s'| lea ecx D$ecx+2 | je L8>
        L4: cmp B$eax+2 'g' | jne L5> | mov W$ecx '>s'| lea ecx D$ecx+2 | je L8>
        L5: cmp W$eax+2 'be' | jne L6> | mov W$ecx '<='| lea ecx D$ecx+2 | je L8>
        L6: cmp W$eax+2 'ae' | jne L7> | mov W$ecx '>='| lea ecx D$ecx+2 | je L8>
        L7: cmp W$eax+2 'ne' | jne L8> | mov W$ecx '<>'| lea ecx D$ecx+2 | je L8>
        L8:
;------------------------------------------------------------------------------------
;volta ao fim do primeiro parametro e prepara para receber o terceiro parametro
;------------------------------------------------------------------------------------
                    mov B$ecx ' '
                    mov eax edi ; volta para o endereço do fim do primeiro parâmetro
                    inc ecx
;------------------------------------------------------------------------------------
;pega o terceiro parametro da macro
;------------------------------------------------------------------------------------
                    While B$eax <> ' '
                        mov dl B$eax
                        mov B$ecx dl
                        inc ecx
                        inc eax
                    End_While
;------------------------------------------------------------------------------------
;Monta os 3 parametros na macro
;------------------------------------------------------------------------------------
                    mov edi Cache

                    While edi < ecx
                        mov dl B$edi
                        mov B$esi dl
                        inc edi
                        inc esi
                    End_While

                    lea edx D$eax+18 ; endereço da ultima linha onde havia o código da macro [fik apontado no Byte anterior ao 0D]
                    lea ecx D$eax+3 ; endereço da ultima posiçao da linha do code, antes de pular a linha
                    mov eax ecx ; endereço do final da linha code no handle principal
                    call ScanAndRealoc

                    add eax 4
                ret
____________________________________________________________________________________________

CreatorMain:

call FindEndAdress
mov D$FirstAdress Buffer
mov eax D$FirstAdress

..While eax < D$LastAdress
;--------------------------------------------------------------------------------------------------
;Proc/EndP Recon Start
;--------------------------------------------------------------------------------------------------
    ...If D$eax = 'Code'
        mov D$FirstAdressWithMacro eax ; pega o primeiro endereço onde reside a macro
        add eax 23
        ..If_And D$eax = 'push', D$eax+4 = ' ebp', D$eax+14 = 'mov ', D$eax+18 = 'ebp ', D$eax+21 = ' esp'
                call InternalSubstitution
                call ScanAndRealoc
        ..End_if
    ...End_if
;--------------------------------------------------------------------------------------------------
;Proc/EndP Recon End
;--------------------------------------------------------------------------------------------------

;--------------------------------------------------------------------------------------------------
;Loop Recon Start
;--------------------------------------------------------------------------------------------------
    ...If D$eax = 'cmp '

            add eax 4
            mov esi eax ; salva o endereço atual do eax, local do primeiro parametro

;------------------------------------------------------------------------------------
;procura e pega o nome do label[seção]
;------------------------------------------------------------------------------------
            .While D$eax <> 'Code'
                inc eax
            .End_While

            mov ebx CodeSectName ; guarda o nome do label para comparar

            .While B$eax <> 0a
                mov dx W$eax
                mov W$ebx dx
                add ebx 2
                add eax 2
            .End_While

            mov D$ebx-1 ':'
            sub ebx 12
;------------------------------------------------------------------------------------
;parte da validação
;------------------------------------------------------------------------------------
            .While eax < D$LastAdress

                If_MemComp D$eax = D$ebx Dwordr, D$eax+4 = D$ebx+4 Dwordr, D$eax+8 = D$ebx+8 Dwordr
                    call MacroIfRecog
                    jmp M1>
                End_If_MemComp

                ;If_And D$eax = 'jmp ', D$eax+4 = 'Code'
                inc eax

            .End_While
M1:
    ...End_if
;--------------------------------------------------------------------------------------------------
;Loop Recon End
;--------------------------------------------------------------------------------------------------

;--------------------------------------------------------------------------------------------------
;Align Recon Start
;--------------------------------------------------------------------------------------------------
    ...If D$eax = 'mov '
        If_MemComp D$eax+3 = D$eax+7 Dwordr
            mov D$eax 'Alig'
            mov D$eax+4 'n 04'
            lea edx D$eax+11 ; endereço da ultima linha onde havia o código da macro [fik apontado no Byte anterior ao 0D]
            lea ecx D$eax+8 ; endereço da ultima posiçao da linha do code, antes de pular a linha
            mov eax ecx ; endereço do final da linha code no handle principal
            call ScanAndRealoc
        End_if_MemComp
    ...End_if
;--------------------------------------------------------------------------------------------------
    ...If D$eax = 'xchg'
        If_MemComp D$eax+4 = D$eax+8 Dwordr
            mov D$eax 'Alig'
            mov D$eax+4 'n 04'
            lea edx D$eax+12 ; endereço da ultima linha onde havia o código da macro [fik apontado no Byte anterior ao 0D]
            lea ecx D$eax+8 ; endereço da ultima posiçao da linha do code, antes de pular a linha
            mov eax ecx ; endereço do final da linha code no handle principal
            call ScanAndRealoc
        End_if_MemComp
    ...End_if
;--------------------------------------------------------------------------------------------------
    ...If D$eax = 'lea '
        If_MemComp W$eax+4 = W$eax+10 Wordr;, B$eax+6 = B$eax+12 Byter
            mov D$eax 'Alig'
            mov D$eax+4 'n 04'
            lea edx D$eax+13 ; endereço da ultima linha onde havia o código da macro [fik apontado no Byte anterior ao 0D]
            lea ecx D$eax+8 ; endereço da ultima posiçao da linha do code, antes de pular a linha
            mov eax ecx ; endereço do final da linha code no handle principal
            call ScanAndRealoc
        End_if_MemComp
    ...End_if
;--------------------------------------------------------------------------------------------------
    ...If D$eax = 'add '
        ..If B$eax+8 = '0'
            If_Or D$eax+4 = 'eax ', D$eax+4 = 'ebx ', D$eax+4 = 'ecx ', D$eax+4 = 'edx ',
                  D$eax+4 = 'edi ', D$eax+4 = 'esi ', D$eax+4 = 'ebp ', D$eax+4 = 'esp '
                mov D$eax 'Alig'
                mov D$eax+4 'n 04'
                lea edx D$eax+9 ; endereço da ultima linha onde havia o código da macro [fik apontado no Byte anterior ao 0D]
                lea ecx D$eax+8 ; endereço da ultima posiçao da linha do code, antes de pular a linha
                mov eax ecx ; endereço do final da linha code no handle principal
                call ScanAndRealoc
            End_If
        ..End_If
    ...End_if
;--------------------------------------------------------------------------------------------------
    ...If D$eax = 'nop ';, B$eax+2 = 'p'
            mov D$eax 'Alig'
            mov D$eax+4 'n 04'
;;
            lea edx D$eax+12 ; endereço da ultima linha onde havia o código da macro [fik apontado no Byte anterior ao 0D]
            lea ecx D$eax+8 ; endereço da ultima posiçao da linha do code, antes de pular a linha
            mov eax ecx ; endereço do final da linha code no handle principal
            call ScanAndRealoc
;;
    ...End_if
;--------------------------------------------------------------------------------------------------
    ...If_And D$eax = 'int ', B$eax+4 = '3'
            mov D$eax 'Alig'
            mov D$eax+4 'n 04'
;;
            lea edx D$eax+12 ; endereço da ultima linha onde havia o código da macro [fik apontado no Byte anterior ao 0D]
            lea ecx D$eax+8 ; endereço da ultima posiçao da linha do code, antes de pular a linha
            mov eax ecx ; endereço do final da linha code no handle principal
            call ScanAndRealoc
;;
    ...End_if
;--------------------------------------------------------------------------------------------------
;Align Recon End
;--------------------------------------------------------------------------------------------------

    inc eax

..End_While

call 'KERNEL32.ExitProcess' &Null
____________________________________________________________________________________________

;;
Alinhamentos

;;falta fazer
nop
int 3

;;feito
mov eax eax | mov ebx ebx | mov ecx ecx | mov edx edx
mov edi edi | mov esi esi | mov ebp ebp | mov esp esp

xchg eax eax

add eax 0 | add ebx 0 | add ecx 0 | add edx 0
add edi 0 | add esi 0 | add ebp 0 | add esp 0

lea eax D$eax | lea ebx D$ebx | lea ecx D$ecx
lea edx D$edx | lea edi D$edi | lea esi D$esi
lea ebp D$ebp | lea esp D$esp
;;
____________________________________________________________________________________________
TITLE Libs

____________________________________________________________________________________________
____________________________________________________________________________________________

;              FIRST PART: TRANSLATING THE WHOLE LIBARY INTO ROSASM SYNTAX

;              Authors: Guga and Betov. August/September 2005?
____________________________________________________________________________________________
____________________________________________________________________________________________

;;

  * Main function:
        LibScanner

  * Main Procedure (Dialog): 'ScanLibFile'
  
  * GUI Functions:

    LibScanCleanUp, LibScanDialog_EnableContinueMenu, SaveLibFileAs, LibScanDialog_ToggleToolbarText,
    LibScanDialog_HoverToolbarText, LibScanDialog_EnableContinuePrevTabMenu, LibScanDialog_EnableContinueNextTabMenu,
    OpenLibFile, LibScanDisplayFileSize, WriteObjectTypeinTitle, CoolControl_LVBeginSort, LibScanDialog_OnNotify,
    CoolControlTB_CreateImageList, CoolControlDlg_CreateTab, Tab1Proc, Tab2Proc, CoolControlWin_CreateToolbar,
    SetupListview, CoolControl_LVBeginSort, ListViewLibSort

  * Library Parsing Routines:
    
    LibCoffMarking, GetLibListing, GetOneCoffListing
    >>> 'OpenLibFile', 'LibSignatureCheck'
  
    >>> either 'GetLibListing' or 'GetOneCoffListing'
    
    'ParseLibObj' calls for 'GetCoffListing', in case of Obj Files in .Lib.
    
    CodeView Checking:
        WriteRawDataDebugS


  * Routines in charge of the IMAGE_FILE_MACHINE Equates:
  
    'WriteIMAGE_FILE_MACHINE', 'IsIMAGE_FILE_MACHINE'
    
    
  * 'WriteAuxiliarySymbolsRecords'

    ToDo:
    
    -   Build the steps for the DIS System. Need to identify all symbols, accordying to the DataTypes. I mean,
        we need to interpret them when they are found inside a CodeView file or inside regular Symbol Structures
        (Auxiliary or not). This is a hell of a work, but it is worthfull, because they contains full info.

    -   Analyze and parse OMF Files (Borland and Microsoft, Libs and Objs). They are not too hard to parse, but there are
        minor differences between M$ and Borland ones.

    -   Analyze and Parse all Delphi DCU files. They are not too hard to parse (Check Dede and DMFtoINT), but
        we must take care of the different delphi versions, because the structures varies sometimes.

;;
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
  File Jobs:
;;


[LibsFileFilter: B$ 'Supported Files (*.lib, *.a, *.obj, *.o, *.dcu, *.pdb, *.dbg)', 0  '*.lib;*.a;*.obj;*.o;*.dcu;*.pdb;*.dbg', 0
                 B$ 'Library Files (*.lib)', 0  '*.lib', 0
                 B$ 'Library Files MingWin32/Gcc (*.a)', 0  '*.a', 0
                 B$ 'Object Files (*.obj)', 0  '*.obj', 0
                 B$ 'Object Files MingWin32/Gcc (*.o)', 0  '*.o', 0
                 B$ 'Delphi and Kilyx Control Unit Files  (*.dcu)', 0  '*.dcu', 0
                 B$ 'Program DataBase Files (*.pdb)', 0  '*.pdb', 0
                 B$ 'Debugging Files  (*.dbg)', 0  '*.dbg', 0
                 B$ 'All Files', 0  '*.*', 0 0]

[CustomLibsFileFilter:  ? #&MAX_PATH]
[LibSaveFilter: ? #&MAX_PATH] [ChoosenLibFile: ? #&MAX_PATH]
[OpenLibFileTitle: B$ 'Choose a Lib file...' 0]

; OpenFile Structure for Libs:

[OPENLIB:
 @lStructSize: D$ Len
 @hwndOwner: D$ 0
 @hInstance: D$ 0
 @lpstrFilter: D$ LibsFileFilter
 @lpstrCustomFilter: D$ CustomLibsFileFilter
 @nMaxCustFilter: D$ 260
 @nFilterIndex: D$ 1
 @lpstrFile: D$ LibSaveFilter
 @nMaxFile: D$ 260
 @lpstrFileTitle: D$ ChoosenLibFile
 @nMaxFileTitle: D$ 260
 @lpstrInitialDir: D$ 0
 @lpstrTitle: D$ OpenLibFileTitle
 @Flags: D$ &OFN_EXPLORER__&OFN_FILEMUSTEXIST__&OFN_LONGNAMES__&OFN_PATHMUSTEXIST
 @nFileOffset: W$ 0
 @nFileExtension: W$ 0
 @lpstrDefExt: D$ 0
 @lCustData: D$ 0
 @lpfnHook: D$ 0
 @lpTemplateName: D$ 0]
____________________________________________________________________________________________

[LibFileHandle: ?    LibFileLength: ?    LibFileMemory: ?   LibFileMemoryEnd: ?]

Proc OpenLibFile:
    Arguments @Adressee

    call 'KERNEL32.CreateFileA' LibSaveFilter, &GENERIC_READ,
                                &FILE_SHARE_READ+&FILE_SHARE_WRITE, 0, &OPEN_EXISTING,
                                &FILE_ATTRIBUTE_NORMAL, 0
    mov D$LibFileHandle eax

    call 'KERNEL32.GetFileSize' eax, 0 | mov D$LibFileLength eax

    call LibScanDisplayFileSize D@Adressee

    If eax = 0
        call LibScanDialog_EnableContinueMenu &FALSE
        call 'USER32.MessageBoxA' 0, {B$ "Dumping process aborted !!!", D$ CRLF2, B$ "The file you are trying to load is empty (The size of the file is Zero).", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL
    Else
        add eax 10

        VirtualAlloc LibFileMemory, eax | add D$LibFileMemory 10

        call 'KERNEL32.ReadFile' D$LibFileHandle, D$LibFileMemory,
                                 D$LibFileLength, NumberOfReadBytes, 0

        call 'KERNEL32.CloseHandle' D$LibFileHandle

        mov eax D$LibFileMemory | add eax D$LibFileLength | mov D$LibFileMemoryEnd eax
    End_If
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  Called from 'ScanLibFile' Dialog Proc:
  
      Main Procedures for the RosAsm syntax translation of a Library
;;
____________________________________________________________________________________________

; Object and Library Constants
[UNKNOWN_LIB_FILE 0]
[COFF_LIB_FILE 1]
[COFF_OBJ_FILE 2]
[DCU1_KILYX_OBJ_FILE 3]
[DCU2_KILYX_OBJ_FILE 4]
[DCU3_KILYX_OBJ_FILE 5]
[DCU2_OBJ_FILE 6]
[DCU3_OBJ_FILE 7]
[DCU4_OBJ_FILE 8]
[DCU5_OBJ_FILE 9]
[DCU6_OBJ_FILE 10]
[DCU7_OBJ_FILE 11]
[OMF_OBJ_FILE 12]
[PDB_OBJ_FILE 13]
[DBG_OBJ_FILE 14]

; Verification Buffer to hold the above constants
[ValidLib: D$ 0]

Proc LibSignatureCheck:
    pushad

  ; Valid Tag?
    mov esi D$LibFileMemory

    .If D$esi+2 = 'arch'
        ; Valid .lib
        mov D$ValidLib COFF_LIB_FILE

    .Else_If D$esi = 0F21F148C ; Borland Kylix 1.0 unit file (DCU). Ver=100
        mov D$ValidLib DCU1_KILYX_OBJ_FILE

    .Else_If D$esi = 0E1011DD ; Borland Kylix 2.0 unit file (DCU). Ver=101
        mov D$ValidLib DCU2_KILYX_OBJ_FILE

    .Else_If D$esi = 0E0001DD ; Borland Kylix 2.0 unit file (kind $00) (DCU). Ver=101
        mov D$ValidLib DCU2_KILYX_OBJ_FILE

    .Else_If D$esi = 0F1001DD ; Borland Kylix 3.0 unit file (DCU). Ver=102
        mov D$ValidLib DCU3_KILYX_OBJ_FILE

    .Else_If D$esi = 050505348 ; Borland Delphi 2.0 unit file (DCU). Ver=2
        mov D$ValidLib DCU2_OBJ_FILE

    .Else_If D$esi = 044518641 ; Borland Delphi 3.0 unit file (DCU). Ver=3
        mov D$ValidLib DCU3_OBJ_FILE

    .Else_If D$esi = 04768A6D8 ; Borland Delphi 4.0 unit file (DCU). Ver=4
        mov D$ValidLib DCU4_OBJ_FILE

    .Else_If D$esi = 0F21F148B ; Borland Delphi 5.0 unit file (DCU). Ver=5
        mov D$ValidLib DCU5_OBJ_FILE

    .Else_If D$esi = 0E0000DD ; Borland Delphi 6.0 unit file (DCU). Ver=6
        mov D$ValidLib DCU6_OBJ_FILE

    .Else_If D$esi = 0E8000DD ; Borland Delphi 6.0 unit file (kind $80) (DCU). Ver=6
        mov D$ValidLib DCU6_OBJ_FILE

    .Else_If D$esi = 0FF80FFFF ; Borland Delphi 7.0 (Free) (DCU). Ver=7
        mov D$ValidLib DCU7_OBJ_FILE

    .Else_If D$esi = 0FF0000DF ; Borland Delphi 7.0 unit file (DCU). Ver=7
        mov D$ValidLib DCU7_OBJ_FILE

    .Else_If D$esi = 0F0000DF ; Borland Delphi 7.0 unit file (DCU). Ver=7
        mov D$ValidLib DCU7_OBJ_FILE

    .Else_If_Or W$esi = &IMAGE_FILE_MACHINE_UNKNOWN, W$esi = &IMAGE_FILE_MACHINE_ALPHA,
                W$esi = &IMAGE_FILE_MACHINE_ALPHA64, W$esi = &IMAGE_FILE_MACHINE_ARM,
                W$esi = &IMAGE_FILE_MACHINE_AXP64, W$esi = &IMAGE_FILE_MACHINE_CEF,
                W$esi = &IMAGE_FILE_MACHINE_I386, W$esi = &IMAGE_FILE_MACHINE_I486,
                W$esi = &IMAGE_FILE_MACHINE_I586, W$esi = &IMAGE_FILE_MACHINE_IA64,
                W$esi = &IMAGE_FILE_MACHINE_M68K, W$esi = &IMAGE_FILE_MACHINE_MIPS16,
                W$esi = &IMAGE_FILE_MACHINE_MIPSFPU, W$esi = &IMAGE_FILE_MACHINE_MIPSFPU16,
                W$esi = &IMAGE_FILE_MACHINE_POWERPC, W$esi = &IMAGE_FILE_MACHINE_R10000,
                W$esi = &IMAGE_FILE_MACHINE_R3000, W$esi = &IMAGE_FILE_MACHINE_R4000,
                W$esi = &IMAGE_FILE_MACHINE_R6000, W$esi = &IMAGE_FILE_MACHINE_SH3,
                W$esi = &IMAGE_FILE_MACHINE_SH3E, W$esi = &IMAGE_FILE_MACHINE_SH4,
                W$esi = &IMAGE_FILE_MACHINE_SH5, W$esi = &IMAGE_FILE_MACHINE_SH3DSP,
                W$esi = &IMAGE_FILE_MACHINE_THUMB, W$esi = &IMAGE_FILE_MACHINE_WCEMIPSV2,
                W$esi = &IMAGE_FILE_MACHINE_AM33, W$esi = &IMAGE_FILE_MACHINE_AMD64,
                W$esi = &IMAGE_FILE_MACHINE_CEE, W$esi = &IMAGE_FILE_MACHINE_EBC,
                W$esi = &IMAGE_FILE_MACHINE_M32R, W$esi = &IMAGE_FILE_MACHINE_POWERPCFP,
                W$esi = &IMAGE_FILE_MACHINE_TRICORE

        ; Valid .obj, if here:
        mov D$ValidLib COFF_OBJ_FILE

    .Else_If_And B$esi = 080, W$esi+1 < 1024, W$esi+1 > 0 ; the W$esi+1 is the record lenght. The max size of the record len is 1024(The entire record, inclusind the magic signature), and it must not be 0
        ; Valid OMF .obj
        mov D$ValidLib OMF_OBJ_FILE

    .Else_If D$esi+40 = 0474A
        ; Valid Pdb file
        mov D$ValidLib PDB_OBJ_FILE

    .Else_If D$esi = 04944
        ; Possible dbg file found
        mov D$ValidLib DBG_OBJ_FILE

    .Else
;;
        cmp B$esi 0F0; LibHdr
        jnz @TestFileType2
        
            mov eax eax
        @TestFileType2: ; Object File Found

        cmp B$esi 080; THEADDR ; Object OMF Sig
        jz @TestFileType3
        cmp B$esi 082; LHEADDR ; Library OMF Sig (Microsoft)
        jnz @TestFileType4

        @TestFileType3:
            movzx eax B$esi+2
            inc esi
            movzx eax B$esi+1 ; The Record length is a word, but the Low order must be 0, because the lenght must be only 255 bytes long
            movzx ecx al
            
@TestFileType4: ; Not OMF
;;
        mov D$ValidLib UNKNOWN_LIB_FILE
    .End_If
    popad
EndP
____________________________________________________________________________________________

; All Identified Libs and Objects are identified by this function.

Proc ParseIdentifiedLibs:
    Arguments @Adressee
    pushad

    mov esi D$LibFileMemory

    .If D$ValidLib = COFF_LIB_FILE
        call WriteObjectTypeinTitle D@Adressee, {"Library COFF", 0}
        call CoffLibFound
        call GetLibListing D@Adressee, hLibReportEdit, hLibReportEditLength

    .Else_If D$ValidLib = COFF_OBJ_FILE
         call WriteObjectTypeinTitle D@Adressee, {"Object COFF", 0}
         call GetOneCoffListing D@Adressee, hLibReportEdit, hLibReportEditLength


    .Else_If D$ValidLib = DCU1_KILYX_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        call LibScanDialog_EnableContinueMenu &FALSE
        call WriteObjectTypeinTitle D@Adressee, {"Delphi Kilyx 1", 0}
        call 'USER32.MessageBoxA' D@Adressee, {B$ "Delphi Kilyx 1 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet.", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU2_KILYX_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        call LibScanDialog_EnableContinueMenu &FALSE
        call WriteObjectTypeinTitle D@Adressee, {"Delphi Kilyx 2", 0}
        call 'USER32.MessageBoxA' D@Adressee, {B$ "Delphi Kilyx2 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet.", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU3_KILYX_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        call LibScanDialog_EnableContinueMenu &FALSE
        call WriteObjectTypeinTitle D@Adressee, {"Delphi Kilyx 3", 0}
        call 'USER32.MessageBoxA' D@Adressee, {B$ "Delphi Kilyx3 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet.", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU2_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        call LibScanDialog_EnableContinueMenu &FALSE
        call WriteObjectTypeinTitle D@Adressee, {"Delphi 2", 0}
        call 'USER32.MessageBoxA' D@Adressee, {B$ "Delphi 2 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet.", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU3_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        call LibScanDialog_EnableContinueMenu &FALSE
        call WriteObjectTypeinTitle D@Adressee, {"Delphi 3", 0}
        call 'USER32.MessageBoxA' D@Adressee, {B$ "Delphi 3 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet.", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU4_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        call LibScanDialog_EnableContinueMenu &FALSE
        call WriteObjectTypeinTitle D@Adressee, {"Delphi 4", 0}
        call 'USER32.MessageBoxA' D@Adressee, {B$ "Delphi 4 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet.", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU5_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        call LibScanDialog_EnableContinueMenu &FALSE
        call WriteObjectTypeinTitle D@Adressee, {"Delphi 5", 0}
        call 'USER32.MessageBoxA' D@Adressee, {B$ "Delphi 5 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet.", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU6_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        call LibScanDialog_EnableContinueMenu &FALSE
        call WriteObjectTypeinTitle D@Adressee, {"Delphi 6", 0}
        call 'USER32.MessageBoxA' D@Adressee, {B$ "Delphi 6 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet.", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DCU7_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        call LibScanDialog_EnableContinueMenu &FALSE
        call WriteObjectTypeinTitle D@Adressee, {"Delphi 7", 0}
        call 'USER32.MessageBoxA' D@Adressee, {B$ "Delphi 7 (DCU) Signature was Found..", D$ CRLF2, B$ "Sorry, but delphi objects are not handled by this dumper yet.", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = OMF_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        call LibScanDialog_EnableContinueMenu &FALSE
        call WriteObjectTypeinTitle D@Adressee, {"OMF Object", 0}
        call 'USER32.MessageBoxA' D@Adressee, {B$ "Object Module Format (OMF) Signature was Found..", D$ CRLF2, B$ "Sorry, but OMF objects are not handled by this dumper yet.", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = PDB_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        call LibScanDialog_EnableContinueMenu &FALSE
        call WriteObjectTypeinTitle D@Adressee, {"Pdb File", 0}
        call 'USER32.MessageBoxA' D@Adressee, {B$ "Program DataBase (Pdb) Signature was Found..", D$ CRLF2, B$ "Sorry, but PDB files are not handled by this dumper yet.", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .Else_If D$ValidLib = DBG_OBJ_FILE
        ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
        call LibScanDialog_EnableContinueMenu &FALSE
        call WriteObjectTypeinTitle D@Adressee, {"Dbg File", 0}
        call 'USER32.MessageBoxA' D@Adressee, {B$ "Degug Format (dbg) Signature was Found..", D$ CRLF2, B$ "Sorry, but dbg files are not handled by this dumper yet.", 0}, {'LibScan', 0},
                                  &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL

    .End_If
    popad
EndP
____________________________________________________________________________________________

Proc CoffLibFound:

  ; Tag:
    add esi 8
   ____________________________________________
  ; First Lib Header:
    If W$esi = '/ '
        push esi
            lea esi D$esi+48 | call GetMemberSize
        pop esi
        add esi 03C | add esi eax | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Second Optional Lib Header:
    If W$esi = '/ '
        push esi
            lea esi D$esi+48 | call GetMemberSize
        pop esi
        add esi 03C | add esi eax | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Third optional Lib Header:
    If W$esi = '//'
        push esi
            lea esi D$esi+48 | call GetMemberSize
        pop esi
        add esi 03C | add esi eax | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Coff Files:
L5: call InitCoffIndice
;;
  We overwrite the "UserID", at +28. We will use this Ordinal to build Synthetic
  Labels (in replacement of the real Names), to save from Duplications, when we
  recompie the output, with RosAsm, for testing the validity of the Rendering
  (Asm Source Form version).
;;
    While B$esi <> 0
        mov eax D$LibObjIndice, D$esi+LIB_USER_ID eax
        mov ax W$LibObjIndice+4, W$esi+LIB_USER_ID+4 ax

        call IncrementLibCoffIndice

        push esi
            lea esi D$esi+LIB_MEMBER_SIZE
            call GetMemberSize
        pop esi

        add esi COFF_HEADER_SIZE | add esi D$MemberSize
        On esi >= D$LibFileMemoryEnd, ExitP
        On B$esi = 0A, inc esi
    End_While

EndP

;;
Proc LibCoffMarking:

  ; Valid Tag?
    mov esi D$LibFileMemory

    .If D$esi+2 = 'arch'
        ; Valid .lib
        mov D$ValidLib COFF_LIB_FILE

    .Else
        call IsIMAGE_FILE_MACHINE D$esi

        If eax = &TRUE
          ; Valid .obj, if here:
            mov D$ValidLib COFF_OBJ_FILE | ExitP

        Else
            call 'USER32.MessageBoxA' 0, {B$ "The 'arch' Magic Signature Tag was not found.", D$ CRLF2, B$ "This is not a COFF Object File", 0}, {'LibScan', 0},
                                      &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL
            mov D$ValidLib UNKNOWN_LIB_FILE | ExitP
        End_If

    .End_If
   ____________________________________________
  ; Tag:
    add esi 8
   ____________________________________________
  ; First Lib Header:
    If W$esi = '/ '
        push esi
            lea esi D$esi+48 | call GetMemberSize
        pop esi
        add esi 03C | add esi eax | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Second Optional Lib Header:
    If W$esi = '/ '
        push esi
            lea esi D$esi+48 | call GetMemberSize
        pop esi
        add esi 03C | add esi eax | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Third optional Lib Header:
    If W$esi = '//'
        push esi
            lea esi D$esi+48 | call GetMemberSize
        pop esi
        add esi 03C | add esi eax | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Coff Files:
L5: call InitCoffIndice

;  We overwrite the "UserID", at +28. We will use this Ordinal to build Synthetic
 ; Labels (in replacement of the real Names), to save from Duplications, when we
  ;recompie the output, with RosAsm, for testing the validity of the Rendering
;  (Asm Source Form version).

    While B$esi <> 0
        mov eax D$LibObjIndice, D$esi+LIB_USER_ID eax
        mov ax W$LibObjIndice+4, W$esi+LIB_USER_ID+4 ax

        call IncrementLibCoffIndice

        push esi
            lea esi D$esi+LIB_MEMBER_SIZE
            call GetMemberSize
        pop esi

        add esi COFF_HEADER_SIZE | add esi D$MemberSize
        On esi >= D$LibFileMemoryEnd, ExitP
        On B$esi = 0A, inc esi
    End_While

EndP

;;

____________________________________________________________________________________________
;;
  To save from Duplications, the Ordinal Coff Indice are stored inside each Heasder
  upon the LIB_USER_ID.
  
  Before writing each Names, we call for 'CopyCoffIndice'.
;;

CopyCoffIndice:
    mov D$edi 'Obj_'
    mov eax D$esi+LIB_USER_ID, D$edi+4 eax,
        ax W$esi+LIB_USER_ID+4, W$edi+8 ax,
        D$edi+10 ' ; '
    add edi 13
ret
____________________________________________________________________________________________

;[@LibHexaMem: ?    @COFFnumber: ?    @Base: ?]
Proc GetLibListing:
    Argument @Handle, @OutPut, @OutputSize

    pushad

        On D$LookUpValidNameCharsTable = 0, call InitLookUpValidNameCharsTable

        ; The Parsed Data will be stored in edi
        mov edi D@OutPut

        mov ecx D$LibFileLength | shl ecx 6 | VirtualAlloc edi ecx

        call GetLongNamesBase

        mov esi D$LibFileMemory, edi D$edi

        ____________________________________________
        ; RosAsm Notice
        mov esi WriteNotice | While B$esi <> 0 | movsb | End_While
        ____________________________________________
        ; Tag:
        call WriteLibTag

        mov D$ARCHIVE_MEMBER_HEADER_Indice '0000', W$ARCHIVE_MEMBER_HEADER_Indice+4 '01'
       ____________________________________________
      ; First Lib Header:
        If W$esi = '/ '
            call Write_IMAGE_ARCHIVE_MEMBER_HEADER_1
          ; First Lib Member:
            push esi
                call WriteHeaderMember1
            pop esi
            add esi D$MemberSize | On B$esi = 0A, inc esi
        End_If
       ____________________________________________
      ; Second optional Lib Header:
        If W$esi = '/ '
            call WriteSecondLibHeaderComment
            call Write_IMAGE_ARCHIVE_MEMBER_HEADER_2
            push esi
                call WriteHeaderMember2
            pop esi
            add esi D$MemberSize | On B$esi = 0A, inc esi
        End_If
       ____________________________________________
      ; Third optional Lib Header:
        If W$esi = '//'

            call WriteThirdLibHeaderComment

            call GetLongNamesPointer
            call Write_IMAGE_ARCHIVE_MEMBER_HEADER_3
            push esi
                call WriteHeaderMember3
            pop esi
            add esi D$MemberSize | On B$esi = 0A, inc esi
        End_If
       ____________________________________________
      ; Coff Files:
        push esi
            mov esi CoffComment
            While B$esi <> 0 | movsb | End_While
        pop esi

        call InitCoffIndice

        sub D$LibFileMemoryEnd 20

        While esi < D$LibFileMemoryEnd
            call WriteCoffTitle
            call Write_Obj_IMAGE_ARCHIVE_MEMBER_HEADER
            call ParseLibObj
            ; To be used in the listview control
            call AddListviewItem, D$hList

            add esi D$MemberSize | On esi >= D$LibFileMemoryEnd, jmp L2>
            On B$esi = 0A, inc esi
            call IncrementLibCoffIndice

        End_While

L2:
        ; The Parsed Data, must be displayed in the edit box
        mov eax D@OutPut    ;   Initial Address of the parsed data
        mov eax D$eax       ;   eax is now at the start of the address

        call 'USER32.SetDlgItemTextA' D$hTabDlg1, IDC_LIB_SOURCE, eax

        ; Computed and store the outputed size of the Parsed Data displayed in the edit control
        mov eax D@OutputSize
        mov ecx D@OutPut
        mov ecx D$ecx
        sub edi ecx
        mov D$eax edi

    popad

EndP

_________________________________________________________________________________________________

[hLibReportEdit: ?];    @COFFnumber: ?    @Base: ?]
[hLibReportEditLength: D$ 0]

Proc GetOneCoffListing:
    Argument @Handle, @OutPut, @OutputSize

    pushad

    ; The Parsed Data will be stored in edi
    mov edi D@OutPut

    call InitCoffIndice

    mov ecx D$LibFileLength | shl ecx 6 | VirtualAlloc edi ecx

    mov esi D$LibFileMemory, edi D$edi

    ____________________________________________
    ; RosAsm Notice
    push esi
    mov esi WriteNotice | While B$esi <> 0 | movsb | End_While
    pop esi

    call ParseLibObj

    call ParseOpenedFilePath LibSaveFilter

    move D$MemberSize D$LibFileLength
    call AddListviewItem, D$hList

    ; The Parsed Data, must be displayed in the edit box
    mov eax D@OutPut    ;   Initial Address of the parsed data
    mov eax D$eax       ;   eax is now at the start of the address
    call 'USER32.SetDlgItemTextA' D$hTabDlg1 , IDC_LIB_SOURCE, eax; SHOW ALL Parsed Data in the 1st Tab dialog...

    ; Computed and store the outpued size of the Parsed Data displayed in the edit control
    mov eax D@OutputSize
    mov ecx D@OutPut
    mov ecx D$ecx
    sub edi ecx
    mov D$eax edi

    popad
EndP

_________________________________________________________________________________________________

; This function is to be used for displaying the object file name in the list view

; Built this way to solve really weird file namings paths. This is similar to ParseLibObjectSymbolName


Proc ParseOpenedFilePath:
    Arguments @StartAddress
    Local @TempEndAddr, @TempStartAddr, @StartExportObjAddr, @EndObjPathAddr, @StartObjExtensionAddr, @UseExportedLibrary

    pushad

    ; Always clear the loaded data before use.
    call ClearBuffer ObjectName, 256
    call ClearBuffer ObjExtensionStr, 16
    call ClearBuffer ObjPathStr, 256

    ; Initialize all the data
    mov D$ObjFileNameType 0
    mov D$UseObjPath 0
    mov D$UseObjExtension 0
    mov D@TempStartAddr 0
    mov D@TempEndAddr 0
    mov D@StartExportObjAddr 0
    mov D@UseExportedLibrary 0

    mov esi D@StartAddress

    While B$esi <> 0
        inc esi
    End_While
    mov D@TempEndAddr esi

    ; 1st Step. Now that we have our full string, we need to see if it have any path inside.
    ; We must start from the end to the beginning of the string to find the path chars.
    mov esi D@StartAddress
    mov ecx D@TempEndAddr

    .While esi <> ecx

        If_Or B$ecx = '/', B$ecx = '\'

            mov D@EndObjPathAddr ecx
            mov D$UseObjPath 1
            jmp L1>
        End_If

        dec ecx
    .End_While

   L1:

    ; 2nd Step. If we have a Path, we will copy it to the proper Buffer (ObjPathStr)

    .If D$UseObjPath = 1
        ; Here esi is already defined as the starting point. We don't need to change it now.
        mov ecx D@EndObjPathAddr
        mov edi ObjPathStr

        .While esi <> ecx
            movsb
            ;inc esi
        .End_While
        inc esi ; Bypass the last "/" or "\" char preceeding the object name.
        mov D@StartAddress esi ; Will points to the beginning of the object name only

    .End_If


    ; 3rd Step. Chekc the file name Type. If the len of the object name is equal or bigger then 16 bytes, it is a LongName.
    ; Otherwise it is short name.

    mov eax D@TempEndAddr
    sub eax D@StartAddress

    If eax <= 16
        mov D$ObjFileNameType 0
    Else
        mov D$ObjFileNameType 1
    End_If



    ; 4th Step. At this point we have only the name of the object and it's extension (if any).
    ; So we must find and copy the object extension.

    mov esi D@StartAddress
    mov ecx D@TempEndAddr
    mov edi ObjectName

    .Do

        .If B$esi = '.'
            mov D$UseObjExtension 1
            mov edi ObjExtensionStr
            inc esi ; Bypass the "." char
            While esi <> ecx
                movsb
            End_While
            jmp L2>
        .End_If

        movsb
    .Loop_Until esi = ecx

   L2:

    popad
EndP

_________________________________________________________________________________________________


[CoffListingTitle: "
; -------------------- Coff Listing: -------------------------

[IMAGE_FILE_HEADER_", 0]

[ObjMachineText: B$ 'Machine: W$ ', 0
 ObjNumberOfSectionsText: 'NumberOfSections: W$ ', 0
 ObjTimeDateStampText: 'TimeDateStamp: D$ ', 0
 ObjPointerToSymbolTableText: 'PointerToSymbolTable: D$ ', 0
 ObjPbjNumberOfSymbolsText: 'NumberOfSymbols: D$ ', 0
 ObjSizeOfOptionalHeaderText: 'SizeOfOptionalHeader: W$ ', 0
 ObjCharacteristicsText: 'Characteristics: W$ ', 0

SymbolTableText: 'ImgSym000001 - IMAGE_FILE_HEADER_', 0]



[SizeOfOptionalHeaderInObj: ?   ObjNumberOfSections: ?   FirstSectionPointer: ?]

GetCoffIMAGE_FILE_HEADER:
    push esi
        mov esi CoffListingTitle
        While B$esi <> 0 | movsb | End_While
        call WriteIndiceOnly
        mov B$edi ':', W$edi+1 CRLF | add edi 3
    pop esi

    ; To be used in AddListviewItem
    push esi
        mov D$LvOffsetCOFF 0 ; always initialize at 0 1st, due to the several loopings for each object.
        sub esi D$LibFileMemory
        mov D$LvOffsetCOFF esi
    pop esi

    call WriteLibImportObjItem ObjMachineText, &FALSE | sub edi 2
        ; To be used in AddListviewItem
        mov W$CoffMachineType 0 ; always initialize at 0 1st, due to the several loopings for each object.
        move W$CoffMachineType W$esi
    call Write_IMAGE_FILE_MACHINE D$esi | mov W$edi CRLF | add edi 2

    add esi 2 | movzx eax W$esi | mov D$ObjNumberOfSections eax

    call WriteLibImportObjItem ObjNumberOfSectionsText, &TRUE

    add esi 2 | mov eax D$esi
    call WriteLibImportObjItem ObjTimeDateStampText, &TRUE
    call WriteLinkerMemberTimeDateStamp D$esi

    add esi 4 | mov eax D$esi
    mov D$CoffSymbolsPointer eax ; To be used in WriteImageSymbolTable
    call WriteLibImportObjItem ObjPointerToSymbolTableText, &FALSE | sub edi 2

    If eax <> 0
        call WriteLibImportObjItem SymbolTableText, &FALSE | sub edi 2
        call WriteIndiceOnly
        push esi
            mov esi {' ; Hex Value:  ', 0}
            While B$esi <> 0 | movsb | End_While
        pop esi
    End_If

    call Writeeax | mov W$edi CRLF | add edi 2 ; Write the Value of the SymbolTable Pointer in Hexadecimal string


    add esi 4 | mov eax D$esi
    mov D$CoffSymbolsNumber eax ; To be used in WriteImageSymbolTable
    mov D$ObjSymbolsNumber eax ; To be used in AddListviewItem
    call WriteLibImportObjItem ObjPbjNumberOfSymbolsText, &TRUE

    add esi 4 | movzx eax W$esi | mov D$SizeOfOptionalHeaderInObj eax
    call WriteLibImportObjItem ObjSizeOfOptionalHeaderText, &TRUE

    add esi 2 | movzx eax W$esi
    call WriteLibImportObjItem ObjCharacteristicsText, &TRUE | sub edi 2
    movzx eax W$esi
    If eax <> 0
        call WriteObjCharacteristics
    End_If

    mov W$edi CRLF
    mov B$edi+2 ']'
    mov D$edi+3 CRLF2 | add edi 7

    add esi 2
ret


[CoffListingIMAGE_OPTIONAL_HEADERTitle: B$ "[IMAGE_OPTIONAL_HEADER_", 0

 ImgOptHdr.Magic: W$'ImgOptHdr.Magic: W$ ', 0
 ImgOptHdr.MajorLinkerVersion: 'ImgOptHdr.MajorLinkerVersion: B$ ', 0
 ImgOptHdr.MinorLinkerVersion: 'ImgOptHdr.MinorLinkerVersion: B$ ', 0
 ImgOptHdr.SizeOfCode: 'ImgOptHdr.SizeOfCode: D$ ', 0
 ImgOptHdr.SizeOfInitializedData: 'ImgOptHdr.SizeOfInitializedData: D$ ', 0
 ImgOptHdr.SizeOfUninitializedData: 'ImgOptHdr.SizeOfUninitializedData: D$ ', 0
 ImgOptHdr.AddressOfEntryPoint: 'ImgOptHdr.AddressOfEntryPoint: D$ ', 0
 ImgOptHdr.BaseOfCode: 'ImgOptHdr.BaseOfCode: D$ ', 0
 ImgOptHdr.BaseOfData: 'ImgOptHdr.BaseOfData: D$ ', 0
 ImgOptHdr.ImageBase: 'ImgOptHdr.ImageBase: D$ ', 0
 ImgOptHdr.SectionAlignment: 'ImgOptHdr.SectionAlignment: D$ ', 0
 ImgOptHdr.FileAlignment: 'ImgOptHdr.FileAlignment: D$ ', 0
 ImgOptHdr.MajorOperatingSystemVersion: 'ImgOptHdr.MajorOperatingSystemVersion: W$ ', 0
 ImgOptHdr.MinorOperatingSystemVersion: 'ImgOptHdr.MinorOperatingSystemVersion: W$ ', 0
 ImgOptHdr.MajorImageVersion: 'ImgOptHdr.MajorImageVersion: W$ ', 0
 ImgOptHdr.MinorImageVersion: 'ImgOptHdr.MinorImageVersion: W$ ', 0
 ImgOptHdr.MajorSubsystemVersion: 'ImgOptHdr.MajorSubsystemVersion: W$ ', 0
 ImgOptHdr.MinorSubsystemVersion: 'ImgOptHdr.MinorSubsystemVersion: W$ ', 0
 ImgOptHdr.Win32VersionValue: 'ImgOptHdr.Win32VersionValue: D$ ', 0
 ImgOptHdr.SizeOfImage: 'ImgOptHdr.SizeOfImage: D$ ', 0
 ImgOptHdr.SizeOfHeaders: 'ImgOptHdr.SizeOfHeaders: D$ ', 0
 ImgOptHdr.CheckSum: 'ImgOptHdr.CheckSum: D$ ', 0
 ImgOptHdr.Subsystem: 'ImgOptHdr.Subsystem: W$ ', 0
 ImgOptHdr.DllCharacteristics: 'ImgOptHdr.DllCharacteristics: W$ ', 0
 ImgOptHdr.SizeOfStackReserve: 'ImgOptHdr.SizeOfStackReserve: D$ ', 0
 ImgOptHdr.SizeOfStackCommit: 'ImgOptHdr.SizeOfStackCommit: D$ ', 0
 ImgOptHdr.SizeOfHeapReserve: 'ImgOptHdr.SizeOfHeapReserve: D$ ', 0
 ImgOptHdr.SizeOfHeapCommit: 'ImgOptHdr.SizeOfHeapCommit: D$ ', 0
 ImgOptHdr.LoaderFlags: 'ImgOptHdr.LoaderFlags: D$ ', 0
 ImgOptHdr.NumberOfRvaAndSizes: 'ImgOptHdr.NumberOfRvaAndSizes: D$ ', 0

 ImgDataDir.Export: 'ImgDataDir.Export: D$ ', 0
 ImgDataDir.ExportSize: 'ImgDataDir.ExportSize: D$ ', 0
 ImgDataDir.Import: 'ImgDataDir.Import: D$ ', 0
 ImgDataDir.ImportSize: 'ImgDataDir.ImportSize: D$ ', 0
 ImgDataDir.Resource: 'ImgDataDir.Resource: D$ ', 0
 ImgDataDir.ResourceSize: 'ImgDataDir.ResourceSize: D$ ', 0
 ImgDataDir.Exception: 'ImgDataDir.Exception: D$ ', 0
 ImgDataDir.ExceptionSize: 'ImgDataDir.ExceptionSize: D$ ', 0
 ImgDataDir.Certificate: 'ImgDataDir.Certificate: D$ ', 0
 ImgDataDir.CertificateSize: 'ImgDataDir.CertificateSize: D$ ', 0
 ImgDataDir.Relocation: 'ImgDataDir.Relocation: D$ ', 0
 ImgDataDir.RelocationSize: 'ImgDataDir.RelocationSize: D$ ', 0
 ImgDataDir.Debug: 'ImgDataDir.Debug: DebugDir: D$ ', 0
 ImgDataDir.DebugSize: 'ImgDataDir.DebugSize: D$ ', 0
 ImgDataDir.Architecture: 'ImgDataDir.Architecture: D$ ', 0
 ImgDataDir.ArchitectureSize: 'ImgDataDir.ArchitectureSize: D$ ', 0
 ImgDataDir.GPReg: 'ImgDataDir.GPReg: D$ ', 0
 ImgDataDir.GPRegSize: 'ImgDataDir.GPRegSize: D$ ', 0
 ImgDataDir.Thread: 'ImgDataDir.Thread: D$ ', 0
 ImgDataDir.ThreadSize: 'ImgDataDir.ThreadSize: D$ ', 0
 ImgDataDir.ConfigTable: 'ImgDataDir.ConfigTable: D$ ', 0
 ImgDataDir.ConfigTableSize: 'ImgDataDir.ConfigTableSize: D$ ', 0
 ImgDataDir.BoundIAT: 'ImgDataDir.BoundIAT: D$ ', 0
 ImgDataDir.BoundIATSize: 'ImgDataDir.BoundIATSize: D$ ', 0
 ImgDataDir.IAT: 'ImgDataDir.IAT: D$ ', 0
 ImgDataDir.IATSize: 'ImgDataDir.IATSize: D$ ', 0
 ImgDataDir.DelayID: 'ImgDataDir.DelayID: D$ ', 0
 ImgDataDir.DelayIDSize: 'ImgDataDir.DelayIDSize: D$ ', 0
 ImgDataDir.COM: 'ImgDataDir.COM: D$ ', 0
 ImgDataDir.COMSize: 'ImgDataDir.COMSize: D$ ', 0
 ImgDataDir.Reserved: 'ImgDataDir.Reserved: D$ ', 0
 ImgDataDir.ReservedSize: 'ImgDataDir.ReservedSize: D$ ', 0]

[IMAGE_DATA_DIRECTORY_Title: B$ '; ---- IMAGE_DATA_DIRECTORY ----', 0]


Write_IMAGE_DATA_DIRECTORY_Title:
    mov W$edi CRLF | add edi 2

    push esi
        zCopy IMAGE_DATA_DIRECTORY_Title
    pop esi

    mov D$edi CRLF2 | add edi 4
ret


WriteObjMagic:
    push esi
        If eax = &IMAGE_NT_OPTIONAL_HDR32_MAGIC
            zCopy {' ; &IMAGE_NT_OPTIONAL_HDR32_MAGIC', 0}
        Else_If eax = &IMAGE_NT_OPTIONAL_HDR64_MAGIC
            zCopy {' ; &IMAGE_NT_OPTIONAL_HDR64_MAGIC', 0}
        Else
            zCopy {' ; Likely corrupted unknown Magic Value', 0}
        End_If
    pop esi

    mov W$edi CRLF | add edi 2
ret


WriteObjSubSystem:
    push esi
        .If eax = &IMAGE_SUBSYSTEM_UNKNOWN
            zCopy {' ; &IMAGE_SUBSYSTEM_UNKNOWN', 0}
        .Else_If eax = &IMAGE_SUBSYSTEM_NATIVE
            zCopy {' ; &IMAGE_SUBSYSTEM_NATIVE', 0}
        .Else_If eax = &IMAGE_SUBSYSTEM_WINDOWS_GUI
            zCopy {' ; &IMAGE_SUBSYSTEM_WINDOWS_GUI', 0}
        .Else_If eax = &IMAGE_SUBSYSTEM_WINDOWS_CUI
            zCopy {' ; &IMAGE_SUBSYSTEM_WINDOWS_CUI', 0}
        .Else_If eax = &IMAGE_SUBSYSTEM_OS2_CUI
            zCopy {' ; &IMAGE_SUBSYSTEM_OS2_CUI', 0}
        .Else_If eax = &IMAGE_SUBSYSTEM_POSIX_CUI
            zCopy {' ; &IMAGE_SUBSYSTEM_POSIX_CUI', 0}
        .Else_If eax = &IMAGE_SUBSYSTEM_WINDOWS_CE_GUI
            zCopy {' ; &IMAGE_SUBSYSTEM_WINDOWS_CE_GUI', 0}
        .Else_If eax = &IMAGE_SUBSYSTEM_EFI_APPLICATION
            zCopy {' ; &IMAGE_SUBSYSTEM_EFI_APPLICATION', 0}
        .Else_If eax = &IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER
            zCopy {' ; &IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER', 0}
        .Else_If eax = &IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER
            zCopy {' ; &IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER', 0}
        .Else_If eax = &IMAGE_SUBSYSTEM_NATIVE_WINDOWS
            zCopy {' ; &IMAGE_SUBSYSTEM_NATIVE_WINDOWS', 0}
        .Else
            zCopy {' ; Likely corrupted unknown SubSystem Record', 0}
        .End_If
    pop esi

    mov W$edi CRLF | add edi 2
ret


WriteDllCharacteristics:
    .If eax <> 0
        push esi
            mov D$edi ' ; ' | add edi 3

            test eax &IMAGE_DLLCHARACTERISTICS_PPROCESS_LIB_INIT | jz L1>
                zCopy {'&IMAGE_DLLCHARACTERISTICS_PPROCESS_LIB_INIT__', 0}

L1:         test eax &IMAGE_DLLCHARACTERISTICS_PPROCESS_LIB_TERM | jz L1>
                zCopy {'&IMAGE_DLLCHARACTERISTICS_PPROCESS_LIB_TERM__', 0}

L1:         test eax &IMAGE_DLLCHARACTERISTICS_PTHREAD_LIB_INIT | jz L1>
                zCopy {'&IMAGE_DLLCHARACTERISTICS_PTHREAD_LIB_INIT__', 0}

L1:         test eax &IMAGE_DLLCHARACTERISTICS_PTHREAD_LIB_TERM | jz L1>
                zCopy {'&IMAGE_DLLCHARACTERISTICS_PTHREAD_LIB_TERM__', 0}

L1:         test eax &IMAGE_DLLCHARACTERISTICS_NO_BIND | jz L1>
                zCopy {'&IMAGE_DLLCHARACTERISTICS_NO_BIND__', 0}

L1:         test eax &IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE | jz L1>
                zCopy {'&IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE__', 0}

L1:         test eax &IMAGE_DLLCHARACTERISTICS_WDM_DRIVER | jz L1>
                zCopy {'&IMAGE_DLLCHARACTERISTICS_WDM_DRIVER__', 0}

L1:         While B$edi = '_' | dec edi | End_While
        pop esi
    .End_If

    mov W$edi CRLF | add edi 2
ret


GetCoffIMAGE_OPTIONAL_HEADER:
    push esi
        mov esi CoffListingIMAGE_OPTIONAL_HEADERTitle
        While B$esi <> 0 | movsb | End_While
        call WriteIndiceOnly
        mov B$edi ':', W$edi+1 CRLF | add edi 3
    pop esi

    movzx eax W$esi
    push eax
    call WriteLibImportObjItem ImgOptHdr.Magic, &TRUE | sub edi 2
    pop eax
    call WriteObjMagic

    add esi 2 | movzx eax B$esi
    call WriteLibImportObjItem ImgOptHdr.MajorLinkerVersion, &TRUE

    inc esi | movzx eax B$esi
    call WriteLibImportObjItem ImgOptHdr.MinorLinkerVersion, &TRUE

    inc esi
    lodsd | call WriteLibImportObjItem ImgOptHdr.SizeOfCode, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.SizeOfInitializedData, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.SizeOfUninitializedData, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.AddressOfEntryPoint, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.BaseOfCode, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.BaseOfData, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.ImageBase, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.SectionAlignment, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.FileAlignment, &TRUE

    lodsw | and eax 0FFFF
    call WriteLibImportObjItem ImgOptHdr.MajorOperatingSystemVersion, &TRUE

    lodsw | and eax 0FFFF
    call WriteLibImportObjItem ImgOptHdr.MinorOperatingSystemVersion, &TRUE

    lodsw | and eax 0FFFF
    call WriteLibImportObjItem ImgOptHdr.MajorImageVersion, &TRUE

    lodsw | and eax 0FFFF
    call WriteLibImportObjItem ImgOptHdr.MinorImageVersion, &TRUE

    lodsw | and eax 0FFFF
    call WriteLibImportObjItem ImgOptHdr.MajorSubsystemVersion, &TRUE

    lodsw | and eax 0FFFF
    call WriteLibImportObjItem ImgOptHdr.MinorSubsystemVersion, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.Win32VersionValue, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.SizeOfImage, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.SizeOfHeaders, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.CheckSum, &TRUE

    lodsw | and eax 0FFFF
    push eax
    call WriteLibImportObjItem ImgOptHdr.Subsystem, &TRUE | sub edi 2
    pop eax
    call WriteObjSubSystem

    lodsw | and eax 0FFFF
    push eax
    call WriteLibImportObjItem ImgOptHdr.DllCharacteristics, &TRUE | sub edi 2
    pop eax
    call WriteDllCharacteristics

    lodsd | call WriteLibImportObjItem ImgOptHdr.SizeOfStackReserve, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.SizeOfStackCommit, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.SizeOfHeapReserve, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.SizeOfHeapCommit, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.LoaderFlags, &TRUE

    lodsd | call WriteLibImportObjItem ImgOptHdr.NumberOfRvaAndSizes, &TRUE


    call Write_IMAGE_DATA_DIRECTORY_Title


    lodsd | call WriteLibImportObjItem ImgDataDir.Export, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.ExportSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.Import, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.ImportSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.Resource, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.ResourceSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.Exception, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.ExceptionSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.Certificate, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.CertificateSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.Relocation, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.RelocationSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.Debug, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.DebugSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.Architecture, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.ArchitectureSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.GPReg, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.GPRegSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.Thread, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.ThreadSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.ConfigTable, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.ConfigTableSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.BoundIAT, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.BoundIATSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.IAT, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.IATSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.DelayID, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.DelayIDSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.COM, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.COMSize, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.Reserved, &TRUE

    lodsd | call WriteLibImportObjItem ImgDataDir.ReservedSize, &TRUE

    sub edi 2 | mov B$edi ']', D$edi+1 CRLF2 | add edi 5

ret
____________________________________________________________________________________________


[CoffSectionHeaderTitle: "
;;
_____________________________________________________

The Section Header
_____________________________________________________
_____________________________________________________

IMAGE_SECTION_HEADER Structure

;;

", 0]

[SectionHeaderNumber: '001', 0]

InitSectionHeaderNumber:
    mov D$SectionHeaderNumber '001'
ret



IncrementSectionHeaderNumber:

    push ebx
        lea ebx D$SectionHeaderNumber+2

        inc B$ebx
        While B$ebx > '9'
            mov B$ebx '0' | dec ebx | inc B$ebx
        End_While
    pop ebx
ret

[CoffSectionHeaderName: 'Name1', 0
 CoffSectionHeaderVirtualSize: 'MiscVirtualSize', 0
 CoffSectionHeaderRVA: 'VirtualAddress', 0
 CoffSectionHeaderSize: 'SizeOfRawData', 0
 CoffSectionHeaderPointerToData: 'PointerToRawData', 0
 CoffSectionHeaderPointerToReloc: 'PointerToRelocations', 0
 CoffSectionHeaderPointerToLinesNumbers: 'PointerToLinenumbers', 0
 CoffSectionHeaderNumberOfRelocations: 'NumberOfRelocations', 0
 CoffSectionHeaderNumberOfLinesNumbers: 'NumberOfLinenumbers', 0
 CoffSectionHeaderCharacteristics: 'Characteristics', 0]

Proc WriteObjSectionHeaderItem:
    Argument @Text1, @Text2

        push esi
            call WriteObjIndice
            zCopy {'ImgSecHdr', 0}
            zCopy SectionHeaderNumber
            mov B$edi '.' | inc edi
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text2, al B$eax+2

        ...If al = 'B'
            mov edx esi | add edx 8
            mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:         mov B$edi "'" | inc edi
            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ...Else_If al = 'W'
            lodsw | and eax 0FFFF | call WriteEax

        ...Else

            ..If D$esi <> 0
                mov eax D@Text1

                .If D$eax = 'Size' ; from "SizeOfRawData" string

                    call WriteSectionHeaderRawSizeDiffLabel
                    push esi | zcopy {" ; Hex Value:  ", 0} | pop esi

                .Else_If D$eax+8 = 'oRaw'; From "PointerToRawData" string
                    ;mov eax D$esi-4
                    If D$esi-4 = 0
                        mov D$esi 0
                    Else

                        call WriteSectionHeaderPointerToDataDiffLabel
                        push esi | zcopy {" ; Hex Value:  ", 0} | pop esi
                    End_If
                .Else_If D$eax+9 = 'Relo'; From "PointerToRelocations" string
                    call InitSectionRelocNumber
                    ;movzx eax W$esi+4+4
                    ; Fix the value at esi when the Reloc Number is 0, but it is pointing somewhere
                    If W$esi+4+4 = 0
                        mov D$esi 0
                    Else
                        call WriteSectionHeaderPointerToRelocDiffLabel
                        push esi | zcopy {" ; Hex Value:  ", 0} | pop esi
                    End_If
                .Else_If D$eax+9 = 'Line'; From "PointerToLinenumbers" string
                    call InitSectionLineNumber
                    ;movzx eax W$esi+4+2
                    If W$esi+4+2 = 0
                        mov D$esi 0
                    Else
                        call WriteSectionHeaderPointerToLineNumberDiffLabel
                        push esi | zcopy {" ; Hex Value:  ", 0} | pop esi
                    End_If
;;
                Else_If D$eax = 'Misc'; From "MiscVirtualSize" string

                    call WriteSectionHeaderVirtualSizeDiffLabel
                    push esi | zcopy {" ; Hex Value:  ", 0} | pop esi
;;

                .End_If

            ..End_If

            lodsd | call WriteEax

        ...End_If

        mov W$edi CRLF | add edi 2
EndP


WriteCharacteristicsEquates:

    If eax <> 0
        mov D$edi ' ; ' | add edi 3
    End_If

    test eax &IMAGE_SCN_TYPE_REG | jz L1>
        zCopy {'&IMAGE_SCN_TYPE_REG__', 0}
L1: test eax &IMAGE_SCN_TYPE_DSECT | jz L1>
        zCopy {'&IMAGE_SCN_TYPE_DSECT__', 0}
L1: test eax &IMAGE_SCN_TYPE_NOLOAD | jz L1>
        zCopy {'&IMAGE_SCN_TYPE_NOLOAD__', 0}
L1: test eax &IMAGE_SCN_TYPE_GROUP | jz L1>
        zCopy {'&IMAGE_SCN_TYPE_GROUP__', 0}
L1: test eax &IMAGE_SCN_TYPE_NO_PAD | jz L1>
        zCopy {'&IMAGE_SCN_TYPE_NO_PAD__', 0}
L1: test eax &IMAGE_SCN_TYPE_COPY | jz L1>
        zCopy {'&IMAGE_SCN_TYPE_COPY__', 0}
L1: test eax &IMAGE_SCN_CNT_CODE | jz L1>
        zCopy {'&IMAGE_SCN_CNT_CODE__', 0}
L1: test eax &IMAGE_SCN_CNT_INITIALIZED_DATA | jz L1>
        zCopy {'&IMAGE_SCN_CNT_INITIALIZED_DATA__', 0}
L1: test eax &IMAGE_SCN_CNT_UNINITIALIZED_DATA | jz L1>
        zCopy {'&IMAGE_SCN_CNT_UNINITIALIZED_DATA__', 0}
L1: test eax &IMAGE_SCN_LNK_OTHER | jz L1>
        zCopy {'&IMAGE_SCN_LNK_OTHER__', 0}
L1: test eax &IMAGE_SCN_LNK_INFO | jz L1>
        zCopy {'&IMAGE_SCN_LNK_INFO__', 0}
L1: test eax &IMAGE_SCN_TYPE_OVER | jz L1>
        zCopy {'&IMAGE_SCN_TYPE_OVER__', 0}
L1: test eax &IMAGE_SCN_LNK_REMOVE | jz L1>
        zCopy {'&IMAGE_SCN_LNK_REMOVE__', 0}
L1: test eax &IMAGE_SCN_LNK_COMDAT | jz L1>
        zCopy {'&IMAGE_SCN_LNK_COMDAT__', 0}
L1: test eax &IMAGE_SCN_MEM_FARDATA | jz L1>
        zCopy {'&IMAGE_SCN_MEM_FARDATA__', 0}
L1: test eax &IMAGE_SCN_MEM_PURGEABLE | jz L1>
        zCopy {'&IMAGE_SCN_MEM_PURGEABLE__', 0}
L1: test eax &IMAGE_SCN_MEM_16BIT | jz L1>
        zCopy {'&IMAGE_SCN_MEM_16BIT__', 0}
L1: test eax &IMAGE_SCN_MEM_LOCKED | jz L1>
        zCopy {'&IMAGE_SCN_MEM_LOCKED__', 0}
L1: test eax &IMAGE_SCN_MEM_PRELOAD | jz L1>
        zCopy {'&IMAGE_SCN_MEM_PRELOAD__', 0}

L1: mov ebx eax | and ebx 0FF_0000

    .If ebx = &IMAGE_SCN_ALIGN_1BYTES                ; 010_0000
        zCopy {'&IMAGE_SCN_ALIGN_1BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_2BYTES           ; 020_0000
        zCopy {'&IMAGE_SCN_ALIGN_2BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_4BYTES           ; 030_0000
        zCopy {'&IMAGE_SCN_ALIGN_4BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_8BYTES           ; 040_0000
        zCopy {'&IMAGE_SCN_ALIGN_8BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_16BYTES          ; 050_0000
        zCopy {'&IMAGE_SCN_ALIGN_16BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_32BYTES          ; 060_0000
        zCopy {'&IMAGE_SCN_ALIGN_32BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_64BYTES          ; 070_0000
        zCopy {'&IMAGE_SCN_ALIGN_64BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_128BYTES         ; 080_0000
        zCopy {'&IMAGE_SCN_ALIGN_128BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_256BYTES         ; 090_0000
        zCopy {'&IMAGE_SCN_ALIGN_256BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_512BYTES         ; 0A0_0000
        zCopy {'&IMAGE_SCN_ALIGN_512BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_1024BYTES        ; 0B0_0000
        zCopy {'&IMAGE_SCN_ALIGN_1024BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_2048BYTES        ; 0C0_0000
        zCopy {'&IMAGE_SCN_ALIGN_2048BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_4096BYTES        ; 0D0_0000
        zCopy {'&IMAGE_SCN_ALIGN_4096BYTES__', 0}
    .Else_If ebx = &IMAGE_SCN_ALIGN_8192BYTES        ; 0E0_0000
        zCopy {'&IMAGE_SCN_ALIGN_8192BYTES__', 0}
    .End_If

L1: test eax &IMAGE_SCN_LNK_NRELOC_OVFL | jz L1>
        zCopy {'&IMAGE_SCN_LNK_NRELOC_OVFL__', 0}
L1: test eax &IMAGE_SCN_MEM_DISCARDABLE | jz L1>
        zCopy {'&IMAGE_SCN_MEM_DISCARDABLE__', 0}
L1: test eax &IMAGE_SCN_MEM_NOT_CACHED | jz L1>
        zCopy {'&IMAGE_SCN_MEM_NOT_CACHED__', 0}
L1: test eax &IMAGE_SCN_MEM_NOT_PAGED | jz L1>
        zCopy {'&IMAGE_SCN_MEM_NOT_PAGED__', 0}
L1: test eax &IMAGE_SCN_MEM_SHARED | jz L1>
        zCopy {'&IMAGE_SCN_MEM_SHARED__', 0}
L1: test eax &IMAGE_SCN_MEM_EXECUTE | jz L1>
        zCopy {'&IMAGE_SCN_MEM_EXECUTE__', 0}
L1: test eax &IMAGE_SCN_MEM_READ | jz L1>
        zCopy {'&IMAGE_SCN_MEM_READ__', 0}
L1: test eax &IMAGE_SCN_MEM_WRITE | jz L1>
        zCopy {'&IMAGE_SCN_MEM_WRITE__', 0}
L1:

    While B$edi-1 = '_' | dec edi | End_While
ret



____________________________________________________________________________________________

[MemberName1Offset: ?]

Proc GetName1Offset:
    pushad
        ; edi  is used as a Byte Counter
        mov edi 8 ; Size of the Name1 member
        inc esi ; ByPass the 1st '/'
        mov ecx 10, ebx 0, eax 0

        Do
            On B$esi = 0, jmp L0> ; If we reach 0 jmp over
            On B$esi = ' ', jmp L0> ; If we reach ' ' jmp over
            mul ecx
            push eax
                lodsb | sub al '0' | mov bl al
            pop eax
            add eax ebx
            dec edi
        Loop_Until edi = 0

L0:

        mov D$MemberName1Offset eax

    popad
EndP

____________________________________________________________________________________________



Proc WriteSectionNameStringTablePointerComment:
    Uses esi, eax, edx


    ; Initialize the String Record Counter
    call InitStringTableRecord

    ; eax is pointing to the Offset of the String on the String Table
    mov eax D$MemberName1Offset
    mov edx D$PointerToStringTable
    mov esi edx ; esi is pointing to the Beginning of the String Table
    add edx eax ; edx will be using as a counter of the total amount of strings untill we reach the String where we are.
    add esi 4   ; Bypass the String Table Size. and Point to the beginning of the 1st String

    .Do

        While B$esi <> 0 | inc esi | End_While | inc esi | On B$esi = 0, mov edx 0

        call IncrementStringTableRecord

    .Loop_Until esi >= edx


        push esi
            call WriteObjIndice
            zCopy {'StringData', 0}
            zCopy StringTableRecord
        pop esi


    ; Restore the Value of StringTableRecord

    call InitStringTableRecord


EndP

___________________________________________

[SectionNameIndirectMessage: B$ "________________________________________________________________________

; Section Name indirectly addressed in Name1 member.
; The name of the Section is: ", 0]


Proc WriteIndirectSectionName:
    Uses esi

        call GetName1Offset ; convert the Offset to hexadecimal
        call GetStringTablePointer

        ;zCopy SymbolTableTitle
        mov esi D$CoffSectionBase
        add esi D$CoffSymbolsPointer

        push esi
            zCopy SectionNameIndirectMessage
        pop esi

            mov ecx D$PointerToStringTable

        push esi
            add ecx D$MemberName1Offset | mov esi ecx
            While B$esi <> 0 | movsb | End_While
        pop esi

        push esi
            zCopy {W$ CRLF, B$ "; Referenced in String Table data at: ", 0}
            call WriteSectionNameStringTablePointerComment
            zCopy {W$ CRLF, B$ "________________________________________________________________________", D$ CRLF2 0}
        pop esi

EndP

___________________________________________________

;;

Section Name    Content                     Characteristics
.arch           Alpha architecture info     &IMAGE_SCN_MEM_READ__&IMAGE_SCN_CNT_INITIALIZED_DATA (...) &IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_DISCARDABLE
.bss            Uninitialized data          &IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_MEM_READ (...) &IMAGE_SCN_MEM_WRITE
.data           Initialized data            &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ (...) &IMAGE_SCN_MEM_WRITE
.edata          Export tables               &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ
.idata          Import tables               &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.pdata          Exception information       &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ
.rdata          Read-only initialized data  &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ
.reloc          Image relocations           &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ (...) &IMAGE_SCN_MEM_DISCARDABLE
.rsrc           Resource directory          &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ (...) &IMAGE_SCN_MEM_WRITE
.text           Executable code             &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_MEM_EXECUTE (...) &IMAGE_SCN_MEM_READ
.tls            Thread-local storage        &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ (...) &IMAGE_SCN_MEM_WRITE
.xdata          Exception information       &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ


&IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE = 0E0000040

&IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE = 0E0000080

Some common Names and their Flag values:

.bss C0300080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.bss C0301080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.bss C0400080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.bss C0401080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.bss C0500080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA__&IMAGE_SCN_ALIGN_16BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.CRT C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.data C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.data C0301040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.data C0400040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.data C0401040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.data C0500040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_16BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.debug 42000048 &IMAGE_SCN_TYPE_NO_PAD__&IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_DISCARDABLE__&IMAGE_SCN_MEM_READ
.debug 42100040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_1BYTES__&IMAGE_SCN_MEM_DISCARDABLE__&IMAGE_SCN_MEM_READ
.debug 42100048 &IMAGE_SCN_TYPE_NO_PAD__&IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_1BYTES__&IMAGE_SCN_MEM_DISCARDABLE__&IMAGE_SCN_MEM_READ
.debug 42101040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_1BYTES__&IMAGE_SCN_MEM_DISCARDABLE__&IMAGE_SCN_MEM_READ
.debug 42101048 &IMAGE_SCN_TYPE_NO_PAD__&IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_1BYTES__&IMAGE_SCN_MEM_DISCARDABLE__&IMAGE_SCN_MEM_READ
.debug 42400048 &IMAGE_SCN_TYPE_NO_PAD__&IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_DISCARDABLE__&IMAGE_SCN_MEM_READ
.drectve 100A00 &IMAGE_SCN_LNK_INFO__&IMAGE_SCN_LNK_REMOVE__&IMAGE_SCN_ALIGN_1BYTES
.idata C0000048 &IMAGE_SCN_TYPE_NO_PAD__&IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.idata C0100040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_1BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.idata C0200040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_2BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.idata C0201040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_2BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.idata C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.idata C0301040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.orpc 60501020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_16BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.rdata 40300040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ
.rdata 40301040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ
.rdata 40400040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ
.rdata 40401040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ
.rdata 40500040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_16BYTES__&IMAGE_SCN_MEM_READ
.text 400020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_ALIGN_8BYTES
.text 60000020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.text 60101020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_1BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.text 60201020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_2BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.text 60300020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.text 60301020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.text 60500020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_ALIGN_16BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.text 60501020 &IMAGE_SCN_CNT_CODE__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_16BYTES__&IMAGE_SCN_MEM_EXECUTE__&IMAGE_SCN_MEM_READ
.tls C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_ALIGN_4BYTES__&IMAGE_SCN_MEM_READ__&IMAGE_SCN_MEM_WRITE
.xdata 40401040 &IMAGE_SCN_CNT_INITIALIZED_DATA__&IMAGE_SCN_LNK_COMDAT__&IMAGE_SCN_ALIGN_8BYTES__&IMAGE_SCN_MEM_READ


__________________________________

Detailed sections found on several Libraries and executables files

.text 400020 &IMAGE_SCN_CNT_CODE   &IMAGE_SCN_ALIGN_8BYTES  
.orpc 60501020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_16BYTES &IMAGE_SCN_LNK_COMDAT 
.text 60000020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ   
.text 60101020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_1BYTES &IMAGE_SCN_LNK_COMDAT 
.text 60201020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_2BYTES &IMAGE_SCN_LNK_COMDAT 
.text 60300020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_4BYTES  
.text 60301020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_4BYTES &IMAGE_SCN_LNK_COMDAT 
.text 60500020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_16BYTES  
.text 60501020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_16BYTES &IMAGE_SCN_LNK_COMDAT 

; Data Flags

.CRT C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES 
.data C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES 
.data C0301040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES &IMAGE_SCN_LNK_COMDAT
.data C0400040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_8BYTES 
.data C0401040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_8BYTES &IMAGE_SCN_LNK_COMDAT
.data C0500040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_16BYTES 

.edata 040000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  
.rdata 040000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  
.rsrc 040000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  
.rdata 040000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  
.INIT 042000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  &IMAGE_SCN_MEM_DISCARDABLE
.reloc 042000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  &IMAGE_SCN_MEM_DISCARDABLE
.rdata 050000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  &IMAGE_SCN_MEM_SHARED
.reloc 050000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  &IMAGE_SCN_MEM_SHARED
.rsrc 050000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  &IMAGE_SCN_MEM_SHARED
BSS 0C0000000  &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 
.tls 0C0000000  &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 
.idata 0C0000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 
DATA 0C0000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 
.data 0C0000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 
.shared 0D0000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_MEM_SHARED
.idata 040000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ  
.bss 0C0000080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 
.CRT 0C0000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE 

; Really weird sections at C:\WINNT\Driver Cache\i386 
; It is worthfull to analyze to fix them like I was doing for the Dumped files. (RosAsm crashes, for example at ftdisk.sys)

PAGE 060000020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ  
INIT 0E2000020 &IMAGE_SCN_CNT_CODE &IMAGE_SCN_MEM_EXECUTE &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_MEM_DISCARDABLE

.rdata 048000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_NOT_PAGED  
.data 0C8000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_NOT_PAGED &IMAGE_SCN_MEM_WRITE 
.rsrc 042000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE  
.reloc 042000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE  
.rsrc 048000040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_NOT_PAGED  


; Debug Data
; Name Types .debug$S; .debug$F; .debug$T; .debug$P

.debug$S 42000048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  
.debug$F 42100040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE   &IMAGE_SCN_ALIGN_1BYTES
.debug$S 42100040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE   &IMAGE_SCN_ALIGN_1BYTES
.debug$T 42100040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE   &IMAGE_SCN_ALIGN_1BYTES
.debug$P 42100048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  &IMAGE_SCN_ALIGN_1BYTES
.debug$S 42100048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  &IMAGE_SCN_ALIGN_1BYTES
.debug$T 42100048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  &IMAGE_SCN_ALIGN_1BYTES
.debug$S 42101040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE  &IMAGE_SCN_LNK_COMDAT &IMAGE_SCN_ALIGN_1BYTES
.debug$F 42101048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD &IMAGE_SCN_LNK_COMDAT &IMAGE_SCN_ALIGN_1BYTES
.debug$S 42101048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD &IMAGE_SCN_LNK_COMDAT &IMAGE_SCN_ALIGN_1BYTES
.debug$F 42400048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  &IMAGE_SCN_ALIGN_8BYTES

.debug 42100040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE   &IMAGE_SCN_ALIGN_1BYTES
.debug 42101040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE  &IMAGE_SCN_LNK_COMDAT &IMAGE_SCN_ALIGN_1BYTES
.debug 42000048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  
.debug 42100048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  &IMAGE_SCN_ALIGN_1BYTES
.debug 42101048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD &IMAGE_SCN_LNK_COMDAT &IMAGE_SCN_ALIGN_1BYTES
.debug 42400048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_DISCARDABLE &IMAGE_SCN_TYPE_NO_PAD  &IMAGE_SCN_ALIGN_8BYTES

.idata C0100040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_1BYTES  
.idata C0200040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_2BYTES  
.idata C0201040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_2BYTES  &IMAGE_SCN_LNK_COMDAT
.idata C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES  
.idata C0301040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES  &IMAGE_SCN_LNK_COMDAT
.idata C0000048 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE  &IMAGE_SCN_TYPE_NO_PAD 

.rdata 040300040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_4BYTES 
.rdata 040301040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_4BYTES &IMAGE_SCN_LNK_COMDAT
.rdata 040400040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_8BYTES 
.rdata 040401040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_8BYTES &IMAGE_SCN_LNK_COMDAT
.rdata 040500040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_16BYTES 

.tls 0C0300040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES


.xdata 040401040 &IMAGE_SCN_CNT_INITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_ALIGN_8BYTES &IMAGE_SCN_LNK_COMDAT

; Virtual Data Flags

.bss 0C0300080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES 
.bss 0C0301080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_4BYTES &IMAGE_SCN_LNK_COMDAT
.bss 0C0400080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_8BYTES 
.bss 0C0401080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_8BYTES &IMAGE_SCN_LNK_COMDAT
.bss 0C0500080 &IMAGE_SCN_CNT_UNINITIALIZED_DATA &IMAGE_SCN_MEM_READ &IMAGE_SCN_MEM_WRITE &IMAGE_SCN_ALIGN_16BYTES 

; Linker Directive Flags

.drectve 0100A00 &IMAGE_SCN_LNK_INFO &IMAGE_SCN_LNK_REMOVE &IMAGE_SCN_ALIGN_1BYTES




;;

[RawDataType: D$ 0]

; RawData Types Constants

[RDT_DATA 0] ; This is the default. If everything fails, it always set to DATA
[RDT_LNKDIRECTIVE 1]
[RDT_CODE 2]
[RDT_VIRTUALDATA 3]
[RDT_DEBUGS 4]
[RDT_DEBUGF 5]
[RDT_DEBUGT 6]
[RDT_DEBUGP 7]
[RDT_IDATA 8]
[RDT_RDATA 9]
[RDT_XDATA 10]
[RDT_PDATA 11]
[RDT_EDATA 12]
[RDT_TLSDATA 13]
[RDT_RELOCDATA 14]
[RDT_RSRCDATA 15]
[RDT_ERROR 16] ; This is DATA, but we set this Flag to identify some error cases messages
[RDT_STABSTR 17] ; .stabstr ; NetFramework stab string section. This section contains only strings.

Proc IdentifyRawDataType:
    Uses eax, esi, ecx

    mov eax D$esi+36 ; eax points to the Characteristics member

    ; Reinitialize the Raw Data to make sure it always will be set to 0 when the below
    ; checkings fails.

    mov D$RawDataType 0

    ; Check if it is .text or .code or any other section that is related to code only
    .Test_If eax &IMAGE_SCN_CNT_CODE
            jmp L0>
    .Test_Else_If eax &IMAGE_SCN_MEM_EXECUTE
    L0:
            Test_If eax &IMAGE_SCN_CNT_UNINITIALIZED_DATA
                mov D$RawDataType RDT_VIRTUALDATA
            Test_Else
                mov D$RawDataType RDT_CODE
            Test_End

    .Test_Else

        ; All the rest is Data. Let's analyze what kind of data it is.
        ; Find Virtual Data
        ; Guga Note: Look at CTLFWR32.LIB we will need a Virtual data. Like we did for the raw data.

        Test_If eax &IMAGE_SCN_CNT_UNINITIALIZED_DATA
            mov D$RawDataType RDT_VIRTUALDATA
            ExitP
        Test_End

        ; Check for long section names (KSGUID.LIB)
        If B$esi = '/'
            ; Similar to what we found at WriteIndirectSectionName
            call GetName1Offset ; convert the Offset to hexadecimal
            call GetStringTablePointer
            mov esi D$CoffSectionBase
            add esi D$CoffSymbolsPointer
            mov ecx D$PointerToStringTable
            add ecx D$MemberName1Offset | mov esi ecx
        End_If

        ; Find Virtual Data
        ; convert all section names to small caps and compare them.
        ; save the address of esi to be restored later
        push D$esi, D$esi+4
        or D$esi 020202020
        or D$esi+4 020202020

        .If D$esi = 'bss' ; BSS or bss
            jmp L0>
        .Else_If D$esi = '.bss'

        L0:
            mov D$RawDataType RDT_VIRTUALDATA

        ; Find Debug Data. It will use the proper Debug structures to display in the raw data.
        .Else_If D$esi = '.deb'

            If D$esi+4 = 'ug$s' ; .debug$s , .debug$S or Big caps
                mov D$RawDataType RDT_DEBUGS
            Else_If D$esi+4 = 'ug$f' ; .debug$f , .debug$F or Big caps
                mov D$RawDataType RDT_DEBUGF
            Else_If D$esi+4 = 'ug$t' ; .debug$t , .debug$T or Big caps
                mov D$RawDataType RDT_DEBUGT
            Else_If D$esi+4 = 'ug$p' ; .debug$p , .debug$P or Big caps
                mov D$RawDataType RDT_DEBUGP
            Else
                mov D$RawDataType RDT_ERROR
            End_If

        ; Find NetFramework Stab Structure. It will use the proper Debug structures to display in the raw data.
        .Else_If_And D$esi = '.sta', D$esi+4 = 'bstr'
            mov D$RawDataType RDT_STABSTR

        ; Check for Linker Directive data. esi points to the Characteristics member.

        .Else_If_And D$esi = '.dre', D$esi+4 = 'ctve' ; .drectve

            Test_If eax &IMAGE_SCN_LNK_INFO
                ; PointerToRelocations and PointerToLinenumbers must be 0, because
                ; the section must not have relocations or line numbers.
                If_And D$esi+24 = 0, D$esi+28 = 0
                    mov D$RawDataType RDT_LNKDIRECTIVE
                Else
                    mov D$RawDataType RDT_ERROR
                End_If

            Test_Else
                mov D$RawDataType RDT_ERROR
            Test_End

        ; Find Common Data. (.data; .idata; .rdata; .xdata; .pdata; .edata)

        .Else_If_And D$esi = '.dat', B$esi+4 = 'a'
            mov D$RawDataType RDT_DATA

        .Else_If D$esi+2 = 'data'

            If W$esi = '.i' ; Import Data Tables. Need to use proper structures or Data arrays.
                            ; Using IMAGE_IMPORT_DESCRIPTOR structure. Take a look at ACLCLS.LIB to we identify the proper structures and Data Bytes
                mov D$RawDataType RDT_IDATA
            Else_If W$esi = '.r' ; Read Only Data. In general, it is a series of Dwords, but it can be anything, like a serie of structures etc.
                mov D$RawDataType RDT_RDATA
            Else_If W$esi = '.x' ; Exception information Data Tables. Need to use proper structures EXCEPTION_RECORD. _msExcept _msExcInfo
                mov D$RawDataType RDT_XDATA
            Else_If W$esi = '.p' ; Exception information Data Tables. Need to use proper structures (EXCEPTION_RECORD ?)
                mov D$RawDataType RDT_PDATA
            Else_If W$esi = '.e' ; Export Data Tables. Need to use proper structures or Data arrays (IMAGE_EXPORT_DIRECTORY ?)
                mov D$RawDataType RDT_EDATA
            Else
                mov D$RawDataType RDT_ERROR
            End_If

        .Else_If D$esi = '.tls' ; Thread-local storage Data. Some section uses the IMAGE_TLS_DIRECTORY32 to point to
                                ; some data inside this .tls section. See MSVCRT.LIB, MSVCRTD.LIB, LIBCMT.LIB, LIBCMTD.LIB
            mov D$RawDataType RDT_TLSDATA

        .Else_If_And D$esi = '.rel', W$esi+4 = 'oc' ; Image relocations. We must use the (IMAGE_RELOCATION ?) for this
            mov D$RawDataType RDT_RELOCDATA

        .Else_If_And D$esi = '.rsr', B$esi+4 = 'c' ; Resource Section. We must use the IMAGE_RESOURCE_DIRECTORY structure.
            mov D$RawDataType RDT_RSRCDATA

        .Else
            ; When everything else fails or we have some unknown section names, we always set to DATA
            mov D$RawDataType RDT_DATA
        .End_If

        pop D$esi+4, D$esi

    .Test_End

EndP

___________________________________________________

GetCoffSectionHeader:

    push esi
        zCopy CoffSectionHeaderTitle
    pop esi

    ; The name of the section is indirected addressed on the String Table ?
    ; Yes, do next line. No, jmp over. Example: KSGUID.LIB

    If B$esi = '/'
        call WriteIndirectSectionName
    End_If

    push esi
        mov B$edi '[' | inc edi
        call WriteObjIndice
        zCopy {'ImgSecHdr', 0}
        zCopy SectionHeaderNumber
        mov B$edi ':', W$edi+1 CRLF | add edi 3
    pop esi

;    call IdentifyRawDataType

    call WriteObjSectionHeaderItem CoffSectionHeaderName, {': B$ ', 0}

    If B$esi-8 = '/'
        call WriteLinkerMemberSizeHex D$MemberName1Offset
    End_If

    call WriteObjSectionHeaderItem CoffSectionHeaderVirtualSize, {': D$ ', 0}
    call WriteObjSectionHeaderItem CoffSectionHeaderRVA, {': D$ ', 0}
    call WriteObjSectionHeaderItem CoffSectionHeaderSize, {': D$ ', 0}
    call WriteObjSectionHeaderItem CoffSectionHeaderPointerToData, {': D$ ', 0}
    call WriteObjSectionHeaderItem CoffSectionHeaderPointerToReloc, {': D$ ', 0}
    call WriteObjSectionHeaderItem CoffSectionHeaderPointerToLinesNumbers, {': D$ ', 0}
    call WriteObjSectionHeaderItem CoffSectionHeaderNumberOfRelocations, {': W$ ', 0}
    call WriteObjSectionHeaderItem CoffSectionHeaderNumberOfLinesNumbers, {': W$ ', 0}
    call WriteObjSectionHeaderItem CoffSectionHeaderCharacteristics, {': D$ ', 0}
    push esi
        sub edi 2 | mov eax D$esi-4 | call WriteCharacteristicsEquates
        mov W$edi CRLF, B$edi+2 ']', D$edi+3 CRLF2 | add edi 7
    pop esi
ret
____________________________________________________________________________________________

WriteSectionHeaderVirtualSizeDiffLabel:
    push esi

        call WriteObjIndice
        zCopy {"VirtualDataEnd", 0}
        zCopy SectionHeaderNumber

        mov D$edi ' - ' | add edi 3

        call WriteObjIndice
        zCopy {"VirtualData", 0}
        zCopy SectionHeaderNumber
    pop esi
ret


WriteSectionHeaderRawSizeDiffLabel:

    If D$esi+4 = 0 ; Is PointerToRawData = 0 ? If so, it means we are dealing with Virtual data. Do next line
        push esi | lodsd | call WriteEax | pop esi | ret
    End_If

    push esi

        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".RawDataEnd", 0}

        mov D$edi ' - ' | add edi 3

        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".RawData", 0}

    pop esi
ret

[IMAGE_FILE_HEADER_Comment1: 'IMAGE_FILE_HEADER_', 0]

WriteSectionHeaderPointerToDataDiffLabel:
    push esi

        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".RawData", 0}

        mov D$edi ' - ' | add edi 3

        zCopy IMAGE_FILE_HEADER_Comment1
        call WriteIndiceOnly

    pop esi
ret


Proc FixRelocDiffLabel:
    uses eax, ebx, ecx, esi, edi

    ; reinitialize the sectino counter
    call InitSectionHeaderNumber

    movzx ecx W$ObjNumberOfSections
    mov ebx D$FirstSectionPointer
    mov edi D$esi ; edi hold the value of our PointerToRelocations to be compared

L0:

    ; Points to PointerToRelocations starting at the 1st section
   .If edi = D$ebx+018 ; is our relocs equal to the relocs on section where we are ?
        If W$ebx+020 <> 0 ; Is NumberOfRelocations = 0 ? Yes, we are analysing our own section
            ExitP
        End_If
   .End_If

   call IncrementSectionHeaderNumber
   add ebx 028 ; go to the next section
   Loop L0<


EndP


WriteSectionHeaderPointerToRelocDiffLabel:

    push D$SectionHeaderNumber

    If W$esi+4+4 = 0 ; Points to NumberOfRelocations. aclcls.lib
        ; Check how many relocs we have. If we have 0, it means that the pointer is being referenced by another section.
         call FixRelocDiffLabel
    End_If

    push esi

        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".ImgReloc", 0}
        zCopy RelocNumber

        mov D$edi ' - ' | add edi 3

        zCopy IMAGE_FILE_HEADER_Comment1
        call WriteIndiceOnly

    pop esi

    pop D$SectionHeaderNumber

ret


WriteSectionHeaderPointerToLineNumberDiffLabel:
    push esi

        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".LineNumber", 0}
        zCopy CoffLineNumber

        mov D$edi ' - ' | add edi 3

        zCopy IMAGE_FILE_HEADER_Comment1
        call WriteIndiceOnly

    pop esi
ret


; It should display for example: ; Stringdata15 - StringTableSize

Proc WriteSectionHeaderPointerToStringTableDiffLabel:
    Uses esi, eax, edx

    ; Initialize the String Record Counter

    call InitStringTableRecord

    ; On this case, the Stringtable must be initialized with 0. Otherwise our counter will already start at 01
    ; So, we must reset the counter to '000000'.

    mov D$StringTableRecord+4 '00'

    lodsd ; eax is pointing to the Offset of the String on the String Table
    mov edx D$PointerToStringTable
    add edx 4 ; Bypass the String Table Size. and Point to the beginning of the 1st String
    mov esi edx ; esi is pointing to the 1st string
    add edx eax ; edx will be using as a counter of the total amount of strings untill we reach the String where we are.

    .Do

        While B$esi <> 0 | inc esi | End_While | inc esi | On B$esi = 0, mov edx 0

        call IncrementStringTableRecord

    .Loop_Until esi >= edx


        push esi
            call WriteObjIndice
            zCopy {'StringData', 0}
            zCopy StringTableRecord
        pop esi

        mov D$edi ' - ' | add edi 3

        call WriteObjIndice
        zCopy {'StringTableSize', 0}
        zCopy {' ; Hex Value:  ', 0}


EndP

____________________________________________________________________________________________


Proc WriteSectionHeaderSymbolConstantIndex:
    uses eax, ecx, ebx, esi

    call InitSymbolIndexRecord
    call WriteObjIndice

    ; Fix the label to show in Caps and replace the '." with an "_"
    ; The 1st char in "Obj000000." is in Caps, so we don't need to overwrite the "O" char

    push edi
    mov B$edi-1 '_', W$edi-9 'BJ'
    pop edi

    push esi
    zCopy {'SYMBOLINDEX', 0}
    pop esi

    mov ecx D$esi

    ; Note to René: Replacing this with a hex to decimal ascii string is better,
    ; but i couldn't make it be on the same style as SymbolTableIndex

    While ecx <> 0
        call IncrementSymbolIndexRecord
        dec ecx
    End_While

    zCopy SymbolTableIndex

    ; restore the SymbolTableIndex
    call InitSymbolIndexRecord

EndP
____________________________________________________________________________________________



[CoffRelocHeaderTitle: "; IMAGE_RELOCATION Structure, pointed at: ", 0]

[CoffRelocHeaderRelocRVA: 'VirtualAddress', 0
 CoffRelocHeaderRelocCount: 'RelocCount', 0
 CoffRelocHeaderSymbolTableIndex: 'SymbolTableIndex', 0
 CoffRelocHeaderType: 'Type1', 0]

Proc WriteObjRelocHeaderItem:
    Argument @Text1, @Text2

        push esi
            call WriteObjIndice

            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber

            zCopy {'.ImgReloc', 0}
            zCopy RelocNumber;SectionHeaderNumber
            mov B$edi '.' | inc edi
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text2, al B$eax+2

        ..If al = 'D'

            .If D$esi <> 0

                mov eax D@Text1

                If D$eax = 'Virt' ; from "VirtualAddress" string

                    lodsd | call WriteEax
                    push esi | zcopy {" ; Hex Value:  ", 0} | pop esi

                ;Else_If D$eax = 'Relo'; From "RelocCount" string

                    ;call WriteSectionHeaderPointerToDataDiffLabel
                    ;push esi | zcopy {" ; Hex Value:  ", 0} | pop esi

                Else_If D$eax = 'Symb'; From "SymbolTableIndex" string
                    call WriteSectionHeaderSymbolConstantIndex
                    add esi 4 ; we need to increment esi by 4 to we adjust at the end of the End_If macro
                    push esi | zcopy {" ; Hex Value:  ", 0} | pop esi

                End_If

            .Else
                add esi 4


            .End_If
            ; We need to subtract esi by 4 (01 Dword) to we get back to the path again. It was increased above.
            sub esi 4 | lodsd | call WriteEax

        ..Else_If al = 'W'
            lodsw | and eax 0FFFF | call WriteEax

        ;..Else

        ..End_If

        mov W$edi CRLF | add edi 2
EndP

_________________________________________________________

;;
a) When the  Machine member of IMAGE_FILE_HEADER is settlled to one of 
theses: IMAGE_FILE_MACHINE_I386, IMAGE_FILE_MACHINE_I486, 
IMAGE_FILE_MACHINE_I586,  IMAGE_FILE_MACHINE_IA64 (So, INtel compatible 
processors), the equates are:

&IMAGE_REL_I386_ABSOLUTE
&IMAGE_REL_I386_DIR16
&IMAGE_REL_I386_REL16
&IMAGE_REL_I386_DIR32
&IMAGE_REL_I386_DIR32NB
&IMAGE_REL_I386_SEG12
&IMAGE_REL_I386_SECTION
&IMAGE_REL_I386_SECREL
&IMAGE_REL_I386_REL32

b) When the  Machine member of IMAGE_FILE_HEADER is settlled to one of 
theses: IMAGE_FILE_MACHINE_MIPS16, IMAGE_FILE_MACHINE_MIPSFPU, 
IMAGE_FILE_MACHINE_MIPSFPU16 , IMAGE_FILE_MACHINE_R10000, 
IMAGE_FILE_MACHINE_R3000,
IMAGE_FILE_MACHINE_R4000, IMAGE_FILE_MACHINE_WCEMIPSV2
(So, MIPS compatible processors), the equates are:

&IMAGE_REL_MIPS_ABSOLUTE
&IMAGE_REL_MIPS_REFHALF
&IMAGE_REL_MIPS_REFWORD
&IMAGE_REL_MIPS_JMPADDR
&IMAGE_REL_MIPS_REFHI
&IMAGE_REL_MIPS_REFLO
&IMAGE_REL_MIPS_GPREL
&IMAGE_REL_MIPS_LITERAL
&IMAGE_REL_MIPS_SECTION
&IMAGE_REL_MIPS_SECREL
&IMAGE_REL_MIPS_SECRELLO
&IMAGE_REL_MIPS_SECRELHI
&IMAGE_REL_MIPS_JMPADDR16
&IMAGE_REL_MIPS_REFWORDNB
&IMAGE_REL_MIPS_PAIR

c) When the  Machine member of IMAGE_FILE_HEADER is settlled to one of 
theses: IMAGE_FILE_MACHINE_ALPHA, IMAGE_FILE_MACHINE_ALPHA64, 
IMAGE_FILE_MACHINE_AXP64 (So, Alpha compatible processors), the equates are:

&IMAGE_REL_ALPHA_ABSOLUTE
&IMAGE_REL_ALPHA_REFLONG
&IMAGE_REL_ALPHA_REFQUAD
&IMAGE_REL_ALPHA_GPREL32
&IMAGE_REL_ALPHA_LITERAL
&IMAGE_REL_ALPHA_LITUSE
&IMAGE_REL_ALPHA_GPDISP
&IMAGE_REL_ALPHA_BRADDR
&IMAGE_REL_ALPHA_HINT
&IMAGE_REL_ALPHA_INLINE_REFLONG
&IMAGE_REL_ALPHA_REFHI
&IMAGE_REL_ALPHA_REFLO
&IMAGE_REL_ALPHA_PAIR
&IMAGE_REL_ALPHA_MATCH
&IMAGE_REL_ALPHA_SECTION
&IMAGE_REL_ALPHA_SECREL
&IMAGE_REL_ALPHA_REFLONGNB
&IMAGE_REL_ALPHA_SECRELLO
&IMAGE_REL_ALPHA_SECRELHI
&IMAGE_REL_ALPHA_REFQ3
&IMAGE_REL_ALPHA_REFQ2
&IMAGE_REL_ALPHA_REFQ1
&IMAGE_REL_ALPHA_GPRELLO
&IMAGE_REL_ALPHA_GPRELHI

d) When the  Machine member of IMAGE_FILE_HEADER is settlled to one of 
theses: IMAGE_FILE_MACHINE_POWERPC, IMAGE_FILE_MACHINE_POWERPCFP, (So, IBM 
POwer PC compatible processors), the equates are:

&IMAGE_REL_PPC_ABSOLUTE
&IMAGE_REL_PPC_ADDR64
&IMAGE_REL_PPC_ADDR32
&IMAGE_REL_PPC_ADDR24
&IMAGE_REL_PPC_ADDR16
&IMAGE_REL_PPC_ADDR14
&IMAGE_REL_PPC_REL24
&IMAGE_REL_PPC_REL14
&IMAGE_REL_PPC_ADDR32NB
&IMAGE_REL_PPC_SECREL
&IMAGE_REL_PPC_SECTION
&IMAGE_REL_PPC_SECREL16
&IMAGE_REL_PPC_REFHI
&IMAGE_REL_PPC_REFLO
&IMAGE_REL_PPC_PAIR
&IMAGE_REL_PPC_SECRELLO
&IMAGE_REL_PPC_SECRELHI
&IMAGE_REL_PPC_GPREL

e) When the  Machine member of IMAGE_FILE_HEADER is settlled to one of 
theses: IMAGE_FILE_MACHINE_SH3, IMAGE_FILE_MACHINE_SH3DSP, 
IMAGE_FILE_MACHINE_SH3E, IMAGE_FILE_MACHINE_SH4, IMAGE_FILE_MACHINE_SH5,  
(So, Hitachi SuperH compatible processors), the equates are:

&IMAGE_REL_SH3_ABSOLUTE
&IMAGE_REL_SH3_DIRECT16
&IMAGE_REL_SH3_DIRECT32
&IMAGE_REL_SH3_DIRECT8
&IMAGE_REL_SH3_DIRECT8_WORD
&IMAGE_REL_SH3_DIRECT8_LONG
&IMAGE_REL_SH3_DIRECT4
&IMAGE_REL_SH3_DIRECT4_WORD
&IMAGE_REL_SH3_DIRECT4_LONG
&IMAGE_REL_SH3_PCREL8_WORD
&IMAGE_REL_SH3_PCREL8_LONG
&IMAGE_REL_SH3_PCREL12_WORD
&IMAGE_REL_SH3_STARTOF_SECTION
&IMAGE_REL_SH3_SIZEOF_SECTION
&IMAGE_REL_SH3_SECTION
&IMAGE_REL_SH3_SECREL
&IMAGE_REL_SH3_DIRECT32_NB

f) When the  Machine member of IMAGE_FILE_HEADER is settlled to one of 
theses: IMAGE_FILE_MACHINE_ARM,  (So, ARM compatible processors), the 
equates are:

&IMAGE_REL_ARM_ABSOLUTE
&IMAGE_REL_ARM_ADDR32
&IMAGE_REL_ARM_ADDR32NB
&IMAGE_REL_ARM_BRANCH24
&IMAGE_REL_ARM_BRANCH11
&IMAGE_REL_ARM_SECTION
&IMAGE_REL_ARM_SECREL
;;

WriteRelocHeaderTypeEquate:
    push esi

    movzx eax W$esi-2 | mov ebx D$CoffSectionBase | movzx ebx W$ebx

    mov D$edi ' ; ' | add edi 3

    ; Intel Compatible: IMAGE_FILE_MACHINE_I386, IMAGE_FILE_MACHINE_I486,
    ; IMAGE_FILE_MACHINE_I586,  IMAGE_FILE_MACHINE_IA64

    ..If ebx = &IMAGE_FILE_MACHINE_I386
L1:     .If eax = &IMAGE_REL_I386_ABSOLUTE
            zCopy {'&IMAGE_REL_I386_ABSOLUTE', 0}
        .Else_If eax = &IMAGE_REL_I386_DIR16
            zCopy {'&IMAGE_REL_I386_DIR16', 0}
        .Else_If eax = &IMAGE_REL_I386_REL16
            zCopy {'&IMAGE_REL_I386_REL16', 0}
        .Else_If eax = &IMAGE_REL_I386_DIR32
            zCopy {'&IMAGE_REL_I386_DIR32', 0}
        .Else_If eax = &IMAGE_REL_I386_DIR32NB
            zCopy {'&IMAGE_REL_I386_DIR32NB', 0}
        .Else_If eax = &IMAGE_REL_I386_SEG12
            zCopy {'&IMAGE_REL_I386_SEG12', 0}
        .Else_If eax = &IMAGE_REL_I386_SECTION
            zCopy {'&IMAGE_REL_I386_SECTION', 0}
        .Else_If eax = &IMAGE_REL_I386_SECREL
            zCopy {'&IMAGE_REL_I386_SECREL', 0}
        .Else_If eax = &IMAGE_REL_I386_REL32
            zCopy {'&IMAGE_REL_I386_REL32', 0}
        .End_If

    ..Else_If ebx = &IMAGE_FILE_MACHINE_I486
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_I586
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_IA64
        jmp L1<<


    ; Mips Compatible: IMAGE_FILE_MACHINE_MIPS16, IMAGE_FILE_MACHINE_MIPSFPU,
    ; IMAGE_FILE_MACHINE_MIPSFPU16 , IMAGE_FILE_MACHINE_R10000,
    ; IMAGE_FILE_MACHINE_R3000, IMAGE_FILE_MACHINE_R4000, IMAGE_FILE_MACHINE_WCEMIPSV2

    ..Else_If ebx = &IMAGE_FILE_MACHINE_MIPS16
L1:     .If eax = &IMAGE_REL_MIPS_ABSOLUTE
            zCopy {'&IMAGE_REL_I386_ABSOLUTE', 0}
        .Else_If eax = &IMAGE_REL_MIPS_REFHALF
            zCopy {'&IMAGE_REL_MIPS_REFHALF', 0}
        .Else_If eax = &IMAGE_REL_MIPS_REFWORD
            zCopy {'&IMAGE_REL_MIPS_REFWORD', 0}
        .Else_If eax = &IMAGE_REL_MIPS_JMPADDR
            zCopy {'&IMAGE_REL_MIPS_JMPADDR', 0}
        .Else_If eax = &IMAGE_REL_MIPS_REFHI
            zCopy {'IMAGE_REL_MIPS_REFHI', 0}
        .Else_If eax = &IMAGE_REL_MIPS_REFLO
            zCopy {'&IMAGE_REL_MIPS_REFLO', 0}
        .Else_If eax = &IMAGE_REL_MIPS_GPREL
            zCopy {'&IMAGE_REL_MIPS_GPREL', 0}
        .Else_If eax = &IMAGE_REL_MIPS_LITERAL
            zCopy {'&IMAGE_REL_MIPS_LITERAL', 0}
        .Else_If eax = &IMAGE_REL_MIPS_SECTION
            zCopy {'&IMAGE_REL_MIPS_SECTION', 0}
        .Else_If eax = &IMAGE_REL_MIPS_SECREL
            zCopy {'&IMAGE_REL_MIPS_SECREL', 0}
        .Else_If eax = &IMAGE_REL_MIPS_SECRELLO
            zCopy {'&IMAGE_REL_MIPS_SECRELLO', 0}
        .Else_If eax = &IMAGE_REL_MIPS_SECRELHI
            zCopy {'&IMAGE_REL_MIPS_SECRELHI', 0}
        .Else_If eax = &IMAGE_REL_MIPS_JMPADDR16
            zCopy {'&IMAGE_REL_MIPS_JMPADDR16', 0}
        .Else_If eax = &IMAGE_REL_MIPS_REFWORDNB
            zCopy {'&IMAGE_REL_MIPS_REFWORDNB', 0}
        .Else_If eax = &IMAGE_REL_MIPS_PAIR
            zCopy {'&IMAGE_REL_MIPS_PAIR', 0}
        .End_If


    ..Else_If ebx = &IMAGE_FILE_MACHINE_MIPSFPU
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_MIPSFPU16
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_R10000
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_R3000
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_R4000
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_WCEMIPSV2
        jmp L1<<


    ; Alpha Compatible: IMAGE_FILE_MACHINE_ALPHA, IMAGE_FILE_MACHINE_ALPHA64, IMAGE_FILE_MACHINE_AXP64

    ..Else_If ebx = &IMAGE_FILE_MACHINE_ALPHA
L1:     .If eax = &IMAGE_REL_ALPHA_ABSOLUTE
            zCopy {'&IMAGE_REL_ALPHA_ABSOLUTE', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_REFLONG
            zCopy {'&IMAGE_REL_ALPHA_REFLONG', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_REFQUAD
            zCopy {'&IMAGE_REL_ALPHA_REFQUAD', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_GPREL32
            zCopy {'&IMAGE_REL_ALPHA_GPREL32', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_LITERAL
            zCopy {'&IMAGE_REL_ALPHA_LITERAL', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_LITUSE
            zCopy {'&IMAGE_REL_ALPHA_LITUSE', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_GPDISP
            zCopy {'&IMAGE_REL_ALPHA_GPDISP', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_BRADDR
            zCopy {'&IMAGE_REL_ALPHA_BRADDR', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_HINT
            zCopy {'&IMAGE_REL_ALPHA_HINT', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_INLINE_REFLONG
            zCopy {'&IMAGE_REL_ALPHA_INLINE_REFLONG', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_REFHI
            zCopy {'&IMAGE_REL_ALPHA_REFHI', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_REFLO
            zCopy {'&IMAGE_REL_ALPHA_REFLO', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_PAIR
            zCopy {'&IMAGE_REL_ALPHA_PAIR', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_MATCH
            zCopy {'&IMAGE_REL_ALPHA_MATCH', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_SECTION
            zCopy {'&IMAGE_REL_ALPHA_SECTION', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_SECREL
            zCopy {'&IMAGE_REL_ALPHA_SECREL', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_REFLONGNB
            zCopy {'&IMAGE_REL_ALPHA_REFLONGNB', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_SECRELLO
            zCopy {'&IMAGE_REL_ALPHA_SECRELLO', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_SECRELHI
            zCopy {'&IMAGE_REL_ALPHA_SECRELHI', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_REFQ3
            zCopy {'&IMAGE_REL_ALPHA_REFQ3', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_REFQ2
            zCopy {'&IMAGE_REL_ALPHA_REFQ2', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_REFQ1
            zCopy {'&IMAGE_REL_ALPHA_REFQ1', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_GPRELLO
            zCopy {'&IMAGE_REL_ALPHA_GPRELLO', 0}
        .Else_If eax = &IMAGE_REL_ALPHA_GPRELHI
            zCopy {'&IMAGE_REL_ALPHA_GPRELHI', 0}
        .End_If

    ..Else_If ebx = &IMAGE_FILE_MACHINE_ALPHA64
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_AXP64
        jmp L1<<

    ; IBM Power PC compatible: IMAGE_FILE_MACHINE_POWERPC, IMAGE_FILE_MACHINE_POWERPCFP

    ..Else_If ebx = &IMAGE_FILE_MACHINE_POWERPC
L1:     .If eax = &IMAGE_REL_PPC_ABSOLUTE
            zCopy {'&IMAGE_REL_PPC_ABSOLUTE', 0}
        .Else_If eax = &IMAGE_REL_PPC_ADDR64
            zCopy {'&IMAGE_REL_PPC_ADDR64', 0}
        .Else_If eax = &IMAGE_REL_PPC_ADDR32
            zCopy {'&IMAGE_REL_PPC_ADDR32', 0}
        .Else_If eax = &IMAGE_REL_PPC_ADDR24
            zCopy {'&IMAGE_REL_PPC_ADDR24', 0}
        .Else_If eax = &IMAGE_REL_PPC_ADDR16
            zCopy {'&IMAGE_REL_PPC_ADDR16', 0}
        .Else_If eax = &IMAGE_REL_PPC_ADDR14
            zCopy {'&IMAGE_REL_PPC_ADDR14', 0}
        .Else_If eax = &IMAGE_REL_PPC_REL24
            zCopy {'&IMAGE_REL_PPC_REL24', 0}
        .Else_If eax = &IMAGE_REL_PPC_REL14
            zCopy {'&IMAGE_REL_PPC_REL14', 0}
        .Else_If eax = &IMAGE_REL_PPC_ADDR32NB
            zCopy {'&IMAGE_REL_PPC_ADDR32NB', 0}
        .Else_If eax = &IMAGE_REL_PPC_SECREL
            zCopy {'&IMAGE_REL_PPC_SECREL', 0}
        .Else_If eax = &IMAGE_REL_PPC_SECTION
            zCopy {'&IMAGE_REL_PPC_SECTION', 0}
        .Else_If eax = &IMAGE_REL_PPC_SECREL16
            zCopy {'&IMAGE_REL_PPC_SECREL16', 0}
        .Else_If eax = &IMAGE_REL_PPC_REFHI
            zCopy {'&IMAGE_REL_PPC_REFHI', 0}
        .Else_If eax = &IMAGE_REL_PPC_REFLO
            zCopy {'&IMAGE_REL_PPC_REFLO', 0}
        .Else_If eax = &IMAGE_REL_PPC_PAIR
            zCopy {'&IMAGE_REL_PPC_PAIR', 0}
        .Else_If eax = &IMAGE_REL_PPC_SECRELLO
            zCopy {'&IMAGE_REL_PPC_SECRELLO', 0}
        .Else_If eax = &IMAGE_REL_PPC_SECRELHI
            zCopy {'&IMAGE_REL_PPC_SECRELHI', 0}
        .Else_If eax = &IMAGE_REL_PPC_GPREL
            zCopy {'&IMAGE_REL_PPC_GPREL', 0}
        .End_If

    ..Else_If ebx = &IMAGE_FILE_MACHINE_POWERPCFP
        jmp L1<<

    ; Hitachi SuperH compatible: IMAGE_FILE_MACHINE_SH3, IMAGE_FILE_MACHINE_SH3DSP, IMAGE_FILE_MACHINE_SH3E, IMAGE_FILE_MACHINE_SH4, IMAGE_FILE_MACHINE_SH5

    ..Else_If ebx = &IMAGE_FILE_MACHINE_SH3
L1:     .If eax = &IMAGE_REL_SH3_ABSOLUTE
            zCopy {'&IMAGE_REL_SH3_ABSOLUTE', 0}
        .Else_If eax = &IMAGE_REL_SH3_DIRECT16
            zCopy {'&IMAGE_REL_SH3_DIRECT16', 0}
        .Else_If eax = &IMAGE_REL_SH3_DIRECT32
            zCopy {'&IMAGE_REL_SH3_DIRECT32', 0}
        .Else_If eax = &IMAGE_REL_SH3_DIRECT8
            zCopy {'&IMAGE_REL_SH3_DIRECT8', 0}
        .Else_If eax = &IMAGE_REL_SH3_DIRECT8_WORD
            zCopy {'&IMAGE_REL_SH3_DIRECT8_WORD', 0}
        .Else_If eax = &IMAGE_REL_SH3_DIRECT8_LONG
            zCopy {'&IMAGE_REL_SH3_DIRECT8_LONG', 0}
        .Else_If eax = &IMAGE_REL_SH3_DIRECT4
            zCopy {'&IMAGE_REL_SH3_DIRECT4', 0}
        .Else_If eax = &IMAGE_REL_SH3_DIRECT4_WORD
            zCopy {'&IMAGE_REL_SH3_DIRECT4_WORD', 0}
        .Else_If eax = &IMAGE_REL_SH3_DIRECT4_LONG
            zCopy {'&IMAGE_REL_SH3_DIRECT4_LONG', 0}
        .Else_If eax = &IMAGE_REL_SH3_PCREL8_WORD
            zCopy {'&IMAGE_REL_SH3_PCREL8_WORD', 0}
        .Else_If eax = &IMAGE_REL_SH3_PCREL8_LONG
            zCopy {'&IMAGE_REL_SH3_PCREL8_LONG', 0}
        .Else_If eax = &IMAGE_REL_SH3_PCREL12_WORD
            zCopy {'&IMAGE_REL_SH3_PCREL12_WORD', 0}
        .Else_If eax = &IMAGE_REL_SH3_STARTOF_SECTION
            zCopy {'&IMAGE_REL_SH3_STARTOF_SECTION', 0}
        .Else_If eax = &IMAGE_REL_SH3_SIZEOF_SECTION
            zCopy {'&IMAGE_REL_SH3_SIZEOF_SECTION', 0}
        .Else_If eax = &IMAGE_REL_SH3_SECTION
            zCopy {'&IMAGE_REL_SH3_SECTION', 0}
        .Else_If eax = &IMAGE_REL_SH3_SECREL
            zCopy {'&IMAGE_REL_SH3_SECREL', 0}
        .Else_If eax = &IMAGE_REL_SH3_DIRECT32_NB
            zCopy {'&IMAGE_REL_SH3_DIRECT32_NB', 0}
        .End_If

    ..Else_If ebx = &IMAGE_FILE_MACHINE_SH3DSP
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_SH3E
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_SH4
        jmp L1<<

    ..Else_If ebx = &IMAGE_FILE_MACHINE_SH5
        jmp L1<<

    ; ARM compatible: IMAGE_FILE_MACHINE_ARM

    ..Else_If ebx = &IMAGE_FILE_MACHINE_ARM
        .If eax = &IMAGE_REL_ARM_ABSOLUTE
            zCopy {'&IMAGE_REL_ARM_ABSOLUTE', 0}
        .Else_If eax = &IMAGE_REL_ARM_ADDR32
            zCopy {'&IMAGE_REL_ARM_ADDR32', 0}
        .Else_If eax = &IMAGE_REL_ARM_ADDR32NB
            zCopy {'&IMAGE_REL_ARM_ADDR32NB', 0}
        .Else_If eax = &IMAGE_REL_ARM_BRANCH24
            zCopy {'&IMAGE_REL_ARM_BRANCH24', 0}
        .Else_If eax = &IMAGE_REL_ARM_BRANCH11
            zCopy {'&IMAGE_REL_ARM_BRANCH11', 0}
        .Else_If eax = &IMAGE_REL_ARM_SECTION
            zCopy {'&IMAGE_REL_ARM_SECTION', 0}
        .Else_If eax = &IMAGE_REL_ARM_SECREL
            zCopy {'&IMAGE_REL_ARM_SECREL', 0}
        .End_If

    ..End_If

    pop esi


ret

; GugaNote
; Problem of multiple section with different relocs with DX9SDKSampleFramework.lib
; Most often, they may contains relocs offset, but size is 0 (ForceLibrary.lib)

Proc GetCoffRelocHeader:
    uses ecx, ebx

    push esi
        zCopy CoffRelocHeaderTitle
        call WriteObjIndice
        zCopy {"ImgSecHdr", 0}
        zCopy SectionHeaderNumber
        zCopy {".PointerToRelocations", 0}
        zCopy {" Member", CRLF2, "[", 0}

        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".ImgReloc", 0}
        zCopy RelocNumber
        mov B$edi ':', W$edi+1 CRLF | add edi 3
    pop esi

    call WriteObjRelocHeaderItem CoffRelocHeaderRelocRVA, {': D$ ', 0}
    call WriteObjRelocHeaderItem CoffRelocHeaderSymbolTableIndex, {': D$ ', 0}
    call WriteObjRelocHeaderItem CoffRelocHeaderType, {': W$ ', 0}
    sub edi 2 | call WriteRelocHeaderTypeEquate
    mov W$edi CRLF | add edi 2

    push esi
        mov B$edi ']', D$edi+1 CRLF2 | add edi 5
    pop esi
EndP
____________________________________________________________

[RelocNumber: '000001', 0]


InitSectionRelocNumber:
    mov D$RelocNumber '0000', D$RelocNumber+4 '01'
ret


IncrementSectionRelocNumber:
    lea ebx D$RelocNumber+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret




____________________________________________________________

Proc WriteObjLineHeaderItem:
    Argument @Text1, @Text2
    Uses edx

        push esi
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".LineNumber", 0}
        zCopy CoffLineNumber

        zCopy D@Text1
        zCopy D@Text2
        pop esi


                mov eax D@Text1

                .If D$eax = 'Symb' ; from "SymbolTableIndex" string
                    call WriteSectionHeaderSymbolConstantIndex
                    push esi | zcopy {" ; Hex Value:  ", 0} | pop esi
                    lodsd | call WriteEax

                .Else_If D$eax = 'Virt'; From "VirtualAddress" string
                    lodsd | call WriteEax

                .Else_If D$eax = 'Line'; From "Linenumber" string
                    xor eax eax
                    lodsw | call WriteEax

                .End_If


        mov W$edi CRLF | add edi 2
EndP

;;
[IMAGE_LINENUMBER:
 SymbolTableIndex: VirtualAddress: D$ 0
 Linenumber: W$ 0]
;;

[CoffLineNumberTitle: "
__________________________________________________

; IMAGE_LINENUMBER Structure, pointed at: ", 0]

[CoffLineHeaderSymbolTableIndex: 'SymbolTableIndex', 0
 CoffLineHeaderVirtualAddress: 'VirtualAddress', 0
 CoffLineHeaderLinenumber: 'Linenumber', 0]

Proc GetCoffLineHeader:
    uses ecx, ebx


    push esi
        zCopy CoffLineNumberTitle
        call WriteObjIndice
        zCopy {"ImgSecHdr", 0}
        zCopy SectionHeaderNumber
        zCopy {".PointerToLinenumbers Member", 0}
    pop esi

    mov D$edi CRLF2 | add edi 4

    If W$esi+4 <> 0
        push esi
        zCopy {"; This Structure contains the correspondent line number on the original source specified at LineNumber member.", 0}
        zCopy {W$ CRLF, B$ "; Also it is related only to Code and contains the Virtual Address of some referenced data that can", 0}
        zCopy {W$ CRLF, B$ "; be a Local Variable, Argument, or a Data Pointer", D$ CRLF2, 0}
        pop esi
    End_If


    push esi
        mov B$edi "[" | inc edi
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".LineNumber", 0}
        zCopy CoffLineNumber
        mov B$edi ':', W$edi+1 CRLF | add edi 3
    pop esi

    ; problem in ATLDLOAD.LIB

    If W$esi+4 = 0

        call WriteObjLineHeaderItem CoffLineHeaderSymbolTableIndex, {': D$ ', 0}
    Else

        call WriteObjLineHeaderItem CoffLineHeaderVirtualAddress, {': D$ ', 0}

    End_If

    call WriteObjLineHeaderItem CoffLineHeaderLinenumber, {': W$ ', 0}

;    sub edi 2 | call WriteRelocHeaderTypeEquate
 ;   mov W$edi CRLF | add edi 2

    push esi
        mov B$edi ']', D$edi+1 CRLF2 | add edi 5
    pop esi
EndP



[CoffLineNumber: '000001', 0]


InitSectionLineNumber:
    mov D$CoffLineNumber '0000', D$CoffLineNumber+4 '01'
ret


IncrementSectionLineNumber:
    lea ebx D$CoffLineNumber+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret


____________________________________________________________

[CoffSectionSize: ?  CoffPointerToData: ?  CoffPointerToReloc: ?  NumberOfRelocations: ?
CoffPointerToLineNumber: ?  NumberOfLineNumbers: ?]

GetCoffSectionsVariables:

    add esi 8   ;  CoffSectionHeaderName, {': B$ ', 0}

    add esi 4   ; CoffSectionHeaderVirtualSize, {': D$ ', 0}

    add esi 4   ; CoffSectionHeaderRVA, {': D$ ', 0} / VirtualAddress

    move D$CoffSectionSize D$esi
    add esi 4   ; CoffSectionHeaderSize, {': D$ ', 0} / SizeOfRawData

    move D$CoffPointerToData D$esi
    add esi 4   ;  CoffSectionHeaderPointerToData, {': D$ ', 0} / PointerToRawData

    move D$CoffPointerToReloc D$esi
    add esi 4   ; CoffSectionHeaderPointerToReloc, {': D$ ', 0} / PointerToRelocations

    move D$CoffPointerToLineNumber D$esi
    add esi 4   ; CoffSectionHeaderPointerToLinesNumbers, {': D$ ', 0} / PointerToLinenumbers

    move W$NumberOfRelocations W$esi
    add esi 2   ; CoffSectionHeaderNumberOfRelocations, {': W$ ', 0}

    move W$NumberOfLineNumbers W$esi
    add esi 2   ; CoffSectionHeaderNumberOfLinesNumbers, {': W$ ', 0}


  ; CoffSectionHeaderNumberOfRelocations, {': W$ ', 0}

  ; CoffSectionHeaderNumberOfLinesNumbers, {': W$ ', 0}
  ; CoffSectionHeaderCharacteristics, {': D$ ', 0}
ret


[CoffSymbolsPointer: ?  CoffSymbolsNumber: ?
 PointerToSymbolsStringTable: ?  SizeOfSymbolsStringsTable: ?
 EndOfSymbolsStringsTable: ?]

GetImageSymbolsVariables:
    push esi
        mov esi D$CoffSectionBase
        mov eax D$esi+8
        If eax <> 0
            add eax esi | mov D$CoffSymbolsPointer eax
        Else
            mov D$CoffSymbolsPointer 0
        End_If

        move D$CoffSymbolsNumber D$esi+12

        If D$CoffSymbolsPointer <> 0
          ; Search the Pointer to the Symbols Strings Table (18 is the Size of one Symbol Record):
            mov ecx D$CoffSymbolsNumber, eax 18
            mul ecx
            add eax D$CoffSymbolsPointer
            mov D$PointerToSymbolsStringTable eax
            move D$SizeOfSymbolsStringsTable D$eax
            add eax D$eax | mov D$EndOfSymbolsStringsTable eax
        End_If
    pop esi
ret
____________________________________________________________________________________________

Proc WriteAuxSymFmt1DiffLabel:
    Uses esi, ebx, ecx, eax, edx, D$SectionHeaderNumber, D$CoffLineNumber


    push esi

    mov ebx D$FirstSectionPointer

    movzx ecx W$esi-14 ; ecx is pointing to the previous section value
    ; we need to recompute the sectionheader number

    call InitSectionHeaderNumber
    call InitSectionLineNumber

    mov edx edi ; for keeping the path to edi, let's save it at edx

    ; Guga note this is the errros on DX9SDKSampleFramework.lib We have an 0 previous section

    On ecx = 0 , ExitP

    If ecx <> 1 ; Are we pointing to thye 1st section ?
        push ecx

            Do
                call IncrementSectionHeaderNumber
                dec ecx
            Loop_Until ecx = 1

        pop ecx

    End_If

    sub esi 18+8 ; esi is pointing to the beginning of previous Symbol

    push edx

    If ecx <> 1     ; If we are pointing to the 1st Section, we don´ need to add it to the offset of the IMAGE_SECTION_HEADER
        mov eax 40  ; eax is the Size of the IMAGE_SECTON_HEADER
        imul ecx    ; multiply by the section where we must go
        add ebx eax
        sub ebx 40  ; need to subtract from the Size of IMAGE_SECTION_HEADER to get back to the proper path.
    End_If

    pop edx


    pop esi ; restore our value at esi

    ; we must point to the proper Section (IMAGE_SECTION_HEADER)
    add ebx 28 ; we are pointing to PointerToLinenumbers
    mov eax D$ebx ; eax points to the value of linenumber in the ImgSec where we are

    mov edi D$esi ; edi is pointing to the LineNumber value to be compare

    .If eax <> edi ; is the pointer where we are is equal to the value found in the linenumber ?
                   ; Yes, jmp over.


        movzx ecx W$ebx+6 ; ecx is our counter it points to the number of line numbers
        ; No. the values are different. We are dealing with several linenumbers in the same section.
        ; Let's check for their values.

        L0:

            On eax = edi, jmp @OutLoop
            add eax 6 ; we need to add the value in edi (IMAGE_SECTION_HEADER where we are) 6 that is the size of the line number structure
            call IncrementSectionLineNumber
        Loop L0<

@OutLoop:


    .End_If


        mov edi edx ; retore the path to edi

        push esi

        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".LineNumber", 0}
        zCopy CoffLineNumber

        mov D$edi ' - ' | add edi 3

        zCopy IMAGE_FILE_HEADER_Comment1
        call WriteIndiceOnly
        zcopy {" ; Hex Value:  ", 0}
        pop esi

EndP



Proc WriteAuxiliarySymbolsRecordsFormat1Item:
    Argument @Text1, @Text2
    Uses edx,  D$SymbolTableIndex , D$SymbolTableIndex+4

        push esi
            call WriteObjIndice
            zCopy {'ImgAuxFmt1.Ind', 0}
            zCopy SymbolTableRecord
            mov B$edi '.' | inc edi
            zCopy D@Text1
            zCopy D@Text2
        pop esi


        mov eax D@Text1

        .If D$eax = 'TagI' ; from "TagIndex" string
            ;call WriteAuxSymFmt5DiffLabel
            call WriteSectionHeaderSymbolConstantIndex
            push esi | zcopy {" ; Hex Value:  ", 0} | pop esi
            lodsd | call WriteEax

        .Else_If D$eax = 'Tota'; From "TotalSize" string
            lodsd | call WriteEax

        .Else_If D$eax+9 = 'Line'; From "PointerToLinenumber" string
            If D$esi <> 0
                call WriteAuxSymFmt1DiffLabel
             End_If
            lodsd | call WriteEax

        .Else_If D$eax+9 = 'Next'; From "PointerToNextFunction" string

            If D$esi <> 0
                call WriteSectionHeaderSymbolConstantIndex
                push esi | zcopy {" ; Hex Value:  ", 0} | pop esi
            End_If

            lodsd | call WriteEax

        .Else_If D$eax = 'Rese'; From "Reserved" string
            xor eax eax
            lodsw | call WriteEax

        .End_If


        mov W$edi CRLF | add edi 2


EndP


;[ImgAuxSym: 'ImgAuxSym', 0] ; Guga Note: Remove this data variable. It is not used anymore


[Fmt1TagIndex: 'TagIndex', 0
 Fmt1TotalSize: 'TotalSize', 0
 Fmt1PointerToLinenumber: 'PointerToLinenumber', 0
 Fmt1PointerToNextFunction: 'PointerToNextFunction', 0
 Fmt1Reserved: 'Reserved', 0]

Proc WriteAuxiliarySymbolsRecordsFormat1:

        push esi
            call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt1.Ind', 0}
            zCopy SymbolTableRecord
            mov B$edi ':', W$edi+1 CRLF | add edi 3
        pop esi

        call WriteAuxiliarySymbolsRecordsFormat1Item Fmt1TagIndex, {': D$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat1Item Fmt1TotalSize, {': D$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat1Item Fmt1PointerToLinenumber, {': D$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat1Item Fmt1PointerToNextFunction, {': D$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat1Item Fmt1Reserved, {': W$ ', 0}
        sub edi 2

EndP

_________________________________________________________

Proc WriteAuxiliarySymbolsRecordsFormat2Item:
    Argument @Text1, @Text2
    Uses edx, ecx, D$SymbolTableIndex, D$SymbolTableIndex+4

        push esi
            call WriteObjIndice
            zCopy {'ImgAuxFmt2.Ind', 0}
            zCopy SymbolTableRecord
            mov B$edi '.' | inc edi
            zCopy D@Text1
            zCopy D@Text2
        pop esi


        mov eax D@Text1


        .If D$eax+5 = 'ved1' ; from "Reserved1" string
            lodsd | call WriteEax

        .Else_If D$eax = 'Line'; From "LineNumber" string
            xor eax eax
            lodsw | call WriteEax
            push esi | zcopy {" ; Base Line Number", 0} | pop esi

        .Else_If D$eax+5 = 'ved2'; From "Reserved2" string
            xor eax eax
            mov ecx 6
            L0:
                lodsb | call WriteEax
                mov W$edi ", " | add edi 2
            Loop L0<
            sub edi 2

        .Else_If D$eax = 'Poin'; From "PointerToNextFunction" string

            If D$esi <> 0
                call WriteSectionHeaderSymbolConstantIndex
                push esi | zcopy {" ; Hex Value:  ", 0} | pop esi
            End_If

            lodsd | call WriteEax

        .Else_If D$eax+5 = 'ved3'; From "Reserved3" string
            xor eax eax
            lodsw | call WriteEax

        .End_If

        mov W$edi CRLF | add edi 2

EndP



[Fmt2Reserved1: 'Reserved1', 0
 Fmt2LineNumber: 'LineNumber', 0
 Fmt2Reserved2: 'Reserved2', 0
 Fmt2PointerToNextFunction: 'PointerToNextFunction', 0
 Fmt2Reserved3: 'Reserved3', 0]

Proc WriteAuxiliarySymbolsRecordsFormat2:

        push esi
            call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt2.Ind', 0}
            zCopy SymbolTableRecord
            mov B$edi ':', W$edi+1 CRLF | add edi 3
        pop esi

        call WriteAuxiliarySymbolsRecordsFormat2Item Fmt2Reserved1, {': D$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat2Item Fmt2LineNumber, {': W$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat2Item Fmt2Reserved2, {': B$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat2Item Fmt2PointerToNextFunction, {': D$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat2Item Fmt2Reserved3, {': W$ ', 0}
        sub edi 2

EndP

_________________________________________________________

Proc WriteAuxSymFmt3CharacteristicEquates:
    Uses esi;, ebx

    ;mov ebx esi

    .If D$esi = &IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY
        zCopy {'&IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY ; Hex Value:  ', 0}
    .Else_If D$esi = &IMAGE_WEAK_EXTERN_SEARCH_LIBRARY
        zCopy {'&IMAGE_WEAK_EXTERN_SEARCH_LIBRARY ; Hex Value:  ', 0}
    .Else_If D$esi = &IMAGE_WEAK_EXTERN_SEARCH_ALIAS
        zCopy {'&IMAGE_WEAK_EXTERN_SEARCH_ALIAS ; Hex Value:  ', 0}
    .End_if


EndP

Proc WriteAuxiliarySymbolsRecordsFormat3Item:
    Argument @Text1, @Text2
    Uses edx, ecx, D$SymbolTableIndex, D$SymbolTableIndex+4

        push esi
            call WriteObjIndice
            zCopy {'ImgAuxFmt3.Ind', 0}
            zCopy SymbolTableRecord
            mov B$edi '.' | inc edi
            zCopy D@Text1
            zCopy D@Text2
        pop esi


        mov eax D@Text1


        .If D$eax = 'TagI' ; from "TagIndex" string
            If D$esi <> 0
               call WriteSectionHeaderSymbolConstantIndex
               push esi | zcopy {" ; Hex Value:  ", 0} | pop esi
            End_If

            lodsd | call WriteEax

        .Else_If D$eax = 'Char'; From "Characteristics" string
            ;lodsd | call WriteEax
            call WriteAuxSymFmt3CharacteristicEquates
            lodsd | call WriteEax

        .Else_If D$eax = 'Rese'; From "Reserved" string
            xor eax eax
            mov ecx 10
            L0:
                lodsb | call WriteEax
                mov W$edi ", " | add edi 2
            Loop L0<
            sub edi 2

        .End_If

        mov W$edi CRLF | add edi 2

EndP



[Fmt3TagIndex: 'TagIndex', 0
 Fmt3Characteristics: 'Characteristics', 0
 Fmt3Reserved: 'Reserved', 0]

Proc WriteAuxiliarySymbolsRecordsFormat3:

        push esi
            call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt3.Ind', 0}
            zCopy SymbolTableRecord
            mov B$edi ':', W$edi+1 CRLF | add edi 3
        pop esi

        call WriteAuxiliarySymbolsRecordsFormat3Item Fmt3TagIndex, {': D$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat3Item Fmt3Characteristics, {': D$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat3Item Fmt3Reserved, {': B$ ', 0}
        sub edi 2

EndP


_________________________________________________________


Proc WriteAuxiliarySymbolsRecordsFormat4:

        push esi
            call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt4.Ind', 0}
            zCopy SymbolTableRecord
            mov B$edi ':', W$edi+1 CRLF | add edi 3
            call WriteObjIndice
            zCopy {'ImgAuxFmt4.Ind', 0}
            zCopy SymbolTableRecord
            zCopy {'.FileName: B$ ', 0}
        pop esi

        mov edx esi | add edx 18

        .If B$esi = 0
            mov B$edi '0' | inc edi | inc esi
        .Else

        mov B$edi "'" | inc edi
L0:     lodsb
            If al = 0
                dec esi | jmp L1>
            End_If
        stosb | On esi < edx, jmp L0<
L1:     mov B$edi "'" | inc edi

        .End_If

        While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ;mov W$edi CRLF | add edi 2


EndP


__________________________________________________________



Proc WriteAuxSymFmt5DiffLabel:
    Uses esi, ebx, ecx, eax, edx

    mov ebx D$FirstSectionPointer

    movzx ecx W$esi-18+12 ; ecx is pointing to the previous section value
    ; we need to recompute the sectionheader number

    call InitSectionHeaderNumber

    mov edx edi ; for keeping the path to edi, let's save it at edx

    ; Guga note this is the errros on DX9SDKSampleFramework.lib We have an 0 previous section

    On ecx = 0 , jmp C2>>

    If ecx <> 1 ; Are we pointing to thye 1st section ?
        push ecx

            Do
                call IncrementSectionHeaderNumber
                dec ecx
            Loop_Until ecx = 1

        pop ecx

    End_If

    sub esi 18 ; esi is pointing to the beginning of previous Symbol

    push edx

    If ecx <> 1     ; If we are pointing to the 1st Section, we don´ need to add it to the offset of the IMAGE_SECTION_HEADER
        mov eax 40  ; eax is the Size of the IMAGE_SECTON_HEADER
        imul ecx    ; multiply by the section where we must go
        add ebx eax
        sub ebx 40  ; need to subtract from the Size of IMAG_SECTION_HEADER to get back to the proper path.
    End_If

    pop edx

    ; we must point to the proper Section (IMAGE_SECTION_HEADER)

    mov eax ebx ; The 1st String where we are (The Section in IMAGE_SECTION_HEADER)
    mov edi esi ; edi is pointing to the beginning of the previous section. (Our string to be compared)

    mov ecx 8   ;how many bytes in the string...char= one byte
    repe cmpsb
    jne C2>

        mov edi edx ; retore the path to edi

        add eax 20 ; eax is pointing to PointerToRawData on IMAGE_SECTION_HEADER from the structure we label
        mov esi D$eax ; now we point it to esi

        .If D$eax <> 0 ; Is PointerToRawData = 0 ? Is it Virtual data ? No, do next line.

            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".RawDataEnd", 0}

            mov D$edi ' - ' | add edi 3

            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".RawData ; Hex Value:  ", 0}

        .End_If

        ExitP

    C2:

    mov edi edx ; retore the path to edi

EndP


Proc WriteAuxSymFmt5TypeEquates:
    Uses esi, ebx

    mov ebx esi


    .If B$ebx = &IMAGE_COMDAT_SELECT_NODUPLICATES
        zCopy {'&IMAGE_COMDAT_SELECT_NODUPLICATES ; Hex Value:  ', 0}
    .Else_If B$ebx = &IMAGE_COMDAT_SELECT_ANY
        zCopy {'&IMAGE_COMDAT_SELECT_ANY ; Hex Value:  ', 0}
    .Else_If B$ebx = &IMAGE_COMDAT_SELECT_SAME_SIZE
        zCopy {'&IMAGE_COMDAT_SELECT_SAME_SIZE ; Hex Value:  ', 0}
    .Else_If B$ebx = &IMAGE_COMDAT_SELECT_EXACT_MATCH
        zCopy {'&IMAGE_COMDAT_SELECT_EXACT_MATCH ; Hex Value:  ', 0}
    .Else_If B$ebx = &IMAGE_COMDAT_SELECT_ASSOCIATIVE
        zCopy {'&IMAGE_COMDAT_SELECT_ASSOCIATIVE ; Hex Value:  ', 0}
    .Else_If B$ebx = &IMAGE_COMDAT_SELECT_LARGEST
        zCopy {'&IMAGE_COMDAT_SELECT_LARGEST ; Hex Value:  ', 0}
    .End_if


EndP


[Fmt5Length: 'Length', 0
 Fmt5NumberOfRelocations: 'NumberOfRelocations', 0
 Fmt5NumberOfLinenumbers: 'NumberOfLinenumbers', 0
 Fmt5CheckSum: 'CheckSum', 0
 Fmt5Number: 'Number', 0
 Fmt5Selection: 'Selection', 0
 Fmt5Reserved: 'Reserved', 0]

Proc WriteAuxiliarySymbolsRecordsFormat5Item:
    Argument @Text1, @Text2
    Uses edx, ecx;, D$SymbolTableIndex, D$SymbolTableIndex+4

        push esi
            call WriteObjIndice
            zCopy {'ImgAuxFmt5.Ind', 0}
            zCopy SymbolTableRecord
            mov B$edi '.' | inc edi
            zCopy D@Text1
            zCopy D@Text2
        pop esi


                mov eax D@Text1

                .If D$eax = 'Leng' ; from "Length" string
                    call WriteAuxSymFmt5DiffLabel
                    lodsd | call WriteEax

                .Else_If D$eax+8 = 'Relo'; From "NumberOfRelocations" string
                    xor eax eax
                    lodsw | call WriteEax

                .Else_If D$eax+8 = 'Line'; From "NumberOfLinenumbers" string
                    xor eax eax
                    lodsw | call WriteEax

                .Else_If D$eax = 'Chec'; From "CheckSum" string
                    lodsd | call WriteEax

                .Else_If D$eax = 'Numb'; From "Number" string

                    xor eax eax
                    lodsw | call WriteEax

                .Else_If D$eax = 'Sele'; From "Selection" string
                    call WriteAuxSymFmt5TypeEquates
                    xor eax eax
                    lodsb | call WriteEax

                .Else_If D$eax = 'Rese'; From "Reserved" string
                    xor eax eax
                    mov ecx 3
                    L0:
                        xor eax eax
                        lodsb | call WriteEax
                        mov W$edi ", " | add edi 2
                    Loop L0<
                    sub edi 2

                .End_If


        mov W$edi CRLF | add edi 2


EndP


Proc WriteAuxiliarySymbolsRecordsFormat5:

        push esi
            call WriteObjIndice
            zCopy {B$ 'ImgAuxFmt5.Ind', 0}
            zCopy SymbolTableRecord
            mov B$edi ':', W$edi+1 CRLF | add edi 3
        pop esi

        call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5Length, {': D$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5NumberOfRelocations, {': W$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5NumberOfLinenumbers, {': W$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5CheckSum, {': D$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5Number, {': W$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5Selection, {': B$ ', 0}
        call WriteAuxiliarySymbolsRecordsFormat5Item Fmt5Reserved, {': B$ ', 0}
        sub edi 2

EndP


_______________________________________________________________


; Examples: frmMainNET.obj, program_PadraoCOM.obj, Hello World_PAdraoNET.obj
; GIven to me (Guga) by Fabricio

Proc WriteAuxiliarySymbolsRecordsFormatUnknown:
    ;Argument @Pointer

    push esi
        call WriteObjIndice
        zCopy {'ImgAuxSym', 0}
        zCopy SymbolTableRecord
        zCopy {'FormatUnknwon: B$ ', 0}
    pop esi

;        mov esi D@Pointer, ecx 18
        mov ecx 18

L0:     lodsb | and eax 0FF | call WriteEax
        mov W$edi ', ' | add edi 2 | loop L0<
        sub edi 2
        ;mov B$edi-2 "'" | dec edi
EndP

_______________________________________________________________

Proc WriteAuxiliarySymbolsRecords:
    Arguments @Number
    Uses ecx, ebx

    .Do

        call WriteSymbolConstantIndex
        call IncrementSymbolIndexRecord

        mov W$edi CRLF | add edi 2
        mov B$edi '[' | inc edi

        call IncrementSymbolTableRecord

            ..If D$SymbolStorageClass = &IMAGE_SYM_CLASS_EXTERNAL
            ; example at libgccguga.a

                .If B$esi-4 = (&IMAGE_SYM_DTYPE_FUNCTION shl 4) + &IMAGE_SYM_TYPE_NULL ; Type1Complex = 020
                    ;If W$esi-6 >= 0  ;
                    ; SectionNumber >= 0. Once again the documentation lied. We can have a 0 section number
                        call WriteAuxiliarySymbolsRecordsFormat1
                    ;End_If
                .End_If

            ..Else_If D$SymbolStorageClass = &IMAGE_SYM_CLASS_FUNCTION
            ; example at shit.obj
                call WriteAuxiliarySymbolsRecordsFormat2

            ..Else_If D$SymbolStorageClass = &IMAGE_SYM_CLASS_WEAK_EXTERNAL
            ; example at stats.lib ; Libdc.lib
                .If W$esi-6 = &IMAGE_SYM_UNDEFINED  ; SectionNumber = &IMAGE_SYM_UNDEFINED
                    If D$esi-10 = 0 ; Value member = 0
                        call WriteAuxiliarySymbolsRecordsFormat3
                    End_If
                .End_If

            ..Else_If D$SymbolStorageClass = &IMAGE_SYM_CLASS_FILE
                call WriteAuxiliarySymbolsRecordsFormat4

            ..Else_If D$SymbolStorageClass = &IMAGE_SYM_CLASS_STATIC
                call WriteAuxiliarySymbolsRecordsFormat5

            ..Else
                call WriteAuxiliarySymbolsRecordsFormatUnknown

            ..End_If

        mov B$edi ']', D$edi+1 CRLF2 | add edi 5
        dec D$CoffSymbolsNumber ; decrement our counter from the total amount symbols
        dec D@Number ; decrement the total amount of Auxiliary Symbols

    .Loop_Until D@Number = 0

EndP

____________________________________________________________________________________________


[SymbolTableTitle: "
_________________________________________________________

; Symbols Table Structure IMAGE_SYMBOL
_________________________________________________________


", 0
SymbolTableShortName: 'NameShort', 0
SymbolTableLongNameZero: 'NameZero', 0
SymbolTableLongNameOffset: 'NameLongOffset', 0
SymbolTableValue: 'Value', 0
SymbolTableSectionNumber: 'SectionNumber', 0
SymbolTableTypeComplex: 'Type1Complex', 0
SymbolTableTypeBase: 'Type1Base', 0
SymbolTableStorageClass: 'StorageClass', 0
SymbolTableNumberOfAuxSymbols: 'NumberOfAuxSymbols', 0]


;[PointerToSymbolsRecords: ?]

[SymbolTableRecord: '000001', 0]


InitSymbolTableRecord:
    mov D$SymbolTableRecord '0000', D$SymbolTableRecord+4 '01'
ret


IncrementSymbolTableRecord:
    lea ebx D$SymbolTableRecord+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret


Proc WriteImageSymbolTableFieldName:
    Argument @String1 @String2
    Uses esi, ecx, ebx

   ; If D@String2 < SymbolTableShortName1
   ;      mov eax D@String1, ebx D@String2
   ;      int3
   ; End_If

        call WriteObjIndice
        zCopy D@String1
        zCopy SymbolTableRecord
        zCopy D@String2
EndP


;;
&IMAGE_SYM_UNDEFINED 0 Symbol record is not yet assigned a section.
    If the value is 0 this indicates a references to an external symbol 
    defined elsewhere. If the value is non-zero this is a common symbol 
    with a size specified by the value. 
&IMAGE_SYM_ABSOLUTE -1 The symbol has an absolute (non-relocatable) value 
    and is not an address. 
&IMAGE_SYM_DEBUG -2 The symbol provides general type or debugging information 
    but does not correspond to a section. Microsoft tools use this setting 
    along with .file records (storage class FILE). 
;;

WriteRelocSectionNumberEquate:
    push esi
        ;mov ebx D$PointerToSymbolsRecords

        If W$esi = &IMAGE_SYM_UNDEFINED
            zCopy {'&IMAGE_SYM_UNDEFINED ; Hex Value:  ', 0}
        Else_If W$esi = &IMAGE_SYM_ABSOLUTE
            zCopy {'&IMAGE_SYM_ABSOLUTE ; Hex Value:  ', 0}
        Else_If W$esi = &IMAGE_SYM_DEBUG
            zCopy {'&IMAGE_SYM_DEBUG ; Hex Value:  ', 0}
        End_If
    pop esi
ret

;;
WriteRelocSectionNumberEquate_Old:
    push esi
        mov ebx D$PointerToSymbolsRecords

        If W$ebx = &IMAGE_SYM_UNDEFINED
            zCopy {' ; &IMAGE_SYM_UNDEFINED', 0}
        Else_If W$ebx = &IMAGE_SYM_ABSOLUTE
            zCopy {' ; &IMAGE_SYM_ABSOLUTE', 0}
        Else_If W$ebx = &IMAGE_SYM_DEBUG
            zCopy {' ; &IMAGE_SYM_DEBUG', 0}
        End_If
    pop esi
ret
;;

;;
The most significative byte equates are:

&IMAGE_SYM_DTYPE_NULL
&IMAGE_SYM_DTYPE_POINTER
&IMAGE_SYM_DTYPE_FUNCTION
&IMAGE_SYM_DTYPE_ARRAY


The less signfiicative byte are:

&IMAGE_SYM_TYPE_NULL
&IMAGE_SYM_TYPE_VOID
&IMAGE_SYM_TYPE_CHAR
&IMAGE_SYM_TYPE_SHORT
&IMAGE_SYM_TYPE_INT
&IMAGE_SYM_TYPE_LONG
&IMAGE_SYM_TYPE_FLOAT
&IMAGE_SYM_TYPE_DOUBLE
&IMAGE_SYM_TYPE_STRUCT
&IMAGE_SYM_TYPE_UNION
&IMAGE_SYM_TYPE_ENUM
&IMAGE_SYM_TYPE_MOE
&IMAGE_SYM_TYPE_BYTE
&IMAGE_SYM_TYPE_WORD
&IMAGE_SYM_TYPE_UINT
&IMAGE_SYM_TYPE_DWORD
;;

[RelocTypeD: ?  RelocType: ?]

;;
        .If_And eax >= 32, eax <= 65535 ; Check for Corrupted library. Reserved Bits are not 0

            call LibScan_ErrManager IMP_OBJ_RESBIT_ERR

            If eax = &FALSE ; The user pressed No
                ExitP

            Else_If eax = &TRUE ; The user pressed Yes. We will Zero all reserved bits for him continue the parsing.
                mov eax D@Flags ; Restore the original value of eax to be fixed
                mov ah 0 ; Clear High Bits Flags
                btr eax 5 | btr eax 6 | btr eax 7 ; Clear Bits 5 to 7

            End_If

        .End_If


;;
;WriteRelocTypeEquates:
Proc WriteSymbolTypeEquates:
    Uses esi, ebx

        .If B$esi > 63 ; Check for Corrupted library. The actual maximum value is 63 (03F)

            call LibScan_ErrManager IMP_OBJ_RESBIT_ERR

            If eax = &FALSE ; The user pressed No
                ExitP

            Else_If eax = &TRUE ; The user pressed Yes. We will Zero all reserved bits for him continue the parsing.

                ; Clear all high flags, returning only in the targeting Byte
                xor eax eax | lodsb | btr eax 6 | btr eax 7 ; Clear Bits 6 and , that are what exceed the limit of 63
                mov ebx eax
            End_If

        .Else

            xor eax eax | lodsb | mov ebx eax

        .End_If

        and eax 0F | shr ebx 4

        ;mov D$RelocType eax, D$RelocTypeD ebx

        If ebx = &IMAGE_SYM_DTYPE_NULL
            zCopy {'(&IMAGE_SYM_DTYPE_NULL shl 4)', 0}
        Else_If ebx = &IMAGE_SYM_DTYPE_POINTER
            zCopy {'(&IMAGE_SYM_DTYPE_POINTER shl 4)', 0}
        Else_If ebx = &IMAGE_SYM_DTYPE_FUNCTION
            zCopy {'(&IMAGE_SYM_DTYPE_FUNCTION shl 4)', 0}
        Else_If ebx = &IMAGE_SYM_DTYPE_ARRAY
            zCopy {'(&IMAGE_SYM_DTYPE_ARRAY shl 4)', 0}
        End_If

        .If eax = &IMAGE_SYM_TYPE_NULL
            zCopy {' + &IMAGE_SYM_TYPE_NULL', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_VOID
            zCopy {' + &IMAGE_SYM_TYPE_VOID', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_CHAR
            zCopy {' + &IMAGE_SYM_TYPE_CHAR', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_SHORT
            zCopy {' + &IMAGE_SYM_TYPE_SHORT', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_INT
            zCopy {' + &IMAGE_SYM_TYPE_INT', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_LONG
            zCopy {' + &IMAGE_SYM_TYPE_LONG', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_FLOAT
            zCopy {' + &IMAGE_SYM_TYPE_FLOAT', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_DOUBLE
            zCopy {' + &IMAGE_SYM_TYPE_DOUBLE', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_STRUCT
            zCopy {' + &IMAGE_SYM_TYPE_STRUCT', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_UNION
            zCopy {' + &IMAGE_SYM_TYPE_UNION', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_ENUM
            zCopy {' + &IMAGE_SYM_TYPE_ENUM', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_MOE
            zCopy {' + &IMAGE_SYM_TYPE_MOE', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_BYTE
            zCopy {' + &IMAGE_SYM_TYPE_BYTE', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_WORD
            zCopy {' + &IMAGE_SYM_TYPE_WORD', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_UINT
            zCopy {' + &IMAGE_SYM_TYPE_UINT', 0}
        .Else_If eax = &IMAGE_SYM_TYPE_DWORD
            zCopy {' + &IMAGE_SYM_TYPE_DWORD', 0}
        .End_If

        zCopy {' ; Hex Value:  ', 0}

EndP


;;
&IMAGE_SYM_CLASS_END_OF_FUNCTION -1 Special symbol representing end of function, for debugging purposes. 
&IMAGE_SYM_CLASS_NULL 0 No storage class assigned. 
&IMAGE_SYM_CLASS_AUTOMATIC 1 Automatic (stack) variable. The Value field specifies stack frame offset. 
&IMAGE_SYM_CLASS_EXTERNAL 2 Used by Microsoft tools for external symbols. The Value field indicates the size if the section number is IMAGE_SYM_UNDEFINED (0). If the section number is not 0, then the Value field specifies the offset within the section. 
&IMAGE_SYM_CLASS_STATIC 3 The Value field specifies the offset of the symbol within the section. If the Value is 0, then the symbol represents a section name. 
&IMAGE_SYM_CLASS_REGISTER 4 Register variable. The Value field specifies register number. 
&IMAGE_SYM_CLASS_EXTERNAL_DEF 5 Symbol is defined externally. 
&IMAGE_SYM_CLASS_LABEL 6 Code label defined within the module. The Value field specifies the offset of the symbol within the section. 
&IMAGE_SYM_CLASS_UNDEFINED_LABEL 7 Reference to a code label not defined. 
&IMAGE_SYM_CLASS_MEMBER_OF_STRUCT 8 Structure member. The Value field specifies nth member. 
&IMAGE_SYM_CLASS_ARGUMENT 9 Formal argument (parameter)of a function. The Value field specifies nth argument. 
&IMAGE_SYM_CLASS_STRUCT_TAG 10 Structure tag-name entry. 
&IMAGE_SYM_CLASS_MEMBER_OF_UNION 11 Union member. The Value field specifies nth member. 
&IMAGE_SYM_CLASS_UNION_TAG 12 Union tag-name entry. 
&IMAGE_SYM_CLASS_TYPE_DEFINITION 13 Typedef entry. 
&IMAGE_SYM_CLASS_UNDEFINED_STATIC 14 Static data declaration. 
&IMAGE_SYM_CLASS_ENUM_TAG 15 Enumerated type tagname entry. 
&IMAGE_SYM_CLASS_MEMBER_OF_ENUM 16 Member of enumeration. Value specifies nth member. 
&IMAGE_SYM_CLASS_REGISTER_PARAM 17 Register parameter. 
&IMAGE_SYM_CLASS_BIT_FIELD 18 Bit-field reference. Value specifies nth bit in the bit field. 
&IMAGE_SYM_CLASS_BLOCK 100 A .bb (beginning of block) or .eb (end of block) record. Value is the relocatable address of the code location. 
&IMAGE_SYM_CLASS_FUNCTION 101 Used by Microsoft tools for symbol records that define the extent of a function: begin function (named .bf), end function (.ef), and lines in function (.lf). For .lf records, Value gives the number of source lines in the function. For .ef records, Value gives the size of function code. 
&IMAGE_SYM_CLASS_END_OF_STRUCT 102 End of structure entry. 
&IMAGE_SYM_CLASS_FILE 103 Used by Microsoft tools, as well as traditional COFF format, for the source-file symbol record. The symbol is followed by auxiliary records that name the file. 
&IMAGE_SYM_CLASS_SECTION 104 Definition of a section (Microsoft tools use STATIC storage class instead). 
&IMAGE_SYM_CLASS_WEAK_EXTERNAL 105 Weak external. See Section 5.5.3, “Auxiliary Format 3: Weak Externals,” for more information. 
;;



[SymbolStorageClass: D$ 0]

WriteRelocStorageClassEquate:
    push esi

        movzx eax B$esi | mov D$SymbolStorageClass eax

        .If eax = &IMAGE_SYM_CLASS_ARGUMENT
            zCopy {'&IMAGE_SYM_CLASS_ARGUMENT ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_AUTOMATIC
            zCopy {'&IMAGE_SYM_CLASS_AUTOMATIC ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_BIT_FIELD
            zCopy {'&IMAGE_SYM_CLASS_BIT_FIELD ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_BLOCK
            zCopy {'&IMAGE_SYM_CLASS_BLOCK ; Hex Value:  ', 0}
         .Else_If eax = &IMAGE_SYM_CLASS_END_OF_FUNCTION
            zCopy {'&IMAGE_SYM_CLASS_END_OF_FUNCTION ; Hex Value:  ', 0}
         .Else_If eax = &IMAGE_SYM_CLASS_END_OF_STRUCT
            zCopy {'&IMAGE_SYM_CLASS_END_OF_STRUCT ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_ENUM_TAG
            zCopy {'&IMAGE_SYM_CLASS_ENUM_TAG ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_EXTERNAL
            zCopy {'&IMAGE_SYM_CLASS_EXTERNAL ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_EXTERNAL_DEF
            zCopy {'&IMAGE_SYM_CLASS_EXTERNAL_DEF ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_FAR_EXTERNAL
            zCopy {'&IMAGE_SYM_CLASS_FAR_EXTERNAL ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_FILE
            zCopy {'&IMAGE_SYM_CLASS_FILE ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_FUNCTION
            zCopy {'&IMAGE_SYM_CLASS_FUNCTION ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_LABEL
            zCopy {'&IMAGE_SYM_CLASS_LABEL ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_MEMBER_OF_ENUM
            zCopy {'&IMAGE_SYM_CLASS_MEMBER_OF_ENUM ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_MEMBER_OF_STRUCT
            zCopy {'&IMAGE_SYM_CLASS_MEMBER_OF_STRUCT ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_MEMBER_OF_UNION
            zCopy {'&IMAGE_SYM_CLASS_MEMBER_OF_UNION ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_NULL
            zCopy {'&IMAGE_SYM_CLASS_NULL ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_REGISTER
            zCopy {'&IMAGE_SYM_CLASS_REGISTER ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_REGISTER_PARAM
            zCopy {'&IMAGE_SYM_CLASS_REGISTER_PARAM ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_SECTION
            zCopy {'&IMAGE_SYM_CLASS_SECTION ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_STATIC
            zCopy {'&IMAGE_SYM_CLASS_STATIC ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_STRUCT_TAG
            zCopy {'&IMAGE_SYM_CLASS_STRUCT_TAG ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_TYPE_DEFINITION
            zCopy {'&IMAGE_SYM_CLASS_TYPE_DEFINITION ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_UNDEFINED_LABEL
            zCopy {'&IMAGE_SYM_CLASS_UNDEFINED_LABEL ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_UNDEFINED_STATIC
            zCopy {'&IMAGE_SYM_CLASS_UNDEFINED_STATIC ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_UNION_TAG
            zCopy {'&IMAGE_SYM_CLASS_UNION_TAG ; Hex Value:  ', 0}
        .Else_If eax = &IMAGE_SYM_CLASS_WEAK_EXTERNAL
            zCopy {'&IMAGE_SYM_CLASS_WEAK_EXTERNAL ; Hex Value:  ', 0}
        .End_If

    pop esi
ret



Proc WriteSymbolTableHeaderItem:
    Argument @Text1, @Text2
    Uses edx;, eax

        push esi
            call WriteObjIndice
            zCopy {'ImgSym', 0}
            zCopy SymbolTableRecord
            mov B$edi '.' | inc edi
            zCopy D@Text1
            zCopy D@Text2
        pop esi


                mov eax D@Text1

                ..If D$eax+4 = 'Shor' ; from "NameShort" string

                    mov edx esi | add edx 8
                    mov B$edi "'" | inc edi
L0:                 lodsb
                    If al = 0
                        dec esi | jmp L1>
                    End_If
                    stosb | On esi < edx, jmp L0<
L1:                 mov B$edi "'" | inc edi
                    While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

                ..Else_If D$eax+4 = 'Zero'; From "NameZero" string
                    lodsd | call WriteEax

                ..Else_If D$eax+8 = 'Offs'; From "NameLongOffset" string

                    call WriteSectionHeaderPointerToStringTableDiffLabel
                    lodsd | call WriteEax

                ..Else_If D$eax = 'Valu'; From "Value" string

                    ;call WriteCharacteristicsEquates
                    lodsd | call WriteEax

                        .If D$esi-4 <> 0 ; If the Value member is not Zero, do next line
                            If B$esi+4 = &IMAGE_SYM_CLASS_SECTION ; If StorageClass member is IMAGE_SYM_CLASS_SECTION, do next line
                                push esi
                                push D$esi-4
                                push eax
                                mov eax D$esi-4
                                call WriteCharacteristicsEquates
                                pop eax
                                pop D$esi-4
                                pop esi

                            End_If
                        .End_If

                ..Else_If D$eax = 'Sect'; From "SectionNumber" string
                    call WriteRelocSectionNumberEquate
                    xor eax eax
                    lodsw | call WriteEax

                ..Else_If D$eax = 'Type'; From "Type1Complex" string
                    call WriteSymbolTypeEquates
                    xor eax eax
                    lodsb | call WriteEax

                ..Else_If D$eax = '1Bas'; From "Type1Base" string
                    call WriteSymbolTypeEquates
                    xor eax eax
                    lodsb | call WriteEax

                ..Else_If D$eax = 'Stor'; From "StorageClass" string

                    call WriteRelocStorageClassEquate
                    xor eax eax
                    lodsb | call WriteEax

                ..Else_If D$eax+8 = 'AuxS'; From "NumberOfAuxSymbols" string
                    xor eax eax
                    lodsb | call WriteEax

;;
                ..Else_If D$eax = 'Misc'; From "MiscVirtualSize" string

                    call WriteSectionHeaderVirtualSizeDiffLabel
                    push esi | zcopy {" ; Hex Value:  ", 0} | pop esi
;;

                ;..Else

                    ;lodsd | call WriteEax

                ..End_If


        mov W$edi CRLF | add edi 2
EndP

____________________________________________________________

[SymbolTableIndex: '000000', 0]


InitSymbolIndexRecord:
    mov D$SymbolTableIndex '0000', D$SymbolTableIndex+4 '00'
ret


IncrementSymbolIndexRecord:
    lea ebx D$SymbolTableIndex+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret

Proc WriteSymbolConstantIndex:
    Uses esi, ecx

            mov B$edi '[' | inc edi
            call WriteObjIndice

            ; Fix the label to show in Caps and replace the '." with an "_"
            ; The 1st char in "Obj000000." is in Caps, so we don't need to overwrite the "O" char

            push edi
                mov B$edi-1 '_', W$edi-9 'BJ'
            pop edi

            zCopy {'SYMBOLINDEX', 0}
            zCopy SymbolTableIndex
            mov B$edi ' ' | inc edi

            mov esi SymbolTableIndex

            .If_And D$esi = '0000', D$SymbolTableIndex+4 = '00'

                mov B$edi '0' | inc edi
            .Else

                mov ecx 6 ; Size of the SymbolTable String
            L0:

                While B$esi <> '0'

                    L1:
                        movsb
                    Loop L1<
                    On ecx = 0, jmp @Out

                End_While

                inc esi
            Loop L0<

            .End_If
@Out:
            zCopy {B$ "] ; Symbol Index Constant used in IMAGE_RELOCATION Structure.", W$ CRLF, 0}


EndP

____________________________________________________________


; What do we need here ?
; CoffSymbolsPointer = Pointer to the Coff symbols Table
; CoffSymbolsNumber = Amount of Symbols Table structures

; The values where from GetCoffIMAGE_FILE_HEADER

[AuxSymbolCount: D$ 0]

[StringtableCheckFlag: D$ &FALSE]

[SymbolTableNameLongMessage: B$ "________________________________________________________________________

; Name Label indirectly addressed at NameLongOffset.
; The name of the Symbol is: ", 0]


WriteImageSymbolTable:

    ; Initialise the String Table Checking.

    mov D$StringtableCheckFlag &FALSE

    call InitSymbolTableRecord
    call InitSymbolIndexRecord

    zCopy SymbolTableTitle
    mov esi D$CoffSectionBase
    add esi D$CoffSymbolsPointer

.Do

    If B$esi = 0

        push esi
            zCopy SymbolTableNameLongMessage
        pop esi

            mov ecx D$PointerToStringTable

        push esi
            add ecx D$esi+4 | mov esi ecx
            While B$esi <> 0 | movsb | End_While
            zCopy {W$ CRLF, B$ "________________________________________________________________________", D$ CRLF2 0}
        pop esi

    End_If

        call WriteSymbolConstantIndex
        call IncrementSymbolIndexRecord ; Increment it for the next Normal Symbol or Auxiliary Symbol
        mov W$edi CRLF | add edi 2

    .If_And W$esi+12 = &IMAGE_SYM_UNDEFINED, B$esi+16 = &IMAGE_SYM_CLASS_EXTERNAL
        push esi
        zCopy {B$ "; This symbol is defined externally. It can be a Dll function or a runtime function", D$ CRLF2 0}
        pop esi

    .Else_If B$esi+16 = &IMAGE_SYM_CLASS_SECTION

        If W$esi+12 = &IMAGE_SYM_UNDEFINED
            push esi
            zCopy {B$ "; This symbol represents the Section Name. It's not used because it is not defined in any Section." , W$ CRLF, B$ "; However, the value member is the Characteristics of a Section if existant." , D$ CRLF2 0}
            pop esi
        Else
            push esi
            zCopy {B$ "; This symbol represents the Section Name. The value member is the Characteristics of the Section," , W$ CRLF, B$ "; but it may not be the same as what is found on the Section Structure.", D$ CRLF2 0}
            pop esi
        End_If
    .End_If

        push esi
            mov B$edi '[' | inc edi
            call WriteObjIndice
            zCopy {'ImgSym', 0}
            zCopy SymbolTableRecord
            mov B$edi ':', W$edi+1 CRLF | add edi 3
        pop esi

    .If B$esi = 0

        If D$esi+4 <> 0 ; need this flag to check if we have String Table pointer or not.
            mov D$StringtableCheckFlag &TRUE
        End_If

        call WriteSymbolTableHeaderItem SymbolTableLongNameZero, {': D$ ', 0}
        call WriteSymbolTableHeaderItem SymbolTableLongNameOffset, {': D$ ', 0}

    .Else

        call WriteSymbolTableHeaderItem SymbolTableShortName, {': B$ ', 0}

    .End_If


    call WriteSymbolTableHeaderItem SymbolTableValue, {': D$ ', 0}
    call WriteSymbolTableHeaderItem SymbolTableSectionNumber, {': W$ ', 0}
    call WriteSymbolTableHeaderItem SymbolTableTypeComplex, {': B$ ', 0}
    call WriteSymbolTableHeaderItem SymbolTableTypeBase, {': B$ ', 0}
    call WriteSymbolTableHeaderItem SymbolTableStorageClass, {': B$ ', 0}
    call WriteSymbolTableHeaderItem SymbolTableNumberOfAuxSymbols, {': B$ ', 0}

    sub edi 2
    mov B$edi ']' | inc edi ; Close the bracket

    dec D$CoffSymbolsNumber ; decrement our counter

    If B$esi-1 <> 0 ; Is Auxiliary Value = 0 ? No, do next line.

        movzx eax B$esi-1 | mov D$AuxSymbolCount eax
        mov D$edi CRLF2 | add edi 4
        call WriteAuxiliarySymbolsRecords eax

    Else
        ; To prevent adding extra Paragraphs (8 Bytes) we need this else macro, because the end of the
        ; auxiliary record before, already is adding 4 bytes (CRLF2) on exit.
        mov D$edi CRLF2 | add edi 4

    End_If

        call IncrementSymbolTableRecord

    .Loop_Until D$CoffSymbolsNumber = 0

ret


[PointerToStringTable: D$ 0]

; This function is used to calculate the Pointer to the String table. All we are doing is compute
; the real size of the Symbols Structures (With the Auxiliary Symbols) and adding it to the Coff Base

GetStringTablePointer:
    pushad

    mov esi D$CoffSectionBase
    add esi D$CoffSymbolsPointer
    mov ecx D$CoffSymbolsNumber

    .Do
        add esi 18 ; The size of each IMAGE_SYMBOL Structure
        dec ecx

        If B$esi-1 <> 0 ; Is Auxiliary Value = 0 ? No, do next line.
            movzx eax B$esi-1; | mov D$AuxSymbolCount eax The amount of auxiliary symbols found on this Symbol structure
                ;call WriteAuxiliarySymbolsRecords eax

            Do
                add esi 18 ; Add to the size of each Auxiliary Symbol
                dec ecx ;decrement our counter from the total amount of Symbols
                dec eax ; decrement the total amount of Auxiliary Symbols
            Loop_Until eax = 0 ; Did we finished all Auxiliary symbols for this Symbol ?

        End_If

    .Loop_Until ecx = 0

    mov D$PointerToStringTable esi

    popad

ret



[StringTableRecord: '000001', 0]


InitStringTableRecord:
    mov D$StringTableRecord '0000', D$StringTableRecord+4 '01'
ret


IncrementStringTableRecord:
    lea ebx D$StringTableRecord+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret


[StringTableTitle: "
_________________________________________________________

; Strings Table
_________________________________________________________


", 0]


WriteImageSymbolStringsTable:

    ; Initialize the String Record Counter

    call InitStringTableRecord

    push esi
        zCopy StringTableTitle
        mov B$edi '[' | inc edi
        call WriteObjIndice
        zCopy {'StringTableSize: D$ ', 0}

        call WriteObjIndice
        zCopy {'StringDataEnd - ', 0}
        call WriteObjIndice
        zCopy {'StringTableSize] ; Hex Value:  ', 0}

    pop esi

    mov edx esi | add edx D$esi ; We will use edx as a counter delimiter for the strings

    lodsd | call WriteEax
    push esi | zCopy {D$ CRLF2, B$ "; Strings Array", D$ CRLF2 0} | pop esi


    push esi
        mov B$edi '[' | inc edi
        call WriteObjIndice
        zCopy {'StringData', 0}
        mov B$edi ':', W$edi+1 CRLF | add edi 3
    pop esi


   .Do

        push esi
            call WriteObjIndice
            zCopy {'StringData', 0}
            zCopy StringTableRecord
            zCopy {": B$ '", 0}
        pop esi


        While B$esi <> 0 | movsb | End_While | inc esi | On B$esi = 0, mov edx 0

        mov D$edi "', 0" | add edi 4
        mov W$edi CRLF | add edi 2

        call IncrementStringTableRecord

    .Loop_Until esi >= edx

    sub edi 2

       push esi
            mov W$edi CRLF | add edi 2
            call WriteObjIndice
            zCopy {B$ "StringDataEnd:]", W$ CRLF, 0}
        pop esi

ret


____________________________________________________________________________________________

[CoffSectionBase: ?]

GetCoffListing:
    mov D$CoffSectionBase esi

    call GetCoffIMAGE_FILE_HEADER

    If D$SizeOfOptionalHeaderInObj <> 0
        push esi
            call GetCoffIMAGE_OPTIONAL_HEADER
        pop esi
        add esi D$SizeOfOptionalHeaderInObj
    End_If

    call InitSectionHeaderNumber
    mov ecx D$ObjNumberOfSections

    .If ecx <> 0 ; If Section NUmber is not 0, do all checkings

        mov D$FirstSectionPointer esi

        push esi, ecx
        L0:
            push ecx
            call GetCoffSectionHeader
            call IncrementSectionHeaderNumber
            pop ecx
        loop L0<
        pop ecx, esi

        call InitSectionHeaderNumber
        call InitSectionRelocNumber
        mov esi D$FirstSectionPointer

        If D$ObjNumberOfSections <> 0
            L0:
                push ecx, esi
                call IdentifyRawDataType
                call GetCoffSectionsVariables
                call WriteCoffSectionData
                On W$NumberOfRelocations <> 0, call WriteCoffReloc
                On W$NumberOfLineNumbers <> 0, call WriteCoffLineNumber
                call IncrementSectionHeaderNumber
                pop esi, ecx
                add esi 40
            loop L0<
        End_If

        If D$CoffSymbolsPointer <> 0
            call GetStringTablePointer
            call WriteImageSymbolTable
            ; When we don´t have any StringTable pointers, we bypass the next call
            On D$StringtableCheckFlag = &TRUE, call WriteImageSymbolStringsTable
        End_If

    .Else ; Else, if section number is 0, perform only the checkings for the Symbol Pointer. Only this because the Optional
          ; Header check were already performed. This was because a problem like this in corelibc.lib (Pelles file)

        If D$CoffSymbolsPointer <> 0
            call GetStringTablePointer
            call WriteImageSymbolTable
            ; When we don´t have any StringTable pointers, we bypass the next call
            On D$StringtableCheckFlag = &TRUE, call WriteImageSymbolStringsTable
        End_If


    .End_If

ret
____________________________________________________________________________________________

;;
  Values set in 'FirstSectionPointer', 'CoffSectionSize', 'CoffPointerToData'
  by 'GetCoffSectionsVariables'.
;;


__________________________________________________________________

Proc WriteRawDataLinkerDirectiveReport:
    Uses esi, eax, edx

        mov edx esi | add edx ecx

        .If B$esi = 0
            mov B$edi '0' | inc edi | inc esi
        .Else

            mov D$edi '    ' | add edi 4
L0:         lodsb
            If al = 0
                dec esi | jmp L1>

            Else_If al = ' '
                mov W$edi CRLF, D$edi+2 '    ' | add edi 6

            Else
                stosb
            End_If
            On esi < edx, jmp L0<

L1:

        .End_If
;ret
EndP

__________________________________________________________________

;WriteRelocStorageClassEquate

[DebugSIndexValue: D$ 0]

WriteDebugSIndexEquate:
    push esi

        movzx eax W$esi | mov D$DebugSIndexValue eax

        .If eax = &S_COMPILE
            zCopy {'&S_COMPILE ; Hex Value:  ', 0}
        .Else_If eax = &S_REGISTER
            zCopy {'&S_REGISTER ; Hex Value:  ', 0}
        .Else_If eax = &S_CONSTANT
            zCopy {'&S_CONSTANT ; Hex Value:  ', 0}
        .Else_If eax = &S_UDT
            zCopy {'&S_UDT ; Hex Value:  ', 0}
        .Else_If eax = &S_SSEARCH
            zCopy {'&S_SSEARCH ; Hex Value:  ', 0}
        .Else_If eax = &S_END
            zCopy {'&S_END ; Hex Value:  ', 0}
        .Else_If eax = &S_SKIP
            zCopy {'&S_SKIP ; Hex Value:  ', 0}
        .Else_If eax = &S_CVRESERVE
            zCopy {'&S_CVRESERVE ; Hex Value:  ', 0}
        .Else_If eax = &S_OBJNAME
            zCopy {'&S_OBJNAME ; Hex Value:  ', 0}
        .Else_If eax = &S_ENDARG
            zCopy {'&S_ENDARG ; Hex Value:  ', 0}
        .Else_If eax = &S_COBOLUDT
            zCopy {'&S_COBOLUDT ; Hex Value:  ', 0}
        .Else_If eax = &S_MANYREG
            zCopy {'&S_MANYREG ; Hex Value:  ', 0}
        .Else_If eax = &S_RETURN
            zCopy {'&S_RETURN ; Hex Value:  ', 0}
        .Else_If eax = &S_ENTRYTHIS
            zCopy {'&S_ENTRYTHIS ; Hex Value:  ', 0}
        .Else_If eax = &S_BPREL16
            zCopy {'&S_BPREL16 ; Hex Value:  ', 0}
        .Else_If eax = &S_LDATA16
            zCopy {'&S_LDATA16 ; Hex Value:  ', 0}
        .Else_If eax = &S_GDATA16
            zCopy {'&S_GDATA16 ; Hex Value:  ', 0}
        .Else_If eax = &S_PUB16
            zCopy {'&S_PUB16 ; Hex Value:  ', 0}
        .Else_If eax = &S_LPROC16
            zCopy {'&S_LPROC16 ; Hex Value:  ', 0}
        .Else_If eax = &S_GPROC16
            zCopy {'&S_GPROC16 ; Hex Value:  ', 0}
        .Else_If eax = &S_THUNK16
            zCopy {'&S_THUNK16 ; Hex Value:  ', 0}
        .Else_If eax = &S_BLOCK16
            zCopy {'&S_BLOCK16 ; Hex Value:  ', 0}
        .Else_If eax = &S_WITH16
            zCopy {'&S_WITH16 ; Hex Value:  ', 0}
        .Else_If eax = &S_LABEL16
            zCopy {'&S_LABEL16 ; Hex Value:  ', 0}
        .Else_If eax = &S_CEXMODEL16
            zCopy {'&S_CEXMODEL16 ; Hex Value:  ', 0}
        .Else_If eax = &S_VFTPATH16
            zCopy {'&S_VFTPATH16 ; Hex Value:  ', 0}
        .Else_If eax = &S_REGREL16
            zCopy {'&S_REGREL16 ; Hex Value:  ', 0}
        .Else_If eax = &S_BPREL32
            zCopy {'&S_BPREL32 ; Hex Value:  ', 0}
        .Else_If eax = &S_LDATA32
            zCopy {'&S_LDATA32 ; Hex Value:  ', 0}
        .Else_If eax = &S_GDATA32
            zCopy {'&S_GDATA32 ; Hex Value:  ', 0}
        .Else_If eax = &S_PUB32
            zCopy {'&S_PUB32 ; Hex Value:  ', 0}
        .Else_If eax = &S_LPROC32
            zCopy {'&S_LPROC32 ; Hex Value:  ', 0}
        .Else_If eax = &S_GPROC32
            zCopy {'&S_GPROC32 ; Hex Value:  ', 0}
        .Else_If eax = &S_THUNK32
            zCopy {'&S_THUNK32 ; Hex Value:  ', 0}
        .Else_If eax = &S_BLOCK32
            zCopy {'&S_BLOCK32 ; Hex Value:  ', 0}
        .Else_If eax = &S_VFTPATH32
            zCopy {'&S_VFTPATH32 ; Hex Value:  ', 0}
        .Else_If eax = &S_REGREL32
            zCopy {'&S_REGREL32 ; Hex Value:  ', 0}
        .Else_If eax = &S_LTHREAD32
            zCopy {'&S_LTHREAD32 ; Hex Value:  ', 0}
        .Else_If eax = &S_GTHREAD32
            zCopy {'&S_GTHREAD32 ; Hex Value:  ', 0}
        .Else_If eax = &S_LPROCMIPS
            zCopy {'&S_LPROCMIPS ; Hex Value:  ', 0}
        .Else_If eax = &S_GPROCMIPS
            zCopy {'&S_GPROCMIPS ; Hex Value:  ', 0}
        .Else_If eax = &S_PROCREF
            zCopy {'&S_PROCREF ; Hex Value:  ', 0}
        .Else_If eax = &S_DATAREF
            zCopy {'&S_DATAREF ; Hex Value:  ', 0}
        .Else_If eax = &S_ALIGN
            zCopy {'&S_ALIGN ; Hex Value:  ', 0}
        .Else_If eax = &S_BLOCK_CV2
            zCopy {'&S_BLOCK_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_BPREL_CV2
            zCopy {'&S_BPREL_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_BPREL32_CV3
            zCopy {'&S_BPREL32_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_COBOLUDT_CV3
            zCopy {'&S_COBOLUDT_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_COMPILE_CV2
            zCopy {'&S_COMPILE_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_COMPILE_CV3
            zCopy {'&S_COMPILE_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_CONSTANT_CV2
            zCopy {'&S_CONSTANT_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_CONSTANT_CV3
            zCopy {'&S_CONSTANT_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_GDATA_CV2
            zCopy {'&S_GDATA_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_GDATA_CV3
            zCopy {'&S_GDATA_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_GPROC_CV2
            zCopy {'&S_GPROC_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_GPROC32_CV3
            zCopy {'&S_GPROC32_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_GTHREAD_CV3
            zCopy {'&S_GTHREAD_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_LABEL_CV2
            zCopy {'&S_LABEL_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_LDATA_CV2
            zCopy {'&S_LDATA_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_LDATA_CV3
            zCopy {'&S_LDATA_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_LPROC_CV2
            zCopy {'&S_LPROC_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_LPROC_CV3
            zCopy {'&S_LPROC_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_LTHREAD_CV3
            zCopy {'&S_LTHREAD_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_MANYREG_CV3
            zCopy {'&S_MANYREG_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_MSTOOL_CV2
            zCopy {'&S_MSTOOL_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_PUB_CV3
            zCopy {'&S_PUB_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_PUB_DATA_CV2
            zCopy {'&S_PUB_DATA_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_PUB_FUNC1_CV2
            zCopy {'&S_PUB_FUNC1_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_PUB_FUNC2_CV2
            zCopy {'&S_PUB_FUNC2_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_REGISTER_CV3
            zCopy {'&S_REGISTER_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_REGREL_CV3
            zCopy {'&S_REGREL_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_THUNK_CV2
            zCopy {'&S_THUNK_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_UDT_CV2
            zCopy {'&S_UDT_CV2; Hex Value:  ', 0}
        .Else_If eax = &S_UDT_CV3
            zCopy {'&S_UDT_CV3; Hex Value:  ', 0}
        .Else_If eax = &S_VFTTABLE_CV3
            zCopy {'&S_VFTTABLE_CV3; Hex Value:  ', 0}
        .End_If
    pop esi
ret


__________________________________________________________________

Proc WriteRawDataDebugSItem:
    Argument @Text1, @Text2
    uses eax

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice

            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1

        If D$eax = 'Leng' ; from "Length" string
            xor eax eax
            lodsw | call WriteEax

        Else_If D$eax = 'Inde'; From "Index" string
            call WriteDebugSIndexEquate
            xor eax eax
            lodsw | call WriteEax

        End_If

        mov W$edi CRLF | add edi 2
EndP

__________________________________________________________________


Proc WriteCVdataTitle:
    Uses esi, ecx

    mov D$edi '    ' | add edi 4
    call WriteObjIndice
    zCopy {"Sec", 0}
    zCopy SectionHeaderNumber
    zCopy {".Index", 0}
    zCopy DebugNumber
    zCopy D$CVLabel
    zCopy {'DummyBytes', 0}
    If D$NestedLeafType = &TRUE
        zCopy {'.Arr', 0}
        zCopy LeafTypeArrayObjIndice
    End_If
    mov D$edi ': B$', B$edi+4 ' ' | add edi 5

EndP
__________________________________________________________________

[DebugNumber: '000001', 0]


InitSectionDebugNumber:
    mov D$DebugNumber '0000', D$DebugNumber+4 '01'
ret


IncrementSectionDebugNumber:
    lea ebx D$DebugNumber+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret


__________________________________________________________________


__________________________________________________________________

;;
Flag1 Member:

The Flag1 member is a Byte value responsable for several different computatiions accordying to specified bits.
We need to shr the founded values to find the proper equates used.


PCodePresent : 1 Uses Bit 0. When the bit is flagged the file uses PCode. Otherwise it don't use.
                Equates :   CV4_PCODE_ENABLED 01
                            CV4_PCODE_DISABLED 0

FloatPrecision :2   Uses Bits 1 and 2. The FloatPrecision flag is set to 1 if the compiler follows the
                    ANSI C floating-point precision rules. This is specified for Microsoft C compilers
                    by setting the -Op option. So, i builded 4 equates:
    
                    CV4_FP_PRECISION_RESERVED1 0
                    CV4_FP_PRECISION_ANSI 1
                    CV4_FP_PRECISION_RESERVED2 2
                    CV4_FP_PRECISION_RESERVED3 3

FloatPackage :2     Uses bits 3 and 4. The equates used are:

                    CV4_FP8087_PROCESSOR 0 Hardware processor (80x87 for Intel 80x86 processors)
                    CV4_FP8087_EMULATOR 1 Emulator
                    CV4_FP8087_ALTMATH 2 Altmath
                    CV4_FP8087_RESERVED 3 Reserved

AmbientData :3      Uses bits 5, 6, 7 . The equates used are:

                    Ambient code and data memory model enumeration:
                    CV4_AMBIENTDATA_NEAR 0 Near
                    CV4_AMBIENTDATA_FAR 1 Far
                    CV4_AMBIENTDATA_HUGE 2 Huge
                    CV4_AMBIENTDATA_RESERVED3 3 Reserved
                    CV4_AMBIENTDATA_RESERVED4 4 Reserved
                    CV4_AMBIENTDATA_RESERVED5 5 Reserved
                    CV4_AMBIENTDATA_RESERVED6 6 Reserved
                    CV4_AMBIENTDATA_RESERVED7 7 Reserved

                    Note: Values  3 - 7 Reserved
;;


Proc WriteCVCompileFlag1Equates:
    Uses esi, ebx, eax

    xor eax eax | lodsb | mov ebx eax

    push ebx
    push eax

    shr ebx 5 ; This is to calculate AmbientData. Shr by 5 because the Bit 5 is the one that is starting to be flagged.

    .If ebx = &CV4_AMBIENTDATA_NEAR
        zCopy {'(&CV4_AMBIENTDATA_NEAR shl 5)', 0}
    .Else_If ebx = &CV4_AMBIENTDATA_FAR
        zCopy {'(&CV4_AMBIENTDATA_FAR shl 5)', 0}
    .Else_If ebx = &CV4_AMBIENTDATA_HUGE
        zCopy {'(&CV4_AMBIENTDATA_HUGE shl 5)', 0}
    .Else_If ebx = &CV4_AMBIENTDATA_RESERVED3
        zCopy {'(&CV4_AMBIENTDATA_RESERVED3 shl 5)', 0}
    .Else_If ebx = &CV4_AMBIENTDATA_RESERVED4
        zCopy {'(&CV4_AMBIENTDATA_RESERVED4 shl 5)', 0}
    .Else_If ebx = &CV4_AMBIENTDATA_RESERVED5
        zCopy {'(&CV4_AMBIENTDATA_RESERVED5 shl 5)', 0}
    .Else_If ebx = &CV4_AMBIENTDATA_RESERVED6
        zCopy {'(&CV4_AMBIENTDATA_RESERVED6 shl 5)', 0}
    .Else
        zCopy {'(&CV4_AMBIENTDATA_RESERVED7 shl 5)', 0}
    .End_If

        zCopy {' + ', 0}
        ; Now we must Zero bits 5 to 7 to shr again to find the next records for FloatPackage (Bits 3-4)
        btr eax 5 | btr eax 6 | btr eax 7
        ; After clearing the bits, we need to compute only the needed bits to be shred
        shr eax 3 ; This is to calculate FloatPackage. Shr by 3 because the Bit 3 is the one that is starting to be flagged.

    .If eax = &CV4_FP8087_PROCESSOR
        zCopy {'(&CV4_FP8087_PROCESSOR shl 3)', 0}
    .Else_If eax = &CV4_FP8087_EMULATOR
        zCopy {'(&CV4_FP8087_EMULATOR shl 3)', 0}
    .Else_If eax = &CV4_FP8087_ALTMATH
        zCopy {'(&CV4_FP8087_ALTMATH shl 3)', 0}
    .Else
        zCopy {'(&CV4_FP8087_RESERVED shl 3)', 0}
    .End_If

    pop eax
    pop ebx

        zCopy {' + ', 0}

    ; Now we restored the values of ebx and eax. We will going to find the values for
    ; PCodePresent (Bit 0) and FloatPrecision (Bits 1 and 2)
    ; Since we restored the values we must clear bits 3 to 7

    ; zeroes bits 3 to 7
    btr eax 3 | btr eax 4 | btr eax 5 | btr eax 6 | btr eax 7


    shr eax 1 ; This is to calculate FloatPrecision. Shr by 1 because the Bit 1 is the one that is starting to be flagged.

    .If eax = &CV4_FP_PRECISION_RESERVED1
        zCopy {'(&CV4_FP_PRECISION_RESERVED1 shl 1)', 0}
    .Else_If eax = &CV4_FP_PRECISION_ANSI
        zCopy {'(&CV4_FP_PRECISION_ANSI shl 1)', 0}
    .Else_If eax = &CV4_FP_PRECISION_RESERVED2
        zCopy {'(&CV4_FP_PRECISION_RESERVED2 shl 1)', 0}
    .Else
        zCopy {'(&CV4_FP_PRECISION_RESERVED3 shl 1)', 0}
    .End_If

        zCopy {' + ', 0}

    and ebx 01 ; This is to calculate PCodePresent.
               ; The value of 1 is because it is the maximum value of all bits flagged. (Bit 0)

    .If ebx = &CV4_PCODE_ENABLED
        zCopy {'&CV4_PCODE_ENABLED', 0}
    .Else
        zCopy {'&CV4_PCODE_DISABLED', 0}
    .End_If

        zCopy {' ; Hex Value:  ', 0}

EndP

;;

Flag2 Member:

The Flag2 member is a Byte value responsable for several different computatiions accordying to specified bits.
We need to shr the founded values to find the proper equates used.


AmbientCode :3  Uses bits 0, 1 , 2. The equates used are:

                CV4_AMBIENTCODE_NEAR 0 Near
                CV4_AMBIENTCODE_FAR 1 Far
                CV4_AMBIENTCODE_HUGE 2 Huge
                CV4_AMBIENTCODE_RESERVED3 3 Reserved
                CV4_AMBIENTCODE_RESERVED4 4 Reserved
                CV4_AMBIENTCODE_RESERVED5 5 Reserved
                CV4_AMBIENTCODE_RESERVED6 6 Reserved
                CV4_AMBIENTCODE_RESERVED7 7 Reserved

                Note: Values  3 - 7 Reserved

Mode32 :1       Uses Bit 3. When the bit is flagged the file is compiled for 32-bit addresses, otherwise it is not.
                Equates used are:
                
                CV4_MODE32_ENABLED 1 ; Compiled for 32-bit addresses
                CV4_MODE32_DISABLED 0  ; Not compiled for 32-bit addresses

Reserved :4     Used Bits 4,5,6,7. Those bits are reserved. So, they shoulnd't be used, we can set them all to 0.

;;

_______________________________________________

Proc WriteCVCompileFlag2Equates:
    Uses esi, ebx, eax

    If B$esi > 15
        xor eax eax
        lodsb | btr eax 4 | btr eax 5 | btr eax 6 | btr eax 7 ; Clear Bits 4 to 7, that are what exceed the limit of 15
        mov ebx eax
    Else
        xor eax eax | lodsb | mov ebx eax
    End_If

    and eax 07 ; This is to calculate AmbientCode.
               ; The value of 7 is because it is the maximum value of all bits flagged. (0 to 3)

    shr ebx 3 ; This is to calculate Mode32. Shr by 3 because the Bit 3 is the one that is flagged.

    If ebx = &CV4_MODE32_ENABLED
        zCopy {'(&CV4_MODE32_ENABLED shl 3)', 0}
    Else
        zCopy {'(&CV4_MODE32_DISABLED shl 3)', 0}
    End_If

    .If eax = &CV4_AMBIENTCODE_NEAR
        zCopy {' + &CV4_AMBIENTCODE_NEAR', 0}
    .Else_If eax = &CV4_AMBIENTCODE_FAR
        zCopy {' + &CV4_AMBIENTCODE_FAR', 0}
    .Else_If eax = &CV4_AMBIENTCODE_HUGE
        zCopy {' + &CV4_AMBIENTCODE_HUGE', 0}
    .Else_If eax = &CV4_AMBIENTCODE_RESERVED3
        zCopy {' + &CV4_AMBIENTCODE_RESERVED3', 0}
    .Else_If eax = &CV4_AMBIENTCODE_RESERVED4
        zCopy {' + &CV4_AMBIENTCODE_RESERVED4', 0}
    .Else_If eax = &CV4_AMBIENTCODE_RESERVED5
        zCopy {' + &CV4_AMBIENTCODE_RESERVED5', 0}
    .Else_If eax = &CV4_AMBIENTCODE_RESERVED6
        zCopy {' + &CV4_AMBIENTCODE_RESERVED6', 0}
    .Else
        zCopy {' + &CV4_AMBIENTCODE_RESERVED7', 0}
    .End_If
        zCopy {' ; Hex Value:  ', 0}

EndP
_______________

;;
Used Equates. All that is not listed is reserved

&CV4_COMPILE_LANG_C 0 ; C
&CV4_COMPILE_LANG_CPLUS 01 ; C++
&CV4_COMPILE_LANG_FORTRAN 02; Fortran
&CV4_COMPILE_LANG_MASM 03; Masm
&CV4_COMPILE_LANG_PASCAL 04; Pascal
&CV4_COMPILE_LANG_BASIC 05; Basic
&CV4_COMPILE_LANG_COBOL 06; Cobol

;;

Proc WriteCVCompileLanguageEquates:
    Uses esi

    .If B$esi = &CV4_COMPILE_LANG_C
        zCopy {'&CV4_COMPILE_LANG_C ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_LANG_CPLUS
        zCopy {'&CV4_COMPILE_LANG_CPLUS ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_LANG_FORTRAN
        zCopy {'&CV4_COMPILE_LANG_FORTRAN ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_LANG_MASM
        zCopy {'&CV4_COMPILE_LANG_MASM ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_LANG_PASCAL
        zCopy {'&CV4_COMPILE_LANG_PASCAL ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_LANG_BASIC
        zCopy {'&CV4_COMPILE_LANG_BASIC ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_LANG_COBOL
        zCopy {'&CV4_COMPILE_LANG_COBOL ; Hex Value:  ', 0}
    .End_if


EndP

_______________

;;

Used Equates. All that is not listed is reserved

&CV4_COMPILE_MACHINE_I80 ; Intel 8080
&CV4_COMPILE_MACHINE_I86 ; Intel 8086
&CV4_COMPILE_MACHINE_I286 ; Intel 80286
&CV4_COMPILE_MACHINE_I386 ; Intel 80386
&CV4_COMPILE_MACHINE_I486 ; Intel 80486
&CV4_COMPILE_MACHINE_I586 ; Intel Pentium
&CV4_COMPILE_MACHINE_R4000 ; MIPS R4000
&CV4_COMPILE_MACHINE_MIPSRESERVED1 ; Reserved for future MIPS processor
&CV4_COMPILE_MACHINE_MIPSRESERVED2 ; Reserved for future MIPS processor
&CV4_COMPILE_MACHINE_MC68000 ; MC68000
&CV4_COMPILE_MACHINE_MC68010 ; MC68010
&CV4_COMPILE_MACHINE_MC68020 ; MC68020
&CV4_COMPILE_MACHINE_MC68030 ; MC68030
&CV4_COMPILE_MACHINE_MC68040 ; MC68040
&CV4_COMPILE_MACHINE_ALPHA ; DEC Alpha
;;


Proc WriteCVCompileMachineEquates:
    Uses esi

    .If B$esi = &CV4_COMPILE_MACHINE_I80
        zCopy {'&CV4_COMPILE_MACHINE_I80 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_I86
        zCopy {'&CV4_COMPILE_MACHINE_I86 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_I286
        zCopy {'&CV4_COMPILE_MACHINE_I286 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_I386
        zCopy {'&CV4_COMPILE_MACHINE_I386 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_I486
        zCopy {'&CV4_COMPILE_MACHINE_I486 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_I586
        zCopy {'&CV4_COMPILE_MACHINE_I586 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_R4000
        zCopy {'&CV4_COMPILE_MACHINE_R4000 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MIPSRESERVED1
        zCopy {'&CV4_COMPILE_MACHINE_MIPSRESERVED1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MIPSRESERVED2
        zCopy {'&CV4_COMPILE_MACHINE_MIPSRESERVED2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MC68000
        zCopy {'&CV4_COMPILE_MACHINE_MC68000 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MC68010
        zCopy {'&CV4_COMPILE_MACHINE_MC68010 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MC68020
        zCopy {'&CV4_COMPILE_MACHINE_MC68020 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MC68030
        zCopy {'&CV4_COMPILE_MACHINE_MC68030 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_MC68040
        zCopy {'&CV4_COMPILE_MACHINE_MC68040 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_COMPILE_MACHINE_ALPHA
        zCopy {'&CV4_COMPILE_MACHINE_ALPHA ; Hex Value:  ', 0}
    .End_if


EndP
________________

Proc WriteRawDataDebugSCompileItem:
    Argument @Text1, @Text2, @DataSize
    uses eax, ecx

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'Compile.', 0}
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1

        ..If D$eax = 'Mach' ; from "Machine" string
            call WriteCVCompileMachineEquates
            If D@DataSize = 4
                lodsd | call WriteEax
            Else
                xor eax eax
                lodsb | call WriteEax
            End_If
        ..Else_If D$eax = 'Lang'; From "Language" string
            call WriteCVCompileLanguageEquates
            If D@DataSize = 4
                lodsd | call WriteEax
            Else
                xor eax eax
                lodsb | call WriteEax
            End_If

        ..Else_If D$eax+2 = 'ags1'; From "Flags1" string
            call WriteCVCompileFlag1Equates
            If D@DataSize = 4
                lodsd | call WriteEax
            Else
                xor eax eax
                lodsb | call WriteEax
            End_If

        ..Else_If D$eax+2 = 'ags2'; From "Flags2" string
            call WriteCVCompileFlag2Equates
            If D@DataSize = 4
                lodsd | call WriteEax
            Else
                xor eax eax
                lodsb | call WriteEax
            End_If

        ..Else_If D$eax = 'Unkn'; From "Unknown" string
            If D@DataSize = 4
                lodsd | call WriteEax
            Else
                xor eax eax
                lodsw | call WriteEax
            End_If

        ..Else_If D$eax = 'Comp'; From "CompilerID" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            If D@DataSize = 2 ; this happens only in S_COMPILE_CV2. It´' size is not 2, but we use this to identify this type.
                push eax
                    call StrLenProc esi
                    mov ecx eax
                    inc ecx ; The size is increased to we alow including the zero byte
                pop eax
            Else
                movzx ecx B$esi-1
            End_If

            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2
EndP

_________________________________________

[CVNonLeafIndexPad03Unknown01: 'Unknown01', 0
 CVNonLeafIndexPad03Unknown02: 'Unknown02', 0
 CVNonLeafIndexPad03Unknown03: 'Unknown03', 0
 CVNonLeafIndexPad03NameLenght: 'NameLenght', 0
 CVNonLeafIndexPad03Name: 'Name', 0]

Proc WriteRawDataDebugSNonLeafIndexPad03:
    Uses ecx, eax, ebx
    ; This is to avoid that the Structure have dummy bytes at the end.
   ; mov ebx esi
  ;  sub ebx 2
 ;   mov ecx D$SizeAdd
;    add ebx ecx

;    push ebx

    call WriteRawDataDebugSNonLeafIndexPad03Item CVNonLeafIndexPad03Unknown01, {': B$ ', 0}
    call WriteRawDataDebugSNonLeafIndexPad03Item CVNonLeafIndexPad03Unknown02, {': B$ ', 0}
    call WriteRawDataDebugSNonLeafIndexPad03Item CVNonLeafIndexPad03Unknown03, {': B$ ', 0}
    call WriteRawDataDebugSNonLeafIndexPad03Item CVNonLeafIndexPad03NameLenght, {': D$ ', 0}

    mov ebx esi
    mov ecx D$SizeAdd
    add ebx ecx
    add ebx D$esi-4

    If D$esi-4 <> 0 ; is the Name Lenght = 0 ? jmp over.

        push ebx
            call WriteRawDataDebugSNonLeafIndexPad03Item CVNonLeafIndexPad03Name, {': B$ ', 0}
        pop ebx

    End_If
    ; Is the end of this structure ends on the proper place ?

    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________

Proc WriteRawDataDebugSNonLeafIndexPad03Item:
    Argument @Text1, @Text2
    uses eax, ecx, ebx

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'NoIndexLeafPad03.', 0}
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1

        ..If D$eax = 'Unkn' ; from "Unknown01", "Unknown02", "Unknown03" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            lodsd | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-4
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2
EndP

________________________

[CVCompileMachine: 'Machine', 0
 CVCompileLanguage: 'Language', 0
 CVCompileFlags1: 'Flags1', 0
 CVCompileFlags2: 'Flags2', 0
 CVCompileUnknown: 'Unknown', 0
 CVCompileCompilerID: 'CompilerID', 0
 CVCompileNameLenght: 'NameLenght', 0
 CVCompileName: 'Name', 0]


Proc WriteRawDataDebugSCompile:
    Uses ecx, eax, ebx
    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx

    .If W$esi-2 = &S_COMPILE
        call WriteRawDataDebugSCompileItem CVCompileMachine, {': B$ ', 0}, 1
        call WriteRawDataDebugSCompileItem CVCompileLanguage, {': B$ ', 0}, 1
        call WriteRawDataDebugSCompileItem CVCompileFlags1, {': B$ ', 0}, 1
        call WriteRawDataDebugSCompileItem CVCompileFlags2, {': B$ ', 0}, 1
        call WriteRawDataDebugSCompileItem CVCompileNameLenght, {': B$ ', 0}, 1
        call WriteRawDataDebugSCompileItem CVCompileName, {': B$ ', 0}, 1
    .Else_If W$esi-2 = &S_COMPILE_CV3
        call WriteRawDataDebugSCompileItem CVCompileLanguage, {': D$ ', 0}, 4
        call WriteRawDataDebugSCompileItem CVCompileMachine, {': D$ ', 0}, 4
        call WriteRawDataDebugSCompileItem CVCompileFlags2, {': D$ ', 0}, 4
        call WriteRawDataDebugSCompileItem CVCompileFlags1, {': D$ ', 0}, 4
        call WriteRawDataDebugSCompileItem CVCompileCompilerID, {': W$ ', 0}, 2
        call WriteRawDataDebugSCompileItem CVCompileNameLenght, {': B$ ', 0}, 1
        call WriteRawDataDebugSCompileItem CVCompileName, {': B$ ', 0}, 1

    .Else_If W$esi-2 = &S_COMPILE_CV2
        ; The members below seems to be a variation of the S_OBJNAME structured data.
        ; The Unknown seems to be the Signature
        ; The name is the object name, with full path. (And not the name of the object only as in S_OBJECT)
        call WriteRawDataDebugSCompileItem CVCompileUnknown, {': D$ ', 0}, 4
        call WriteRawDataDebugSCompileItem CVCompileName, {': B$ ', 0}, 2
    .End_If

    pop ebx

    ; Is the end of this structure ends on the proper place ?

    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP


________________________________________________________________________________

[CVMsToolMachine: 'Machine', 0
 CVMsToolLanguage: 'Language', 0
 CVMsToolUnknown1: 'Unknown1', 0
 CVMsToolUnknown2: 'Unknown2', 0
 CVMsToolUnknown3: 'Unknown3', 0
 CVMsToolUnknown4: 'Unknown4', 0
 CVMsToolUnknown5: 'Unknown5', 0
 CVMsToolUnknown6: 'Unknown6', 0
 CVMsToolUnknown7: 'Unknown7', 0
 CVMsToolUnknown8: 'Unknown8', 0
 CVMsToolName: 'Name', 0]

Proc WriteRawDataDebugSMsTool:
    Uses ecx, eax, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx

    .If W$esi-2 = &S_MSTOOL_CV2
        call WriteRawDataDebugSMsToolItem CVMsToolMachine, {': B$ ', 0}
        call WriteRawDataDebugSMsToolItem CVMsToolLanguage, {': B$ ', 0}
        call WriteRawDataDebugSMsToolItem CVMsToolUnknown1, {': W$ ', 0}
        call WriteRawDataDebugSMsToolItem CVMsToolUnknown2, {': W$ ', 0}
        call WriteRawDataDebugSMsToolItem CVMsToolUnknown3, {': W$ ', 0}
        call WriteRawDataDebugSMsToolItem CVMsToolUnknown4, {': W$ ', 0}
        call WriteRawDataDebugSMsToolItem CVMsToolUnknown5, {': W$ ', 0}
        call WriteRawDataDebugSMsToolItem CVMsToolUnknown6, {': W$ ', 0}
        call WriteRawDataDebugSMsToolItem CVMsToolUnknown7, {': W$ ', 0}
        call WriteRawDataDebugSMsToolItem CVMsToolUnknown8, {': W$ ', 0}
        call WriteRawDataDebugSMsToolItem CVMsToolName, {': B$ ', 0}
    .End_If

    pop ebx

    ; Is the end of this structure ends on the proper place ?

    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP
_________________________________

Proc WriteRawDataDebugSMsToolItem:
    Argument @Text1, @Text2
    uses eax, ecx

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'MsTool.', 0}
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1

        ..If D$eax = 'Mach' ; from "Machine" string
            call WriteCVCompileMachineEquates
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Lang'; From "Language" string
            call WriteCVCompileLanguageEquates
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax+4 = 'own1'; From "Unknown1" string
                xor eax eax
                lodsw | call WriteEax

        ..Else_If D$eax+4 = 'own2'; From "Unknown2" string
                xor eax eax
                lodsw | call WriteEax

        ..Else_If D$eax+4 = 'own3'; From "Unknown3" string
                xor eax eax
                lodsw | call WriteEax

        ..Else_If D$eax+4 = 'own4'; From "Unknown4" string
                xor eax eax
                lodsw | call WriteEax

        ..Else_If D$eax+4 = 'own5'; From "Unknown5" string
                xor eax eax
                lodsw | call WriteEax

        ..Else_If D$eax+4 = 'own6'; From "Unknown6" string
                xor eax eax
                lodsw | call WriteEax

        ..Else_If D$eax+4 = 'own7'; From "Unknown7" string
                xor eax eax
                lodsw | call WriteEax

        ..Else_If D$eax+4 = 'own8'; From "Unknown8" string
                xor eax eax
                lodsw | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name. On this case (S_MSTOOL_CV2) The name is a null terminated string
                push eax
                    call StrLenProc esi
                    mov ecx eax
                    inc ecx ; The size is increased to we alow including the zero byte
                pop eax

            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2
EndP

________________________________________________________________________________

[CVRegisterType: 'Type', 0
 CVRegisterOldCVType: 'OldCVType', 0
 CVRegisterRegister: 'Register', 0
 CVRegisterNameLenght: 'NameLenght', 0
 CVRegisterName: 'Name', 0
 CVRegisterTrackingInfo: 'TrackingInfo', 0]

Proc WriteRawDataDebugSRegister:
    Local @EndPos, @OldCodeView
    Uses ecx, eax

    mov D@OldCodeView &FALSE
    If W$esi-2 = &S_REGISTER_CV3
        mov D@OldCodeView &TRUE
    End_If


    ; 1st find start of symbol (Address of index -> S_REGISTER)
    mov ecx esi
    sub ecx 2 ; at ecx we point to the Index value
    movzx eax W$esi-4 ; find the len of the symbol
    add ecx eax
    mov D@EndPos ecx

    If D@OldCodeView = &TRUE
        Call WriteRawDataDebugSRegisterItem CVRegisterOldCVType , {': W$ ', 0}
    End_If
    call WriteRawDataDebugSRegisterItem CVRegisterType, {': W$ ', 0}
    call WriteRawDataDebugSRegisterItem CVRegisterRegister, {': W$ ', 0}
    call WriteRawDataDebugSRegisterItem CVRegisterNameLenght, {': B$ ', 0}
    call WriteRawDataDebugSRegisterItem CVRegisterName, {': B$ ', 0}

    ..If esi <> D@EndPos ; is esi ending at EndPos ? No, do next line. Yes, jmp over

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'Register.TrackingInfo: B$ ', 0}
        pop esi

        mov ecx D@EndPos
        sub ecx esi

        .Do
            push ecx
            xor eax eax
            lodsb | call WriteEax
            mov W$edi ', ' | add edi 2
            pop ecx
            dec ecx
        .Loop_Until ecx = 0
            sub edi 2
            mov W$edi CRLF | add edi 2
    ..End_If

    ; bypass esi. Need to review this stuff
;    call WriteRawDataDebugSRegisterItem CVRegisterTrackingInfo, {': B$ ', 0}

; type equates here: WriteCVBPRel32TypeEquates
; call Write_IMAGE_FILE_MACHINE D$CoffMachineType
EndP
________________________________________________________________________________

Proc WriteRawDataDebugSRegisterItem:
    Argument @Text1, @Text2
    uses eax, ecx

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'Register.', 0}
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1

        ..If D$eax = 'Type' ; from "Type" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'OldC' ; from "OldCVType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Regi'; From "Register" string
            .If_Or D$CoffMachineType = &IMAGE_FILE_MACHINE_I386, D$CoffMachineType = &IMAGE_FILE_MACHINE_I486, D$CoffMachineType = &IMAGE_FILE_MACHINE_I586
                call WriteCVRegisterIntelRegEquates
            .Else_If D$CoffMachineType = &IMAGE_FILE_MACHINE_M68K
                call WriteCVRegisterM68KRegEquates
            .Else_If_Or D$CoffMachineType = &IMAGE_FILE_MACHINE_MIPS16, D$CoffMachineType = &IMAGE_FILE_MACHINE_MIPSFPU, D$CoffMachineType = &IMAGE_FILE_MACHINE_MIPSFPU16
                call WriteCVRegisterMipsRegEquates
            .End_If
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2
EndP

________________________________________________________________________________

Proc WriteCVRegisterIntelRegEquates:
    Uses esi

    .If B$esi = &CV4_REGISTER_INTEL_REG_NONE
        zCopy {'&CV4_REGISTER_INTEL_REG_NONE ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_AL
        zCopy {'&CV4_REGISTER_INTEL_REG_AL ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_CL
        zCopy {'&CV4_REGISTER_INTEL_REG_CL ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_DL
        zCopy {'&CV4_REGISTER_INTEL_REG_DL ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_BL
        zCopy {'&CV4_REGISTER_INTEL_REG_BL ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_AH
        zCopy {'&CV4_REGISTER_INTEL_REG_AH ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_CH
        zCopy {'&CV4_REGISTER_INTEL_REG_CH ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_DH
        zCopy {'&CV4_REGISTER_INTEL_REG_DH ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_BH
        zCopy {'&CV4_REGISTER_INTEL_REG_BH ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_AX
        zCopy {'&CV4_REGISTER_INTEL_REG_AX ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_CX
        zCopy {'&CV4_REGISTER_INTEL_REG_CX ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_DX
        zCopy {'&CV4_REGISTER_INTEL_REG_DX ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_BX
        zCopy {'&CV4_REGISTER_INTEL_REG_BX ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_SP
        zCopy {'&CV4_REGISTER_INTEL_REG_SP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_BP
        zCopy {'&CV4_REGISTER_INTEL_REG_BP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_SI
        zCopy {'&CV4_REGISTER_INTEL_REG_SI ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_DI
        zCopy {'&CV4_REGISTER_INTEL_REG_DI ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_EAX
        zCopy {'&CV4_REGISTER_INTEL_REG_EAX ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_ECX
        zCopy {'&CV4_REGISTER_INTEL_REG_ECX ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_EDX
        zCopy {'&CV4_REGISTER_INTEL_REG_EDX ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_EBX
        zCopy {'&CV4_REGISTER_INTEL_REG_EBX ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_ESP
        zCopy {'&CV4_REGISTER_INTEL_REG_ESP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_EBP
        zCopy {'&CV4_REGISTER_INTEL_REG_EBP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_ESI
        zCopy {'&CV4_REGISTER_INTEL_REG_ESI ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_EDI
        zCopy {'&CV4_REGISTER_INTEL_REG_EDI ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_ES
        zCopy {'&CV4_REGISTER_INTEL_REG_ES ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_CS
        zCopy {'&CV4_REGISTER_INTEL_REG_CS ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_SS
        zCopy {'&CV4_REGISTER_INTEL_REG_SS ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_DS
        zCopy {'&CV4_REGISTER_INTEL_REG_DS ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_FS
        zCopy {'&CV4_REGISTER_INTEL_REG_FS ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_REG_GS
        zCopy {'&CV4_REGISTER_INTEL_REG_GS ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SPECIALREGCASE_IP
        zCopy {'&CV4_REGISTER_INTEL_SPECIALREGCASE_IP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SPECIALREGCASE_FLAGS
        zCopy {'&CV4_REGISTER_INTEL_SPECIALREGCASE_FLAGS ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SPECIALREGCASE_EIP
        zCopy {'&CV4_REGISTER_INTEL_SPECIALREGCASE_EIP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SPECIALREGCASE_EFLAGS
        zCopy {'&CV4_REGISTER_INTEL_SPECIALREGCASE_EFLAGS ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_TEMP
        zCopy {'&CV4_REGISTER_INTEL_PCODEREG_TEMP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_TEMPH
        zCopy {'&CV4_REGISTER_INTEL_PCODEREG_TEMPH ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_QUOTE
        zCopy {'&CV4_REGISTER_INTEL_PCODEREG_QUOTE ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_RESERVED1
        zCopy {'&CV4_REGISTER_INTEL_PCODEREG_RESERVED1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_RESERVED2
        zCopy {'&CV4_REGISTER_INTEL_PCODEREG_RESERVED2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_RESERVED3
        zCopy {'&CV4_REGISTER_INTEL_PCODEREG_RESERVED3 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_RESERVED4
        zCopy {'&CV4_REGISTER_INTEL_PCODEREG_RESERVED4 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_PCODEREG_RESERVED5
        zCopy {'&CV4_REGISTER_INTEL_PCODEREG_RESERVED5 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_CR0
        zCopy {'&CV4_REGISTER_INTEL_SYSREG_CR0 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_CR1
        zCopy {'&CV4_REGISTER_INTEL_SYSREG_CR1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_CR2
        zCopy {'&CV4_REGISTER_INTEL_SYSREG_CR2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_CR3
        zCopy {'&CV4_REGISTER_INTEL_SYSREG_CR3 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR0
        zCopy {'&CV4_REGISTER_INTEL_SYSREG_DR0 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR1
        zCopy {'&CV4_REGISTER_INTEL_SYSREG_DR1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR2
        zCopy {'&CV4_REGISTER_INTEL_SYSREG_DR2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR3
        zCopy {'&CV4_REGISTER_INTEL_SYSREG_DR3 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR4
        zCopy {'&CV4_REGISTER_INTEL_SYSREG_DR4 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR5
        zCopy {'&CV4_REGISTER_INTEL_SYSREG_DR5 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR6
        zCopy {'&CV4_REGISTER_INTEL_SYSREG_DR6 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREG_DR7
        zCopy {'&CV4_REGISTER_INTEL_SYSREG_DR7 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST0
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST0 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST2
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST3
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST3 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST4
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST4 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST5
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST5 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST6
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST6 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ST7
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_ST7 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_CONTROL
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_CONTROL ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_STATUS
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_STATUS ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_TAG
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_TAG ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_FPIP
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_FPIP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_FPCS
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_FPCS ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_FPDO
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_FPDO ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_FPDS
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_FPDS ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_ISEM
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_ISEM ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_FPEIP
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_FPEIP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_INTEL_SYSREGEXTENSION_FPEDO
        zCopy {'&CV4_REGISTER_INTEL_SYSREGEXTENSION_FPEDO ; Hex Value:  ', 0}
    .End_If

EndP
________________________________________________________________________________

Proc WriteCVRegisterM68KRegEquates:
    Uses esi

    .If B$esi = &CV4_REGISTER_M68K_DATA_REG0
        zCopy {'&CV4_REGISTER_M68K_DATA_REG0 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG1
        zCopy {'&CV4_REGISTER_M68K_DATA_REG1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG2
        zCopy {'&CV4_REGISTER_M68K_DATA_REG2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG3
        zCopy {'&CV4_REGISTER_M68K_DATA_REG3 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG4
        zCopy {'&CV4_REGISTER_M68K_DATA_REG4 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG5
        zCopy {'&CV4_REGISTER_M68K_DATA_REG5 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG6
        zCopy {'&CV4_REGISTER_M68K_DATA_REG6 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_DATA_REG7
        zCopy {'&CV4_REGISTER_M68K_DATA_REG7 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG0
        zCopy {'&CV4_REGISTER_M68K_ADDRESS_REG0 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG1
        zCopy {'&CV4_REGISTER_M68K_ADDRESS_REG1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG2
        zCopy {'&CV4_REGISTER_M68K_ADDRESS_REG2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG3
        zCopy {'&CV4_REGISTER_M68K_ADDRESS_REG3 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG4
        zCopy {'&CV4_REGISTER_M68K_ADDRESS_REG4 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG5
        zCopy {'&CV4_REGISTER_M68K_ADDRESS_REG5 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG6
        zCopy {'&CV4_REGISTER_M68K_ADDRESS_REG6 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_ADDRESS_REG7
        zCopy {'&CV4_REGISTER_M68K_ADDRESS_REG7 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_CCR
        zCopy {'&CV4_REGISTER_M68K_R68_CCR ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_SR
        zCopy {'&CV4_REGISTER_M68K_R68_SR ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_USP
        zCopy {'&CV4_REGISTER_M68K_R68_USP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_MSP
        zCopy {'&CV4_REGISTER_M68K_R68_MSP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_SFC
        zCopy {'&CV4_REGISTER_M68K_R68_SFC ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_DFC
        zCopy {'&CV4_REGISTER_M68K_R68_DFC ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_CACR
        zCopy {'&CV4_REGISTER_M68K_R68_CACR ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_VBR
        zCopy {'&CV4_REGISTER_M68K_R68_VBR ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_CAAR
        zCopy {'&CV4_REGISTER_M68K_R68_CAAR ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_ISP
        zCopy {'&CV4_REGISTER_M68K_R68_ISP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_PC
        zCopy {'&CV4_REGISTER_M68K_R68_PC ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED1
        zCopy {'&CV4_REGISTER_M68K_RESERVED1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_FPCR
        zCopy {'&CV4_REGISTER_M68K_R68_FPCR ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_FPSR
        zCopy {'&CV4_REGISTER_M68K_R68_FPSR ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_R68_FPIAR
        zCopy {'&CV4_REGISTER_M68K_R68_FPIAR ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED2
        zCopy {'&CV4_REGISTER_M68K_RESERVED2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT0
        zCopy {'&CV4_REGISTER_M68K_FLOATING_POINT0 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT1
        zCopy {'&CV4_REGISTER_M68K_FLOATING_POINT1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT2
        zCopy {'&CV4_REGISTER_M68K_FLOATING_POINT2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT3
        zCopy {'&CV4_REGISTER_M68K_FLOATING_POINT3 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT4
        zCopy {'&CV4_REGISTER_M68K_FLOATING_POINT4 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT5
        zCopy {'&CV4_REGISTER_M68K_FLOATING_POINT5 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT6
        zCopy {'&CV4_REGISTER_M68K_FLOATING_POINT6 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_FLOATING_POINT7
        zCopy {'&CV4_REGISTER_M68K_FLOATING_POINT7 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED3
        zCopy {'&CV4_REGISTER_M68K_RESERVED3 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED4
        zCopy {'&CV4_REGISTER_M68K_RESERVED4 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED5
        zCopy {'&CV4_REGISTER_M68K_RESERVED5 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED6
        zCopy {'&CV4_REGISTER_M68K_RESERVED6 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED7
        zCopy {'&CV4_REGISTER_M68K_RESERVED7 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED8
        zCopy {'&CV4_REGISTER_M68K_RESERVED8 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED9
        zCopy {'&CV4_REGISTER_M68K_RESERVED9 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED10
        zCopy {'&CV4_REGISTER_M68K_RESERVED10 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED11
        zCopy {'&CV4_REGISTER_M68K_RESERVED11 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED12
        zCopy {'&CV4_REGISTER_M68K_RESERVED12 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_RESERVED13
        zCopy {'&CV4_REGISTER_M68K_RESERVED13 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_CV_R68_PSR
        zCopy {'&CV4_REGISTER_M68K_CV_R68_PSR ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_M68K_CV_R68_PCSR
        zCopy {'&CV4_REGISTER_M68K_CV_R68_PCSR ; Hex Value:  ', 0}
    .End_If

EndP
________________________________________________________________________________

Proc WriteCVRegisterMipsRegEquates:
    Uses esi

    .If B$esi = &CV4_REGISTER_MIPS_NOREGISTER
        zCopy {'&CV4_REGISTER_MIPS_NOREGISTER ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_ZERO
        zCopy {'&CV4_REGISTER_MIPS_INT_ZERO ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_AT
        zCopy {'&CV4_REGISTER_MIPS_INT_AT ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_V0
        zCopy {'&CV4_REGISTER_MIPS_INT_V0 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_V1
        zCopy {'&CV4_REGISTER_MIPS_INT_V1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_A0
        zCopy {'&CV4_REGISTER_MIPS_INT_A0 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_A1
        zCopy {'&CV4_REGISTER_MIPS_INT_A1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_A2
        zCopy {'&CV4_REGISTER_MIPS_INT_A2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_A3
        zCopy {'&CV4_REGISTER_MIPS_INT_A3 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T0
        zCopy {'&CV4_REGISTER_MIPS_INT_T0 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T1
        zCopy {'&CV4_REGISTER_MIPS_INT_T1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T2
        zCopy {'&CV4_REGISTER_MIPS_INT_T2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T3
        zCopy {'&CV4_REGISTER_MIPS_INT_T3 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T4
        zCopy {'&CV4_REGISTER_MIPS_INT_T4 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T5
        zCopy {'&CV4_REGISTER_MIPS_INT_T5 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T6
        zCopy {'&CV4_REGISTER_MIPS_INT_T6 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T7
        zCopy {'&CV4_REGISTER_MIPS_INT_T7 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S0
        zCopy {'&CV4_REGISTER_MIPS_INT_S0 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S1
        zCopy {'&CV4_REGISTER_MIPS_INT_S1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S2
        zCopy {'&CV4_REGISTER_MIPS_INT_S2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S3
        zCopy {'&CV4_REGISTER_MIPS_INT_S3 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S4
        zCopy {'&CV4_REGISTER_MIPS_INT_S4 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S5
        zCopy {'&CV4_REGISTER_MIPS_INT_S5 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S6
        zCopy {'&CV4_REGISTER_MIPS_INT_S6 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S7
        zCopy {'&CV4_REGISTER_MIPS_INT_S7 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T8
        zCopy {'&CV4_REGISTER_MIPS_INT_T8 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_T9
        zCopy {'&CV4_REGISTER_MIPS_INT_T9 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_KT0
        zCopy {'&CV4_REGISTER_MIPS_INT_KT0 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_KT1
        zCopy {'&CV4_REGISTER_MIPS_INT_KT1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_GP
        zCopy {'&CV4_REGISTER_MIPS_INT_GP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_SP
        zCopy {'&CV4_REGISTER_MIPS_INT_SP ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_S8
        zCopy {'&CV4_REGISTER_MIPS_INT_S8 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_RA
        zCopy {'&CV4_REGISTER_MIPS_INT_RA ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_LO
        zCopy {'&CV4_REGISTER_MIPS_INT_LO ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_INT_HI
        zCopy {'&CV4_REGISTER_MIPS_INT_HI ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FIR
        zCopy {'&CV4_REGISTER_MIPS_FIR ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_PSR
        zCopy {'&CV4_REGISTER_MIPS_PSR ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT0
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT0 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT1
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT1 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT2
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT2 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT3
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT3 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT4
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT4 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT5
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT5 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT6
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT6 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT7
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT7 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT8
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT8 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT9
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT9 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT10
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT10 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT11
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT11 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT12
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT12 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT13
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT13 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT14
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT14 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT15
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT15 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT16
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT16 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT17
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT17 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT18
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT18 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT19
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT19 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT20
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT20 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT21
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT21 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT22
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT22 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT23
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT23 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT24
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT24 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT25
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT25 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT26
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT26 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT27
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT27 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT28
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT28 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT29
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT29 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT30
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT30 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT31
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT31 ; Hex Value:  ', 0}
    .Else_If B$esi = &CV4_REGISTER_MIPS_FLOATING_POINT_STATUS_REG
        zCopy {'&CV4_REGISTER_MIPS_FLOATING_POINT_STATUS_REG ; Hex Value:  ', 0}
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeStructureItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.VarStr', 0}
        zCopy D@Text1
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'Coun'; From "Count" string
            xor eax eax
            lodsw | call WriteEax
        ..Else_If D$eax = 'Fiel'; From "Field" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'OldC'; From "OldCVType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax
        ..Else_If D$eax+13 = 'own1'; From "OldCVTypeUnknown1" string
            xor eax eax
            lodsw | call WriteEax
        ..Else_If D$eax+13 = 'own2'; From "OldCVTypeUnknown2" string
            xor eax eax
            lodsw | call WriteEax
         ..Else_If D$eax = 'Prop'; From "Property" string
            xor eax eax
            lodsw | call WriteEax
        ..Else_If D$eax = 'dLis'; From "dList" string
            xor eax eax
            lodsw | call WriteEax
        ..Else_If D$eax = 'vSha'; From "vShape" string
            xor eax eax
            lodsw | call WriteEax
        ..Else_If D$eax = 'Stru'; From "StructLen" string
            xor eax eax
            lodsw | call WriteEax


        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP
___________________________________________________

[CVLeafTypeStructureCount: 'Count', 0
 CVLeafTypeStructureField: 'Field', 0
 CVLeafTypeStructureOldCVType: 'OldCVType', 0
 CVLeafTypeStructureOldCVTypeUnkn1: 'OldCVTypeUnknown1', 0
 CVLeafTypeStructureOldCVTypeUnkn2: 'OldCVTypeUnknown2', 0
 CVLeafTypeStructureProperty: 'Property', 0
 CVLeafTypeStructuredList: 'dList', 0
 CVLeafTypeStructurevshape: 'vShape', 0
 CVLeafTypeStructuredStructLen: 'StructLen', 0]

Proc WriteRawDataDebugSContantLeafTypeStructure:
    Local @OldCodeView
    Uses eax, ecx

    mov D@OldCodeView &FALSE
    If W$esi-2 = &LF_STRUCTURE_CV3
        mov D@OldCodeView &TRUE
    End_If

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx

        call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructureCount, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructureField, {': W$ ', 0}
        If D@OldCodeView = &TRUE
            call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeUnionOldCVType, {': W$ ', 0}
            call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructureOldCVTypeUnkn1, {': W$ ', 0}
            call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructureOldCVTypeUnkn2, {': W$ ', 0}
        End_If
        call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructureProperty, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructuredList, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructurevshape, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeStructureItem CVLeafTypeStructuredStructLen, {': W$ ', 0}

        call WriteRawDataDebugSContantLeafTypeStructureItem CVCompileNameLenght, {': B$ ', 0}
        call WriteRawDataDebugSContantLeafTypeStructureItem CVCompileName, {': B$ ', 0}
        sub edi 2

    pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If


EndP
________________________________________________________________________________

[CVLeafTypeUnionCount: 'Count', 0
 CVLeafTypeUnionField: 'Field', 0
 CVLeafTypeUnionOldCVType: 'OldCVType', 0
 CVLeafTypeUnionProperty: 'Property', 0
 CVLeafTypeUnionUnionLen: 'UnionLength', 0]
;LF_UNION count @field property length
; WriteRawDataDebugSContantLeafTypeMember
Proc WriteRawDataDebugSContantLeafTypeUnion:
    Local @OldCodeView
    Uses eax, ecx


    mov D@OldCodeView &FALSE
    If W$esi-2 = &LF_UNION_CV3
        mov D@OldCodeView &TRUE
    End_If

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx

        call WriteRawDataDebugSContantLeafTypeUnionItem CVLeafTypeUnionCount, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeUnionItem CVLeafTypeUnionField, {': W$ ', 0}
        If D@OldCodeView = &TRUE
            call WriteRawDataDebugSContantLeafTypeUnionItem CVLeafTypeUnionOldCVType, {': W$ ', 0}
        End_If
        call WriteRawDataDebugSContantLeafTypeUnionItem CVLeafTypeUnionProperty, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeUnionItem CVLeafTypeUnionUnionLen, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeUnionItem CVCompileNameLenght, {': B$ ', 0}
        call WriteRawDataDebugSContantLeafTypeUnionItem CVCompileName, {': B$ ', 0}
        sub edi 2

    pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If


EndP
________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeUnionItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.Union.', 0}
        zCopy D@Text1
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'Coun'; From "Count" string
            xor eax eax
            lodsw | call WriteEax
        ..Else_If D$eax = 'Fiel'; From "Field" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax
        ..Else_If D$eax = 'OldC'; From "OldCVType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax
        ..Else_If D$eax = 'Prop'; From "Property" string
            xor eax eax
            lodsw | call WriteEax
        ..Else_If D$eax = 'Unio'; From "UnionLength" string
            xor eax eax
            lodsw | call WriteEax


        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP
________________________________________________________________________________


Proc WriteRawDataDebugSContantLeafTypePointerItem:
   Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.Pointer.', 0}
        zCopy D@Text1
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'OldC'; From "OldCVType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Type'; From "Type" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..End_If

        mov W$edi CRLF | add edi 2

EndP
_______________________________________________________________________

[CVLeafTypeModifierOldCVType: 'OldCVType', 0
 CVLeafTypeModifierAttribute: 'Attribute', 0
 CVLeafTypeModifierIndex: 'Index', 0]

Proc WriteRawDataDebugSContantLeafTypeModifier:
    Local @OldCodeView
    Uses eax, ecx

    mov D@OldCodeView &FALSE
    If W$esi-2 = &LF_MODIFIER_CV3
        mov D@OldCodeView &TRUE
    End_If


    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        If D@OldCodeView = &TRUE
            call WriteRawDataDebugSContantLeafTypeModifierItem CVLeafTypeModifierOldCVType, {': W$ ', 0}
        End_If
        call WriteRawDataDebugSContantLeafTypeModifierItem CVLeafTypeModifierAttribute, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeModifierItem CVLeafTypeModifierIndex, {': W$ ', 0}
        sub edi 2
    pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If


EndP
_________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeModifierItem:
   Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.Modifier.', 0}
        zCopy D@Text1
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'OldC'; From "OldCVType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            ; same as in WriteCVCompileFlag2Equates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Inde'; From "Type" string
            xor eax eax
            lodsw | call WriteEax

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

_________________________________________________________________________________


[CVLeafTypePointerOldCVType: 'OldCVType', 0
 CVLeafTypePointerAttribute: 'Attribute', 0
 CVLeafTypePointerType: 'Type', 0]

Proc WriteRawDataDebugSContantLeafTypePointer:
    Local @OldCodeView
    Uses eax, ecx

    mov D@OldCodeView &FALSE
    If W$esi-2 = &LF_POINTER_CV3
        mov D@OldCodeView &TRUE
    End_If


    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        If D@OldCodeView = &TRUE
            call WriteRawDataDebugSContantLeafTypePointerItem CVLeafTypePointerOldCVType, {': W$ ', 0}
        End_If
        call WriteRawDataDebugSContantLeafTypePointerItem CVLeafTypePointerAttribute, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypePointerItem CVLeafTypePointerType, {': W$ ', 0}
        sub edi 2
    pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If


EndP
________________________________________________________________________________

            ;WriteRawDataDebugSBPRel32
[CVLeafTypeArrayElemType: 'ElemType' , 0
 CVLeafTypeArrayIdxType: 'IdxType' , 0
 CVLeafTypeArrayLength: 'Length' , 0
 CVLeafTypeArrayNamelenght: 'NameLenght' , 0
 CVLeafTypeArrayName: 'Name' , 0]

Proc WriteRawDataDebugSContantLeafTypeArray:
    Uses eax, ecx


    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayElemType , {': W$ ', 0}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayIdxType , {': W$ ', 0}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayLength, {': W$ ', 0}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayNamelenght, {': B$ ', 0}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayName, {': B$ ', 0}
        sub edi 2
    pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP
________________________________________________________________________________
Proc WriteRawDataDebugSContantLeafTypeArrayItem:
    Argument @Text1, @Text2
    uses eax, ecx

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'Constant.LeafType.Array.', 0}
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1

        ..If D$eax = 'Elem' ; from "ElemType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'IdxT'; From "IdxType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Leng'; From "Lenght" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

________________________________________________________________________________
Proc WriteRawDataDebugSContantLeafTypeProcedureItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.Procedure.', 0}
        zCopy D@Text1
        zCopy D@Text2
    pop esi

        mov eax D@Text1

         ..If D$eax = 'rvTy'; From "rvType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Call'; From "Call" string
            call WriteCVLF_ProcCallConvTypeEquates
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Rese'; From "Reserved" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Parm'; From "Parms" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'ArgL'; From "ArgList" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

_________________________________________

[CVLeafTypeProcrvType: 'rvType', 0
 CVLeafTypeProcCall: 'Call', 0
 CVLeafTypeProcrvReserved: 'Reserved', 0
 CVLeafTypeProcrvParms: 'Parms', 0
 CVLeafTypeProcrvArgList: 'ArgList', 0]

Proc WriteRawDataDebugSContantLeafTypeProcedure:
    Uses eax, ecx


    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeProcedureItem CVLeafTypeProcrvType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeProcedureItem CVLeafTypeProcCall, {': B$ ', 0}
        call WriteRawDataDebugSContantLeafTypeProcedureItem CVLeafTypeProcrvReserved, {': B$ ', 0}
        call WriteRawDataDebugSContantLeafTypeProcedureItem CVLeafTypeProcrvParms, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeProcedureItem CVLeafTypeProcrvArgList, {': W$ ', 0}
        sub edi 2
    pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

[CVLeafTypeMFunctionRvType: 'RvType', 0
 CVLeafTypeMFunctionClass: 'Class', 0
 CVLeafTypeMFunctionThis: 'This', 0
 CVLeafTypeMFunctionCall: 'Call', 0
 CVLeafTypeMFunctionRes: 'Res', 0
 CVLeafTypeMFunctionParms: 'Parms', 0
 CVLeafTypeMFunctionOldCVType: 'OldCVType', 0
 CVLeafTypeMFunctionArglist: 'Arglist', 0
 CVLeafTypeMFunctionThisAdjust: 'ThisAdjust', 0]

Proc WriteRawDataDebugSContantLeafTypeMFunction:
    Local @OldCodeView
    Uses eax, ecx


    mov D@OldCodeView &FALSE
    If W$esi-2 = &LF_MFUNCTION_CV3
        mov D@OldCodeView &TRUE
    End_If

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx

        If D@OldCodeView = &TRUE
            call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionRvType, {': D$ ', 0}, &TRUE
            call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionClass, {': D$ ', 0}, &TRUE
            call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionThis, {': D$ ', 0}, &TRUE
        Else
            call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionRvType, {': W$ ', 0}, &FALSE
            call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionClass, {': W$ ', 0}, &FALSE
            call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionThis, {': W$ ', 0}, &FALSE

        End_If
        call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionCall, {': B$ ', 0}, &FALSE
        call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionRes, {': B$ ', 0}, &FALSE
        call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionParms, {': W$ ', 0}, &FALSE
        If D@OldCodeView = &TRUE
            call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionOldCVType, {': W$ ', 0}, &TRUE
        End_If
        call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionArglist, {': W$ ', 0}, &FALSE
        call WriteRawDataDebugSContantLeafTypeMFunctionItem CVLeafTypeMFunctionThisAdjust, {': D$ ', 0}, &FALSE
        sub edi 2

    pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP
________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeMFunctionItem:
    Argument @Text1, @Text2, @UseOldCVType
    uses eax, ecx, ebx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.MFunction.', 0}
        zCopy D@Text1
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'RvTy'; From "RvType" string
            call WriteCVBPRel32TypeEquates
            If D@UseOldCVType = &TRUE
                lodsd | call WriteEax
            Else
                xor eax eax
                lodsw | call WriteEax
            End_If
        ..Else_If D$eax = 'Clas'; From "Class" string
            call WriteCVBPRel32TypeEquates
            If D@UseOldCVType = &TRUE
                lodsd | call WriteEax
            Else
                xor eax eax
                lodsw | call WriteEax
            End_If
        ..Else_If D$eax = 'This'; From "This" string
            .If D$eax+4 = 'Adju'; From "ThisAdjust" string
                lodsd | call WriteEax
            .Else   ; From "This" string
                call WriteCVBPRel32TypeEquates
                If D@UseOldCVType = &TRUE
                    lodsd | call WriteEax
                Else
                    xor eax eax
                    lodsw | call WriteEax
                End_If
            .End_If
        ..Else_If D$eax = 'Call'; From "Call" string
            call WriteCVLF_ProcCallConvTypeEquates
            xor eax eax
            lodsb | call WriteEax
        ..Else_If W$eax = 'Re'; From "Res" string
            xor eax eax
            lodsb | call WriteEax
        ..Else_If D$eax = 'Parm'; From "Parms" string
            xor eax eax
            lodsw | call WriteEax
        ..Else_If D$eax = 'OldC'; From "OldCVType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax
        ..Else_If D$eax = 'Argl'; From "Arglist" string
            xor eax eax
            lodsw | call WriteEax
        ..End_If

        mov W$edi CRLF | add edi 2

EndP

________________________________________________________________________________

Proc WriteCVLF_ProcCallConvTypeEquates:
    Uses esi

    ..If W$esi = &CV4_CALL_NEAR_C
        zCopy {'&CV4_CALL_NEAR_C; Near C (arguments pushed right to left, caller pops arguments) - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_FAR_C
        zCopy {'&CV4_CALL_FAR_C; Far C - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_NEAR_PASCAL
        zCopy {'&CV4_CALL_NEAR_PASCAL; Near Pascal (arguments pushed left to right, callee pops arguments) - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_FAR_PASCAL
        zCopy {'&CV4_CALL_FAR_PASCAL; Far Pascal - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_NEAR_FASTCALL
        zCopy {'&CV4_CALL_NEAR_FASTCALL; Near fastcall - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_FAR_FASTCALL
        zCopy {'&CV4_CALL_FAR_FASTCALL; Far fastcall - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED6
        zCopy {'&CV4_CALL_RESERVED6; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_NEAR_STDCALL
        zCopy {'&CV4_CALL_NEAR_STDCALL; Near stdcall - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_FAR_STDCALL
        zCopy {'&CV4_CALL_FAR_STDCALL; Far stdcall - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_NEAR_SYSCALL
        zCopy {'&CV4_CALL_NEAR_SYSCALL; Near syscall - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_FAR_SYSCALL
        zCopy {'&CV4_CALL_FAR_SYSCALL; Far syscall - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_THIS_CALL
        zCopy {'&CV4_CALL_THIS_CALL; This call - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_MIPS_CALL
        zCopy {'&CV4_CALL_MIPS_CALL; MIPS call - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_GENERIC
        zCopy {'&CV4_CALL_GENERIC; Generic - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED14
        zCopy {'&CV4_CALL_RESERVED14; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED15
        zCopy {'&CV4_CALL_RESERVED15; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED16
        zCopy {'&CV4_CALL_RESERVED16; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED17
        zCopy {'&CV4_CALL_RESERVED17; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED18
        zCopy {'&CV4_CALL_RESERVED18; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED19
        zCopy {'&CV4_CALL_RESERVED19; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED20
        zCopy {'&CV4_CALL_RESERVED20; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED21
        zCopy {'&CV4_CALL_RESERVED21; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED22
        zCopy {'&CV4_CALL_RESERVED22; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED23
        zCopy {'&CV4_CALL_RESERVED23; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED24
        zCopy {'&CV4_CALL_RESERVED24; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED25
        zCopy {'&CV4_CALL_RESERVED25; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED26
        zCopy {'&CV4_CALL_RESERVED26; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED27
        zCopy {'&CV4_CALL_RESERVED27; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED28
        zCopy {'&CV4_CALL_RESERVED28; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED29
        zCopy {'&CV4_CALL_RESERVED29; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED30
        zCopy {'&CV4_CALL_RESERVED30; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED31
        zCopy {'&CV4_CALL_RESERVED31; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED32
        zCopy {'&CV4_CALL_RESERVED32; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED33
        zCopy {'&CV4_CALL_RESERVED33; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED34
        zCopy {'&CV4_CALL_RESERVED34; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED35
        zCopy {'&CV4_CALL_RESERVED35; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED36
        zCopy {'&CV4_CALL_RESERVED36; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED37
        zCopy {'&CV4_CALL_RESERVED37; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED38
        zCopy {'&CV4_CALL_RESERVED38; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED39
        zCopy {'&CV4_CALL_RESERVED39; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED40
        zCopy {'&CV4_CALL_RESERVED40; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED41
        zCopy {'&CV4_CALL_RESERVED41; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED42
        zCopy {'&CV4_CALL_RESERVED42; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED43
        zCopy {'&CV4_CALL_RESERVED43; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED44
        zCopy {'&CV4_CALL_RESERVED44; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED45
        zCopy {'&CV4_CALL_RESERVED45; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED46
        zCopy {'&CV4_CALL_RESERVED46; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED47
        zCopy {'&CV4_CALL_RESERVED47; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED48
        zCopy {'&CV4_CALL_RESERVED48; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED49
        zCopy {'&CV4_CALL_RESERVED49; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED50
        zCopy {'&CV4_CALL_RESERVED50; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED51
        zCopy {'&CV4_CALL_RESERVED51; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED52
        zCopy {'&CV4_CALL_RESERVED52; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED53
        zCopy {'&CV4_CALL_RESERVED53; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED54
        zCopy {'&CV4_CALL_RESERVED54; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED55
        zCopy {'&CV4_CALL_RESERVED55; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED56
        zCopy {'&CV4_CALL_RESERVED56; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED57
        zCopy {'&CV4_CALL_RESERVED57; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED58
        zCopy {'&CV4_CALL_RESERVED58; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED59
        zCopy {'&CV4_CALL_RESERVED59; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED60
        zCopy {'&CV4_CALL_RESERVED60; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED61
        zCopy {'&CV4_CALL_RESERVED61; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED62
        zCopy {'&CV4_CALL_RESERVED62; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED63
        zCopy {'&CV4_CALL_RESERVED63; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED64
        zCopy {'&CV4_CALL_RESERVED64; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED65
        zCopy {'&CV4_CALL_RESERVED65; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED66
        zCopy {'&CV4_CALL_RESERVED66; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED67
        zCopy {'&CV4_CALL_RESERVED67; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED68
        zCopy {'&CV4_CALL_RESERVED68; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED69
        zCopy {'&CV4_CALL_RESERVED69; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED70
        zCopy {'&CV4_CALL_RESERVED70; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED71
        zCopy {'&CV4_CALL_RESERVED71; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED72
        zCopy {'&CV4_CALL_RESERVED72; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED73
        zCopy {'&CV4_CALL_RESERVED73; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED74
        zCopy {'&CV4_CALL_RESERVED74; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED75
        zCopy {'&CV4_CALL_RESERVED75; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED76
        zCopy {'&CV4_CALL_RESERVED76; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED77
        zCopy {'&CV4_CALL_RESERVED77; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED78
        zCopy {'&CV4_CALL_RESERVED78; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED79
        zCopy {'&CV4_CALL_RESERVED79; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED80
        zCopy {'&CV4_CALL_RESERVED80; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED81
        zCopy {'&CV4_CALL_RESERVED81; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED82
        zCopy {'&CV4_CALL_RESERVED82; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED83
        zCopy {'&CV4_CALL_RESERVED83; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED84
        zCopy {'&CV4_CALL_RESERVED84; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED85
        zCopy {'&CV4_CALL_RESERVED85; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED86
        zCopy {'&CV4_CALL_RESERVED86; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED87
        zCopy {'&CV4_CALL_RESERVED87; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED88
        zCopy {'&CV4_CALL_RESERVED88; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED89
        zCopy {'&CV4_CALL_RESERVED89; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED90
        zCopy {'&CV4_CALL_RESERVED90; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED91
        zCopy {'&CV4_CALL_RESERVED91; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED92
        zCopy {'&CV4_CALL_RESERVED92; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED93
        zCopy {'&CV4_CALL_RESERVED93; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED94
        zCopy {'&CV4_CALL_RESERVED94; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED95
        zCopy {'&CV4_CALL_RESERVED95; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED96
        zCopy {'&CV4_CALL_RESERVED96; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED97
        zCopy {'&CV4_CALL_RESERVED97; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED98
        zCopy {'&CV4_CALL_RESERVED98; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED99
        zCopy {'&CV4_CALL_RESERVED99; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED100
        zCopy {'&CV4_CALL_RESERVED100; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED101
        zCopy {'&CV4_CALL_RESERVED101; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED102
        zCopy {'&CV4_CALL_RESERVED102; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED103
        zCopy {'&CV4_CALL_RESERVED103; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED104
        zCopy {'&CV4_CALL_RESERVED104; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED105
        zCopy {'&CV4_CALL_RESERVED105; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED106
        zCopy {'&CV4_CALL_RESERVED106; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED107
        zCopy {'&CV4_CALL_RESERVED107; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED108
        zCopy {'&CV4_CALL_RESERVED108; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED109
        zCopy {'&CV4_CALL_RESERVED109; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED110
        zCopy {'&CV4_CALL_RESERVED110; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED111
        zCopy {'&CV4_CALL_RESERVED111; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED112
        zCopy {'&CV4_CALL_RESERVED112; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED113
        zCopy {'&CV4_CALL_RESERVED113; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED114
        zCopy {'&CV4_CALL_RESERVED114; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED115
        zCopy {'&CV4_CALL_RESERVED115; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED116
        zCopy {'&CV4_CALL_RESERVED116; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED117
        zCopy {'&CV4_CALL_RESERVED117; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED118
        zCopy {'&CV4_CALL_RESERVED118; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED119
        zCopy {'&CV4_CALL_RESERVED119; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED120
        zCopy {'&CV4_CALL_RESERVED120; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED121
        zCopy {'&CV4_CALL_RESERVED121; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED122
        zCopy {'&CV4_CALL_RESERVED122; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED123
        zCopy {'&CV4_CALL_RESERVED123; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED124
        zCopy {'&CV4_CALL_RESERVED124; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED125
        zCopy {'&CV4_CALL_RESERVED125; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED126
        zCopy {'&CV4_CALL_RESERVED126; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED127
        zCopy {'&CV4_CALL_RESERVED127; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED128
        zCopy {'&CV4_CALL_RESERVED128; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED129
        zCopy {'&CV4_CALL_RESERVED129; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED130
        zCopy {'&CV4_CALL_RESERVED130; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED131
        zCopy {'&CV4_CALL_RESERVED131; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED132
        zCopy {'&CV4_CALL_RESERVED132; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED133
        zCopy {'&CV4_CALL_RESERVED133; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED134
        zCopy {'&CV4_CALL_RESERVED134; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED135
        zCopy {'&CV4_CALL_RESERVED135; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED136
        zCopy {'&CV4_CALL_RESERVED136; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED137
        zCopy {'&CV4_CALL_RESERVED137; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED138
        zCopy {'&CV4_CALL_RESERVED138; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED139
        zCopy {'&CV4_CALL_RESERVED139; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED140
        zCopy {'&CV4_CALL_RESERVED140; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED141
        zCopy {'&CV4_CALL_RESERVED141; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED142
        zCopy {'&CV4_CALL_RESERVED142; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED143
        zCopy {'&CV4_CALL_RESERVED143; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED144
        zCopy {'&CV4_CALL_RESERVED144; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED145
        zCopy {'&CV4_CALL_RESERVED145; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED146
        zCopy {'&CV4_CALL_RESERVED146; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED147
        zCopy {'&CV4_CALL_RESERVED147; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED148
        zCopy {'&CV4_CALL_RESERVED148; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED149
        zCopy {'&CV4_CALL_RESERVED149; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED150
        zCopy {'&CV4_CALL_RESERVED150; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED151
        zCopy {'&CV4_CALL_RESERVED151; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED152
        zCopy {'&CV4_CALL_RESERVED152; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED153
        zCopy {'&CV4_CALL_RESERVED153; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED154
        zCopy {'&CV4_CALL_RESERVED154; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED155
        zCopy {'&CV4_CALL_RESERVED155; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED156
        zCopy {'&CV4_CALL_RESERVED156; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED157
        zCopy {'&CV4_CALL_RESERVED157; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED158
        zCopy {'&CV4_CALL_RESERVED158; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED159
        zCopy {'&CV4_CALL_RESERVED159; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED160
        zCopy {'&CV4_CALL_RESERVED160; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED161
        zCopy {'&CV4_CALL_RESERVED161; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED162
        zCopy {'&CV4_CALL_RESERVED162; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED163
        zCopy {'&CV4_CALL_RESERVED163; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED164
        zCopy {'&CV4_CALL_RESERVED164; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED165
        zCopy {'&CV4_CALL_RESERVED165; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED166
        zCopy {'&CV4_CALL_RESERVED166; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED167
        zCopy {'&CV4_CALL_RESERVED167; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED168
        zCopy {'&CV4_CALL_RESERVED168; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED169
        zCopy {'&CV4_CALL_RESERVED169; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED170
        zCopy {'&CV4_CALL_RESERVED170; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED171
        zCopy {'&CV4_CALL_RESERVED171; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED172
        zCopy {'&CV4_CALL_RESERVED172; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED173
        zCopy {'&CV4_CALL_RESERVED173; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED174
        zCopy {'&CV4_CALL_RESERVED174; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED175
        zCopy {'&CV4_CALL_RESERVED175; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED176
        zCopy {'&CV4_CALL_RESERVED176; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED177
        zCopy {'&CV4_CALL_RESERVED177; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED178
        zCopy {'&CV4_CALL_RESERVED178; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED179
        zCopy {'&CV4_CALL_RESERVED179; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED180
        zCopy {'&CV4_CALL_RESERVED180; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED181
        zCopy {'&CV4_CALL_RESERVED181; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED182
        zCopy {'&CV4_CALL_RESERVED182; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED183
        zCopy {'&CV4_CALL_RESERVED183; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED184
        zCopy {'&CV4_CALL_RESERVED184; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED185
        zCopy {'&CV4_CALL_RESERVED185; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED186
        zCopy {'&CV4_CALL_RESERVED186; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED187
        zCopy {'&CV4_CALL_RESERVED187; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED188
        zCopy {'&CV4_CALL_RESERVED188; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED189
        zCopy {'&CV4_CALL_RESERVED189; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED190
        zCopy {'&CV4_CALL_RESERVED190; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED191
        zCopy {'&CV4_CALL_RESERVED191; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED192
        zCopy {'&CV4_CALL_RESERVED192; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED193
        zCopy {'&CV4_CALL_RESERVED193; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED194
        zCopy {'&CV4_CALL_RESERVED194; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED195
        zCopy {'&CV4_CALL_RESERVED195; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED196
        zCopy {'&CV4_CALL_RESERVED196; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED197
        zCopy {'&CV4_CALL_RESERVED197; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED198
        zCopy {'&CV4_CALL_RESERVED198; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED199
        zCopy {'&CV4_CALL_RESERVED199; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED200
        zCopy {'&CV4_CALL_RESERVED200; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED201
        zCopy {'&CV4_CALL_RESERVED201; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED202
        zCopy {'&CV4_CALL_RESERVED202; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED203
        zCopy {'&CV4_CALL_RESERVED203; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED204
        zCopy {'&CV4_CALL_RESERVED204; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED205
        zCopy {'&CV4_CALL_RESERVED205; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED206
        zCopy {'&CV4_CALL_RESERVED206; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED207
        zCopy {'&CV4_CALL_RESERVED207; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED208
        zCopy {'&CV4_CALL_RESERVED208; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED209
        zCopy {'&CV4_CALL_RESERVED209; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED210
        zCopy {'&CV4_CALL_RESERVED210; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED211
        zCopy {'&CV4_CALL_RESERVED211; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED212
        zCopy {'&CV4_CALL_RESERVED212; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED213
        zCopy {'&CV4_CALL_RESERVED213; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED214
        zCopy {'&CV4_CALL_RESERVED214; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED215
        zCopy {'&CV4_CALL_RESERVED215; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED216
        zCopy {'&CV4_CALL_RESERVED216; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED217
        zCopy {'&CV4_CALL_RESERVED217; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED218
        zCopy {'&CV4_CALL_RESERVED218; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED219
        zCopy {'&CV4_CALL_RESERVED219; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED220
        zCopy {'&CV4_CALL_RESERVED220; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED221
        zCopy {'&CV4_CALL_RESERVED221; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED222
        zCopy {'&CV4_CALL_RESERVED222; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED223
        zCopy {'&CV4_CALL_RESERVED223; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED224
        zCopy {'&CV4_CALL_RESERVED224; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED225
        zCopy {'&CV4_CALL_RESERVED225; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED226
        zCopy {'&CV4_CALL_RESERVED226; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED227
        zCopy {'&CV4_CALL_RESERVED227; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED228
        zCopy {'&CV4_CALL_RESERVED228; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED229
        zCopy {'&CV4_CALL_RESERVED229; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED230
        zCopy {'&CV4_CALL_RESERVED230; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED231
        zCopy {'&CV4_CALL_RESERVED231; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED232
        zCopy {'&CV4_CALL_RESERVED232; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED233
        zCopy {'&CV4_CALL_RESERVED233; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED234
        zCopy {'&CV4_CALL_RESERVED234; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED235
        zCopy {'&CV4_CALL_RESERVED235; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED236
        zCopy {'&CV4_CALL_RESERVED236; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED237
        zCopy {'&CV4_CALL_RESERVED237; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED238
        zCopy {'&CV4_CALL_RESERVED238; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED239
        zCopy {'&CV4_CALL_RESERVED239; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED240
        zCopy {'&CV4_CALL_RESERVED240; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED241
        zCopy {'&CV4_CALL_RESERVED241; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED242
        zCopy {'&CV4_CALL_RESERVED242; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED243
        zCopy {'&CV4_CALL_RESERVED243; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED244
        zCopy {'&CV4_CALL_RESERVED244; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED245
        zCopy {'&CV4_CALL_RESERVED245; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED246
        zCopy {'&CV4_CALL_RESERVED246; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED247
        zCopy {'&CV4_CALL_RESERVED247; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED248
        zCopy {'&CV4_CALL_RESERVED248; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED249
        zCopy {'&CV4_CALL_RESERVED249; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED250
        zCopy {'&CV4_CALL_RESERVED250; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED251
        zCopy {'&CV4_CALL_RESERVED251; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED252
        zCopy {'&CV4_CALL_RESERVED252; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED253
        zCopy {'&CV4_CALL_RESERVED253; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED254
        zCopy {'&CV4_CALL_RESERVED254; Reserved - Hex Value:  ', 0}
    ..Else_If W$esi = &CV4_CALL_RESERVED255
        zCopy {'&CV4_CALL_RESERVED255; Reserved - Hex Value:  ', 0}
    ..End_if

EndP
________________________________________________________________________________


Proc WriteRawDataDebugSContantLeafTypeArgListItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.ArgList', 0}
        zCopy D@Text1
        If D$ArgListIndexCount <> 0
            ZCopy LeafTypeArgListIndice
        End_If
        zCopy D@Text2
    pop esi

    call WriteCVBPRel32TypeEquates
    xor eax eax
    lodsw | call WriteEax
    mov W$edi CRLF | add edi 2

EndP

_________________________________________________

[CVLeafTypeArgListIndice: 'Indice', 0
CVLeafTypeArgListOldCVType: 'OldCVType', 0]


;    mov D$LeafTypeArgListIndice '0000', D$LeafTypeArgListIndice+4 '01'
;            call IncrementLeafTypeArgListIndex

[LeafTypeArgListIndice: '000001', 0]

IncrementLeafTypeArgListIndex:
    lea ebx D$LeafTypeArgListIndice+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret

[ArgListIndexCount: D$ 0]

Proc WriteRawDataDebugSContantLeafTypeArgList:
    Local @OldCodeView
    Uses eax, ecx, ebx

    mov D@OldCodeView &FALSE
    If W$esi-2 = &LF_ARGLIST_CV3
        mov D@OldCodeView &TRUE
    End_If

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        push ecx
        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'Constant.LeafType.ArgList.', 0}
            zCopy {'ArgCount: W$ ', 0}
        pop esi
        xor eax eax
        lodsw | call WriteEax
        mov W$edi CRLF | add edi 2
        pop ecx

        movzx ecx W$esi-2

    mov D$ArgListIndexCount ecx
    mov D$LeafTypeArgListIndice '0000', D$LeafTypeArgListIndice+4 '01'

    .If ecx <> 0 ; if the amount of bytes is 0 jmp over

        L0:
            call WriteRawDataDebugSContantLeafTypeArgListItem CVLeafTypeArgListIndice, {': W$ ', 0}
            If D@OldCodeView = &TRUE
                call WriteRawDataDebugSContantLeafTypeArgListItem CVLeafTypeArgListOldCVType, {': W$ ', 0}
            End_If

            call IncrementLeafTypeArgListIndex
        Loop L0<

    .End_If

    pop ebx

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP


________________________________________________________________________________

[NestedLeafType: D$ 0]

Proc WriteRawDataDebugSContantLeafTypeFieldList:
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx
    ;mov D@EndAddr ebx


    mov D$NestedLeafType &TRUE
    mov D$LeafTypeArrayObjIndice '0000', D$LeafTypeArrayObjIndice+4 '01'

    .Do

        push esi
            mov W$edi CRLF | add edi 2
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'Constant.LeafType.Descriptor', 0}
        pop esi

        ; from here we must insert a Buffer flag saying it is nested to we use the array indexs
;            push ebx

        ..If W$esi = &LF_BCLASS
            push esi | zCopy {'.BClass.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_BCLASS', 0}
            call WriteRawDataDebugSContantLeafTypeBClass &FALSE

        ..Else_If W$esi = &LF_VBCLASS
            push esi | zCopy {'.VBClass.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_VBCLASS', 0}
            call WriteRawDataDebugSContantLeafTypeVBClass &FALSE

        ..Else_If W$esi = &LF_IVBCLASS
            push esi | zCopy {'.IVBClass.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_IVBCLASS', 0}
            call WriteRawDataDebugSContantLeafTypeIVBClass &FALSE

        ..Else_If W$esi = &LF_ENUMERATE
            push esi | zCopy {'.Enumerate.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_ENUMERATE', 0}
            call WriteRawDataDebugSContantLeafTypeEnumerate &FALSE

        ..Else_If W$esi = &LF_FRIENDFCN
            push esi | zCopy {'.FriendFcn.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_FRIENDFCN', 0}
            call WriteRawDataDebugSContantLeafTypeFriendFcn &FALSE

        ..Else_If W$esi = &LF_INDEX
            push esi | zCopy {'.Index.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_INDEX', 0}
            call WriteRawDataDebugSContantLeafTypeIndex &FALSE

        ..Else_If W$esi = &LF_MEMBER;, W$esi = 01405
            ;WriteRawDataDebugSRegister
            ;push ebx
            push esi | zCopy {'.Member.Arr', 0} | pop esi
                If W$esi = &LF_MEMBER
                    call WriteRawDataDebugSContantLeafTypeEquate {'&LF_MEMBER', 0}
                Else
                    ;call WriteRawDataDebugSContantLeafTypeEquate {'&LF_MEMBER_CV3', 0}
                End_If
                call WriteRawDataDebugSContantLeafTypeMember &FALSE
            ;pop ebx
        ..Else_If W$esi = &LF_STMEMBER
            push esi | zCopy {'.STMember.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_STMEMBER', 0}
            call WriteRawDataDebugSContantLeafTypeSTMember &FALSE

        ..Else_If W$esi = &LF_METHOD
            push esi | zCopy {'.Method.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_METHOD', 0}
            call WriteRawDataDebugSContantLeafTypeMethod &FALSE

        ..Else_If W$esi = &LF_NESTTYPE
            push esi | zCopy {'.NestType.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_NESTTYPE', 0}
            call WriteRawDataDebugSContantLeafTypeNestType &FALSE

        ..Else_If W$esi = &LF_VFUNCTAB
            push esi | zCopy {'.VFuncTab.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_VFUNCTAB', 0}
            call WriteRawDataDebugSContantLeafTypeVFuncTab &FALSE

        ..Else_If W$esi = &LF_FRIENDCLS
            push esi | zCopy {'.FriendCls.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_FRIENDCLS', 0}
            call WriteRawDataDebugSContantLeafTypeFriendCls &FALSE

        ..Else_If W$esi = &LF_ONEMETHOD
            push esi | zCopy {'.OneMethod.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_ONEMETHOD', 0}
            call WriteRawDataDebugSContantLeafTypeOneMethod &FALSE

        ..Else_If W$esi = &LF_VFUNCOFF
            push esi | zCopy {'.VFuncOffset.Arr', 0} | pop esi
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_VFUNCOFF', 0}
            call WriteRawDataDebugSContantLeafTypeVFuncOffset &FALSE

        ..End_If
;            push ebx
            .If_And B$esi > &LF_PAD0, B$esi =< &LF_PAD15

                movzx ecx B$esi
                sub ecx 0F0
                mov W$edi CRLF | add edi 2
                call WriteCVdataTitle

                    mov edx 0
                    xor eax eax

                L0:

                    movzx eax B$esi
                    push ebx | call WriteEax | pop ebx

                    mov W$edi ', ' | add edi 2 | inc esi
                    inc edx
                    If edx > 15
                        mov W$edi CRLF | add edi 2 | mov edx 0
                        mov D$edi '    ', D$edi+4 '    ' | add edi 8
                    End_If
                Loop L0<
                sub edi 2
                dec edi
                mov W$edi+1 CRLF | add edi 2
                inc edi

            .End_If

            call IncrementLeafTypeArrayIndex
;            pop ebx
            ;pop ebx
        .Loop_Until esi = ebx
;L2:
    mov D$NestedLeafType &FALSE
    mov W$edi CRLF | add edi 2
;    sub edi 2
 ;   dec edi
  ;  mov W$edi+1 CRLF | add edi 2
   ; inc edi

EndP


________________________________________________________________________________

[LeafTypeArrayObjIndice: '000001', 0]

Proc IncrementLeafTypeArrayIndex:

    pushad

    lea ebx D$LeafTypeArrayObjIndice+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While

    popad

EndP
____________________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeBClassItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.BClass.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'Type'; From "Type" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Offs'; From "Offset" string
            xor eax eax
            lodsw | call WriteEax

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeBClassType: 'Type', 0
 CVLeafTypeVFuncTypeBClassAttribute: 'Attribute', 0
 CVLeafTypeVFuncTypeBClassOffset: 'Offset', 0]

Proc WriteRawDataDebugSContantLeafTypeBClass:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeBClassItem CVLeafTypeVFuncTypeBClassType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeBClassItem CVLeafTypeVFuncTypeBClassAttribute, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeBClassItem CVLeafTypeVFuncTypeBClassOffset, {': W$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeVBClassItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.VBClass.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'Inde'; From "Index" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'bTyp'; From "bType" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'VbTy'; From "VbType" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Vbpo'; From "Vbpoff" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Vbof'; From "Vboff" string
            xor eax eax
            lodsw | call WriteEax

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeVBClassType: 'Index', 0
 CVLeafTypeVFuncTypeVBClassbType: 'bType', 0
 CVLeafTypeVFuncTypeVBClassvbType: 'VbType', 0
 CVLeafTypeVFuncTypeVBClassAttribute: 'Attribute', 0
 CVLeafTypeVFuncTypeVBClassvbpoff: 'Vbpoff', 0
 CVLeafTypeVFuncTypeVBClassvboff: 'Vboff', 0]

Proc WriteRawDataDebugSContantLeafTypeVBClass:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeVBClassItem CVLeafTypeVFuncTypeVBClassType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeVBClassItem CVLeafTypeVFuncTypeVBClassbType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeVBClassItem CVLeafTypeVFuncTypeVBClassvbType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeVBClassItem CVLeafTypeVFuncTypeVBClassAttribute, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeVBClassItem CVLeafTypeVFuncTypeVBClassvbpoff, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeVBClassItem CVLeafTypeVFuncTypeVBClassvboff, {': W$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeIVBClassItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.IVBClass.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'Inde'; From "Index" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'bTyp'; From "bType" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'VbTy'; From "VbType" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Vbpo'; From "Vbpoff" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Vbof'; From "Vboff" string
            xor eax eax
            lodsw | call WriteEax

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeIVBClassType: 'Index', 0
 CVLeafTypeVFuncTypeIVBClassbType: 'bType', 0
 CVLeafTypeVFuncTypeIVBClassvbType: 'VbType', 0
 CVLeafTypeVFuncTypeIVBClassAttribute: 'Attribute', 0
 CVLeafTypeVFuncTypeIVBClassvbpoff: 'Vbpoff', 0
 CVLeafTypeVFuncTypeIVBClassvboff: 'Vboff', 0]


Proc WriteRawDataDebugSContantLeafTypeIVBClass:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeIVBClassItem CVLeafTypeVFuncTypeIVBClassType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeIVBClassItem CVLeafTypeVFuncTypeIVBClassbType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeIVBClassItem CVLeafTypeVFuncTypeIVBClassvbType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeIVBClassItem CVLeafTypeVFuncTypeIVBClassAttribute, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeIVBClassItem CVLeafTypeVFuncTypeIVBClassvbpoff, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeIVBClassItem CVLeafTypeVFuncTypeIVBClassvboff, {': W$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeEnumerateItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.Enumerate.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1


        ..If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Valu'; From "Value" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeEnumerateAttribute: 'Attribute', 0
 CVLeafTypeVFuncTypeEnumerateValue: 'Value', 0
 CVLeafTypeVFuncTypeEnumerateNameLenght: 'NameLenght', 0
 CVLeafTypeVFuncTypeEnumerateName: 'Name', 0]

Proc WriteRawDataDebugSContantLeafTypeEnumerate:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeEnumerateItem CVLeafTypeVFuncTypeEnumerateAttribute, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeEnumerateItem CVLeafTypeVFuncTypeEnumerateValue, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeEnumerateItem CVLeafTypeVFuncTypeEnumerateNameLenght, {': B$ ', 0}
        call WriteRawDataDebugSContantLeafTypeEnumerateItem CVLeafTypeVFuncTypeEnumerateName, {': B$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeFriendFcnItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.FriendFcn.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'Type'; From "Type" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeFriendFcnType: 'Type', 0
 CVLeafTypeVFuncTypeFriendFcnNameLenght: 'NameLenght', 0
 CVLeafTypeVFuncTypeFriendFcnName: 'Name', 0]

Proc WriteRawDataDebugSContantLeafTypeFriendFcn:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeFriendFcnItem CVLeafTypeVFuncTypeFriendFcnType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeFriendFcnItem CVLeafTypeVFuncTypeFriendFcnNameLenght, {': B$ ', 0}
        call WriteRawDataDebugSContantLeafTypeFriendFcnItem CVLeafTypeVFuncTypeFriendFcnName, {': B$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeIndexItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.Type.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        xor eax eax
        lodsw | call WriteEax

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeTypeIndex: 'Index', 0]

Proc WriteRawDataDebugSContantLeafTypeIndex:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeIndexItem CVLeafTypeVFuncTypeTypeIndex, {': W$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeMemberItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.Member.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'OldC' ; from "OldCVType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Type'; From "Type" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Offs'; From "Offset" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeMemberOldCVType: 'OldCVType', 0
 CVLeafTypeVFuncTypeMemberType: 'Type', 0
 CVLeafTypeVFuncTypeMemberAttribute: 'Attribute', 0
 CVLeafTypeVFuncTypeMemberOffset: 'Offset', 0
 CVLeafTypeVFuncTypeMemberNameLenght: 'NameLenght', 0
 CVLeafTypeVFuncTypeMemberName: 'Name', 0]
;WriteRawDataDebugSRegister
Proc WriteRawDataDebugSContantLeafTypeMember:
    Arguments @Nested
    Local @OldCodeView
    Uses eax, ecx, ebx

    mov D@OldCodeView &FALSE
    If W$esi-2 = 01405
        mov D@OldCodeView &TRUE
    End_If
    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        If D@OldCodeView = &TRUE
            Call WriteRawDataDebugSContantLeafTypeMemberItem CVLeafTypeVFuncTypeMemberOldCVType , {': W$ ', 0}
        End_If
        call WriteRawDataDebugSContantLeafTypeMemberItem CVLeafTypeVFuncTypeMemberType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeMemberItem CVLeafTypeVFuncTypeMemberAttribute, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeMemberItem CVLeafTypeVFuncTypeMemberOffset, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeMemberItem CVLeafTypeVFuncTypeMemberNameLenght, {': B$ ', 0}
        call WriteRawDataDebugSContantLeafTypeMemberItem CVLeafTypeVFuncTypeMemberName, {': B$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeSTMemberItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.StMember.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'Type'; From "Type" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeStMemberType: 'Type', 0
 CVLeafTypeVFuncTypeStMemberAttribute: 'Attribute', 0
 CVLeafTypeVFuncTypeStMemberNameLenght: 'NameLenght', 0
 CVLeafTypeVFuncTypeStMemberName: 'Name', 0]

Proc WriteRawDataDebugSContantLeafTypeSTMember:
    Arguments @Nested
    Uses eax, ecx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeSTMemberItem CVLeafTypeVFuncTypeStMemberType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeSTMemberItem CVLeafTypeVFuncTypeStMemberAttribute, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeSTMemberItem CVLeafTypeVFuncTypeStMemberNameLenght, {': B$ ', 0}
        call WriteRawDataDebugSContantLeafTypeSTMemberItem CVLeafTypeVFuncTypeStMemberName, {': B$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeMethodItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.Method.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'Coun'; From "Count" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'mLis'; From "mList" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeMethodCount: 'Count', 0
 CVLeafTypeVFuncTypeMethodmList: 'mList', 0
 CVLeafTypeVFuncTypeMethodNameLenght: 'NameLenght', 0
 CVLeafTypeVFuncTypeMethodTypeName: 'Name', 0]

Proc WriteRawDataDebugSContantLeafTypeMethod:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeMethodItem CVLeafTypeVFuncTypeMethodCount, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeMethodItem CVLeafTypeVFuncTypeMethodmList, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeMethodItem CVLeafTypeVFuncTypeMethodNameLenght, {': B$ ', 0}
        call WriteRawDataDebugSContantLeafTypeMethodItem CVLeafTypeVFuncTypeMethodTypeName, {': B$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP
_________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeNestTypeItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.NestedType.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'Inde'; From "Index" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeNestTypeIndex: 'Index', 0
 CVLeafTypeVFuncTypeNestTypeNameLenght: 'NameLenght', 0
 CVLeafTypeVFuncTypeNestTypeName: 'Name', 0]

Proc WriteRawDataDebugSContantLeafTypeNestType:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeNestTypeItem CVLeafTypeVFuncTypeNestTypeIndex, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeNestTypeItem CVLeafTypeVFuncTypeNestTypeNameLenght, {': B$ ', 0}
        call WriteRawDataDebugSContantLeafTypeNestTypeItem CVLeafTypeVFuncTypeNestTypeName, {': B$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP
_________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeVFuncTabItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.VFuncTab.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        xor eax eax
        lodsw | call WriteEax

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeVFuncTabType: 'Type', 0]

Proc WriteRawDataDebugSContantLeafTypeVFuncTab:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeVFuncTabItem CVLeafTypeVFuncTypeVFuncTabType, {': W$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeFriendClsItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.FriendClass.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        xor eax eax
        lodsw | call WriteEax

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeFriendClsType: 'Type', 0]

Proc WriteRawDataDebugSContantLeafTypeFriendCls:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeFriendClsItem CVLeafTypeVFuncTypeFriendClsType, {': W$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

__________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeOneMethodItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.OneMethod.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax = 'Attr'; From "Attribute" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Type'; From "Type" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'vBas'; From "vBaseOffset" string
            lodsd | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncTypeOneMethodattribute: 'Attribute', 0
 CVLeafTypeVFuncTypeOneMethodType: 'Type', 0
 CVLeafTypeVFuncTypeOneMethodvBaseOffset: 'vBaseOffset', 0
 CVLeafTypeVFuncTypeOneMethodNameLenght: 'NameLenght', 0
 CVLeafTypeVFuncTypeOneMethodName: 'Name', 0]

Proc WriteRawDataDebugSContantLeafTypeOneMethod:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeOneMethodItem CVLeafTypeVFuncTypeOneMethodattribute, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeOneMethodItem CVLeafTypeVFuncTypeOneMethodType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeOneMethodItem CVLeafTypeVFuncTypeOneMethodvBaseOffset, {': D$ ', 0}
        call WriteRawDataDebugSContantLeafTypeOneMethodItem CVLeafTypeVFuncTypeOneMethodNameLenght, {': B$ ', 0}
        call WriteRawDataDebugSContantLeafTypeOneMethodItem CVLeafTypeVFuncTypeOneMethodName, {': B$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeVFuncOffsetItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.VFunc.', 0}
        zCopy D@Text1
        If D$NestedLeafType = &TRUE
            zCopy {'.Arr', 0}
            zCopy LeafTypeArrayObjIndice
        End_If
        zCopy D@Text2
    pop esi

        mov eax D@Text1

         ..If D$eax = 'Type'; From "Type" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Offs'; From "Offset" string
            lodsd | call WriteEax

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

______________________________________________________

[CVLeafTypeVFuncType: 'Type', 0
 CVLeafTypeVFuncOffset: 'Offset', 0]

Proc WriteRawDataDebugSContantLeafTypeVFuncOffset:
    Arguments @Nested
    Uses eax, ecx, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx
        call WriteRawDataDebugSContantLeafTypeVFuncOffsetItem CVLeafTypeVFuncType, {': W$ ', 0}
        call WriteRawDataDebugSContantLeafTypeVFuncOffsetItem CVLeafTypeVFuncOffset, {': D$ ', 0}
        sub edi 2
    pop ebx

    ; Is this structure inside another one ? Yes, exit. FALSE = Nested. TRUE = not nested
    ; This is because the leaf types:
    ; &LF_BCLASS; &LF_VBCLASS; &LF_IVBCLASS; &LF_ENUMERATE; &LF_FRIENDFCN; &LF_INDEX
    ; &LF_MEMBER; &LF_STMEMBER; &LF_METHOD; &LF_NESTTYPE; &LF_VFUNCTAB; &LF_ONEMETHOD ; &LF_VFUNCOFF
    ; May exists inside the &LF_FIELDLIST Structure like an array of structures.
    ; So we need to jmp over the lenght check if we have nested structures like this.

    On D@Nested = &FALSE, ExitP

    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeComplexNumber:
    Argument @Text, @Size
    Uses eax, ecx

    mov ebx esi
    mov ecx D@Size
    add ebx ecx

    .If esi <> ebx
        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'Constant.LeafType.', 0}
            zCopy D@Text
            zCopy {': B$ ', 0}
        pop esi

        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

        sub edi 2
        dec edi
        mov W$edi+1 CRLF | add edi 2
        pop ecx
        inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP
________________________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeVarStrItem:
    Argument @Text1, @Text2
    uses eax, ecx

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'Constant.LeafType.VarStr', 0}
        zCopy D@Text1
        zCopy D@Text2
    pop esi

        mov eax D@Text1

        ..If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx W$esi-2
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

______________________________________________

Proc WriteRawDataDebugSContantLeafTypeVarStr:
    Uses eax, ecx

    call WriteRawDataDebugSContantLeafTypeVarStrItem CVCompileNameLenght, {': W$ ', 0}
    call WriteRawDataDebugSContantLeafTypeVarStrItem CVCompileName, {': B$ ', 0}
    sub edi 2

EndP
______________________________________________

Proc WriteRawDataDebugSContantLeafTypeEquate:
    Argument @Text
    uses eax, ecx, ebx


    If D$NestedLeafType = &TRUE
        push esi | zCopy LeafTypeArrayObjIndice | pop esi
    End_If
    push esi
        zCopy {': W$ ', 0}
        zCopy D@Text
        zCopy {' ; Hex Value:  ', 0}
    pop esi
    xor eax eax
    lodsw | call WriteEax
    mov W$edi CRLF | add edi 2

EndP

___________________________________________

[LeafTypeError: D$ &TRUE]

; The PDebug section is nothing but a Type.
; Note: Check the file SDKUTIL from lcc library

Proc WriteRawDataDebugSContantLeafTypeItem:
    Uses eax, ecx

    mov D$LeafTypeError &TRUE ; In Any case, the default is True, meaning that we have no errors.

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'Constant.LeafType', 0}
        pop esi

    ; 1st we need to identify the Undefined Leaf Types. Accordying to the documentation, we have:

    ; a) No LF_... index can have a value of 0x0000.
    ; b) Because of the method used to maintain natural alignment in complex lists, no leaf index can
    ;    have a value greater than or equal to 0xf000.
    ; c) Also, no leaf index can have a value such that the least significant 8 bits of the value
    ;    is greater than or equal to 0xf0.

    ...If W$esi = 0
        jmp L0>
    ...Else_If W$esi >= 0F000
L0:     push esi | zCopy {': W$ ', 0} | pop esi
        xor eax eax
        lodsw | call WriteEax
        zCopy {' ; No Defined Type', 0}

        mov D$LeafTypeError &FALSE ; Set the error case

    ...Else_If B$esi >= 0F0

        push esi | zCopy {'.Padding: B$ ', 0} | pop esi

        push esi

        .If B$esi = &LF_PAD0
            zCopy {'&LF_PAD0 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD1
            zCopy {'&LF_PAD1 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD2
            zCopy {'&LF_PAD2 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD3
            zCopy {'&LF_PAD3 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD4
            zCopy {'&LF_PAD4 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD5
            zCopy {'&LF_PAD5 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD6
            zCopy {'&LF_PAD6 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD7
            zCopy {'&LF_PAD7 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD8
            zCopy {'&LF_PAD8 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD9
            zCopy {'&LF_PAD9 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD10
            zCopy {'&LF_PAD10 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD11
            zCopy {'&LF_PAD11 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD12
            zCopy {'&LF_PAD12 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD13
            zCopy {'&LF_PAD13 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD14
            zCopy {'&LF_PAD14 ; Hex Value:  ', 0}
        .Else_If B$esi = &LF_PAD15
            zCopy {'&LF_PAD15 ; Hex Value:  ', 0}
        .End_If

        pop esi

        xor eax eax
        lodsb | call WriteEax

        push esi
            zCopy {' - No Defined Type', 0}
            mov W$edi CRLF | add edi 2
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'.Undefined: B$ ', 0}
        pop esi

        xor eax eax
        lodsb | call WriteEax
        zCopy {' ; No Defined Type', 0}

        mov D$LeafTypeError &FALSE ; Set the error case

    ; 2nd We must now identify the known defined Types.

    ...Else

        ..If_Or W$esi = &LF_MODIFIER, W$esi = &LF_MODIFIER_CV3
            If W$esi = &LF_MODIFIER
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_MODIFIER', 0}
            Else
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_MODIFIER_CV3', 0}
            End_If
            call WriteRawDataDebugSContantLeafTypeModifier

        ..Else_If_Or W$esi = &LF_POINTER, W$esi = &LF_POINTER_CV3 ; see sdkutil.lib to we handle the equates for the different Bits (A true hell)
            If W$esi = &LF_POINTER
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_POINTER', 0}
            Else
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_POINTER_CV3', 0}
            End_If
            call WriteRawDataDebugSContantLeafTypePointer

        ..Else_If W$esi = &LF_ARRAY
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_ARRAY', 0}
            call WriteRawDataDebugSContantLeafTypeArray

        ..Else_If W$esi = &LF_CLASS
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_CLASS', 0}
            call WriteRawDataDebugSContantLeafTypeStructure

        ..Else_If_Or W$esi = &LF_STRUCTURE, W$esi = &LF_STRUCTURE_CV3
            If W$esi = &LF_STRUCTURE
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_STRUCTURE', 0}
            Else
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_STRUCTURE_CV3', 0}
            End_If
            call WriteRawDataDebugSContantLeafTypeStructure

        ..Else_If_Or W$esi = &LF_UNION, W$esi = &LF_UNION_CV3
            If W$esi = &LF_UNION
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_UNION', 0}
            Else
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_UNION_CV3', 0}
            End_If
            call WriteRawDataDebugSContantLeafTypeUnion

        ..Else_If W$esi = &LF_ENUM
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_ENUM', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_PROCEDURE
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_PROCEDURE', 0}
            call WriteRawDataDebugSContantLeafTypeProcedure

        ..Else_If_Or W$esi = &LF_MFUNCTION, W$esi = &LF_MFUNCTION_CV3
            If W$esi = &LF_MFUNCTION
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_MFUNCTION', 0}
            Else
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_MFUNCTION_CV3', 0}
            End_If
                call WriteRawDataDebugSContantLeafTypeMFunction

        ..Else_If W$esi = &LF_VTSHAPE
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_VTSHAPE', 0}
            sub esi 2
            jmp L0>>
            ; Note to Guga. The error in sdkutil is here. Missing this parse

        ..Else_If W$esi = &LF_COBOL0
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_COBOL0', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_COBOL1
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_COBOL1', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_BARRAY
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_BARRAY', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_LABEL
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_LABEL', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_NULL
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_NULL', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_NOTTRAN
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_NOTTRAN', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_DIMARRAY
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_DIMARRAY', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_VFTPATH
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_VFTPATH', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_PRECOMP
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_PRECOMP', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_ENDPRECOMP
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_ENDPRECOMP', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_OEM
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_OEM', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_RESERVED
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_RESERVED', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_SKIP
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_SKIP', 0}
            jmp L0>>

        ..Else_If_Or W$esi = &LF_ARGLIST, W$esi = &LF_ARGLIST_CV3
            If W$esi = &LF_ARGLIST
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_ARGLIST', 0}
            Else
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_ARGLIST_CV3', 0}
            End_If
            call WriteRawDataDebugSContantLeafTypeArgList

        ..Else_If W$esi = &LF_DEFARG
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_DEFARG', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_LIST
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_LIST', 0}
            jmp L0>>

        ..Else_If_Or W$esi = &LF_FIELDLIST;, W$esi = 01203
        ;WriteRawDataDebugSRegister
            If W$esi = &LF_FIELDLIST
                call WriteRawDataDebugSContantLeafTypeEquate {'&LF_FIELDLIST', 0}
            Else
                ;call WriteRawDataDebugSContantLeafTypeEquate {'&LF_FIELDLIST_CV3', 0}
            End_If
            call WriteRawDataDebugSContantLeafTypeFieldList

        ..Else_If W$esi = &LF_DERIVED
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_DERIVED', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_BITFIELD
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_BITFIELD', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_METHODLIST
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_METHODLIST', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_DIMCONU
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_DIMCONU', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_DIMCONLU
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_DIMCONLU', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_DIMVARU
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_DIMVARU', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_DIMVARLU
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_DIMVARLU', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_REFSYM
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_REFSYM', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_BCLASS
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_BCLASS', 0}
            call WriteRawDataDebugSContantLeafTypeBClass &FALSE

        ..Else_If W$esi = &LF_VBCLASS
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_VBCLASS', 0}
            call WriteRawDataDebugSContantLeafTypeVBClass &FALSE

        ..Else_If W$esi = &LF_IVBCLASS
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_IVBCLASS', 0}
            call WriteRawDataDebugSContantLeafTypeIVBClass &FALSE

        ..Else_If W$esi = &LF_ENUMERATE
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_ENUMERATE', 0}
            call WriteRawDataDebugSContantLeafTypeEnumerate &FALSE

        ..Else_If W$esi = &LF_FRIENDFCN
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_FRIENDFCN', 0}
            call WriteRawDataDebugSContantLeafTypeFriendFcn &FALSE

        ..Else_If W$esi = &LF_INDEX
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_INDEX', 0}
            call WriteRawDataDebugSContantLeafTypeIndex &FALSE

        ..Else_If W$esi = &LF_MEMBER
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_MEMBER', 0}
            call WriteRawDataDebugSContantLeafTypeMember &FALSE

        ..Else_If W$esi = &LF_STMEMBER
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_STMEMBER', 0}
            call WriteRawDataDebugSContantLeafTypeSTMember &FALSE

        ..Else_If W$esi = &LF_METHOD
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_METHOD', 0}
            call WriteRawDataDebugSContantLeafTypeMethod &FALSE

        ..Else_If W$esi = &LF_NESTTYPE
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_NESTTYPE', 0}
            call WriteRawDataDebugSContantLeafTypeNestType &FALSE

        ..Else_If W$esi = &LF_VFUNCTAB
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_VFUNCTAB', 0}
            call WriteRawDataDebugSContantLeafTypeVFuncTab &FALSE

        ..Else_If W$esi = &LF_FRIENDCLS
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_FRIENDCLS', 0}
            call WriteRawDataDebugSContantLeafTypeFriendCls &FALSE

        ..Else_If W$esi = &LF_ONEMETHOD
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_ONEMETHOD', 0}
            call WriteRawDataDebugSContantLeafTypeOneMethod &FALSE

        ..Else_If W$esi = &LF_VFUNCOFF
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_VFUNCOFF', 0}
            call WriteRawDataDebugSContantLeafTypeVFuncOffset &FALSE

        ..Else_If W$esi = &LF_NUMERIC
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_NUMERIC', 0}
            jmp L0>>

        ..Else_If W$esi = &LF_CHAR
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_CHAR', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Char', 0}, 1

        ..Else_If W$esi = &LF_SHORT
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_SHORT', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Short', 0}, 2

        ..Else_If W$esi = &LF_USHORT
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_USHORT', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'UShort', 0}, 2

        ..Else_If W$esi = &LF_LONG
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_LONG', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Long', 0}, 4

        ..Else_If W$esi = &LF_ULONG
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_ULONG', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'ULong', 0}, 4

        ..Else_If W$esi = &LF_REAL32
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_REAL32', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Float32Bit', 0}, 4

        ..Else_If W$esi = &LF_REAL64
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_REAL64', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Float64Bit', 0}, 8

        ..Else_If W$esi = &LF_REAL80
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_REAL80', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Float80Bit', 0}, 10

        ..Else_If W$esi = &LF_REAL128
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_REAL128', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Float128Bit', 0}, 16

        ..Else_If W$esi = &LF_QUADWORD
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_QUADWORD', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Quadword', 0}, 8

        ..Else_If W$esi = &LF_UQUADWORD
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_UQUADWORD', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'UQuadword', 0}, 8

        ..Else_If W$esi = &LF_REAL48
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_REAL48', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Real48Bit', 0}, 6

        ..Else_If W$esi = &LF_COMPLEX32
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_COMPLEX32', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Complex32BitReal', 0}, 4
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Complex32BitImaginary', 0}, 4

        ..Else_If W$esi = &LF_COMPLEX64
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_COMPLEX64', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Complex64BitReal', 0}, 8
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Complex64BitImaginary', 0}, 8

        ..Else_If W$esi = &LF_COMPLEX80
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_COMPLEX80', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Complex80BitReal', 0}, 10
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Complex80BitImaginary', 0}, 10

        ..Else_If W$esi = &LF_COMPLEX128
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_COMPLEX128', 0}
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Complex128BitReal', 0}, 16
            call WriteRawDataDebugSContantLeafTypeComplexNumber {'Complex128BitImaginary', 0}, 16

        ..Else_If W$esi = &LF_VARSTRING
            call WriteRawDataDebugSContantLeafTypeEquate {'&LF_VARSTRING', 0}
            call WriteRawDataDebugSContantLeafTypeVarStr

        ..Else
L0:

            push ecx
            push eax
            push esi
                If D$NestedLeafType = &TRUE
                    zCopy LeafTypeArrayObjIndice
                End_If
                zCopy {'.TypeUnknown: W$ ', 0}
            pop esi
            xor eax eax
            lodsw | call WriteEax
            mov W$edi CRLF | add edi 2
            pop eax
            pop ecx
            sub D$SizeAdd 2


        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'Constant.LeafType', 0}
        pop esi


            call WriteRawDataDebugSContantLeafTypeUnkown
            mov D$LeafTypeError &FALSE ; Set the error case

        ..End_If

    ...End_If

    mov W$edi CRLF | add edi 2

EndP
__________________________________________________________________

Proc WriteRawDataDebugSContantLeafTypeUnkown:
    Uses eax, ecx


    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
;    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx
;;
    push ebx

                    push esi
                        mov D$edi '    ' | add edi 4
                        call WriteObjIndice
                        zCopy {"Sec", 0}
                        zCopy SectionHeaderNumber
                        zCopy {".Index", 0}
                        zCopy DebugNumber
                        zCopy D$CVLabel
                        zCopy {'Constant.LeafType.Unknown: B$ ', 0}
                    pop esi
    pop ebx
;;
;;

    push ebx
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayElemType , {': W$ ', 0}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayIdxType , {': W$ ', 0}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayLength, {': W$ ', 0}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayNamelenght, {': B$ ', 0}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayName, {': B$ ', 0}
        sub edi 2
    pop ebx
;;
    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
;;
        mov W$edi CRLF | add edi 2
        ;call WriteCVdataTitle
                    push esi
                        mov D$edi '    ' | add edi 4
                        call WriteObjIndice
                        zCopy {"Sec", 0}
                        zCopy SectionHeaderNumber
                        zCopy {".Index", 0}
                        zCopy DebugNumber
                        zCopy D$CVLabel
                        zCopy {'Constant.LeafType.Unknown: B$ ', 0}
                    pop esi

;;
        push esi | ZCopy {'.Unknown: B$ ', 0} | pop esi

        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP
__________________________________________________________________

Proc WriteRawDataDebugSContantItem:
    Argument @Text1, @Text2, @UseLen
    uses eax, ecx, edx

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'Constant.', 0}
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1

        ..If D$eax = 'Type' ; from "Type" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'OldC' ; from "OldCVType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            If D@UseLen = &TRUE ; this happens only in S_CONSTANT_CV2.
                push eax
                    call StrLenProc esi
                    mov ecx eax
                    inc ecx ; The size is increased to we alow including the zero byte
                pop eax
            Else
                movzx ecx B$esi-1
            End_If

            mov edx esi | add edx ecx


            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP
_______________________________________


;;
Structures used:

. Note, in all equates used to dirrefernciate the structures, when Type member is 0 (&T_NOTYPE), the structure
is related to a enumeration, and the leaf member types (achieved from WriteRawDataDebugSContantLeafTypeItem) are not
used. Instead, the Constant.LeafType is replaced by an EnumerationValue member

 - S_CONSTANT_CV3 uses:
 
     CV3.Length: W$ 015
     CV3.Index: W$ &S_CONSTANT_CV3; Hex Value:  01002
     CV3.Constant.OldCVType: W$ 01058
     CV3.Constant.Type: W$ &T_NOTYPE ; Uncharacterized type (no type) - Hex Value:  0
     CV3.Constant.EnumerationValue: W$ 02 ; This symbol is an enumeration constant type.
     CV3.Constant.NameLenght: B$ 0C
     CV3.Constant.Name: B$ 'STUB_MARSHAL'

 - S_CONSTANT_CV2 uses:
 
     CV3.Length: W$ 015
     CV3.Index: W$ &S_CONSTANT_CV2; Hex Value:  01107
     CV3.Constant.OldCVType: W$ 01058
     CV3.Constant.Type: W$ &T_NOTYPE ; Uncharacterized type (no type) - Hex Value:  0
     CV3.Constant.EnumerationValue: W$ 02 ; This symbol is an enumeration constant type.
     CV3.Constant.NameLenght: B$ 0C
     CV3.Constant.Name: B$ 'STUB_MARSHAL'

;;

[CVConstantOldCVType: 'OldCVType', 0
 CVConstantType: 'Type', 0
 CVConstantNameLenght: 'NameLenght', 0
 CVConstantName: 'Name', 0]

Proc WriteRawDataDebugSContant:
    Local @OldCodeView
    Uses ecx, eax


    mov D@OldCodeView &FALSE
    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx

    If W$esi-2 = &S_CONSTANT_CV3
        call WriteRawDataDebugSContantItem CVConstantOldCVType, {': W$ ', 0}, &FALSE
    Else_If W$esi-2 = &S_CONSTANT_CV2
        call WriteRawDataDebugSContantItem CVConstantOldCVType, {': W$ ', 0}, &FALSE
        mov D@OldCodeView &TRUE
    End_If

    call WriteRawDataDebugSContantItem CVConstantType, {': W$ ', 0}, &FALSE

    .If W$esi-2 = &T_NOTYPE
        push ecx
        push eax
        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'Constant.EnumerationValue: W$ ', 0}
        pop esi
        xor eax eax
        lodsw | call WriteEax

        push esi | zCopy {' ; This symbol is an enumeration constant type.', 0} | pop esi
        mov W$edi CRLF | add edi 2
        pop eax
        pop ecx
    .Else
        call WriteRawDataDebugSContantLeafTypeItem
    .End_If

    .If D$LeafTypeError <> &FALSE ; No Errors. Do next Line. Jmp otherwise
        If D@OldCodeView = &FALSE
            call WriteRawDataDebugSContantItem CVCompileNameLenght, {': B$ ', 0}, &FALSE
            call WriteRawDataDebugSContantItem CVCompileName, {': B$ ', 0}, &FALSE
        Else
            call WriteRawDataDebugSContantItem CVCompileName, {': B$ ', 0}, &TRUE
        End_If
    .End_If


    pop ebx

    ; Is the end of this structure ends on the proper place ?

    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

__________________________________________________________________

[CVUDTOldCVType: 'OldCVType', 0
 CVUDTType: 'Type' , 0
 CVUDTNamelenght: 'NameLenght' , 0
 CVUDTName: 'Name' , 0]

Proc WriteRawDataDebugSUDT:
    Local @OldCodeView
    Uses ecx

    mov D@OldCodeView 0
    If W$esi-2 = &S_UDT_CV3
        mov D@OldCodeView 1
    Else_If W$esi-2 = &S_UDT_CV2
        mov D@OldCodeView 2
    End_If

    If D@OldCodeView <> 0
        Call WriteRawDataDebugSUDTItem CVUDTOldCVType , {': W$ ', 0}, &FALSE
    End_If

    Call WriteRawDataDebugSUDTItem CVUDTType , {': W$ ', 0}, &FALSE

    If D@OldCodeView = 2
        Call WriteRawDataDebugSUDTItem CVUDTName , {': B$ ', 0}, &TRUE
    Else
        Call WriteRawDataDebugSUDTItem CVUDTNamelenght , {': B$ ', 0}, &FALSE
        Call WriteRawDataDebugSUDTItem CVUDTName , {': B$ ', 0}, &FALSE
    End_If
EndP
__________________________________________________________________

Proc WriteRawDataDebugSUDTItem:
    Argument @Text1, @Text2, @UseLen
    uses eax, ecx

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'UDT.', 0}
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1

        ..If D$eax = 'OldC'; From "OldCVType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Type'; From "Type" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            If D@UseLen = &TRUE ; this happens only in S_CONSTANT_CV2.
                push eax
                    call StrLenProc esi
                    mov ecx eax
                    inc ecx ; The size is increased to we alow including the zero byte
                pop eax
            Else
                movzx ecx B$esi-1
            End_If

            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP
__________________________________________________________________



;WriteCVCompileFlag1Equates
;WriteCVGlobalProcFlagEquates

;;
Flag Member:

The Flag member is a Byte value responsable for several different computations accordying to specified bits.
We need to shr the founded values to find the proper equates used. This member is the Flags for the specified
procedure.

Fpo :1  Uses Bit 0. When this bit is flagged the function has frame pointer omitted. Otherwise it don't use.
        Equates:    CV4_FUNCTION_FPO_ENABLED 01
                    CV4_FUNCTION_FPO_DISABLED 0

Interrupt :1  Uses Bit 1. When this bit is flagged the function is interrupt routine. Otherwise it is not.
              Equates:    CV4_FUNCTION_INT_ENABLED 01
                          CV4_FUNCTION_INT_DISABLED 0

Return :1  Uses Bit 2. When this bit is flagged the function performs Far return. Otherwise it doesn't.
            Equates:    CV4_FUNCTION_RET_ENABLED 01
                        CV4_FUNCTION_RET_DISABLED 0

Never :1  Uses Bit 3. When this bit is flagged the function never returns. Otherwise it does.
            Equates:    CV4_FUNCTION_NORET_ENABLED 01
                        CV4_FUNCTION_NORET_DISABLED 0

Bits 4 to 7 are not used. They must be settled to 0.

;;

Proc WriteCVGlobalProcFlagEquates:
    Uses esi, ebx, eax

    xor eax eax | lodsb
   ; We must clear Bits 4 to 7 because they are not used
    btr eax 4 | btr eax 5 | btr eax 6 | btr eax 7
    mov ebx eax

    push ebx
    push eax

    shr ebx 3 ; This is to calculate Never member. Shr by 3 because the Bit 3 is the one that is starting to be flagged.

    .If ebx = &CV4_FUNCTION_NORET_ENABLED
        zCopy {'(&CV4_FUNCTION_NORET_ENABLED shl 3)', 0}
    .Else;_If ebx = CV4_FUNCTION_NORET_DISABLED
        zCopy {'(&CV4_FUNCTION_NORET_DISABLED shl 3)', 0}
    .End_If

        zCopy {' + ', 0}
        ; Now we must Zero bit 3 to shr again to find the next records for Return Member (Bit 2)
        btr eax 3
        ; After clearing the bits, we need to compute only the needed bits to be shred
        shr eax 2 ; This is to calculate Return member. Shr by 2 because the Bit 2 is the one that is starting to be flagged.

    .If eax = &CV4_FUNCTION_RET_ENABLED
        zCopy {'(&CV4_FUNCTION_RET_ENABLED shl 2)', 0}
    .Else;_If eax = CV4_FUNCTION_RET_DISABLED
        zCopy {'(&CV4_FUNCTION_RET_DISABLED shl 2)', 0}
    .End_If

    pop eax
    pop ebx

        zCopy {' + ', 0}

    ; Now we restored the values of ebx and eax. We will going to find the values for
    ; Interrupt (Bit 1) and Fpo (Bit 0)
    ; Since we restored the values we must clear bits 2 to 3 (Rememeber that bits 4 to 7 are already cleared)

    ; zeroes bits 2 to 3
    btr eax 2 | btr eax 3

    shr eax 1 ; This is to calculate Interrupt. Shr by 1 because the Bit 1 is the one that is starting to be flagged.

    .If eax = &CV4_FUNCTION_INT_ENABLED
        zCopy {'(&CV4_FUNCTION_INT_ENABLED shl 1)', 0}
    .Else;_If eax = CV4_FUNCTION_INT_DISABLED
        zCopy {'(&CV4_FUNCTION_INT_DISABLED shl 1)', 0}
    .End_If

        zCopy {' + ', 0}

    and ebx 01 ; This is to calculate Fpo.
               ; The value of 1 is because it is the maximum value of all bits flagged. (Bit 0)

    .If ebx = &CV4_FUNCTION_FPO_ENABLED
        zCopy {'&CV4_FUNCTION_FPO_ENABLED', 0}
    .Else
        zCopy {'&CV4_FUNCTION_FPO_DISABLED', 0}
    .End_If

        zCopy {' ; Hex Value:  ', 0}

EndP

______________________________________

Proc WriteRawDataDebugSGlobalProcItem:
    Argument @Text1, @Text2
    uses eax, ecx

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy D$CVGlobalProcLabel;{'GlobalProcedure.', 0}
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1

        ..If D$eax = 'Ppar' ; from "Pparent" string
            lodsd | call WriteEax

        ..Else_If D$eax = 'Pend'; From "Pend" string
            lodsd | call WriteEax

        ..Else_If D$eax = 'Pnex'; From "Pnext" string
            lodsd | call WriteEax

        ..Else_If D$eax+2 = 'ocLe'; From "ProcLength" string
            lodsd | call WriteEax

        ..Else_If D$eax+4 = 'gSta'; From "DebugStart" string
            lodsd | call WriteEax

        ..Else_If D$eax+4 = 'gEnd'; From "DebugEnd" string
            lodsd | call WriteEax

        ..Else_If D$eax = 'OldC'; From "OldCVType" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Offs'; From "Offset" string
            lodsd | call WriteEax

        ..Else_If D$eax = 'Segm'; From "Segment" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+2 = 'octy'; From "Proctype" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax
            .If W$esi-2 >= &CV_FIRST_NONPRIM
                push esi | ZCopy {"; This is a Non-Primitive Type. The value is: ", 0} | pop esi
                movzx eax W$esi-2
                sub eax &CV_FIRST_NONPRIM
                call WriteEax
            .End_If

        ..Else_If D$eax = 'Flag'; From "Flags" string
            call WriteCVGlobalProcFlagEquates
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                ;mov B$edi "'" | inc edi
                mov B$edi '"' | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             ;mov B$edi "'" | inc edi
                mov B$edi '"' | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

________________________

[CVGlobalProcPparent: 'Pparent' , 0
 CVGlobalProcPend: 'Pend' , 0
 CVGlobalProcPnext: 'Pnext' , 0
 CVGlobalProcLength: 'ProcLength' , 0
 CVGlobalProcDebugStart: 'DebugStart' , 0
 CVGlobalProcDebugEnd: 'DebugEnd' , 0
 CVGlobalProcOldCVType: 'OldCVType' , 0 ; for obsolete versinos of CodeView (V 3 and earlier)
 CVGlobalProcOffset: 'Offset' , 0
 CVGlobalProcSegment: 'Segment' , 0
 CVGlobalProcProctype: 'Proctype' , 0
 CVGlobalProcFlags: 'Flags' , 0
 CVGlobalProcNamelenght: 'NameLenght' , 0
 CVGlobalProcName: 'Name' , 0]

[CVGlobalProcLabel: B$ 0 #20]

Proc WriteRawDataDebugSGlobalProc:
    Local @OldCodeView
    Uses ecx

    mov D@OldCodeView &FALSE

    If W$esi-2 = &S_LPROC32
        move D$CVGlobalProcLabel {'LocalProcedure.', 0}
    Else
        move D$CVGlobalProcLabel {'GlobalProcedure.', 0}
    End_If

    If W$esi-2 = &S_GPROC32_CV3
        mov D@OldCodeView &TRUE
    End_If

    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcPparent , {': D$ ', 0}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcPend , {': D$ ', 0}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcPnext , {': D$ ', 0}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcLength , {': D$ ', 0}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcDebugStart , {': D$ ', 0}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcDebugEnd , {': D$ ', 0}

    If D@OldCodeView = &TRUE
        Call WriteRawDataDebugSGlobalProcItem CVGlobalProcOldCVType , {': W$ ', 0}
    End_If

    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcOffset , {': D$ ', 0}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcSegment , {': W$ ', 0}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcProctype , {': W$ ', 0}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcFlags , {': B$ ', 0}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcNamelenght , {': B$ ', 0}
    Call WriteRawDataDebugSGlobalProcItem CVGlobalProcName , {': B$ ', 0}

EndP

__________________________________________________________________

Proc WriteRawDataDebugSObjectName:
;    Uses ecx
    Uses ecx, eax, ebx
    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx



    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'ObjName.Signature: D$ ', 0}
    pop esi

        lodsd | call WriteEax
        mov W$edi CRLF | add edi 2

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'ObjName.NameLenght: B$ ', 0}
    pop esi

        xor eax eax
        lodsb | call WriteEax

        mov W$edi CRLF | add edi 2

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {".Index", 0}
        zCopy DebugNumber
        zCopy D$CVLabel
        zCopy {'ObjName.Name: B$ ', 0}
    pop esi

        ; ecx points to the size of the Name
        movzx ecx B$esi-1
        mov edx esi | add edx ecx

        .If B$esi = 0
            mov B$edi '0' | inc edi | inc esi
        .Else

        mov B$edi "'" | inc edi
L0:     lodsb
            If al = 0
                dec esi | jmp L1>
            End_If
        stosb | On esi < edx, jmp L0<
L1:     mov B$edi "'" | inc edi

        .End_If

        While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        mov W$edi CRLF | add edi 2

    pop ebx

    ; Is the end of this structure ends on the proper place ?

    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If


EndP

__________________________________________________________________

[CVThunkStart1632Pparent: 'Pparent' , 0
 CVThunkStart1632Pend: 'Pend' , 0
 CVThunkStart1632Pnext: 'Pnext' , 0
 CVThunkStart1632Offset: 'Offset' , 0
 CVThunkStart1632Segment: 'Segment' , 0
 CVThunkStart1632ThunkLength: 'ThunkLength' , 0
 CVThunkStart1632Ordinal: 'Ordinal' , 0
 CVThunkStart1632Namelenght: 'NameLenght' , 0
 CVThunkStart1632Name: 'Name' , 0
 CVThunkStart1632VariantAdjustorDelta: 'VariantAdjustor.Delta', 0
 CVThunkStart1632VariantAdjustorTargetFunctionNameLen: 'VariantAdjustor.TargetFunctionNameLenght', 0
 CVThunkStart1632VariantAdjustorTargetFunctionName: 'VariantAdjustor.TargetFunctionName', 0
 CVThunkStart1632VariantVCallVTableDisplacement: 'VariantVCall.VTableDisplacement', 0
 CVThunkStart1632VariantPCodeSegment: 'VariantPCode.Segment', 0
 CVThunkStart1632VariantPCodeOffset: 'VariantPCode.Offset', 0]

Proc WriteRawDataDebugSThunkStart1632:
    Local @OrdinalValue
    Uses ecx, eax

    mov D@OrdinalValue 0

    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Pparent , {': D$ ', 0}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Pend , {': D$ ', 0}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Pnext , {': D$ ', 0}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Offset , {': D$ ', 0}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Segment , {': W$ ', 0}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632ThunkLength , {': W$ ', 0}
    movzx eax B$esi
    mov D@OrdinalValue eax
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Ordinal , {': B$ ', 0}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Namelenght , {': B$ ', 0}
    Call WriteRawDataDebugSThunkStart1632Item CVThunkStart1632Name , {': B$ ', 0}

    ; Below are some members that i have no files to check, but accordying to the documentation, it seems correct.
    .If D@OrdinalValue = &CV4_THUNK32_ADJUSTOR
        push edi | push esi | call 'USER32.MessageBoxA' 0, {"CV4 - S_THUNK32 / Variant. Please, send this file to us to we check if the CV4 structure is correct", 0}, {"Attention !!!!", 0}, &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL | pop esi | pop edi
        Call WriteRawDataDebugSThunkStart1632VariantItem CVThunkStart1632VariantAdjustorDelta, {': W$ ', 0}
        Call WriteRawDataDebugSThunkStart1632VariantItem CVThunkStart1632VariantAdjustorTargetFunctionNameLen, {': B$ ', 0}
        Call WriteRawDataDebugSThunkStart1632VariantItem CVThunkStart1632VariantAdjustorTargetFunctionName, {': B$ ', 0}
    .Else_If D@OrdinalValue = &CV4_THUNK32_VCALL
        push edi | push esi | call 'USER32.MessageBoxA' 0, {"CV4 - S_THUNK32 / Variant. Please, send this file to us to we check if the CV4 structure is correct", 0}, {"Attention !!!!", 0}, &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL | pop esi | pop edi
        Call WriteRawDataDebugSThunkStart1632VariantItem CVThunkStart1632VariantVCallVTableDisplacement, {': W$ ', 0}
    .Else_If D@OrdinalValue = &CV4_THUNK32_PCODE
        push edi | push esi | call 'USER32.MessageBoxA' 0, {"CV4 - S_THUNK32 / Variant. Please, send this file to us to we check if the CV4 structure is correct", 0}, {"Attention !!!!", 0}, &MB_OK__&MB_ICONWARNING__&MB_SYSTEMMODAL | pop esi | pop edi
        Call WriteRawDataDebugSThunkStart1632VariantItem CVThunkStart1632VariantPCodeSegment, {': W$ ', 0}
        Call WriteRawDataDebugSThunkStart1632VariantItem CVThunkStart1632VariantPCodeOffset, {': D$ ', 0}
    .End_If

EndP
__________________________________________________________________

Proc WriteRawDataDebugSThunkStart1632Item:
    Argument @Text1, @Text2
    uses eax, ecx

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'ThunkStart1632.', 0}
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1

        ..If D$eax = 'Ppar' ; from "Pparent" string
            lodsd | call WriteEax

        ..Else_If D$eax = 'Pend'; From "Pend" string
            lodsd | call WriteEax

        ..Else_If D$eax = 'Pnex'; From "Pnext" string
            lodsd | call WriteEax

        ..Else_If D$eax = 'Offs'; From "Offset" string
            lodsd | call WriteEax

        ..Else_If D$eax = 'Segm'; From "Segment" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Thun'; From "ThunkLength" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Ordi'; From "Ordinal" string
            call WriteCVThunkStart1632OrdinalEquates
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

__________________________________________________________________

Proc WriteRawDataDebugSThunkStart1632VariantItem:
    Argument @Text1, @Text2
    uses eax, ecx

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'ThunkStart1632.', 0}
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1


        ..If D$eax+16 = 'Delt' ; from "VariantAdjustor.Delta" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+34 = 'Leng'; From "VariantAdjustor.TargetFunctionNameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax+30 = 'Name'; From "VariantAdjustor.TargetFunctionName" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..Else_If D$eax+13 = 'VTab'; From "VariantVCall.VTableDisplacement" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+13 = 'Segm'; From "VariantPCode.Segment" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+13 = 'Offs'; From "VariantPCode.Offset" string
            lodsd | call WriteEax

         ..End_If

        mov W$edi CRLF | add edi 2

EndP

__________________________________________________________________

Proc WriteCVThunkStart1632OrdinalEquates:
    Uses esi;, ebx, eax

    .If B$esi = &CV4_THUNK32_NOTYPE
        zCopy {'&CV4_THUNK32_NOTYPE', 0}
    .Else_If B$esi = &CV4_THUNK32_ADJUSTOR
        zCopy {'&CV4_THUNK32_ADJUSTOR', 0}
    .Else_If B$esi = &CV4_THUNK32_VCALL
        zCopy {'&CV4_THUNK32_VCALL', 0}
    .Else_If B$esi = &CV4_THUNK32_PCODE
        zCopy {'&CV4_THUNK32_PCODE', 0}

    .End_If

        zCopy {' ; Hex Value:  ', 0}

EndP
__________________________________________________________________


;;
These are the primitives Types Listings. All values not used below are unknown or not specified.

Equates used:

Special Types

T_NOTYPE 0x0000 Uncharacterized type (no type)
T_ABS 0x0001 Absolute symbol
T_SEGMENT 0x0002 Segment type
T_VOID 0x0003 Void
T_PVOID 0x0103 Near pointer to void
T_PFVOID 0x0203 Far pointer to void
T_PHVOID 0x0303 Huge pointer to void
T_32PVOID 0x0403 32-bit near pointer to void
T_32PFVOID 0x0503 32-bit far pointer to void
T_CURRENCY 0x0004 Basic 8-byte currency value
T_NBASICSTR 0x0005 Near Basic string
T_FBASICSTR 0x0006 Far Basic string
T_NOTTRANS 0x0007 Untranslated type record from Microsoft symbol format
T_BIT 0x0060 Bit
T_PASCHAR 0x0061 Pascal CHAR

Character Types

T_CHAR 0x0010 8-bit signed
T_UCHAR 0x0020 8-bit unsigned
T_PCHAR 0x0110 Near pointer to 8-bit signed
T_PUCHAR 0x0120 Near pointer to 8-bit unsigned
T_PFCHAR 0x0210 Far pointer to 8-bit signed
T_PFUCHAR 0x0220 Far pointer to 8-bit unsigned
T_PHCHAR 0x0310 Huge pointer to 8-bit signed
T_PHUCHAR 0x0320 Huge pointer to 8-bit unsigned
T_32PCHAR 0x0410 16:32 near pointer to 8-bit signed
T_32PUCHAR 0x0420 16:32 near pointer to 8-bit unsigned
T_32PFCHAR 0x0510 16:32 far pointer to 8-bit signed
T_32PFUCHAR 0x0520 16:32 far pointer to 8-bit unsigned

Real Character Types

T_RCHAR 0x0070 Real char
T_PRCHAR 0x0170 Near pointer to a real char
T_PFRCHAR 0x0270 Far pointer to a real char
T_PHRCHAR 0x0370 Huge pointer to a real char
T_32PRCHAR 0x0470 16:32 near pointer to a real char
T_32PFRCHAR 0x0570 16:32 far pointer to a real char

Wide Character Types

T_WCHAR 0x0071 Wide char
T_PWCHAR 0x0171 Near pointer to a wide char
T_PFWCHAR 0x0271 Far pointer to a wide char
T_PHWCHAR 0x0371 Huge pointer to a wide char
T_32PWCHAR 0x0471 16:32 near pointer to a wide char
T_32PFWCHAR 0x0571 16:32 far pointer to a wide char

Real 16-bit Integer Types

T_INT2 0x0072 Real 16-bit signed int
T_UINT2 0x0073 Real 16-bit unsigned int
T_PINT2 0x0172 Near pointer to 16-bit signed int
T_PUINT2 0x0173 Near pointer to 16-bit unsigned int
T_PFINT2 0x0272 Far pointer to 16-bit signed int
T_PFUINT2 0x0273 Far pointer to 16-bit unsigned int
T_PHINT2 0x0372 Huge pointer to 16-bit signed int
T_PHUINT2 0x0373 Huge pointer to 16-bit unsigned int
T_32PINT2 0x0472 16:32 near pointer to 16-bit signed int
T_32PUINT2 0x0473 16:32 near pointer to 16-bit unsigned int
T_32PFINT2 0x0572 16:32 far pointer to 16-bit signed int
T_32PFUINT2 0x0573 16:32 far pointer to 16-bit unsigned int

16-bit Short Types

T_SHORT 0x0011 16-bit signed
T_USHORT 0x0021 16-bit unsigned
T_PSHORT 0x0111 Near pointer to 16-bit signed
T_PUSHORT 0x0121 Near pointer to 16-bit unsigned
T_PFSHORT 0x0211 Far pointer to 16-bit signed
T_PFUSHORT 0x0221 Far pointer to 16-bit unsigned
T_PHSHORT 0x0311 Huge pointer to 16-bit signed
T_PHUSHORT 0x0321 Huge pointer to 16-bit unsigned
T_32PSHORT 0x0411 16:32 near pointer to 16-bit signed
T_32PUSHORT 0x0421 16:32 near pointer to 16-bit unsigned
T_32PFSHORT 0x0511 16:32 far pointer to 16-bit signed
T_32PFUSHORT 0x0521 16:32 far pointer to 16-bit unsigned

Real 32-bit Integer Types

T_INT4 0x0074 Real 32-bit signed int
T_UINT4 0x0075 Real 32-bit unsigned int
T_PINT4 0x0174 Near pointer to 32-bit signed int
T_PUINT4 0x0175 Near pointer to 32-bit unsigned int
T_PFINT4 0x0274 Far pointer to 32-bit signed int
T_PFUINT4 0x0275 Far pointer to 32-bit unsigned int
T_PHINT4 0x0374 Huge pointer to 32-bit signed int
T_PHUINT4 0x0375 Huge pointer to 32-bit unsigned int
T_32PINT4 0x0474 16:32 near pointer to 32-bit signed int
T_32PUINT4 0x0475 16:32 near pointer to 32-bit unsigned int
T_32PFINT4 0x0574 16:32 far pointer to 32-bit signed int
T_32PFUINT4 0x0575 16:32 far pointer to 32-bit unsigned int

32-bit Long Types

T_LONG 0x0012 32-bit signed
T_ULONG 0x0022 32-bit unsigned
T_PLONG 0x0112 Near pointer to 32-bit signed
T_PULONG 0x0122 Near pointer to 32-bit unsigned
T_PFLONG 0x0212 Far pointer to 32-bit signed
T_PFULONG 0x0222 Far pointer to 32-bit unsigned
T_PHLONG 0x0312 Huge pointer to 32-bit signed
T_PHULONG 0x0322 Huge pointer to 32-bit unsigned
T_32PLONG 0x0412 16:32 near pointer to 32-bit signed
T_32PULONG 0x0422 16:32 near pointer to 32-bit unsigned
T_32PFLONG 0x0512 16:32 far pointer to 32-bit signed
T_32PFULONG 0x0522 16:32 far pointer to 32-bit unsigned

Real 64-bit int Types

T_INT8 0x0076 64-bit signed int
T_UINT8 0x0077 64-bit unsigned int
T_PINT8 0x0176 Near pointer to 64-bit signed int
T_PUINT8 0x0177 Near pointer to 64-bit unsigned int
T_PFINT8 0x0276 Far pointer to 64-bit signed int
T_PFUINT8 0x0277 Far pointer to 64-bit unsigned int
T_PHINT8 0x0376 Huge pointer to 64-bit signed int
T_PHUINT8 0x0377 Huge pointer to 64-bit unsigned int
T_32PINT8 0x0476 16:32 near pointer to 64-bit signed int
T_32PUINT8 0x0477 16:32 near pointer to 64-bit unsigned int
T_32PFINT8 0x0576 16:32 far pointer to 64-bit signed int
T_32PFUINT8 0x0577 16:32 far pointer to 64-bit unsigned int

64-bit Integral Types

T_QUAD 0x0013 64-bit signed
T_UQUAD 0x0023 64-bit unsigned
T_PQUAD 0x0113 Near pointer to 64-bit signed
T_PUQUAD 0x0123 Near pointer to 64-bit unsigned
T_PFQUAD 0x0213 Far pointer to 64-bit signed
T_PFUQUAD 0x0223 Far pointer to 64-bit unsigned
T_PHQUAD 0x0313 Huge pointer to 64-bit signed
T_PHUQUAD 0x0323 Huge pointer to 64-bit unsigned
T_32PQUAD 0x0413 16:32 near pointer to 64-bit signed
T_32PUQUAD 0x0423 16:32 near pointer to 64-bit unsigned
T_32PFQUAD 0x0513 16:32 far pointer to 64-bit signed
T_32PFUQUAD 0x0523 16:32 far pointer to 64-bit unsigned

32-bit Real Types

T_REAL32 0x0040 32-bit real
T_PREAL32 0x0140 Near pointer to 32-bit real
T_PFREAL32 0x0240 Far pointer to 32-bit real
T_PHREAL32 0x0340 Huge pointer to 32-bit real
T_32PREAL32 0x0440 16:32 near pointer to 32-bit real
T_32PFREAL32 0x0540 16:32 far pointer to 32-bit real

48-bit Real Types

T_REAL48 0x0044 48-bit real
T_PREAL48 0x0144 Near pointer to 48-bit real
T_PFREAL48 0x0244 Far pointer to 48-bit real
T_PHREAL48 0x0344 Huge pointer to 48-bit real
T_32PREAL48 0x0444 16:32 near pointer to 48-bit real
T_32PFREAL48 0x0544 16:32 far pointer to 48-bit real

64-bit Real Types

T_REAL64 0x0041 64-bit real
T_PREAL64 0x0141 Near pointer to 64-bit real
T_PFREAL64 0x0241 Far pointer to 64-bit real
T_PHREAL64 0x0341 Huge pointer to 64-bit real
T_32PREAL64 0x0441 16:32 near pointer to 64-bit real
T_32PFREAL64 0x0541 16:32 far pointer to 64-bit real

80-bit Real Types

T_REAL80 0x0042 80-bit real
T_PREAL80 0x0142 Near pointer to 80-bit real
T_PFREAL80 0x0242 Far pointer to 80-bit real
T_PHREAL80 0x0342 Huge pointer to 80-bit real
T_32PREAL80 0x0442 16:32 near pointer to 80-bit real
T_32PFREAL80 0x0542 16:32 far pointer to 80-bit real

128-bit Real Types
T_REAL128 0x0043 128-bit real
T_PREAL128 0x0143 Near pointer to 128-bit real
T_PFREAL128 0x0243 Far pointer to 128-bit real
T_PHREAL128 0x0343 Huge pointer to 128-bit real
T_32PREAL128 0x0443 16:32 near pointer to 128-bit real
T_32PFREAL128 0x0543 16:32 far pointer to 128-bit real

32-bit Complex Types

T_CPLX32 0x0050 32-bit complex
T_PCPLX32 0x0150 Near pointer to 32-bit complex
T_PFCPLX32 0x0250 Far pointer to 32-bit complex
T_PHCPLX32 0x0350 Huge pointer to 32-bit complex
T_32PCPLX32 0x0450 16:32 near pointer to 32-bit complex
T_32PFCPLX32 0x0550 16:32 far pointer to 32-bit complex

64-bit Complex Types

T_CPLX64 0x0051 64-bit complex
T_PCPLX64 0x0151 Near pointer to 64-bit complex
T_PFCPLX64 0x0251 Far pointer to 64-bit complex
T_PHCPLX64 0x0351 Huge pointer to 64-bit complex
T_32PCPLX64 0x0451 16:32 near pointer to 64-bit complex
T_32PFCPLX64 0x0551 16:32 far pointer to 64-bit complex

80-bit Complex Types

T_CPLX80 0x0052 80-bit complex
T_PCPLX80 0x0152 Near pointer to 80-bit complex
T_PFCPLX80 0x0252 Far pointer to 80-bit complex
T_PHCPLX80 0x0352 Huge pointer to 80-bit complex
T_32PCPLX80 0x0452 16:32 near pointer to 80-bit complex
T_32PFCPLX80 0x0552 16:32 far pointer to 80-bit complex

128-bit Complex Types

T_CPLX128 0x0053 128-bit complex
T_PCPLX128 0x0153 Near pointer to 128-bit complex
T_PFCPLX128 0x0253 Far pointer to 128-bit complex
T_PHCPLX128 0x0353 Huge pointer to 128-bit real
T_32PCPLX128 0x0453 16:32 near pointer to 128-bit complex
T_32PFCPLX128 0x0553 16:32 far pointer to 128-bit complex

Boolean Types

T_BOOL08 0x0030 8-bit Boolean
T_BOOL16 0x0031 16-bit Boolean
T_BOOL32 0x0032 32-bit Boolean
T_BOOL64 0x0033 64-bit Boolean
T_PBOOL08 0x0130 Near pointer to 8-bit Boolean
T_PBOOL16 0x0131 Near pointer to 16-bit Boolean
T_PBOOL32 0x0132 Near pointer to 32-bit Boolean
T_PBOOL64 0x0133 Near pointer to 64-bit Boolean
T_PFBOOL08 0x0230 Far pointer to 8-bit Boolean
T_PFBOOL16 0x0231 Far pointer to 16-bit Boolean
T_PFBOOL32 0x0232 Far pointer to 32-bit Boolean
T_PFBOOL32 0x0233 Far pointer to 64-bit Boolean
T_PHBOOL08 0x0330 Huge pointer to 8-bit Boolean
T_PHBOOL16 0x0331 Huge pointer to 16-bit Boolean
T_PHBOOL32 0x0332 Huge pointer to 32-bit Boolean
T_PHBOOL64 0x0333 Huge pointer to 64-bit Boolean
T_32PBOOL08 0x0430 16:32 near pointer to 8-bit Boolean
T_32PBOOL16 0x0431 16:32 near pointer to 16-bit Boolean
T_32PBOOL32 0x0432 16:32 near pointer to 32-bit Boolean
T_32PBOOL64 0x0433 16:32 near pointer to 64-bit Boolean
T_32PFBOOL08 0x0530 16:32 far pointer to 8-bit Boolean
T_32PFBOOL16 0x0531 16:32 far pointer to 16-bit Boolean
T_32PFBOOL32 0x0532 16:32 far pointer to 32-bit Boolean
T_32PFBOOL64 0x0533 16:32 far pointer to 64-bit Boolean
;;

Proc WriteCVBPRel32TypeEquates:
    Uses esi

    ..If W$esi = &T_NOTYPE
        zCopy {'&T_NOTYPE ; Uncharacterized type (no type) - Hex Value:  ', 0}
    ..Else_If W$esi = &T_ABS
        zCopy {'&T_ABS ; Absolute symbol - Hex Value:  ', 0}
    ..Else_If W$esi = &T_SEGMENT
        zCopy {'&T_SEGMENT ; Segment type - Hex Value:  ', 0}
    ..Else_If W$esi = &T_VOID
        zCopy {'&T_VOID ; Void - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PVOID
        zCopy {'&T_PVOID ; Near pointer to void - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFVOID
        zCopy {'&T_PFVOID ; Far pointer to void - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHVOID
        zCopy {'&T_PHVOID ; Huge pointer to void - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PVOID
        zCopy {'&T_32PVOID ; 32-bit near pointer to void - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFVOID
        zCopy {'&T_32PFVOID ; 32-bit far pointer to void - Hex Value:  ', 0}
    ..Else_If W$esi = &T_CURRENCY
        zCopy {'&T_CURRENCY ; Basic 8-byte currency value - Hex Value:  ', 0}
    ..Else_If W$esi = &T_NBASICSTR
        zCopy {'&T_NBASICSTR ; Near Basic string - Hex Value:  ', 0}
    ..Else_If W$esi = &T_FBASICSTR
        zCopy {'&T_FBASICSTR ; Far Basic string - Hex Value:  ', 0}
    ..Else_If W$esi = &T_NOTTRANS
        zCopy {'&T_NOTTRANS ; Untranslated type record from Microsoft symbol format - Hex Value:  ', 0}
    ..Else_If W$esi = &T_BIT
        zCopy {'&T_BIT ; Bit - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PASCHAR
        zCopy {'&T_PASCHAR ; Pascal CHAR - Hex Value:  ', 0}
    ..Else_If W$esi = &T_CHAR
        zCopy {'&T_CHAR ; 8-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_UCHAR
        zCopy {'&T_UCHAR ; 8-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PCHAR
        zCopy {'&T_PCHAR ; Near pointer to 8-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PUCHAR
        zCopy {'&T_PUCHAR ; Near pointer to 8-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFCHAR
        zCopy {'&T_PFCHAR ; Far pointer to 8-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFUCHAR
        zCopy {'&T_PFUCHAR ; Far pointer to 8-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHCHAR
        zCopy {'&T_PHCHAR ; Huge pointer to 8-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHUCHAR
        zCopy {'&T_PHUCHAR ; Huge pointer to 8-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PCHAR
        zCopy {'&T_32PCHAR ; 16:32 near pointer to 8-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PUCHAR
        zCopy {'&T_32PUCHAR ; 16:32 near pointer to 8-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFCHAR
        zCopy {'&T_32PFCHAR ; 16:32 far pointer to 8-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFUCHAR
        zCopy {'&T_32PFUCHAR ; 16:32 far pointer to 8-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_RCHAR
        zCopy {'&T_RCHAR ; Real char - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PRCHAR
        zCopy {'&T_PRCHAR ; Near pointer to a real char - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFRCHAR
        zCopy {'&T_PFRCHAR ; Far pointer to a real char - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHRCHAR
        zCopy {'&T_PHRCHAR ; Huge pointer to a real char - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PRCHAR
        zCopy {'&T_32PRCHAR ; 16:32 near pointer to a real char - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFRCHAR
        zCopy {'&T_32PFRCHAR ; 16:32 far pointer to a real char - Hex Value:  ', 0}
    ..Else_If W$esi = &T_WCHAR
        zCopy {'&T_WCHAR ; Wide char - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PWCHAR
        zCopy {'&T_PWCHAR ; Near pointer to a wide char - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFWCHAR
        zCopy {'&T_PFWCHAR ; Far pointer to a wide char - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHWCHAR
        zCopy {'&T_PHWCHAR ; Huge pointer to a wide char - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PWCHAR
        zCopy {'&T_32PWCHAR ; 16:32 near pointer to a wide char - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFWCHAR
        zCopy {'&T_32PFWCHAR ; 16:32 far pointer to a wide char - Hex Value:  ', 0}
    ..Else_If W$esi = &T_INT2
        zCopy {'&T_INT2 ; Real 16-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_UINT2
        zCopy {'&T_UINT2 ; Real 16-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PINT2
        zCopy {'&T_PINT2 ; Near pointer to 16-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PUINT2
        zCopy {'&T_PUINT2 ; Near pointer to 16-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFINT2
        zCopy {'&T_PFINT2 ; Far pointer to 16-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFUINT2
        zCopy {'&T_PFUINT2 ; Far pointer to 16-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHINT2
        zCopy {'&T_PHINT2 ; Huge pointer to 16-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHUINT2
        zCopy {'&T_PHUINT2 ; Huge pointer to 16-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PINT2
        zCopy {'&T_32PINT2 ; 16:32 near pointer to 16-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PUINT2
        zCopy {'&T_32PUINT2 ; 16:32 near pointer to 16-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFINT2
        zCopy {'&T_32PFINT2 ; 16:32 far pointer to 16-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFUINT2
        zCopy {'&T_32PFUINT2 ; 16:32 far pointer to 16-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_SHORT
        zCopy {'&T_SHORT ; 16-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_USHORT
        zCopy {'&T_USHORT ; 16-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PSHORT
        zCopy {'&T_PSHORT ; Near pointer to 16-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PUSHORT
        zCopy {'&T_PUSHORT ; Near pointer to 16-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFSHORT
        zCopy {'&T_PFSHORT ; Far pointer to 16-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFUSHORT
        zCopy {'&T_PFUSHORT ; Far pointer to 16-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHSHORT
        zCopy {'&T_PHSHORT ; Huge pointer to 16-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHUSHORT
        zCopy {'&T_PHUSHORT ; Huge pointer to 16-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PSHORT
        zCopy {'&T_32PSHORT ; 16:32 near pointer to 16-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PUSHORT
        zCopy {'&T_32PUSHORT ; 16:32 near pointer to 16-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFSHORT
        zCopy {'&T_32PFSHORT ; 16:32 far pointer to 16-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFUSHORT
        zCopy {'&T_32PFUSHORT ; 16:32 far pointer to 16-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_INT4
        zCopy {'&T_INT4 ; Real 32-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_UINT4
        zCopy {'&T_UINT4 ; Real 32-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PINT4
        zCopy {'&T_PINT4 ; Near pointer to 32-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PUINT4
        zCopy {'&T_PUINT4 ; Near pointer to 32-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFINT4
        zCopy {'&T_PFINT4 ; Far pointer to 32-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFUINT4
        zCopy {'&T_PFUINT4 ; Far pointer to 32-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHINT4
        zCopy {'&T_PHINT4 ; Huge pointer to 32-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHUINT4
        zCopy {'&T_PHUINT4 ; Huge pointer to 32-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PINT4
        zCopy {'&T_32PINT4 ; 16:32 near pointer to 32-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PUINT4
        zCopy {'&T_32PUINT4 ; 16:32 near pointer to 32-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFINT4
        zCopy {'&T_32PFINT4 ; 16:32 far pointer to 32-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFUINT4
        zCopy {'&T_32PFUINT4 ; 16:32 far pointer to 32-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_LONG
        zCopy {'&T_LONG ; 32-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_ULONG
        zCopy {'&T_ULONG ; 32-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PLONG
        zCopy {'&T_PLONG ; Near pointer to 32-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PULONG
        zCopy {'&T_PULONG ; Near pointer to 32-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFLONG
        zCopy {'&T_PFLONG ; Far pointer to 32-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFULONG
        zCopy {'&T_PFULONG ; Far pointer to 32-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHLONG
        zCopy {'&T_PHLONG ; Huge pointer to 32-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHULONG
        zCopy {'&T_PHULONG ; Huge pointer to 32-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PLONG
        zCopy {'&T_32PLONG ; 16:32 near pointer to 32-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PULONG
        zCopy {'&T_32PULONG ; 16:32 near pointer to 32-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFLONG
        zCopy {'&T_32PFLONG ; 16:32 far pointer to 32-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFULONG
        zCopy {'&T_32PFULONG ; 16:32 far pointer to 32-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_INT8
        zCopy {'&T_INT8 ; 64-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_UINT8
        zCopy {'&T_UINT8 ; 64-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PINT8
        zCopy {'&T_PINT8 ; Near pointer to 64-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PUINT8
        zCopy {'&T_PUINT8 ; Near pointer to 64-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFINT8
        zCopy {'&T_PFINT8 ; Far pointer to 64-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFUINT8
        zCopy {'&T_PFUINT8 ; Far pointer to 64-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHINT8
        zCopy {'&T_PHINT8 ; Huge pointer to 64-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHUINT8
        zCopy {'&T_PHUINT8 ; Huge pointer to 64-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PINT8
        zCopy {'&T_32PINT8 ; 16:32 near pointer to 64-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PUINT8
        zCopy {'&T_32PUINT8 ; 16:32 near pointer to 64-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFINT8
        zCopy {'&T_32PFINT8 ; 16:32 far pointer to 64-bit signed int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFUINT8
        zCopy {'&T_32PFUINT8 ; 16:32 far pointer to 64-bit unsigned int - Hex Value:  ', 0}
    ..Else_If W$esi = &T_QUAD
        zCopy {'&T_QUAD ; 64-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_UQUAD
        zCopy {'&T_UQUAD ; 64-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PQUAD
        zCopy {'&T_PQUAD ; Near pointer to 64-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PUQUAD
        zCopy {'&T_PUQUAD ; Near pointer to 64-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFQUAD
        zCopy {'&T_PFQUAD ; Far pointer to 64-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFUQUAD
        zCopy {'&T_PFUQUAD ; Far pointer to 64-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHQUAD
        zCopy {'&T_PHQUAD ; Huge pointer to 64-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHUQUAD
        zCopy {'&T_PHUQUAD ; Huge pointer to 64-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PQUAD
        zCopy {'&T_32PQUAD ; 16:32 near pointer to 64-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PUQUAD
        zCopy {'&T_32PUQUAD ; 16:32 near pointer to 64-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFQUAD
        zCopy {'&T_32PFQUAD ; 16:32 far pointer to 64-bit signed - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFUQUAD
        zCopy {'&T_32PFUQUAD ; 16:32 far pointer to 64-bit unsigned - Hex Value:  ', 0}
    ..Else_If W$esi = &T_REAL32
        zCopy {'&T_REAL32 ; 32-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PREAL32
        zCopy {'&T_PREAL32 ; Near pointer to 32-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFREAL32
        zCopy {'&T_PFREAL32 ; Far pointer to 32-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHREAL32
        zCopy {'&T_PHREAL32 ; Huge pointer to 32-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PREAL32
        zCopy {'&T_32PREAL32 ; 16:32 near pointer to 32-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFREAL32
        zCopy {'&T_32PFREAL32 ; 16:32 far pointer to 32-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_REAL48
        zCopy {'&T_REAL48 ; 48-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PREAL48
        zCopy {'&T_PREAL48 ; Near pointer to 48-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFREAL48
        zCopy {'&T_PFREAL48 ; Far pointer to 48-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHREAL48
        zCopy {'&T_PHREAL48 ; Huge pointer to 48-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PREAL48
        zCopy {'&T_32PREAL48 ; 16:32 near pointer to 48-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFREAL48
        zCopy {'&T_32PFREAL48 ; 16:32 far pointer to 48-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_REAL64
        zCopy {'&T_REAL64 ; 64-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PREAL64
        zCopy {'&T_PREAL64 ; Near pointer to 64-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFREAL64
        zCopy {'&T_PFREAL64 ; Far pointer to 64-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHREAL64
        zCopy {'&T_PHREAL64 ; Huge pointer to 64-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PREAL64
        zCopy {'&T_32PREAL64 ; 16:32 near pointer to 64-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFREAL64
        zCopy {'&T_32PFREAL64 ; 16:32 far pointer to 64-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_REAL80
        zCopy {'&T_REAL80 ; 80-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PREAL80
        zCopy {'&T_PREAL80 ; Near pointer to 80-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFREAL80
        zCopy {'&T_PFREAL80 ; Far pointer to 80-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHREAL80
        zCopy {'&T_PHREAL80 ; Huge pointer to 80-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PREAL80
        zCopy {'&T_32PREAL80 ; 16:32 near pointer to 80-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFREAL80
        zCopy {'&T_32PFREAL80 ; 16:32 far pointer to 80-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_REAL128
        zCopy {'&T_REAL128 ; 128-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PREAL128
        zCopy {'&T_PREAL128 ; Near pointer to 128-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFREAL128
        zCopy {'&T_PFREAL128 ; Far pointer to 128-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHREAL128
        zCopy {'&T_PHREAL128 ; Huge pointer to 128-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PREAL128
        zCopy {'&T_32PREAL128 ; 16:32 near pointer to 128-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFREAL128
        zCopy {'&T_32PFREAL128 ; 16:32 far pointer to 128-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_CPLX32
        zCopy {'&T_CPLX32 ; 32-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PCPLX32
        zCopy {'&T_PCPLX32 ; Near pointer to 32-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFCPLX32
        zCopy {'&T_PFCPLX32 ; Far pointer to 32-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHCPLX32
        zCopy {'&T_PHCPLX32 ; Huge pointer to 32-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PCPLX32
        zCopy {'&T_32PCPLX32 ; 16:32 near pointer to 32-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFCPLX32
        zCopy {'&T_32PFCPLX32 ; 16:32 far pointer to 32-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_CPLX64
        zCopy {'&T_CPLX64 ; 64-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PCPLX64
        zCopy {'&T_PCPLX64 ; Near pointer to 64-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFCPLX64
        zCopy {'&T_PFCPLX64 ; Far pointer to 64-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHCPLX64
        zCopy {'&T_PHCPLX64 ; Huge pointer to 64-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PCPLX64
        zCopy {'&T_32PCPLX64 ; 16:32 near pointer to 64-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFCPLX64
        zCopy {'&T_32PFCPLX64 ; 16:32 far pointer to 64-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_CPLX80
        zCopy {'&T_CPLX80 ; 80-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PCPLX80
        zCopy {'&T_PCPLX80 ; Near pointer to 80-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFCPLX80
        zCopy {'&T_PFCPLX80 ; Far pointer to 80-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHCPLX80
        zCopy {'&T_PHCPLX80 ; Huge pointer to 80-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PCPLX80
        zCopy {'&T_32PCPLX80 ; 16:32 near pointer to 80-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFCPLX80
        zCopy {'&T_32PFCPLX80 ; 16:32 far pointer to 80-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_CPLX128
        zCopy {'&T_CPLX128 ; 128-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PCPLX128
        zCopy {'&T_PCPLX128 ; Near pointer to 128-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFCPLX128
        zCopy {'&T_PFCPLX128 ; Far pointer to 128-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHCPLX128
        zCopy {'&T_PHCPLX128 ; Huge pointer to 128-bit real - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PCPLX128
        zCopy {'&T_32PCPLX128 ; 16:32 near pointer to 128-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFCPLX128
        zCopy {'&T_32PFCPLX128 ; 16:32 far pointer to 128-bit complex - Hex Value:  ', 0}
    ..Else_If W$esi = &T_BOOL08
        zCopy {'&T_BOOL08 ; 8-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_BOOL16
        zCopy {'&T_BOOL16 ; 16-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_BOOL32
        zCopy {'&T_BOOL32 ; 32-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_BOOL64
        zCopy {'&T_BOOL64 ; 64-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PBOOL08
        zCopy {'&T_PBOOL08 ; Near pointer to 8-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PBOOL16
        zCopy {'&T_PBOOL16 ; Near pointer to 16-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PBOOL32
        zCopy {'&T_PBOOL32 ; Near pointer to 32-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PBOOL64
        zCopy {'&T_PBOOL64 ; Near pointer to 64-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFBOOL08
        zCopy {'&T_PFBOOL08 ; Far pointer to 8-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFBOOL16
        zCopy {'&T_PFBOOL16 ; Far pointer to 16-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFBOOL32
        zCopy {'&T_PFBOOL32 ; Far pointer to 32-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PFBOOL32
        zCopy {'&T_PFBOOL32 ; Far pointer to 64-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHBOOL08
        zCopy {'&T_PHBOOL08 ; Huge pointer to 8-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHBOOL16
        zCopy {'&T_PHBOOL16 ; Huge pointer to 16-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHBOOL32
        zCopy {'&T_PHBOOL32 ; Huge pointer to 32-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_PHBOOL64
        zCopy {'&T_PHBOOL64 ; Huge pointer to 64-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PBOOL08
        zCopy {'&T_32PBOOL08 ; 16:32 near pointer to 8-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PBOOL16
        zCopy {'&T_32PBOOL16 ; 16:32 near pointer to 16-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PBOOL32
        zCopy {'&T_32PBOOL32 ; 16:32 near pointer to 32-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PBOOL64
        zCopy {'&T_32PBOOL64 ; 16:32 near pointer to 64-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFBOOL08
        zCopy {'&T_32PFBOOL08 ; 16:32 far pointer to 8-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFBOOL16
        zCopy {'&T_32PFBOOL16 ; 16:32 far pointer to 16-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFBOOL32
        zCopy {'&T_32PFBOOL32 ; 16:32 far pointer to 32-bit Boolean - Hex Value:  ', 0}
    ..Else_If W$esi = &T_32PFBOOL64
        zCopy {'&T_32PFBOOL64 ; 16:32 far pointer to 64-bit Boolean - Hex Value:  ', 0}
    ..End_if

EndP
_____________________________________
; Non Primitive Types, can be interpreted as the leaf types, for values bigger then 01000
Proc WriteCVNonPrimitiveTypeEquates:
    Uses esi

        ; For values bigger or equal to 01000, it is probably that they are related to leaf type indices, because
        ; they are related to Non-Primitive types

        .If W$esi = &LF_ENUMERATE_CV2
            zCopy {'&LF_ENUMERATE_CV2; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_ARRAY_CV2
            zCopy {'&LF_ARRAY_CV2; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_CLASS_CV2
            zCopy {'&LF_CLASS_CV2; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_STRUCTURE_CV2
            zCopy {'&LF_STRUCTURE_CV2; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_UNION_CV2
            zCopy {'&LF_UNION_CV2; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_ENUM_CV2
            zCopy {'&LF_ENUM_CV2; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_MEMBER_CV2
            zCopy {'&LF_MEMBER_CV2; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_MODIFIER_CV3
            zCopy {'&LF_MODIFIER_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_POINTER_CV3
            zCopy {'&LF_POINTER_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_ARRAY_CV3
            zCopy {'&LF_ARRAY_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_CLASS_CV3
            zCopy {'&LF_CLASS_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_STRUCTURE_CV3
            zCopy {'&LF_STRUCTURE_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_UNION_CV3
            zCopy {'&LF_UNION_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_ENUM_CV3
            zCopy {'&LF_ENUM_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_PROCEDURE_CV3
            zCopy {'&LF_PROCEDURE_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_MFUNCTION_CV3
            zCopy {'&LF_MFUNCTION_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_COBOL0_CV3
            zCopy {'&LF_COBOL0_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_BARRAY_CV3
            zCopy {'&LF_BARRAY_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_DIMARRAY_CV3
            zCopy {'&LF_DIMARRAY_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_VFTPATH_CV3
            zCopy {'&LF_VFTPATH_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_PRECOMP_CV3
            zCopy {'&LF_PRECOMP_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_OEM_CV3
            zCopy {'&LF_OEM_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_SKIP_CV3
            zCopy {'&LF_SKIP_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_ARGLIST_CV3
            zCopy {'&LF_ARGLIST_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_DEFARG_CV3
            zCopy {'&LF_DEFARG_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_FIELDLIST_CV3
            zCopy {'&LF_FIELDLIST_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_DERIVED_CV3
            zCopy {'&LF_DERIVED_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_BITFIELD_CV3
            zCopy {'&LF_BITFIELD_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_METHODLIST_CV3
            zCopy {'&LF_METHODLIST_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_DIMCONU_CV3
            zCopy {'&LF_DIMCONU_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_DIMCONLU_CV3
            zCopy {'&LF_DIMCONLU_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_DIMVARU_CV3
            zCopy {'&LF_DIMVARU_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_DIMVARLU_CV3
            zCopy {'&LF_DIMVARLU_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_BCLASS_CV3
            zCopy {'&LF_BCLASS_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_VBCLASS_CV3
            zCopy {'&LF_VBCLASS_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_IVBCLASS_CV3
            zCopy {'&LF_IVBCLASS_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_FRIENDFCN_CV3
            zCopy {'&LF_FRIENDFCN_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_INDEX_CV3
            zCopy {'&LF_INDEX_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_MEMBER_CV3
            zCopy {'&LF_MEMBER_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_STMEMBER_CV3
            zCopy {'&LF_STMEMBER_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_METHOD_CV3
            zCopy {'&LF_METHOD_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_NESTTYPE_CV3
            zCopy {'&LF_NESTTYPE_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_VFUNCTAB_CV3
            zCopy {'&LF_VFUNCTAB_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_FRIENDCLS_CV3
            zCopy {'&LF_FRIENDCLS_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_ONEMETHOD_CV3
            zCopy {'&LF_ONEMETHOD_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_VFUNCOFF_CV3
            zCopy {'&LF_VFUNCOFF_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_NESTTYPEEX_CV3
            zCopy {'&LF_NESTTYPEEX_CV3; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_CHAR
            zCopy {'&LF_CHAR; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_NUMERIC
            zCopy {'&LF_NUMERIC; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_SHORT
            zCopy {'&LF_SHORT; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_USHORT
            zCopy {'&LF_USHORT; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_LONG
            zCopy {'&LF_LONG; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_ULONG
            zCopy {'&LF_ULONG; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_REAL32
            zCopy {'&LF_REAL32; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_REAL64
            zCopy {'&LF_REAL64; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_REAL80
            zCopy {'&LF_REAL80; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_REAL128
            zCopy {'&LF_REAL128; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_QUADWORD
            zCopy {'&LF_QUADWORD; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_UQUADWORD
            zCopy {'&LF_UQUADWORD; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_REAL48
            zCopy {'&LF_REAL48; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_COMPLEX32
            zCopy {'&LF_COMPLEX32; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_COMPLEX64
            zCopy {'&LF_COMPLEX64; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_COMPLEX80
            zCopy {'&LF_COMPLEX80; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_COMPLEX128
            zCopy {'&LF_COMPLEX128; - Hex Value:  ', 0}
        .Else_If W$esi = &LF_VARSTRING
            zCopy {'&LF_VARSTRING; - Hex Value:  ', 0}
        .Else_If W$esi = &CV_FIRST_NONPRIM
            zCopy {'&CV_FIRST_NONPRIM; - Hex Value:  ', 0}
        .End_If

EndP

[MemberSize2: ?]

Proc WriteCVBPRel32OffsetComment:
    Arguments @dwValue
    Uses esi, eax, ebx, edx, ecx

    mov eax D@dwValue

    If eax = 0
        zCopy {" ; This symbol cannot be evaluated because its location is unknown.", 0}
    End_If

    jns @sign
        push eax
            zCopy {" ; This is a Local variable: ebp-", 0}
            neg eax
            call WriteEax
        pop eax
            zCopy {" , ebp+", 0}
            call WriteEax
            ExitP
@sign:

        ..If eax < 8
            zCopy {" ; Incorrect Symbol Allocation. This can be a Data Pointer, and not a Local Var or a Argument for this function.", 0}
        ..Else
            mov ecx eax
            sub eax 8

            ..If eax = 0
                zCopy {" ; This is a Parameter: ebp+08. Argument = 1. RosAsm Style: Arg1", 0}
            ..Else

                ; divide eax by 4 to calculate how many parameters we have, and if it is a multiple of 4 or not.
                mov edx 0, ebx 4
                div ebx

                If edx = 0

                    inc eax ; Increment eax to display the proper amount of Arguments.

                    push eax
                        zCopy {" ; This is a Parameter: ebp+", 0}
                        mov eax ecx | call WriteEax
                    pop eax

                    zCopy {". Argument = ", 0}

                    push esi
                    push edi
                    push eax
                        ; Calculate and Display Size (Convert Hexa do Decimal String)
                        mov D$membersize2 eax
                        mov esi membersize2, ecx 4
                        call toUDword
                        mov esi edi, edi DecimalBuffer
                        Do | movsb | LoopUntil B$esi-1 = 0
                    pop eax
                    pop edi
                    pop esi

                    zCopy DecimalBuffer
                    zCopy {". RosAsm Style: Arg", 0}
                    zCopy DecimalBuffer
                Else
                    zCopy {" ; Incorrect Symbol Allocation. This can be a Data Pointer, and not a Local Var or a Argument for this function.", 0}
                End_If

            ..End_If

        ..End_If

EndP
_____________________________________

Proc WriteRawDataDebugSBPRel32Item:
    Argument @Text1, @Text2
    uses eax, ecx

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy {'BPRel32.', 0}
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1

        ..If D$eax = 'Offs' ; from "Offset" string
            lodsd | call WriteEax
            call WriteCVBPRel32OffsetComment D$esi-4

        ..Else_If D$eax = 'OldC'; From "OldCVType" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Type'; From "Type" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP

________________

[CVBPRel32Offset: 'Offset' , 0
 CVBPRel32OldCVType: 'OldCVType', 0
 CVBPRel32Type: 'Type' , 0
 CVBPRel32Namelenght: 'NameLenght' , 0
 CVBPRel32Name: 'Name' , 0]


Proc WriteRawDataDebugSBPRel32:
    Local @OldCodeView
    Uses ecx

    mov D@OldCodeView &FALSE
    If W$esi-2 = &S_BPREL32_CV3
        mov D@OldCodeView &TRUE
    End_If


    Call WriteRawDataDebugSBPRel32Item CVBPRel32Offset , {': D$ ', 0}
    If D@OldCodeView = &TRUE
        Call WriteRawDataDebugSBPRel32Item CVBPRel32OldCVType , {': W$ ', 0}
    End_If
    Call WriteRawDataDebugSBPRel32Item CVBPRel32Type , {': W$ ', 0}
    Call WriteRawDataDebugSBPRel32Item CVBPRel32Namelenght , {': B$ ', 0}
    Call WriteRawDataDebugSBPRel32Item CVBPRel32Name , {': B$ ', 0}

EndP

__________________________________________________________________

[CVLocalData32OldCVType: 'OldCVType', 0
 CVLocalData32Offset: 'Offset' , 0
 CVLocalData32Segment: 'Segment' , 0
 CVLocalData32Type: 'Type' , 0
 CVLocalData32Namelenght: 'NameLenght' , 0
 CVLocalData32Name: 'Name' , 0]

[CVLocalData32Label: B$ 0 #20]

Proc WriteRawDataDebugSLData32:
    Local @OldCodeView
;    Uses ecx
    Uses ecx, eax, ebx

    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx

    push ebx

    If W$esi-2 = &S_LDATA32
        move D$CVLocalData32Label {'LocalData32.', 0}
    Else_If_Or W$esi-2 = &S_GDATA32, W$esi-2 = &S_GDATA_CV3
        move D$CVLocalData32Label {'GlobalData32.', 0}
    Else
        move D$CVLocalData32Label {'PublicData32.', 0}
    End_If

    If W$esi-2 = &S_GDATA_CV3
        mov D@OldCodeView &TRUE
    End_If

    If D@OldCodeView = &TRUE
        Call WriteRawDataDebugSLData32Item CVLocalData32OldCVType , {': D$ ', 0}
    End_If

    Call WriteRawDataDebugSLData32Item CVLocalData32Offset , {': D$ ', 0}
    Call WriteRawDataDebugSLData32Item CVLocalData32Segment , {': W$ ', 0}
    Call WriteRawDataDebugSLData32Item CVLocalData32Type , {': W$ ', 0}
    Call WriteRawDataDebugSLData32Item CVLocalData32Namelenght , {': B$ ', 0}
    Call WriteRawDataDebugSLData32Item CVLocalData32Name , {': B$ ', 0}

    pop ebx

    ; Is the end of this structure ends on the proper place ?

    .If esi <> ebx
        mov W$edi CRLF | add edi 2
        call WriteCVdataTitle
        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If


EndP

______________________________________

Proc WriteRawDataDebugSLData32Item:
    Argument @Text1, @Text2
    uses eax, ecx

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {".Index", 0}
            zCopy DebugNumber
            zCopy D$CVLabel
            zCopy D$CVLocalData32Label
            zCopy D@Text1
            zCopy D@Text2
        pop esi

        mov eax D@Text1


        ..If D$eax = 'OldC'; From "OldCVType" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Offs'; From "Offset" string
            lodsd | call WriteEax

        ..Else_If D$eax = 'Segm'; From "Segment" string
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax = 'Type'; From "Type" string
            call WriteCVBPRel32TypeEquates
            xor eax eax
            lodsw | call WriteEax

        ..Else_If D$eax+4 = 'Leng'; From "NameLenght" string
            xor eax eax
            lodsb | call WriteEax

        ..Else_If D$eax = 'Name'; From "Name" string

            ; ecx points to the size of the Name
            movzx ecx B$esi-1
            mov edx esi | add edx ecx

            .If B$esi = 0
                mov B$edi '0' | inc edi | inc esi
            .Else

                mov B$edi "'" | inc edi
L0:             lodsb
                If al = 0
                    dec esi | jmp L1>
                End_If
                stosb | On esi < edx, jmp L0<
L1:             mov B$edi "'" | inc edi

            .End_If

            While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

        ..End_If

        mov W$edi CRLF | add edi 2

EndP


__________________________________________________________________


[CVDataLenght: 'Length', 0
 CVDataIndex: 'Index', 0]

[SizeAdd: D$ 0]
[CVLabel: B$ 0 #6]
[CV5Label: B$ '.CV5.' , 0] ; found in some .NET Object Files
[CV4Label: B$ '.CV4.' , 0]
[CV3Label: B$ '.CV3.' , 0]
[CV2Label: B$ '.CV2.' , 0] ; Unknown CV Signature

Proc WriteRawDataDebugS:
    Local @CVSize, @RawDataEnd
    Uses ecx, esi, eax

    mov ecx esi
    add ecx D$CoffSectionSize
    mov D@RawDataEnd ecx

    ; If Signature is not 1. Do a byte chain. Signature = 1 is Code or CodeView 4 ?. Other values are data or CodeView older versions ?

    .If D$esi = 1
        move D$CVLabel CV4Label
        jmp L0>>
    .Else_If D$esi = 2
        move D$CVLabel CV3Label
        jmp L0>>
    .Else_If D$esi = 4
        sub edi 4
        push esi | ZCopy {D$ CRLF2, B$ '; This Codeview format is unespecified. It is common for Dot NET files. ', D$ CRLF2, B$ '    B$: ', 0} | pop esi
        mov ecx D$CoffSectionSize
        call WriteRawDataDataSection
        ExitP
    .Else    ;   Sometimes they do not contain signatures like in: clusapi2.obj
        move D$CVLabel CV2Label
        mov D$SizeAdd 0
        call InitSectionDebugNumber
        move D@CVSize D$CoffSectionSize
        sub edi 4
        add D@CVSize esi ; CVSize points to the beginning of the Debug Raw Data
        mov W$edi CRLF | add edi 2
        mov D$edi '    ' | add edi 4
        push esi | zCopy {'; This Debug Section have no signature.', 0} | pop esi
        mov W$edi CRLF | add edi 2
        jmp L1>>

    .End_If

L0:

    mov D$SizeAdd 0

    call InitSectionDebugNumber

    move D@CVSize D$CoffSectionSize
    sub edi 4

    mov D$edi CRLF2 | add edi 4

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy D$CVLabel
        zCopy {'Signature: D$ ', 0}
    pop esi


        add D@CVSize esi ; CVSize points to the beginning of the Debug Raw Data

        lodsd | call WriteEax

        If D$esi-4 = 1
            push esi | ZCopy {" ; The compiler that made this Object File, emitted OMF (Object Module Format) types on it's symbols and Types below", 0} | pop esi
        End_If

        mov W$edi CRLF | add edi 2

   L1:

    .While esi <> D@RawDataEnd

        movzx eax W$esi
        mov D$SizeAdd eax

        ...If_Or W$esi = 0, W$esi+2 = 0 ; If lenght = 0 , or index = 0 do next line
            add esi 2 ; only increment esi by 2
        ...Else

            .If_Or W$esi+2 = &S_GPROC32, W$esi+2 = &S_LPROC32, W$esi+2 = &S_THUNK32, W$esi+2 = &S_GPROC32_CV3
                push esi | ZCopy {D$ CRLF2, B$ '; ---------------------- Procedure Start  ---------------------- ', W$ CRLF, 0} | pop esi
            .End_If

            call WriteRawDataDebugSItem CVDataLenght, {': W$ ', 0}
            call WriteRawDataDebugSItem CVDataIndex, {': W$ ', 0}

            ..If_Or W$esi-2 = &S_COMPILE, W$esi-2 = &S_COMPILE_CV3, W$esi-2 = &S_COMPILE_CV2
                call WriteRawDataDebugSCompile

            ..Else_If W$esi-2 = &S_MSTOOL_CV2 ; found in acos.obj This is a variation of S_COMPILE found in older versions of codeview
                call WriteRawDataDebugSMsTool

            ..Else_If_Or W$esi-2 = &S_REGISTER, W$esi-2 = &S_REGISTER_CV3; Register variable
                call WriteRawDataDebugSRegister

            ..Else_If_Or W$esi-2 = &S_CONSTANT, W$esi-2 = &S_CONSTANT_CV3, W$esi-2 = &S_CONSTANT_CV2 ; Constant symbol (frmMainNET.obj)
                call WriteRawDataDebugSContant

            ..Else_If_Or W$esi-2 = &S_UDT, W$esi-2 = &S_UDT_CV3, W$esi-2 = &S_UDT_CV2; User-defined Type (frmMainNET.obj)
                call WriteRawDataDebugSUDT

            ..Else_If W$esi-2 = &S_SSEARCH ; Start search
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_END ; End block, procedure, with, or thunk
                push esi | ZCopy {W$ CRLF, B$ '; ---------------------- Procedure End  ---------------------- ', D$ CRLF2, 0} | pop esi

            ..Else_If W$esi-2 = &S_SKIP ; Skip - Reserve symbol space
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_CVRESERVE ; Reserved for internal use by the Microsoft debugger
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_OBJNAME ; Specify name of object file
                call WriteRawDataDebugSObjectName

            ..Else_If W$esi-2 = &S_ENDARG ; Specify end of arguments in function symbols
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_COBOLUDT ; Microfocus COBOL user-defined type
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_MANYREG ; Many register symbol
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_RETURN ; Function return description
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_ENTRYTHIS ; Description of this pointer at entry
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_BPREL16 ; BP relative 16:16
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_LDATA16 ; Local data 16:16
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_GDATA16 ; Global data 16:16
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_PUB16 ; Public symbol 16:16
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_LPROC16 ; Local procedure start 16:16
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_GPROC16 ; Global procedure start 16:16
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_THUNK16 ; Thunk start 16:16
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_BLOCK16 ; Block start 16:16
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_WITH16 ; With start 16:16
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_LABEL16 ; Code label 16:16
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_CEXMODEL16 ; Change execution model 16:16
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_VFTPATH16 ; Virtual function table path descriptor 16:16
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_REGREL16 ; Specify 16:16 offset relative to arbitrary register
                mov eax eax
                jmp L0>>

            ..Else_If_Or W$esi-2 = &S_BPREL32, W$esi-2 = &S_BPREL32_CV3 ; BP relative 16:32
                call WriteRawDataDebugSBPRel32
            ..Else_If W$esi-2 = &S_LDATA32 ; Local data 16:32
                call WriteRawDataDebugSLData32

            ..Else_If_Or W$esi-2 = &S_GDATA32, W$esi-2 = &S_GDATA_CV3 ; Global data 16:32
                call WriteRawDataDebugSLData32

            ..Else_If W$esi-2 = &S_PUB32 ; Public symbol 16:32
                call WriteRawDataDebugSLData32

            ..Else_If W$esi-2 = &S_LPROC32 ; Local (Static) procedure start 16:32
                call WriteRawDataDebugSGlobalProc
            ..Else_If_Or W$esi-2 = &S_GPROC32, W$esi-2 = &S_GPROC32_CV3 ; Global procedure start 16:32
                call WriteRawDataDebugSGlobalProc
            ..Else_If W$esi-2 = &S_THUNK32 ; Thunk start 16:32
                call WriteRawDataDebugSThunkStart1632

            ..Else_If W$esi-2 = &S_BLOCK32 ; Block start 16:32
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_VFTPATH32 ; Virtual function table path descriptor 16:32
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_REGREL32 ; 16:32 offset relative to arbitrary register
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_LTHREAD32 ; Local Thread Storage data
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_GTHREAD32 ; Global Thread Storage data
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_LPROCMIPS ; Local procedure start MIPS
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_GPROCMIPS ; Global procedure start MIPS
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_PROCREF ; Reference to a procedure
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_DATAREF ; Reference to data
                mov eax eax
                jmp L0>>

            ..Else_If W$esi-2 = &S_ALIGN ; Page align symbols
                mov eax eax
                jmp L0>>

            ..Else_If_Or W$esi-2 >= 01000;, W$esi-2 >= 0
L0:
                push esi
                    mov D$edi '    ' | add edi 4
                    call WriteObjIndice
                    zCopy {"Sec", 0}
                    zCopy SectionHeaderNumber
                    zCopy {".Index", 0}
                    zCopy DebugNumber
                    zCopy D$CVLabel
                    zCopy {'Unknown', 0}
                pop esi
                call WriteRawDataDebugSUnknown

        ..End_If

    ...End_If

        call IncrementSectionDebugNumber
        mov eax D@CVSize
        mov W$edi CRLF | add edi 2

;    .Loop_Until esi >= eax
    .End_While
EndP
__________________________________________________________________

Proc WriteRawDataDebugSUnknown:
    Uses eax, ecx


    ; This is to avoid that the Structure have dummy bytes at the end.
    mov ebx esi
    sub ebx 2
    mov ecx D$SizeAdd
    add ebx ecx
;;
    push ebx

                    push esi
                        mov D$edi '    ' | add edi 4
                        call WriteObjIndice
                        zCopy {"Sec", 0}
                        zCopy SectionHeaderNumber
                        zCopy {".Index", 0}
                        zCopy DebugNumber
                        zCopy D$CVLabel
                        zCopy {'Constant.LeafType.Unknown: B$ ', 0}
                    pop esi
    pop ebx
;;
;;

    push ebx
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayElemType , {': W$ ', 0}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayIdxType , {': W$ ', 0}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayLength, {': W$ ', 0}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayNamelenght, {': B$ ', 0}
        Call WriteRawDataDebugSContantLeafTypeArrayItem CVLeafTypeArrayName, {': B$ ', 0}
        sub edi 2
    pop ebx
;;
    ; Is the end of this structure ends on the proper place ?
    .If esi <> ebx
;;
        mov W$edi CRLF | add edi 2
        ;call WriteCVdataTitle
                    push esi
                        mov D$edi '    ' | add edi 4
                        call WriteObjIndice
                        zCopy {"Sec", 0}
                        zCopy SectionHeaderNumber
                        zCopy {".Index", 0}
                        zCopy DebugNumber
                        zCopy D$CVLabel
                        zCopy {'Constant.LeafType.Unknown: B$ ', 0}
                    pop esi

;;
        push esi | ZCopy {'.Unknown: B$ ', 0} | pop esi

        push ecx

        mov edx 0
        xor eax eax

        Do

            movzx eax B$esi
            push ebx | call WriteEax | pop ebx

            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If

        Loop_Until esi = ebx

            sub edi 2
            dec edi
            mov W$edi+1 CRLF | add edi 2
            pop ecx
            inc edi
    .Else
        mov W$edi CRLF | add edi 2
    .End_If

EndP

__________________________________________________________________



Proc WriteRawDataDebugT:
    Local @CVSize, @RawDataEnd
    Uses ecx, esi, eax

    mov ecx esi
    add ecx D$CoffSectionSize
    mov D@RawDataEnd ecx

    ; If Signature is not 1. Do a byte chain. Signature = 1 is Code or CodeView 4 ?. Other values are data or CodeView older versions ?
    If D$esi = 1
        move D$CVLabel CV4Label
        jmp L0>
    Else_If D$esi = 2
        move D$CVLabel CV3Label
        jmp L0>
    Else_If D$esi = 4
        move D$CVLabel CV5Label ; found in NET files. This is really really painfull.
        jmp L0>
    Else
        call WriteRawDataDataSection
        ExitP
    End_If

L0:

    mov D$SizeAdd 0

    call InitSectionDebugNumber

    move D@CVSize D$CoffSectionSize
    sub edi 4

    mov D$edi CRLF2 | add edi 4

    push esi
        mov D$edi '    ' | add edi 4
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy D$CVLabel
        zCopy {'Signature: D$ ', 0}
    pop esi

        add D@CVSize esi ; CVSize points to the beginning of the Debug Raw Data

        lodsd | call WriteEax
        If D$esi-4 = 1
            push esi | ZCopy {" ; The compiler that made this Object File, emitted OMF (Object Module Format) types on it's symbols and Types below", 0} | pop esi
        End_If

        mov W$edi CRLF | add edi 2

        ; sometimes we may have a file with only the Signature Byte. (Size of raw data is 4 in VBAEXE6.LIB)
        On D@RawDataEnd = esi, ExitP

    .Do
        movzx eax W$esi
        mov D$SizeAdd eax

        ...If W$esi = 0 ; If lenght = 0 do next line
            add esi 2 ; only increment esi by 2

        ...Else

            push eax

            push esi
                mov D$edi '    ' | add edi 4
                call WriteObjIndice

                zCopy {"Sec", 0}
                zCopy SectionHeaderNumber
                zCopy {".Index", 0}
                zCopy DebugNumber
                zCopy D$CVLabel
                zCopy {"Length: W$ ", 0}
            pop esi

                xor eax eax
                lodsw | call WriteEax

            mov W$edi CRLF | add edi 2
            pop eax

            call WriteRawDataDebugSContantLeafTypeItem

    ...End_If

        call IncrementSectionDebugNumber
        mov eax D@CVSize
        mov W$edi CRLF | add edi 2

    .Loop_Until esi >= eax

EndP

__________________________________________________________________

Proc WriteRawDataDebugFItem:
    Argument @Text1, @Text2
    uses eax

        push esi
            mov D$edi '    ' | add edi 4
            call WriteObjIndice

            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber

            zCopy {'.FPOData', 0}
            mov B$edi '.' | inc edi
            zCopy D@Text1
            zCopy D@Text2
        pop esi

                mov eax D@Text1

                If D$eax = 'ulOf' ; from "ulOffStart" string
                    lodsd | call WriteEax
                    ;call WriteSectionHeaderRawSizeDiffLabel
                    ;push esi | zcopy {" ; Hex Value:  ", 0} | pop esi

                Else_If D$eax+2 = 'Proc'; From "cbProcSize" string
                    lodsd | call WriteEax
                    ;call WriteSectionHeaderPointerToDataDiffLabel
                    ;push esi | zcopy {" ; Hex Value:  ", 0} | pop esi

                Else_If D$eax = 'cdwL'; From "cdwLocals" string
                    lodsd | call WriteEax
                    ;call InitSectionRelocNumber
                    ;call WriteSectionHeaderPointerToRelocDiffLabel
                    ;push esi | zcopy {" ; Hex Value:  ", 0} | pop esi

                Else_If D$eax = 'cdwP'; From "cdwParams" string
                    xor eax eax
                    lodsw | call WriteEax
                    ;call InitSectionLineNumber
                    ;call WriteSectionHeaderPointerToLineNumberDiffLabel
                    ;push esi | zcopy {" ; Hex Value:  ", 0} | pop esi

                Else_If D$eax+2 = 'Prol'; From "cbProlog" string
                    xor eax eax
                    lodsb | call WriteEax
                    ;call InitSectionLineNumber
                    ;call WriteSectionHeaderPointerToLineNumberDiffLabel
                    ;push esi | zcopy {" ; Hex Value:  ", 0} | pop esi

                Else_If D$eax = 'Func'; From "FunctionSpec" string
                    xor eax eax
                    lodsb | call WriteEax
                    ;call InitSectionLineNumber
                    ;call WriteSectionHeaderPointerToLineNumberDiffLabel
                    ;push esi | zcopy {" ; Hex Value:  ", 0} | pop esi

                End_If

        mov W$edi CRLF | add edi 2
EndP


;;
 similar to WriteImageSymbolTable and GetCoffSectionHeader
 Uses FPO_DATA Structure. The FPO_DATA in the structures.str is wrong, the correct is:

[FPOData:
 FPOData.ulOffStart: D$ 0
 FPOData.cbProcSize: D$ 0
 FPOData.cdwLocals: D$ 0
 FPOData.cdwParams: W$ 0
 FPOData.cbProlog: B$ 0
 FPOData.FunctionSpec: B$ 0]
;;

[RawDataulOffStart: 'ulOffStart', 0
 RawDatacbProcSize: 'cbProcSize', 0
 RawDatacdwLocals: 'cdwLocals', 0
 RawDatacdwParams: 'cdwParams', 0
 RawDatacbProlog: 'cbProlog', 0
 RawDataFunctionSpec: 'FunctionSpec', 0]


WriteRawDataDebugF:

    sub edi 4

    mov D$edi CRLF2 | add edi 4
    call WriteRawDataDebugFItem RawDataulOffStart, {': D$ ', 0}
    call WriteRawDataDebugFItem RawDatacbProcSize, {': D$ ', 0}
    call WriteRawDataDebugFItem RawDatacdwLocals, {': D$ ', 0}
    call WriteRawDataDebugFItem RawDatacdwParams, {': W$ ', 0}
    call WriteRawDataDebugFItem RawDatacbProlog, {': B$ ', 0}
    call WriteRawDataDebugFItem RawDataFunctionSpec, {': B$ ', 0}

ret
__________________________________________________________________

WriteRawDataOnlyStringsSection:

    ; Initialize the String Record Counter

    call InitStringTableRecord
    push esi
        call WriteObjIndice
        zCopy {"Sec", 0}
        zCopy SectionHeaderNumber
        zCopy {'.StringData.Signature', 0}
        mov D$edi ': B$', B$edi+4 ' ' | add edi 5
    pop esi
        While B$esi <> 0 | movsb | End_While
    xor eax eax
    lodsb | call WriteEax

    mov W$edi CRLF | add edi 2

    mov edx D$CoffSectionSize
    dec edx
    add edx, esi ; We will use edx as a counter delimiter for the strings

   .Do

        push esi
            call WriteObjIndice
            zCopy {"Sec", 0}
            zCopy SectionHeaderNumber
            zCopy {'.StringData.Arr', 0}
            zCopy StringTableRecord
            zCopy {": B$ '", 0}
        pop esi


        While B$esi <> 0 | movsb | End_While | inc esi | On B$esi = 0, mov edx 0

        mov D$edi "', 0" | add edi 4
        mov W$edi CRLF | add edi 2

        call IncrementStringTableRecord

    .Loop_Until esi >= edx

    sub edi 2
    mov W$edi CRLF | add edi 2
ret

__________________________________________________________________

WriteRawDataDataSection:

L0:         movzx eax B$esi | call WriteEax
            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If
            loop L0<

            sub edi 2
ret
__________________________________________________________________

WriteRawDataCodeSection:

L0:         movzx eax B$esi | call WriteEax
            mov W$edi ', ' | add edi 2 | inc esi
            inc edx
            If edx > 15
                mov W$edi CRLF | add edi 2 | mov edx 0
                mov D$edi '    ', D$edi+4 '    ' | add edi 8
            End_If
            loop L0<

            sub edi 2

ret
__________________________________________________________________

WriteRawDataLinkerDirective:

    mov edx esi | add edx ecx

    .If B$esi = 0
        mov B$edi '0' | inc edi | inc esi
    .Else

        mov B$edi "'" | inc edi
L0:     lodsb
        If al = 0
            dec esi | jmp L1>
        End_If
        stosb | On esi < edx, jmp L0<
L1:     mov B$edi "'" | inc edi

    .End_If

    While esi < edx | lodsb | mov D$edi ', 0' | add edi 3 | End_While

ret
__________________________________________________________________

WriteRawdataEnd:

    mov W$edi CRLF | add edi 2
    call WriteObjIndice
    zCopy {"Sec", 0}
    zCopy SectionHeaderNumber
    zCopy {".RawDataEnd", 0}
    zCopy {":]", CRLF2}
ret
__________________________________________________________________

Proc WriteRawdataTitle:
    Uses esi, ecx

    zCopy CoffRawDataSectionTitle
    call WriteObjIndice
    zCopy {"ImgSecHdr", 0}
    zCopy SectionHeaderNumber
    zCopy {B$ ".PointerToRawData", W$ CRLF, 0}

    mov W$edi CRLF, B$edi+2 '[' | add edi 3
    call WriteObjIndice
    zCopy {"Sec", 0}
    zCopy SectionHeaderNumber
    zCopy {'.RawData', 0}
    mov D$edi ': B$', B$edi+4 ' ' | add edi 5

EndP
__________________________________________________________________

[CoffRawDataInfoTitle: B$ "_________________________________________________________

; Raw Data Info
_________________________________________________________
", 0]

[CoffRawDataSectionTitle: "
; These are the Raw Data Values referenced at: ", 0]

Proc WriteCoffSectionData:
    Uses esi, eax, ecx, edx


    ...If D$CoffSectionSize = 0

    ...Else_If D$CoffPointerToData = 0 ; Is the Pointer to Raw Data = 0 ? Yes, exit

    ...Else

        push esi | zCopy CoffRawDataInfoTitle | pop esi
        ; esi points to the Begin of the Raw data section, ecx points to the size of the raw data
        mov esi D$CoffSectionBase | add esi D$CoffPointerToData
        mov ecx D$CoffSectionSize, edx 0

        ..If D$RawDataType = RDT_LNKDIRECTIVE
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    Linker Directive Reports:", D$ CRLF2, 0} | pop esi
                call WriteRawDataLinkerDirectiveReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataLinkerDirective

        ..Else_If D$RawDataType = RDT_CODE
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to CODE", D$ CRLF2, 0} | pop esi
                ; call WriteRawDataCodeSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataCodeSection

        ..Else_If D$RawDataType = RDT_VIRTUALDATA
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to Virtual Data", D$ CRLF2, 0} | pop esi
                ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_DEBUGS
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to Debug$S", D$ CRLF2, 0} | pop esi
                ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            ;call WriteRawDataDebugS
            call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_DEBUGF
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to Debug$F - Frame Point Omission", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDebugFReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDebugF

        ..Else_If D$RawDataType = RDT_DEBUGT
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to Debug$T - Debug Type", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDataSection
            ;call WriteRawDataDebugT

        ..Else_If D$RawDataType = RDT_DEBUGP
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to Debug$P", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle
            call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_STABSTR
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to NetFramework strings section - stabstr", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle
            sub edi 4
            mov W$edi CRLF | add edi 2
            call WriteRawDataOnlyStringsSection

        ..Else_If D$RawDataType = RDT_IDATA
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to Import Table Data - idata", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_RDATA
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to Read-Only Data - rdata", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_XDATA
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to Exception information - xdata", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_PDATA
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to Exception information - pdata", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_EDATA
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to Export tables - edata", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_TLSDATA
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to Thread-local storage - tls", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_RELOCDATA
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to Image relocations - reloc", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_RSRCDATA
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to resources - rsrc", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDataSection

        ..Else_If D$RawDataType = RDT_ERROR
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    There was an error on the debug or the data section. These raw values will be assumed as DATA", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDataSection

        ..Else
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            push esi | zCopy {B$ "    This Raw Data is related only to DATA", D$ CRLF2, 0} | pop esi
            ; call WriteRawDataDataSectionReport
            mov W$edi CRLF, W$edi+2 ';;', W$edi+4 CRLF | add edi 6
            call WriteRawdataTitle

            call WriteRawDataDataSection

        ..End_If

        call WriteRawdataEnd

    ...End_If

EndP



;;
  Values set in 'FirstSectionPointer', 'NumberOfRelocations', 'CoffPointerToReloc'
  by 'GetCoffSectionsVariables'.
;;

WriteCoffReloc:

    call InitSectionRelocNumber

    push esi
        mov esi D$CoffSectionBase | add esi D$CoffPointerToReloc
        mov ecx D$NumberOfRelocations

L0:     push ecx
            call GetCoffRelocHeader
            call IncrementSectionRelocNumber
        pop ecx

        loop L0<
    pop esi
ret



WriteCoffLineNumber:
    call InitSectionLineNumber
    push esi
        mov esi D$CoffSectionBase | add esi D$CoffPointerToLineNumber
        mov ecx D$NumberOfLineNumbers

L0:     push ecx
            call GetCoffLineHeader
            call IncrementSectionLineNumber
        pop ecx

        loop L0<
    pop esi
ret


____________________________________________________________________________________________




[ImageFileEquate: B$ '&IMAGE_FILE_', 0
 IMAGE_FILE_16BIT_MACHINE: '16BIT_MACHINE', 0
 IMAGE_FILE_32BIT_MACHINE: '32BIT_MACHINE__', 0
 IMAGE_FILE_AGGRESSIVE_WS_TRIM: 'AGGRESSIVE_WS_TRIM', 0
 IMAGE_FILE_BYTES_REVERSED_HI: 'BYTES_REVERSED_HI__', 0
 IMAGE_FILE_BYTES_REVERSED_LO: 'BYTES_REVERSED_LO__', 0
 IMAGE_FILE_DEBUG_STRIPPED: 'DEBUG_STRIPPED__', 0
 IMAGE_FILE_DLL: 'DLL__', 0
 IMAGE_FILE_EXECUTABLE_IMAGE: 'EXECUTABLE_IMAGE__', 0
 IMAGE_FILE_LARGE_ADDRESS_AWARE: 'LARGE_ADDRESS_AWARE__', 0
 IMAGE_FILE_LINE_NUMS_STRIPPED: 'LINE_NUMS_STRIPPED__', 0
 IMAGE_FILE_LOCAL_SYMS_STRIPPED: 'LOCAL_SYMS_STRIPPED__', 0
 IMAGE_FILE_NET_RUN_FROM_SWAP: 'NET_RUN_FROM_SWAP__', 0
 IMAGE_FILE_RELOCS_STRIPPED: 'RELOCS_STRIPPED__', 0
 IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP: 'REMOVABLE_RUN_FROM_SWAP__', 0
 IMAGE_FILE_SYSTEM: 'SYSTEM__', 0
 IMAGE_FILE_UP_SYSTEM_ONLY: 'UP_SYSTEM_ONLY__', 0]


WriteObjCharacteristics:
    push esi

    mov D$edi ' ; ' | add edi 3

    test eax &IMAGE_FILE_32BIT_MACHINE | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_32BIT_MACHINE

L1: test eax &IMAGE_FILE_16BIT_MACHINE | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_16BIT_MACHINE

L1: test eax &IMAGE_FILE_BYTES_REVERSED_HI | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_BYTES_REVERSED_HI

L1: test eax &IMAGE_FILE_AGGRESSIVE_WS_TRIM | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_AGGRESSIVE_WS_TRIM

L1: test eax &IMAGE_FILE_BYTES_REVERSED_LO | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_BYTES_REVERSED_LO

L1: test eax &IMAGE_FILE_DEBUG_STRIPPED | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_DEBUG_STRIPPED

L1: test eax &IMAGE_FILE_DLL | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_DLL

L1: test eax &IMAGE_FILE_EXECUTABLE_IMAGE | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_EXECUTABLE_IMAGE

L1: test eax &IMAGE_FILE_LARGE_ADDRESS_AWARE | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_LARGE_ADDRESS_AWARE

L1: test eax &IMAGE_FILE_LINE_NUMS_STRIPPED | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_LINE_NUMS_STRIPPED

L1: test eax &IMAGE_FILE_LOCAL_SYMS_STRIPPED | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_LOCAL_SYMS_STRIPPED

L1: test eax &IMAGE_FILE_NET_RUN_FROM_SWAP | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_NET_RUN_FROM_SWAP

L1: test eax &IMAGE_FILE_RELOCS_STRIPPED | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_RELOCS_STRIPPED

L1: test eax &IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP

L1: test eax &IMAGE_FILE_SYSTEM | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_SYSTEM

L1: test eax &IMAGE_FILE_UP_SYSTEM_ONLY | jz L1>
        zCopy ImageFileEquate, IMAGE_FILE_UP_SYSTEM_ONLY

L1: pop esi

    While B$edi-1 = '_' | dec edi | End_While
ret

____________________________________________________________________________________________
____________________________________________________________________________________________
;;
  Data, Equates used more than once
;;

[COFF_HEADER_SIZE 03C    ARCH_TAG 8
 LIB_USER_ID 01C         LIB_MEMBER_SIZE 030]

[IMAGE_ARCHIVE_MEMBER_HEADERstring: ' Structure: IMAGE_ARCHIVE_MEMBER_HEADER', 0]
____________________________________________________________________________________________

;;
  This is called multiple times
;;

[MemberSize: ?]

GetMemberSize:
    push esi
        mov ecx 10, ebx 0, eax 0
        While B$esi > ' '
            mul ecx
            push eax
                lodsb | sub al '0' | mov bl al
            pop eax
            add eax ebx
        End_While
        mov D$MemberSize eax
    pop esi
ret

______________________________

[MemberDate: ?]

GetMemberDate:
    push esi
        mov ecx 10, ebx 0, eax 0
        While B$esi > ' '
            mul ecx
            push eax
                lodsb | sub al '0' | mov bl al
            pop eax
            add eax ebx
        End_While
        mov D$MemberDate eax
    pop esi
ret

______________________________

Proc WriteNamesLinkerMemberX:
    Argument @Name, @n, @LinkerMember
    Local @Item

        push esi
            mov esi D@LinkerMember
            While B$esi <> 0 | movsb | End_While

            mov B$edi '.' | inc edi
            mov esi D@Name

            move D@Item D$esi

            If D$esi = 'Size'
                pop esi | push esi
                call GetMemberSize
                mov esi D@Name

            Else_If D$esi = 'Date'
                pop esi | push esi
                call GetMemberDate
                mov esi D@Name
            End_If

            While B$esi <> 0 | movsb | End_While
        pop esi

        mov D$edi ': B$' | add edi 4

        .If D@n <> 0-2

            mov W$edi " '" | add edi 2
            mov ecx D@n

            If D@Item = 'User'
                mov D$edi '****', W$edi+4 '**' | add edi 6 | sub ecx 6 | add esi 6
            End_If

            rep movsb

            While B$edi-1 = 0 | dec edi | End_While

            mov B$edi "'" | inc edi
            mov W$edi CRLF | add edi 2

        .Else
            mov B$edi ' ' | inc edi
            mov ecx D@n | neg ecx
L0:         lodsb | and eax 0FF | call WriteEax | mov W$edi ', ' | add edi 2 | loop L0<
            sub edi 2

        .End_If
EndP

____________________________________________________________________________________________

[LibObjIndice: '000001', 0]

InitCoffIndice:
    mov D$LibObjIndice '0000', D$LibObjIndice+4 '01'
ret

IncrementLibCoffIndice:
    lea ebx D$LibObjIndice+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret

WriteCoffIndice:
    push esi
        mov D$edi 'Obj_' | add edi 4
        mov eax D$LibObjIndice, D$edi eax
        mov ax W$LibObjIndice+4, W$edi+4 ax
        mov D$edi+6 ': ; ' | add edi 10
    pop esi
ret


_________________________________________________________

[szDateString: B$ ? #64]
[szTimeString: B$ ? #64]

Proc WriteLinkerMemberTimeDateStamp:
    Arguments @TimeDate
    Uses esi

        ; Write the Value of the Date in Hexadecimal string
        mov esi {' ; Hex Value:  ', 0}
        sub edi 2 ; We need to subtract 02 Bytes, to bypass the CRLF
        While B$esi <> 0 | movsb | End_While
        mov eax D@TimeDate
        call Writeeax

        mov esi {' - TimeDate Stamp: ', 0}
        While B$esi <> 0 | movsb | End_While

      ; Get the DateTime Stamp

      ; Time date stamp to string Function
        call TimeDateStampToString D@TimeDate, {"yyyy/MM/dd ddd ", 0},
                                   {"HH:mm:ss UTC", 0}, szDateString, szTimeString

      ; Write the TimeDate Stamp strings
        mov esi szDateString
        While B$esi <> 0 | movsb | End_While

        mov esi szTimeString
        While B$esi <> 0 | movsb | End_While

      ; We now Add the paragraphs marks, and add 02 Bytes at edi:
        mov W$edi CRLF | add edi 2


EndP

_________________________________________________________

Proc WriteLinkerMemberSizeHex:
    Arguments @SizeValue
    Uses esi
    ; Write the Value of the Size in Hexadecimal string

        mov esi {' ; Hex Value:  ', 0}
        sub edi 2 ; We need to subtract 02 Bytes, to bypass the CRLF
        While B$esi <> 0 | movsb | End_While
        mov eax D@SizeValue
        call Writeeax
        mov W$edi CRLF | add edi 2 ; We now Add the paragraphs marks, and add 02 Bytes at edi

EndP
_________________________________________________________


[NamesLinkerMember: 'NamesLinkerMember'
 ARCHIVE_MEMBER_HEADER_Indice: '000001', 0]


[NamesLinkerMember1: 'NamesLinkerMember_1', 0]

Write_IMAGE_ARCHIVE_MEMBER_HEADER_1:
    mov B$edi '[' | inc edi

    call WriteNamesLinkerMemberX {'Name1', 0}, 16, NamesLinkerMember1
    call WriteNamesLinkerMemberX {'Date', 0}, 12, NamesLinkerMember1
    call WriteLinkerMemberTimeDateStamp D$MemberDate
    call WriteNamesLinkerMemberX {'UserID', 0}, 6, NamesLinkerMember1
    call WriteNamesLinkerMemberX {'GroupID', 0}, 6, NamesLinkerMember1
    call WriteNamesLinkerMemberX {'Mode', 0}, 8, NamesLinkerMember1
    call WriteNamesLinkerMemberX {'Size1', 0}, 10, NamesLinkerMember1
    call WriteLinkerMemberSizeHex D$MemberSize
    call WriteNamesLinkerMemberX {'EndHeader', 0}, 0-2, NamesLinkerMember1

    mov B$edi ']', D$edi+1 CRLF2 | add edi 5

    lea ebx D$ARCHIVE_MEMBER_HEADER_Indice+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret


[NamesLinkerMember2: 'NamesLinkerMember_2', 0]

Write_IMAGE_ARCHIVE_MEMBER_HEADER_2:
    mov B$edi '[' | inc edi

    call WriteNamesLinkerMemberX {'Name1', 0}, 16, NamesLinkerMember2
    call WriteNamesLinkerMemberX {'Date', 0}, 12, NamesLinkerMember2
    call WriteLinkerMemberTimeDateStamp D$MemberDate
    call WriteNamesLinkerMemberX {'UserID', 0}, 6, NamesLinkerMember2
    call WriteNamesLinkerMemberX {'GroupID', 0}, 6, NamesLinkerMember2
    call WriteNamesLinkerMemberX {'Mode', 0}, 8, NamesLinkerMember2
    call WriteNamesLinkerMemberX {'Size1', 0}, 10, NamesLinkerMember2
    call WriteLinkerMemberSizeHex D$MemberSize
    call WriteNamesLinkerMemberX {'EndHeader', 0}, 0-2, NamesLinkerMember2

    mov B$edi ']', D$edi+1 CRLF2 | add edi 5

    lea ebx D$ARCHIVE_MEMBER_HEADER_Indice+3 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret


[NamesLinkerMember3: 'NamesLinkerMember_3', 0]

Write_IMAGE_ARCHIVE_MEMBER_HEADER_3:
    mov B$edi '[' | inc edi

    call WriteNamesLinkerMemberX {'Name1', 0}, 16, NamesLinkerMember3
    call WriteNamesLinkerMemberX {'Date', 0}, 12, NamesLinkerMember3
    call WriteLinkerMemberTimeDateStamp D$MemberDate
    call WriteNamesLinkerMemberX {'UserID', 0}, 6, NamesLinkerMember3
    call WriteNamesLinkerMemberX {'GroupID', 0}, 6, NamesLinkerMember3
    call WriteNamesLinkerMemberX {'Mode', 0}, 8, NamesLinkerMember3
    call WriteNamesLinkerMemberX {'Size1', 0}, 10, NamesLinkerMember3
    call WriteLinkerMemberSizeHex D$MemberSize
    call WriteNamesLinkerMemberX {'EndHeader', 0}, 0-2, NamesLinkerMember3

    mov B$edi ']', D$edi+1 CRLF2 | add edi 5

    lea ebx D$ARCHIVE_MEMBER_HEADER_Indice+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret

[CoffTitle: "

_____________________________________________________________________________________________
_____________________________________________________________________________________________

; The Coff File Format Starts here. Indice: ", 0]

WriteCoffTitle:
    push esi
        mov esi CoffTitle | While B$esi <> 0 | movsb | End_While
        mov eax D$LibObjIndice, D$edi eax,
            ax W$LibObjIndice+4, W$edi+4 ax,
            D$edi+6 CRLF2 | add edi 10
    pop esi
ret


[Obj_LIB_USER_ID: 'Obj_'
 CopyOf_LIB_USER_ID: '000001', 0]

Proc Write_Obj_IMAGE_ARCHIVE_MEMBER_HEADER:
    Local @StartAddress

    mov B$edi '[' | inc edi

    ...If B$esi = '/'
      ; First or Second Header: nop
        ..If B$esi+1 <> ' '
          ; Case of Obj with LongNames Table in the Third Header:
            call WriteCoffIndice
            push esi
                inc esi
                If D$LongNamesBase <> 0
                    call CheckLongNameDisplacement | On eax = &FALSE, jmp L1>
                    ; to be used in AddListviewItem
                    mov D$StartObjNameAddress edi
                    call WriteLongName esi
                Else

   L1:
                    ; to be used in AddListviewItem
                    mov D$StartObjNameAddress edi
                    call CopyObjSymbolName

                End_If
                mov esi IMAGE_ARCHIVE_MEMBER_HEADERstring
                While B$esi <> 0 | movsb | End_While
                mov W$edi CRLF | add edi 2
            pop esi
        ..Else
            ; There seem to exist case of Functions called by Number, here
            mov D$StartObjNameAddress edi

            call WriteCoffIndice
            While B$esi <> 0 | movsb | End_While
            push esi
                mov esi IMAGE_ARCHIVE_MEMBER_HEADERstring
                While B$esi <> 0 | movsb | End_While
                mov W$edi CRLF | add edi 2
            pop esi

        ..End_If

    ...Else
      ; Case of Obj without LongNames Table (No Third Header) Ex.: UUID.LIB ; WLDAP32.LIB:
        call WriteCoffIndice

        mov D$StartObjNameAddress edi
        push esi

            call CopyObjSymbolName
            mov esi IMAGE_ARCHIVE_MEMBER_HEADERstring
            While B$esi <> 0 | movsb | End_While
            mov W$edi CRLF | add edi 2
        pop esi

    ...End_If

    call ParseLibObjectSymbolName D$StartObjNameAddress

    mov eax D$esi+LIB_USER_ID, D$CopyOf_LIB_USER_ID eax,
        ax W$esi+LIB_USER_ID+4, W$CopyOf_LIB_USER_ID+4 ax

    call WriteNamesLinkerMemberX {'Name1', 0}, 16, Obj_LIB_USER_ID
    call WriteNamesLinkerMemberX {'Date', 0}, 12, Obj_LIB_USER_ID
    call WriteLinkerMemberTimeDateStamp D$MemberDate
    call WriteNamesLinkerMemberX {'UserID', 0}, 6, Obj_LIB_USER_ID
    call WriteNamesLinkerMemberX {'GroupID', 0}, 6, Obj_LIB_USER_ID
    call WriteNamesLinkerMemberX {'Mode', 0}, 8, Obj_LIB_USER_ID
    call WriteNamesLinkerMemberX {'Size1', 0}, 10, Obj_LIB_USER_ID
    call WriteLinkerMemberSizeHex D$MemberSize
    call WriteNamesLinkerMemberX {'EndHeader', 0}, 0-2, Obj_LIB_USER_ID

    mov B$edi ']', D$edi+1 CRLF2 | add edi 5

    lea ebx D$ARCHIVE_MEMBER_HEADER_Indice+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While

EndP
____________________________________________________________________________________________


; This function is to be used for displaying the object file name in the list view

; Built this way to solve really weird file nameings paths like:

;;
[Obj_000009: ; Long Name: wizard\wizard.obj Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000001: ; Short Name: poide.exe Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000004: ; Short Name: poide.exe Function Name: _WizAddProjectFileA@4 Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000050: ; Long Name: unwind-dw2-fde.o Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000235 ; Short Name: $UWD\except.obj Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000235 ; Long Name: $UWD\validadd.obj Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000135 ; Long Name: ../XXX\nanonano.obj Structure: IMAGE_ARCHIVE_MEMBER_HEADER
[Obj_000134 ; Long Name: ./.XXX/nanonano.obj Structure: IMAGE_ARCHIVE_MEMBER_HEADER
;;

[ObjectName: B$ 0 #256]
[StartObjNameAddress: D$ 0]
[EndObjNameAddress: D$ 0]
[ObjExtensionStr: B$ 0 #16]
[UseObjExtension: D$ 0]
[ExportedLibrary: D$ 0]
[ExportedLibraryStr: B$ 0 #256]
[UseObjPath: D$ 0]
[ObjPathStr: B$ 0 #256]

Proc ParseLibObjectSymbolName:
    Arguments @StartAddress
    Local @TempEndAddr, @TempStartAddr, @StartExportObjAddr, @EndObjPathAddr, @StartObjExtensionAddr, @UseExportedLibrary

    pushad

    ; Always clear the loaded data before use.
    call ClearBuffer ObjectName, 256
    call ClearBuffer ObjExtensionStr, 16
    call ClearBuffer ObjPathStr, 256

    ; Initialize all the data
    mov D$ObjFileNameType 0
    mov D$UseObjPath 0
    mov D$UseObjExtension 0
    mov D@TempStartAddr 0
    mov D@TempEndAddr 0
    mov D@StartExportObjAddr 0
    mov D@UseExportedLibrary 0

    mov esi D@StartAddress

    ; 1St Step. Locate the start and the end of the String, and also get the FileNameType and the check Exported Library
    mov ecx 0 ; we will use ecx as a counter.
              ; The maximum size allowed for this is 784 bytes (Max path + Max Object Name + Max exported Lib string + Max extension)
    .While ecx <> (256*3+16)

        .If_And D$esi = 'Long', D$esi+4 = ' Nam' ; is it a Long Name string type ?

            ; to be used in AddListviewItem
            mov D$ObjFileNameType 1
            add D@StartAddress 11 ; (String len) "Long Name: "

        .Else_If_And D$esi = 'Shor', D$esi+4 = 't Na' ; is it a Short Name string type ?

            ; to be used in AddListviewItem
            mov D$ObjFileNameType 0
            add D@StartAddress 12 ; (String len) "Short Name: "

        .Else_If_And D$esi = ' Fun', D$esi+4 = 'ctio', D$esi+8 = 'n Na', D$esi+12 = 'me: '

            ; to be used in AddListviewItem
            mov D@StartExportObjAddr esi
            mov D@UseExportedLibrary 1

        .Else_If_And D$esi = ' Str', D$esi+4 = 'uctu', D$esi+8 = 're: ' ; Did we reached the end of the string ?
                                                                        ; Our string always ends with " Structure: "
            mov D@TempEndAddr esi
            jmp L1>

        .End_If
        inc ecx
        inc esi
    .End_While

   L1:


    ; 2nd Step. Now that we have the start and ending address, we must check if we are dealing with a non-common format.
    ; These formats always have the String " Function Name: " on it. Copy it to the proper buffer (ExportedLibraryStr)

    .If D@UseExportedLibrary = 1
        mov esi D@StartExportObjAddr
        move D@TempEndAddr D@StartExportObjAddr
    .End_If


    ; 3rd Step. Now that we have our full string, we need to see if it have any path inside.
    ; We must start from the end to the beginning of the string to find the path chars.
    mov esi D@StartAddress
    mov ecx D@TempEndAddr

    .While esi <> ecx

        If_Or B$ecx = '/', B$ecx = '\'

            mov D@EndObjPathAddr ecx
            mov D$UseObjPath 1
            jmp L1>
        End_If

        dec ecx
    .End_While

   L1:

    ; 4th Step. If we have a Path, we will copy it to the proper Buffer (ObjPathStr)

    .If D$UseObjPath = 1
        ; Here esi is already defined as the starting point. We don't need to change it now.
        mov ecx D@EndObjPathAddr
        mov edi ObjPathStr

        .While esi <> ecx
            movsb
            ;inc esi
        .End_While
        inc esi ; Bypass the last "/" or "\" char preceeding the object name.
        mov D@StartAddress esi ; Will points to the beginning of the object name only

    .End_If

    ; 5th Step. At this point we have only the name of the object and it's extension (if any).
    ; So we must find and copy the object extension.

    mov esi D@StartAddress
    mov ecx D@TempEndAddr
    mov edi ObjectName

    On esi = ecx, jmp L2> ; If the end and starting address is teh same ones, it is an empty string

    .Do

        .If B$esi = '.'
            mov D$UseObjExtension 1
            mov edi ObjExtensionStr
            inc esi ; Bypass the "." char
            While esi <> ecx
                movsb
            End_While
            jmp L2>
        .End_If

        movsb
    .Loop_Until esi = ecx

   L2:

    popad
EndP

____________________________________________________________________________________________


ParseLibObj:
    push esi
        ...If W$esi = &IMAGE_FILE_MACHINE_UNKNOWN
            ..If W$esi+2 = &IMPORT_OBJECT_HDR_SIG2
              ; +12 is the 'NameType'. 0 >>> Ordinal for the Function,
              ; that should be at +10...
                .If W$esi+012 <> 0
                    call WriteLibImportObj
                    add esi 014
                    call WriteImportObjStrings

                .Else
                    ;call SendMeThisLib
                    call WriteLibImportObj

                    movzx eax W$esi+010
                    mov edx D$esi+0C
                    add esi 014
                    add edx esi
                    mov ebx esi | While B$ebx <> 0 | inc ebx | End_While | inc ebx
                    If ebx < edx
                        call WriteImportObjStrings
                    Else
                        call WriteImportObjStringAndOrdinal eax
                    End_If
                .End_If

            ..Else
                ; to be added in AddListviewItem
                ; Always clear the loaded data before use.
                call ClearBuffer ExportedLibraryStr, 256
                mov D$ExportedLibrary 0
                call GetCoffListing

            ..End_If

        ...Else
            ; to be added in AddListviewItem
            ; Always clear the loaded data before use.
            call ClearBuffer ExportedLibraryStr, 256
            mov D$ExportedLibrary 0
            call GetCoffListing

        ...End_If
    pop esi
ret
____________________________________________________________________________________________

[IMAGE_FILE_MACHINE_Text:
 &IMAGE_FILE_MACHINE_UNKNOWN, '&IMAGE_FILE_MACHINE_UNKNOWN', 0
 &IMAGE_FILE_MACHINE_ALPHA, '&IMAGE_FILE_MACHINE_ALPHA', 0
 &IMAGE_FILE_MACHINE_ALPHA64, '&IMAGE_FILE_MACHINE_ALPHA64', 0
 &IMAGE_FILE_MACHINE_ARM, '&IMAGE_FILE_MACHINE_ARM', 0
 &IMAGE_FILE_MACHINE_AXP64, '&IMAGE_FILE_MACHINE_AXP64', 0
 &IMAGE_FILE_MACHINE_CEF, '&IMAGE_FILE_MACHINE_CEF', 0
 &IMAGE_FILE_MACHINE_I386, '&IMAGE_FILE_MACHINE_I386', 0
 &IMAGE_FILE_MACHINE_I486, '&IMAGE_FILE_MACHINE_I486', 0
 &IMAGE_FILE_MACHINE_I586, '&IMAGE_FILE_MACHINE_I586', 0
 &IMAGE_FILE_MACHINE_IA64, '&IMAGE_FILE_MACHINE_IA64', 0

 &IMAGE_FILE_MACHINE_M68K, '&IMAGE_FILE_MACHINE_M68K', 0
 &IMAGE_FILE_MACHINE_MIPS16, '&IMAGE_FILE_MACHINE_MIPS16', 0
 &IMAGE_FILE_MACHINE_MIPSFPU, '&IMAGE_FILE_MACHINE_MIPSFPU', 0
 &IMAGE_FILE_MACHINE_MIPSFPU16, '&IMAGE_FILE_MACHINE_MIPSFPU16', 0
 &IMAGE_FILE_MACHINE_POWERPC, '&IMAGE_FILE_MACHINE_POWERPC', 0
 &IMAGE_FILE_MACHINE_R10000, '&IMAGE_FILE_MACHINE_R10000', 0
 &IMAGE_FILE_MACHINE_R3000, '&IMAGE_FILE_MACHINE_R3000', 0
 &IMAGE_FILE_MACHINE_R4000, '&IMAGE_FILE_MACHINE_R4000', 0
 &IMAGE_FILE_MACHINE_R6000, '&IMAGE_FILE_MACHINE_R6000', 0
 &IMAGE_FILE_MACHINE_SH3, '&IMAGE_FILE_MACHINE_SH3', 0

 &IMAGE_FILE_MACHINE_SH3E, '&IMAGE_FILE_MACHINE_SH3E', 0
 &IMAGE_FILE_MACHINE_SH4, '&IMAGE_FILE_MACHINE_SH4', 0
 &IMAGE_FILE_MACHINE_SH5, '&IMAGE_FILE_MACHINE_SH5', 0
 &IMAGE_FILE_MACHINE_SH3DSP, '&IMAGE_FILE_MACHINE_SH3DSP', 0
 &IMAGE_FILE_MACHINE_THUMB, '&IMAGE_FILE_MACHINE_THUMB', 0
 &IMAGE_FILE_MACHINE_WCEMIPSV2, '&IMAGE_FILE_MACHINE_WCEMIPSV2', 0
 &IMAGE_FILE_MACHINE_AM33, '&IMAGE_FILE_MACHINE_AM33', 0
 &IMAGE_FILE_MACHINE_AMD64, '&IMAGE_FILE_MACHINE_AMD64', 0
 &IMAGE_FILE_MACHINE_CEE, '&IMAGE_FILE_MACHINE_CEE', 0
 &IMAGE_FILE_MACHINE_EBC, '&IMAGE_FILE_MACHINE_EBC', 0

 &IMAGE_FILE_MACHINE_M32R, '&IMAGE_FILE_MACHINE_M32R', 0
 &IMAGE_FILE_MACHINE_POWERPCFP, '&IMAGE_FILE_MACHINE_POWERPCFP', 0
 &IMAGE_FILE_MACHINE_TRICORE, '&IMAGE_FILE_MACHINE_TRICORE', 0, 0-1, 0-1]

[UnKown_IMAGE_FILE_MACHINE: ' ; Unknown or corrupted IMAGE_FILE_MACHINE', 0]

Proc WriteIMAGE_FILE_MACHINE:
    Argument @Type
    Uses esi

        mov esi IMAGE_FILE_MACHINE_Text, eax D@Type | and eax 0FFFF

        ..While D$esi <> 0-1
            .If D$esi = eax
                add esi 4 | While B$esi <> 0 | movsb | End_While | ExitP
            .Else
                add esi 5
                .While B$esi <> '&'
                    inc esi
                    If D$esi = 0-1
                        call WriteEax
                        mov esi UnKown_IMAGE_FILE_MACHINE
                        While B$esi <> 0 | movsb | End_While | ExitP
                    End_If
                .End_While
                sub esi 4
            .End_If
        ..End_While
EndP


Proc IsIMAGE_FILE_MACHINE:
    Argument @Type
    Uses esi

        mov esi IMAGE_FILE_MACHINE_Text, eax D@Type | and eax 0FFFF

        .While D$esi <> 0-1
            .If D$esi = eax
                mov eax &TRUE | ExitP
            .Else
                add esi 5
                While B$esi <> '&'
                    inc esi
                    If D$esi = 0-1
                        mov eax &FALSE | ExitP
                    End_If
                End_While
                sub esi 4
            .End_If
        .End_While
EndP

____________________________________________________________________________________________



;;
 
 
 LibScan_ErrManager
 _____________________
 
    This function manages the error cases of the LIbScanner system
 
 Parameters: 
 
    ErrFlag: Handle to the error message. The equates used on this function are:

    IMP_OBJ_RESBIT_ERR = 01 ; Reserved Bits are not Zero
    IMP_OBJ_UNKTYPE_ERR = 02 ; Unknown Type
    

        PE_DATADIRSMALL 01 = The Directory Entry is located before the 1st section, on the DosHeader or in the PEHeader.
 
 Return values:
 
    Return &TRUE if  the user wants to contine analysing the file.
    Return &FALSE if he wants to stop the analysis.
 
 
;;

;[PE_DATADIRSMALL 01]
;[PE_DIRDATADOS 02]
;[PE_DIRDATASIZE 03]
;[PE_DIRDATAUNKNOWN 04]

[IMP_OBJ_RESBIT_ERR 01]
[IMP_OBJ_UNKTYPE_ERR 02]


Proc LibScan_ErrManager:
    Arguments @ErrFlag
    Uses edx ; messagebox function changes the value of edx...So we need to preserve it, because we will use it.

    mov eax D@ErrFlag

    .If eax = IMP_OBJ_RESBIT_ERR


        call 'USER32.MessageBoxA' 0, {"CORRUPTED LIBRARY !!!

The reserved Bits for the ImpObjHdr.Type member of the structure IMPORT_OBJECT_HEADER
on this Library are not Zero.

RosAsm can continue loading this file, but we will set the reserved Bits to ZERO to you be able to load this safelly.

* Press the YES button to set the necessary bits to Zero.
* Press the NO button to end analysing this file.
  
If after the automatically fix, this file still have errors, please, report this error to the author at:
  Betov@free.fr

Or report this error to the Development Team at the main RosAsm Forum.

Many thanks in advance. Betov.
  
", 0}, {'Corrupted Library', 0}, &MB_SYSTEMMODAL__&MB_ICONEXCLAMATION__&MB_YESNO

            If eax = &IDNO
                mov eax &FALSE
            Else_If eax = &IDYES
                mov eax &TRUE
            End_If

    .Else_If eax = IMP_OBJ_UNKTYPE_ERR

          call 'USER32.MessageBoxA' D$hwnd {"UNKNOWN TYPE !!!.

The reserved Bits for the ImpObjHdr.Type member of the structure IMPORT_OBJECT_HEADER
on this Library are of a Unknown Type.

The regular Type values of this member can not be 3, 7, 11, 15 to 31.

Your file have one of those unknown types.

RosAsm can't continue loading this file.

Please, report this error to the author, and send this file to the author at:
  Betov@free.fr

Or report this error to the Development Team at the main RosAsm Forum.

Many thanks in advance. Betov." 0} {"Unknown Type" 0} &MB_SYSTEMMODAL__&MB_ICONEXCLAMATION

            mov eax &FALSE

    .End_If

EndP


____________________________________________________________________________________________

[ImpObjHdrSig1Text: B$ 'ImpObjHdr.Sig1: W$ &IMAGE_FILE_MACHINE_UNKNOWN', 0
 ImpObjHdrSig2Text: 'ImpObjHdr.Sig2: W$ &IMPORT_OBJECT_HDR_SIG2', 0
 ImpObjHdrVersionText: 'ImpObjHdr.Version: W$ ', 0
 ImpObjHdrMachineText: 'ImpObjHdr.Machine: W$ ', 0
 ImpObjHdrTimeDateStampText: 'ImpObjHdr.TimeDateStamp: D$ ', 0
 ImpObjHdrSizeOfDataText: 'ImpObjHdr.SizeOfData: D$ ', 0
 ImpObjHdrOrdinalText: 'ImpObjHdr.Ordinal.Hint: W$ ', 0
 ImpObjHdrType: 'ImpObjHdr.Type: W$ ', 0]

WriteObjIndice:
    mov D$edi 'Obj',
        ecx D$LibObjIndice, D$edi+3 ecx,
        cx W$LibObjIndice+4, W$edi+7 cx

    add edi 9

    mov B$edi '.' | inc edi
ret


WriteIndiceOnly:
    mov ecx D$LibObjIndice, D$edi ecx, cx W$LibObjIndice+4, W$edi+4 cx
    add edi 6
ret


Proc WriteLibImportObjItem:
    Arguments @Text, @Flag
    Uses esi

        call WriteObjIndice

        mov esi D@Text | While B$esi <> 0 | movsb | End_While

        If D@Text = ImpObjHdrMachineText
            call WriteIMAGE_FILE_MACHINE eax

        Else_If D@Text = ImpObjHdrType
            ; Need to increase edi with CRLF at the end, because when  the function returns, it
            ; decreases edi by 2. And we need to close the bracket after the paragraph, due to the commented
            ; Hexadecimal Value below.
            push eax
            call WriteLibImportObjType eax
            pop eax
            zCopy {' ; Hex Value:  ', 0}
            call WriteEax
            mov W$edi CRLF | add edi 2

        Else_If D@Text = ImpObjHdrSizeOfDataText

            push esi
                call WriteObjIndice
                zCopy {'ImportStringsEnd', 0}
            pop esi

            mov D$edi ' - ' | add edi 3
            push esi
                call WriteObjIndice
                zCopy {'ImportStrings ; Hex Value:  ', 0}
            pop esi
            call WriteEax

        Else_If B@Flag = &TRUE
            call WriteEax

        End_If

        mov W$edi CRLF | add edi 2
EndP

____________________________________________________________________________________________


[LibImportObjType:
; Bits 0 and 1:

 IMPORT_OBJECT_CODE: '&IMPORT_OBJECT_CODE', 0
 IMPORT_OBJECT_DATA: '&IMPORT_OBJECT_DATA', 0
 IMPORT_OBJECT_CONST: '&IMPORT_OBJECT_CONST', 0

; Bits 2 to 3 (SHRed) >>> 0 to 1
 IMPORT_OBJECT_NAME: '&IMPORT_OBJECT_NAME', 0
 IMPORT_OBJECT_NAME_NO_PREFIX: '&IMPORT_OBJECT_NAME_NO_PREFIX', 0
 IMPORT_OBJECT_NAME_UNDECORATE: '&IMPORT_OBJECT_NAME_UNDECORATE', 0
 IMPORT_OBJECT_ORDINAL: '&IMPORT_OBJECT_ORDINAL', 0
]


;;
  Example, if a Type Word would be:
  
  '&IMPORT_OBJECT_DATA' and '&IMPORT_OBJECT_NAME_NO_PREFIX'
  
  The Assembly representation would be:
  
  &IMPORT_OBJECT_DATA + (&IMPORT_OBJECT_NAME_NO_PREFIX shl 2)
;;

;;

    We have at eax the ImpObjHdr.Type member that is a WORD data. Accordying to the documentation, we only
    are interested in Bits 0 to 3 to use for Type and NameType members interpretations.
    Bit4 is for Unknown Type and should not be considered to analysis at the present moment.
    Bits 5 to 15 are reserved and should be setlled to 0 accordying to the docs, because they are not
    interpreteded and are not used whatsoever.
    
    A Word data have a maximum value of 0FFFF (65535), meaning that bits 0 to 15 are all settled to 1.
    
    Since bits 5 to 15 are not used, we can set them all to 0, that will result on a maximum value for this member of
    31 (Bits 0 to 4 are all settled to 1, then).
    
    Now, our WORD have a maximum range of 31.
    
    Accordying to the docs, we can have a possible set of Equates under the following form:
 
    EQUATES Forms                                               Value   Bits Sets                       Union
    
    &IMPORT_OBJECT_CODE+(&IMPORT_OBJECT_ORDINAL shl 2)          = 0     No Bits are Flaged              Ordinal
    &IMPORT_OBJECT_CODE+(&IMPORT_OBJECT_NAME shl 2)             = 4     Only Bit2 is flaged             Hint
    &IMPORT_OBJECT_CODE+(&IMPORT_OBJECT_NAME_NO_PREFIX shl 2)   = 8     Only Bit3 is flaged             Hint
    &IMPORT_OBJECT_CODE+(&IMPORT_OBJECT_NAME_UNDECORATE shl 2)  = 12    Only Bit2 and Bit3 are flaged   Hint
     
    &IMPORT_OBJECT_DATA+(&IMPORT_OBJECT_ORDINAL shl 2)          = 1     Only Bit0 is flaged             Ordinal
    &IMPORT_OBJECT_DATA+(&IMPORT_OBJECT_NAME shl 2)             = 5     Only Bit0 and Bit2 are flaged   Hint
    &IMPORT_OBJECT_DATA+(&IMPORT_OBJECT_NAME_NO_PREFIX shl 2)   = 9     Only Bit0 and Bit3 are flaged   Hint
    &IMPORT_OBJECT_DATA+(&IMPORT_OBJECT_NAME_UNDECORATE shl 2)  = 13    Only Bit0,Bit2,Bit3 are flaged  Hint
 
    &IMPORT_OBJECT_CONST+(&IMPORT_OBJECT_ORDINAL shl 2)         = 2     Only Bit1 is flaged             Ordinal
    &IMPORT_OBJECT_CONST+(&IMPORT_OBJECT_NAME shl 2)            = 6     Only Bit1 and Bit2 are flaged   Hint
    &IMPORT_OBJECT_CONST+(&IMPORT_OBJECT_NAME_NO_PREFIX shl 2)  = 10    Only Bit1 and Bit3 are flaged   Hint
    &IMPORT_OBJECT_CONST+(&IMPORT_OBJECT_NAME_UNDECORATE shl 2) = 14    Only Bit1,Bit2,Bit3 are flaged  Hint

    
    So, All values equal or above 14 are not allowed and also we can not have the following values and interpretations:
    So, from values between 31 and 14 we have an Unknown Type. All Values bigger or equal then 32 we have a corrupted
    Library because the reserved Fields are not 0.
    
    The list of Uknown Types are:
    03; 07; 11, 15 to 31

   Ex.: We have a WORD with the value of 4073. So we clean the high bits resulting, like this:
                mov eax 4073 | mov ah 0 ; Bits 8 to 15 settled to 0)
        
        Now we must clear the bits 5 to 7, because they are unused. Like this:
         btr eax 5 | btr eax 6 | btr eax 7 ; I´m using this, because it is probably faster on big files.
         
        Or we can also do this:
        shl eax 3 | mov ah 0 | shr eax 3
        
   
   
;;

[SymNameType: B$ 0] ; Holds the NameType value to be used to Skip the leading chars on NameType member.

Proc WriteLibImportObjType:
    Argument @Flags
    Uses esi, ebx

        mov eax D@Flags

        .If_And eax >= 32, eax <= 65535 ; Check for Corrupted library. Reserved Bits are not 0

            call LibScan_ErrManager IMP_OBJ_RESBIT_ERR

            If eax = &FALSE ; The user pressed No
                ExitP

            Else_If eax = &TRUE ; The user pressed Yes. We will Zero all reserved bits for him continue the parsing.
                mov eax D@Flags ; Restore the original value of eax to be fixed
                mov ah 0 ; Clear High Bits Flags
                btr eax 5 | btr eax 6 | btr eax 7 ; Clear Bits 5 to 7

            End_If

        .End_If

        ; Check for Unknown Types


        test eax 010 | jz A1> ; Is Bit4 Flagged ? So, is eax = 16 to 31 ? No, jmp over
            call LibScan_ErrManager IMP_OBJ_UNKTYPE_ERR | ExitP
A1:
        test eax 1 | jz A2> ; Is bit0 flagged ? No...Ok, we don´ have any unknown types (15, 11, 7, 3)
            test eax 2 | jz A2> ; is bit1 also Flagged ? No...Ok, we don´ have any unknown types (15, 11, 7, 3) jmp over.

            call LibScan_ErrManager IMP_OBJ_UNKTYPE_ERR | ExitP ; Yes bit0 and bit1 are flagged, we have unknown types (15, 11, 7, 3)

A2:


    ; We are Ok. We have only the values 0,1,2,4,5,6,8,9,10,12,13,14 on eax

          ; First lower two Bits (Code / Data / Constant). We can only have one of the 02 bits set, or none of them.

            test eax &IMPORT_OBJECT_DATA | jz L1> ; Is Bit0 Flaged ? Yes, do next line. Values = 1,5,9,13
                mov esi IMPORT_OBJECT_DATA
                jmp L2>

L1:         test eax &IMPORT_OBJECT_CONST | jz L1> ; Is Bit1 Flaged ? Yes, do next line. Values = 2,6,10,14
                mov esi IMPORT_OBJECT_CONST
                jmp L2>

L1:         ; we don´ have bit0 and bit1 flagged. Values = 0,4,8,12
                mov esi IMPORT_OBJECT_CODE

L2:
                While B$esi <> 0 | movsb | End_While
                mov W$edi '+(' | add edi 2


          ; Second Part of the Record of Bits 2,3 (Ordinal, Name, NoPrefix, Undecorated)
          ; We can have all of the 02 bits set, or none of them.

                shr eax 2


            cmp eax &IMPORT_OBJECT_NAME_UNDECORATE | jnz L1> ; Is Bit0 and 1 Flaged ? Yes, do next line
                                                            ; Values = 12, 13, 14
                mov esi IMPORT_OBJECT_NAME_UNDECORATE
                mov B$SymNameType &IMPORT_OBJECT_NAME_UNDECORATE ; Save for later skip leading chars
                jmp L2>


L1:         test eax &IMPORT_OBJECT_NAME | jz L1> ; Is Bit0 Flaged ? Yes, do next line. Values = 4,5,6
                mov esi IMPORT_OBJECT_NAME
                jmp L2>

L1:         test eax &IMPORT_OBJECT_NAME_NO_PREFIX | jz L1> ; Is Bit1 Flaged ? Yes, do next line. Values = 8,9,10
                mov esi IMPORT_OBJECT_NAME_NO_PREFIX
                mov B$SymNameType &IMPORT_OBJECT_NAME_NO_PREFIX ; Save for later skip leading chars
                jmp L2>

L1:         ; we don't have bit0 and bit1 flagged. Values = 0,1,2
                mov esi IMPORT_OBJECT_ORDINAL

L2:
                While B$esi <> 0 | movsb | End_While
                mov D$edi ' shl', D$edi+4 ' 2)' | add edi 7

EndP


____________________________________________________________________________________________

Proc WriteImportObjHdrTimeDateStamp:
    Arguments @TimeDate
    Uses esi

        sub edi 2 ; We need to subtract 02 Bytes, to bypass the previous CRLF
        mov esi {' ; - TimeDate Stamp: ', 0}
        While B$esi <> 0 | movsb | End_While

        ; Get the DateTime Stamp

        ; Time date stamp to string Function
        call TimeDateStampToString D@TimeDate {"yyyy/MM/dd ddd ", 0} {"HH:mm:ss UTC", 0} szDateString szTimeString

        ; Write the TimeDate Stamp strings
        mov esi szDateString
        While B$esi <> 0 | movsb | End_While

        mov esi szTimeString
        While B$esi <> 0 | movsb | End_While

        mov W$edi CRLF | add edi 2 ; We now Add the paragraphs marks, and add 02 Bytes at edi

EndP
____________________________________________________________________________________________

[ImpObjDateStamp: ?]

WriteLibImportObj:

    push esi
        mov esi CoffListingTitle
        While B$esi <> 0 | movsb | End_While
        call WriteIndiceOnly
        mov B$edi ':', W$edi+1 CRLF | add edi 3
    pop esi

    ; To be used in AddListviewItem
    push esi
        mov D$LvOffsetCOFF 0 ; always initialize at 0 1st, due to the several loopings for each object.
        sub esi D$LibFileMemory
        mov D$LvOffsetCOFF esi
    pop esi

    push esi
;        mov B$edi '[' | inc edi

        call WriteLibImportObjItem ImpObjHdrSig1Text, &FALSE | add esi 2

        call WriteLibImportObjItem ImpObjHdrSig2Text, &FALSE | add esi 2

        movzx eax W$esi | add esi 2
        call WriteLibImportObjItem ImpObjHdrVersionText, &TRUE

        ; To be used in AddListviewItem
        mov W$CoffMachineType 0 ; always initialize at 0 1st, due to the several loopings for each object.
        move W$CoffMachineType W$esi

        movzx eax W$esi | add esi 2
        call WriteLibImportObjItem ImpObjHdrMachineText, &TRUE

        lodsd
        mov D$ImpObjDateStamp eax
        call WriteLibImportObjItem ImpObjHdrTimeDateStampText, &TRUE
        call WriteImportObjHdrTimeDateStamp D$ImpObjDateStamp

        lodsd
        If D$esi-4 <> 0
            call WriteLibImportObjItem ImpObjHdrSizeOfDataText, &TRUE
        Else

            push esi
                call WriteObjIndice
                zCopy ImpObjHdrSizeOfDataText
            pop esi
            call WriteEax
            mov W$edi CRLF | add edi 2
        End_If

        movzx eax W$esi | add esi 2
        call WriteLibImportObjItem ImpObjHdrOrdinalText, &TRUE

        movzx eax W$esi | add esi 2
        call WriteLibImportObjItem ImpObjHdrType, &TRUE

        mov B$edi-2 ']' | dec edi | mov D$edi CRLF2 | add edi 4
    pop esi
ret


[ImportStringsText: B$ "ImportStrings: B$ '", 0
 RosAsmInterpretation: "; RosAsm Interpretation: '", 0
 RosAsmUndecoratedName: "; Full Undecorated Name: ", 0]

;[UndecNameBuffer: D$ 0 #4000]
;[Size_Of_UndecNameBuffer 4000]

Proc WriteImportObjStrings:
    Uses ecx, esi

    mov D$edi '[' | inc edi
    mov D$edi 'Obj',
        eax D$LibObjIndice, D$edi+3 eax,
        ax W$LibObjIndice+4, W$edi+7 ax,
        B$edi+9 '.' | add edi 10
    push esi
        mov esi ImportStringsText | While B$esi <> 0 | movsb | End_While
    pop esi

    push esi
        ; to be added in AddListviewItem
        push esi
        push edi
            ; Always clear the loaded data before use.
            call ClearBuffer ExportedLibraryStr, 256
            mov D$ExportedLibrary 1
            mov edi ExportedLibraryStr
            While B$esi <> 0 | movsb | End_While
        pop edi
        pop esi


        ; Copy the Function Name:
        While B$esi <> 0 | movsb | End_While
        mov D$edi "', 0", D$edi+4 ", '" | add edi 7
        While B$esi = 0 | inc esi | End_While

        ; Copy the Module Name:
        push esi
            While B$esi <> 0 | movsb | End_While
            mov D$edi "', 0" | add edi 4
            mov W$edi CRLF | add edi 2
            push esi
                call WriteObjIndice
                zCopy {'ImportStringsEnd:]', 0}
            pop esi
            mov D$edi CRLF2 | add edi 4

            mov esi RosAsmInterpretation | While B$esi <> 0 | movsb | End_While
        pop esi

        ; Copy the Commented Module Name:
        While B$esi <> 0 | movsb | End_While
        mov eax D$edi-4 | or eax 020202000
        If eax = '.dll'
            sub edi 4
        End_If

        mov B$edi '.' | inc edi
    pop esi

    mov ecx esi ; Copy esi String to be used for name undecoration

  ; Copy the Commented Function Name:

    ; Remove 1st '_'; '@'; '?'
    .If B$SymNameType = &IMPORT_OBJECT_NAME_NO_PREFIX

        On B$esi = '_', inc esi
        On B$esi = '@', inc esi
        On B$esi = '?', inc esi

       While B$esi <> 0 | movsb | End_While

    ; Remove 1st '_'; '@'; '?' and truncate after next '@'.
    ; Ex:   _AbortPath@4 to AbortPath
    ;       ?WSCWriteProviderOrder@@YGHPAKK@Z to WSCWriteProviderOrder WS2_32.lib
    ;       ___CxxLongjmpUnwind@4 to __CxxLongjmpUnwind (MSVCRT.LIB)

    .Else_If B$SymNameType = &IMPORT_OBJECT_NAME_UNDECORATE

        On B$esi = '_', inc esi
        On B$esi = '@', inc esi
        On B$esi = '?', inc esi
        ; Ok, removed the above chars. No we need to truncate after findng the @
        While B$esi <> '@'

            On B$esi = 0, jmp L0> ; Sometimes we have No @ char here (Pelles\advapi32.lib)
                                  ; [Obj000397.ImportStrings: B$ '_SetServiceBits', 0, 'ADVAPI32.dll', 0]
            movsb

        End_While

        L0:

    .Else
        ; For all other cases, keep the lib name intact
       While B$esi <> 0 | movsb | End_While

    .End_if

    mov B$edi "'" | inc edi

    mov D$edi CRLF2 | add edi 4

    ; Write the full Undecorated name. Ecx ecx points to {'?wndTopMost@CWnd@@2V1@B' , 0}

    push esi
        mov esi RosAsmUndecoratedName | While B$esi <> 0 | movsb | End_While
    pop esi

    push ecx
    call 'IMAGEHLP.UnDecorateSymbolName' ecx, Trash, 4000, &UNDNAME_COMPLETE
    pop ecx

    call StrCmp ecx Trash

    ; If the strings are the same it means that the above function failed, because the undecoretated name is not the same
    ; as the original loaded name.
    If eax = 0
        call Simple_UndecorateSymbolName ecx, Trash
    End_If

    push esi
        mov esi Trash | While B$esi <> 0 | movsb | End_While
    pop esi


    mov D$edi CRLF2 | add edi 4
EndP
___________________________________________________________________________
;;

Bad Values

[Obj000004.ImportStrings: B$ '?ClearFontManager@@YAXXZ', 0, 'AYGSHELL.dll', 0
Obj000004.ImportStringsEnd:]

; RosAsm Interpretation: 'AYGSHELL.?ClearFontManager@@YAXXZ'

; Full Undecorated Name: void __cdecl ClearFontManager(void)


Good values


; RosAsm Interpretation: 'ACLUI.EditSecurity'

; Full Undecorated Name: _EditSecurity@8
;;

Proc Simple_UndecorateSymbolName:
    Arguments @Input, @Output
    Local @ParamCount

    pushad

    mov D@ParamCount 0
    mov edi D@Input

    While B$edi <> 0
        On B$edi = '?', jmp L4>> ; On this simplified versin we cannot have this char
        On B$edi = '$', jmp L4>> ; On this simplified versin we cannot have this char
        On B$edi = '@', jmp L1> ; This is possible to have, but a good symbols can only have this once.
        inc edi
    End_While

    jmp L2>
L1:
   inc edi

    While B$edi <> 0
        On B$edi = '@', jmp L4>> ; If we found this value again, we have a bad symbol
        If_And B$edi < '0', B$edi > '9' ; the values after the '@' char must be numbers from 0 to 9. Otherwise it is a bad symbol
            jmp L4>
        End_If
        inc edi
    End_While

    ; If we reach here we have a Good Symbol.
L2:

    mov esi D@Input
    mov edi D@Output

    If B$esi = '_'
        inc esi
    End_If

    If B$esi = 0
        push esi | ZCopy {"Invalid ! Null Symbol Name.", 0} | pop esi
        jmp L4>
    End_If

    .While B$esi <> 0

        .If B$esi = '@' ; We found our delimiter for the Parameters amount.
            inc esi ; Bypass the '@' char.
            call DecimalStringToDword esi
            shr eax 2 ; divide the result by 4
            push esi | ZCopy {" - Amount of Parameters: ", 0} | pop esi

            ; Convert Dword to Decimal String
            push edi
                mov D@ParamCount eax
                lea esi D@ParamCount
                mov ecx 4
                call toUDword
                mov esi edi
            pop edi

            Do | movsb | LoopUntil B$esi-1 = 0
            dec edi
            jmp L3>
        .End_If

        movsb
    .End_While

L3:
    mov B$edi 0

   L4:

    popad

EndP

___________________________________________________________________________
___________________________________________________________________________

; based on GetMemberSize

Proc DecimalStringToDword:
    Arguments @String
    Uses, esi, ebx, ecx, edx

    mov esi D@String
    mov ecx 10, ebx 0, eax 0

    .While B$esi <> 0
        on B$esi = ' ', ExitP
        mul ecx
        push eax
            lodsb | sub al '0' | mov bl al
        pop eax
        add eax ebx
    .End_While

EndP
___________________________________________________________________________
___________________________________________________________________________

Proc WriteImportObjStringAndOrdinal:
    Argument @Ordinal

        mov D$edi '[' | inc edi
        mov D$edi 'Obj',
            eax D$LibObjIndice, D$edi+3 eax,
            ax W$LibObjIndice+4, W$edi+7 ax,
            B$edi+9 '.' | add edi 10
        push esi
            mov esi ImportStringsText | While B$esi <> 0 | movsb | End_While
        pop esi


        ; to be added in AddListviewItem
        push esi
        push edi

            ; Always clear the loaded data before use.
            call ClearBuffer ExportedLibraryStr, 256
            mov D$ExportedLibrary 1
            mov edi ExportedLibraryStr
            While B$esi <> 0 | movsb | End_While
        pop edi
        pop esi


        ; Copy the Module Name:
        push esi
            While B$esi <> 0 | movsb | End_While
            mov D$edi "', 0" | add edi 4
            mov W$edi CRLF | add edi 2
            push esi
                call WriteObjIndice
                zCopy {'ImportStringsEnd:]', 0}
            pop esi
            mov D$edi CRLF2 | add edi 4

            mov esi RosAsmInterpretation | While B$esi <> 0 | movsb | End_While

        pop esi

      ; Copy the Commented Module Name:
        While B$esi <> 0 | movsb | End_While
        mov eax D$edi-4 | or eax 020202000
        If eax = '.dll'
            sub edi 4
        End_If

        mov B$edi '.' | inc edi
    pop esi
  ; Copy the Commented Function Ordinal:
    mov eax D@Ordinal | call WriteEax

    mov D$edi CRLF2 | add edi 4
EndP



[LookUpValidNameCharsTable: B$ ? #0100]

InitLookUpValidNameCharsTable:
    mov edi LookUpValidNameCharsTable, eax 0, ecx 0100

  ; Build a normal Asicii Table:
L0: mov B$edi+eax al | inc eax | loop L0<
ret

  ; Replace everything above 127 by '_'
    mov ecx 080, ebx 080, al '_'
L0: mov B$edi+ebx al | inc ebx | loop L0<

  ; Replace Ascii 127 by '_'
    mov B$edi+07F '_'

    mov eax '\' | mov B$edi+eax '.'

    mov eax '?' | mov B$edi+eax '.'

    mov eax '_' | mov B$edi+eax '.'

    mov eax '$' | mov B$edi+eax '.'

    mov eax '|' | mov B$edi+eax '.'
ret
;;
  ; Other possibility:
  
    mov al '_', ecx 0100, edi LookUpValidNameCharsTable | rep stosb
    
    mov edi LookUpValidNameCharsTable, eax '0'
    While eax <= '9'
        mov B$edi+eax al | inc al
    End_While
    
    mov eax 'A'
    While eax <= 'Z'
        mov B$edi+eax al | inc al
    End_While
    
    mov eax 'a'
    While eax <= 'z'
        mov B$edi+eax al | inc al
    End_While
ret
;;

[LookUpValidNameChars | lodsb | and eax 0FF | mov al B$LookUpValidNameCharsTable+eax | stosb]

[IMAGE_ARCHIVE_MEMBER_SIZE 030]

GetLongNamesPointer:  ; GetMemberSize
    ...If D$LongNamesBase = 0
        pushad
          ;  mov esi D$LibFileMemory | add esi 8

L0:         If W$esi = '//'
                add esi 03C
                mov D$LongNamesBase esi

            Else_If B$esi = '/'
                push D$MemberSize
                    add esi IMAGE_ARCHIVE_MEMBER_SIZE
                    call GetMemberSize
                    sub esi IMAGE_ARCHIVE_MEMBER_SIZE
                    add esi 03C | add esi D$MemberSize
                pop D$MemberSize | jmp L0<

            End_If
        popad
    ...End_If
ret


CheckLongNameDisplacement:
    push esi
        While B$esi <> ' '
            lodsb
            If al < '0'
                mov eax &FALSE | jmp L9>
            Else_If al > '9'
                mov eax &FALSE | jmp L9>
            End_If
        End_While
        mov eax &TRUE
L9: pop esi
ret


Proc WriteLongName:  ; GetMemberSize
    Argument @Dis
    Uses ebx, ecx, edx

    push esi
        mov esi {'Long Name: ', 0};IMAGE_ARCHIVE_MEMBER_HEADERstring
        While B$esi <> 0 | movsb | End_While
    pop esi

        mov esi D@Dis, ecx 10, ebx 0, eax 0

        While B$esi > ' '
            mul ecx
            push eax
                lodsb | sub al '0' | mov bl al
            pop eax
            add eax ebx
        End_While

        mov esi D$LongNamesBase | add esi eax

        While B$esi >= ' ' | movsb | End_While
        On B$edi-1 = '/', dec edi
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[LongNamesBase: ?]

GetLongNamesBase:
    mov D$LongNamesBase 0
   ____________________________________________
  ; Lib Tag:
    mov esi D$LibFileMemory | add esi 8

    If W$esi = '/ '
        push esi
            add esi LIB_MEMBER_SIZE | call GetMemberSize
        pop esi
        add esi COFF_HEADER_SIZE
        add esi D$MemberSize | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Second optional Lib Header:
    If W$esi = '/ '
        push esi
            add esi LIB_MEMBER_SIZE | call GetMemberSize
        pop esi
        add esi COFF_HEADER_SIZE
        add esi D$MemberSize | On B$esi = 0A, inc esi
    End_If
   ____________________________________________
  ; Third optional Lib Header:
    If W$esi = '//'
        add esi COFF_HEADER_SIZE
        mov D$LongNamesBase esi
    End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
                      Write the Tag and first Library Header
;;
____________________________________________________________________________________________

[WriteNotice: ";;

RosAsm Development Team presents:
________________________________________________

______________ Lib Scanner v 1.0  ______________
__________________  Set/05  ____________________
________________________________________________

This file was generated by RosAsm Library File Dumper,
aka known as Lib Scanner v 1.0.

http://www.rosasm.org
http://rosasm.org
http://betov.free.fr

If you have any questions about this file, read RosAsm's
Help file (B_U_Asm.exe), or feel free to contact us at:

http://www.quanta-it.com/easbell/RosAsmForum/index.php

_______________________

Author(s):

René Tournois (Betov)
Gustavo Trigueiros (Beyond2000!)

;;
________________________________________________


", 0]


[LibTag: ";;

________________________________________________

    Tag Data. The Magic String
________________________________________________
________________________________________________
;;

[Magic: B$   '!<arch>', 0A]

;;
________________________________________________

    First Linker Header - Names Linker Member
________________________________________________
________________________________________________
;;

; This is the IMAGE_ARCHIVE_MEMBER_HEADER Structure.

", 0]
____________________________________________________________________________________________

WriteLibTag:
  ; (Includes the First Headers comments at once):
    mov esi LibTag | While B$esi <> 0 | movsb | End_While

    mov esi D$LibFileMemory | add esi 8
ret
____________________________________________________________________________________________

[AmountOfMembers: "; Amount of Members on the file.

[PublicSymbols1: D$ ", 0]

[NumberOfSymbols: ?]

ShowAmountOfSymbols1:
;;
  Show the Amount of Symbols (a dWord stored the other way round):
;;
    push esi
        mov esi AmountOfMembers | While B$esi <> 0 | movsb | End_While
    pop esi
    lodsd | bswap eax | mov D$NumberOfSymbols eax | call WriteEax

    mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret
____________________________________________________________________________________________

[AmountOfOffsets1: "; Amount of Offsets of the Public Symbols.

[SymOffset:
 ", 0]

ShowOffsetTable1: ; 'ShowOffsetTable2'
;;
  Show the Offset Table (where each dWord is a Displacement from Top of File,
  to the IMAGE_ARCHIVE_MEMBER_HEADER of the .Obj File concerned with the
  matching Name found in the next "Symbols Table" String):
;;
    push esi
        mov esi AmountOfOffsets1 | While B$esi <> 0 | movsb | End_While
    pop esi

    mov ecx D$NumberOfSymbols

L0: lodsd
    push esi
    ; Eax: Displacement to the SymOffset array Data. If it is 0, jmp over.
        ..If eax = 0
            mov esi {'&NULL ; Null Pointer. Does not point to any Object in this file.', 0}

        ..Else
            mov esi D$LibFileMemory | bswap eax | add esi eax

            .If B$esi = '/'
L1:             push ecx
                    call GetLongNamesPointer
                    call CopyCoffIndice | inc esi
                    If D$LongNamesBase <> 0
                       ;                     mov esi D$LongNamesBase
                        call CheckLongNameDisplacement | On eax = &FALSE, jmp L1>
                        call WriteLongName esi
                    Else
L1:                     call CopySymbolName
                    End_If
                pop ecx

            .Else
                call CopyCoffIndice | call CopySymbolName

            .End_If

            mov esi IMAGE_ARCHIVE_MEMBER_HEADERstring

        ..End_If

        While B$esi <> 0 | movsb | End_While
    pop esi
    mov W$edi CRLF, B$edi+2 ' ' | add edi 3 | dec ecx | jnz L0<<
ret


CopySymbolName:
  ; Copy the ARCHIVE_MEMBER_HEADER Name:
  push ecx
  mov ecx 1 ; It is used as a counter. Starting with 1 (The 1st byte)


    push esi
        mov esi {'Short Name: ', 0}
        While B$esi <> 0 | movsb | End_While
    pop esi

    push esi

    While B$esi > ' '
        movsb
            ; Short Names always ends with an "/ ". Or sometimes with an "/"
            If W$esi+1 = '/ '
                movsW
                jmp L2>
            Else_If ecx = 16; Did we reached the 16th byte ? ON that case we may still have "/" as the last char
                jmp L2>
            End_If
        inc ecx
    End_While


L2:     On B$edi-1 = '/', dec edi ; Clean Up the last "/" char

    pop esi

    ; We need to retrieve the Function Name in case for the Import Header (The non common Coff format)
    ; To avoid inserting the ".directive" strings etc. We need only the real function name for this type
    ; of structure.

    ..If W$esi+58+2 = &IMAGE_FILE_MACHINE_UNKNOWN
        .If W$esi+58+2+2 = &IMPORT_OBJECT_HDR_SIG2

            push esi
                mov esi {' Function Name: ', 0}
                While B$esi <> 0 | movsb | End_While
            pop esi

            lea esi D$esi+60+20
            On B$esi = '/', inc esi
            While B$esi > '/' | LookUpValidNameChars | End_While

        .End_If
    ..End_If

   ; If this is a common Coff Format, we compute the Function name it follows it here
    pop ecx
ret


CopyObjSymbolName:
  ; Copy the ARCHIVE_MEMBER_HEADER Name:
  push ecx
  mov ecx 1 ; It is used as a counter. Starting with 1 (The 1st byte)

    push esi
        mov esi {'Short Name: ', 0}
        While B$esi <> 0 | movsb | End_While
    pop esi

    push esi

    While B$esi > ' '
        movsb
            ; Short Names always ends with an "/ ". Or sometimes with an "/"
            If W$esi+1 = '/ '
                movsW
                jmp L2>
            Else_If ecx = 16; Did we reached the 16th byte ? ON that case we may still have "/" as the last char
                jmp L2>
            End_If
        inc ecx
    End_While


L2:     On B$edi-1 = '/', dec edi ; Clean Up the last "/" char

    pop esi
    mov D$ExportedLibrary 0
    ; We need to retrieve the Function Name in case for the Import Header (The non common Coff format)
    ; To avoid inserting the ".directive" strings etc. We need only the real function name for this type
    ; of structure.

    ..If W$esi+58+2 = &IMAGE_FILE_MACHINE_UNKNOWN
        .If W$esi+58+2+2 = &IMPORT_OBJECT_HDR_SIG2

        mov D$ExportedLibrary edi

        push esi
            mov esi {' Function Name: ', 0}
            While B$esi <> 0 | movsb | End_While
        pop esi

        lea esi D$esi+60+20
        While B$esi >= ' ' | LookUpValidNameChars | End_While

        .End_If

    ..End_If

   ; If this is a common Coff Format, we compute the Function Name it follows it here
    pop ecx

ret
____________________________________________________________________________________________

[StringsArrayComments1: "]

; Array of null terminated strings that are the name of
;the Symbols List (The value of the array is defined by PublicSymbols member).

[Symname1:
 ", 0]

[Symname1.Data: B$   "Symname1.Data"
 SymName1Counter: "000001: B$   '", 0]

ShowSymbolsTable1:
;;
  Show the Symbols Table, that is a simple zero-ended string array. Each String
  is a Symbol used, in order, by the .Obj File, which the IMAGE_ARCHIVE_MEMBER_HEADER
  is pointed to, by the above Offset Table:
;;
    push esi
        mov esi StringsArrayComments1
        While B$esi <> 0 | movsb | End_While
    pop esi

    mov D$SymName1Counter '0000', W$SymName1Counter+4 '01', ecx D$NumberOfSymbols

L0: push esi
        mov esi Symname1.Data
        While B$esi <> 0 | movsb | End_While
    pop esi
    While B$esi <> 0 | LookUpValidNameChars | End_While | inc esi
    mov D$edi "', 0", W$edi+4 CRLF, B$edi+6 ' ' | add edi 7
    lea ebx D$SymName1Counter+5
    inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx
        inc B$ebx
    End_While
    loop L0<
    sub edi 3
    mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret
____________________________________________________________________________________________

WriteHeaderMember1:
    call ShowAmountOfSymbols1
    If D$NumberOfSymbols > 0
        call ShowOffsetTable1
        call ShowSymbolsTable1
    End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________
;;
                              Write the Second Library Header
;;
____________________________________________________________________________________________

[SecondLibHeaderComment: ";;
_____________________________________________________

    Secondary Linker Header - Names Linker Member
_____________________________________________________
_____________________________________________________
;;

; This is the IMAGE_ARCHIVE_MEMBER_HEADER Structure.

", 0]
____________________________________________________________________________________________

WriteSecondLibHeaderComment:
    push esi
        mov esi SecondLibHeaderComment
        While B$esi <> 0 | movsb | End_While
    pop esi
ret
____________________________________________________________________________________________

[AmountOfSymbols2: "; Total amount of Objects files.

[PublicSymbols2: D$ ", 0]

ShowAmountOfSymbols2:
;;
  Show the Amount of Symbols (a dWord stored the other way round):
;;
    push esi
        mov esi AmountOfSymbols2 | While B$esi <> 0 | movsb | End_While
    pop esi
    lodsd | mov D$NumberOfSymbols eax | call WriteEax

    mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret
____________________________________________________________________________________________

[AmountOfOffsets2: "; Amount of Offsets of the Object Files Found.

[SymOffset2:
 ", 0]

ShowOffsetTable2:  ; 'ShowOffsetTable1'
;;
  Show the Offset Table (where each dWord is a Displacement from Top of File,
  to the IMAGE_ARCHIVE_MEMBER_HEADER of the .Obj File concerned with the
  matching Name found in the next "Symbols Table" String):
;;
    push esi
        mov esi AmountOfOffsets2 | While B$esi <> 0 | movsb | End_While
    pop esi

    mov ecx D$NumberOfSymbols

L0: lodsd
    push esi
  ; Eax: Displacement to the SymOffset array Data. If it is 0, jmp over.

        ..If eax = 0
            mov esi {'&NULL ; Null Pointer. Does not point to any Object in this file.', 0}

        ..Else
            mov esi D$LibFileMemory | add esi eax
            .If B$esi = '/'
                call GetLongNamesPointer
                call CopyCoffIndice | inc esi
                If D$LongNamesBase <> 0
                    call CheckLongNameDisplacement | On eax = &FALSE, jmp L1>
                    call WriteLongName esi
                Else
L1:                 call CopySymbolName
                End_If

            .Else
                call CopyCoffIndice | call CopySymbolName

            .End_If

            mov esi IMAGE_ARCHIVE_MEMBER_HEADERstring

        ..End_If

        While B$esi <> 0 | movsb | End_While

    pop esi
    mov W$edi CRLF, B$edi+2 ' ' | add edi 3 | dec ecx | jnz L0<< ;loop L0<
    mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret
____________________________________________________________________________________________

[AmountOfSymbols3: "; Amount of Public Symbols on the file.

[PublicSymbols3: D$ ", 0]

ShowAmountOfSymbols2Bis:
;;
  Show the Amount of Members (a dWord stored the other way round), for Second Header:
;;
    push esi
        mov esi AmountOfSymbols3 | While B$esi <> 0 | movsb | End_While
    pop esi
    lodsd | mov D$NumberOfSymbols eax | call WriteEax

    mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret
____________________________________________________________________________________________

[IndexString2: "; Array of the Word data, representing the Index of the exported functions of the Symbols List.
; It points to the object files inside the lib.
; (The amount of the elements in the array is defined by the PublicSymbols2 member)

[SymIndex:
 ", 0]

[SymIndex2.Data: "SymIndex.Data"
 SymIndex2Counter: "000001:  W$    ", 0]


ShowIndexTable2:
;;
  Flow of reversed Words. They are indexes to point out what String goes with what Obj File:
;;
    push esi
        mov esi IndexString2 | While B$esi <> 0 | movsb | End_While
    pop esi

    mov ecx D$NumberOfSymbols, D$SymIndex2Counter '0000', W$SymIndex2Counter+4 '01'

L0: push esi
        mov esi SymIndex2.Data
        While B$esi <> 0 | movsb | End_While
    pop esi
  ; This one is not reversed:
    lodsw | and eax 0FFFF | call WriteEax



    lea ebx D$SymIndex2Counter+5
    inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx
        inc B$ebx
    End_While

    mov W$edi CRLF, B$edi+2 ' ' | add edi 3 | loop L0<

    sub edi 3
ret
____________________________________________________________________________________________

[StringsArrayComments2: "]

; Array of null terminated strings that are the name of
;the Symbols List (The value of the array is defined by PublicSymbols member).

[Symname2:
 ", 0]

[Symname2.Data: B$   "Symname2.Data"
 SymName2Counter: "000001: B$   '", 0]

ShowSymbolsTable2:
;;
  Show the Symbols Table, that is a simple zero-ended string array. Each String
  is a Symbol used, in order, by the .Obj File, which the IMAGE_ARCHIVE_MEMBER_HEADER
  is pointed to, by the above Offset Table:
;;
    push esi
        mov esi StringsArrayComments2
        While B$esi <> 0 | movsb | End_While
    pop esi

    mov D$SymName2Counter '0000', W$SymName2Counter+4 '01', ecx D$NumberOfSymbols

L0: push esi
        mov esi Symname2.Data
        While B$esi <> 0 | movsb | End_While
    pop esi
    While B$esi <> 0 | LookUpValidNameChars | End_While | inc esi
    mov D$edi "', 0", W$edi+4 CRLF, B$edi+6 ' ' | add edi 7
    lea ebx D$SymName2Counter+5
    inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx
        inc B$ebx
    End_While
    loop L0<
    sub edi 3
    mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret
____________________________________________________________________________________________

WriteHeaderMember2:
    call ShowAmountOfSymbols2
    On D$NumberOfSymbols > 0, call ShowOffsetTable2
    call ShowAmountOfSymbols2Bis
    If D$NumberOfSymbols > 0
        call ShowIndexTable2
        call ShowSymbolsTable2
    End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

;;
   Write the third Library Header
;;
____________________________________________________________________________________________


[ThirdLibHeaderComment: ";;
_____________________________________________________

    Tertiary Linker Header - Names Linker Member
_____________________________________________________
_____________________________________________________
;;

; This is the IMAGE_ARCHIVE_MEMBER_HEADER Structure.

", 0]
____________________________________________________________________________________________

WriteThirdLibHeaderComment:
    push esi
        mov esi ThirdLibHeaderComment
        While B$esi <> 0 | movsb | End_While
    pop esi
ret
____________________________________________________________________________________________

[LongNamesTableComment3:
"; Amount of Null Terminated String related to the Objects with LongNames.

[", 0]

[LongObjectNames: "LongObjectNames.data"

LongObjectNamesCounter: "000001: B$ '", 0]
____________________________________________________________________________________________

WriteLongNameTableComment3:
    mov D$LongObjectNamesCounter '0000', W$LongObjectNamesCounter+4 '01'

    push esi
        mov esi LongNamesTableComment3
        While B$esi <> 0 | movsb | End_While
    pop esi
ret

ShowLongNamesTable3:
    mov edx esi | add edx D$MemberSize

    ..While esi < edx
        push esi
            mov esi LongObjectNames
            While B$esi <> 0 | movsb | End_While

            lea ebx D$LongObjectNamesCounter+5
            inc B$ebx
            While B$ebx > '9'
                mov B$ebx '0' | dec ebx | inc B$ebx
            End_While
        pop esi

        While B$esi >= ' ' | LookUpValidNameChars | End_While | inc esi
        While B$esi < ' ' | inc esi | End_While
        mov D$edi "', 0", W$edi+4 CRLF | add edi 6
    ..End_While

    sub edi 2 | mov B$edi ']', D$edi+1 CRLF2 | add edi 5
ret


WriteHeaderMember3:
    If D$MemberSize > 0
        call WriteLongNameTableComment3
        call ShowLongNamesTable3
    End_If
ret
____________________________________________________________________________________________
____________________________________________________________________________________________

; Coff

[CoffComment: ";;
_____________________________________________________

Coff File Headers:
_____________________________________________________
_____________________________________________________
;;

", 0]

____________________________________________________________________________________________
____________________________________________________________________________________________
____________________________________________________________________________________________
____________________________________________________________________________________________
____________________________________________________________________________________________
____________________________________________________________________________________________
____________________________________________________________________________________________


;;
                                      Lib jobs
;;

[LibSymbolsMap: ?]

[SymbolsNumber: ?    CoffIndice: ?]

GetLibCode:
    mov D$SymbolsNumber 0, D$LibNumberOfBytes 0
    call GetLibSymbolsNumber | On D$SymbolsNumber = 0, jmp L9>>

    call CreateLibBuffers
    move D$LibDisassemblyPtr D$LibDisassembly, D$LibBytesCopyPtr D$LibBytesCopy
    mov D$CoffIndice 0

L0: call GetCoffBase D$CoffIndice
    .If W$esi <> 0-1
        If W$esi+2 <> 0-1
            call ScanCoff
        End_If
    .End_If
    inc D$CoffIndice | mov eax D$CoffIndice | cmp eax D$SymbolsNumber | jb L0<<

    call DecodeLib
L9: ret


GetLibSymbolsNumber:
    mov esi D$LibFileMemory

  ; Number of SYMBOLs in ecx:
    mov eax D$esi+COFF_HEADER_SIZE+ARCH_TAG | bswap eax
    mov D$SymbolsNumber eax
ret

; esi point to Coff Base (014C):

[CoffHeaderBase: ?]

[LibNumberOfBytes: ?]

ScanCoff:
    ..If W$esi <> 0-1 ; 'PeHeader'
        mov W$esi 0-1
        mov D$CoffHeaderBase esi
      ; Number of Coff Sections in ecx:
        movzx ecx W$esi+2
        add esi 014 ; COFF_HEADER_SIZE ; example: '.text'

L0:     and D$esi+SECTION_FLAG &IMAGE_SCN_CNT_CODE

        .If D$esi+SECTION_FLAG = &IMAGE_SCN_CNT_CODE
            push ecx, esi
                mov ecx D$esi+SECTION_FILESIZE, esi D$esi+SECTION_FILEPOINTER

                If ecx <> 0
                    add esi D$CoffHeaderBase
                    mov edi D$LibBytesCopyPtr
                    mov D$edi ecx | add edi 4
                    add D$LibNumberOfBytes ecx
                    rep movsb
                    mov D$LibBytesCopyPtr edi
                End_If
            pop esi, ecx
        .End_If

        add esi SECTIONHEADERSIZE | loop L0<
    ..End_If
ret

;;
B$ '.text',0,0,0
AppTrueCodeSize: D$   0     ; true size of code in file
AppCodeRVAoffset: D$   0    ; RVA offset (aligned on 01000 boundary)
AppFileSizeOfCode: D$   0   ; file aligned size of code (0200 aligned)
AppStartOfCode: D$   00     ; pointer to code (true first code in file - not entry point-)
D$   00                     ; dummy reloc ptr
D$   00                     ; dummy line number ptr
W$   00                     ; dummy reloc number
W$   00                     ; dummy number of line number
CodeCharacteristics:
D$   0_60000020             ; characteristics (readable, runable, code)
;;

[LibBytesCopy: ?    LibBytesCopyPtr: ?    LibDisassembly: ?    LibDisassemblyPtr: ?]

CreateLibBuffers:
    VirtualAlloc LibBytesCopy, D$LibFileLength
  ; VirtualAlloc LibSymbolsMap, D$LibFileLength
    mov ecx D$LibFileLength | shl ecx 5 | VirtualAlloc LibDisassembly ecx
    move D$LibDisassemblyPtr D$LibDisassembly
    add D$LibDisassembly 4
ret


Proc GetCoffBase:
    Argument @Indice

        mov esi D$LibFileMemory, eax D@Indice
        mov esi D$esi+eax*4+COFF_HEADER_SIZE+ARCH_TAG+4
        bswap esi | add esi D$LibFileMemory

      ; esi now points to a COFF Object:
        add esi COFF_HEADER_SIZE

      ; esi now point, typically, to 014C
EndP



Proc SetStringPointer:
    Arguments @Base, @Offset, @String
    Uses edi
      ; Write the Pointer to String directly on the Code "0, 0, 0, 0":
        mov edi D@Base
        add edi D$esi+SECTION_FILEPOINTER
        add edi D@Offset
        move D$edi D@String
EndP

____________________________________________________________________________________________



__________________________________________________________________________________________________________________
__________________________________________________________________________________________________________________

;;

----------------------------------------------------------------------
        Data used to build the Main dialog and Tab controls.
----------------------------------------------------------------------
----------------------------------------------------------------------

;;

__________________________________________________________________________________________________________________

;;
Proc WriteSectionHeaderSymbolConstantIndex:
    uses eax, ecx, ebx, esi

    call InitSymbolIndexRecord
    call WriteObjIndice

    ; Fix the label to show in Caps and replace the '." with an "_"
    ; The 1st char in "Obj000000." is in Caps, so we don't need to overwrite the "O" char

    push edi
    mov B$edi-1 '_', W$edi-9 'BJ'
    pop edi

    push esi
    zCopy {'SYMBOLINDEX', 0}
    pop esi

    mov ecx D$esi

    ; Note to René: Replacing this with a hex to decimal ascii string is better,
    ; but i couldn't make it be on the same style as SymbolTableIndex

    While ecx <> 0
        call IncrementSymbolIndexRecord
        dec ecx
    End_While

    zCopy SymbolTableIndex

    ; restore the SymbolTableIndex
    call InitSymbolIndexRecord

EndP
;;


; LV_ITEM Structure

[buffer2: B$ 0 #&MAXPATH]

[lvi:
 lvi.imask: D$ &LVIF_TEXT
 lvi.iItem: D$ 0
 lvi.iSubItem: D$ 0
 lvi.state: D$ &LVIS_FOCUSED
 lvi.stateMask: D$ 0
 lvi.pszText: D$ buffer2
 lvi.cchTextMax: D$ &MAXPATH
 lvi.iImage: D$ 0
 lvi.lParam: D$ 0
 lvi.iIndent: D$ 0]

;&LVCF_ORDER

[LvOffsetCOFF: D$ 0]
;GetCoffIMAGE_FILE_HEADER

[DecimalBuffer: B$ ? #16];B$ 020 #10 0]
[HexaDecimalBuffer: B$ ? #16]

[ObjSymbolsNumber: D$ 0]

[CoffMachineType: D$ 0]

[ObjFileNameType: D$ 0]


; The decimal and hexadecimal convertion routines comes from MouseHintDrawWindow

Proc AddListviewItem:
    Arguments @h2List
    pushad


    ; Calculate and Display Index Value
    mov edi buffer2
    mov esi LibObjIndice
    While B$esi <> 0 | movsb | End_While

    sub edi 6
    mov D$lvi.pszText edi
    mov D$lvi.iSubItem, 0
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTITEM, 0, lvi

    ; Calculate and Display FileName

    move D$lvi.pszText ObjectName
    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Calculate and Display Extension

    If D$UseObjExtension = 0
        mov D$lvi.pszText {"No extension", 0}
    Else
        move D$lvi.pszText ObjExtensionStr
    End_If
    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi


    ; Display File Name Type
    ; Definition of values in Write_Obj_IMAGE_ARCHIVE_MEMBER_HEADER

    If D$ObjFileNameType = 1
        mov D$lvi.pszText {"Long Name", 0}
    Else
        mov D$lvi.pszText {"Short Name", 0}
    End_If
    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi


    ; Display the Path of the Object file
    If D$UseObjPath = 0
        mov D$lvi.pszText {"Not used", 0}
    Else
        mov D$lvi.pszText ObjPathStr
    End_If

    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

   ; Calculate and Display Offset (Convert hexa dword to string)

    mov edi HexaDecimalBuffer
    DwordToHex D$LvOffsetCOFF
    mov B$edi 0

    move D$lvi.pszText HexaDecimalBuffer
    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Calculate and Display Size (Convert Hexa do Decimal String)

    mov esi MemberSize, ecx 4
    call toUDword
    mov esi edi, edi DecimalBuffer
    Do | movsb | LoopUntil B$esi-1 = 0

    move D$lvi.pszText DecimalBuffer
    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Display Object Type
    If D$ExportedLibrary = 0
        mov D$lvi.pszText {"Runtime Object", 0}
    Else
        mov D$lvi.pszText {"Exported Object", 0}
    End_If

    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Display Function Name used in Exported Library
    If D$ExportedLibrary = 0
        mov D$lvi.pszText {"Not used", 0}
    Else
        move D$lvi.pszText ExportedLibraryStr
    End_If

    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi


    ; Display the Machine Type

    mov D$buffer2 edi ; eax holds the address of the initial Equate String

    call Write_IMAGE_FILE_MACHINE D$CoffMachineType
    mov B$edi 0 ; Fix the end of edi in all cases. Force Null Terminated String
    mov eax D$buffer2

    If B$eax = '&'
        inc D$buffer2
        move D$lvi.pszText D$buffer2
    Else
        mov D$lvi.pszText {"Unknown or Corrupted Machine Type", 0}
    End_If
    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ;  Calculate and Display Number of Sections (Convert Hexa do Decimal String)

    .If D$ExportedLibrary = 0
        mov esi ObjNumberOfSections, ecx 4
        call toUDword
        mov esi edi, edi DecimalBuffer
        Do | movsb | LoopUntil B$esi-1 = 0

        mov D$lvi.pszText DecimalBuffer
    .Else
        mov D$lvi.pszText {"No Sections", 0}
    .End_If

    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Display Time and Date Stamp
    ; This came from WriteImportObjHdrTimeDateStamp
    ;TimeDateStringtoDword
    call Concatenation szDateString, szTimeString, buffer2
    move D$lvi.pszText buffer2
    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi


    ;  Calculate and Display Number of Symbols (Convert Hexa do Decimal String) CoffSymbolsNumber
    .If D$ExportedLibrary = 0
        mov esi ObjSymbolsNumber, ecx 4
        call toUDword
        mov esi edi, edi DecimalBuffer
        Do | movsb | Loop_Until B$esi-1 = 0

        mov D$lvi.pszText DecimalBuffer
    .Else
        mov D$lvi.pszText {"No Symbols", 0}
    .End_If

    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Show Optional Header Options (False if it don't use Optional Header, True otherwise)

    If D$SizeOfOptionalHeaderInObj = 0
        mov D$lvi.pszText {"False", 0}
    Else
        mov D$lvi.pszText {"True", 0}
    End_If
    inc D$lvi.iSubItem
    call 'user32.SendMessageA', D@h2list, &LVM_SETITEM, 0, lvi

    ; Clear the Buffer before exit

    mov ecx &MAXPATH
    mov edi 0
    L0:
        mov B$buffer2+edi 0
        inc edi
    Loop L0<

    popad

EndP


___________________________________________

; Used Macros


; Amount of Columns of the ListView
[Lib_LVTotalCol 14]

; String Data

[Header1: B$ 'Index',0]
[Header2: B$ 'File Name',0]
[Header3: B$ 'Extension',0]
[Header4: B$ 'FileName Type',0]
[Header5: B$ 'Path',0]
[Header6: B$ 'Offset',0]
[Header7: B$ 'Size',0]
[Header8: B$ 'Object Type',0]
[Header9: B$ 'Exported Function',0]
[Header10: B$ 'Machine Type',0]
[Header11: B$ 'Sections',0]
[Header12: B$ 'Time and Date',0]
[Header13: B$ 'Symbols',0]
[Header14: B$ 'Optional Header',0]

; Our used Constants to identify what field is what
[LVIEW_INDEX 0]
[LVIEW_FILENAME 01]
[LVIEW_EXTENSION 02]
[LVIEW_NAMETYPE 03]
[LVIEW_PATH 04]
[LVIEW_OFFSET 05]
[LVIEW_SIZE 06]
[LVIEW_OBJTYPE 07]
[LVIEW_EXPORTEDFUNCTION 08]
[LVIEW_MACHINE 09]
[LVIEW_SECTION 10]
[LVIEW_TIME 11]
[LVIEW_SYMBOL 12]
[LVIEW_OPTIONAL 13]

[hHeader: D$ ?]
[hList: D$ ?]

; LV_COLUMN Structure

[lvc:
 lvc.imask: D$ 0
 lvc.fmt: D$ &LVCFMT_LEFT
 lvc.lx: D$ 80  ; columnwidth
 lvc.pszText: D$ 0
 lvc.cchTextMax: D$ 0
 lvc.iSubItem: D$ 0
 lvc.iImage: D$ 0
 lvc.iOrder: D$ 0]

Proc SetupListview:
    Arguments @h2List

    ; /*Listview setup */
    mov D$lvc.imask, &LVCF_TEXT+&LVCF_WIDTH
    mov D$lvc.pszText, Header1
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_INDEX, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header2
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_FILENAME, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header3
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_EXTENSION, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header4
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_NAMETYPE, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header5
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_PATH, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header6
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_OFFSET, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header7
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_SIZE, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header8
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_OBJTYPE, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header9
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_EXPORTEDFUNCTION, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header10
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_MACHINE, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header11
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_SECTION, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header12
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_TIME, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header13
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_SYMBOL, lvc
    or D$lvc.imask, &LVCF_FMT
    mov D$lvc.pszText, Header14
    call 'user32.SendMessageA', D@h2list, &LVM_INSERTCOLUMN, LVIEW_OPTIONAL, lvc

    ;/* these 5 lines create a FLAT columnheader */
    call 'user32.SendMessageA', D@h2List, &LVM_GETHEADER__&LVM_ENSUREVISIBLE__&LVM_SETCOLUMNORDERARRAY, 0, 0 ;// get handle to header;&LVM_GETHEADER, 0, 0 ;// get handle to header
    mov D$hHeader, eax ;// preserve header handle
    call 'user32.GetWindowLongA', D$hHeader, &GWL_STYLE ;// get current window styles
    xor eax, &HDS_BUTTONS
    call 'user32.SetWindowLongA', D$hHeader, &GWL_STYLE, eax ;// set the new header styles

    ;/* Setup extended styles like gridlines, back-foregroundcolors */
    call 'user32.SendMessageA', D@h2List, &LVM_SETEXTENDEDLISTVIEWSTYLE, 0, &LVS_EX_FULLROWSELECT__&LVS_EX_HEADERDRAGDROP__&LVS_EX_SUBITEMIMAGES__&LVS_EX_GRIDLINES__&LVS_EX_FLATSB
    call 'user32.SendMessageA', D@h2List, &LVM_SETTEXTCOLOR, 0, {RGB 186 48 38};{RGB 0 0 0} ;0
    call 'user32.SendMessageA', D@h2List, &LVM_SETBKCOLOR, 0, {RGB 255 255 255} ; 0FFFFFF
    call 'user32.SendMessageA', D@h2List, &LVM_SETTEXTBKCOLOR, 0, {RGB 240, 247, 166} ; 0A6F7F0

EndP

___________________________________________________________________________________________________________

; ----------------------------------------------
; 2nd Dialog Tab Frame Procedure
; This is to show the Object Listing
; ----------------------------------------------


Proc Tab2Proc:
    Arguments @hWin, @uMsg, @wParam, @lParam

    pushad

    If D@uMsg = &WM_INITDIALOG
        call 'USER32.SendMessageW' D@lParam, &EM_SETSEL, 0-1, 0
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | ExitP
    Else_If D@uMsg = &WM_NOTIFY
        call LibScanDialog_OnNotify D@hWin, D@lParam
    Else_If D@uMsg = &WM_CTLCOLOREDIT
        call 'GDI32.SetBkColor' D@wParam, D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | ExitP
    Else
        popad | mov eax &FALSE | ExitP
    End_If

    popad | mov eax &TRUE
EndP


; ----------------------------------------------
; 1st Dialog Tab Frame Procedure
; This is where the MZ Header dialog is used
; ----------------------------------------------


Proc Tab1Proc:
    Arguments @hWin, @uMsg, @wParam, @lParam

    pushad

    .If D@uMsg = &WM_INITDIALOG
        call 'USER32.SendMessageW' D@lParam, &EM_SETSEL, 0-1, 0
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | ExitP
    .Else_If D@uMsg = &WM_NOTIFY
        call LibScanDialog_OnNotify D@hWin, D@lParam
    .Else_If D@uMsg = &WM_CTLCOLOREDIT
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | ExitP
    .Else
        popad | mov eax &FALSE | ExitP
    .End_If

    popad | mov eax &TRUE
EndP




______________________________________________________________________________________________

; constants for the library dialogs

; Dialog Controls

[IDD_MAINLIB 20] ; Main Dialog where it will hold the tabs.

; Internal controls for this dialog

[IDC_LIBFILESIZE 4] ; The Edit Control where the path name is displayed
[IDC_OPENLIBFILE 5] ; The Edit Control where the path name is displayed
[IDC_TABCTRL 38]  ; Main Tab Control Resource.
[IDC_LOADLIB 3]     ; The "Open" Button.

[IDD_TAB1 21] ; Id of the 1st Dialog "Library Structure"

; Internal controls for this dialog

[IDC_LIB_TARGET 11] ; 1 59 199 188 . ES_MULTI ES_AUTOVS ES_AUTOH WS_VS WS_HSC WS_TAB WS_BO
[IDC_LIB_SOURCE 10] ; 202 57 178 188. ES_MULTI ES_AUTOVS WS_VS WS_BO


[IDD_TAB2 22]  ; Id of the 2nd Dialog "Object Listing"
; Internal controls for this dialog
[IDC_LVIEW 30] ; Id for the listview control

[IDD_TAB3 23] ; Id of the 3rd Dialog other Header
[IDD_TAB4 24] ; Id of the 4th Dialog Section Images


; Menu Equates

[M03_Menu  4000                  M03_Open  4001                  M03_Close  4002
 M03_Save_Report  4003           M03_Exit  4004                  M03_Single_Object_File  4005
 M03_Runtime_Objects_Only  4006  M03_Exported_Objects_Only  4007 M03_All_Object_Files  4008
 M03_Build_Dis_File  4009        M03_Next_Tab  4010              M03_Previous_Tab  4011
 M03_First_Tab  4012             M03_Last_Tab  4013              M03_Show_ToolBarText  4014
 M03_Hover_ToolBar  4015         M03_About  4016]

; Structures used

[NMHDR.hwndFromDis 0
 NMHDR.idFromDis 4
 NMHDR.codeDis 8]


[hInst: D$ 0]

[SortDecimal: D$ 0] ; Sort Buffer

[flag_TB_00: ?]

; Tab Selection
[LibScanSelTabStruc 0]
[LibScanSelTabObj 1]
[LibScanSelTabDisasm 2]
[LibScanSelTabDisBuild 3]

[LibScanTab_ImageList: ?]
; Tag Dialog 20

Proc ScanLibFile:
    Arguments @Adressee, @Message, @wParam, @lParam

     pushad

    ...If D@Message = &WM_COMMAND                  ; User action

        ..If_Or D@wParam = &IDCANCEL, D@wParam = M03_Exit  ; User clicks on upper right [X] or Exited through the menu
            call LibScanCleanUp D@Adressee
            call 'COMCTL32.ImageList_Destroy' D$LibScanDialog_ImageList
            call 'COMCTL32.ImageList_Destroy' D$LibScanTab_ImageList
            call 'USER32.EndDialog' D@Adressee 0
            mov D$LibScanToolbarHandle 0
            mov B$LibScanIsFileOpen &FALSE

        ..Else_If D@wParam = M03_Close
            call LibScanCleanUp D@Adressee
            mov B$LibScanIsFileOpen &FALSE
            call LibScanDialog_EnableContinueMenu &FALSE
            jmp L5>>

        ..Else_If D@wParam = M03_Save_Report
            call SaveLibFileAs D@Adressee, D$hLibReportEdit, D$hLibReportEditLength

        ..Else_If D@wParam = M03_Single_Object_File
            call SaveOneObjectFile D@Adressee

        ..Else_If D@wParam = M03_Runtime_Objects_Only
            call SaveAllObjectFile D@Adressee, EXPORT_RUNTIME_OBJECTS

        ..Else_If D@wParam = M03_Exported_Objects_Only
            call SaveAllObjectFile D@Adressee, EXPORT_EXPORTED_OBJECTS

        ..Else_If D@wParam = M03_All_Object_Files
            call SaveAllObjectFile D@Adressee, EXPORT_ALL_OBJECTS

        ..Else_If D@wParam = M03_Show_ToolBarText
            call LibScanDialog_ToggleToolbarText D@Adressee

        ..Else_If D@wParam = M03_Hover_ToolBar
            call LibScanDialog_HoverToolbarText D@Adressee

        ..Else_If D@wParam = M03_Next_Tab
            call LibScanDialog_EnableContinuePrevTabMenu &TRUE
            call 'USER32.SendMessageA' D$hTab &TCM_GETCURSEL 0 0
            .If eax <> LibScanSelTabDisBuild
                inc eax
                call 'USER32.SendMessageA' D$hTab &TCM_SETCURSEL eax eax
                inc eax

                If eax <> D$SelTab
                    push eax
                    mov eax D$SelTab
                    call 'USER32.ShowWindow' D$eax*4+hTabDlg1 &SW_HIDE
                    pop eax
                    mov D$SelTab eax
                    call 'USER32.ShowWindow' D$eax*4+hTabDlg1 &SW_SHOWDEFAULT
                End_If
            .End_If

            If D$SelTab = LibScanSelTabDisBuild
                call LibScanDialog_EnableContinueNextTabMenu &FALSE
            End_If

        ..Else_If D@wParam = M03_Previous_Tab

            call 'user32.SendMessageA' D$hTab &TCM_GETCURSEL 0 0
            .If eax <> LibScanSelTabStruc
                dec eax
                call 'USER32.SendMessageA' D$hTab &TCM_SETCURSEL eax eax
                dec eax

                If eax <> D$SelTab
                    push eax
                    mov eax D$SelTab
                    call 'USER32.ShowWindow' D$eax*4+hTabDlg1 &SW_HIDE
                    pop eax
                    mov D$SelTab eax
                    call 'USER32.ShowWindow' D$eax*4+hTabDlg1 &SW_SHOWDEFAULT
                End_If
                call LibScanDialog_EnableContinueNextTabMenu &TRUE
            .End_If

            If D$SelTab = LibScanSelTabStruc
                call LibScanDialog_EnableContinuePrevTabMenu &FALSE
            End_If

        ..Else_If D@wParam = M03_First_Tab
L5:
                call 'USER32.SendMessageA' D$hTab &TCM_SETCURSEL LibScanSelTabStruc LibScanSelTabStruc
                mov eax LibScanSelTabStruc
                mov D$SelTab LibScanSelTabObj

                If eax <> D$SelTab
                    push eax
                    mov eax D$SelTab
                    call 'user32.ShowWindow' D$eax*4+hTabDlg1 &SW_HIDE
                    pop eax
                    mov D$SelTab eax
                    call 'USER32.ShowWindow' D$eax*4+hTabDlg1 &SW_SHOWDEFAULT
                End_If
                call LibScanDialog_EnableContinueNextTabMenu &TRUE
                call LibScanDialog_EnableContinuePrevTabMenu &FALSE

        ..Else_If D@wParam = M03_Last_Tab

                call 'USER32.SendMessageA' D$hTab &TCM_SETCURSEL LibScanSelTabDisBuild LibScanSelTabDisBuild
                mov ecx LibScanSelTabDisBuild
                mov eax D$SelTab
                If eax = D$SelTab
                    push eax
                    mov eax D$SelTab
                    call 'USER32.ShowWindow' D$eax*4+hTabDlg1 &SW_HIDE
                    pop eax
                    mov eax LibScanSelTabDisBuild
                    mov D$SelTab eax
                    call 'USER32.ShowWindow' D$eax*4+hTabDlg1 &SW_SHOWDEFAULT
                End_If
                call LibScanDialog_EnableContinueNextTabMenu &FALSE
                call LibScanDialog_EnableContinuePrevTabMenu &TRUE

        ..Else_If D@wParam = M03_Open

            mov D$ChoosenLibFile 0
            move D$OPENLIB@hwndOwner D@Adressee
            move D$OPENLIB@hInstance D$hInstance
            move D$OPENLIB@lpstrFilter LibsFileFilter
            call 'COMDLG32.GetOpenFileNameA' OPENLIB

            .If D$ChoosenLibFile <> 0
                call LibScanCleanUp D@Adressee
                call LibScanDialog_EnableContinueMenu &TRUE

                call 'USER32.SendDlgItemMessageA' D@Adressee IDC_OPENLIBFILE &WM_SETTEXT 0 LibSaveFilter
                call 'USER32.SendDlgItemMessageA' D@Adressee IDC_OPENLIBFILE &WM_GETTEXT 0 LibSaveFilter ; GET THE FILENAME

                ; The user is opening the file, Clean the list view.
                call 'USER32.SendMessageA', D$hlist, &LVM_DELETEALLITEMS, 0, lvi

                call OpenLibFile D@Adressee
                On D$LibFileLength = 0, jmp L9>> ; Exit when the file size is 0.

                call LibSignatureCheck

                If D$ValidLib = UNKNOWN_LIB_FILE
                    ; Disables the Menus itens to prevent the user tries to save a report, or do something wrong with it
                    call LibScanDialog_EnableContinueMenu &FALSE
                    call 'USER32.DialogBoxParamA' D$hinstance, IDD_LIBSCANWARNINGMSG, D@Adressee, LibScanWarning, &NULL
                    jmp L9>>
                End_If

                call ParseIdentifiedLibs D@Adressee

                ; Below we can only remove after we build the parser for each one of these libraries.
                ; But we can leave this lines here, in the meanwhile
                If_Or D$ValidLib = DCU1_KILYX_OBJ_FILE, D$ValidLib = DCU2_KILYX_OBJ_FILE,
                      D$ValidLib = DCU3_KILYX_OBJ_FILE, D$ValidLib = DCU2_OBJ_FILE,
                      D$ValidLib = DCU3_OBJ_FILE, D$ValidLib = DCU4_OBJ_FILE,
                      D$ValidLib = DCU5_OBJ_FILE, D$ValidLib = DCU6_OBJ_FILE,
                      D$ValidLib = DCU7_OBJ_FILE, D$ValidLib = OMF_OBJ_FILE,
                      D$ValidLib = PDB_OBJ_FILE, D$ValidLib = DBG_OBJ_FILE
                    jmp L9>>
                End_If
            .End_If

            call CoolControl_LVBeginSort ListViewLibSort, SortDecimal, D$hlist, 1
      ;  ..Else_If D@wParam = &IDHELP
      ;      call Help, B_U_AsmName, DisassemblerHelp, ContextHlpMessage

        ..End_If


    ...Else_If D@Message = &WM_NOTIFY
        call LibScanDialog_OnNotify D@Adressee, D@lParam

    ...Else_If D@Message = &WM_NCMOUSEMOVE
        ..If B$LibScanHoverTBText <> &MF_UNCHECKED
            .If D$flag_TB_00 = 0                    ;check flag toolbar
                call 'USER32.ShowWindow' D$LibScanToolbarHandle &SW_SHOW
                mov D$flag_TB_00 1                  ;set flag toolbar
            .End_If
        ..End_If
    ...Else_If D@Message = &WM_MOUSEMOVE
        ..If B$LibScanHoverTBText <> &MF_UNCHECKED
            .If D$flag_TB_00 = 1                    ;check flag toolbar
                call 'USER32.ShowWindow' D$LibScanToolbarHandle &SW_HIDE
                mov D$flag_TB_00 0                  ;set flag toolbar
            .End_If
        ..End_If

    ...Else_If D@Message = &WM_INITDIALOG

        call 'USER32.GetMenu' D@Adressee | mov D$LibScanMenuHandle eax

        ; Create the image list
        call CoolControlTB_CreateImageList LibScanDialog_ImageList, IDB_LibScanEnableTB, IDB_LibScanDisableTB, 20, 20, &ILC_COLOR32+&ILC_MASK, LibScanToolButtonsNumber, LibScanToolButtonsNumber

        call CoolControlTB_CreateImageList LibScanTab_ImageList, IDB_LibScanTABEnable, IDB_LibScanTABDisable, 20, 20, &ILC_COLOR32+&ILC_MASK, LibScanTabControlsNumber, LibScanTabControlsNumber

        ;Create the tabs
        call CoolControlDlg_CreateTab D@Adressee, IDC_TABCTRL, hTab, LibScanTabControl

        ;Create the tab dialogs
        call 'user32.CreateDialogParamA' D$hInstance IDD_TAB1 D$hTab Tab1Proc 0
        mov D$hTabDlg1 eax

        call 'user32.CreateDialogParamA' D$hInstance IDD_TAB2 D$hTab Tab2Proc 0
        mov D$hTabDlg2 eax


        call 'user32.GetDlgItem' D$hTabDlg2 IDC_LVIEW ; Get the ListView Control in the 2nd TAB resources, and
                                                    ; use it on the handle of the main window
        mov D$hList eax                              ; Now we return the result (found in eax), copying it to
                                                    ; the Handle of the Tab Control in the resource.
                                                    ; So, all we did was get the TAB Control and save it to the Tab handle.

        ; Create the toolbar
        call CoolControlWin_CreateToolbar D@Adressee, LibScanToolbarHandle, LibScanToolbarButtons,
        LibScanToolButtonsNumber, LibScanToolTipsStrings, LSTBWin_Cmd

        ; Initialize the Menu state
        call LibScanDialog_EnableContinueMenu &FALSE
        call LibScanDialog_EnableContinuePrevTabMenu &FALSE

        ;/* Setup listview */
        call SetupListview, D$hList
        call CoolControl_LVBeginSort ListViewLibSort, SortDecimal, D$hlist, 1
;;
        call 'user32.CreateDialogParamA' D$hInstance IDD_TAB3 D$hTab Tab3Proc 0
        mov D$hTabDlg3 eax
        call 'user32.CreateDialogParamA' D$hInstance IDD_TAB4 D$hTab Tab4Proc 0
        mov D$hTabDlg4 eax
;;


    ...Else_If D@Message = &WM_CLOSE
        call LibScanCleanUp D@Adressee
        call 'COMCTL32.ImageList_Destroy' D$LibScanDialog_ImageList
        call 'COMCTL32.ImageList_Destroy' D$LibScanTab_ImageList
        call 'USER32.EndDialog' D@Adressee &NULL
        mov D$LibScanToolbarHandle 0
        mov B$LibScanIsFileOpen &FALSE

    ...Else_If D@Message = &WM_CTLCOLOREDIT
        call 'GDI32.SetBkColor' D@wParam D$DialogsBackColor
        popad | mov eax D$DialogsBackGroundBrushHandle | ExitP

    ...Else
        popad | mov eax &FALSE | ExitP

    ...End_If

L9: popad | mov eax &TRUE
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; This function handles all Notifications messages from all controls in the different Tabs
; It is mandatory to they be called inside each Tab Procedure (Tab1Proc, Tab2Proc ....)
; because we need they behave as a callback to handle the proper messages from each control Tab

Proc LibScanDialog_OnNotify:
    Arguments @Adressee, @Notification

    mov ebx D@Notification
    mov edx D$ebx+NMHDR.idFromDis
    mov eax D$ebx+NMHDR.codeDis

    .If edx = IDC_TABCTRL
        If eax = &TCN_SELCHANGE
            call CoolControlTabChange_OnNotify D@Notification, SelTab, D$hTab
        End_If

    .Else_If edx = IDC_LVIEW
        If eax = &LVN_COLUMNCLICK
            call CoolControl_ListViewAlternateSort ListViewLibSort, D@Notification, SortDecimal, D$hList, Lib_LVTotalCol
        Else_If eax = &NM_DBLCLK
            call SaveOneObjectFile D@Adressee
        End_If

    .Else_If eax = &TTN_NEEDTEXT

        If_And edx >= D$LSTB01.idCommand, edx <= D$LSTB10.idCommand
            call CoolControlTB_OnNotify D@Adressee, D@Notification, LibScanToolbarButtons, LibScanToolButtonsNumber, LibScanToolTipsStrings
        Else_If_And edx >= LibScanSelTabStruc, edx <= LibScanSelTabDisBuild
            call CoolControlTabToolTip_OnNotify D@Notification, LibScanTabNumber, LibScanTabToolTipStrings
        End_If

    .End_If

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc SaveOneObjectFile:
    Arguments @Adressee

    pushad

    call 'user32.SendMessageA' D$hList, &LVM_GETNEXTITEM, 0-1, &LVNI_SELECTED
    If eax <> 0-1
        call SaveSingleObjectFileAs D@Adressee, eax
    Else
        call 'user32.MessageBoxA' D@Adressee, {B$ "No field selected or empty fields.", D$ CRLF2, B$ "You must select one field in the ListControl to allow exporting the Selected Object file.", 0}, {"Attention !", 0}, &MB_ICONEXCLAMATION
    End_If

    popad
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________


[ObjSaveFileFilter: B$ 'Object File (*.obj)', 0  '*.obj', 0 0]
[ObjSaveFilter: ? #&MAX_PATH]

Proc SaveSingleObjectFileAs:
    Arguments @Adressee, @SelectedItem
    pushad

    ; 1st we get the FileName

    move D$lvi.iItem D@SelectedItem
    mov D$lvi.iSubItem 1 ; [Header2: B$ 'File Name',0] ; string
    call 'USER32.SendMessageA' D$hlist, &LVM_GETITEM, D@SelectedItem, lvi
    ; the result is in szBuff0

    mov edi ObjSaveFilter
    push esi | ZCopy szBuff0 | pop esi
    mov B$edi 0

    mov D$ChoosenLibFile 0
    move D$SAVELIB.lpstrFile ObjSaveFilter
    move D$SAVELIB.hwndOwner D@Adressee
    move D$SAVELIB.hInstance D$hInstance
    move D$SAVELIB.lpstrFilter ObjSaveFileFilter
    call 'Comdlg32.GetSaveFileNameA' SAVELIB

    ..If eax <> 0
        .If D$ChoosenLibFile <> 0
            call ForceExtension ObjSaveFilter, '.obj'

            ; Get the Offset
            move D$lvi.iItem D@SelectedItem
            mov D$lvi.iSubItem 5 ; [Header6: B$ 'Offset',0] ; hexadecimal value string
            call 'USER32.SendMessageA' D$hlist, &LVM_GETITEM, D@SelectedItem, lvi
            call AsciiBase szBuff0 BASE_HEX
            mov edi eax

            ; Get the size
            move D$lvi.iItem D@SelectedItem
            mov D$lvi.iSubItem 6 ; [Header7: B$ 'Size',0] ; decimal value
            call 'USER32.SendMessageA' D$hlist, &LVM_GETITEM, D@SelectedItem, lvi
            call String2Dword szBuff0

            mov esi D$LibFileMemory
            add esi edi
            call SaveLibFile, esi, eax, ObjSaveFilter
        .End_If
    ..End_If

    popad
EndP


____________________________________________________________________________________________
____________________________________________________________________________________________

[ObjPathTitle: B$ 'For the Exported Object Files', 0]
[MultipleObjectPath: B$ ? #&MAXPATH]

[EXPORT_ALL_OBJECTS 0]
[EXPORT_RUNTIME_OBJECTS 1]
[EXPORT_EXPORTED_OBJECTS 2]
; Flag = 0 (Save all Objects)
; Flag = 1 (Save all Runtime Objects)
; Flag = 2 (Save all Exported Objects)
Proc SaveAllObjectFile:
    Arguments @Adressee, @Flag
    Local @SelectedItem, @CountItens, @FolderPathStart, @RepeatedName

; More examples here MultipleCompileTests SaveSingleObjectFileAs
    pushad

    call BrowseForFolder D@Adressee, ObjPathTitle
    ...If B$BrowseForFolderAborted <> &TRUE

        ; Initialize all revelant Data
        mov D@RepeatedName 0
        mov D@CountItens 0
        mov D$RepeatedObjIndice '0000', D$RepeatedObjIndice+4 '00'
        ; 1st we calculate the amount of objectsinside the lib
        call String2Dword LibObjIndice
        mov D@CountItens eax

        mov D@SelectedItem 0 ; always starts at the 1st item (that have the value of 0)
        mov esi FolderPath, edi MultipleObjectPath
        While B$esi <> 0 | movsb | End_While | mov B$edi '\' | inc edi
        mov D@FolderPathStart edi

        .Do

            .If D@Flag = EXPORT_RUNTIME_OBJECTS
                move D$lvi.iItem D@SelectedItem
                mov D$lvi.iSubItem 7 ; [Header8: B$ 'Object Type',0] ; string
                call 'USER32.SendMessageA' D$hlist, &LVM_GETITEM, D@SelectedItem, lvi
                On D$szBuff0 <> 'Runt', jmp L1>> ; Not a runtime Object, jmp over it
            .Else_If D@Flag = EXPORT_EXPORTED_OBJECTS
                move D$lvi.iItem D@SelectedItem
                mov D$lvi.iSubItem 7 ; [Header8: B$ 'Object Type',0] ; string
                call 'USER32.SendMessageA' D$hlist, &LVM_GETITEM, D@SelectedItem, lvi
                On D$szBuff0 <> 'Expo', jmp L1>> ; Not a Export Object, jmp over it
            .End_If
            ; 1st we get the FileName

            move D$lvi.iItem D@SelectedItem
            mov D$lvi.iSubItem 1 ; [Header2: B$ 'File Name',0] ; string
            call 'USER32.SendMessageA' D$hlist, &LVM_GETITEM, D@SelectedItem, lvi

            ; Copy the filename to the path and append the '.obj' extension
            ; the result is in szBuff0
            mov esi szBuff0
            While B$esi <> 0 | movsb | End_While
            mov D$edi '.obj' | add edi 4 | mov B$edi 0

            call 'KERNEL32.FindFirstFileA' MultipleObjectPath, FindFile

            If eax <> &INVALID_HANDLE_VALUE ; do we have an existing file with this name ?
                ; Yes...append a new name for it
                mov D$edi-4 '_New'
                call IncrementObjExportNameIndex
                mov esi RepeatedObjIndice
                While B$esi <> 0 | movsb | End_While
                mov D$edi '.obj' | add edi 4 | mov B$edi 0

            End_If

            ; Get the Offset
            move D$lvi.iItem D@SelectedItem
            mov D$lvi.iSubItem 5 ; [Header6: B$ 'Offset',0] ; hexadecimal value string
            call 'USER32.SendMessageA' D$hlist, &LVM_GETITEM, D@SelectedItem, lvi
            call AsciiBase szBuff0 BASE_HEX
            mov edi eax

            ; Get the size
            move D$lvi.iItem D@SelectedItem
            mov D$lvi.iSubItem 6 ; [Header7: B$ 'Size',0] ; decimal value
            call 'USER32.SendMessageA' D$hlist, &LVM_GETITEM, D@SelectedItem, lvi
            call String2Dword szBuff0

            mov esi D$LibFileMemory
            add esi edi
            call SaveLibFile, esi, eax, MultipleObjectPath
L1:
            mov edi D@FolderPathStart
            inc D@SelectedItem
            dec D@CountItens
        .Loop_Until D@CountItens = 0

    ...End_If
    popad
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[RepeatedObjIndice: '000000', 0]

IncrementObjExportNameIndex:
    lea ebx D$RepeatedObjIndice+5 | inc B$ebx
    While B$ebx > '9'
        mov B$ebx '0' | dec ebx | inc B$ebx
    End_While
ret

____________________________________________________________________________________________
____________________________________________________________________________________________



[LibSaveFileFilter: B$ 'Text File (*.txt)', 0  '*.txt', 0
                    B$ 'Assembly File (*.asm)', 0  '*.asm', 0
                    B$ 'All Files', 0  '*.*', 0 0]

[CustomLibFileFilter:  0 #&MAX_PATH]

[SaveLibFileTitle: B$ 'Save Library Structure report as...', 0]

; OPENFILENAMEA Structure

[SAVELIB:
 SAVELIB.lStructSize: D$ Len
 SAVELIB.hwndOwner: D$ 0
 SAVELIB.hInstance: D$ 0
 SAVELIB.lpstrFilter: D$ LibSaveFileFilter
 SAVELIB.lpstrCustomFilter: D$ CustomLibFileFilter
 SAVELIB.nMaxCustFilter: D$ 260
 SAVELIB.nFilterIndex: D$ 1
 SAVELIB.lpstrFile: D$ LibSaveFilter
 SAVELIB.nMaxFile: D$ 260
 SAVELIB.lpstrFileTitle: D$ ChoosenLibFile
 SAVELIB.nMaxFileTitle: D$ 260
 SAVELIB.lpstrInitialDir: D$ 0
 SAVELIB.lpstrTitle: D$ SaveLibFileTitle
 SAVELIB.Flags: D$ &OFN_EXPLORER__&OFN_FILEMUSTEXIST__&OFN_LONGNAMES__&OFN_PATHMUSTEXIST
 SAVELIB.nFileOffset: W$ 0
 SAVELIB.nFileExtension: W$ 0
 SAVELIB.lpstrDefExt: D$ 0
 SAVELIB.lCustData: D$ 0
 SAVELIB.lpfnHook: D$ 0
 SAVELIB.lpTemplateName: D$ 0]

[LibScanIsFileOpen: B$ &FALSE]

Proc SaveLibFileAs:
    Arguments @Adressee, @OutPut, @OutPutSize
    uses eax

    ; To Insert the Appended String. We inset it, when the user opens a new file only. On case the user presses Clear Button
    ; the Buffer is emptyed.
    If_And B$LibScanIsFileOpen = &FALSE, D$hLibReportEdit <> 0
        call LibScanAppendReportName LibSaveFilter
    End_If

    mov D$ChoosenLibFile 0
    move D$SAVELIB.lpstrFile LibSaveFilter
    move D$SAVELIB.hwndOwner D@Adressee
    move D$SAVELIB.hInstance D$hInstance
    move D$SAVELIB.lpstrFilter LibSaveFileFilter
    call 'Comdlg32.GetSaveFileNameA' SAVELIB

    On eax = 0, ExitP
    .If D$ChoosenLibFile <> 0
        If D$SAVELIB.nFilterIndex = 1 ; extension .txt
            call ForceExtension LibSaveFilter, '.txt'
        Else_If D$SAVELIB.nFilterIndex = 2 ; extension .asm
            call ForceExtension LibSaveFilter, '.asm'
        Else ; Force txt extensino if the user is trying to save as "all"
            call ForceExtension LibSaveFilter, '.txt'
        End_If
        call SaveLibFile, D@OutPut, D@OutPutSize, LibSaveFilter
    .End_If

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc LibScanAppendReportName:
    Arguments @String
    Uses eax, ecx, edi

    mov edi D@String
    ;sub edi 2     ; edi points to the end of the string 2

    .While edi >= D@String

        .If_Or B$edi = ':', B$edi = '/', B$edi = '\'

            Do
                On B$edi = '.', jmp L1>
                inc edi
            Loop_Until B$edi = 0
            jmp L1>
        .End_If

        ;dec edi
        inc edi
    .End_While
    L1:
        push esi | ZCopy {"Report.txt", 0} | pop esi
        mov D$edi 0
    mov B$LibScanIsFileOpen &TRUE
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc SaveLibFile:
    Arguments @OutPut, @OutPutSize, @FileFilter

    pushad

    call 'KERNEL32.CreateFileA' D@FileFilter, &GENERIC_WRITE,
                                &FILE_SHARE_READ__&FILE_SHARE_WRITE, &NULL, &CREATE_ALWAYS,
                                &FILE_ATTRIBUTE_NORMAL, &NULL

    mov D$LibFileHandle eax

    If eax = &INVALID_HANDLE_VALUE
        mov eax D$BusyFilePtr | call MessageBox | popad | ret
    End_If

    mov D$DestinationHandle eax, D$NumberOfReadBytes 0

    call 'KERNEL32.WriteFile' D$DestinationHandle, D@OutPut, D@OutPutSize, NumberOfReadBytes  0
    call 'KERNEL32.CloseHandle' D$DestinationHandle | mov D$DestinationHandle 0

    popad

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; This function will cleanup all previously loaded Data in case the user reopens the file without
; closing the CharMap Dialog

Proc LibScanCleanUp:
    Arguments @Adressee
    ; Free LibFileMemory
    VirtualFree D$LibFileMemory
    ; Free hLibReportEdit Report
    VirtualFree D$hLibReportEdit

    call 'USER32.SendDlgItemMessageA' D@Adressee, IDC_OPENLIBFILE, &WM_SETTEXT, 0, &NULL
    call 'USER32.SendDlgItemMessageA' D@Adressee, IDC_LIBFILESIZE, &WM_SETTEXT, 0, &NULL
    call 'USER32.SendDlgItemMessageA' D$hTabDlg1, IDC_LIB_SOURCE, &WM_SETTEXT, 0, &NULL
    call 'user32.SendMessageA', D$hList, &LVM_DELETEALLITEMS, 0, lvi
    call 'USER32.SendMessageA' D@Adressee, &WM_SETTEXT, 0, {"ScanLib v 1.0", 0}

    call ClearBuffer szBuff0, 256
    call ClearBuffer szBuff1, 256

    ; Must clean these listview itens to avoid that we have errors on the resequence
    mov D$lvi.iItem 0
    mov D$lvi.iSubItem 0
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc CoolControlDlg_CreateTab:
    Arguments @Adressee, @nIDDlgItem, @OutPutHandle, @CCTabStructure
    Local @TabsAmount, @UseImage


    mov D@TabsAmount 0
    mov D@UseImage 0

    call 'user32.GetDlgItem' D@Adressee, D@nIDDlgItem ; Get the Tab Control in the resources, and
                                                    ; use it on the handle of the main window
                                                    ; of this procedure.
    lea edi D@OutPutHandle
    mov edi D$edi
    mov D$edi eax                                   ; Now we return the result (found in eax), copying it to
                                                    ; the Handle of the Tab Control in the resource.
                                                    ; So, all we did was get the TAB Control and save it to the Tab handle.

    mov ecx D@CCTabStructure
    mov eax D$ecx+CCTabOrganize.ImageListDis

    If eax = 0
        mov D@UseImage &FALSE
    Else
        mov D@UseImage &TRUE
        push ecx | SendMessage D$edi, &TCM_SETIMAGELIST, 0, D$eax | pop ecx
    End_If

    mov edx D$ecx+CCTabOrganize.TCITEMDis
    move D$edx+TC_ITEM.imaskDis D$ecx+CCTabOrganize.iMaskFlagDis

    mov eax D$ecx+CCTabOrganize.TabsAmountDis
    move D@TabsAmount D$eax

    mov ebx 0

    .Do

        ; TabTitle copied to ts.pszText
        mov esi D$ecx+CCTabOrganize.StringArrayDis
        mov esi D$esi+ebx*4
        mov D$edx+TC_ITEM.pszTextDis esi

        ; TabTitleLen copied to ts.cchTextMax
        mov esi D$ecx+CCTabOrganize.StringLenArrayDis
        mov esi D$esi+ebx*4
        move D$edx+TC_ITEM.cchTextMaxDis D$esi

        If D@UseImage = &TRUE
            ; Image ID copied to ts.iImage
            mov D$edx+TC_ITEM.iImageDis ebx
        End_If

        push edx
        push ecx
        call 'user32.SendMessageA' D$edi &TCM_INSERTITEM ebx edx
        pop ecx
        pop edx

        inc ebx
    .Loop_Until ebx = D@TabsAmount
;;
[TC_ITEM.imaskDis 0
 TC_ITEM.lpReserved1Dis 4
 TC_ITEM.lpReserved2Dis 8
 TC_ITEM.pszTextDis 12
 TC_ITEM.cchTextMaxDis 16
 TC_ITEM.iImageDis 20
 TC_ITEM.lParamDis 24]
     
;;
;;

        mov D$ts.imask &TCIF_TEXT__&TCIF_IMAGE ; Mask text & image
        mov D$ts.pszText TabTitle1
        mov D$ts.cchTextMax TabTitle1Len
        mov D$ts.iImage 0
        call 'user32.SendMessageA' D$edi &TCM_INSERTITEM 0 ts

        mov D$ts.imask &TCIF_TEXT__&TCIF_IMAGE ; Mask text & image
        mov D$ts.pszText TabTitle2
        mov D$ts.cchTextMax TabTitle2Len
        mov D$ts.iImage 1
        call 'user32.SendMessageA' D$edi &TCM_INSERTITEM 1 ts

        mov D$ts.imask &TCIF_TEXT__&TCIF_IMAGE ; Mask text & image
        mov D$ts.pszText TabTitle3
        mov D$ts.cchTextMax TabTitle3Len
        mov D$ts.iImage 2
        call 'user32.SendMessageA' D$edi &TCM_INSERTITEM 2 ts


        mov D$ts.imask &TCIF_TEXT__&TCIF_IMAGE ; Mask text & image
        mov D$ts.pszText TabTitle4
        mov D$ts.cchTextMax TabTitle4Len
        mov D$ts.iImage 3
        call 'user32.SendMessageA' D$edi &TCM_INSERTITEM 3 ts
;;

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________


[LibScannerTitle: B$ 0 #100]

Proc WriteObjectTypeinTitle:
    Arguments @Adressee, @TextTitle

    pushad

    mov eax D@TextTitle
    mov edi LibScannerTitle
    push esi | Zcopy {"ScanLib v 1.0 - ", 0} | pop esi

    push esi | ZCopy eax | pop eax
    push esi | Zcopy {" Format", 0} | pop esi

    mov B$edi 0
    call 'USER32.SendMessageA' D@Adressee, &WM_SETTEXT, 0, LibScannerTitle

    popad

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; Enable / Gray-out execution control commands.

Proc LibScanDialog_EnableContinueMenu:
    Arguments @Enable

    If D@Enable = 1
        mov ebx &MF_ENABLED
    Else
        mov ebx &MF_GRAYED
    EndIf

    call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Close, ebx
    call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Save_Report, ebx
    call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Single_Object_File, ebx
    call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_All_Object_Files, ebx
    call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Runtime_Objects_Only, ebx
    call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Exported_Objects_Only, ebx
    call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Build_Dis_File, ebx

    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Close, D@Enable
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Save_Report, D@Enable
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Single_Object_File, D@Enable
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_All_Object_Files, D@Enable
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Runtime_Objects_Only, D@Enable
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Exported_Objects_Only, D@Enable
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Build_Dis_File, D@Enable

  ; Invert
    If D@Enable = 1
        mov ebx &MF_GRAYED
        mov D@Enable 0
    Else
        mov ebx &MF_ENABLED
        mov D@Enable 1
    EndIf

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc LibScanDialog_EnableContinueNextTabMenu:
    Arguments @Enable

    If D@Enable = 1
        mov ebx &MF_ENABLED
    Else
        mov ebx &MF_GRAYED
    EndIf

    call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Next_Tab, ebx
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Next_Tab, D@Enable

    call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Last_Tab, ebx
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Last_Tab, D@Enable
  ; Invert
    If D@Enable = 1
        mov ebx &MF_GRAYED
        mov D@Enable 0
    Else
        mov ebx &MF_ENABLED
        mov D@Enable 1
    EndIf

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc LibScanDialog_EnableContinuePrevTabMenu:
    Arguments @Enable
    uses eax, ecx, edx

    If D@Enable = 1
        mov ebx &MF_ENABLED
    Else
        mov ebx &MF_GRAYED
    EndIf

    call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_Previous_Tab, ebx
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_Previous_Tab, D@Enable

    call 'USER32.EnableMenuItem' D$LibScanMenuHandle, M03_First_Tab, ebx
    SendMessage D$LibScanToolbarHandle, &TB_ENABLEBUTTON, M03_First_Tab, D@Enable


  ; Invert
    If D@Enable = 1
        mov ebx &MF_GRAYED
        mov D@Enable 0
    Else
        mov ebx &MF_ENABLED
        mov D@Enable 1
    EndIf

EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc LibScanDisplayFileSize:
    Arguments @Adressee

    pushad
    ; Calculate and Display File Size
    mov edi buffer2
    lea esi D$LibFileLength

    mov ecx 4
    call toUDword
    mov esi edi, edi DecimalBuffer
    Do | movsb | LoopUntil B$esi = 0
    push esi | ZCopy {' Bytes', 0} | pop esi
    mov B$edi 0

    call 'USER32.SendDlgItemMessageA' D@Adressee IDC_LIBFILESIZE &WM_SETTEXT 0 DecimalBuffer
    call 'USER32.SendDlgItemMessageA' D@Adressee IDC_LIBFILESIZE &WM_GETTEXT 0 DecimalBuffer ; GET THE FILENAME
    popad
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc LibScanDialog_ToggleToolbarText:
    Arguments @Addresse
    Structure @TBButtonInfo 32, @Size 0, @Mask 4, @Text 24

    mov D@Size 32, D@Mask &TBIF_TEXT

  ; get check state of menu item, invert, toggle band and set inverted check state
    call 'User32.GetMenuState' D$LibScanMenuHandle, M03_Show_ToolBarText, &MF_BYCOMMAND
    push eax
        xor edx edx | test eax &MF_CHECKED | setz dl
        mov B$LibScanShowTBText dl
        call CoolControlWin_CreateCommandTB D@Addresse, LibScanToolbarHandle, LibScanToolbarButtons, LibScanToolButtonsNumber, LibScanToolTipsStrings, LSTBWin_Cmd
    pop eax
    xor eax &MF_CHECKED | and eax &MF_CHECKED
    call 'USER32.CheckMenuItem' D$LibScanMenuHandle, M03_Show_ToolBarText, eax
    SendMessage D$LibScanMenuHandle, &TB_AUTOSIZE, 0, 0

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

[LibScanHoverTBText: ?]

Proc LibScanDialog_HoverToolbarText:
    Arguments @Addresse
    Structure @TBButtonInfo 32, @Size 0, @Mask 4, @Text 24

    mov D@Size 32, D@Mask &TBIF_TEXT

  ; get check state of menu item, invert, toggle band and set inverted check state
    call 'User32.GetMenuState' D$LibScanMenuHandle, M03_Hover_ToolBar, &MF_BYCOMMAND
    push eax
        xor edx edx | test eax &MF_CHECKED | setz dl
        mov B$LibScanHoverTBText dl
        ;call CoolControlWin_CreateCommandTB D@Addresse, LibScanToolbarHandle, LibScanToolbarButtons, LibScanToolButtonsNumber, LibScanToolTipsStrings, LSTBWin_Cmd
    pop eax
    xor eax &MF_CHECKED | and eax &MF_CHECKED
    call 'USER32.CheckMenuItem' D$LibScanMenuHandle, M03_Hover_ToolBar, eax
    SendMessage D$LibScanMenuHandle, &TB_AUTOSIZE, 0, 0

EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

DecodeLib:   ; EncodeDecode
    mov B$WeAreInTheCodeBox &TRUE

        mov esi D$LibBytesCopy, edi D$LibDisassemblyPtr

      ; Disassemble: (DisMain)
        .While D$esi <> 0
            lodsd | mov edx esi | add edx eax

            While esi < edx
                push edx
                    mov B$DisFlag 0, D$SegmentOverride 0, B$AddressSizeOverride 0
                    mov B$OperandSizeOverride 0, W$DisSizeMarker 'D$'
                    mov B$DisCodeDisplacement &FALSE, B$EscapePrefix &FALSE

L1:                 movzx eax B$esi | inc esi | call D$DisOp1+eax*4
                    On B$DisFlag = DISDONE, jmp L1<

                    mov W$edi CRLF | add edi 2
                pop edx
            End_While

            mov D$edi CRLF2 | add edi 4 | mov esi edx
        .End_While

        mov D$LibDisassemblyPtr edi

    mov B$WeAreInTheCodeBox &FALSE
ret




__________________________________________________________________________________________________________________



; Tag Dialog 20

LibScanner:
    call 'USER32.DialogBoxParamA' D$hinstance, IDD_MAINLIB, &NULL, ScanLibFile, &NULL
ret

____________________________________________________________________________________________

[IDD_LIBSCANWARNINGMSG 23]
[IDC_DISPLAYWARNINGMSG 10]
[IDC_DISPLAYWARNINGHEXA 20]

[IDB_LIBWARNING_BITMAP 200]
[IDC_LIBWARNING_SHOWICON 6]

[LibScanWarnMsg: B$ "The Magic Signature Tag was not found.

This is not a Object File supported by this dumper
__________________________________________________", 0]

[LibScanHexaMsg: 0 #256]
[LibWarningStaticImage: D$ 0]
[LibScanhIcon: D$ 0]

Proc LibScanWarning:
    Arguments @Adressee, @Message, @wParam, @lParam

     pushad


    ..If D@Message = &WM_INITDIALOG

        call 'user32.GetDlgItem' D@Adressee IDC_LIBWARNING_SHOWICON ; Get the handle of the Static Image
        mov D$LibWarningStaticImage eax
        call 'USER32.LoadBitmapA' D$hInstance, IDB_LIBWARNING_BITMAP
        mov D$LibScanhIcon eax

        call 'user32.SendMessageA' D$LibWarningStaticImage, &STM_SETIMAGE, &IMAGE_BITMAP, D$LibScanhIcon
        call 'USER32.SendDlgItemMessageA' D@Adressee IDC_DISPLAYWARNINGMSG &WM_SETTEXT 0 LibScanWarnMsg
        call 'USER32.SendDlgItemMessageA' D@Adressee IDC_DISPLAYWARNINGMSG &WM_GETTEXT 0 LibScanWarnMsg

        ; Calculate and Display File Size
        mov edi LibScanHexaMsg
        mov ecx D$LibFileLength
        mov esi D$LibFileMemory

        If D$LibFileLength < 80  ; Maximum amount of bytes
            mov ecx D$LibFileLength
        Else_If ecx = 0 ; This shouldn´t happen, because we already have a Zero Size check, but...security is never too much ;)
            mov ecx 1
        Else
            mov ecx 80
        End_If

        ; Convert the 1st 80 Bytes to Decimal String notation.
        xor eax eax
        mov edx 0
        Do
            lodsb
            call writeeax
            xor eax eax
            mov B$edi ' ' | inc edi
            dec ecx
        Loop_Until ecx = 0
        mov B$edi 0

        call 'USER32.SetDlgItemTextA' D@Adressee, IDC_DISPLAYWARNINGHEXA, LibScanHexaMsg

    ..Else_If D@Message = &WM_CLOSE
        call ClearBuffer LibScanHexaMsg, 256
        call 'User32.EndDialog' D@Adressee &NULL

    ..Else_If D@Message = &WM_COMMAND
        .If D@wParam = &IDOK
            call ClearBuffer LibScanHexaMsg, 256
            call 'User32.EndDialog' D@Adressee &NULL
         .End_If

    ..Else

       popad | mov eax &FALSE | ExitP

    ..End_If

    popad
    mov eax &TRUE
EndP

____________________________________________________________

[szBuff1: B$ 0 #256]

Proc ListViewLibSort:
    Arguments @lParam1, @lParam2, @lParamSort
    Local @Dir1, @Dir2
    Uses edi, ebx, esi, ecx, edx

;    call ClearCharMapData szBuff0, 256
;    call ClearCharMapData szBuff1, 256

    and D@Dir1 0
    and D@Dir2 0
    mov D$lvi.imask &LVIF_TEXT
    lea eax D$szBuff0
    mov D$lvi.pszText eax
    mov D$lvi.cchTextMax 256

    mov D$lvi.iSubItem 01
    call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
    xor eax eax
    mov al B$szBuff0
    mov D@Dir1 eax
    call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi
    xor eax eax
    mov al B$szBuff0
    mov D@Dir2 eax

    ; Decimal Value [Header1: B$ 'Index',0]
    ..If_Or D@lParamSort = 01, D@lParamSort = 02

        mov D$lvi.iSubItem 0
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
        call String2Dword szBuff0
        mov edi eax
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi
        call String2Dword szBuff0

        If D@lParamSort = 1
            sub edi eax
            mov eax edi
        Else
            sub eax edi
        End_If

    ; Hexadecimal Value [Header2: B$ 'File Name',0] ; string
    ..Else_If_Or D@lParamSort = 3, D@lParamSort = 4

        mov D$lvi.iSubItem 1
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
        call strcpy szBuff1, szBuff0
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 3
            call lstrcmpi szBuff1, szBuff0
        Else
            call lstrcmpi szBuff0, szBuff1
        End_If

    ; [Header3: B$ 'Extension',0] ; string
    ..Else_If_Or D@lParamSort = 5, D@lParamSort = 6

        mov D$lvi.iSubItem 2
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
        call strcpy szBuff1, szBuff0
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 5
            call stricmp szBuff1, szBuff0
        Else
            call stricmp szBuff0, szBuff1
        End_If

    ; [Header4: B$ 'FileName Type',0] ; string
    ..Else_If_Or D@lParamSort = 7, D@lParamSort = 8

        mov D$lvi.iSubItem 3
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
        call strcpy szBuff1, szBuff0
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 7
            call stricmp szBuff1, szBuff0
        Else
            call stricmp szBuff0, szBuff1
        End_If

    ; [Header5: B$ 'Path',0] ; string
    ..Else_If_Or D@lParamSort = 9, D@lParamSort = 10

        mov D$lvi.iSubItem 4
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
        call strcpy szBuff1, szBuff0
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 9
            call lstrcmpi szBuff1, szBuff0
        Else
            call lstrcmpi szBuff0, szBuff1
        End_If

    ; [Header6: B$ 'Offset',0] ; hexadecimal value string
    ..Else_If_Or D@lParamSort = 11, D@lParamSort = 12

        mov D$lvi.iSubItem 5
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
        call AsciiBase szBuff0 BASE_HEX
        mov edi eax
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi
        call AsciiBase szBuff0 BASE_HEX

        If D@lParamSort = 11
            sub edi eax
            mov eax edi
        Else
            sub eax edi
        End_If


    ; [Header7: B$ 'Size',0] ; decimal value
    ..Else_If_Or D@lParamSort = 13, D@lParamSort = 14

        mov D$lvi.iSubItem 6
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
        call String2Dword szBuff0
        mov edi eax
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi
        call String2Dword szBuff0

        If D@lParamSort = 13
            sub edi eax
            mov eax edi
        Else
            sub eax edi
        End_If

    ; [Header8: B$ 'Object Type',0] ; string
    ..Else_If_Or D@lParamSort = 15, D@lParamSort = 16

        mov D$lvi.iSubItem 7
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
        call strcpy szBuff1, szBuff0
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 15
            call stricmp szBuff1, szBuff0
        Else
            call stricmp szBuff0, szBuff1
        End_If

    ; [Header9: B$ 'Exported Function',0] ; string
    ..Else_If_Or D@lParamSort = 17, D@lParamSort = 18

        mov D$lvi.iSubItem 8
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
        call strcpy szBuff1, szBuff0
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 17
            call lstrcmpi szBuff1, szBuff0
        Else
            call lstrcmpi szBuff0, szBuff1
        End_If

    ; [Header10: B$ 'Machine Type',0] ; string
    ..Else_If_Or D@lParamSort = 19, D@lParamSort = 20

        mov D$lvi.iSubItem 9
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
        call strcpy szBuff1, szBuff0
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi

        If D@lParamSort = 19
            call lstrcmpi szBuff1, szBuff0
        Else
            call lstrcmpi szBuff0, szBuff1
        End_If

    ; [Header11: B$ 'Sections',0] ; decimal value
    ..Else_If_Or D@lParamSort = 21, D@lParamSort = 22

        mov D$lvi.iSubItem 10
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
            If_And D$szBuff0 = 'No S', D$szBuff0+4 = 'ecti' ; "No Sections" string = 0
                mov eax 0
            Else
                call String2Dword szBuff0
            End_If
        mov edi eax
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi
            If_And D$szBuff0 = 'No S', D$szBuff0+4 = 'ecti' ; "No Sections" string = 0
                mov eax 0
            Else
                call String2Dword szBuff0
            End_If
        If D@lParamSort = 21
            sub edi eax
            mov eax edi
        Else
            sub eax edi
        End_If

    ; [Header12: B$ 'Time and Date',0] ; time and date string - convert it to dword
    ..Else_If_Or D@lParamSort = 23, D@lParamSort = 24

        mov D$lvi.iSubItem 11
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
        ;TimeDateStringtoDword
        call strcpy szBuff1, szBuff0
        mov edi eax
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi
        call String2Dword szBuff0

        If D@lParamSort = 23
            call lstrcmpi szBuff1, szBuff0
        Else
            call lstrcmpi szBuff0, szBuff1
        End_If

    ; [Header13: B$ 'Symbols',0] ; decimal value
    ..Else_If_Or D@lParamSort = 25, D@lParamSort = 26
        mov D$lvi.iSubItem 12
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
            If_And D$szBuff0 = 'No S', D$szBuff0+4 = 'ymbo' ; "No Symbols" String = 0
                mov eax 0
            Else
                call String2Dword szBuff0
            End_If
        mov edi eax
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi
            If_And D$szBuff0 = 'No S', D$szBuff0+4 = 'ymbo' ; "No Symbols" String = 0
                mov eax 0
            Else
                call String2Dword szBuff0
            End_If
        If D@lParamSort = 25
            sub edi eax
            mov eax edi
        Else
            sub eax edi
        End_If

    ; [Header14: B$ 'Optional Header',0] ; string
    ..Else_If_Or D@lParamSort = 27, D@lParamSort = 28
        ; Optional Header can be only True or False.
        mov D$lvi.iSubItem 13
        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam1, lvi
            If D$szBuff0 = 'True'
                mov eax 1
            Else
                mov eax 0
            End_If
        mov edi eax

        call 'USER32.SendMessageA' D$hlist, &LVM_GETITEMTEXT, D@lParam2, lvi
            If D$szBuff0 = 'True'
                mov eax 1
            Else
                mov eax 0
            End_If

        If D@lParamSort = 27
            sub edi eax
            mov eax edi
        Else
            sub eax edi
        End_If



    ..End_If
;---------- [Keep the folders on top] ----------

    .If_And B@Dir1 = '<', B@Dir2 <> '<'
        xor eax eax
        dec eax
        ExitP
    .Else_If_And B@Dir2 = '<', B@Dir1 <> '<'
        xor eax eax
        inc eax
        ExitP
    .Else_If_And B@Dir1 = '<', B@Dir2 = '<'
        xor eax eax
    .End_If

EndP


________________________________________________________________________________________


; ToolBar Data and Functions

[LibScanMenuHandle: ?]
[LibScanDialog_ImageList: ?]
[IDB_LibScanEnableTB 30]
[IDB_LibScanDisableTB 31]
[LibScanToolbarHandle: D$ 0]

[LIBSCANDLG_TOOLBAR 400]

; Flow control buttons ; TBBUTTON Structure

[LibScanToolbarButtons:
    LSTB01.iBitmap: D$ 0
    LSTB01.idCommand: D$ M03_Open
    LSTB01.fsState: B$ &TBSTATE_ENABLED
    LSTB01.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB01._wPad1: W$ 0
    LSTB01.dwData: D$ 0
    LSTB01.iString: D$ 0

    LSTB02.iBitmap: D$ 1
    LSTB02.idCommand: D$ M03_Close
    LSTB02.fsState: B$ &TBSTATE_ENABLED
    LSTB02.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB02._wPad1: W$ 0
    LSTB02.dwData: D$ 0
    LSTB02.iString: D$ 0

    LSTB03.iBitmap: D$ 2
    LSTB03.idCommand: D$ M03_Save_Report
    LSTB03.fsState: B$ &TBSTATE_ENABLED
    LSTB03.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB03._wPad1: W$ 0
    LSTB03.dwData: D$ 0
    LSTB03.iString: D$ 0

    LSTB04.iBitmap: D$ 3
    LSTB04.idCommand: D$ M03_Single_Object_File
    LSTB04.fsState: B$ &TBSTATE_ENABLED
    LSTB04.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB04._wPad1: W$ 0
    LSTB04.dwData: D$ 0
    LSTB04.iString: D$ 0

    LSTB05.iBitmap: D$ 4
    LSTB05.idCommand: D$ M03_All_Object_Files
    LSTB05.fsState: B$ &TBSTATE_ENABLED
    LSTB05.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB05._wPad1: W$ 0
    LSTB05.dwData: D$ 0
    LSTB05.iString: D$ 0

    LSTB06.iBitmap: D$ 5
    LSTB06.idCommand: D$ M03_Build_Dis_File
    LSTB06.fsState: B$ &TBSTATE_ENABLED
    LSTB06.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB06._wPad1: W$ 0
    LSTB06.dwData: D$ 0
    LSTB06.iString: D$ 0

    LSTB07.iBitmap: D$ 6
    LSTB07.idCommand: D$ M03_Next_Tab
    LSTB07.fsState: B$ &TBSTATE_ENABLED
    LSTB07.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB07._wPad1: W$ 0
    LSTB07.dwData: D$ 0
    LSTB07.iString: D$ 0

    LSTB08.iBitmap: D$ 7
    LSTB08.idCommand: D$ M03_Previous_Tab
    LSTB08.fsState: B$ &TBSTATE_ENABLED
    LSTB08.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB08._wPad1: W$ 0
    LSTB08.dwData: D$ 0
    LSTB08.iString: D$ 0

    LSTB09.iBitmap: D$ 8
    LSTB09.idCommand: D$ M03_First_Tab
    LSTB09.fsState: B$ &TBSTATE_ENABLED
    LSTB09.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB09._wPad1: W$ 0
    LSTB09.dwData: D$ 0
    LSTB09.iString: D$ 0

    LSTB10.iBitmap: D$ 9
    LSTB10.idCommand: D$ M03_Last_Tab
    LSTB10.fsState: B$ &TBSTATE_ENABLED
    LSTB10.fsStyle: B$ &BTNS_AUTOSIZE
    LSTB10._wPad1: W$ 0
    LSTB10.dwData: D$ 0
    LSTB10.iString: D$ 0]


[LIBSCAN_TOOLBAR_STYLE &WS_CHILD__&WS_VISIBLE__&TBSTYLE_FLAT__&TBSTYLE_LIST__&TBSTYLE_AUTOSIZE__&TBSTYLE_TRANSPARENT__&TBSTYLE_TOOLTIPS__&CCS_TOP]

[LibScanShowTBText: ?]

[StrLibScanOpen:      'Open' 0
 StrLibScanClose:     'Close' 0
 StrLibScanSave:      'Save Report' 0
 StrLibScanSingleObj: 'Extract Single Object' 0
 StrLibScanAllObj:    'Extract All Objects' 0
 StrLibScanDIS:       'Build DIS File' 0
 StrLibScanNextTab:   'Goto Next tab' 0
 StrLibScanPrevTab:   'Goto Previous tab' 0
 StrLibScanFirstTab:  'Goto First tab' 0
 StrLibScanLastTab:   'Goto Last tab' 0]

[LibScanToolButtonsNumber 10]

[LibScanToolTipsStrings: StrLibScanOpen StrLibScanClose StrLibScanSave StrLibScanSingleObj
                         StrLibScanAllObj StrLibScanDIS StrLibScanNextTab StrLibScanPrevTab
                         StrLibScanFirstTab StrLibScanLastTab]


[LSTBWin_Cmd:
 LSTBWin_Cmd.bWidth: D$ 20
 LSTBWin_Cmd.dwStyle: D$ LIBSCAN_TOOLBAR_STYLE
 LSTBWin_Cmd.hMenu: D$ LIBSCANDLG_TOOLBAR
 LSTBWin_Cmd.hIml: D$ LibScanDialog_ImageList
 LSTBWin_Cmd.ShowTxtFlag: D$ LibScanShowTBText]

__________________________________________________________________________________________

; Tab Control Data and Functions

[IDB_LibScanTABEnable 40]
[IDB_LibScanTABDisable 41]

[LibScanTabControlsNumber 4]

; This structure is of the type TC_ITEM
[ts:
 ts.imask: D$ &TCIF_TEXT
 ts.lpReserved1: D$ 0
 ts.lpReserved2: D$ 0
 ts.pszText: D$ 0
 ts.cchTextMax: len
 ts.iImage: D$ 0-01
 ts.lParam: D$ 0]

[TC_ITEM.imaskDis 0
 TC_ITEM.lpReserved1Dis 4
 TC_ITEM.lpReserved2Dis 8
 TC_ITEM.pszTextDis 12
 TC_ITEM.cchTextMaxDis 16
 TC_ITEM.iImageDis 20
 TC_ITEM.lParamDis 24]

; Tab Dialog Messages and Data

[TabTitle1: B$ "Library Structure" 0
TabTitle1Len: D$ len]

[TabTitle2: B$ "Object Files" 0
TabTitle2Len: D$ len]

[TabTitle3: B$ "Disassembled Display" 0
TabTitle3Len: D$ len]

[TabTitle4: B$ "DIS Builder" 0
TabTitle4Len: D$ len]

[LibScanTabToolTipStrings: TabTitle1 TabTitle2 TabTitle3 TabTitle4]
[LibScanTabToolTipStringsLen: TabTitle1Len TabTitle2Len TabTitle3Len TabTitle4Len]

; CCTabOrganize Structure

[LibScanTabControl:
 LibScanTabControl.TCITEM: D$ ts
 LibScanTabControl.iMaskFlag: D$ &TCIF_TEXT__&TCIF_IMAGE
 LibScanTabControl.ImageList: D$ LibScanTab_ImageList
 LibScanTabControl.TabsAmount: D$ LibScanTabNumber
 LibScanTabControl.StringArray: D$ LibScanTabToolTipStrings
 LibScanTabControl.StringLenArray: D$ LibScanTabToolTipStringsLen]

[CCTabOrganize.TCITEMDis 0
 CCTabOrganize.iMaskFlagDis 4
 CCTabOrganize.ImageListDis 8
 CCTabOrganize.TabsAmountDis 12
 CCTabOrganize.StringArrayDis 16
 CCTabOrganize.StringLenArrayDis 20]

[Size_Of_CCTabOrganize 24]


[LibScanTabNumber: 4]

[hTab: D$ 0] ; Handle of the Tab Control in the resource, that is inside the main Dialog

[SelTab: D$ 0] ; Selection Tab Flag.

[hTabDlg1: D$ 0 ; Handle of the 1st Dialog MZ Header
 hTabDlg2: D$ 0 ; Handle of the 2nd Dialog PE Header
 hTabDlg3: D$ 0 ; Handle of the 3rd Dialog PE DataDirectory Header
 hTabDlg4: D$ 0] ; Handle of the 4th Dialog Image Section Headers

__________________________________________________________________________________________


; RunTime Functions


;;

    Concatenation
    
    This function concatenates (join) 02 strings, and save the result on a buffer.

 Parameters:
 
    Source1: The 1st string to be joined
  
    Source2: The 2nd string to be joined
    
    Destination: The outputed buffer where the new string is stored
 

 Usage Example:
 
 
    call Concatenation {"HY ! My name is",0} {"Guga", 0}  edi

_______________________________________________________________

  Author:
    
    RobotBob (Eric) - Original Author

;;


Proc Concatenation:
    Arguments @Source1, @Source2, @Destination
    Uses esi, edi

        mov esi D@Source1, edi D@Destination
        While B$esi <> 0 | movsb | End_While

        mov esi D@Source2
        While B$esi <> 0 | movsb | End_While

        movsb
EndP
____________________________________________________________________________________________________________

; Guga CodeView Equates



;;
#define MAKESIG(a,b,c,d)        ((a) | ((b) << 8) | ((c) << 16) | ((d) << 24))
#define CODEVIEW_NB09_SIG       MAKESIG('N','B','0','9')
#define CODEVIEW_NB10_SIG       MAKESIG('N','B','1','0')
#define CODEVIEW_NB11_SIG       MAKESIG('N','B','1','1')
#define CODEVIEW_RSDS_SIG       MAKESIG('R','S','D','S')

;;

[MAKESIG | (#1 or (#2 shl 8) or (#3 shl 16) or (#4 shl 24))]

[CODEVIEW_NB09_SIG 03930424E] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','9'] ; The result is reversed NB09
[CODEVIEW_NB10_SIG 03031424E] ; [CODEVIEW_NB10_SIG  MAKESIG 'N','B','1','0'] ; The result is reversed NB10
[CODEVIEW_NB11_SIG 03131424E] ; [CODEVIEW_NB11_SIG  MAKESIG 'N','B','1','1'] ; The result is reversed NB11
[CODEVIEW_RSDS_SIG 053445352] ; [CODEVIEW_RSDS_SIG  MAKESIG 'R','S','D','S'] ; The result is reversed RSDS


; weird. The real signature (pdb files) in hexadecimal is not reversed. It is the regular order, Like:
;;
[CODEVIEW_NB00_SIG 04E423030] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','0'] ; The result is NB00
[CODEVIEW_NB01_SIG 04E423031] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','1'] ; The result is NB01
[CODEVIEW_NB02_SIG 04E423032] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','2'] ; The result is NB02
[CODEVIEW_NB03_SIG 04E423033] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','3'] ; The result is NB03
[CODEVIEW_NB04_SIG 04E423034] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','4'] ; The result is NB04
[CODEVIEW_NB05_SIG 04E423035] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','5'] ; The result is NB05
[CODEVIEW_NB06_SIG 04E423036] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','6'] ; The result is NB06
[CODEVIEW_NB07_SIG 04E423037] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','7'] ; The result is NB07
[CODEVIEW_NB08_SIG 04E423038] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','8'] ; The result is NB08
[CODEVIEW_NB09_SIG 04E423039] ; [CODEVIEW_NB09_SIG  MAKESIG 'N','B','0','9'] ; The result is NB09
[CODEVIEW_NB10_SIG 04E423130] ; [CODEVIEW_NB10_SIG  MAKESIG 'N','B','1','0'] ; The result is NB10
[CODEVIEW_NB11_SIG 04E423131] ; [CODEVIEW_NB11_SIG  MAKESIG 'N','B','1','1'] ; The result is NB11
[CODEVIEW_RSDS_SIG 052534453] ; [CODEVIEW_RSDS_SIG  MAKESIG 'R','S','D','S'] ; The result is RSDS
;;


;;

Note to Guga:

It seems that when a Lib file is used by the linker, it inserts the whole object file that
uses a specific function that was called by the source.

For example, if we have a source file with a call to a external lib containing "Function01", and this lib file
have 45 different Object files. The only Object file that will be used and "linked" is the one containing the 
"Functino01" function. (Example, if this function exists only in Object 32.

What happens is that the whole Object32.obj (Inside that lib) is used and linked/injected inside to produce the new
application. This explains why some applications have too many nested data inside code. Because the Object file that
is injected is fixed. And it contains theit own Code and Data sectinos, but the final application interprets it as 
Code only to inject the function on the final code section.

Sometimes it don´ happens, because when you build your file, the 1st to be done is to use the linked object/libs,
and after it is used, the compiler translates the Source code to produce the new object file. So this new object
file is surrounding the fixed object files. Like:


1st step:

Source Code
 --- Fixed Object File (Code Section)
 ----Fixed Object File (Data Section)
 
 2nd step , Linking
 
 Resultant Object File from source file. (Code Section from the new Object file) --|
 --- Fixed Object File (Code Section)                                              |
 ----Fixed Object File (Data Section)                                              |
 Resultant Object File from source file. (Data Section from the new Object file) --|
 
 Or something Like this.
 
 So, what we can do for the DIS ?
 
 Maybe the better is we once we identify a specific function, we check which Object File (Inside or not a lib)
 it belongs to, and then we just need to disassemble that whole object file that is evidently inside the exe.

Bingo !!!
This is exactly this :):):)
Check on ml.exe

We will see this function:
_flsall at 0043E359

It belongs to a specific object file 394 inside that consists in only this function.

Immediatelly after this function we have another one:

__mbsdec at 0043E3C6

This one belongs to other object file. (On the same lib)

Also, check the function _memcpy it contains nested code and data, and no debug info, but the relocs, and symbols seems
to be enough to find what are the data and code part of it.

;;



;;
 Note to René

a) Assembler Errors

        call 'Kernel32.WriteFile' D@File, RegContent, 14, BytesTransfered, 0

        mov edi RegContent | mov W$edi+1 'DX' | add edi 4
"       DwordToHex D$ebx+0A8
        call 'Kernel32.WriteFile' D@File, RegContent, 14, BytesTransfered, 0


When i try to assemble a copy of RoAsm2028b with RosAsm2028b, it keeps inserting a " char like above.
It causes rosasm to now assemble the file. The reason is because after assemblying it and RosAsm do
his job, it changes the lines of the source code and adds this extra ".


LibScannner

a) Errors: 

In several places of the whole RosAsm source i found a mismatch of size in CRLF displacement.
It was displaying this:

mov D$edi CRLF | add edi 2

When the correct is:

mov W$edi CRLF | add edi 2

Like in the Error Tab, here:

mov esi D@Text1, edi Trash1, ecx 0 | mov D$edi CRLF | add edi 2
(...)
mov esi D@Text2, edi Trash2, ecx 0 | mov D$edi CRLF | add edi 2


b) On file libgccguga.a, and on libgcc.a it was crashing due to an memory error.


I Fixed it increasing allocated memory here:

  ; Allocate mem for Strings ('CompletionTable')
  ; and for list of pointers to Strings ('CompletionPointers'):

    push ecx
        ;inc ecx | shl ecx 2 | or ecx 1
        inc ecx | shl ecx 5 | or ecx 1 ; -----------> Added this
        VirtualAlloc CompletionPointers ecx
    pop ecx

    ;shl ecx 5 | or ecx 1
    shl ecx 8 | or ecx 1 ; -------------------------> Added this
    VirtualAlloc CompletionTable ecx | inc D$CompletionTable

  ; Fill the Tables:
    mov edi D$CompletionTable, ebx D$CompletionPointers


Note: Although it is fixed, the same memory problem hapens on UAFXCWD.LIB
The file does not load completelly on the object listing and also don't load on the structure editor.
So, maybe we need to calculate and extend memory like in ReMapSourceMemoryIfNeeded
The reason is because the generated text file is something around 0C0D3407 bytes (202,20 Mb)

c) Even fixing the above memory problem. It still crashes on LIBCMTD.LIB
THis one i couldn't fix 

Proc SetQwordCheckSum:
    Argument @Pointer

    pushad

        mov esi D@Pointer

        If B$esi < '0'
            ;
        Else_If B$esi <= '9'
            error D$NumerAsSymbolPtr
        End_If

        call CheckSum64 | call NoDuplication D@Pointer | call CheckSum16

      ; The List Pointer is used to test empty Records (Lists Pointers can never be zero):
        .If D$CheckSumsRecords+ecx = 0
            On D$CheckSumsRecords+ecx+4 <> 0, jmp L1>
            mov D$CheckSumsRecords+ecx eax
            mov D$CheckSumsRecords+ecx+4 ebx
            move D$CheckSumsRecords+ecx+8 D@Pointer
          ; D$CheckSumsRecords+ecx+12 = 0
        .Else
L1:         If D$CheckSumsRecords+ecx+12 = 0
                move D$CheckSumsRecords+ecx+12 D$PointerToCheckSumsLinkedRecords
            Else
                mov edi D$CheckSumsRecords+ecx+12
                While D$edi+12 <> 0 | mov edi D$edi+12 | End_While
                move D$edi+12 D$PointerToCheckSumsLinkedRecords
            End_If

            mov edi D$PointerToCheckSumsLinkedRecords
            mov D$edi eax ; -----------------------------> Crashes here

d) Fixed Loading BookMarks when Loading the MRU files.

When i loaded a file through the MRU List, the bookmarks where not being loaded.
I fixed here (MainProc TAB):



            .Else_If eax > 3000             ; Most Recently Used Files.
                If eax < 3005
                    push eax
                        call Security       ; 'Security' also uses eax as return Value.
                    pop ebx
                    On eax = &IDCANCEL, jmp L9>>
                        mov eax ebx         ; ... and 'LoadRMUfile' as input.
                        call LoadRMUfile | call EnableMenutems | call LoadBookMarks ; added the call to LoadBookmarks


e) Small codecomplete error.

I added some new equates for CodeView 4, but if i start typing:

"&CV4_" and press control space an error messagebox shows up saying that it can´ find the equate and ask me to build a list.

But, if i type only: "&CV" and press control+space, the list displays properly

I added some equates like: &CV4_COMPILE_MACHINE_I80


f) RosAsm is crashing on Preparse Equal

If i write at the top of this lib "PREPARSE Equal" (After the Title) RosAsm crashes badly

g) Disassembler error on Floating Point Data.

Here:

[Data04D17F4: T$ 1.414214]
[<Data04D17FE: B$ 0, 0, 080, 07F  B$ 0, 0]
[Data04D1804: B$ 0, 048, 0C0, 0FF, F$ 0.5, F$ -1.443411e+035, F$ -4.952773e-007
                 F$ 2.295747e-041, F$ 4.573838e-041]
                 
Should be:

[Data04D17F4: T$ 1.414214]
[Data04D17FE: F$ 3.4028237e+038]
[Data04D1804: F$ -5.1117124e+038, F$ 0.5, F$ -1.443411e+035, F$ -4.952773e-007
                 F$ 2.295747e-041, F$ 4.573838e-041]

This is because all of them points to Fld instructions, like:

here:
    fld F$Data04D17FE
jmp E4>  ; Code04AAF8C
    
Code04AAF1B: J1:


and here:
    
Code04AAFD2: L4:
    fstp ST0
    fld F$Data04D1804
    
Code04AAFDA: M2:

h) Disassembler error on MMX mnemonic.

On testing.exe from C:\Guga\EvilHomerNewSite\site\stig.servehttp.com\homer\DirectX\Example1, ehit is being disasembled:

    cvtpq2ps XMM0 XMM2                ; 0F 5B C2 
    cvtpq2ps XMM2 XMM7                ; 0F 5B D7 
    mulps XMM0 XMM1                   ; 0F 59 C1 
    mulps XMM3 XMM2                   ; 0F 59 DA 
    pop ecx                           ; 59 
    ret                               ; C3 
    
Code040A4CC: B2:

But the correct is cvtdq2ps, like:

    cvtdq2ps XMM0 XMM2                ; 0F 5B C2 
    cvtdq2ps XMM2 XMM7                ; 0F 5B D7 
    mulps XMM0 XMM1                   ; 0F 59 C1 
    mulps XMM3 XMM2                   ; 0F 59 DA 
    pop ecx                           ; 59 
    ret                               ; C3 
    
Code040A4CC: B2:

I changed here:


cvtdq2ps

Op5B:
    .If B$EscapePrefix = &FALSE
        mov D$edi 'pop ' | add edi 4
        If B$OperandSizeOverride = &FALSE
            inc D$LikelyCode
            mov D$edi 'ebx ' | add edi 3
        Else
           ; inc D$UnLikelyCode
            mov W$edi 'bx' | add edi 2
        End_If

    .Else

        ;inc D$UnLikelyCode
;        mov D$edi 'cvtp'
        If B$OperandSizeOverride = &TRUE ; CVTPS2DQ xmm1, xmm2/m128
            mov D$edi 'cvtp'
            mov D$edi+4 's2dq'
        Else                             ; CVTDQ2PS xmm1, xmm2/m128
            mov D$edi 'cvtd'            ; Guga fix. It must be cvtd
            mov D$edi+4 'q2ps'          ; Guga Error Here. It is d2ps and not q2ps
        End_If
        mov B$edi+8 ' ' | add edi 9 | jmp Dis_xmm1__xmm2_m128

Also on this same file we have several problems of bad interpretations of code as data. It comes for example from here:

All of the Pointers are to Code and Not data, like "mov D$ecx  Code04124BB" ; "mov D$ecx+04 Code0411707" etc etc

Code0406E53: O7:
    call Code0406D6F
    test al 020
    mov ecx D$esp+04 | je Code040708C
    test al al | jns Code040708C
    test ah 01
    mov D$ecx  Data04124BB ; error here it is a pointer to code and not to data
    mov D$ecx+04 Data0411707 ; error here it is a pointer to code and not to data
    mov D$ecx+08 Data041277C ; error here it is a pointer to code and not to data
    mov D$ecx+0C Data040D957 ; error here it is a pointer to code and not to data
    mov D$ecx+014 Data0412510 ; error here it is a pointer to code and not to data
    mov D$ecx+018 Data0411778 ; error here it is a pointer to code and not to data
    mov D$ecx+01C Code04117DF
    mov D$ecx+020 Data04127FE ; error here it is a pointer to code and not to data
    mov D$ecx+024 Data0412549 ; error here it is a pointer to code and not to data
    mov D$ecx+028 Code0411CBF
    mov D$ecx+02C Data040DB89 ; error here it is a pointer to code and not to data
    mov D$ecx+030 Data0412BA6 ; error here it is a pointer to code and not to data
    mov D$ecx+034 Data0412BE9 ; error here it is a pointer to code and not to data
    mov D$ecx+038 Code0411CC4
    mov D$ecx+03C Code0411E4C
    mov D$ecx+040 Data041285D ; error here it is a pointer to code and not to data
    mov D$ecx+044 Data04125AD ; error here it is a pointer to code and not to data
    mov D$ecx+048 Data04116EB ; error here it is a pointer to code and not to data
    mov D$ecx+04C Data040C47C ; error here it is a pointer to code and not to data
    mov D$ecx+050 Data040C515 ; error here it is a pointer to code and not to data
    mov D$ecx+054 Code0412D8B
    mov D$ecx+058 Data0412CCD ; error here it is a pointer to code and not to data
    mov D$ecx+05C Data040C572 ; error here it is a pointer to code and not to data
    mov D$ecx+060 Data040C5B6 ; error here it is a pointer to code and not to data
    mov D$ecx+064 Data040C9E7 ; error here it is a pointer to code and not to data
    mov D$ecx+068 Data040DC58 ; error here it is a pointer to code and not to data
    mov D$ecx+06C Data040DCA8 ; error here it is a pointer to code and not to data
    mov D$ecx+070 Data040DD93 ; error here it is a pointer to code and not to data
    mov D$ecx+074 Data040CAAC ; error here it is a pointer to code and not to data
    mov D$ecx+078 Data040DE6F ; error here it is a pointer to code and not to data
    mov D$ecx+07C Data040DED2 ; error here it is a pointer to code and not to data
    mov D$ecx+080 Data040DF30 ; error here it is a pointer to code and not to data
    mov D$ecx+084 Data040DF89 ; error here it is a pointer to code and not to data
    mov D$ecx+088 Data0412DEF ; error here it is a pointer to code and not to data
    mov D$ecx+08C Code040CB18
    mov D$ecx+090 Data040CC4F ; error here it is a pointer to code and not to data
    mov D$ecx+094 Data040DFD0 ; error here it is a pointer to code and not to data
    mov D$ecx+098 Data040E078 ; error here it is a pointer to code and not to data
    mov D$ecx+09C Code040E1FF
    mov D$ecx+0A0 Data040F397 ; error here it is a pointer to code and not to data
    mov D$ecx+0A4 Data040F53C ; error here it is a pointer to code and not to data
    mov D$ecx+0A8 Code040FA70
    mov D$ecx+0AC Data040CCDC ; error here it is a pointer to code and not to data
    mov D$ecx+0B0 Data040CD6E ; error here it is a pointer to code and not to data
    mov D$ecx+0D8 Data041298F ; error here it is a pointer to code and not to data
    mov D$ecx+0CC Data041183E ; error here it is a pointer to code and not to data
    mov D$ecx+0C0 Data0412645 ; error here it is a pointer to code and not to data
    mov D$ecx+0B8 Data041268E ; error here it is a pointer to code and not to data
    mov D$ecx+0D0 Data0412A00 ; error here it is a pointer to code and not to data
    mov D$ecx+0C4 Data04118AF ; error here it is a pointer to code and not to data
    mov D$ecx+0DC Data040CDD2 ; error here it is a pointer to code and not to data
    mov D$ecx+0E0 Data040CE79 ; error here it is a pointer to code and not to data
    mov D$ecx+0D4 Data0412AC8 ; error here it is a pointer to code and not to data
    mov D$ecx+0BC Data04126D1 ; error here it is a pointer to code and not to data
    mov D$ecx+0C8 Data0411983 ; error here it is a pointer to code and not to data
    mov D$ecx+010 Data0410FBF ; error here it is a pointer to code and not to data
    mov D$ecx+0B4 Code040CF1E
    mov D$ecx+0E8 Code0412200
    mov D$ecx+0E4 Code0412340 | je H6>  ; Code040708C
    test ah 02 | je H6>  ; Code040708C
    mov D$ecx+03C Code0412072
    mov D$ecx+048 Code0410CDD
    mov D$ecx+098 Data040E14A ; error here it is a pointer to code and not to data
    mov D$ecx+09C Code040FB89
    mov D$ecx+060 Data040C7D2 ; error here it is a pointer to code and not to data
    
Code040708C: H6:
    test al 040 | je A0>  ; Code04070E0
    mov D$ecx+0F8 Code040BE40
    mov D$ecx+0FC Code040BEE0
    mov D$ecx+0100 Data040C200 ; error here it is a pointer to code and not to data
    mov D$ecx+0EC Data040B7C0 ; error here it is a pointer to code and not to data
    mov D$ecx+0F0 Data040BA20 ; error here it is a pointer to code and not to data
    mov D$ecx+0F4 Data040BC80 ; error here it is a pointer to code and not to data
    mov D$ecx+0104 Code040B700
    mov D$ecx+0110 Code040B640
    
Code04070E0: A0:
    ret


You will also note that even fixing this we have other errors like it may result in this (After fixing the Data to Code problem):

Code040C47C: M4:
    mov edx D$esp+0C
    mov eax D$esp+08
    movq MM2 Q$edx 
    movq MM3 Q$edx+08
    movq MM4 MM2
    movq MM5 MM3
    movq MM0 Q$eax 
    punpckhdq MM4 MM2
    punpckhdq MM5 MM3
    movq MM1 Q$eax+08
    punpckldq MM4 MM2
    punpckldq MM5 MM3
    mov eax D$esp+04
    movq MM6 MM4
    movq MM7 MM5
    psrlw MM6 Q$edi+ecx+089E02DEF ; Error Here
    inc ecx
    add B$edi  cl
    psubusb MM6 Q$edi+ecx+089E015EF
    inc ecx
    add B$edi  cl
    psubsb MM6 Q$edi+ecx+0FB4E10F
    psrlq MM3 Q$esi+0F1A6F0F
    pmulhw MM3 Q$edx+086A6F0F
    psubw MM6 Q$edi+ecx+089E035EF
    inc ecx
    add B$edi  cl
    psrad MM5 Q$esi+0B4F00F0F
    pxor MM5 Q$Data04189E0
    psubusb MM6 Q$edi+ecx+0F0F207F
jmp 0F74FD4B7

But the correct is:
Code040C47C: M4:

.text:0040C47C                 mov     edx, [esp+0Ch]
.text:0040C480                 mov     eax, [esp+8]
.text:0040C484                 movq    mm2, qword ptr [edx]
.text:0040C487                 movq    mm3, qword ptr [edx+8]
.text:0040C48B                 movq    mm4, mm2
.text:0040C48E                 movq    mm5, mm3
.text:0040C491                 movq    mm0, qword ptr [eax]
.text:0040C494                 punpckhdq mm4, mm2
.text:0040C497                 punpckhdq mm5, mm3
.text:0040C49A                 movq    mm1, qword ptr [eax+8]
.text:0040C49E                 punpckldq mm4, mm2
.text:0040C4A1                 punpckldq mm5, mm3
.text:0040C4A4                 mov     eax, [esp+4]
.text:0040C4A8                 movq    mm6, mm4
.text:0040C4AB                 movq    mm7, mm5
.text:0040C4AE                 pfmul   mm2, mm1
.text:0040C4B2                 pxor    mm5, ds:qword_4189E0
.text:0040C4B9                 pfmul   mm3, mm0
.text:0040C4BD                 pxor    mm2, ds:qword_4189E0
.text:0040C4C4                 pfmul   mm5, mm0
.text:0040C4C8                 pfmul   mm4, mm1
.text:0040C4CC                 pfadd   mm2, mm3
.text:0040C4D0                 movq    mm3, qword ptr [edx]
.text:0040C4D3                 pfsub   mm4, mm5
.text:0040C4D7                 movq    mm5, qword ptr [edx+8]
.text:0040C4DB                 pfmul   mm7, mm1
.text:0040C4DF                 pxor    mm6, ds:qword_4189E0
.text:0040C4E6                 pfacc   mm4, mm2
.text:0040C4EA                 pfmul   mm6, mm0
.text:0040C4EE                 pxor    mm5, ds:qword_4189E0
.text:0040C4F5                 pfmul   mm3, mm0
.text:0040C4F9                 movq    qword ptr [eax], mm4
.text:0040C4FC                 pfmul   mm5, mm1
.text:0040C500                 pfadd   mm6, mm7
.text:0040C504                 pfsub   mm5, mm3
.text:0040C508                 pfacc   mm6, mm5
.text:0040C50C                 movq    qword ptr [eax+8], mm6
.text:0040C510                 femms
.text:0040C512                 retn    0Ch
.text:0040C515 ; ---------------------------------------------------------------------------


;;




;;

Guga changes
a)

                    Else_If B$esi-1 = 0E9
                        test B$eax EVOCATED | jz L1>
                      ; 2 or more JMP Instructions to the same location:
                        ;or B$eax PUSH_EBP+NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                        ; GugaNote This is a jmp call
                        or B$eax NODE+INSTRUCTION+ACCESSED+EVOCATED+LABEL
                        mov ebx eax | sub ebx D$RoutingMap | add ebx D$SectionsMap
                        mov B$ebx CODEFLAG
                        jmp L5>
                        
b)

This is for the JCC
    While edi < edx
        If B$esi > 3
            On B$edi = 0, mov B$edi CODEFLAG
            On B$edi = CODEFLAG, mov B$ebx INSTRUCTION+EVOCATED+LABEL+ACCESSED;+PUSH_EBP
        End_If
        inc esi, edi, ebx
    End_While
;;


;;

More errors.

On ntdll.dll (D:\RosAsm\dlls\NewDlls)

Here:

    mov D$eax+0BC es                  ; 8C 88 BC 00 00 00 
    mov D$eax+098 es                  ; 8C 98 98 00 00 00 
    mov D$eax+094 es                  ; 8C 80 94 00 00 00 
    mov D$eax+090 es                  ; 8C A0 90 00 00 00 
    mov D$eax+08C es                  ; 8C A8 8C 00 00 00 
    mov D$eax+0C8 es                  ; 8C 90 C8 00 00 00 
    mov D$eax  010007                 ; C7 00 07 00 01 00 
    push 01                           ; 6A 01 
    push eax                          ; 50 
    push D$ebp+08                     ; FF 75 08 
    call Code078468A5C                ; E8 29 C5 FD FF 
(...)
    call Code07848C4A0                ; E8 48 FF FF FF 
RtlRaiseStatus:: Code07848C558: P2:

The "es" is repeated. It dhould be:

    mov D$eax+0BC cs                  ; 8C 88 BC 00 00 00 
    mov D$eax+098 ds                  ; 8C 98 98 00 00 00 
    mov D$eax+094 es                  ; 8C 80 94 00 00 00 
    mov D$eax+090 fs                  ; 8C A0 90 00 00 00 
    mov D$eax+08C gs                  ; 8C A8 8C 00 00 00 
    mov D$eax+0C8 ss                  ; 8C 90 C8 00 00 00 
    mov D$eax  010007                 ; C7 00 07 00 01 00 
    push 01                           ; 6A 01 
    push eax                          ; 50 
    push D$ebp+08                     ; FF 75 08 
    call Code078468A5C                ; E8 29 C5 FD FF 
(...)
    call Code07848C4A0                ; E8 48 FF FF FF 
RtlRaiseStatus:: Code07848C558: P2:


The error was here:

WriteEffectiveAddressFromModRm:  ; 044 00_100_100
(...)

    .Else_If al = 2
        call StartEffectiveAddress | RmMask bl To al

        If al = 0      | mov D$edi 'eax+' | add edi 4
        Else_If al = 1 | mov D$edi 'ecx+' | add edi 4
        Else_If al = 2 | mov D$edi 'edx+' | add edi 4
        Else_If al = 3 | mov D$edi 'ebx+' | add edi 4
        Else_If al = 4 | call WriteFromSib
            ..If B$edi-1 <> '+'
                mov B$edi '+' | inc edi
            ..End_If
        Else_If al = 5 | mov D$edi 'ebp+' | add edi 4
        Else_If al = 6 | mov D$edi 'esi+' | add edi 4
        Else           | mov D$edi 'edi+' | add edi 4
        End_If

        ; call Writedis32 ; ----> Here was the error. The values of eax and ebx was changing
        push ebx | push eax | call Writedis32 | pop eax | pop ebx ; --> This was my preliminary fix.

    .Else ; bl = 3

The 1st fix i made was only a palleative way to retrieve back the values of eax and ebx in order to don´t change
the values of bl and al, but this is not the proper way to go, because we have several other functions that call to
this Writedis32 and also in some functions below or after it.

All of those surrounding functions changes the values, because they are not preserved. The functions are top-down, like:

WriteBase5dis32: ; starting address
    If B$edi-1 <> '+'
        mov B$edi '+' | inc edi
    End_If

WriteDis32:
    If B$AddressSizeOverride = &FALSE
        lodsd
    Else
        lodsw | and eax 0FFFF | call WriteEax | ret
    End_If

WriteDisRelative:
    mov D$LastCodeRef eax | On eax = 0, jmp L8>>

L0: If B$SimpleScan = &TRUE
        mov B$DisFlag DISDONE+DISLINEOVER | ret
    End_If

So i fix it all only adding a Proc macro and a use macro in all functinos and adding a call to the next function in sequence,
like this:


Proc WriteBase5dis32:
    Uses eax, ebx, ecx, edx
    
    If B$edi-1 <> '+'
        mov B$edi '+' | inc edi
    End_If
    call WriteDis32
EndP

Proc WriteDis32:
    Uses eax, ebx, ecx, edx

    If B$AddressSizeOverride = &FALSE
        lodsd
    Else
        lodsw | and eax 0FFFF | call WriteEax | ExitP;ret
    End_If
    call WriteDisRelative
EndP

Proc WriteDisRelative:
    ;Uses eax, ebx, ecx, edx ; Maybe not use eax here bccause of  | jnz WriteDisRelative
    Uses ebx, ecx, edx ; Maybe not use eax here

    mov D$LastCodeRef eax | On eax = 0, jmp L8>>

L0: If B$SimpleScan = &TRUE
        mov B$DisFlag DISDONE+DISLINEOVER | ExitP;ret
    End_If

L0: On B$WeAreInTheCodeBox = &TRUE, jmp L8>>

    sub eax D$DisImageBase | add eax D$SectionsMap

    On eax >= D$EndOfSectionsMap, jmp L8>>
    On eax <= D$SectionsMap, jmp L8>>

    mov B$ToJumpsTable &FALSE
    mov al B$eax | and al DATAFLAG+VIRTUALFLAG+IMPORTFLAG+CODEFLAG+CONSTANTFLAG

    ..If al = 0
        mov eax D$LastCodeRef

        mov ebx eax | sub ebx D$DisImageBase | add ebx D$SizesMap

            .If B$LeaInstruction = &TRUE
               ; or B$ebx POINTER | mov B$LeaInstruction &FALSE
            .Else_If W$edi-2 = 'B$'
                or B$ebx BYTE
                sub ebx D$SizesMap | add ebx D$SectionsMap | mov B$ebx DATAFLAG
            .Else_If W$edi-2 = 'W$'
                or B$ebx WORD
                sub ebx D$SizesMap | add ebx D$SectionsMap
                mov B$ebx DATAFLAG, B$ebx+1 DATAFLAG
            .Else_If W$edi-2 = 'D$'
                or B$ebx DWORD
                sub ebx D$SizesMap | add ebx D$SectionsMap
                mov D$ebx FOURDATAFLAGS
            .Else_If W$edi-2 = 'F$'
                or B$ebx FP4
                sub ebx D$SizesMap | add ebx D$SectionsMap
                mov D$ebx FOURDATAFLAGS
            .Else_If W$edi-2 = 'R$'
                or B$ebx FP8
                sub ebx D$SizesMap | add ebx D$SectionsMap
                mov D$ebx FOURDATAFLAGS, D$ebx+4 FOURDATAFLAGS
            .Else_If W$edi-2 = 'T$'
                or B$ebx FP10
                sub ebx D$SizesMap | add ebx D$SectionsMap
                mov D$ebx FOURDATAFLAGS, D$ebx+4 FOURDATAFLAGS, D$ebx+6 FOURDATAFLAGS
            .Else
                jmp L8>>
               ; or B$ebx POINTER
            .End_If

    ..Else_If al = DATAFLAG
        mov eax D$LastCodeRef | call StoreDisSize
        sub eax D$DisImageBase | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        mov D$edi 'Data' | add edi 4 | jmp L8>>

    ..Else_If al = CODEFLAG
      ; Is it a call to a Jumps Table?
        mov eax D$LastCodeRef
        sub eax D$DisImageBase | add eax D$UserPeStart

        If W$eax = 025FF ; Code of jmp relative long
            mov ebx D$eax+2 | sub ebx D$DisImageBase | add ebx D$SectionsMap
            On ebx > D$EndOfSectionsMap, jmp L1>
            On ebx < D$SectionsMap, jmp L1>
                On B$ebx <> IMPORTFLAG, jmp L1>

                    mov B$ApiCommentWanted &TRUE, ebx D$eax+2, D$PtrToApiName ebx

                  ; On B$WithSymbolicsAnalyzes = &FALSE, mov B$ToJumpsTable &TRUE
;                    push eax
;                        mov al B$WithSymbolicsAnalyzes | xor al &TRUE
;                        mov B$ToJumpsTable al
;                        On B$WithoutJumpsTableCalls = &TRUE, mov B$ToJumpsTable &FALSE
;                    pop eax
;                    mov ebx D$eax+2 | jmp L5>>
        End_If

L1:     mov eax D$LastCodeRef
        sub eax D$DisImageBase | add eax D$RoutingMap
        test B$eax INSTRUCTION | jz L8>>
        or B$eax NODE+LABEL | mov D$edi 'Code' | add edi 4 | jmp L8>>

    ..Else_If al = VIRTUALFLAG
        mov eax D$LastCodeRef | call StoreDisSize
        sub eax D$DisImageBase | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        mov D$edi 'Virt', D$edi+4 'ual ' | add edi 7 | jmp L8>>

    ..Else_If al = CONSTANTFLAG
L1:     mov eax D$LastCodeRef | call StoreDisSize
        sub eax D$DisImageBase | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        mov D$edi 'Cons', D$edi+4 'tant', B$edi+8 ' ' | add edi 8 | jmp L8>>

    ..Else_If al = IMPORTFLAG
        mov ebx D$LastCodeRef
L5:     sub ebx D$DisImageBase | add ebx D$UserPeStart | mov ebx D$ebx
      ; May be a wrong pointing inside the .Import!
      ; Add a Pointer test!
        On ebx < D$ApiBuffer, ExitP;ret
        On ebx >= D$EndOfApiBuffer, ExitP;ret

        push esi

            On W$edi-2 = 'D$', sub edi 2

            mov esi ebx

            .If D$edi-4 = 'jmp '    ; Jumps Table?
                call WriteApiJmpTableLabel

                While B$esi <> 0 | movsb | End_While

            .Else_If D$edi-4 = 'all '  ; call api?
                call FlagNoReturnApi
                call FlagApiProcedures
                While B$esi <> 0 | movsb | End_While

          ; Other case: Either "mov eax D$ApiCall" or "mov D$eax ApiCall"
            .Else
                push edi
                    mov al "'"
                    While B$edi > LF
                        dec edi
                        On B$edi = '$', mov al 0
                    End_While
                pop edi
                mov esi ebx
                If al = 0
                    While B$esi <> '.' | inc esi | End_While | inc esi
                End_If
                While B$esi <> 0 | movsb | End_While
                On al = 0, dec edi

            .End_If
        pop esi

     ..End_If

    ExitP;ret
______________________________________________
; Note to René: All of this is for your Tests ?

L7:         pop ebx, eax, esi
            mov B$edi ':' | inc edi | NextDisLine

            mov D$edi 'jmp ' | add edi 4
        .End_If
ExitP;ret

       ; If B$ToJumpsTable = &FALSE
       ;     mov B$edi "'" | inc edi
       ; End_If
        push esi
            mov esi ebx | While B$esi <> 0 | movsb | End_While
        pop esi
      ;  mov eax D$edi-4 | or eax 0202020 | On eax = '.dll' | sub edi 4
      ;  mov B$edi '.' | inc edi
;      ; Switch to the real Import for reading the Pointer to Function Name:
;        sub ebx D$RoutingMap | add ebx D$UserPeStart
;        Test D$ebx 0_8000_0000 | jnz L6>
;            push esi
;                mov esi D$ebx | add esi 2 | add esi D$UserPeStart
;                If esi < D$UserPeStart
;D0:                 mov B$DisFlag DISFAILED | pop esi | ret
;                Else_If esi > D$UserPeEnd
;                    jmp D0<
;                End_If
;                While B$esi <> 0 | movsb | End_While
;            pop esi
;            If B$ToJumpsTable = &FALSE
;                mov B$edi "'" | inc edi
;            End_If
            ExitP;ret

;L6:     mov eax D$ebx | xor eax 0_8000_0000 | call WriteEax
;        If B$ToJumpsTable = &FALSE
;            mov B$edi "'" | inc edi
;        End_If
        ExitP;ret

    ..Else_If al = 0
        mov ebx D$LastCodeRef
        sub ebx D$DisImageBase | add ebx D$RoutingMap
        mov eax D$ebx
        If eax = 0
            sub ebx D$RoutingMap | add ebx D$SectionsMap
            mov B$ebx CONSTANTFLAG | jmp L1<<
        End_If
    ..End_If
_______________________________________

L8: On B$WeAreInTheCodeBox = &FALSE, jmp L8>
    On D$LibFileMemory = 0, jmp L8>
        push esi
            mov esi D$LastCodeRef
            .If esi > D$LibFileMemory
                mov eax D$LibFileMemory | add eax D$LibFileLength
                If esi < eax
                    While B$esi <> 0 | movsb | End_While
                   ; mov D$edi ' ; <', D$edi+4 '<<<<' | add edi 8
                Else
                    pop esi | jmp L8>
                End_If
            .Else
                pop esi | jmp L8>
            .End_If
        pop esi
        ExitP;ret

L8: ;On D$LastCodeRef = 0438E28, int3

    .If B$edi-1 = '+'
        If W$edi-3 = '*2'
            call TryWithIndice 2
        Else_If W$edi-3 = '*4'
            call TryWithIndice 4
        Else_If W$edi-3 = '*8'
            call TryWithIndice 8
        End_If
    .End_If

    If W$DisplacementFromLabel = 0
        mov eax D$LastCodeRef | sub eax D$DisImageBase | add eax D$SizesMap
        mov ebx D$SizesMap | add ebx 4
        On eax < ebx, jmp L8>
        On eax > D$EndOfSizesMap, jmp L8>
        test B$eax-4 FP8 | jz L8>
            sub D$LastCodeRef 4 | mov W$DisplacementFromLabel '+4'
    End_If

L8: push 0-1

    mov ebx D$LastCodeRef

L0: mov eax ebx | shr ebx 4 | and eax 0F
    add eax '0' | On eax > '9', add eax 7
    push eax
    cmp ebx 0 | ja L0<

    mov B$edi '0' | inc edi
L0: pop eax | cmp eax 0-1 | je L9>
    mov B$edi al | inc edi | jmp L0<

L9: If W$DisplacementFromLabel <> 0
        mov ax W$DisplacementFromLabel | stosw
        mov W$DisplacementFromLabel 0
    End_If

    mov eax D$LastCodeRef | sub eax D$DisImageBase | add eax D$SectionsMap

    .If eax < D$SectionsMap
        ;
    .Else_If eax < D$EndOfSectionsMap
        If B$eax = DATAFLAG
            sub eax D$SectionsMap | add eax D$RoutingMap | or B$eax LABEL+EVOCATED
        End_If
    .End_If

    On B$ApiCommentWanted = &TRUE, call WriteApiLabelComment
;ret
EndP



------------------------

i Also changed here:


BuildTruthAsciiTable:
    VirtualAlloc TruthAsciiTable 256
    mov edi D$TruthAsciiTable, al BADASCII, ecx 256 | rep stosb

    mov edi D$TruthAsciiTable, B$edi 0
    mov B$edi+LF GOODASCII, B$edi+CR GOODASCII,
        B$edi+0A7 GOODASCII,    ; $
        B$edi+025 GOODASCII,    ; %
        B$edi+0A9 GOODASCII,    ; ®
        B$edi+02F GOODASCII     ; /

    mov ebx 32, ecx 127;8
    While ebx =< ecx
        mov B$edi+ebx GOODASCII | inc ebx
    End_While

  ; 128 - 32 + 6 > 102
ret

Chars 127 and 128 are not Good Ascii
;;







;;
    lstrcmpi

    This function compare two Null Terminated Ascii strings (With the same size or not). It looks for the
    Language version of your system to order the Strings.
    The functionality is exactly the same as on lstrcmpiA inside Kernel32.dll.
    
    Arguments:
    
    String1:    First ascii null terminated to be inputed
    String2:    Second ascii null terminated to be inputed
    
    Return Values:
        If the Strings are the same, eax returns 0
        If the 1st String alphabetically preceeds the 2nd String, eax returns 0-1.
        If the 1st String is alphabetically located after the 2nd String, eax returns 1.
        
    Example of usage and their return values:

    call lstrcmpi {B$ "AB", 0} {B$ "AB", 0} ; Eax = 0
    call lstrcmpi {B$ "AB", 0} {B$ "CD", 0} ; Eax = 0-1
    call lstrcmpi {B$ "CD", 0} {B$ "AB", 0} ; Eax = 1
    call lstrcmpi {B$ "RosAsm", 0} {B$ "Assembly", 0} ; Eax = 1
    call lstrcmpi {B$ "Assembly", 0} {B$ "RosAsm", 0} ; Eax = 0-1
    
    Note: If you are using this function to organize (list) strings. The starting order in crescent sttrings.
    Like the following list of strings:
        
        Home, House, Indian, RosAsm, Slovak, Story

    If you are trying to build a list of strings without having to use the Languiage definitions of your system, use
    the functions:
    
    strcmp - The same functionality as this lstrcmpi, but built on a simplified way to not use the Lang definitions.
             It will displays the order of strings in crescent order.

    stricmp - The same functionality as this lstrcmpi, but built on a simplified way to not use the Lang definitions.
             It will displays the order of strings in decrescent order.
;;

Proc lstrcmpi:
    Arguments @String1, @String2
    uses ebx, esi, ecx, edx

    call 'kernel32.GetThreadLocale'
    call 'kernel32.CompareStringA' eax, &LOCALE_ILANGUAGE__&LOCALE_USE_CP_ACP, D@String1, 0-01, D@String2, 0-1

    ...If eax = 0

        call 'kernel32.GetSystemDefaultLCID'
        call 'kernel32.CompareStringA' eax, &LOCALE_ILANGUAGE__&LOCALE_USE_CP_ACP, D@String1, 0-01, D@String2, 0-1

        ..If eax = 0

            .If D@String1 <> 0

                If D@String2 <> 0
                    call stricmp D@String1, D@String2
                Else_If D@String1 <> 0 ; There is an error on the original dll. This may be eax and not String1
                    mov eax 1
                Else
                    mov eax D@String2
                    neg eax
                    sbb eax eax
                End_If
                ExitP

            .End_If

            mov eax D@String2
            neg eax
            sbb eax eax
            ExitP

        ..End_If

    ...End_If

    add eax 0-02

EndP





;;
    Stricmp

    This function compare two Null Terminated Ascii strings (With the same size or not). It is a simplified version
    of lstrcmpi from kernel32.dll, with the diference that in this function it does not look for the
    Language version of your system, and also it reverses the order if a user is building a List of Strings.
    For example, on lstrcmpi the initial order of a String Listings is crescent. On this function the starting order
    is decrescent.
    The functionality is exactly the same as on _stricmp and _strcmpi inside ntdll.dll.
    It handle only latin alphabet without accents. So, only vowels and consonants from A to Z.
    
    To display a list of files in crescent alphabetical order, use Strcmp function.
    
    Arguments:
    
    String1:    First ascii null terminated to be inputed
    String2:    Second ascii null terminated to be inputed
    
    Return Values:
        If the Strings are the same, eax returns 0
        If the 1st String alphabetically preceeds the 2nd String, eax returns 1.
        If the 1st String is alphabetically located after the 2nd String, eax returns 0-1.
        
    Example of usage and their return values:
        
    call stricmp {B$ "AB", 0} {B$ "AB", 0} ; Eax = 0
    call stricmp {B$ "AB", 0} {B$ "CD", 0} ; Eax = 1
    call stricmp {B$ "CD", 0} {B$ "AB", 0} ; Eax = 0-1
    call stricmp {B$ "RosAsm", 0} {B$ "Assembly", 0} ; Eax = 0-1
    call stricmp {B$ "Assembly", 0} {B$ "RosAsm", 0} ; Eax = 1
    
    Note: Used Macros. Default RosAsm macro system, plus:
    
    [If_And    | If #1 #2 #3    | #+3]
    [.If_And   | .If #1 #2 #3   | #+3]
    [..If_And  | ..If #1 #2 #3  | #+3]
    [...If_And | ...If #1 #2 #3 | #+3]

    [Else_If_And    | Else    | If_And    #F>L]
    [.Else_If_And   | .Else   | .If_And   #F>L]
    [..Else_If_And  | ..Else  | ..If_And  #F>L]
    [...Else_If_And | ...Else | ...If_And #F>L]

    If you are using this function to organize (list) strings. The starting order in decrescent strings.
    Like the following list of strings:
        
        Story, Slovak, RosAsm, Indian, House, Home

;;

Proc stricmp:
    Arguments @String1, @String2
    Uses edi, esi, ebx

    mov esi D@String2
    mov edi D@String1
    mov al 0FF


    .Do
        Do
            On al = 0, jmp L2>
            mov al B$esi
            inc esi
            mov ah B$edi
            inc edi
        Loop_Until ah <> al

        ; Lower case convertion
        If_And al >= 'A', al <= 'Z'
            xor al 32
        End_If

        If_And ah >= 'A', ah <= 'Z'
            xor ah 32
        End_If

    .Loop_Until al <> ah
    sbb al al
    sbb al 0-1
L2:
    movsx eax al

EndP

____________________________________________________________________________________________

;;
    String2Dword

    This function converts a Null Terminated Decimal Ascii String to a 32 Bits Dword Value.
    
    Arguments:
    
    String:    The inputed String to be converted
    
    Return Values:
        If the function suceeds eax returns the value of the dword string.
        If the function fails eax returns 0.
;;

Proc String2Dword:
    Arguments @String
    Local @Result
    Uses ecx, edi, edx, esi

    mov D@Result 0
    mov edi D@String
    mov ecx D@String
    On ecx = 0, ExitP

    call StrLenProc edi

    .While B$ecx <> 0

        xor edx edx
        mov dl B$edi
        sub dl '0'  ; subtrack each digit with "0" to convert it to hex value
        mov esi eax
        dec esi
        push eax
            mov eax edx
            push ebx
                mov ebx 10;0A
                While esi > 0
                    mul ebx
                    dec esi
                End_While
            pop ebx
            add D@Result eax
        pop eax
        inc edi
        dec eax
        inc ecx
    .End_While
    mov eax D@Result

EndP
____________________________________________________________________________________________


;;
    Strcmp

    This function compare two Null Terminated Ascii strings (With the same size or not). It is a simplified version
    of lstrcmpi from kernel32.dll, with the diference that in this function it does not look for the
    Language version of your system. It also displays the same order if a user is building a List of Strings.
    For example, on lstrcmpi the initial order of a String Listings is crescent. On this function the starting order
    is also crescent.
    It handle only latin alphabet without accents. So, only vowels and consonants from A to Z.
    
    To display a list of files in decrescent alphabetical order, use Stricmp function.
        
    Arguments:
    
    String1:    First ascii null terminated to be inputed
    String2:    Second ascii null terminated to be inputed
    
    Return Values:
        If the Strings are the same, eax returns 0
        If the 1st String alphabetically preceeds the 2nd String, eax returns 0-1.
        If the 1st String is alphabetically located after the 2nd String, eax returns 1.
        
    Example of usage and their return values:
        
    call strcmp {B$ "AB", 0} {B$ "AB", 0} ; Eax = 0
    call strcmp {B$ "AB", 0} {B$ "CD", 0} ; Eax = 0-1
    call strcmp {B$ "CD", 0} {B$ "AB", 0} ; Eax = 1
    call strcmp {B$ "RosAsm", 0} {B$ "Assembly", 0} ; Eax = 1
    call strcmp {B$ "Assembly", 0} {B$ "RosAsm", 0} ; Eax = 0-1
    
    Note: Used Macros. Default RosAsm macro system, plus:
    
    [If_And    | If #1 #2 #3    | #+3]
    [.If_And   | .If #1 #2 #3   | #+3]
    [..If_And  | ..If #1 #2 #3  | #+3]
    [...If_And | ...If #1 #2 #3 | #+3]

    [Else_If_And    | Else    | If_And    #F>L]
    [.Else_If_And   | .Else   | .If_And   #F>L]
    [..Else_If_And  | ..Else  | ..If_And  #F>L]
    [...Else_If_And | ...Else | ...If_And #F>L]

    Note: If you are using this function to organize (list) strings. The starting order in crescent sttrings.
    Like the following list of strings:
        
        Home, House, Indian, RosAsm, Slovak, Story

;;

Proc strcmp:
    Arguments @String1, @String2
    Uses edi, esi, ebx

    mov esi D@String1
    mov edi D@String2
    mov al 0FF


    .Do
        Do
            On al = 0, jmp L2>
            mov al B$esi
            inc esi
            mov ah B$edi
            inc edi
        Loop_Until ah <> al

        ; Lower case convertion
        If_And al >= 'A', al <= 'Z'
            xor al 32
        End_If

        If_And ah >= 'A', ah <= 'Z'
            xor ah 32
        End_If

    .Loop_Until al <> ah
    sbb al al
    sbb al 0-1
L2:
    movsx eax al

EndP


[szBuff0: B$ ? #256]

[BASE_HEX 16, BASE_DEC 10, BASE_OCT 8, BASE_FOUR 4, BASE_BIN 2]

Proc AsciiBase:
    Arguments @String, @Base
    Uses esi, ebx, edx

        mov esi D@String, eax 0, ebx 0

        While B$esi <> 0
            mov eax ebx | mul D@Base | mov ebx eax, eax 0
            mov al B$esi | sub al '0'
          ; Cases of Hexa Notation:
            On al > 9, sub al 7
            add ebx eax | inc esi
        End_While

        mov eax ebx
EndP

;;
    Strcpy

    This function copies a Null Terminated String to a Buffer. The size of the Buffer must be bigger or equal to the
    size of the string.
    It have the same functionality as lstrcpyA in kernel32.dll
    
    Arguments:
    
    InBound:    The inputed String
    
    OutBound:   The Buffer which will hold the String.
    
;;

Proc strcpy:
    Arguments @OutBound, @InBound
    Uses ecx, esi, edi

    xor ecx ecx
    mov esi D@InBound

    Do
        inc ecx
        inc esi
    Loop_Until B$esi = 0

    mov esi D@InBound | mov edi D@OutBound | rep movsb
    mov B$edi 0

EndP
____________________________________________________________________________________________













































TITLE CoolControls

____________________________________________________________________________________________
____________________________________________________________________________________________

;              Cool Controls are a set of functinos that enhaces the Look of
;              RosAsm Controls, like Menus, ToolBars, Dialogs, Images etc

;              Author: Guga  - January/2.006
____________________________________________________________________________________________
____________________________________________________________________________________________

; ToolBar Controls
____________________________________________________________________________________________
____________________________________________________________________________________________

; CharMap dialog image list initialisation & finalization.


Proc CoolControlTB_CreateImageList:
    Arguments @OutPutHandle, @EnabledImage, @DisabledImage, @Cx, @Cy, @Flags, @CInitial, @CGrow
    Local @Image, @Mask, @TempBuff


    lea edi D@OutPutHandle
    move D@TempBuff D$edi

  ; Create the images
    call 'User32.LoadImageA' D$hInstance, D@EnabledImage, &IMAGE_BITMAP, 0, 0, 0
    If eax = 0
        call ReportWinError {'CoolControl ToolBar CreateImageList: LoadImage (1 - Enabled)' 0}
    EndIf
    mov D@Image eax

    call 'User32.LoadImageA' D$hInstance, D@DisabledImage, &IMAGE_BITMAP, 0, 0, 0
    If eax = 0
        call ReportWinError {'CoolControl ToolBar CreateImageList: LoadImage (2 - Disabled)' 0}
    EndIf
    mov D@Mask eax

    call 'ComCtl32.ImageList_Create' D@Cx, D@Cy, D@Flags, D@CInitial, D@CGrow
    mov D$edi eax       ; Copy the Value store in eax to the Data in Edi (That have the address of the Outputed Buffer)
    mov eax D@TempBuff  ; Copy our previously stored address of the outputed Buffer to eax
    move D$eax D$edi    ; Save the Data to be outputed in the outputed Buffer at the OutPutHandle that now is stored in eax

    call 'ComCtl32.ImageList_Add' D@OutPutHandle, D@Image, D@Mask
    If eax = 0-1
        call ReportWinError {'CoolControl ToolBar: ImageList_Add' 0}
    EndIf

    call 'GDI32.DeleteObject' D@Image
    call 'GDI32.DeleteObject' D@Mask
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc CoolControlWin_CreateToolbar:
    Arguments @Addresse, @OutPutHandle, @ToolStructure, @TotalButtons, @ToolTipArray, @tbCmdStruc
    Local @TempBuff
    pushad

    call 'ComCtl32.InitCommonControlsEx' Init_Common_Controls

    ; Always initialize the ToolBar handle with 0

    lea edi D@OutPutHandle
    move D@TempBuff D$edi
    mov eax D@TempBuff
    mov D$eax 0

    ; Always initialize the Text Flag to FALSE

    mov edx D@tbCmdStruc
    mov edx D$edx+TBWIN_CMD.ShowTxtFlagDis
    mov D$edx &FALSE

    call CoolControlWin_CreateCommandTB D@Addresse, eax, D@ToolStructure, D@TotalButtons, D@ToolTipArray, D@tbCmdStruc
    popad
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

;;
    CoolControlWin_CreateCommandTB
    
    This function builds the toolbar located inside a window handle.
    
    Parameters:
    
        Addresse: Address of the window handle
        
        OutPutHandle: Pointer to the handle of the ToolBar. When the function exits, it will output to the handle
                      of the toolbar.
                      
        ToolStructure: Pointer to a array of TBBUTTON Structure containing the Data to be used for the toolbar.
                       Each element of the array is a TBBUTTON Structure related to each one of button the user wants that
                       his toolbar to have.
        
        TotalButtons:  Total amount of Buttons of the created ToolBar.
        
        ToolTipArray:   Pointer to a array of Pointers (Dwords) to Null-Terminated Strings used for ToolTips or for displaying inside
                        each Button. The amount of elements of the array needs to be the same as the amount of buttons
                        to allow that each button have a ToolTip Text String.
        
        tbCmdStruc:     Pointer to the address of a TBWin_Cmd (ToolBar windows Command) Structure that contains the initialization values
                        of the toolbar to be created.
                        
                        
                        The TBWin_Cmd Structure have the following format:
                        
                        [TBWin_Cmd:
                            bWidth: D$ 0
                            dwStyle: D$ 0
                            hMenu: D$ 0
                            hIml: D$ 0
                            ShowTxtFlag: D$ 0]
                        
                        It member's information are related below:
                        
                            bWidth: Value of the width of each Button of the ToolBar.
                            
                            dwStyle: Styles of the ToolBar. The same ones defined for usage in CreateWindowExA (User32)
                                     when you are creating a 'ToolbarWindow32' class.
                                    
                            hMenu: Menu handle or child identifier of the window
                            
                            hIml: Pointer to a Buffer containing ImageList handle for this toolBar.
                                  The handle must be previously created from the function CoolControlTB_CreateImageList.
                            
                            ShowTxtFlag: Pointer to a Buffer that contains a Flag to display or not the Text inside a Button.
                                         If the Flag is settled to &TRUE the ToolBar displays the text inside the Button,
                                         otherwise it does not display the text.
;;


[CHARMAP_TOOLBAR_STYLE &WS_CHILD__&WS_VISIBLE__&TBSTYLE_FLAT__&TBSTYLE_LIST__&TBSTYLE_AUTOSIZE__&TBSTYLE_TRANSPARENT__&TBSTYLE_TOOLTIPS__&CCS_TOP]

[CHARMAPDLG_TOOLBAR 432]

[CharMapDialog_ImageList: ?]

[CharMapShowTBText: ?]


; Based on DebugDialog_CreateCommandTB
; CharMapToolbarHandle
[TBWin_Cmd:
 TBWin_Cmd.bWidth: D$ 20
 TBWin_Cmd.dwStyle: D$ CHARMAP_TOOLBAR_STYLE
 TBWin_Cmd.hMenu: D$ CHARMAPDLG_TOOLBAR
 TBWin_Cmd.hIml: D$ CharMapDialog_ImageList
 TBWin_Cmd.ShowTxtFlag: D$ CharMapShowTBText]

[TBWIN_CMD.bWidthDis 0
 TBWIN_CMD.dwStyleDis 4
 TBWIN_CMD.hMenuDis 8
 TBWIN_CMD.hImlDis 12
 TBWIN_CMD.ShowTxtFlagDis 16

 SizeOf_TBWIN_CMD 20]

[TBBUTTON.iBitmapDis 0
 TBBUTTON.idCommandDis 4
 TBBUTTON.fsStateDis 8
 TBBUTTON.fsStyleDis 9
 TBBUTTON._wPad1Dis 10
 TBBUTTON.dwDataDis 12
 TBBUTTON.iStringDis 16

 SizeOf_TBBUTTON 20]

Proc CoolControlWin_CreateCommandTB:
    Arguments @Addresse, @OutPutHandle, @ToolStructure, @TotalButtons, @ToolTipArray, @tbCmdStruc
    Local @TBWidth
    pushad

    mov ebx D@ToolStructure
    mov esi 0

    mov ecx D@OutPutHandle ; We need to keep track on ecx because this is the output handle.

    ; Save states & clear if toolbar is Recreated
    .If D$ecx <> 0
        Do
            push ecx | SendMessage D$ecx, &TB_GETSTATE, D$ebx+TBBUTTON.idCommandDis, 0 | pop ecx
            mov B$ebx+TBBUTTON.fsStateDis al
            inc esi
            add ebx SizeOf_TBBUTTON
        Loop_Until esi = D@TotalButtons

        push ecx | call 'USER32.DestroyWindow' D$ecx | pop ecx
    .EndIf

    ; Create toolbar
    push ecx
        mov edx D@tbCmdStruc
        mov esi D@tbCmdStruc
        ; eax = D@TBWidth * D@TotalButtons
        move D@TBWidth D$edx
        mov eax D@TotalButtons
        mul D@TBWidth

        call 'User32.CreateWindowExA' 0, {'ToolbarWindow32' 0}, 0, D$esi+TBWIN_CMD.dwStyleDis,
                                      0, 0, eax, 0, D@Addresse, D$esi+TBWIN_CMD.hMenuDis, D$hInstance, 0

    pop ecx

    mov D$ecx eax
    push ecx | SendMessage D$ecx, &TB_BUTTONSTRUCTSIZE, SizeOf_TBBUTTON, 0 | pop ecx

    mov eax D$esi+TBWIN_CMD.hImlDis
    push ecx | SendMessage D$ecx, &TB_SETIMAGELIST, 0, D$eax | pop ecx

    mov ebx D@ToolStructure
    mov edx D@tbCmdStruc
    mov edx D$edx+TBWIN_CMD.ShowTxtFlagDis
    mov esi 0
    mov edi D@ToolTipArray

  ; Activate / Deactivate Text
    .If D$edx = &TRUE
        Do
            move D$ebx+TBBUTTON.iStringDis D$edi
            inc esi
            add ebx SizeOf_TBBUTTON
            add edi 4
        Loop_Until esi = D@TotalButtons

    .Else
        Do
            mov D$ebx+TBBUTTON.iStringDis 0
            inc esi
            add ebx SizeOf_TBBUTTON
        Loop_Until esi = D@TotalButtons

    .EndIf

    mov ebx D@ToolStructure
    push ecx | SendMessage D$ecx, &TB_ADDBUTTONS, D@TotalButtons, ebx | pop ecx

    popad
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

Proc CoolControlTB_OnNotify:
    Arguments @Handle, @Notification, @ToolStructure, @TotalButtons, @ToolTipArray
    Uses ebx, edx, ecx, edi

        mov ebx D@Notification
        mov edx D$ebx+NMHDR.idFromDis
        mov eax D$ebx+NMHDR.codeDis

        mov edi D@ToolStructure

        ..If eax = &TTN_NEEDTEXT
            mov eax D$ebx+NMHDR.idFromDis
          ; Pointing with esi to the Buttons List IDs:
            lea esi D$edi+TBBUTTON.idCommandDis

            mov ecx 0
            While D$esi <> eax
                add esi SizeOf_TBBUTTON | inc ecx
                If ecx > D@TotalButtons
                    mov eax 0   ; mandatory for TCN_SELCHANGING !!!
                    ExitP
                End_If
            End_While

            mov edi D@ToolTipArray
            mov eax D$edi+ecx*4
            mov D$ebx+TOOLTIPTEXT_lpszText eax

        ..EndIf

        mov eax 0 ; mandatory for TCN_SELCHANGING !!!
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc CoolControlTabToolTip_OnNotify:
    Arguments @Notification, @TotalButtons, @ToolTipArray
    Uses ebx, edx, ecx, edi

        mov ebx D@Notification
        mov edx D$ebx+NMHDR.idFromDis
        mov eax D$ebx+NMHDR.codeDis

        mov esi 0 ; The Tab Item always starts with 0

        ..If eax = &TTN_NEEDTEXT
            mov eax D$ebx+NMHDR.idFromDis
            mov ecx 0
            While esi <> eax
                inc esi | inc ecx
                If ecx > D@TotalButtons
                    mov eax 0   ; mandatory for TCN_SELCHANGING !!!
                    ExitP
                End_If
            End_While

            mov edi D@ToolTipArray
            mov eax D$edi+ecx*4
            mov D$ebx+TOOLTIPTEXT_lpszText eax

        ..EndIf

        mov eax 0 ; mandatory for TCN_SELCHANGING !!!
EndP

____________________________________________________________________________________________
____________________________________________________________________________________________

Proc CoolControlTabChange_OnNotify:
    Arguments @Notification, @TabSelected, @MainTab

        mov ebx D@Notification
        mov eax D$ebx+NMHDR.codeDis
        lea edi D@TabSelected
        mov edi D$edi

        ..If eax = &TCN_SELCHANGE

            ;Tab selection. We are sending the message on the Main Tab Control, in the main dialog.
            ; At ebx we have the handle of the MainTab = htab
            call 'USER32.SendMessageA' D$ebx &TCM_GETCURSEL 0 0
            .If eax <> D$edi

                push eax
                mov eax D$edi
                call 'USER32.ShowWindow' D$eax*4+hTabDlg1 &SW_HIDE
                pop eax
                mov D$edi eax
                call 'USER32.ShowWindow' D$eax*4+hTabDlg1 &SW_SHOWDEFAULT

            .End_If

        ..End_If
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; Tab Controls
____________________________________________________________________________________________
____________________________________________________________________________________________

[RECT.leftDis 0
 RECT.topDis 4
 RECT.rightDis 8
 RECT.bottomDis 12]

[Size_Of_RECT 16]

Proc CoolControlDialog_AdjustDataTabSize:
    Arguments @Handle, @nIDDlgItem, @hWndPage, @Rect
    Local @TabHandle

    pushad

    call 'USER32.GetDlgItem' D@Handle, D@nIDDlgItem
    mov D@TabHandle eax

    mov esi D@Rect
    call 'USER32.GetClientRect' D@TabHandle, esi
    SendMessage D@TabHandle, &TCM_ADJUSTRECT, &FALSE, esi
    mov eax D$esi+RECT.leftDis
    mov ebx D$esi+RECT.topDis
    mov ecx D$esi+RECT.rightDis
    mov edx D$esi+RECT.bottomDis
    sub ecx eax
    sub edx ebx
    call 'USER32.SetWindowPos' D@hWndPage, 0, eax, ebx, ecx, edx, &SWP_NOZORDER

    popad
EndP
____________________________________________________________________________________________
____________________________________________________________________________________________

; ToolBar Controls
____________________________________________________________________________________________
____________________________________________________________________________________________

[NM_LISTVIEW.hdr.hwndFromDis 0
 NM_LISTVIEW.hdr.idFromDis 4
 NM_LISTVIEW.hdr.codeDis 8
 NM_LISTVIEW.iItemDis 12
 NM_LISTVIEW.iSubItemDis 16
 NM_LISTVIEW.uNewStateDis 20
 NM_LISTVIEW.uOldStateDis 24
 NM_LISTVIEW.uChangedDis 28
 NM_LISTVIEW.ptAction.xDis 32
 NM_LISTVIEW.ptAction.yDis 36
 NM_LISTVIEW.lParamDis 40]

;;

    CoolControl_ListViewAlternateSort
    
    This function reorganizes (sorts) each one of the columns on a ListView Control. 
    
    Parameters:
    
        hLView:         Address of a Sort function where the user defines how each one of the ListView itens is displayed.
        
        Notification:   Pointer to the Notification message handle (lParam, for example)
                      
        SortItem:       Address of the Buffer responsable for the Sorting Itens
        
        hList:          Pointer to the handle of the ListView Control.
        
        LViewNumber:    Total amount of Columns used on the listview.


    Returned values: This function does not returns any value.

    Usage Example:
        call CoolControl_ListViewAlternateSort ListViewSort, D@Notification, SortDecimal, D$hCharMapList, 5    

    Note: The functionality of this function is exactly the same as if we defined each listview item by hand, like
          if when we have, for example 5 itens (columns) on a listview, defined as:
          
                .If D$ebx+NM_LISTVIEW.iSubItemDis = 0 ; decimal
                    call AlternateSorting ListViewSort, SortDecimal, D$hCharMapList, 1, 2
                .Else_If D$ebx+NM_LISTVIEW.iSubItemDis = 1 ; hexadecimal
                    call AlternateSorting ListViewSort, SortDecimal, D$hCharMapList, 3, 4
                .Else_If D$ebx+NM_LISTVIEW.iSubItemDis = 2 ; Char
                    call AlternateSorting ListViewSort, SortDecimal, D$hCharMapList, 5, 6
                .Else_If D$ebx+NM_LISTVIEW.iSubItemDis = 3 ; Count
                    call AlternateSorting ListViewSort, SortDecimal, D$hCharMapList, 7, 8
                .Else_If D$ebx+NM_LISTVIEW.iSubItemDis = 4 ; Percent
                    call AlternateSorting ListViewSort, SortDecimal, D$hCharMapList, 9, 10
                .End_If          
;;

Proc CoolControl_ListViewAlternateSort:
    Arguments @hLView, @Notification, @SortItem, @hList, @LViewNumber
    Local @InitValue, @NextValue

    pushad

    mov ebx D@Notification
    mov edx D$ebx+NMHDR.idFromDis
    mov eax D$ebx+NMHDR.codeDis

    mov D@InitValue 1
    mov D@NextValue 2

    mov ecx 0 ; Column Counter. Always starts at the 1st column.

    .While ecx <> D@LViewNumber
        If D$ebx+NM_LISTVIEW.iSubItemDis = ecx
            call AlternateSorting D@hLView, D@SortItem, D@hList, D@InitValue, D@NextValue
            jmp L1> ; Once we identify wich column we are working with, we go out of the loop
        End_If
        inc ecx
        add D@InitValue 2
        add D@NextValue 2
    .End_While

L1: popad
EndP
________________________________________________________________________________________

Proc AlternateSorting:
    Arguments @hLView, @SortItem, @hList, @InitValue, @NextValue
    pushad

    mov edi D@SortItem
    If D$edi = &FALSE
        call 'USER32.SendMessageA' D@hList, &LVM_SORTITEMS, D@InitValue, D@hLView
        call Resequence D@hList
        mov edi D@SortItem
        mov D$edi &TRUE
    Else
        call 'USER32.SendMessageA' D@hList, &LVM_SORTITEMS, D@NextValue, D@hLView
        call Resequence D@hList
        mov edi D@SortItem
        mov D$edi &FALSE
    End_If

    popad
EndP

________________________________________________________________________________________

Proc Resequence:
    Arguments @hList
    Structure @lviResequence 40, lviResequence.imaskDis 0, lviResequence.iItemDis 4, lviResequence.iSubItemDis 8, lviResequence.stateDis 12, lviResequence.stateMaskDis 16, lviResequence.pszTextDis 20, lviResequence.cchTextMaxDis 24, lviResequence.iImageDis 28, lviResequence.lParamDis 32, lviResequence.iIndentDis 36

    pushad

    call 'USER32.SendMessageA' D@hList, &LVM_GETITEMCOUNT, 0, 0
    mov edi eax
    mov D$lviResequence.imaskDis &LVIF_PARAM
    mov D$lviResequence.iSubItemDis 0
    mov D$lviResequence.iItemDis 0

    While edi <> 0
        push D$lviResequence.iItemDis
        pop D$lviResequence.lParamDis
        call 'USER32.SendMessageA' D@hList, &LVM_SETITEM, 0, D@lviResequence
        inc D$lviResequence.iItemDis
        dec edi
    End_While

    popad

EndP
________________________________________________________________________________________

;;

    CoolControl_LVBeginSort
    
    This function initializes the sorting state reorganizes (sorts) each one of the columns on a ListView Control. 
    
    Parameters:
    
        hLView:         Address of a Sort function where the user defines how each one of the ListView itens is displayed.
        
        SortItem:       Address of the Buffer responsable for the Sorting Itens
        
        hList:          Pointer to the handle of the ListView Control.
        
        InitValue:      Initial value of the item the user wants to start first. If the user wants to 
                        start sorting biased on the 1st column (value = 0), theInitValue is equal to 1.
                        If it is biased on the 2nd column, the initvalue is 3.
                        If it is biased on the 3rd column, the initvalue is 5
                        If it is biased on the 4th column, the initvalue is 7, and so on.
                        
                        Note: By default, the InitValue should be settled to 1.

    Returned values: This function does not returns any value.

    Usage Example:
        call CoolControl_LVBeginSort ListViewSort, SortDecimal, D$hCharMapList, 1

;;

Proc CoolControl_LVBeginSort:
    Arguments @hLview, @SortItem, @hList, @InitValue

    pushad
    call 'USER32.SendMessageA' D@hList, &LVM_SORTITEMS, D@InitValue, D@hLview
    call Resequence D@hList
    mov edi D@SortItem
    mov D$edi &TRUE
    popad

EndP


































































TITLE ToDo

;;
____________________________________________________________________________________________

What is this strange 'MemSaveFilter'?
____________________________________________________________________________________________

In some cases of RegistryData modifications, it may be corrupted.
____________________________________________________________________________________________

il manque la fonction clic droit sur les API terminées par W.

____________________________________________________________________________________________

NOPE addition on case of "empty" Macro Evocation: File with:

RosAsm/Ludwig/Noname.exe and debug_me.exe

Needs a re-organization of the Macros jobs, with intermediate copy of one Statement.
____________________________________________________________________________________________

Disassembler: Win32Dasm. At 040796E, there is a list of Pointers. Internaly, the
first one should be Flagged Code, and not Data.
____________________________________________________________________________________________

Disassembler: One Export may have severl Names Exported. Example:

        MyAdvapi32.dll: BuildExplicitAccessWithNameW / A

'WriteExportedFunctionLabel' needs another loop somewhere.
____________________________________________________________________________________________

For Guga:

Dllscanner Tool: It fails showing all Imports on WZCAB.DLL (in the [Disassembled] Folder).
____________________________________________________________________________________________

Review all EBX preservations, from 'Dis_rm8_r8'

____________________________________________________________________________________________

Review the Strings analyzes in the Disassembler. Some 9, 10, 13, are replaced by
Space, when isolated (should be the reverse).
____________________________________________________________________________________________

>     mov D$eax+0BC   ; ----------------> Here missing the register. It 
> should be mov D$eax+0BC es
>     mov D$eax+098 ds
>     mov D$eax+094 ss
>     mov D$eax+090 ss
>     mov D$eax+08C cs
>     mov D$eax+0C8 cs

!!!!!!!!!!!!!!!!!!!!!!!!
____________________________________________________________________________________________

Search for (OpD1) PFMUL 3D Now.
____________________________________________________________________________________________

Extend the "Right-Click on Numbers" Functionalities (FPU? Signed Values?...)
____________________________________________________________________________________________


nop  ; <<<<<<<<< Error manager pointing here, because of the Duplication of
     ; 'SIZEOF_materials'

DeclareTable materials 1 1 SAMPLE_Material.size

[sizeof_materials 34]
[DeclareTable| {SIZEOF_#1 #2  SIZEOF_#1_CHUNK #3   SIZEOF_#1_ELEMENT #4}]

Main: call 'Kernel32.ExitProcess'

____________________________________________________________________________________________

I didn't realise that Q$ is only used for integers.
Maybe an entry into B_U_Asm along the lines of Scarmatil's explanation would be
appropriate?
____________________________________________________________________________________________

From 'MAXDIALOG', and friends... Make it all Dynamic as soon as possible.
____________________________________________________________________________________________

When setting a bp, the caret moves to that line.
Should not happen.
____________________________________________________________________________________________

Clip File:

Review the Doc.
____________________________________________________________________________________________

Disassembler: Looki Report, in ...\Eudora\Attach\Looki.

The last Point is a real miss-interpretation.
____________________________________________________________________________________________

'DeleteIcon':

Looki says it is possible to have left over data after removal. to be Reviewed.

____________________________________________________________________________________________


fnstv D$eax sbb D$eax <<< RightClick SBB eax 'OpCodeList' / 'SearchMneMonic'

____________________________________________________________________________________________

Linux-LINE: Chuck reports:

> As it turns out, there is a problem with the debugger. Wine handles the
> KERNEL32.VirtualQueryEx call with its NtQueryVirtualMemory routine, and
> returns "Unsupported on other process", causing the debugger to display
> "VirtualQueryEx reported error".
____________________________________________________________________________________________

[list - tree/import/export] Not assuming anything but CALL '...'.
____________________________________________________________________________________________

Error-Box with Copy&Paste enable.
____________________________________________________________________________________________

Error Message window:
It should be possible to copy text from the edits.
There should be no cursor.
The window should be fixed. Not sizeable. 
____________________________________________________________________________________________

2. There is a cursor in the error message window, and it is possible to read and write inside the EDITs.
What for? It's funny...
____________________________________________________________________________________________

Code Completion:
When RosAsm can't find the equate, a messagebox pops and asks if you want to build a list, and takes the focus from the Editor.
This is a VERY annoying way to tell you that you mistyped an equate.
It has do be done maybe like that:
* If matched completion found, underline (and bold?).
* when no longer matches, remove the line (or if choosed to bold, unbold?).
* If the last chars were deleted and it matches again, put the underline back.
For example:
&CW_USED
&CW_USEDEDAU
&CW_USEDE
and the option to build the list will appear... (sorry, no idea. maybe as text telling you that it's optional in the main menu).
It can't remain like that.
What do you think?
____________________________________________________________________________________________

B_U_Asm Selection should not reload the actual page.
____________________________________________________________________________________________

We have found out one user not understanding the Cnfiguration Dialog Tab:

>>> ToDo: Make the [Companion Files] Tab the first open one.
____________________________________________________________________________________________

Is the Header KILLFALGed?

____________________________________________________________________________________________

 Disassembler: With the Tests DLL, the Exported Names are wrongly two Byte backwarded.

____________________________________________________________________________________________

A user reports having seen a hang at:

>Proc DataView_FillDataLabelCombo:
>    Arguments @ComboHandle @SortByName
>
>    SendMessage D@ComboHandle, &CB_RESETCONTENT, 0, 0
>    move D$DataLabelComboHandle D@ComboHandle
>
>    mov esi D$PlainLabelList
>    lodsd ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

... which is quite "strange"...

____________________________________________________________________________________________

>- dans RosAsm (je sais pas si c'est toujours le cas) me semble
>que quand on sélectionne replace source, il ne travaille plus
>sur le fichier initialement chargé mais sur l'exe correspondant
>au .asm chargé. Moi j'aurai plutôt vu qu'il remplaçait le source
>et c'est tout. (pour open source only, là je suis d'accord qu'il
>le fasse par contre)
____________________________________________________________________________________________

'OpA3': "mov D$FS:0, eax", with 0 in Word form >>> Other cases.

____________________________________________________________________________________________


Review the 'IsItCode' tuning, from the 'IsItNoReturnCall' comments.

____________________________________________________________________________________________

Implement a PUSHW for pushing imm 16 with negative cases assumed.
____________________________________________________________________________________________

Review 'CheckBracketExpression'
____________________________________________________________________________________________

In 'AnalyzeOfCmParameter' study the possibility of branching Imm reals, from the
'memMarker' Case
____________________________________________________________________________________________

Try to improve the Blocks saving, and to separate into some isolated Folders.
Mabe depending on a Time&Date Stamp.
____________________________________________________________________________________________

once RosAsm has tried to install, and failed to,
even if the the "RosAsmFiles" Folder is copied aside, with all required
Files, it does not try to Auto-Install, the way it does, at the very
first try.
____________________________________________________________________________________________

Review the 'CompileErrorHappend' Flag (not always effective, and does not work for
the last Dialog of the Unfolder (wishable to not show an empty bow after error),
at the end of 'UnfoldMacro'
____________________________________________________________________________________________

With some Selected Blocks (ex: Double-Click), the ScrollBar does not work.

____________________________________________________________________________________________

Name001
Name002
Name003
Name004

utiliser :

Remplace Name par EQUATE_Name (par exemple)...

____________________________________________________________________________________________

> In most schemes, you can define a macro called "at-compile-time" which
> will do calculations at compile time.  So, we could do:
> 
> (define sqrt-table (at-compile-time (list->vector (map (lambda (x)
> (sqrt x)) (range 0 500)))))

____________________________________________________________________________________________

In "Proc @ReplaceEquate:" don't forget to tell Ludwig to do:

call GetFromQwordCheckSum esi, D$EquateList, D$EquateListLimit

____________________________________________________________________________________________

Il me semble que dans un source utilisant les TITLES, si une erreur de type :
"Symbol ne correspondant à aucun label" pointe vers une page différente de celle
où tu te trouves quand tu refermes la fenêtre de message d'erreur tu ne te retrouves
pas sur l'erreur comme d'habitude...

; -----------------------------------------------------------

In 'WriteFloatingPointOperationCode'

...Test_If_Not_And bx FloatingPointOperand, dx FloatingPointOperand
;...

..Test_Else_If_And bx ConstantOperand, dx ConstantOperand
       ; mov eax merde
            EPP_Code '{??:R$ #1}|FLD R$?|{??:R$ #2}|FLD R$?|' | 
        mov eax merde

The error Manager seesm to be perverted by this "EPP_Code" Macro

As the same Macro is Evocated upward, can is be something inside
the String, when parsing Conditional Macros (???!!!...), or can
it be something wrong in the ParaMacros Parser (???!!!...).

What relationship with the Statements Counter?

____________________________________________________________________________________________

Tools -> Configuration -> Help Files

Serait-il possible de d finir le r pertoire courant comme r pertoire par d faut et d'attribuer au diff rents chemins d'Help :
RosAsm\RosAsmFiles\xxxxx.xxx si ils sont pr sents.
____________________________________________________________________________________________

Wish list: 

- Remember the width of the debugger window. 

- Make the Edit functions works while using multiple instances of RosAsm, or at least an option to not show the "You are running multiple instances of Rosasm"... box. 

- For new files ask for the name of the exe the first time it compiles and not before. 
- and for the "New File" box allow user-defined templates for new files. Or a menu item called "New from template". 


Also, and most important: 

- Error in B_U_Asm > Mnemonics Ref: In Strings_Op and List_All_Op, MOVSD incorrectly links to the SSE mnemonic. And in SSE_Op, MOVSD is missed. 

- Limitation: Deleting all String resources in a PE is not allowed. 

____________________________________________________________________________________________

A short lesson in Correct code benchmarking:

CLI        ;not yet  
CPUID      ;or any other serialising
RDTSC
...        ;store edx:eax
test:
...        ;code to test (no loops here, execpt if part of test)
RDTSC      
STI        ;if 
...        ;sub edx:eax,[stored]
           ;sub 11 (the time for one RDTSC)
result in edx:eax, and that's the only true figure.


____________________________________________________________________________________________


'OQregRegImm8'

to do List:

Hello Betov, 

Your quite right in doubting the mnemonic for 

1) pextrw 

mov al B$SecondReg | shl al 3 | or al 0011_000_000 | or al B$FirstReg 
should be 
mov al B$FirstReg | shl al 3 | or al 0011_000_000 | or al B$SecondReg 

2) pinsrw - though there's an error in the doc's we've got this one right. 

3) movm$kps - this one doesn't seem to work the way they've described, 
possibly been corrupted by microsoft and friends... :) :) :) 


Werewolf
____________________________________________________________________________________________

In 'WriteMacroVariable', i comment out the 5th line, without recalling why i wrote
this, previously (it was for the Conditional macros, anyway, but it seems to work
the same without... Wait and see...)

Also to be reviewed, in 'ReplaceFromMacroData', after the 'call StoreMacroVariableByNumber',
the 'NOPE' output should probably not be there, but after the 'call WriteMacroVariableByNumber'
Seems out of logic...
____________________________________________________________________________________________

For Debug Tool-Tips: keep the Equates List alive the same way as the CheckSum Table,
so that the Expression could be parsed?

How to re-Encode? What of the Label?

____________________________________________________________________________________________

Add an error message for Macros stripping the last String Delimiter.

____________________________________________________________________________________________

Encode / Decode Box does not parse the Win32 Equates.

____________________________________________________________________________________________


If you really want me to report the small errors, I will of course start 
doing this. But, as I can fully happily edit all my templates, and my 
apps, to my heart contents with RosAsm, at no problems in 99.9% of cases, 
I do not figure these small details to be important.

As it is to me, a much greater irritant, to use the working windows OS 
menues, than to use a RosAsm that has some rare crash states. Dont know if 
you found the SHIFT+DELETE problem yet. Sometimes, it seems to accumulate 
an error that makes the REPLACE function misbehave.

If I reset RosAsm, by a restart, the REPLACE function works correctly, but 
after some time using it, the replacement function can replace more than 
the exact number of chars. Sometimes it means that a SPACE is added so 
that when I use labels like Button.Close , and I want to replace it with
SkinButton.Close, I end up with SkinButton .Close (which does not compile).

I try to make a list from now on, and post it each week.

But theese small problemes with RosAsm has workarounds, that I use 
instead. For instance, I rarly need the replace functions, so when I do, I 
save, and exit, and restart, because I know it works perfectly then.

____________________________________________________________________________________________

I remember trying to find this in RosAsm's source (long ago) but I couldn't fix it .
Perhaps you could try calling LoadLibrary explicitly with the full path
c:\path\to\program\LibraryToLoad.dll?
It is obvious that there's something funky with setting the current directory.
Btw, I'm also using XP.

____________________________________________________________________________________________


SSE3 Instructions:

FISTTP  DF /1 FISTTP m16int
FISTTP  DB /1 FISTTP m32int
FISTTP  DD /1 FISTTP m64int
LDDQU
MOVSHDUP, MOVSLDUP, MOVDDUP
ADDSUBPS, ADDSUBPD
HADDPS, HSUBPS
HADDPD, HSUBPD
MONITOR
MWAIT

____________________________________________________________________________________________


>@ PI2FW  AMD 3Dnow Packed Integer Word to Floating-Point Conversion-  0Fh 0Fh / 0Ch
>                   - Found in Disassembler ONLY


____________________________________________________________________________________________

What i can do, is, in case of overflow error, go on checking up to the end, so that, 
in case of trailing specifier, it could forward it to the appropriated Routine.

Done for 'TranslateDecimal'.
____________________________________________________________________________________________

Review the BitMap Types. Example, Cursor sizes.
____________________________________________________________________________________________

After the new release of ludwig Debugger (coming after V.2.007d), recall of
the problem of TD_170Graph Demo, that aborts, when trying to Load/Save a File.
____________________________________________________________________________________________

si tu tapes "b tement" &NUL au lieu de &NULL dans un source en contenant plusieurs, 
l'erreur point e est incorrecte :

&NUL

Unknown Win equate name

Certes, mais le saut dans le code se fait, apparemment, sur la premi re  vocation et non sur l'erreur.
____________________________________________________________________________________________

le clic droit sur les appels Api fait appara tre une fen tre "Api call infos" qui
n'est plus redimensionnable. Le probl me est que dans plusieurs cas la largeur 
n'est pas suffisante pour afficher tout le contenu sans retours   la lignes qui 
rendent confus et mal ais  la lecture...

____________________________________________________________________________________________

If the selection is not 3 line after the TITLE, in Search Functions, it is not
shown, because of the pos computation.
____________________________________________________________________________________________

>Apr s un test de d sassemblage d'une petite application utilisant
des TrackBars (r alis e avec RosAsm) tout le code est correctement
>restitu  mais il manque le :
>
>Call 'COMCTL32.InitCommonControls'

____________________________________________________________________________________________


>ici, avec PREPARSE Equal
>
>eax  = 0-32768 produit une erreur
>eax = -32768 produit une erreur
>eax = (-32768) ne produit pas d'erreur
____________________________________________________________________________________________

Hugin/ Nessie/ Nessie.asm: Problem of error not pointed out on Bad Dec. because
of the Dash-Lines considerations, to be implemented, first, into the [Search] Box.
____________________________________________________________________________________________

'LenghtOfBracketStatements' is bad since the modification of the Local Labels
expansions. Used only in 'SearchForApis'. Maybe not worthy the complication...
____________________________________________________________________________________________

For me personally, it would be good if we could configure code completion to match
after a certain, userselectable char. Or maybe match in the whole string ? I write 
"Application.WMSize" or "Application.WMMove", or "SkinSection.GetVisible" or 
"SkinSection.SetText". So code compeltion is a bit useless to me. If I could write 
"WMS" and RosAsm suggested : Application.WMSize, then code completion would be 
_very_ useful. 

And also if matching more than one identifier, the list could be cycled by just 
pressing CTRL+SPACE a second time, or third time. 
____________________________________________________________________________________________

Disassembler: 'NamedIdSubstitution' is wrong with MASM ShowDib2 Demo
____________________________________________________________________________________________

There is a issue in rosasm with local label calls:

Proc DoThis:
 ;code
 call @locall; DoThis@locall
 ;code

Endp
@locall:
 ;code
 ;code
ret

Proc DoThat:
 ;code
 call @locall; DoThat@locall
 ;code

Endp
@locall:
 ;code
 ;code
ret

The code works as espected.
The issue is with right click and tree navigation tools: They go to the  
first label always. Tree shows calls to locals sometimes as childs (as  
must be) but sometimes as orphans.
____________________________________________________________________________________________

[IMAGE_SECTION_HEADER:]
[Name1: B$ 0 #&IMAGE_SIZEOF_SHORT_NAME]
[MiscPhysicalAddress: MiscVirtualSize: D$ 0
 VirtualAddress: D$ 0
 SizeOfRawData: D$ 0
 PointerToRawData: D$ 0
 PointerToRelocations: D$ 0
 PointerToLinenumbers: D$ 0
 NumberOfRelocations: W$ 0
 NumberOfLinenumbers: W$ 0
 Characteristics: D$ 0]

[Name1Dis 0
 VirtualAddressDis 1
 SizeOfRawDataDis 5
 PointerToRawDataDis 9
 PointerToRelocationsDis 13
 PointerToLinenumbersDis 17
 NumberOfRelocationsDis 21
 NumberOfLinenumbersDis 23
 CharacteristicsDis 25]
 
____________________________________________________________________________________________

Is the 066 Prefix whishable or not for the encoding of ARPL ???
 
____________________________________________________________________________________________

add a [Save all TITLEs as Asm Files] in the [Ctrl] [S] feature Dialog
____________________________________________________________________________________________

Resize the Choose Menu Dialog at 90% of the Screen Width.
____________________________________________________________________________________________

Reuse the Trash1/2 Buffers everywhere possible.
____________________________________________________________________________________________

Add a Warning Edit Control in the Statistics.

When Building .Import, with calls to Comctl32.dll, verify that InitCommonControls
is called. If not, output a warning Message.

See: 'StoreDllName' >>> After the .Import is built, search for COMCTL32.
Found >>> Search for in InitCommonControls in 'ApiListB'.
____________________________________________________________________________________________

The "Peter Ctrl-Z" Bug has been fixed by implementing a security in the 'TextPos'
Routine >>> Rewrite all of the Ctrl-Z Functionalities from scratch when possible.
____________________________________________________________________________________________

Titles after failure of a Disassembling attempt >> Todo List
____________________________________________________________________________________________

Extend the sensitive area of Blank-Right-Click in the four directions.
____________________________________________________________________________________________

Redifine the 'FloatToUString' with Ludwig. ecx is not preserved.
____________________________________________________________________________________________

Is there a limit to the Data Alignment ([<??? ...) ? Is there a validity check for
the Number ?
____________________________________________________________________________________________

In the search/Replace Dialog the Tab-Key will not work properly,
the focus will set only on the selected radio button and can only moved with the arrow keys
____________________________________________________________________________________________

It would be very good to have more files in the MRU list, 
perhaps user- defined in the config setting?
____________________________________________________________________________________________

Implement a Table Switch for Strings Recognitions Table (for foreign languages).
____________________________________________________________________________________________

add a Routine to verify that (in Data) a Pointer does not break a pointer.
Examples in the Disasembly of Guga H2INC.
____________________________________________________________________________________________

Re-Assembling C:\ProgramFiles\... '7zFM' and '7zFM' hangs in 'ResetForNewBrackets'. 
A missing Bracket undetected problem.

To fix: Borbid any use of '?' in Code.
____________________________________________________________________________________________

lea al B$esi ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
____________________________________________________________________________________________

Old: Dialog Editor: The Child Style is broken when re-organising a set of Dialogs 
 (insertion of a new Dialog in a List of Dialogs with ID modified >>> WS_POPUP.
 
 Something is wrong in Dialog Editor. Mouse Pointing to the various Controls inside
 [Other Files] Configuration Tab... This seems to be a problem with Group Boxes.
 
 To be verified first: Where must the Group box be in the Z order, in order to enable
 groups of Radio Buttons to work by themselves. JohnFound said, by placing the Group
 Box *after* the Radio Buttons... (???...).
 
 
 --------------
 
 Answer from Wilhelm Zadrapa:
 
 The Group Box must have the WS_GROUP style.

 The controls after that box, up the the next WS_GROUP style are part of the group.
 
 --------------

Dialog Editor:

* Sort the Dialogs each time we leave the Resources Editor.

* When Loading the Debugger's Dialogs Files, problems:

- Child Style not preserved (!!!???...)

- The is a bug outputing weird char(s) in the Class Record.
____________________________________________________________________________________________

Simplify 'IsItaLabel' and 'StoreBookMark': Store the Label to be BookMarked,
in all cases, to a renamed 'LocalBookMark'.

____________________________________________________________________________________________

Yes, Bookmarking Local Data Labels is not implemented. I never though of it, but this is,
evidently, a must have.

"Number forms"... EditControl, for easy copy paste... Yes.


____________________________________________________________________________________________
____________________________________________________________________________________________



; (8 ) 

How come this is not ok? 

Code:



[Label: ? #50 
 EndOfLabel: ?] 
mov ecx EndOfLabel-Label ; Unable to resolve this parameter 
mov ecx (EndOfLabel-Label) ; Immediate only in expressions

____________________________________________________________________________________________

Add a content Checking in the Function for loading a .dlg (not a RosAsm File > Abort).

____________________________________________________________________________________________

When creating a drop-down combo box in the dialog editor, it will not allow you to select the &CBS_DROPDOWNLIST flag - clicking this will only select the &CBS_DROPDOWN flag. 
____________________________________________________________________________________________

Rewrite 'RightClick', 'InternalRightClick', 'InternSearch'. More modular, more actual
Style.
____________________________________________________________________________________________


 To be verified:
 
 When parsing the Sources, there may be a problem with Comments vs MLC, that is:
 
 When skipping Comment it must stop at CR, not at LF, as this might eat a following
 MLC.
____________________________________________________________________________________________

i try to compile your 06midi sample and
it give me this message.
Orphan colon encoun....
at Proc Midi Stream.
Is it bug or something is change the 
assembler?
____________________________________________________________________________________________


____________________________________________________________________________________________


____________________________________________________________________________________________

 
____________________________________________________________________________________________

review the upper char in Clip operations.
 
____________________________________________________________________________________________

 
____________________________________________________________________________________________

What is this:

; 1 = My MF_POPUP substitution.

Example in 'ResetThisMenuIDs', 'TurnThisMenuToExType'. Why did i substitute 1 to 010 ?
____________________________________________________________________________________________

 
 
 Do not send an error message for Api call by number with same Number in two different
 DLL. Force DLL Name for such calls.
 Disassembler, set the Jumps Table Labels' Names in the form of: "DllName0xxx:"
 
 PMULLW > (done)

____________________________________________________________________________________________

'ResetForNewBrackets' diserves a complete rewrite
";!!!!!!!!!" was the thing that made 'Base3 Uses' (without any parameter) hang. I turn it:
"jae L9>>", but i don't understand what the comment means (!!!...). The hell!
 
____________________________________________________________________________________________


____________________________________________________________________________________________


____________________________________________________________________________________________


____________________________________________________________________________________________

____________________________________________________________________________________________

default icon might be removed from the PE
____________________________________________________________________________________________


____________________________________________________________________________________________

 
____________________________________________________________________________________________

 Occasional Problems with Registry Modifications. Is it possible to directely 'refresh'?
 (Delete // re-Create)?

____________________________________________________________________________________________



____________________________________________________________________________________________

In Iczelion 31ListView.exe:

WIN32_FIND_DATA

[WFD_cAlternate: B$ 0 #14] hangs (in Find File Functions), under 2000, with long Names.
____________________________________________________________________________________________

 
error in the Dx Demo:

I think i found a very serious Errors in (RosAsm414b version). i using this macro

[DxCall | mov eax D$#1 | mov eax D$eax | call D$eax+#3 D$#1 #4>L]

when i write this code ( DxCall lpdd '->' Release) , by unfolding or showing in Debuger
it looks so: 

mov eax D$lpdd 
mov eax D$eax 

where is the rest!!! > ; that's because there is no fourth Parameter !! 

instead i use this one:

[DxCall | mov eax D$#1 | mov eax D$eax | push #L>3 | push D$#1 | call D$eax+#2]

____________________________________________________________________________________________

____________________________________________________________________________________________

    
____________________________________________________________________________________________

 
 Long Jumps optimized to short, when possible by Configuration Flag???...

____________________________________________________________________________________________
 
 
 Namings Check on [Include].

 implement a Memory remaping instead of 1 Mega Limit.
 
 ____________________________________________________________________________________________
 
 
 Scrolling text horizontally sucks
 
 By the way, i don't know how the Errors Manager deals with Run-Time errors
 in DB... I'll have to take a look at this... (To-Do List...)

____________________________________________________________________________________________
____________________________________________________________________________________________

 
 Unify ProgressBar creations, scaling, destructions. 
 
______________________________________________
 
 >[Data: DD 0] , without PREPARSE alternate >>> error pointing to the very first 'D' in
 the Source (!!!) (unknown symbol in 'BuildRelocationAndFillSymbols')... So, revue the
 way the Error Management in that computing search for the faultive Statement.
 
 General clean up of the Sources Editor needed. For example, 'StripBackSpace' is no
 more of any use. 
 
 Follow up with Jonne about Prefetch. 
 (Commenting out "cmp B$EregInside &TRUE | je L1>"  OK ???).
 
 File name when loading .asm!!!! Whishable to change? Without Title... yes...
 
 Bug inside the User Menu definition: Only the first Item was effective. Set *all*
 Paths to &MAX_PATH.
 
 Tree View: suppress the reduce Button in the bar, when runing in Auto-Hide Mode.

 Turn all Api calls into Macros, and store all system calls in one [System] TITLE.

 'DebugActiveProcessStop' >>> Download a more recent Win Help...
 
 Might hangs on upload of a non RosAsm written PE. Maybe the concerned PE did got a '.scr'
 section... See this next time.

 May hang when loading sources with broken resources.

 
 To do???: turn [ ... | ... #1>L | ... | #+1] possible. Actually, only #1, #2,...
 can be rolled.

 Problem with CreateDialog... vs DialogBox... Exit does not behave as Win Doc says.

 We could have a 'ReDo' feature if commenting out the 'ClearNextUndoRecord' call in
 'ControlZ' (keep one for the 'TitleMoveFlag'), and implemeting a 'ControlShiftZ' Routine.

 Add something for Extended Styles in the Dialog Editor. Usefull, for example
 for having a ToolWindow Style Dialog, without modifying in Init.

 In the Dialog Editor: Save to ClipBord >>> turn Styles into Win Equates expressions.

 Reset the overall -general purpose- Comments at Top of each TITLE Parts (partially done).
 
 DLL without anything to Reloc > RelocSize = 8 !!!!!!!!!!!!!!!!! (seems to work OK).
 May be this is even required by the OS (it seems to effectively be required).


__________________
 
 The Api Function calls by Numbers seems wrong in the Disassembly.
 

Disassembler Menus: Menu of Win32Dasm incomplete.
 
____________________________

Add a 0 to 9 UpAndDown Control in the Structure Dialog for multiple Structures.

Re-Write the DkStructures.rtf. Add Examples with Equates forms.

compatible symb.table for external Debuggers

____________________________

The 'EditDialogBoxProc' organisation is now unreadable. An important enhancement
should be done with implementing a Tab Control, under the Main List Box. This Tab 
should say [Style][Dim][ID/Menu][Class][Title][Font/Cdata]. Then, Holding the Tab
Index would much simplify and organise the holding of incoming Messages from the 
various Definitions Controls.

Add the Extended Styles. Search first for what Extended Styles may be coming
with the controls. (Even unsure for the Dialog...). Limit to the ensured ones.

Rewrite, in B_U_Asm [Editors][Dialog_Editor], because the guys do not understand
why some things available in RadAsm are not made available in RosAsm Dialog Editor,
Explain the 'MustHaveBitTable', and the 'ExcludeBitTable' implementation (it
seems nobody noticed this... :().

____________________________________________________________________________________________
____________________________________________________________________________________________

In Asm32Tuts:

Strings: Description / Cases / Endings // Length // Searches //
Copying // Pasting / manipulation.
__________________

 Re-Write C_To_Asm, as HLL_To_Asm. Memory / Pointers / Data / Constructs / Size vs Types
 ...

____________________________________________________________________________________________
____________________________________________________________________________________________

Main Implementations to be entirely done:

* HLL Parser(s). -Non Assembly syntax- . Anybody can do it. A Start point is at 'NewParser'.

* OOA Parsers. -Non Assembly syntax- . Experiment a "Couple of hours" tasks managment.

* Conditional Assembly. Start point at 'MacroWithIf'.

* Version Info Resource. I do not know what this Resource is, physically, but there is
  a description in GorC Resources Compiler Manual.

* Code symbolic Profiler. Only me can do do it.

* Source Ripper. Only me can do it.

* Wizards. (Visual Editors sets, in a DLL, for ToolBars, all Windows Types, from simple
  Buttons to MDI Editors, the various readers and players,... ). Anybody can do it. As
  soon as a volunteer raises his hand up for one of these, open a [User Project] for the
  Wizard Collection, at the Board.
  
* Flirt recognition in the Disassembler. Download and study IdaPro and Dede Disassemblers
  first...
  
* Implement ROS Drivers output. First, find the NT Drivers specifications.
  - They are PEs, but, for example, NT KeyBoard.sys seems a raw Binary.
  - How many Types of Drivers? What .ext?
  - 'PeHeaderCharacteristics' should have something specific.
  - 'ImageBase' ?
  - What Entry Point organisation?
  - What developements rules?
  - What Sections?
  
* A new tool would be great for 'tracking' a Variable. Example, after xxx modifications
  of the Assembler, when fixing a bug inside 'StoreVirtualData, i don't remember what i 
  am doing with 'D$DataListPtr''. The question i wish the answer to is: "Do i make any 
  use of this Variable *after* this given point of the Computation? If yes, where?".
  I think i don't use any more this Variable downward, but, if i turn it zero, nothing
  works... So, i must use it somewhere... Maybe 're-use' for something completely 
  different, that would better require another name...
  
  I imagine an added Double-Click Menu Option saying [Track] and outputing something 
  like a Tree-View of the outines making use of it. It should work the same way for Labels
  (Data and Code), Equates and Macros, and would be great for restructuring, renaming,
  and so on. May be, simply the existing Tree-View, but with the concerned Routines 
  written in Red, or something like this.













































































































































































































































































































































































































